{"sha": "2f2c438dce75d8cc532c3baa849eeddc0901802c", "node_id": "C_kwDOAAsO6NoAKDJmMmM0MzhkY2U3NWQ4Y2M1MzJjM2JhYTg0OWVlZGRjMDkwMTgwMmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-08T21:00:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-08T21:00:50Z"}, "message": "Auto merge of #111358 - compiler-errors:rollup-yv27vrp, r=compiler-errors\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #104070 (Prevent aborting guard from aborting the process in a forced unwind)\n - #109410 (Introduce `AliasKind::Inherent` for inherent associated types)\n - #111004 (Migrate `mir_transform` to translatable diagnostics)\n - #111118 (Suggest struct when we get colon in fileds in enum)\n - #111170 (Diagnostic args are still args if they're documented)\n - #111354 (Fix miscompilation when calling default methods on `Future`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "fa7ed639cbffe04f276031f2a76221f91aae56f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa7ed639cbffe04f276031f2a76221f91aae56f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f2c438dce75d8cc532c3baa849eeddc0901802c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2c438dce75d8cc532c3baa849eeddc0901802c", "html_url": "https://github.com/rust-lang/rust/commit/2f2c438dce75d8cc532c3baa849eeddc0901802c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f2c438dce75d8cc532c3baa849eeddc0901802c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfe31889e10e36eed53327d1ca624fbf21b475a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe31889e10e36eed53327d1ca624fbf21b475a5", "html_url": "https://github.com/rust-lang/rust/commit/dfe31889e10e36eed53327d1ca624fbf21b475a5"}, {"sha": "bbea63f627433eb00ef9ac235bcced35e4cfbd4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbea63f627433eb00ef9ac235bcced35e4cfbd4c", "html_url": "https://github.com/rust-lang/rust/commit/bbea63f627433eb00ef9ac235bcced35e4cfbd4c"}], "stats": {"total": 2551, "additions": 2066, "deletions": 485}, "files": [{"sha": "cd665f6e7d95f96cf974f86c3b889e7085405502", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -3353,6 +3353,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_mir_build\",\n  \"rustc_mir_dataflow\",\n+ \"rustc_mir_transform\",\n  \"rustc_monomorphize\",\n  \"rustc_parse\",\n  \"rustc_passes\",\n@@ -3861,8 +3862,10 @@ dependencies = [\n  \"rustc_const_eval\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_fluent_macro\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_mir_dataflow\",\n  \"rustc_serialize\","}, {"sha": "869344ce92d7de544b9d6090f86c5b872f4ad9ca", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1227,6 +1227,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         (value1, value2)\n     }\n \n+    fn filter_landing_pad(&mut self, pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n+        // TODO(antoyo): generate the correct landing pad\n+        self.cleanup_landing_pad(pers_fn)\n+    }\n+\n     #[cfg(feature=\"master\")]\n     fn resume(&mut self, exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n         let exn_type = exn0.get_type();"}, {"sha": "4d0bcd53d15624b3a2f7b91281d33f8c19b8a56c", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -985,13 +985,20 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn cleanup_landing_pad(&mut self, pers_fn: &'ll Value) -> (&'ll Value, &'ll Value) {\n         let ty = self.type_struct(&[self.type_i8p(), self.type_i32()], false);\n-        let landing_pad = self.landing_pad(ty, pers_fn, 1 /* FIXME should this be 0? */);\n+        let landing_pad = self.landing_pad(ty, pers_fn, 0);\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n         (self.extract_value(landing_pad, 0), self.extract_value(landing_pad, 1))\n     }\n \n+    fn filter_landing_pad(&mut self, pers_fn: &'ll Value) -> (&'ll Value, &'ll Value) {\n+        let ty = self.type_struct(&[self.type_i8p(), self.type_i32()], false);\n+        let landing_pad = self.landing_pad(ty, pers_fn, 1);\n+        self.add_clause(landing_pad, self.const_array(self.type_i8p(), &[]));\n+        (self.extract_value(landing_pad, 0), self.extract_value(landing_pad, 1))\n+    }\n+\n     fn resume(&mut self, exn0: &'ll Value, exn1: &'ll Value) {\n         let ty = self.type_struct(&[self.type_i8p(), self.type_i32()], false);\n         let mut exn = self.const_poison(ty);"}, {"sha": "a832999225ab667c89212c885313f3e0ab91e3c1", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1600,7 +1600,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx = Bx::build(self.cx, llbb);\n \n                 let llpersonality = self.cx.eh_personality();\n-                bx.cleanup_landing_pad(llpersonality);\n+                bx.filter_landing_pad(llpersonality);\n \n                 funclet = None;\n             }"}, {"sha": "853c6934c2c243b68ab7797c7650dadb04abfb8e", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -274,6 +274,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     // These are used by everyone except msvc\n     fn cleanup_landing_pad(&mut self, pers_fn: Self::Value) -> (Self::Value, Self::Value);\n+    fn filter_landing_pad(&mut self, pers_fn: Self::Value) -> (Self::Value, Self::Value);\n     fn resume(&mut self, exn0: Self::Value, exn1: Self::Value);\n \n     // These are used only by msvc"}, {"sha": "d7d97fcc3e7b7154382bcc6513e245e2576a05dd", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -51,6 +51,7 @@ rustc_interface = { path = \"../rustc_interface\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n+rustc_mir_transform = { path = \"../rustc_mir_transform\" }\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\"\n@@ -64,5 +65,8 @@ features = [\n [features]\n llvm = ['rustc_interface/llvm']\n max_level_info = ['rustc_log/max_level_info']\n-rustc_use_parallel_compiler = ['rustc_data_structures/rustc_use_parallel_compiler', 'rustc_interface/rustc_use_parallel_compiler',\n-    'rustc_middle/rustc_use_parallel_compiler']\n+rustc_use_parallel_compiler = [\n+    'rustc_data_structures/rustc_use_parallel_compiler',\n+    'rustc_interface/rustc_use_parallel_compiler',\n+    'rustc_middle/rustc_use_parallel_compiler'\n+]"}, {"sha": "9b16f246193f783a1f993b96f90528b0d9eb3b55", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -99,6 +99,7 @@ pub static DEFAULT_LOCALE_RESOURCES: &[&str] = &[\n     rustc_middle::DEFAULT_LOCALE_RESOURCE,\n     rustc_mir_build::DEFAULT_LOCALE_RESOURCE,\n     rustc_mir_dataflow::DEFAULT_LOCALE_RESOURCE,\n+    rustc_mir_transform::DEFAULT_LOCALE_RESOURCE,\n     rustc_monomorphize::DEFAULT_LOCALE_RESOURCE,\n     rustc_parse::DEFAULT_LOCALE_RESOURCE,\n     rustc_passes::DEFAULT_LOCALE_RESOURCE,"}, {"sha": "db97d96fccd181eeb8cd156f7f6fb3ad3441532d", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -571,6 +571,14 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         Some((diagnostic, handler))\n     }\n \n+    /// Retrieves the [`Handler`] if available\n+    pub fn handler(&self) -> Option<&Handler> {\n+        match self.inner.state {\n+            DiagnosticBuilderState::Emittable(handler) => Some(handler),\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => None,\n+        }\n+    }\n+\n     /// Buffers the diagnostic for later emission,\n     /// unless handler has disabled such buffering.\n     pub fn buffer(self, buffered_diagnostics: &mut Vec<Diagnostic>) {"}, {"sha": "6ac1df6a079287c8779394fbd684c1bcfa54535f", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -2419,6 +2419,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             return Ok(None);\n         }\n \n+        //\n+        // Select applicable inherent associated type candidates modulo regions.\n+        //\n+\n         // In contexts that have no inference context, just make a new one.\n         // We do need a local variable to store it, though.\n         let infcx_;\n@@ -2431,14 +2435,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         };\n \n-        let param_env = tcx.param_env(block.owner.to_def_id());\n+        // FIXME(inherent_associated_types): Acquiring the ParamEnv this early leads to cycle errors\n+        // when inside of an ADT (#108491) or where clause.\n+        let param_env = tcx.param_env(block.owner);\n         let cause = ObligationCause::misc(span, block.owner.def_id);\n \n         let mut fulfillment_errors = Vec::new();\n         let mut applicable_candidates: Vec<_> = infcx.probe(|_| {\n             let universe = infcx.create_next_universe();\n \n             // Regions are not considered during selection.\n+            // FIXME(non_lifetime_binders): Here we are \"truncating\" or \"flattening\" the universes\n+            // of type and const binders. Is that correct in the selection phase? See also #109505.\n             let self_ty = tcx.replace_escaping_bound_vars_uncached(\n                 self_ty,\n                 FnMutDelegate {\n@@ -2454,41 +2462,40 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             candidates\n                 .iter()\n-                .filter_map(|&(impl_, (assoc_item, def_scope))| {\n+                .copied()\n+                .filter(|&(impl_, _)| {\n                     infcx.probe(|_| {\n                         let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n \n-                        let impl_ty = tcx.type_of(impl_);\n                         let impl_substs = infcx.fresh_item_substs(impl_);\n-                        let impl_ty = impl_ty.subst(tcx, impl_substs);\n+                        let impl_ty = tcx.type_of(impl_).subst(tcx, impl_substs);\n                         let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n \n-                        // Check that the Self-types can be related.\n-                        // FIXME(fmease): Should we use `eq` here?\n-                        ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n+                        // Check that the self types can be related.\n+                        // FIXME(inherent_associated_types): Should we use `eq` here? Method probing uses\n+                        // `sup` for this situtation, too. What for? To constrain inference variables?\n+                        if ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).is_err()\n+                        {\n+                            return false;\n+                        }\n \n                         // Check whether the impl imposes obligations we have to worry about.\n-                        let impl_bounds = tcx.predicates_of(impl_);\n-                        let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n-\n+                        let impl_bounds = tcx.predicates_of(impl_).instantiate(tcx, impl_substs);\n                         let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n-\n                         let impl_obligations = traits::predicates_for_generics(\n                             |_, _| cause.clone(),\n                             param_env,\n                             impl_bounds,\n                         );\n-\n                         ocx.register_obligations(impl_obligations);\n \n                         let mut errors = ocx.select_where_possible();\n                         if !errors.is_empty() {\n                             fulfillment_errors.append(&mut errors);\n-                            return None;\n+                            return false;\n                         }\n \n-                        // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n-                        Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                        true\n                     })\n                 })\n                 .collect()\n@@ -2497,24 +2504,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if applicable_candidates.len() > 1 {\n             return Err(self.complain_about_ambiguous_inherent_assoc_type(\n                 name,\n-                applicable_candidates.into_iter().map(|(candidate, ..)| candidate).collect(),\n+                applicable_candidates.into_iter().map(|(_, (candidate, _))| candidate).collect(),\n                 span,\n             ));\n         }\n \n-        if let Some((assoc_item, def_scope, impl_substs)) = applicable_candidates.pop() {\n+        if let Some((impl_, (assoc_item, def_scope))) = applicable_candidates.pop() {\n             self.check_assoc_ty(assoc_item, name, def_scope, block, span);\n \n-            // FIXME(inherent_associated_types): To fully *confirm* the *probed* candidate, we still\n-            // need to relate the Self-type with fresh item substs & register region obligations for\n-            // regionck to prove/disprove.\n-\n-            let item_substs =\n-                self.create_substs_for_associated_item(span, assoc_item, segment, impl_substs);\n+            // FIXME(fmease): Currently creating throwaway `parent_substs` to please\n+            // `create_substs_for_associated_item`. Modify the latter instead (or sth. similar) to\n+            // not require the parent substs logic.\n+            let parent_substs = InternalSubsts::identity_for_item(tcx, impl_);\n+            let substs =\n+                self.create_substs_for_associated_item(span, assoc_item, segment, parent_substs);\n+            let substs = tcx.mk_substs_from_iter(\n+                std::iter::once(ty::GenericArg::from(self_ty))\n+                    .chain(substs.into_iter().skip(parent_substs.len())),\n+            );\n \n-            // FIXME(fmease, #106722): Check if the bounds on the parameters of the\n-            // associated type hold, if any.\n-            let ty = tcx.type_of(assoc_item).subst(tcx, item_substs);\n+            let ty = tcx.mk_alias(ty::Inherent, tcx.mk_alias_ty(assoc_item, substs));\n \n             return Ok(Some((ty, assoc_item)));\n         }"}, {"sha": "272177dfbd0f858ea5bc562e4ad6bda2d2255cd0", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -210,6 +210,19 @@ fn do_orphan_check_impl<'tcx>(\n                 NonlocalImpl::DisallowOther,\n             ),\n \n+            // ```\n+            // struct S<T>(T);\n+            // impl<T: ?Sized> S<T> {\n+            //     type This = T;\n+            // }\n+            // impl<T: ?Sized> AutoTrait for S<T>::This {}\n+            // ```\n+            // FIXME(inherent_associated_types): The example code above currently leads to a cycle\n+            ty::Alias(AliasKind::Inherent, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"associated type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n             // type Opaque = impl Trait;\n             // impl AutoTrait for Opaque {}\n             ty::Alias(AliasKind::Opaque, _) => ("}, {"sha": "5c7f7f10b17ecc2cd1b3f8b3f59bd23eb67ad90e", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1948,7 +1948,7 @@ fn is_late_bound_map(\n                 ty::Param(param_ty) => {\n                     self.arg_is_constrained[param_ty.index as usize] = true;\n                 }\n-                ty::Alias(ty::Projection, _) => return ControlFlow::Continue(()),\n+                ty::Alias(ty::Projection | ty::Inherent, _) => return ControlFlow::Continue(()),\n                 _ => (),\n             }\n             t.super_visit_with(self)"}, {"sha": "8df0166f76b4b269c8f97d2760f914b927423eef", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -127,7 +127,7 @@ fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n             // the def_id that this query was called with. We filter to only type and const args here\n             // as a precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n             // but it can't hurt to be safe ^^\n-            if let ty::Alias(ty::Projection, projection) = ty.kind() {\n+            if let ty::Alias(ty::Projection | ty::Inherent, projection) = ty.kind() {\n                 let generics = tcx.generics_of(projection.def_id);\n \n                 let arg_index = segment"}, {"sha": "9200c2aecf55c07699e9bcdf1f289ea64d2d6977", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -59,7 +59,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n-            ty::Alias(ty::Projection, ..) if !self.include_nonconstraining => {\n+            ty::Alias(ty::Projection | ty::Inherent, ..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return ControlFlow::Continue(());\n             }"}, {"sha": "0cd2fc1aa299a4dc3f8a5b532de37fdaebca84e5", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -210,6 +210,9 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 );\n             }\n \n+            // FIXME(inherent_associated_types): Handle this case properly.\n+            ty::Alias(ty::Inherent, _) => {}\n+\n             _ => {}\n         }\n     }"}, {"sha": "05e5d850bf958cc6471a15ed5ff489abdbbe0a09", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -843,7 +843,7 @@ fn find_param_in_ty<'tcx>(\n             return true;\n         }\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                && let ty::Alias(ty::Projection, ..) = ty.kind()\n+                && let ty::Alias(ty::Projection | ty::Inherent, ..) = ty.kind()\n             {\n                 // This logic may seem a bit strange, but typically when\n                 // we have a projection type in a function signature, the"}, {"sha": "67f45f9aa3f0dd64977c8bdd10ab4d142ab76bde", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         match ty.kind() {\n             ty::Adt(adt_def, _) => Some(*adt_def),\n             // FIXME(#104767): Should we handle bound regions here?\n-            ty::Alias(ty::Projection, _) if !ty.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Projection | ty::Inherent, _) if !ty.has_escaping_bound_vars() => {\n                 self.normalize(span, ty).ty_adt_def()\n             }\n             _ => None,"}, {"sha": "3741672e5683c3e906f658d0819f3da82a094768", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -2211,7 +2211,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         | ty::Float(_)\n                         | ty::Adt(_, _)\n                         | ty::Str\n-                        | ty::Alias(ty::Projection, _)\n+                        | ty::Alias(ty::Projection | ty::Inherent, _)\n                         | ty::Param(_) => format!(\"{deref_ty}\"),\n                         // we need to test something like  <&[_]>::len or <(&[u32])>::len\n                         // and Vec::function();"}, {"sha": "08eec0707c0adaf9db0f3b720a9896fd1f2efc35", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -127,7 +127,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                 bug!()\n             }\n \n-            (_, ty::Alias(AliasKind::Projection, _)) | (ty::Alias(AliasKind::Projection, _), _)\n+            (_, ty::Alias(AliasKind::Projection | AliasKind::Inherent, _))\n+            | (ty::Alias(AliasKind::Projection | AliasKind::Inherent, _), _)\n                 if self.tcx.trait_solver_next() =>\n             {\n                 relation.register_type_relate_obligation(a, b);"}, {"sha": "ce70f39cc4014d66aae79c447b747a06e9732761", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -2354,7 +2354,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n             GenericKind::Alias(ref p) => match p.kind(self.tcx) {\n-                ty::AliasKind::Projection => format!(\"the associated type `{}`\", p),\n+                ty::AliasKind::Projection | ty::AliasKind::Inherent => {\n+                    format!(\"the associated type `{}`\", p)\n+                }\n                 ty::AliasKind::Opaque => format!(\"the opaque type `{}`\", p),\n             },\n         };"}, {"sha": "064811bd29d77a25aade79585d08a67122adb6f9", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -71,9 +71,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                              #traits-as-parameters\",\n                         );\n                     }\n-                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n+                    (ty::Alias(ty::Projection | ty::Inherent, _), ty::Alias(ty::Projection | ty::Inherent, _)) => {\n                         diag.note(\"an associated type was expected, but a different one was found\");\n                     }\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n                         if !tcx.is_impl_trait_in_trait(proj.def_id) =>\n                     {\n@@ -222,7 +223,7 @@ impl<T> Trait<T> for X {\n                             diag.span_label(p_span, \"this type parameter\");\n                         }\n                     }\n-                    (ty::Alias(ty::Projection, proj_ty), _) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n+                    (ty::Alias(ty::Projection | ty::Inherent, proj_ty), _) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n                         self.expected_projection(\n                             diag,\n                             proj_ty,\n@@ -231,7 +232,7 @@ impl<T> Trait<T> for X {\n                             cause.code(),\n                         );\n                     }\n-                    (_, ty::Alias(ty::Projection, proj_ty)) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n+                    (_, ty::Alias(ty::Projection | ty::Inherent, proj_ty)) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n                         let msg = format!(\n                             \"consider constraining the associated type `{}` to `{}`\",\n                             values.found, values.expected,"}, {"sha": "362b22b23a8dad81e64d37cb4bad130696df32fe", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -549,6 +549,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // We can't normalize associated types from `rustc_infer`,\n                     // but we can eagerly register inference variables for them.\n                     // FIXME(RPITIT): Don't replace RPITITs with inference vars.\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n                             && !tcx.is_impl_trait_in_trait(projection_ty.def_id) =>\n@@ -569,6 +570,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                         hidden_ty\n                     }\n                     // FIXME(RPITIT): This can go away when we move to associated types\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(\n                         ty::Projection,\n                         ty::AliasTy { def_id: def_id2, substs: substs2, .. },"}, {"sha": "3025cce7ba7e52960b0724e427782264f49c7cb2", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -62,6 +62,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::TypeVisitableExt;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n use rustc_session::config::ExpectedValues;\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n@@ -1442,6 +1443,10 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n             // Bounds are respected for `type X = impl Trait`\n             return;\n         }\n+        if cx.tcx.type_of(item.owner_id).skip_binder().has_inherent_projections() {\n+            // Bounds are respected for `type X = \u2026 Type::Inherent \u2026`\n+            return;\n+        }\n         // There must not be a where clause\n         if type_alias_generics.predicates.is_empty() {\n             return;\n@@ -1561,7 +1566,6 @@ declare_lint_pass!(\n \n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-        use rustc_middle::ty::visit::TypeVisitableExt;\n         use rustc_middle::ty::Clause;\n         use rustc_middle::ty::PredicateKind::*;\n \n@@ -2898,6 +2902,7 @@ impl ClashingExternDeclarations {\n                         | (Generator(..), Generator(..))\n                         | (GeneratorWitness(..), GeneratorWitness(..))\n                         | (Alias(ty::Projection, ..), Alias(ty::Projection, ..))\n+                        | (Alias(ty::Inherent, ..), Alias(ty::Inherent, ..))\n                         | (Alias(ty::Opaque, ..), Alias(ty::Opaque, ..)) => false,\n \n                         // These definitely should have been caught above."}, {"sha": "125b4dc5503100548be60daa014cd00d05560fb5", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1119,14 +1119,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n             //  so they are currently ignored for the purposes of this lint.\n-            ty::Param(..) | ty::Alias(ty::Projection, ..)\n+            ty::Param(..) | ty::Alias(ty::Projection | ty::Inherent, ..)\n                 if matches!(self.mode, CItemKind::Definition) =>\n             {\n                 FfiSafe\n             }\n \n             ty::Param(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Infer(..)\n             | ty::Bound(..)\n             | ty::Error(_)"}, {"sha": "cd6e36874603f8a499100c817af10ca83079af44", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -9,7 +9,7 @@ use crate::diagnostics::utils::{\n     FieldInnerTy, FieldMap, HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n-use quote::{format_ident, quote};\n+use quote::{format_ident, quote, quote_spanned};\n use syn::Token;\n use syn::{parse_quote, spanned::Spanned, Attribute, Meta, Path, Type};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n@@ -251,7 +251,8 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         let diag = &self.parent.diag;\n \n         let field = binding_info.ast();\n-        let field_binding = &binding_info.binding;\n+        let mut field_binding = binding_info.binding.clone();\n+        field_binding.set_span(field.ty.span());\n \n         let ident = field.ident.as_ref().unwrap();\n         let ident = format_ident!(\"{}\", ident); // strip `r#` prefix, if present\n@@ -284,9 +285,9 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     name == \"primary_span\" && matches!(inner_ty, FieldInnerTy::Vec(_));\n                 let (binding, needs_destructure) = if needs_clone {\n                     // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n-                    (quote! { #field_binding.clone() }, false)\n+                    (quote_spanned! {inner_ty.span()=> #field_binding.clone() }, false)\n                 } else {\n-                    (quote! { #field_binding }, true)\n+                    (quote_spanned! {inner_ty.span()=> #field_binding }, true)\n                 };\n \n                 let generated_code = self"}, {"sha": "374ba1a45c06ec89ada4f940cf52d01e357ef5f8", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -4,17 +4,16 @@ use crate::diagnostics::error::{\n     invalid_attr, span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    build_field_mapping, is_doc_comment, new_code_ident,\n-    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span, FieldInfo,\n-    FieldInnerTy, FieldMap, HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n+    build_field_mapping, build_suggestion_code, is_doc_comment, new_code_ident,\n+    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span,\n+    should_generate_set_arg, AllowMultipleAlternatives, FieldInfo, FieldInnerTy, FieldMap,\n+    HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n use syn::{spanned::Spanned, Attribute, Meta, MetaList, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n-use super::utils::{build_suggestion_code, AllowMultipleAlternatives};\n-\n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n pub(crate) struct SubdiagnosticDeriveBuilder {\n     diag: syn::Ident,\n@@ -210,19 +209,20 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     }\n \n     /// Generates the code for a field with no attributes.\n-    fn generate_field_set_arg(&mut self, binding: &BindingInfo<'_>) -> TokenStream {\n-        let ast = binding.ast();\n-        assert_eq!(ast.attrs.len(), 0, \"field with attribute used as diagnostic arg\");\n-\n+    fn generate_field_set_arg(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n         let diag = &self.parent.diag;\n-        let ident = ast.ident.as_ref().unwrap();\n-        // strip `r#` prefix, if present\n-        let ident = format_ident!(\"{}\", ident);\n+\n+        let field = binding_info.ast();\n+        let mut field_binding = binding_info.binding.clone();\n+        field_binding.set_span(field.ty.span());\n+\n+        let ident = field.ident.as_ref().unwrap();\n+        let ident = format_ident!(\"{}\", ident); // strip `r#` prefix, if present\n \n         quote! {\n             #diag.set_arg(\n                 stringify!(#ident),\n-                #binding\n+                #field_binding\n             );\n         }\n     }\n@@ -399,7 +399,8 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let span = attr.span().unwrap();\n-        let ident = &list.path.segments.last().unwrap().ident;\n+        let mut ident = list.path.segments.last().unwrap().ident.clone();\n+        ident.set_span(info.ty.span());\n         let name = ident.to_string();\n         let name = name.as_str();\n \n@@ -498,7 +499,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             .variant\n             .bindings()\n             .iter()\n-            .filter(|binding| !binding.ast().attrs.is_empty())\n+            .filter(|binding| !should_generate_set_arg(binding.ast()))\n             .map(|binding| self.generate_field_attr_code(binding, kind_stats))\n             .collect();\n \n@@ -580,7 +581,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n             .variant\n             .bindings()\n             .iter()\n-            .filter(|binding| binding.ast().attrs.is_empty())\n+            .filter(|binding| should_generate_set_arg(binding.ast()))\n             .map(|binding| self.generate_field_set_arg(binding))\n             .collect();\n "}, {"sha": "e2434981f8d1782fd3fdfb0f051bcae1a6a9f8be", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -207,6 +207,12 @@ impl<'ty> FieldInnerTy<'ty> {\n             FieldInnerTy::Plain(..) => quote! { #inner },\n         }\n     }\n+\n+    pub fn span(&self) -> proc_macro2::Span {\n+        match self {\n+            FieldInnerTy::Option(ty) | FieldInnerTy::Vec(ty) | FieldInnerTy::Plain(ty) => ty.span(),\n+        }\n+    }\n }\n \n /// Field information passed to the builder. Deliberately omits attrs to discourage the\n@@ -851,7 +857,8 @@ impl quote::IdentFragment for SubdiagnosticKind {\n /// Returns `true` if `field` should generate a `set_arg` call rather than any other diagnostic\n /// call (like `span_label`).\n pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n-    field.attrs.is_empty()\n+    // Perhaps this should be an exhaustive list...\n+    field.attrs.iter().all(|attr| is_doc_comment(attr))\n }\n \n pub(super) fn is_doc_comment(attr: &Attribute) -> bool {"}, {"sha": "d5b185e45d6b4aba261ce06424c011b12e93bfc8", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1821,6 +1821,16 @@ rustc_queries! {\n         desc { \"normalizing `{}`\", goal.value.value }\n     }\n \n+    /// Do not call this query directly: invoke `normalize` instead.\n+    query normalize_inherent_projection_ty(\n+        goal: CanonicalProjectionGoal<'tcx>\n+    ) -> Result<\n+        &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>,\n+        NoSolution,\n+    > {\n+        desc { \"normalizing `{}`\", goal.value.value }\n+    }\n+\n     /// Do not call this query directly: invoke `try_normalize_erasing_regions` instead.\n     query try_normalize_generic_arg_after_erasing_regions(\n         goal: ParamEnvAnd<'tcx, GenericArg<'tcx>>"}, {"sha": "8aea2d8aedf982aeb936247069f5ee966fd32e02", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1848,7 +1848,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         let substs = substs.into_iter().map(Into::into);\n         #[cfg(debug_assertions)]\n         {\n-            let n = self.generics_of(_def_id).count();\n+            let generics = self.generics_of(_def_id);\n+\n+            let n = if let DefKind::AssocTy = self.def_kind(_def_id)\n+                && let DefKind::Impl { of_trait: false } = self.def_kind(self.parent(_def_id))\n+            {\n+                // If this is an inherent projection.\n+\n+                generics.params.len() + 1\n+            } else {\n+                generics.count()\n+            };\n             assert_eq!(\n                 (n, Some(n)),\n                 substs.size_hint(),\n@@ -2009,7 +2019,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug_assert_matches!(\n             (kind, self.def_kind(alias_ty.def_id)),\n             (ty::Opaque, DefKind::OpaqueTy)\n-                | (ty::Projection, DefKind::AssocTy)\n+                | (ty::Projection | ty::Inherent, DefKind::AssocTy)\n                 | (ty::Opaque | ty::Projection, DefKind::ImplTraitPlaceholder)\n         );\n         self.mk_ty_from_kind(Alias(kind, alias_ty))"}, {"sha": "49ab9b79e96f32de0dbf5799d9a35f4a56d3d44d", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Infer(ty::FreshTy(_)) => \"fresh type\".into(),\n             ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n-            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n+            ty::Alias(ty::Projection | ty::Inherent, _) => \"associated type\".into(),\n             ty::Param(p) => format!(\"type parameter `{p}`\").into(),\n             ty::Alias(ty::Opaque, ..) => if tcx.ty_is_opaque_future(self) { \"future\".into() } else { \"opaque type\".into() },\n             ty::Error(_) => \"type error\".into(),\n@@ -312,7 +312,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Placeholder(..) => \"higher-ranked type\".into(),\n             ty::Bound(..) => \"bound type variable\".into(),\n-            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n+            ty::Alias(ty::Projection | ty::Inherent, _) => \"associated type\".into(),\n             ty::Param(_) => \"type parameter\".into(),\n             ty::Alias(ty::Opaque, ..) => \"opaque type\".into(),\n         }"}, {"sha": "d64875a9f00e8cc08cae1abf9cd1a3829836ecb7", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -176,14 +176,14 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::Alias(ty::Projection, data) => {\n-                self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n-                self.add_alias_ty(data);\n-            }\n+            &ty::Alias(kind, data) => {\n+                self.add_flags(match kind {\n+                    ty::Projection => TypeFlags::HAS_TY_PROJECTION,\n+                    ty::Inherent => TypeFlags::HAS_TY_INHERENT,\n+                    ty::Opaque => TypeFlags::HAS_TY_OPAQUE,\n+                });\n \n-            &ty::Alias(ty::Opaque, ty::AliasTy { substs, .. }) => {\n-                self.add_flags(TypeFlags::HAS_TY_OPAQUE);\n-                self.add_substs(substs);\n+                self.add_alias_ty(data);\n             }\n \n             &ty::Dynamic(obj, r, _) => {"}, {"sha": "9e672004cf9c0e6dc8d5fbe7598a2643c7831434", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -113,6 +113,12 @@ impl<'tcx> Ty<'tcx> {\n             }\n             Never => InhabitedPredicate::False,\n             Param(_) | Alias(ty::Projection, _) => InhabitedPredicate::GenericType(self),\n+            // FIXME(inherent_associated_types): Most likely we can just map to `GenericType` like above.\n+            // However it's unclear if the substs passed to `InhabitedPredicate::subst` are of the correct\n+            // format, i.e. don't contain parent substs. If you hit this case, please verify this beforehand.\n+            Alias(ty::Inherent, _) => {\n+                bug!(\"unimplemented: inhabitedness checking for inherent projections\")\n+            }\n             Tuple(tys) if tys.is_empty() => InhabitedPredicate::True,\n             // use a query for more complex cases\n             Adt(..) | Array(..) | Tuple(_) => tcx.inhabited_predicate_type(self),"}, {"sha": "47cf48f46cf891fbff7c6493190295f94638ad66", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -324,7 +324,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.kind() {\n-                    ty::Param(_) | ty::Alias(ty::Projection, _) => {\n+                    ty::Param(_) | ty::Alias(ty::Projection | ty::Inherent, _) => {\n                         debug_assert!(tail.has_non_region_param());\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }"}, {"sha": "f882f54d6281118999c2e1badb136b59dcb58b44", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1004,7 +1004,7 @@ impl<'tcx> Term<'tcx> {\n         match self.unpack() {\n             TermKind::Ty(ty) => match ty.kind() {\n                 ty::Alias(kind, alias_ty) => match kind {\n-                    AliasKind::Projection => Some(*alias_ty),\n+                    AliasKind::Projection | AliasKind::Inherent => Some(*alias_ty),\n                     AliasKind::Opaque => None,\n                 },\n                 _ => None,"}, {"sha": "926172ff828c725a9451a193b3d3c7f0cdacad72", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -729,7 +729,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Foreign(def_id) => {\n                 p!(print_def_path(def_id, &[]));\n             }\n-            ty::Alias(ty::Projection, ref data) => {\n+            ty::Alias(ty::Projection | ty::Inherent, ref data) => {\n                 if !(self.should_print_verbose() || NO_QUERIES.with(|q| q.get()))\n                     && self.tcx().is_impl_trait_in_trait(data.def_id)\n                 {"}, {"sha": "da43475941ee5a309780d63a02e38febb36ec9bc", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -550,6 +550,11 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             Ok(tcx.mk_projection(projection_ty.def_id, projection_ty.substs))\n         }\n \n+        (&ty::Alias(ty::Inherent, a_data), &ty::Alias(ty::Inherent, b_data)) => {\n+            let alias_ty = relation.relate(a_data, b_data)?;\n+            Ok(tcx.mk_alias(ty::Inherent, tcx.mk_alias_ty(alias_ty.def_id, alias_ty.substs)))\n+        }\n+\n         (\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: a_substs, .. }),\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: b_substs, .. }),"}, {"sha": "8d0737e1eeeeb979b95e4ff4fb1ca194c6984f81", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1190,9 +1190,9 @@ where\n \n /// Represents the projection of an associated type.\n ///\n-/// For a projection, this would be `<Ty as Trait<...>>::N`.\n-///\n-/// For an opaque type, there is no explicit syntax.\n+/// * For a projection, this would be `<Ty as Trait<...>>::N<...>`.\n+/// * For an inherent projection, this would be `Ty::N<...>`.\n+/// * For an opaque type, there is no explicit syntax.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct AliasTy<'tcx> {\n@@ -1201,12 +1201,16 @@ pub struct AliasTy<'tcx> {\n     /// For a projection, these are the substitutions for the trait and the\n     /// GAT substitutions, if there are any.\n     ///\n+    /// For an inherent projection, they consist of the self type and the GAT substitutions,\n+    /// if there are any.\n+    ///\n     /// For RPIT the substitutions are for the generics of the function,\n     /// while for TAIT it is used for the generic parameters of the alias.\n     pub substs: SubstsRef<'tcx>,\n \n-    /// The `DefId` of the `TraitItem` for the associated type `N` if this is a projection,\n-    /// or the `OpaqueType` item if this is an opaque.\n+    /// The `DefId` of the `TraitItem` or `ImplItem` for the associated type `N` depending on whether\n+    /// this is a projection or an inherent projection or the `DefId` of the `OpaqueType` item if\n+    /// this is an opaque.\n     ///\n     /// During codegen, `tcx.type_of(def_id)` can be used to get the type of the\n     /// underlying type if the type is an opaque.\n@@ -1224,6 +1228,7 @@ pub struct AliasTy<'tcx> {\n impl<'tcx> AliasTy<'tcx> {\n     pub fn kind(self, tcx: TyCtxt<'tcx>) -> ty::AliasKind {\n         match tcx.def_kind(self.def_id) {\n+            DefKind::AssocTy if let DefKind::Impl { of_trait: false } = tcx.def_kind(tcx.parent(self.def_id)) => ty::Inherent,\n             DefKind::AssocTy | DefKind::ImplTraitPlaceholder => ty::Projection,\n             DefKind::OpaqueTy => ty::Opaque,\n             kind => bug!(\"unexpected DefKind in AliasTy: {kind:?}\"),\n@@ -1236,6 +1241,17 @@ impl<'tcx> AliasTy<'tcx> {\n }\n \n /// The following methods work only with associated type projections.\n+impl<'tcx> AliasTy<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n+        self.substs.type_at(0)\n+    }\n+\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+    }\n+}\n+\n+/// The following methods work only with trait associated type projections.\n impl<'tcx> AliasTy<'tcx> {\n     pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n         match tcx.def_kind(self.def_id) {\n@@ -1274,13 +1290,28 @@ impl<'tcx> AliasTy<'tcx> {\n         let def_id = self.trait_def_id(tcx);\n         ty::TraitRef::new(tcx, def_id, self.substs.truncate_to(tcx, tcx.generics_of(def_id)))\n     }\n+}\n \n-    pub fn self_ty(self) -> Ty<'tcx> {\n-        self.substs.type_at(0)\n-    }\n+/// The following methods work only with inherent associated type projections.\n+impl<'tcx> AliasTy<'tcx> {\n+    /// Transform the substitutions to have the given `impl` substs as the base and the GAT substs on top of that.\n+    ///\n+    /// Does the following transformation:\n+    ///\n+    /// ```text\n+    /// [Self, P_0...P_m] -> [I_0...I_n, P_0...P_m]\n+    ///\n+    ///     I_i impl subst\n+    ///     P_j GAT subst\n+    /// ```\n+    pub fn rebase_substs_onto_impl(\n+        self,\n+        impl_substs: ty::SubstsRef<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> ty::SubstsRef<'tcx> {\n+        debug_assert_eq!(self.kind(tcx), ty::Inherent);\n \n-    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n-        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+        tcx.mk_substs_from_iter(impl_substs.into_iter().chain(self.substs.into_iter().skip(1)))\n     }\n }\n "}, {"sha": "520bb55e031c70f366f8e6029eb37cc84c86b421", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -49,6 +49,9 @@ pub trait TypeVisitableExt<'tcx>: TypeVisitable<TyCtxt<'tcx>> {\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n     }\n+    fn has_inherent_projections(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_INHERENT)\n+    }\n     fn has_opaque_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n     }"}, {"sha": "eca5f98a2c01cd22cfa1362a751fe36db913e2d5", "filename": "compiler/rustc_mir_transform/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2FCargo.toml?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -24,6 +24,8 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_span = { path = \"../rustc_span\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n \n [dev-dependencies]\n coverage_test_macros = { path = \"src/coverage/test_macros\" }"}, {"sha": "8c85cb5f76d8627076b9f7f7dc5d50e2678dfb03", "filename": "compiler/rustc_mir_transform/messages.ftl", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fmessages.ftl?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,66 @@\n+mir_transform_const_modify = attempting to modify a `const` item\n+    .note = each usage of a `const` item creates a new temporary; the original `const` item will not be modified\n+\n+mir_transform_const_mut_borrow = taking a mutable reference to a `const` item\n+    .note = each usage of a `const` item creates a new temporary\n+    .note2 = the mutable reference will refer to this temporary, not the original `const` item\n+    .note3 = mutable reference created due to call to this method\n+\n+mir_transform_const_defined_here = `const` item defined here\n+\n+mir_transform_unaligned_packed_ref = reference to packed field is unaligned\n+    .note = packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\n+    .note_ub = creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+    .help = copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+mir_transform_unused_unsafe = unnecessary `unsafe` block\n+    .label = because it's nested under this `unsafe` block\n+\n+mir_transform_requires_unsafe = {$details} is unsafe and requires unsafe {$op_in_unsafe_fn_allowed ->\n+    [true] function or block\n+    *[false] block\n+    }\n+    .not_inherited = items do not inherit unsafety from separate enclosing items\n+\n+mir_transform_call_to_unsafe_label = call to unsafe function\n+mir_transform_call_to_unsafe_note = consult the function's documentation for information on how to avoid undefined behavior\n+mir_transform_use_of_asm_label = use of inline assembly\n+mir_transform_use_of_asm_note = inline assembly is entirely unchecked and can cause undefined behavior\n+mir_transform_initializing_valid_range_label = initializing type with `rustc_layout_scalar_valid_range` attr\n+mir_transform_initializing_valid_range_note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+mir_transform_const_ptr2int_label = cast of pointer to int\n+mir_transform_const_ptr2int_note = casting pointers to integers in constants\n+mir_transform_use_of_static_mut_label = use of mutable static\n+mir_transform_use_of_static_mut_note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+mir_transform_use_of_extern_static_label = use of extern static\n+mir_transform_use_of_extern_static_note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+mir_transform_deref_ptr_label = dereference of raw pointer\n+mir_transform_deref_ptr_note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+mir_transform_union_access_label = access to union field\n+mir_transform_union_access_note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+mir_transform_mutation_layout_constrained_label = mutation of layout constrained field\n+mir_transform_mutation_layout_constrained_note = mutating layout constrained fields cannot statically be checked for valid values\n+mir_transform_mutation_layout_constrained_borrow_label = borrow of layout constrained field with interior mutability\n+mir_transform_mutation_layout_constrained_borrow_note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+mir_transform_target_feature_call_label = call to function with `#[target_feature]`\n+mir_transform_target_feature_call_note = can only be called if the required target features are available\n+\n+mir_transform_unsafe_op_in_unsafe_fn = {$details} is unsafe and requires unsafe block (error E0133)\n+\n+mir_transform_arithmetic_overflow = this arithmetic operation will overflow\n+mir_transform_operation_will_panic = this operation will panic at runtime\n+\n+mir_transform_ffi_unwind_call = call to {$foreign ->\n+    [true] foreign function\n+    *[false] function pointer\n+    } with FFI-unwind ABI\n+\n+mir_transform_fn_item_ref = taking a reference to a function item does not give a function pointer\n+    .suggestion = cast `{$ident}` to obtain a function pointer\n+\n+mir_transform_must_not_suspend = {$pre}`{$def_path}`{$post} held across a suspend point, but should not be\n+    .label = the value is held across this suspend point\n+    .note = {$reason}\n+    .help = consider using a block (`{\"{ ... }\"}`) to shrink the value's scope, ending before the suspend point\n+\n+mir_transform_simd_shuffle_last_const = last argument of `simd_shuffle` is required to be a `const` item"}, {"sha": "b79150737d6129fc5cd9936b82b69333b177d6b1", "filename": "compiler/rustc_mir_transform/src/check_const_item_mutation.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1,11 +1,12 @@\n-use rustc_errors::{DiagnosticBuilder, DiagnosticMessage};\n+use rustc_hir::HirId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::CONST_ITEM_MUTATION;\n use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n \n-use crate::MirLint;\n+use crate::{errors, MirLint};\n \n pub struct CheckConstItemMutation;\n \n@@ -58,16 +59,14 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n         }\n     }\n \n-    fn lint_const_item_usage(\n+    /// If we should lint on this usage, return the [`HirId`], source [`Span`]\n+    /// and [`Span`] of the const item to use in the lint.\n+    fn should_lint_const_item_usage(\n         &self,\n         place: &Place<'tcx>,\n         const_item: DefId,\n         location: Location,\n-        msg: impl Into<DiagnosticMessage>,\n-        decorate: impl for<'a, 'b> FnOnce(\n-            &'a mut DiagnosticBuilder<'b, ()>,\n-        ) -> &'a mut DiagnosticBuilder<'b, ()>,\n-    ) {\n+    ) -> Option<(HirId, Span, Span)> {\n         // Don't lint on borrowing/assigning when a dereference is involved.\n         // If we 'leave' the temporary via a dereference, we must\n         // be modifying something else\n@@ -83,16 +82,9 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n                 .assert_crate_local()\n                 .lint_root;\n \n-            self.tcx.struct_span_lint_hir(\n-                CONST_ITEM_MUTATION,\n-                lint_root,\n-                source_info.span,\n-                msg,\n-                |lint| {\n-                    decorate(lint)\n-                        .span_note(self.tcx.def_span(const_item), \"`const` item defined here\")\n-                },\n-            );\n+            Some((lint_root, source_info.span, self.tcx.def_span(const_item)))\n+        } else {\n+            None\n         }\n     }\n }\n@@ -104,10 +96,14 @@ impl<'tcx> Visitor<'tcx> for ConstMutationChecker<'_, 'tcx> {\n             // Assigning directly to a constant (e.g. `FOO = true;`) is a hard error,\n             // so emitting a lint would be redundant.\n             if !lhs.projection.is_empty() {\n-                if let Some(def_id) = self.is_const_item_without_destructor(lhs.local) {\n-                    self.lint_const_item_usage(&lhs, def_id, loc, \"attempting to modify a `const` item\",|lint| {\n-                        lint.note(\"each usage of a `const` item creates a new temporary; the original `const` item will not be modified\")\n-                    })\n+                if let Some(def_id) = self.is_const_item_without_destructor(lhs.local)\n+                    && let Some((lint_root, span, item)) = self.should_lint_const_item_usage(&lhs, def_id, loc) {\n+                        self.tcx.emit_spanned_lint(\n+                            CONST_ITEM_MUTATION,\n+                            lint_root,\n+                            span,\n+                            errors::ConstMutate::Modify { konst: item }\n+                        );\n                 }\n             }\n             // We are looking for MIR of the form:\n@@ -143,17 +139,22 @@ impl<'tcx> Visitor<'tcx> for ConstMutationChecker<'_, 'tcx> {\n                 });\n                 let lint_loc =\n                     if method_did.is_some() { self.body.terminator_loc(loc.block) } else { loc };\n-                self.lint_const_item_usage(place, def_id, lint_loc, \"taking a mutable reference to a `const` item\", |lint| {\n-                    lint\n-                        .note(\"each usage of a `const` item creates a new temporary\")\n-                        .note(\"the mutable reference will refer to this temporary, not the original `const` item\");\n-\n-                    if let Some((method_did, _substs)) = method_did {\n-                        lint.span_note(self.tcx.def_span(method_did), \"mutable reference created due to call to this method\");\n-                    }\n \n-                    lint\n-                });\n+                let method_call = if let Some((method_did, _)) = method_did {\n+                    Some(self.tcx.def_span(method_did))\n+                } else {\n+                    None\n+                };\n+                if let Some((lint_root, span, item)) =\n+                    self.should_lint_const_item_usage(place, def_id, lint_loc)\n+                {\n+                    self.tcx.emit_spanned_lint(\n+                        CONST_ITEM_MUTATION,\n+                        lint_root,\n+                        span,\n+                        errors::ConstMutate::MutBorrow { method_call, konst: item },\n+                    );\n+                }\n             }\n         }\n         self.super_rvalue(rvalue, loc);"}, {"sha": "2e6cf603d5968938b463e0b85291388dd70ba6be", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1,10 +1,9 @@\n-use rustc_errors::struct_span_err;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n \n-use crate::util;\n use crate::MirLint;\n+use crate::{errors, util};\n \n pub struct CheckPackedRef;\n \n@@ -49,25 +48,7 @@ impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n                     // shouldn't do.\n                     span_bug!(self.source_info.span, \"builtin derive created an unaligned reference\");\n                 } else {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        self.source_info.span,\n-                        E0793,\n-                        \"reference to packed field is unaligned\"\n-                    )\n-                    .note(\n-                        \"packed structs are only aligned by one byte, and many modern architectures \\\n-                        penalize unaligned field accesses\"\n-                    )\n-                    .note(\n-                        \"creating a misaligned reference is undefined behavior (even if that \\\n-                        reference is never dereferenced)\",\n-                    ).help(\n-                        \"copy the field contents to a local variable, or replace the \\\n-                        reference with a raw pointer and use `read_unaligned`/`write_unaligned` \\\n-                        (loads and stores via `*p` must be properly aligned even when using raw pointers)\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(errors::UnalignedPackedRef { span: self.source_info.span });\n                 }\n             }\n         }"}, {"sha": "bdb4f20da10590c31a132c42c2ca8fec238c784c", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1,5 +1,4 @@\n use rustc_data_structures::unord::{UnordItems, UnordSet};\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -15,6 +14,8 @@ use rustc_session::lint::Level;\n \n use std::ops::Bound;\n \n+use crate::errors;\n+\n pub struct UnsafetyChecker<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n     body_did: LocalDefId,\n@@ -509,21 +510,12 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def: LocalDefId) -> &UnsafetyCheckResu\n \n fn report_unused_unsafe(tcx: TyCtxt<'_>, kind: UnusedUnsafe, id: HirId) {\n     let span = tcx.sess.source_map().guess_head_span(tcx.hir().span(id));\n-    let msg = \"unnecessary `unsafe` block\";\n-    tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg, |lint| {\n-        lint.span_label(span, msg);\n-        match kind {\n-            UnusedUnsafe::Unused => {}\n-            UnusedUnsafe::InUnsafeBlock(id) => {\n-                lint.span_label(\n-                    tcx.sess.source_map().guess_head_span(tcx.hir().span(id)),\n-                    \"because it's nested under this `unsafe` block\",\n-                );\n-            }\n-        }\n-\n-        lint\n-    });\n+    let nested_parent = if let UnusedUnsafe::InUnsafeBlock(id) = kind {\n+        Some(tcx.sess.source_map().guess_head_span(tcx.hir().span(id)))\n+    } else {\n+        None\n+    };\n+    tcx.emit_spanned_lint(UNUSED_UNSAFE, id, span, errors::UnusedUnsafe { span, nested_parent });\n }\n \n pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n@@ -537,26 +529,11 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let UnsafetyCheckResult { violations, unused_unsafes, .. } = tcx.unsafety_check_result(def_id);\n \n     for &UnsafetyViolation { source_info, lint_root, kind, details } in violations.iter() {\n-        let (description, note) = details.description_and_note();\n+        let details = errors::RequiresUnsafeDetail { violation: details, span: source_info.span };\n \n         match kind {\n             UnsafetyViolationKind::General => {\n-                // once\n-                let unsafe_fn_msg = if unsafe_op_in_unsafe_fn_allowed(tcx, lint_root) {\n-                    \" function or\"\n-                } else {\n-                    \"\"\n-                };\n-\n-                let mut err = struct_span_err!(\n-                    tcx.sess,\n-                    source_info.span,\n-                    E0133,\n-                    \"{} is unsafe and requires unsafe{} block\",\n-                    description,\n-                    unsafe_fn_msg,\n-                );\n-                err.span_label(source_info.span, description).note(note);\n+                let op_in_unsafe_fn_allowed = unsafe_op_in_unsafe_fn_allowed(tcx, lint_root);\n                 let note_non_inherited = tcx.hir().parent_iter(lint_root).find(|(id, node)| {\n                     if let Node::Expr(block) = node\n                         && let ExprKind::Block(block, _) = block.kind\n@@ -572,22 +549,23 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                         false\n                     }\n                 });\n-                if let Some((id, _)) = note_non_inherited {\n-                    let span = tcx.hir().span(id);\n-                    err.span_label(\n-                        tcx.sess.source_map().guess_head_span(span),\n-                        \"items do not inherit unsafety from separate enclosing items\",\n-                    );\n-                }\n-\n-                err.emit();\n+                let enclosing = if let Some((id, _)) = note_non_inherited {\n+                    Some(tcx.sess.source_map().guess_head_span(tcx.hir().span(id)))\n+                } else {\n+                    None\n+                };\n+                tcx.sess.emit_err(errors::RequiresUnsafe {\n+                    span: source_info.span,\n+                    enclosing,\n+                    details,\n+                    op_in_unsafe_fn_allowed,\n+                });\n             }\n-            UnsafetyViolationKind::UnsafeFn => tcx.struct_span_lint_hir(\n+            UnsafetyViolationKind::UnsafeFn => tcx.emit_spanned_lint(\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 lint_root,\n                 source_info.span,\n-                format!(\"{} is unsafe and requires unsafe block (error E0133)\", description,),\n-                |lint| lint.span_label(source_info.span, description).note(note),\n+                errors::UnsafeOpInUnsafeFn { details },\n             ),\n         }\n     }"}, {"sha": "adb09c509d287e8f8a646beb0df113f21c56eb1d", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1,6 +1,8 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n+use std::fmt::Debug;\n+\n use either::Left;\n \n use rustc_const_eval::interpret::Immediate;\n@@ -17,14 +19,14 @@ use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{\n     self, ConstInt, Instance, ParamEnv, ScalarInt, Ty, TyCtxt, TypeVisitableExt,\n };\n-use rustc_session::lint;\n use rustc_span::Span;\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n use rustc_trait_selection::traits;\n \n use crate::const_prop::CanConstProp;\n use crate::const_prop::ConstPropMachine;\n use crate::const_prop::ConstPropMode;\n+use crate::errors::AssertLint;\n use crate::MirLint;\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -311,18 +313,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn report_assert_as_lint(\n-        &self,\n-        lint: &'static lint::Lint,\n-        location: Location,\n-        message: &'static str,\n-        panic: AssertKind<impl std::fmt::Debug>,\n-    ) {\n-        let source_info = self.body().source_info(location);\n+    fn report_assert_as_lint(&self, source_info: &SourceInfo, lint: AssertLint<impl Debug>) {\n         if let Some(lint_root) = self.lint_root(*source_info) {\n-            self.tcx.struct_span_lint_hir(lint, lint_root, source_info.span, message, |lint| {\n-                lint.span_label(source_info.span, format!(\"{:?}\", panic))\n-            });\n+            self.tcx.emit_spanned_lint(lint.lint(), lint_root, source_info.span, lint);\n         }\n     }\n \n@@ -335,11 +328,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // `AssertKind` only has an `OverflowNeg` variant, so make sure that is\n             // appropriate to use.\n             assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n+            let source_info = self.body().source_info(location);\n             self.report_assert_as_lint(\n-                lint::builtin::ARITHMETIC_OVERFLOW,\n-                location,\n-                \"this arithmetic operation will overflow\",\n-                AssertKind::OverflowNeg(val.to_const_int()),\n+                source_info,\n+                AssertLint::ArithmeticOverflow(\n+                    source_info.span,\n+                    AssertKind::OverflowNeg(val.to_const_int()),\n+                ),\n             );\n             return None;\n         }\n@@ -370,23 +365,23 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let r_bits = r.to_scalar().to_bits(right_size).ok();\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n                 debug!(\"check_binary_op: reporting assert for {:?}\", location);\n+                let source_info = self.body().source_info(location);\n+                let panic = AssertKind::Overflow(\n+                    op,\n+                    match l {\n+                        Some(l) => l.to_const_int(),\n+                        // Invent a dummy value, the diagnostic ignores it anyway\n+                        None => ConstInt::new(\n+                            ScalarInt::try_from_uint(1_u8, left_size).unwrap(),\n+                            left_ty.is_signed(),\n+                            left_ty.is_ptr_sized_integral(),\n+                        ),\n+                    },\n+                    r.to_const_int(),\n+                );\n                 self.report_assert_as_lint(\n-                    lint::builtin::ARITHMETIC_OVERFLOW,\n-                    location,\n-                    \"this arithmetic operation will overflow\",\n-                    AssertKind::Overflow(\n-                        op,\n-                        match l {\n-                            Some(l) => l.to_const_int(),\n-                            // Invent a dummy value, the diagnostic ignores it anyway\n-                            None => ConstInt::new(\n-                                ScalarInt::try_from_uint(1_u8, left_size).unwrap(),\n-                                left_ty.is_signed(),\n-                                left_ty.is_ptr_sized_integral(),\n-                            ),\n-                        },\n-                        r.to_const_int(),\n-                    ),\n+                    source_info,\n+                    AssertLint::ArithmeticOverflow(source_info.span, panic),\n                 );\n                 return None;\n             }\n@@ -398,11 +393,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, &l, &r)?;\n                 Ok(overflow)\n             })? {\n+                let source_info = self.body().source_info(location);\n                 self.report_assert_as_lint(\n-                    lint::builtin::ARITHMETIC_OVERFLOW,\n-                    location,\n-                    \"this arithmetic operation will overflow\",\n-                    AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n+                    source_info,\n+                    AssertLint::ArithmeticOverflow(\n+                        source_info.span,\n+                        AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n+                    ),\n                 );\n                 return None;\n             }\n@@ -543,11 +540,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 // Need proper const propagator for these.\n                 _ => return None,\n             };\n+            let source_info = self.body().source_info(location);\n             self.report_assert_as_lint(\n-                lint::builtin::UNCONDITIONAL_PANIC,\n-                location,\n-                \"this operation will panic at runtime\",\n-                msg,\n+                source_info,\n+                AssertLint::UnconditionalPanic(source_info.span, msg),\n             );\n         }\n "}, {"sha": "602e40d513104c0517da0a89a135dcadf4307de2", "filename": "compiler/rustc_mir_transform/src/errors.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ferrors.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,245 @@\n+use rustc_errors::{\n+    DecorateLint, DiagnosticBuilder, DiagnosticMessage, EmissionGuarantee, Handler, IntoDiagnostic,\n+};\n+use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_middle::mir::{AssertKind, UnsafetyViolationDetails};\n+use rustc_session::lint::{self, Lint};\n+use rustc_span::Span;\n+\n+#[derive(LintDiagnostic)]\n+pub(crate) enum ConstMutate {\n+    #[diag(mir_transform_const_modify)]\n+    #[note]\n+    Modify {\n+        #[note(mir_transform_const_defined_here)]\n+        konst: Span,\n+    },\n+    #[diag(mir_transform_const_mut_borrow)]\n+    #[note]\n+    #[note(mir_transform_note2)]\n+    MutBorrow {\n+        #[note(mir_transform_note3)]\n+        method_call: Option<Span>,\n+        #[note(mir_transform_const_defined_here)]\n+        konst: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_transform_unaligned_packed_ref, code = \"E0793\")]\n+#[note]\n+#[note(mir_transform_note_ub)]\n+#[help]\n+pub(crate) struct UnalignedPackedRef {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_unused_unsafe)]\n+pub(crate) struct UnusedUnsafe {\n+    #[label(mir_transform_unused_unsafe)]\n+    pub span: Span,\n+    #[label]\n+    pub nested_parent: Option<Span>,\n+}\n+\n+pub(crate) struct RequiresUnsafe {\n+    pub span: Span,\n+    pub details: RequiresUnsafeDetail,\n+    pub enclosing: Option<Span>,\n+    pub op_in_unsafe_fn_allowed: bool,\n+}\n+\n+// The primary message for this diagnostic should be '{$label} is unsafe and...',\n+// so we need to eagerly translate the label here, which isn't supported by the derive API\n+// We could also exhaustively list out the primary messages for all unsafe violations,\n+// but this would result in a lot of duplication.\n+impl<'sess, G: EmissionGuarantee> IntoDiagnostic<'sess, G> for RequiresUnsafe {\n+    #[track_caller]\n+    fn into_diagnostic(self, handler: &'sess Handler) -> DiagnosticBuilder<'sess, G> {\n+        let mut diag =\n+            handler.struct_diagnostic(crate::fluent_generated::mir_transform_requires_unsafe);\n+        diag.code(rustc_errors::DiagnosticId::Error(\"E0133\".to_string()));\n+        diag.set_span(self.span);\n+        diag.span_label(self.span, self.details.label());\n+        diag.note(self.details.note());\n+        let desc = handler.eagerly_translate_to_string(self.details.label(), [].into_iter());\n+        diag.set_arg(\"details\", desc);\n+        diag.set_arg(\"op_in_unsafe_fn_allowed\", self.op_in_unsafe_fn_allowed);\n+        if let Some(sp) = self.enclosing {\n+            diag.span_label(sp, crate::fluent_generated::mir_transform_not_inherited);\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub(crate) struct RequiresUnsafeDetail {\n+    pub span: Span,\n+    pub violation: UnsafetyViolationDetails,\n+}\n+\n+impl RequiresUnsafeDetail {\n+    fn note(self) -> DiagnosticMessage {\n+        use UnsafetyViolationDetails::*;\n+        match self.violation {\n+            CallToUnsafeFunction => crate::fluent_generated::mir_transform_call_to_unsafe_note,\n+            UseOfInlineAssembly => crate::fluent_generated::mir_transform_use_of_asm_note,\n+            InitializingTypeWith => {\n+                crate::fluent_generated::mir_transform_initializing_valid_range_note\n+            }\n+            CastOfPointerToInt => crate::fluent_generated::mir_transform_const_ptr2int_note,\n+            UseOfMutableStatic => crate::fluent_generated::mir_transform_use_of_static_mut_note,\n+            UseOfExternStatic => crate::fluent_generated::mir_transform_use_of_extern_static_note,\n+            DerefOfRawPointer => crate::fluent_generated::mir_transform_deref_ptr_note,\n+            AccessToUnionField => crate::fluent_generated::mir_transform_union_access_note,\n+            MutationOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_note\n+            }\n+            BorrowOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_borrow_note\n+            }\n+            CallToFunctionWith => crate::fluent_generated::mir_transform_target_feature_call_note,\n+        }\n+    }\n+\n+    fn label(self) -> DiagnosticMessage {\n+        use UnsafetyViolationDetails::*;\n+        match self.violation {\n+            CallToUnsafeFunction => crate::fluent_generated::mir_transform_call_to_unsafe_label,\n+            UseOfInlineAssembly => crate::fluent_generated::mir_transform_use_of_asm_label,\n+            InitializingTypeWith => {\n+                crate::fluent_generated::mir_transform_initializing_valid_range_label\n+            }\n+            CastOfPointerToInt => crate::fluent_generated::mir_transform_const_ptr2int_label,\n+            UseOfMutableStatic => crate::fluent_generated::mir_transform_use_of_static_mut_label,\n+            UseOfExternStatic => crate::fluent_generated::mir_transform_use_of_extern_static_label,\n+            DerefOfRawPointer => crate::fluent_generated::mir_transform_deref_ptr_label,\n+            AccessToUnionField => crate::fluent_generated::mir_transform_union_access_label,\n+            MutationOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_label\n+            }\n+            BorrowOfLayoutConstrainedField => {\n+                crate::fluent_generated::mir_transform_mutation_layout_constrained_borrow_label\n+            }\n+            CallToFunctionWith => crate::fluent_generated::mir_transform_target_feature_call_label,\n+        }\n+    }\n+}\n+\n+pub(crate) struct UnsafeOpInUnsafeFn {\n+    pub details: RequiresUnsafeDetail,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for UnsafeOpInUnsafeFn {\n+    #[track_caller]\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut DiagnosticBuilder<'a, ()> {\n+        let desc = diag\n+            .handler()\n+            .expect(\"lint should not yet be emitted\")\n+            .eagerly_translate_to_string(self.details.label(), [].into_iter());\n+        diag.set_arg(\"details\", desc);\n+        diag.span_label(self.details.span, self.details.label());\n+        diag.note(self.details.note());\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        crate::fluent_generated::mir_transform_unsafe_op_in_unsafe_fn\n+    }\n+}\n+\n+pub(crate) enum AssertLint<P> {\n+    ArithmeticOverflow(Span, AssertKind<P>),\n+    UnconditionalPanic(Span, AssertKind<P>),\n+}\n+\n+impl<'a, P: std::fmt::Debug> DecorateLint<'a, ()> for AssertLint<P> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut DiagnosticBuilder<'a, ()> {\n+        diag.span_label(self.span(), format!(\"{:?}\", self.panic()));\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        match self {\n+            AssertLint::ArithmeticOverflow(..) => {\n+                crate::fluent_generated::mir_transform_arithmetic_overflow\n+            }\n+            AssertLint::UnconditionalPanic(..) => {\n+                crate::fluent_generated::mir_transform_operation_will_panic\n+            }\n+        }\n+    }\n+}\n+\n+impl<P> AssertLint<P> {\n+    pub fn lint(&self) -> &'static Lint {\n+        match self {\n+            AssertLint::ArithmeticOverflow(..) => lint::builtin::ARITHMETIC_OVERFLOW,\n+            AssertLint::UnconditionalPanic(..) => lint::builtin::UNCONDITIONAL_PANIC,\n+        }\n+    }\n+    pub fn span(&self) -> Span {\n+        match self {\n+            AssertLint::ArithmeticOverflow(sp, _) | AssertLint::UnconditionalPanic(sp, _) => *sp,\n+        }\n+    }\n+    pub fn panic(&self) -> &AssertKind<P> {\n+        match self {\n+            AssertLint::ArithmeticOverflow(_, p) | AssertLint::UnconditionalPanic(_, p) => p,\n+        }\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_ffi_unwind_call)]\n+pub(crate) struct FfiUnwindCall {\n+    #[label(mir_transform_ffi_unwind_call)]\n+    pub span: Span,\n+    pub foreign: bool,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_fn_item_ref)]\n+pub(crate) struct FnItemRef {\n+    #[suggestion(code = \"{sugg}\", applicability = \"unspecified\")]\n+    pub span: Span,\n+    pub sugg: String,\n+    pub ident: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(mir_transform_must_not_suspend)]\n+pub(crate) struct MustNotSupend<'a> {\n+    #[label]\n+    pub yield_sp: Span,\n+    #[subdiagnostic]\n+    pub reason: Option<MustNotSuspendReason>,\n+    #[help]\n+    pub src_sp: Span,\n+    pub pre: &'a str,\n+    pub def_path: String,\n+    pub post: &'a str,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(mir_transform_note)]\n+pub(crate) struct MustNotSuspendReason {\n+    #[primary_span]\n+    pub span: Span,\n+    pub reason: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_transform_simd_shuffle_last_const)]\n+pub(crate) struct SimdShuffleLastConst {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "ac1de989a7204406d2a4f47a940c57e41042dac3", "filename": "compiler/rustc_mir_transform/src/ffi_unwind_calls.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fffi_unwind_calls.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -8,6 +8,8 @@ use rustc_session::lint::builtin::FFI_UNWIND_CALLS;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::PanicStrategy;\n \n+use crate::errors;\n+\n fn abi_can_unwind(abi: Abi) -> bool {\n     use Abi::*;\n     match abi {\n@@ -107,13 +109,13 @@ fn has_ffi_unwind_calls(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> bool {\n                 .lint_root;\n             let span = terminator.source_info.span;\n \n-            let msg = match fn_def_id {\n-                Some(_) => \"call to foreign function with FFI-unwind ABI\",\n-                None => \"call to function pointer with FFI-unwind ABI\",\n-            };\n-            tcx.struct_span_lint_hir(FFI_UNWIND_CALLS, lint_root, span, msg, |lint| {\n-                lint.span_label(span, msg)\n-            });\n+            let foreign = fn_def_id.is_some();\n+            tcx.emit_spanned_lint(\n+                FFI_UNWIND_CALLS,\n+                lint_root,\n+                span,\n+                errors::FfiUnwindCall { span, foreign },\n+            );\n \n             tainted = true;\n         }"}, {"sha": "5989dbebf2db9badf1fd699a1135044768281de0", "filename": "compiler/rustc_mir_transform/src/function_item_references.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Ffunction_item_references.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1,5 +1,4 @@\n use itertools::Itertools;\n-use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n@@ -8,7 +7,7 @@ use rustc_session::lint::builtin::FUNCTION_ITEM_REFERENCES;\n use rustc_span::{symbol::sym, Span};\n use rustc_target::spec::abi::Abi;\n \n-use crate::MirLint;\n+use crate::{errors, MirLint};\n \n pub struct FunctionItemReferences;\n \n@@ -174,27 +173,21 @@ impl<'tcx> FunctionItemRefChecker<'_, 'tcx> {\n         let num_args = fn_sig.inputs().map_bound(|inputs| inputs.len()).skip_binder();\n         let variadic = if fn_sig.c_variadic() { \", ...\" } else { \"\" };\n         let ret = if fn_sig.output().skip_binder().is_unit() { \"\" } else { \" -> _\" };\n-        self.tcx.struct_span_lint_hir(\n+        let sugg = format!(\n+            \"{} as {}{}fn({}{}){}\",\n+            if params.is_empty() { ident.clone() } else { format!(\"{}::<{}>\", ident, params) },\n+            unsafety,\n+            abi,\n+            vec![\"_\"; num_args].join(\", \"),\n+            variadic,\n+            ret,\n+        );\n+\n+        self.tcx.emit_spanned_lint(\n             FUNCTION_ITEM_REFERENCES,\n             lint_root,\n             span,\n-            \"taking a reference to a function item does not give a function pointer\",\n-            |lint| {\n-                lint.span_suggestion(\n-                    span,\n-                    format!(\"cast `{}` to obtain a function pointer\", ident),\n-                    format!(\n-                        \"{} as {}{}fn({}{}){}\",\n-                        if params.is_empty() { ident } else { format!(\"{}::<{}>\", ident, params) },\n-                        unsafety,\n-                        abi,\n-                        vec![\"_\"; num_args].join(\", \"),\n-                        variadic,\n-                        ret,\n-                    ),\n-                    Applicability::Unspecified,\n-                )\n-            },\n+            errors::FnItemRef { span, sugg, ident },\n         );\n     }\n }"}, {"sha": "c9144729145b6143bb51dbcd4505b1878764a07e", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -51,6 +51,7 @@\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n use crate::deref_separator::deref_finder;\n+use crate::errors;\n use crate::simplify;\n use crate::MirPass;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -1891,36 +1892,21 @@ fn check_must_not_suspend_def(\n     data: SuspendCheckData<'_>,\n ) -> bool {\n     if let Some(attr) = tcx.get_attr(def_id, sym::must_not_suspend) {\n-        let msg = rustc_errors::DelayDm(|| {\n-            format!(\n-                \"{}`{}`{} held across a suspend point, but should not be\",\n-                data.descr_pre,\n-                tcx.def_path_str(def_id),\n-                data.descr_post,\n-            )\n+        let reason = attr.value_str().map(|s| errors::MustNotSuspendReason {\n+            span: data.source_span,\n+            reason: s.as_str().to_string(),\n         });\n-        tcx.struct_span_lint_hir(\n+        tcx.emit_spanned_lint(\n             rustc_session::lint::builtin::MUST_NOT_SUSPEND,\n             hir_id,\n             data.source_span,\n-            msg,\n-            |lint| {\n-                // add span pointing to the offending yield/await\n-                lint.span_label(data.yield_span, \"the value is held across this suspend point\");\n-\n-                // Add optional reason note\n-                if let Some(note) = attr.value_str() {\n-                    // FIXME(guswynn): consider formatting this better\n-                    lint.span_note(data.source_span, note.as_str());\n-                }\n-\n-                // Add some quick suggestions on what to do\n-                // FIXME: can `drop` work as a suggestion here as well?\n-                lint.span_help(\n-                    data.source_span,\n-                    \"consider using a block (`{ ... }`) \\\n-                    to shrink the value's scope, ending before the suspend point\",\n-                )\n+            errors::MustNotSupend {\n+                yield_sp: data.yield_span,\n+                reason,\n+                src_sp: data.source_span,\n+                pre: data.descr_pre,\n+                def_path: tcx.def_path_str(def_id),\n+                post: data.descr_post,\n             },\n         );\n "}, {"sha": "5c4b1ead4e9b4519cfe45d228e63125e382a1cf6", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1,4 +1,6 @@\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(let_chains)]\n@@ -69,6 +71,7 @@ pub mod dump_mir;\n mod early_otherwise_branch;\n mod elaborate_box_derefs;\n mod elaborate_drops;\n+mod errors;\n mod ffi_unwind_calls;\n mod function_item_references;\n mod generator;\n@@ -105,6 +108,11 @@ use rustc_const_eval::transform::promote_consts;\n use rustc_const_eval::transform::validate;\n use rustc_mir_dataflow::rustc_peek;\n \n+use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_fluent_macro::fluent_messages;\n+\n+fluent_messages! { \"../messages.ftl\" }\n+\n pub fn provide(providers: &mut Providers) {\n     check_unsafety::provide(providers);\n     coverage::query::provide(providers);"}, {"sha": "dae01e41e5f3d3f466cf7729fabd258d1f537f51", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1,6 +1,6 @@\n //! Lowers intrinsic calls\n \n-use crate::MirPass;\n+use crate::{errors, MirPass};\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -310,11 +310,7 @@ fn resolve_rust_intrinsic<'tcx>(\n }\n \n fn validate_simd_shuffle<'tcx>(tcx: TyCtxt<'tcx>, args: &[Operand<'tcx>], span: Span) {\n-    match &args[2] {\n-        Operand::Constant(_) => {} // all good\n-        _ => {\n-            let msg = \"last argument of `simd_shuffle` is required to be a `const` item\";\n-            tcx.sess.span_err(span, msg);\n-        }\n+    if !matches!(args[2], Operand::Constant(_)) {\n+        tcx.sess.emit_err(errors::SimdShuffleLastConst { span });\n     }\n }"}, {"sha": "49e05efd39d5c36edb11ae2862f44d50e46eded4", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1262,6 +1262,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n+        let prev_span = self.prev_token.span;\n         let id = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n         generics.where_clause = self.parse_where_clause()?;\n@@ -1273,10 +1274,28 @@ impl<'a> Parser<'a> {\n             (thin_vec![], false)\n         } else {\n             self.parse_delim_comma_seq(Delimiter::Brace, |p| p.parse_enum_variant()).map_err(\n-                |mut e| {\n-                    e.span_label(id.span, \"while parsing this enum\");\n+                |mut err| {\n+                    err.span_label(id.span, \"while parsing this enum\");\n+                    if self.token == token::Colon {\n+                        let snapshot = self.create_snapshot_for_diagnostic();\n+                        self.bump();\n+                        match self.parse_ty() {\n+                            Ok(_) => {\n+                                err.span_suggestion_verbose(\n+                                    prev_span,\n+                                    \"perhaps you meant to use `struct` here\",\n+                                    \"struct\".to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            Err(e) => {\n+                                e.cancel();\n+                            }\n+                        }\n+                        self.restore_snapshot(snapshot);\n+                    }\n                     self.recover_stmt();\n-                    e\n+                    err\n                 },\n             )?\n         };"}, {"sha": "f27b8d9df1aa282bcfcc40dc832e3bea6b7b64a8", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -243,6 +243,39 @@ where\n                 // This will also visit substs if necessary, so we don't need to recurse.\n                 return self.visit_projection_ty(proj);\n             }\n+            ty::Alias(ty::Inherent, data) => {\n+                if self.def_id_visitor.skip_assoc_tys() {\n+                    // Visitors searching for minimal visibility/reachability want to\n+                    // conservatively approximate associated types like `Type::Alias`\n+                    // as visible/reachable even if `Type` is private.\n+                    // Ideally, associated types should be substituted in the same way as\n+                    // free type aliases, but this isn't done yet.\n+                    return ControlFlow::Continue(());\n+                }\n+\n+                self.def_id_visitor.visit_def_id(\n+                    data.def_id,\n+                    \"associated type\",\n+                    &LazyDefPathStr { def_id: data.def_id, tcx },\n+                )?;\n+\n+                struct LazyDefPathStr<'tcx> {\n+                    def_id: DefId,\n+                    tcx: TyCtxt<'tcx>,\n+                }\n+                impl<'tcx> fmt::Display for LazyDefPathStr<'tcx> {\n+                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                        write!(f, \"{}\", self.tcx.def_path_str(self.def_id))\n+                    }\n+                }\n+\n+                // This will also visit substs if necessary, so we don't need to recurse.\n+                return if self.def_id_visitor.shallow() {\n+                    ControlFlow::Continue(())\n+                } else {\n+                    data.substs.iter().try_for_each(|subst| subst.visit_with(self))\n+                };\n+            }\n             ty::Dynamic(predicates, ..) => {\n                 // All traits in the list are considered the \"primary\" part of the type\n                 // and are visited by shallow visitors."}, {"sha": "8fea3fc140d7296d6bb352a33d9bd11e6d3e530f", "filename": "compiler/rustc_trait_selection/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fmessages.ftl?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -20,3 +20,5 @@ trait_selection_negative_positive_conflict = found both positive and negative im\n     .negative_implementation_in_crate = negative implementation in crate `{$negative_impl_cname}`\n     .positive_implementation_here = positive implementation here\n     .positive_implementation_in_crate = positive implementation in crate `{$positive_impl_cname}`\n+\n+trait_selection_inherent_projection_normalization_overflow = overflow evaluating associated type `{$ty}`"}, {"sha": "54e22cc3d7fe28635e2bf4115bd8f204fca2ac01", "filename": "compiler/rustc_trait_selection/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -89,3 +89,11 @@ impl IntoDiagnostic<'_> for NegativePositiveConflict<'_> {\n         diag\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(trait_selection_inherent_projection_normalization_overflow)]\n+pub struct InherentProjectionNormalizationOverflow {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: String,\n+}"}, {"sha": "0ede32c753c6924ba22fa60e9d82c7a2d33abb47", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -33,7 +33,7 @@ pub(in crate::solve) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         ty::Dynamic(..)\n         | ty::Param(..)\n         | ty::Foreign(..)\n-        | ty::Alias(ty::Projection, ..)\n+        | ty::Alias(ty::Projection | ty::Inherent, ..)\n         | ty::Placeholder(..)\n         | ty::Bound(..)\n         | ty::Infer(_) => {"}, {"sha": "04b38edc1265fc783b1a6133623fef0b1a98d334", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -655,7 +655,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Placeholder(..) => Some(Err(NoSolution)),\n \n             ty::Infer(_) | ty::Bound(_, _) => bug!(\"unexpected type `{self_ty}`\"),"}, {"sha": "402b09419c87784070d12d205b309c054526832f", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -673,7 +673,7 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for OrphanChecker<'tcx> {\n             | ty::RawPtr(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Alias(ty::Projection, ..) => self.found_non_local_ty(ty),\n+            | ty::Alias(ty::Projection | ty::Inherent, ..) => self.found_non_local_ty(ty),\n \n             ty::Param(..) => self.found_param_ty(ty),\n "}, {"sha": "c9e2ed092d160b0cfd10d05f01eb1e3a808dd568", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1687,13 +1687,14 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ty::Tuple(..) => Some(10),\n                 ty::Param(..) => Some(11),\n                 ty::Alias(ty::Projection, ..) => Some(12),\n-                ty::Alias(ty::Opaque, ..) => Some(13),\n-                ty::Never => Some(14),\n-                ty::Adt(..) => Some(15),\n-                ty::Generator(..) => Some(16),\n-                ty::Foreign(..) => Some(17),\n-                ty::GeneratorWitness(..) => Some(18),\n-                ty::GeneratorWitnessMIR(..) => Some(19),\n+                ty::Alias(ty::Inherent, ..) => Some(13),\n+                ty::Alias(ty::Opaque, ..) => Some(14),\n+                ty::Never => Some(15),\n+                ty::Adt(..) => Some(16),\n+                ty::Generator(..) => Some(17),\n+                ty::Foreign(..) => Some(18),\n+                ty::GeneratorWitness(..) => Some(19),\n+                ty::GeneratorWitnessMIR(..) => Some(20),\n                 ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => None,\n             }\n         }"}, {"sha": "b162e5b8995db2f0e9ce4878442d4cbe60cfa056", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -49,7 +49,8 @@ pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::project::{normalize_projection_type, NormalizeExt};\n+pub use self::project::NormalizeExt;\n+pub use self::project::{normalize_inherent_projection, normalize_projection_type};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;"}, {"sha": "8e684b7ac239b38ee3697a474ba605254af8e906", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 161, "deletions": 2, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -16,6 +16,7 @@ use super::{\n };\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n+use crate::errors::InherentProjectionNormalizationOverflow;\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -370,10 +371,14 @@ pub(crate) fn needs_normalization<'tcx, T: TypeVisitable<TyCtxt<'tcx>>>(\n     reveal: Reveal,\n ) -> bool {\n     match reveal {\n-        Reveal::UserFacing => value\n-            .has_type_flags(ty::TypeFlags::HAS_TY_PROJECTION | ty::TypeFlags::HAS_CT_PROJECTION),\n+        Reveal::UserFacing => value.has_type_flags(\n+            ty::TypeFlags::HAS_TY_PROJECTION\n+                | ty::TypeFlags::HAS_TY_INHERENT\n+                | ty::TypeFlags::HAS_CT_PROJECTION,\n+        ),\n         Reveal::All => value.has_type_flags(\n             ty::TypeFlags::HAS_TY_PROJECTION\n+                | ty::TypeFlags::HAS_TY_INHERENT\n                 | ty::TypeFlags::HAS_TY_OPAQUE\n                 | ty::TypeFlags::HAS_CT_PROJECTION,\n         ),\n@@ -616,6 +621,51 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                 );\n                 normalized_ty\n             }\n+\n+            ty::Inherent if !data.has_escaping_bound_vars() => {\n+                // This branch is *mostly* just an optimization: when we don't\n+                // have escaping bound vars, we don't need to replace them with\n+                // placeholders (see branch below). *Also*, we know that we can\n+                // register an obligation to *later* project, since we know\n+                // there won't be bound vars there.\n+\n+                let data = data.fold_with(self);\n+\n+                // FIXME(inherent_associated_types): Do we need to honor `self.eager_inference_replacement`\n+                // here like `ty::Projection`?\n+                normalize_inherent_projection(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                )\n+            }\n+\n+            ty::Inherent => {\n+                let infcx = self.selcx.infcx;\n+                let (data, mapped_regions, mapped_types, mapped_consts) =\n+                    BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                let data = data.fold_with(self);\n+                let ty = normalize_inherent_projection(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                );\n+\n+                PlaceholderReplacer::replace_placeholders(\n+                    infcx,\n+                    mapped_regions,\n+                    mapped_types,\n+                    mapped_consts,\n+                    &self.universes,\n+                    ty,\n+                )\n+            }\n         }\n     }\n \n@@ -1204,6 +1254,115 @@ fn normalize_to_error<'a, 'tcx>(\n     Normalized { value: new_value, obligations: vec![trait_obligation] }\n }\n \n+/// Confirm and normalize the given inherent projection.\n+#[instrument(level = \"debug\", skip(selcx, param_env, cause, obligations))]\n+pub fn normalize_inherent_projection<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    alias_ty: ty::AliasTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Ty<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    if !tcx.recursion_limit().value_within_limit(depth) {\n+        // Halt compilation because it is important that overflows never be masked.\n+        tcx.sess.emit_fatal(InherentProjectionNormalizationOverflow {\n+            span: cause.span,\n+            ty: alias_ty.to_string(),\n+        });\n+    }\n+\n+    let substs = compute_inherent_assoc_ty_substs(\n+        selcx,\n+        param_env,\n+        alias_ty,\n+        cause.clone(),\n+        depth,\n+        obligations,\n+    );\n+\n+    // Register the obligations arising from the impl and from the associated type itself.\n+    let predicates = tcx.predicates_of(alias_ty.def_id).instantiate(tcx, substs);\n+    for (predicate, span) in predicates {\n+        let predicate = normalize_with_depth_to(\n+            selcx,\n+            param_env,\n+            cause.clone(),\n+            depth + 1,\n+            predicate,\n+            obligations,\n+        );\n+\n+        let nested_cause = ObligationCause::new(\n+            cause.span,\n+            cause.body_id,\n+            // FIXME(inherent_associated_types): Since we can't pass along the self type to the\n+            // cause code, inherent projections will be printed with identity substitutions in\n+            // diagnostics which is not ideal.\n+            // Consider creating separate cause codes for this specific situation.\n+            if span.is_dummy() {\n+                super::ItemObligation(alias_ty.def_id)\n+            } else {\n+                super::BindingObligation(alias_ty.def_id, span)\n+            },\n+        );\n+\n+        obligations.push(Obligation::with_depth(\n+            tcx,\n+            nested_cause,\n+            depth + 1,\n+            param_env,\n+            predicate,\n+        ));\n+    }\n+\n+    let ty = tcx.type_of(alias_ty.def_id).subst(tcx, substs);\n+\n+    let mut ty = selcx.infcx.resolve_vars_if_possible(ty);\n+    if ty.has_projections() {\n+        ty = normalize_with_depth_to(selcx, param_env, cause.clone(), depth + 1, ty, obligations);\n+    }\n+\n+    ty\n+}\n+\n+pub fn compute_inherent_assoc_ty_substs<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    alias_ty: ty::AliasTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> ty::SubstsRef<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    let impl_def_id = tcx.parent(alias_ty.def_id);\n+    let impl_substs = selcx.infcx.fresh_substs_for_item(cause.span, impl_def_id);\n+\n+    let impl_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n+    let impl_ty =\n+        normalize_with_depth_to(selcx, param_env, cause.clone(), depth + 1, impl_ty, obligations);\n+\n+    // Infer the generic parameters of the impl by unifying the\n+    // impl type with the self type of the projection.\n+    let self_ty = alias_ty.self_ty();\n+    match selcx.infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, impl_ty, self_ty) {\n+        Ok(mut ok) => obligations.append(&mut ok.obligations),\n+        Err(_) => {\n+            tcx.sess.delay_span_bug(\n+                cause.span,\n+                format!(\n+                    \"{self_ty:?} was a subtype of {impl_ty:?} during selection but now it is not\"\n+                ),\n+            );\n+        }\n+    }\n+\n+    alias_ty.rebase_substs_onto_impl(impl_substs, tcx)\n+}\n+\n enum Projected<'tcx> {\n     Progress(Progress<'tcx>),\n     NoProgress(ty::Term<'tcx>),"}, {"sha": "8bf934cb78ae1545fdfaa28162541d208ab4d41e", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -257,11 +257,11 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n \n             ty::Opaque => ty.try_super_fold_with(self)?,\n \n-            ty::Projection => {\n+            ty::Projection | ty::Inherent => {\n                 // See note in `rustc_trait_selection::traits::project`\n \n-                let tcx = self.infcx.tcx;\n                 let infcx = self.infcx;\n+                let tcx = infcx.tcx;\n                 // Just an optimization: When we don't have escaping bound vars,\n                 // we don't need to replace them with placeholders.\n                 let (data, maps) = if data.has_escaping_bound_vars() {\n@@ -276,12 +276,15 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n                 // so we cannot canonicalize it.\n-                let c_data = self\n-                    .infcx\n+                let c_data = infcx\n                     .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                let result = tcx.normalize_projection_ty(c_data)?;\n+                let result = match kind {\n+                    ty::Projection => tcx.normalize_projection_ty(c_data),\n+                    ty::Inherent => tcx.normalize_inherent_projection_ty(c_data),\n+                    _ => unreachable!(),\n+                }?;\n                 // We don't expect ambiguity.\n                 if result.is_ambiguous() {\n                     // Rustdoc normalizes possibly not well-formed types, so only\n@@ -294,8 +297,8 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                     }\n                     return Err(NoSolution);\n                 }\n-                let InferOk { value: result, obligations } =\n-                    self.infcx.instantiate_query_response_and_region_obligations(\n+                let InferOk { value: result, obligations } = infcx\n+                    .instantiate_query_response_and_region_obligations(\n                         self.cause,\n                         self.param_env,\n                         &orig_values,"}, {"sha": "a8fb55df2d3029cf04a93a4fb143746e5300f9b9", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -498,7 +498,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // this trait and type.\n                 }\n                 ty::Param(..)\n-                | ty::Alias(ty::Projection, ..)\n+                | ty::Alias(ty::Projection | ty::Inherent, ..)\n                 | ty::Placeholder(..)\n                 | ty::Bound(..) => {\n                     // In these cases, we don't know what the actual"}, {"sha": "616187b69dde4bd89cbb05cd00599f585212cddc", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1268,7 +1268,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // If we have a projection type, make sure to normalize it so we replace it\n                 // with a fresh infer variable\n-                ty::Alias(ty::Projection, ..) => {\n+                ty::Alias(ty::Projection | ty::Inherent, ..) => {\n                     let predicate = normalize_with_depth_to(\n                         self,\n                         obligation.param_env,"}, {"sha": "e4f5a84f4244e1a8a02eefefd5cdd6d70106aa1f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -2315,7 +2315,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Bound(..)\n             | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble constituent types of unexpected type: {:?}\", t);"}, {"sha": "086ab32b520076946de1e1efcd46cff83e66f8d8", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -58,15 +58,8 @@ pub fn obligations<'tcx>(\n         GenericArgKind::Lifetime(..) => return Some(Vec::new()),\n     };\n \n-    let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n-        param_env,\n-        body_id,\n-        span,\n-        out: vec![],\n-        recursion_depth,\n-        item: None,\n-    };\n+    let mut wf =\n+        WfPredicates { infcx, param_env, body_id, span, out: vec![], recursion_depth, item: None };\n     wf.compute(arg);\n     debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", arg, body_id, wf.out);\n \n@@ -91,7 +84,7 @@ pub fn unnormalized_obligations<'tcx>(\n     debug_assert_eq!(arg, infcx.resolve_vars_if_possible(arg));\n \n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id: CRATE_DEF_ID,\n         span: DUMMY_SP,\n@@ -116,7 +109,7 @@ pub fn trait_obligations<'tcx>(\n     item: &'tcx hir::Item<'tcx>,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id,\n         span,\n@@ -138,7 +131,7 @@ pub fn predicate_obligations<'tcx>(\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates {\n-        tcx: infcx.tcx,\n+        infcx,\n         param_env,\n         body_id,\n         span,\n@@ -190,8 +183,8 @@ pub fn predicate_obligations<'tcx>(\n     wf.normalize(infcx)\n }\n \n-struct WfPredicates<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+struct WfPredicates<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: LocalDefId,\n     span: Span,\n@@ -290,9 +283,9 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     }\n }\n \n-impl<'tcx> WfPredicates<'tcx> {\n+impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n+        self.infcx.tcx\n     }\n \n     fn cause(&self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n@@ -325,7 +318,7 @@ impl<'tcx> WfPredicates<'tcx> {\n \n     /// Pushes the obligations required for `trait_ref` to be WF into `self.out`.\n     fn compute_trait_pred(&mut self, trait_pred: &ty::TraitPredicate<'tcx>, elaborate: Elaborate) {\n-        let tcx = self.tcx;\n+        let tcx = self.tcx();\n         let trait_ref = &trait_pred.trait_ref;\n \n         // Negative trait predicates don't require supertraits to hold, just\n@@ -369,7 +362,6 @@ impl<'tcx> WfPredicates<'tcx> {\n             self.out.extend(obligations);\n         }\n \n-        let tcx = self.tcx();\n         self.out.extend(\n             trait_ref\n                 .substs\n@@ -436,13 +428,45 @@ impl<'tcx> WfPredicates<'tcx> {\n         let obligations = self.nominal_obligations_without_const(data.def_id, data.substs);\n         self.out.extend(obligations);\n \n+        self.compute_projection_substs(data.substs);\n+    }\n+\n+    fn compute_inherent_projection(&mut self, data: ty::AliasTy<'tcx>) {\n+        // An inherent projection is well-formed if\n+        //\n+        // (a) its predicates hold (*)\n+        // (b) its substs are wf\n+        //\n+        // (*) The predicates of an inherent associated type include the\n+        //     predicates of the impl that it's contained in.\n+\n+        if !data.self_ty().has_escaping_bound_vars() {\n+            // FIXME(inherent_associated_types): Should this happen inside of a snapshot?\n+            // FIXME(inherent_associated_types): This is incompatible with the new solver and lazy norm!\n+            let substs = traits::project::compute_inherent_assoc_ty_substs(\n+                &mut traits::SelectionContext::new(self.infcx),\n+                self.param_env,\n+                data,\n+                self.cause(traits::WellFormed(None)),\n+                self.recursion_depth,\n+                &mut self.out,\n+            );\n+            // Inherent projection types do not require const predicates.\n+            let obligations = self.nominal_obligations_without_const(data.def_id, substs);\n+            self.out.extend(obligations);\n+        }\n+\n+        self.compute_projection_substs(data.substs);\n+    }\n+\n+    fn compute_projection_substs(&mut self, substs: SubstsRef<'tcx>) {\n         let tcx = self.tcx();\n         let cause = self.cause(traits::WellFormed(None));\n         let param_env = self.param_env;\n         let depth = self.recursion_depth;\n \n         self.out.extend(\n-            data.substs\n+            substs\n                 .iter()\n                 .filter(|arg| {\n                     matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..))\n@@ -464,9 +488,9 @@ impl<'tcx> WfPredicates<'tcx> {\n         if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n             let trait_ref =\n-                ty::TraitRef::from_lang_item(self.tcx, LangItem::Sized, cause.span, [subty]);\n+                ty::TraitRef::from_lang_item(self.tcx(), LangItem::Sized, cause.span, [subty]);\n             self.out.push(traits::Obligation::with_depth(\n-                self.tcx,\n+                self.tcx(),\n                 cause,\n                 self.recursion_depth,\n                 self.param_env,\n@@ -605,6 +629,10 @@ impl<'tcx> WfPredicates<'tcx> {\n                     walker.skip_current_subtree(); // Subtree handled by compute_projection.\n                     self.compute_projection(data);\n                 }\n+                ty::Alias(ty::Inherent, data) => {\n+                    walker.skip_current_subtree(); // Subtree handled by compute_inherent_projection.\n+                    self.compute_inherent_projection(data);\n+                }\n \n                 ty::Adt(def, substs) => {\n                     // WfNominalType\n@@ -697,7 +725,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                     // All of the requirements on type parameters\n                     // have already been checked for `impl Trait` in\n                     // return position. We do need to check type-alias-impl-trait though.\n-                    if self.tcx.is_type_alias_impl_trait(def_id) {\n+                    if self.tcx().is_type_alias_impl_trait(def_id) {\n                         let obligations = self.nominal_obligations(def_id, substs);\n                         self.out.extend(obligations);\n                     }\n@@ -767,15 +795,15 @@ impl<'tcx> WfPredicates<'tcx> {\n         substs: SubstsRef<'tcx>,\n         remap_constness: bool,\n     ) -> Vec<traits::PredicateObligation<'tcx>> {\n-        let predicates = self.tcx.predicates_of(def_id);\n+        let predicates = self.tcx().predicates_of(def_id);\n         let mut origins = vec![def_id; predicates.predicates.len()];\n         let mut head = predicates;\n         while let Some(parent) = head.parent {\n-            head = self.tcx.predicates_of(parent);\n+            head = self.tcx().predicates_of(parent);\n             origins.extend(iter::repeat(parent).take(head.predicates.len()));\n         }\n \n-        let predicates = predicates.instantiate(self.tcx, substs);\n+        let predicates = predicates.instantiate(self.tcx(), substs);\n         trace!(\"{:#?}\", predicates);\n         debug_assert_eq!(predicates.predicates.len(), origins.len());\n \n@@ -788,10 +816,10 @@ impl<'tcx> WfPredicates<'tcx> {\n                 };\n                 let cause = self.cause(code);\n                 if remap_constness {\n-                    pred = pred.without_const(self.tcx);\n+                    pred = pred.without_const(self.tcx());\n                 }\n                 traits::Obligation::with_depth(\n-                    self.tcx,\n+                    self.tcx(),\n                     cause,\n                     self.recursion_depth,\n                     self.param_env,\n@@ -856,7 +884,7 @@ impl<'tcx> WfPredicates<'tcx> {\n         // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n         // am looking forward to the future here.\n         if !data.has_escaping_bound_vars() && !region.has_escaping_bound_vars() {\n-            let implicit_bounds = object_region_bounds(self.tcx, data);\n+            let implicit_bounds = object_region_bounds(self.tcx(), data);\n \n             let explicit_bound = region;\n \n@@ -866,7 +894,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                 let outlives =\n                     ty::Binder::dummy(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n                 self.out.push(traits::Obligation::with_depth(\n-                    self.tcx,\n+                    self.tcx(),\n                     cause,\n                     self.recursion_depth,\n                     self.param_env,"}, {"sha": "2f9e480d8bd529dc1fff1892ba61e3859bf28296", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -372,6 +372,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                     substitution: substs.lower_into(interner),\n                 }))\n             }\n+            ty::Alias(ty::Inherent, _) => unimplemented!(),\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                 chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n                     opaque_ty_id: chalk_ir::OpaqueTyId(def_id),"}, {"sha": "36d80a06ee7e9edc13c4cf94bfa3fc8f2121f6ca", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -10,7 +10,7 @@ use rustc_trait_selection::traits::{self, ObligationCause, SelectionContext};\n use std::sync::atomic::Ordering;\n \n pub(crate) fn provide(p: &mut Providers) {\n-    *p = Providers { normalize_projection_ty, ..*p };\n+    *p = Providers { normalize_projection_ty, normalize_inherent_projection_ty, ..*p };\n }\n \n fn normalize_projection_ty<'tcx>(\n@@ -42,3 +42,30 @@ fn normalize_projection_ty<'tcx>(\n         },\n     )\n }\n+\n+fn normalize_inherent_projection_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    goal: CanonicalProjectionGoal<'tcx>,\n+) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, NormalizationResult<'tcx>>>, NoSolution> {\n+    debug!(\"normalize_provider(goal={:#?})\", goal);\n+\n+    tcx.infer_ctxt().enter_canonical_trait_query(\n+        &goal,\n+        |ocx, ParamEnvAnd { param_env, value: goal }| {\n+            let selcx = &mut SelectionContext::new(ocx.infcx);\n+            let cause = ObligationCause::dummy();\n+            let mut obligations = vec![];\n+            let answer = traits::normalize_inherent_projection(\n+                selcx,\n+                param_env,\n+                goal,\n+                cause,\n+                0,\n+                &mut obligations,\n+            );\n+            ocx.register_obligations(obligations);\n+\n+            Ok(NormalizationResult { normalized_ty: answer })\n+        },\n+    )\n+}"}, {"sha": "eb3c21163ab2aef6ac4434429ee8c8b80ad34f6c", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -194,21 +194,18 @@ fn resolve_associated_item<'tcx>(\n             })\n         }\n         traits::ImplSource::Future(future_data) => {\n-            if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::poll {\n-                // For compiler developers who'd like to add new items to `Future`,\n-                // you either need to generate a shim body, or perhaps return\n-                // `InstanceDef::Item` pointing to a trait default method body if\n-                // it is given a default implementation by the trait.\n-                span_bug!(\n-                    tcx.def_span(future_data.generator_def_id),\n-                    \"no definition for `{trait_ref}::{}` for built-in async generator type\",\n-                    tcx.item_name(trait_item_id)\n-                )\n+            if Some(trait_item_id) == tcx.lang_items().future_poll_fn() {\n+                // `Future::poll` is generated by the compiler.\n+                Some(Instance {\n+                    def: ty::InstanceDef::Item(future_data.generator_def_id),\n+                    substs: future_data.substs,\n+                })\n+            } else {\n+                // All other methods are default methods of the `Future` trait.\n+                // (this assumes that `ImplSource::Future` is only used for methods on `Future`)\n+                debug_assert!(tcx.impl_defaultness(trait_item_id).has_value());\n+                Some(Instance::new(trait_item_id, rcvr_substs))\n             }\n-            Some(Instance {\n-                def: ty::InstanceDef::Item(future_data.generator_def_id),\n-                substs: future_data.substs,\n-            })\n         }\n         traits::ImplSource::Closure(closure_data) => {\n             if cfg!(debug_assertions)"}, {"sha": "7e5a4d1c735324cccdabcd7ad5c4012820e90b72", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -229,50 +229,53 @@ bitflags! {\n \n         /// Does this have `Projection`?\n         const HAS_TY_PROJECTION           = 1 << 10;\n+        /// Does this have `Inherent`?\n+        const HAS_TY_INHERENT             = 1 << 11;\n         /// Does this have `Opaque`?\n-        const HAS_TY_OPAQUE               = 1 << 11;\n+        const HAS_TY_OPAQUE               = 1 << 12;\n         /// Does this have `ConstKind::Unevaluated`?\n-        const HAS_CT_PROJECTION           = 1 << 12;\n+        const HAS_CT_PROJECTION           = 1 << 13;\n \n         /// Could this type be normalized further?\n         const HAS_PROJECTION              = TypeFlags::HAS_TY_PROJECTION.bits\n                                           | TypeFlags::HAS_TY_OPAQUE.bits\n+                                          | TypeFlags::HAS_TY_INHERENT.bits\n                                           | TypeFlags::HAS_CT_PROJECTION.bits;\n \n         /// Is an error type/const reachable?\n-        const HAS_ERROR                   = 1 << 13;\n+        const HAS_ERROR                   = 1 << 14;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS            = 1 << 14;\n+        const HAS_FREE_REGIONS            = 1 << 15;\n \n         /// Does this have any `ReLateBound` regions?\n-        const HAS_RE_LATE_BOUND           = 1 << 15;\n+        const HAS_RE_LATE_BOUND           = 1 << 16;\n         /// Does this have any `Bound` types?\n-        const HAS_TY_LATE_BOUND           = 1 << 16;\n+        const HAS_TY_LATE_BOUND           = 1 << 17;\n         /// Does this have any `ConstKind::Bound` consts?\n-        const HAS_CT_LATE_BOUND           = 1 << 17;\n+        const HAS_CT_LATE_BOUND           = 1 << 18;\n         /// Does this have any bound variables?\n         /// Used to check if a global bound is safe to evaluate.\n         const HAS_LATE_BOUND              = TypeFlags::HAS_RE_LATE_BOUND.bits\n                                           | TypeFlags::HAS_TY_LATE_BOUND.bits\n                                           | TypeFlags::HAS_CT_LATE_BOUND.bits;\n \n         /// Does this have any `ReErased` regions?\n-        const HAS_RE_ERASED               = 1 << 18;\n+        const HAS_RE_ERASED               = 1 << 19;\n \n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n-        const STILL_FURTHER_SPECIALIZABLE = 1 << 19;\n+        const STILL_FURTHER_SPECIALIZABLE = 1 << 20;\n \n         /// Does this value have `InferTy::FreshTy/FreshIntTy/FreshFloatTy`?\n-        const HAS_TY_FRESH                = 1 << 20;\n+        const HAS_TY_FRESH                = 1 << 21;\n \n         /// Does this value have `InferConst::Fresh`?\n-        const HAS_CT_FRESH                = 1 << 21;\n+        const HAS_CT_FRESH                = 1 << 22;\n \n         /// Does this have `Generator` or `GeneratorWitness`?\n-        const HAS_TY_GENERATOR            = 1 << 22;\n+        const HAS_TY_GENERATOR            = 1 << 23;\n     }\n }\n "}, {"sha": "f7344bacc028cfabde19ed343575dc54a9020616", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -37,6 +37,7 @@ pub enum DynKind {\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum AliasKind {\n     Projection,\n+    Inherent,\n     Opaque,\n }\n "}, {"sha": "79624703a4cf7576a88d43386e517fd9af6ea80d", "filename": "library/std/src/personality/dwarf/eh.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -47,6 +47,7 @@ pub enum EHAction {\n     None,\n     Cleanup(usize),\n     Catch(usize),\n+    Filter(usize),\n     Terminate,\n }\n \n@@ -142,9 +143,11 @@ unsafe fn interpret_cs_action(\n         let ttype_index = action_reader.read_sleb128();\n         if ttype_index == 0 {\n             EHAction::Cleanup(lpad)\n-        } else {\n+        } else if ttype_index > 0 {\n             // Stop unwinding Rust panics at catch_unwind.\n             EHAction::Catch(lpad)\n+        } else {\n+            EHAction::Filter(lpad)\n         }\n     }\n }"}, {"sha": "82edb11cbd1461349aea5716f3b2fead13605907", "filename": "library/std/src/personality/gcc.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -135,7 +135,7 @@ cfg_if::cfg_if! {\n                     EHAction::None | EHAction::Cleanup(_) => {\n                         return continue_unwind(exception_object, context);\n                     }\n-                    EHAction::Catch(_) => {\n+                    EHAction::Catch(_) | EHAction::Filter(_) => {\n                         // EHABI requires the personality routine to update the\n                         // SP value in the barrier cache of the exception object.\n                         (*exception_object).private[5] =\n@@ -147,7 +147,8 @@ cfg_if::cfg_if! {\n             } else {\n                 match eh_action {\n                     EHAction::None => return continue_unwind(exception_object, context),\n-                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                    EHAction::Filter(_) if state & uw::_US_FORCE_UNWIND as c_int != 0 => return continue_unwind(exception_object, context),\n+                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) | EHAction::Filter(lpad) => {\n                         uw::_Unwind_SetGR(\n                             context,\n                             UNWIND_DATA_REG.0,\n@@ -201,13 +202,15 @@ cfg_if::cfg_if! {\n             if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n                 match eh_action {\n                     EHAction::None | EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n-                    EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n+                    EHAction::Catch(_) | EHAction::Filter(_) => uw::_URC_HANDLER_FOUND,\n                     EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n                 }\n             } else {\n                 match eh_action {\n                     EHAction::None => uw::_URC_CONTINUE_UNWIND,\n-                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                    // Forced unwinding hits a terminate action.\n+                    EHAction::Filter(_) if actions as i32 & uw::_UA_FORCE_UNWIND as i32 != 0 => uw::_URC_CONTINUE_UNWIND,\n+                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) | EHAction::Filter(lpad) => {\n                         uw::_Unwind_SetGR(\n                             context,\n                             UNWIND_DATA_REG.0,"}, {"sha": "baf2b0a8585297e1654dbf08112eb83fad7c0868", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -556,7 +556,10 @@ where\n                 WherePredicate::EqPredicate { lhs, rhs, bound_params } => {\n                     match *lhs {\n                         Type::QPath(box QPathData {\n-                            ref assoc, ref self_type, ref trait_, ..\n+                            ref assoc,\n+                            ref self_type,\n+                            trait_: Some(ref trait_),\n+                            ..\n                         }) => {\n                             let ty = &*self_type;\n                             let mut new_trait = trait_.clone();"}, {"sha": "c852f9cca2bfde764fd4086449cdf143d5fe89a5", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -706,7 +706,12 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n \n     g.where_predicates.retain(|pred| match pred {\n         clean::WherePredicate::BoundPredicate {\n-            ty: clean::QPath(box clean::QPathData { self_type: clean::Generic(ref s), trait_, .. }),\n+            ty:\n+                clean::QPath(box clean::QPathData {\n+                    self_type: clean::Generic(ref s),\n+                    trait_: Some(trait_),\n+                    ..\n+                }),\n             bounds,\n             ..\n         } => !(bounds.is_empty() || *s == kw::SelfUpper && trait_.def_id() == trait_did),"}, {"sha": "657f3c9ec4577fc598a237069a727de4cec02873", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -441,7 +441,7 @@ fn clean_projection<'tcx>(\n         assoc: projection_to_path_segment(ty, cx),\n         should_show_cast,\n         self_type,\n-        trait_,\n+        trait_: Some(trait_),\n     }))\n }\n \n@@ -1330,7 +1330,13 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                 let mut bounds: Vec<GenericBound> = Vec::new();\n                 generics.where_predicates.retain_mut(|pred| match *pred {\n                     WherePredicate::BoundPredicate {\n-                        ty: QPath(box QPathData { ref assoc, ref self_type, ref trait_, .. }),\n+                        ty:\n+                            QPath(box QPathData {\n+                                ref assoc,\n+                                ref self_type,\n+                                trait_: Some(ref trait_),\n+                                ..\n+                            }),\n                         bounds: ref mut pred_bounds,\n                         ..\n                     } => {\n@@ -1492,25 +1498,30 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n                 assoc: clean_path_segment(p.segments.last().expect(\"segments were empty\"), cx),\n                 should_show_cast,\n                 self_type,\n-                trait_,\n+                trait_: Some(trait_),\n             }))\n         }\n         hir::QPath::TypeRelative(qself, segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            let res = match ty.kind() {\n+            let self_type = clean_ty(qself, cx);\n+\n+            let (trait_, should_show_cast) = match ty.kind() {\n                 ty::Alias(ty::Projection, proj) => {\n-                    Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id)\n+                    let res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n+                    let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n+                    register_res(cx, trait_.res);\n+                    let self_def_id = res.opt_def_id();\n+                    let should_show_cast =\n+                        compute_should_show_cast(self_def_id, &trait_, &self_type);\n+\n+                    (Some(trait_), should_show_cast)\n                 }\n+                ty::Alias(ty::Inherent, _) => (None, false),\n                 // Rustdoc handles `ty::Error`s by turning them into `Type::Infer`s.\n                 ty::Error(_) => return Type::Infer,\n-                // Otherwise, this is an inherent associated type.\n-                _ => return clean_middle_ty(ty::Binder::dummy(ty), cx, None),\n+                _ => bug!(\"clean: expected associated type, found `{ty:?}`\"),\n             };\n-            let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n-            register_res(cx, trait_.res);\n-            let self_def_id = res.opt_def_id();\n-            let self_type = clean_ty(qself, cx);\n-            let should_show_cast = compute_should_show_cast(self_def_id, &trait_, &self_type);\n+\n             Type::QPath(Box::new(QPathData {\n                 assoc: clean_path_segment(segment, cx),\n                 should_show_cast,\n@@ -1836,6 +1847,29 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             clean_projection(bound_ty.rebind(*data), cx, parent_def_id)\n         }\n \n+        ty::Alias(ty::Inherent, alias_ty) => {\n+            let alias_ty = bound_ty.rebind(alias_ty);\n+            let self_type = clean_middle_ty(alias_ty.map_bound(|ty| ty.self_ty()), cx, None);\n+\n+            Type::QPath(Box::new(QPathData {\n+                assoc: PathSegment {\n+                    name: cx.tcx.associated_item(alias_ty.skip_binder().def_id).name,\n+                    args: GenericArgs::AngleBracketed {\n+                        args: substs_to_args(\n+                            cx,\n+                            alias_ty.map_bound(|ty| ty.substs.as_slice()),\n+                            true,\n+                        )\n+                        .into(),\n+                        bindings: Default::default(),\n+                    },\n+                },\n+                should_show_cast: false,\n+                self_type,\n+                trait_: None,\n+            }))\n+        }\n+\n         ty::Param(ref p) => {\n             if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n                 ImplTrait(bounds)"}, {"sha": "38664c3e359a6b5fc44260599db35812cadd8599", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1660,7 +1660,7 @@ impl Type {\n \n     pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n         if let QPath(box QPathData { self_type, trait_, assoc, .. }) = self {\n-            Some((self_type, trait_.def_id(), assoc.clone()))\n+            Some((self_type, trait_.as_ref()?.def_id(), assoc.clone()))\n         } else {\n             None\n         }\n@@ -1704,7 +1704,7 @@ pub(crate) struct QPathData {\n     pub self_type: Type,\n     /// FIXME: compute this field on demand.\n     pub should_show_cast: bool,\n-    pub trait_: Path,\n+    pub trait_: Option<Path>,\n }\n \n /// A primitive (aka, builtin) type."}, {"sha": "d963d6092c48f5b201fbc985ded3e589f7698916", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1116,14 +1116,17 @@ fn fmt_type<'cx>(\n             ref trait_,\n             should_show_cast,\n         }) => {\n+            // FIXME(inherent_associated_types): Once we support non-ADT self-types (#106719),\n+            // we need to surround them with angle brackets in some cases (e.g. `<dyn \u2026>::P`).\n+\n             if f.alternate() {\n-                if should_show_cast {\n+                if let Some(trait_) = trait_ && should_show_cast {\n                     write!(f, \"<{:#} as {:#}>::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n                     write!(f, \"{:#}::\", self_type.print(cx))?\n                 }\n             } else {\n-                if should_show_cast {\n+                if let Some(trait_) = trait_ && should_show_cast {\n                     write!(f, \"&lt;{} as {}&gt;::\", self_type.print(cx), trait_.print(cx))?\n                 } else {\n                     write!(f, \"{}::\", self_type.print(cx))?\n@@ -1139,15 +1142,36 @@ fn fmt_type<'cx>(\n             //        the ugliness comes from inlining across crates where\n             //        everything comes in as a fully resolved QPath (hard to\n             //        look at).\n-            if !f.alternate() && let Ok((url, _, path)) = href(trait_.def_id(), cx) {\n-                write!(\n-                    f,\n-                    \"<a class=\\\"associatedtype\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n-                                title=\\\"type {path}::{name}\\\">{name}</a>\",\n-                    shortty = ItemType::AssocType,\n-                    name = assoc.name,\n-                    path = join_with_double_colon(&path),\n-                )\n+            if !f.alternate() {\n+                // FIXME(inherent_associated_types): We always link to the very first associated\n+                // type (in respect to source order) that bears the given name (`assoc.name`) and that is\n+                // affiliated with the computed `DefId`. This is obviously incorrect when we have\n+                // multiple impl blocks. Ideally, we would thread the `DefId` of the assoc ty itself\n+                // through here and map it to the corresponding HTML ID that was generated by\n+                // `render::Context::derive_id` when the impl blocks were rendered.\n+                // There is no such mapping unfortunately.\n+                // As a hack, we could badly imitate `derive_id` here by keeping *count* when looking\n+                // for the assoc ty `DefId` in `tcx.associated_items(self_ty_did).in_definition_order()`\n+                // considering privacy, `doc(hidden)`, etc.\n+                // I don't feel like that right now :cold_sweat:.\n+\n+                let parent_href = match trait_ {\n+                    Some(trait_) => href(trait_.def_id(), cx).ok(),\n+                    None => self_type.def_id(cx.cache()).and_then(|did| href(did, cx).ok()),\n+                };\n+\n+                if let Some((url, _, path)) = parent_href {\n+                    write!(\n+                        f,\n+                        \"<a class=\\\"associatedtype\\\" href=\\\"{url}#{shortty}.{name}\\\" \\\n+                                    title=\\\"type {path}::{name}\\\">{name}</a>\",\n+                        shortty = ItemType::AssocType,\n+                        name = assoc.name,\n+                        path = join_with_double_colon(&path),\n+                    )\n+                } else {\n+                    write!(f, \"{}\", assoc.name)\n+                }\n             } else {\n                 write!(f, \"{}\", assoc.name)\n             }?;"}, {"sha": "d6773169639c37e51b87d060a4d009e5678eb732", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -2202,7 +2202,9 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n             }\n             clean::Type::QPath(box clean::QPathData { self_type, trait_, .. }) => {\n                 work.push_back(self_type);\n-                process_path(trait_.def_id());\n+                if let Some(trait_) = trait_ {\n+                    process_path(trait_.def_id());\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "b1cef20b434a650d1e7235dbf8fbd702d0cb264e", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -574,7 +574,7 @@ impl FromWithTcx<clean::Type> for Type {\n                 name: assoc.name.to_string(),\n                 args: Box::new(assoc.args.into_tcx(tcx)),\n                 self_type: Box::new(self_type.into_tcx(tcx)),\n-                trait_: trait_.into_tcx(tcx),\n+                trait_: trait_.map(|trait_| trait_.into_tcx(tcx)),\n             },\n         }\n     }"}, {"sha": "3556834071fc964272e902fbdf3d706b5780cdad", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -8,7 +8,7 @@ use serde::{Deserialize, Serialize};\n use std::path::PathBuf;\n \n /// rustdoc format-version.\n-pub const FORMAT_VERSION: u32 = 24;\n+pub const FORMAT_VERSION: u32 = 25;\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n /// about the language items in the local crate, as well as info about external items to allow\n@@ -581,13 +581,15 @@ pub enum Type {\n         #[serde(rename = \"type\")]\n         type_: Box<Type>,\n     },\n-    /// `<Type as Trait>::Name` or associated types like `T::Item` where `T: Iterator`\n+    /// Associated types like `<Type as Trait>::Name` and `T::Item` where\n+    /// `T: Iterator` or inherent associated types like `Struct::Name`.\n     QualifiedPath {\n         name: String,\n         args: Box<GenericArgs>,\n         self_type: Box<Type>,\n+        /// `None` iff this is an *inherent* associated type.\n         #[serde(rename = \"trait\")]\n-        trait_: Path,\n+        trait_: Option<Path>,\n     },\n }\n "}, {"sha": "b27ffe73ffda442d153333d8a92bcd5b1e91de1f", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1424,6 +1424,7 @@ fn ty_auto_deref_stability<'tcx>(\n                 continue;\n             },\n             ty::Param(_) => TyPosition::new_deref_stable_for_result(precedence, ty),\n+            ty::Alias(ty::Inherent, _) => unreachable!(\"inherent projection should have been normalized away above\"),\n             ty::Alias(ty::Projection, _) if ty.has_non_region_param() => {\n                 TyPosition::new_deref_stable_for_result(precedence, ty)\n             },"}, {"sha": "bf8a64acf08d69237d717d1745085a0f2f8e7cb2", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -273,7 +273,9 @@ impl<'a> Validator<'a> {\n             Type::QualifiedPath { name: _, args, self_type, trait_ } => {\n                 self.check_generic_args(&**args);\n                 self.check_type(&**self_type);\n-                self.check_path(trait_, PathKind::Trait);\n+                if let Some(trait_) = trait_ {\n+                    self.check_path(trait_, PathKind::Trait);\n+                }\n             }\n         }\n     }"}, {"sha": "4e5d8dc063241af714e1d057ba815cf453a93c26", "filename": "tests/codegen/vec-shrink-panik.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fcodegen%2Fvec-shrink-panik.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fcodegen%2Fvec-shrink-panik.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fvec-shrink-panik.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -25,7 +25,7 @@ pub fn issue71861(vec: Vec<u32>) -> Box<[u32]> {\n \n     // Call to panic_cannot_unwind in case of double-panic is expected\n     // on LLVM 16 and older, but other panics are not.\n-    // CHECK: cleanup\n+    // CHECK: filter\n     // old-NEXT: ; call core::panicking::panic_cannot_unwind\n     // old-NEXT: panic_cannot_unwind\n \n@@ -40,7 +40,7 @@ pub fn issue75636<'a>(iter: &[&'a str]) -> Box<[&'a str]> {\n \n     // Call to panic_cannot_unwind in case of double-panic is expected,\n     // on LLVM 16 and older, but other panics are not.\n-    // CHECK: cleanup\n+    // CHECK: filter\n     // old-NEXT: ; call core::panicking::panic_cannot_unwind\n     // old-NEXT: panic_cannot_unwind\n "}, {"sha": "871621520b910086d55e71940ab503aa368a987d", "filename": "tests/run-make/forced-unwind-terminate-pof/Makefile", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Frun-make%2Fforced-unwind-terminate-pof%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Frun-make%2Fforced-unwind-terminate-pof%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fforced-unwind-terminate-pof%2FMakefile?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,9 @@\n+# ignore-cross-compile\n+# only-linux\n+include ../tools.mk\n+\n+all: foo\n+\t$(call RUN,foo) | $(CGREP) -v \"cannot unwind\"\n+\n+foo: foo.rs\n+\t$(RUSTC) $<"}, {"sha": "0a51287313f6e97a8016426f3066ecb987f3e062", "filename": "tests/run-make/forced-unwind-terminate-pof/foo.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Frun-make%2Fforced-unwind-terminate-pof%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Frun-make%2Fforced-unwind-terminate-pof%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fforced-unwind-terminate-pof%2Ffoo.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,17 @@\n+// Tests that forced unwind through POF Rust frames wouldn't trigger our terminating guards.\n+\n+#![feature(c_unwind)]\n+#![no_main]\n+\n+extern \"C-unwind\" {\n+    fn pthread_exit(v: *mut core::ffi::c_void) -> !;\n+}\n+\n+unsafe extern \"C\" fn call_pthread_exit() {\n+    pthread_exit(core::ptr::null_mut());\n+}\n+\n+#[no_mangle]\n+unsafe extern \"C-unwind\" fn main(_argc: core::ffi::c_int, _argv: *mut *mut core::ffi::c_char) {\n+    call_pthread_exit();\n+}"}, {"sha": "9bda0acaf83fe7808a3e00eac2b1f1679278c99f", "filename": "tests/rustdoc/inherent-projections.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Frustdoc%2Finherent-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Frustdoc%2Finherent-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finherent-projections.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,44 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// @has 'inherent_projections/fn.create.html'\n+// @has - '//pre[@class=\"rust item-decl\"]' \"create() -> Owner::Metadata\"\n+// @has - '//pre[@class=\"rust item-decl\"]//a[@class=\"associatedtype\"]/@href' 'struct.Owner.html#associatedtype.Metadata'\n+pub fn create() -> Owner::Metadata {}\n+\n+pub struct Owner;\n+\n+impl Owner {\n+    pub type Metadata = ();\n+}\n+\n+// Make sure we handle bound vars correctly.\n+// @has 'inherent_projections/type.User.html' '//pre[@class=\"rust item-decl\"]' \"for<'a> fn(_: Carrier<'a>::Focus)\"\n+pub type User = for<'a> fn(Carrier<'a>::Focus);\n+\n+pub struct Carrier<'a>(&'a ());\n+\n+impl<'a> Carrier<'a> {\n+    pub type Focus = &'a mut i32;\n+}\n+\n+////////////////////////////////////////\n+\n+// FIXME(inherent_associated_types): Below we link to `Proj` but we should link to `Proj-1`.\n+// The current test checks for the buggy behavior for demonstration purposes.\n+\n+// @has 'inherent_projections/type.Test.html'\n+// @has - '//pre[@class=\"rust item-decl\"]' \"Parametrized<i32>\"\n+// @has - '//pre[@class=\"rust item-decl\"]//a[@class=\"associatedtype\"]/@href' 'struct.Parametrized.html#associatedtype.Proj'\n+// @!has - '//pre[@class=\"rust item-decl\"]//a[@class=\"associatedtype\"]/@href' 'struct.Parametrized.html#associatedtype.Proj-1'\n+pub type Test = Parametrized<i32>::Proj;\n+\n+pub struct Parametrized<T>(T);\n+\n+impl Parametrized<bool> {\n+    pub type Proj = ();\n+}\n+\n+impl Parametrized<i32> {\n+    pub type Proj = String;\n+}"}, {"sha": "2b28d2ae60bd4c45de72448f70c73c260062049b", "filename": "tests/rustdoc/intra-doc/inherent-associated-types.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Frustdoc%2Fintra-doc%2Finherent-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Frustdoc%2Fintra-doc%2Finherent-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fintra-doc%2Finherent-associated-types.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,45 @@\n+#![feature(inherent_associated_types)]\n+\n+#![allow(incomplete_features)]\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+// @has inherent_associated_types/index.html\n+\n+// @has - '//a/@href' 'enum.Simple.html#associatedtype.Type'\n+//! [`Simple::Type`]\n+\n+pub enum Simple {}\n+\n+impl Simple {\n+    pub type Type = ();\n+}\n+\n+////////////////////////////////////////\n+\n+// @has 'inherent_associated_types/type.Test0.html' '//a/@href' \\\n+//          'struct.Parametrized.html#associatedtype.Proj'\n+/// [`Parametrized<bool>::Proj`]\n+pub type Test0 = ();\n+\n+// FIXME(inherent_associated_types): The intra-doc link below should point to `Proj-1` not `Proj`.\n+// The current test checks for the buggy behavior for demonstration purposes.\n+// The same bug happens for inherent associated functions and constants (see #85960, #93398).\n+//\n+// Further, at some point we should reject the intra-doc link `Parametrized::Proj`.\n+// It currently links to `Parametrized<bool>::Proj`.\n+\n+// @has 'inherent_associated_types/type.Test1.html'\n+// @has - '//a/@href' 'struct.Parametrized.html#associatedtype.Proj'\n+// @!has - '//a/@href' 'struct.Parametrized.html#associatedtype.Proj-1'\n+/// [`Parametrized<i32>::Proj`]\n+pub type Test1 = ();\n+\n+pub struct Parametrized<T>(T);\n+\n+impl Parametrized<bool> {\n+    pub type Proj = ();\n+}\n+\n+impl Parametrized<i32> {\n+    pub type Proj = String;\n+}"}, {"sha": "642b58b0753fd894e2b0a2defb69bdd700175e6e", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive-doc-comment-field.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive-doc-comment-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive-doc-comment-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive-doc-comment-field.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,49 @@\n+// check-fail\n+// Tests that a doc comment will not preclude a field from being considered a diagnostic argument\n+// normalize-stderr-test \"the following other types implement trait `IntoDiagnosticArg`:(?:.*\\n){0,9}\\s+and \\d+ others\" -> \"normalized in stderr\"\n+// normalize-stderr-test \"diagnostic_builder\\.rs:[0-9]+:[0-9]+\" -> \"diagnostic_builder.rs:LL:CC\"\n+\n+// The proc_macro2 crate handles spans differently when on beta/stable release rather than nightly,\n+// changing the output of this test. Since Subdiagnostic is strictly internal to the compiler\n+// the test is just ignored on stable and beta:\n+// ignore-stage1\n+// ignore-beta\n+// ignore-stable\n+\n+#![feature(rustc_private)]\n+#![crate_type = \"lib\"]\n+\n+extern crate rustc_errors;\n+extern crate rustc_fluent_macro;\n+extern crate rustc_macros;\n+extern crate rustc_session;\n+extern crate rustc_span;\n+\n+use rustc_errors::{Applicability, DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_fluent_macro::fluent_messages;\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_span::Span;\n+\n+fluent_messages! { \"./example.ftl\" }\n+\n+struct NotIntoDiagnosticArg;\n+\n+#[derive(Diagnostic)]\n+#[diag(no_crate_example)]\n+struct Test {\n+    #[primary_span]\n+    span: Span,\n+    /// A doc comment\n+    arg: NotIntoDiagnosticArg,\n+    //~^ ERROR the trait bound `NotIntoDiagnosticArg: IntoDiagnosticArg` is not satisfied\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(no_crate_example)]\n+struct SubTest {\n+    #[primary_span]\n+    span: Span,\n+    /// A doc comment\n+    arg: NotIntoDiagnosticArg,\n+    //~^ ERROR the trait bound `NotIntoDiagnosticArg: IntoDiagnosticArg` is not satisfied\n+}"}, {"sha": "e4b8958b4fae871d3ee0d1fa60dea6bd606e0a60", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive-doc-comment-field.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive-doc-comment-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive-doc-comment-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive-doc-comment-field.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,30 @@\n+error[E0277]: the trait bound `NotIntoDiagnosticArg: IntoDiagnosticArg` is not satisfied\n+  --> $DIR/diagnostic-derive-doc-comment-field.rs:37:10\n+   |\n+LL | #[derive(Diagnostic)]\n+   |          ---------- required by a bound introduced by this call\n+...\n+LL |     arg: NotIntoDiagnosticArg,\n+   |          ^^^^^^^^^^^^^^^^^^^^ the trait `IntoDiagnosticArg` is not implemented for `NotIntoDiagnosticArg`\n+   |\n+   = help: normalized in stderr\n+note: required by a bound in `DiagnosticBuilder::<'a, G>::set_arg`\n+  --> $COMPILER_DIR/rustc_errors/src/diagnostic_builder.rs:LL:CC\n+   = note: this error originates in the macro `forward` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `NotIntoDiagnosticArg: IntoDiagnosticArg` is not satisfied\n+  --> $DIR/diagnostic-derive-doc-comment-field.rs:47:10\n+   |\n+LL | #[derive(Subdiagnostic)]\n+   |          ------------- required by a bound introduced by this call\n+...\n+LL |     arg: NotIntoDiagnosticArg,\n+   |          ^^^^^^^^^^^^^^^^^^^^ the trait `IntoDiagnosticArg` is not implemented for `NotIntoDiagnosticArg`\n+   |\n+   = help: normalized in stderr\n+note: required by a bound in `Diagnostic::set_arg`\n+  --> $COMPILER_DIR/rustc_errors/src/diagnostic.rs:964:5\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "39e34d73f9a431ad1d254d118958dbe4b86d7d26", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -339,12 +339,12 @@ struct ErrorWithDefaultLabelAttr<'a> {\n }\n \n #[derive(Diagnostic)]\n-//~^ ERROR the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n #[diag(no_crate_example, code = \"E0123\")]\n struct ArgFieldWithoutSkip {\n     #[primary_span]\n     span: Span,\n     other: Hello,\n+    //~^ ERROR the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n }\n \n #[derive(Diagnostic)]"}, {"sha": "801e4b5793cc1622916608c419eaa7029d477e76", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -641,15 +641,18 @@ LL | #[derive(Diagnostic)]\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-  --> $DIR/diagnostic-derive.rs:341:10\n+  --> $DIR/diagnostic-derive.rs:346:12\n    |\n LL | #[derive(Diagnostic)]\n-   |          ^^^^^^^^^^ the trait `IntoDiagnosticArg` is not implemented for `Hello`\n+   |          ---------- required by a bound introduced by this call\n+...\n+LL |     other: Hello,\n+   |            ^^^^^ the trait `IntoDiagnosticArg` is not implemented for `Hello`\n    |\n    = help: normalized in stderr\n note: required by a bound in `DiagnosticBuilder::<'a, G>::set_arg`\n   --> $COMPILER_DIR/rustc_errors/src/diagnostic_builder.rs:LL:CC\n-   = note: this error originates in the derive macro `Diagnostic` which comes from the expansion of the macro `forward` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the macro `forward` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 84 previous errors\n "}, {"sha": "f41574403d88766c4d6fdc6af2ef8ee6bb43f4f3", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-adt.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,10 @@\n+// known-bug: #108491\n+\n+// FIXME(inherent_associated_types): This should pass.\n+\n+struct Foo {\n+    bar: Self::Bar,\n+}\n+impl Foo {\n+    pub type Bar = usize;\n+}"}, {"sha": "f313c4946714cebbac02e699ca5e2d893b74456f", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-adt.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,49 @@\n+error[E0601]: `main` function not found in crate `cycle_iat_inside_of_adt`\n+  --> $DIR/cycle-iat-inside-of-adt.rs:10:2\n+   |\n+LL | }\n+   |  ^ consider adding a `main` function to `$DIR/cycle-iat-inside-of-adt.rs`\n+\n+error[E0391]: cycle detected when computing predicates of `Foo`\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+   |\n+note: ...which requires computing predicates of `Foo`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+note: ...which requires computing inferred outlives predicates of `Foo`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+   = note: ...which requires computing the inferred outlives predicates for items in this crate...\n+note: ...which requires computing type of `Foo::bar`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:6:5\n+   |\n+LL |     bar: Self::Bar,\n+   |     ^^^^^^^^^^^^^^\n+note: ...which requires computing normalized predicates of `Foo`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+   = note: ...which again requires computing predicates of `Foo`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | / struct Foo {\n+LL | |     bar: Self::Bar,\n+LL | | }\n+LL | | impl Foo {\n+LL | |     pub type Bar = usize;\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0391, E0601.\n+For more information about an error, try `rustc --explain E0391`."}, {"sha": "0c2a38b1173d9cdf5e2ce02d227ab9952441ff7a", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-where-predicate.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,16 @@\n+// known-bug: unknown\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// FIXME(inherent_associated_types): This shouldn't lead to a cycle error.\n+\n+fn user<T>() where S<T>::P: std::fmt::Debug {}\n+\n+struct S<T>;\n+\n+impl<T: Copy> S<T> {\n+    type P = ();\n+}\n+\n+fn main() {}"}, {"sha": "aaa9a39ea0f4a1d45bdddf2249d63e7e0bd44d94", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-where-predicate.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,37 @@\n+error[E0391]: cycle detected when computing predicates of `user`\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires computing predicates of `user`...\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires computing explicit predicates of `user`...\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires computing normalized predicates of `user`...\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires computing predicates of `user`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:3:1\n+   |\n+LL | / #![feature(inherent_associated_types)]\n+LL | | #![allow(incomplete_features)]\n+LL | |\n+LL | | // FIXME(inherent_associated_types): This shouldn't lead to a cycle error.\n+...  |\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "53ac79e0561baee45614c02ff575e52b27855a20", "filename": "tests/ui/associated-inherent-types/bugs/ice-substitution.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dfe31889e10e36eed53327d1ca624fbf21b475a5/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe31889e10e36eed53327d1ca624fbf21b475a5/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs?ref=dfe31889e10e36eed53327d1ca624fbf21b475a5", "patch": "@@ -1,23 +0,0 @@\n-// known-bug: unknown\n-// failure-status: 101\n-// normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n-// rustc-env:RUST_BACKTRACE=0\n-\n-// FIXME: I presume a type variable that couldn't be solved by `resolve_vars_if_possible`\n-//        escapes the InferCtxt snapshot.\n-\n-#![feature(inherent_associated_types)]\n-#![allow(incomplete_features)]\n-\n-struct Cont<T>(T);\n-\n-impl<T: Copy> Cont<T> {\n-    type Out = Vec<T>;\n-}\n-\n-pub fn weird<T: Copy>(x: T) {\n-    let _: Cont<_>::Out = vec![true];\n-}\n-\n-fn main() {}"}, {"sha": "1648cfb266b5652fc23c0e125b92378215f854c8", "filename": "tests/ui/associated-inherent-types/bugs/ice-substitution.stderr", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfe31889e10e36eed53327d1ca624fbf21b475a5/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dfe31889e10e36eed53327d1ca624fbf21b475a5/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr?ref=dfe31889e10e36eed53327d1ca624fbf21b475a5", "patch": "@@ -1,6 +0,0 @@\n-error: the compiler unexpectedly panicked. this is a bug.\n-\n-query stack during panic:\n-#0 [typeck] type-checking `weird`\n-#1 [used_trait_imports] finding used_trait_imports `weird`\n-end of query stack"}, {"sha": "a920b412b1a492a9840b0c588299bed9d0838926", "filename": "tests/ui/associated-inherent-types/bugs/inference-fail.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dfe31889e10e36eed53327d1ca624fbf21b475a5/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe31889e10e36eed53327d1ca624fbf21b475a5/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs?ref=dfe31889e10e36eed53327d1ca624fbf21b475a5", "patch": "@@ -1,15 +0,0 @@\n-// known-bug: unknown\n-\n-#![feature(inherent_associated_types)]\n-#![allow(incomplete_features)]\n-\n-struct S<T>(T);\n-\n-impl S<()> {\n-    type P = i128;\n-}\n-\n-fn main() {\n-    // We fail to infer `_ == ()` here.\n-    let _: S<_>::P;\n-}"}, {"sha": "632dbf3854b2b7b0eb5f09225f4be7c938abb462", "filename": "tests/ui/associated-inherent-types/bugs/lack-of-regionck.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dfe31889e10e36eed53327d1ca624fbf21b475a5/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfe31889e10e36eed53327d1ca624fbf21b475a5/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs?ref=dfe31889e10e36eed53327d1ca624fbf21b475a5", "patch": "@@ -1,19 +0,0 @@\n-// known-bug: unknown\n-// check-pass\n-\n-// We currently don't region-check inherent associated type projections at all.\n-\n-#![feature(inherent_associated_types)]\n-#![allow(incomplete_features, dead_code)]\n-\n-struct S<T>(T);\n-\n-impl S<&'static ()> {\n-    type T = ();\n-}\n-\n-fn usr<'a>() {\n-    let _: S::<&'a ()>::T; // this should *fail* but it doesn't!\n-}\n-\n-fn main() {}"}, {"sha": "c7f66e645bb577a59783da59bab4a750d71f1afb", "filename": "tests/ui/associated-inherent-types/bugs/wf-check-skipped.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fwf-check-skipped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fwf-check-skipped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fwf-check-skipped.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,15 @@\n+// known-bug: #100041\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// FIXME(inherent_associated_types): This should fail.\n+\n+struct Foo;\n+\n+impl Foo {\n+    type Bar<T> = ();\n+}\n+\n+fn main() -> Foo::Bar::<Vec<[u32]>> {}"}, {"sha": "83be4f43b5e943fad07a64a9e40d2d47179c501d", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     let _: Select<u8>::Projection = ();\n \n     let _: Choose<NonCopy>::Result = ();\n-    let _: Choose<bool>::Result = vec![true];\n+    let _: Choose<&str>::Result = vec![\"\u2026\"]; // regression test for issue #108957\n }\n \n // Test if we use the correct `ParamEnv` when proving obligations."}, {"sha": "48390b9430b60e1ad39752755b73187da6d8e6c8", "filename": "tests/ui/associated-inherent-types/former-subst-ice.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fformer-subst-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fformer-subst-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fformer-subst-ice.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Cont<T>(T);\n+\n+impl<T: Copy> Cont<T> {\n+    type Out = Vec<T>;\n+}\n+\n+pub fn weird<T: Copy>(x: T) {\n+    let _: Cont<_>::Out = vec![true];\n+}\n+\n+fn main() {}"}, {"sha": "464b59c249fe1f232e3695be86d4999e64a4723e", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.item.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.item.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/generic-associated-types-bad.rs:16:10\n+   |\n+LL | const _: Ty::Pr<String> = String::new();\n+   |          ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+note: required by a bound in `Ty::Pr`\n+  --> $DIR/generic-associated-types-bad.rs:10:16\n+   |\n+LL |     type Pr<T: Copy> = T;\n+   |                ^^^^ required by this bound in `Ty::Pr`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4f371b24e80344afffd6bf806e7e3f672dc7c3b0", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.local.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.local.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `Vec<()>: Copy` is not satisfied\n+  --> $DIR/generic-associated-types-bad.rs:20:12\n+   |\n+LL |     let _: Ty::Pr<Vec<()>>;\n+   |            ^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Vec<()>`\n+   |\n+note: required by a bound in `Ty::Pr`\n+  --> $DIR/generic-associated-types-bad.rs:10:16\n+   |\n+LL |     type Pr<T: Copy> = T;\n+   |                ^^^^ required by this bound in `Ty::Pr`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "74ec39424edcbdeb6fdfdf503b3dbb229b040f17", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.region.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.region.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,11 @@\n+error: lifetime may not live long enough\n+  --> $DIR/generic-associated-types-bad.rs:25:12\n+   |\n+LL | fn user<'a>() {\n+   |         -- lifetime `'a` defined here\n+LL |     #[cfg(region)]\n+LL |     let _: Ty::Static<&'a str> = \"\";\n+   |            ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "e66392a0a94116c0a1120451d44f700d183ccfbe", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,26 @@\n+// revisions: item local region\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+#[derive(Clone, Copy)]\n+pub enum Ty {}\n+\n+impl Ty {\n+    type Pr<T: Copy> = T;\n+\n+    type Static<Q: 'static> = Q;\n+}\n+\n+#[cfg(item)]\n+const _: Ty::Pr<String> = String::new(); //[item]~ the trait bound `String: Copy` is not satisfied\n+\n+fn main() {\n+    #[cfg(local)]\n+    let _: Ty::Pr<Vec<()>>; //[local]~ ERROR the trait bound `Vec<()>: Copy` is not satisfied\n+}\n+\n+fn user<'a>() {\n+    #[cfg(region)]\n+    let _: Ty::Static<&'a str> = \"\"; //[region]~ ERROR lifetime may not live long enough\n+}"}, {"sha": "939a4ff60f2bb2fbdce77e970d8d2d68d915dfc0", "filename": "tests/ui/associated-inherent-types/inference-fail.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,11 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T> S<T> { type P = (); }\n+\n+fn main() {\n+    // There is no way to infer this type.\n+    let _: S<_>::P = (); //~ ERROR type annotations needed\n+}"}, {"sha": "f29144e4aa7553cc71e70e36828d19446e717d40", "filename": "tests/ui/associated-inherent-types/inference-fail.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1,8 +1,8 @@\n error[E0282]: type annotations needed\n-  --> $DIR/inference-fail.rs:14:14\n+  --> $DIR/inference-fail.rs:10:12\n    |\n-LL |     let _: S<_>::P;\n-   |              ^ cannot infer type\n+LL |     let _: S<_>::P = ();\n+   |            ^^^^^^^ cannot infer type for type parameter `T`\n \n error: aborting due to previous error\n ", "previous_filename": "tests/ui/associated-inherent-types/bugs/inference-fail.stderr"}, {"sha": "38179214fa124de03df6c8dc4fb259de750b518a", "filename": "tests/ui/associated-inherent-types/inference.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Finference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Finference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Finference.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,39 @@\n+// Testing inference capabilities.\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+use std::convert::identity;\n+\n+struct Container<T>(T);\n+\n+impl Container<u32> {\n+    type Sink = ();\n+}\n+\n+impl<Any> Container<Any> {\n+    type Thing = Any;\n+}\n+\n+impl<T> Container<(T, ())> {\n+    type Output = ((), Wrapped<T>);\n+}\n+\n+fn main() {\n+    // Inferred via the Self type of the impl.\n+    let _: Container<_>::Sink;\n+\n+    // Inferred via the RHS:\n+\n+    let _: Container<_>::Thing = 0;\n+\n+    let _: Container<Wrapped<_>>::Thing = Wrapped(false);\n+\n+    let _: Container<_>::Output = (drop(1), Wrapped(\"...\"));\n+\n+    let binding: Container<_>::Thing = Default::default(); // unsolved at this point\n+    identity::<String>(binding); // constrained and solved here\n+}\n+\n+struct Wrapped<T>(T);"}, {"sha": "a3ae2e2ab4476728f7eb3313af3290ad196373a5", "filename": "tests/ui/associated-inherent-types/issue-109768.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,12 @@\n+// incremental\n+\n+struct Wrapper<T>(T);\n+\n+struct Local<T, U>(T, U);\n+\n+impl<T> Local { //~ ERROR missing generics for struct `Local`\n+    type AssocType3 = T; //~ ERROR inherent associated types are unstable\n+\n+    const WRAPPED_ASSOC_3: Wrapper<Self::AssocType3> = Wrapper();\n+}\n+//~^ ERROR `main` function not found"}, {"sha": "97706d4062a979fef9f4770bae20beca4ecd707d", "filename": "tests/ui/associated-inherent-types/issue-109768.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109768.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,35 @@\n+error[E0601]: `main` function not found in crate `issue_109768`\n+  --> $DIR/issue-109768.rs:11:2\n+   |\n+LL | }\n+   |  ^ consider adding a `main` function to `$DIR/issue-109768.rs`\n+\n+error[E0107]: missing generics for struct `Local`\n+  --> $DIR/issue-109768.rs:7:9\n+   |\n+LL | impl<T> Local {\n+   |         ^^^^^ expected 2 generic arguments\n+   |\n+note: struct defined here, with 2 generic parameters: `T`, `U`\n+  --> $DIR/issue-109768.rs:5:8\n+   |\n+LL | struct Local<T, U>(T, U);\n+   |        ^^^^^ -  -\n+help: add missing generic arguments\n+   |\n+LL | impl<T> Local<T, U> {\n+   |              ++++++\n+\n+error[E0658]: inherent associated types are unstable\n+  --> $DIR/issue-109768.rs:8:5\n+   |\n+LL |     type AssocType3 = T;\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #8995 <https://github.com/rust-lang/rust/issues/8995> for more information\n+   = help: add `#![feature(inherent_associated_types)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0107, E0601, E0658.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "0b5ba7d1fb55da493ca4375156e4ad1d960ac82e", "filename": "tests/ui/associated-inherent-types/issue-109789.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,22 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Foo<T>(T);\n+\n+impl Foo<fn(&'static ())> {\n+    type Assoc = u32;\n+}\n+\n+trait Other {}\n+impl Other for u32 {}\n+\n+// FIXME(inherent_associated_types): Avoid emitting two diagnostics (they only differ in span).\n+// FIXME(inherent_associated_types): Enhancement: Spruce up the diagnostic by saying something like\n+// \"implementation is not general enough\" as is done for traits via\n+// `try_report_trait_placeholder_mismatch`.\n+\n+fn bar(_: Foo<for<'a> fn(&'a ())>::Assoc) {}\n+//~^ ERROR mismatched types\n+//~| ERROR mismatched types\n+\n+fn main() {}"}, {"sha": "7af338274a12ba38fceb0dc03ebb114dc8369eee", "filename": "tests/ui/associated-inherent-types/issue-109789.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109789.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-109789.rs:18:1\n+   |\n+LL | fn bar(_: Foo<for<'a> fn(&'a ())>::Assoc) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected struct `Foo<fn(&'static ())>`\n+              found struct `Foo<for<'a> fn(&'a ())>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-109789.rs:18:11\n+   |\n+LL | fn bar(_: Foo<for<'a> fn(&'a ())>::Assoc) {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected struct `Foo<fn(&'static ())>`\n+              found struct `Foo<for<'a> fn(&'a ())>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b2be19a28f442efc4405b0275bf18656db82b541", "filename": "tests/ui/associated-inherent-types/issue-109790.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fissue-109790.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fissue-109790.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109790.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Foo<T>(T);\n+\n+impl<'a> Foo<fn(&'a ())> {\n+    type Assoc = &'a ();\n+}\n+\n+trait Other {}\n+impl Other for u32 {}\n+\n+fn bar(_: for<'a> fn(Foo<fn(&'a ())>::Assoc)) {}\n+\n+fn main() {}"}, {"sha": "488a2cda649ce9d71727b83e9a17ac4a1a446011", "filename": "tests/ui/associated-inherent-types/late-bound-regions.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,25 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Test if we correctly normalize `S<'a>::P` with respect to late-bound regions.\n+\n+type Function = for<'a> fn(&'a i32) -> S<'a>::P;\n+\n+struct S<'a>(&'a ());\n+\n+trait Inter {\n+    type P;\n+}\n+\n+impl<'a> S<'a> {\n+    type P = &'a i32;\n+}\n+\n+fn ret_ref_local<'e>() -> &'e i32 {\n+    let f: Function = |x| x;\n+\n+    let local = 0;\n+    f(&local) //~ ERROR cannot return value referencing local variable `local`\n+}\n+\n+fn main() {}"}, {"sha": "4706fcca91d0644340b2cd5d393637b22b566dde", "filename": "tests/ui/associated-inherent-types/late-bound-regions.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,12 @@\n+error[E0515]: cannot return value referencing local variable `local`\n+  --> $DIR/late-bound-regions.rs:22:5\n+   |\n+LL |     f(&local)\n+   |     ^^------^\n+   |     | |\n+   |     | `local` is borrowed here\n+   |     returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "4228238aa7b7a26b84a4ebeed7c1b54e070ca48a", "filename": "tests/ui/associated-inherent-types/normalization-overflow.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// FIXME(fmease): I'd prefer to report a cycle error here instead of an overflow one.\n+\n+struct T;\n+\n+impl T {\n+    type This = Self::This; //~ ERROR overflow evaluating associated type `T::This`\n+}\n+\n+fn main() {}"}, {"sha": "16bb64281e3af1ed7f0a2b0dbad513228f377a8a", "filename": "tests/ui/associated-inherent-types/normalization-overflow.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,8 @@\n+error: overflow evaluating associated type `T::This`\n+  --> $DIR/normalization-overflow.rs:9:17\n+   |\n+LL |     type This = Self::This;\n+   |                 ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "a4b372537c789d680e32a81e767c3992e3ce88bf", "filename": "tests/ui/associated-inherent-types/private-in-public.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,26 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+#![crate_type = \"lib\"]\n+\n+#![deny(private_in_public)]\n+\n+pub type PubAlias0 = PubTy::PrivAssocTy;\n+//~^ ERROR private associated type `PubTy::PrivAssocTy` in public interface (error E0446)\n+//~| WARNING this was previously accepted\n+pub type PubAlias1 = PrivTy::PubAssocTy;\n+//~^ ERROR private type `PrivTy` in public interface (error E0446)\n+//~| WARNING this was previously accepted\n+pub type PubAlias2 = PubTy::PubAssocTy<PrivTy>;\n+//~^ ERROR private type `PrivTy` in public interface (error E0446)\n+//~| WARNING this was previously accepted\n+\n+pub struct PubTy;\n+impl PubTy {\n+    type PrivAssocTy = ();\n+    pub type PubAssocTy<T> = T;\n+}\n+\n+struct PrivTy;\n+impl PrivTy {\n+    pub type PubAssocTy = ();\n+}"}, {"sha": "f0a64e96179ac39dd2a0d5aa5141209c77ffbdf7", "filename": "tests/ui/associated-inherent-types/private-in-public.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,34 @@\n+error: private associated type `PubTy::PrivAssocTy` in public interface (error E0446)\n+  --> $DIR/private-in-public.rs:7:1\n+   |\n+LL | pub type PubAlias0 = PubTy::PrivAssocTy;\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+note: the lint level is defined here\n+  --> $DIR/private-in-public.rs:5:9\n+   |\n+LL | #![deny(private_in_public)]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: private type `PrivTy` in public interface (error E0446)\n+  --> $DIR/private-in-public.rs:10:1\n+   |\n+LL | pub type PubAlias1 = PrivTy::PubAssocTy;\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+\n+error: private type `PrivTy` in public interface (error E0446)\n+  --> $DIR/private-in-public.rs:13:1\n+   |\n+LL | pub type PubAlias2 = PubTy::PubAssocTy<PrivTy>;\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7c94539ace1f904db8cc32a2d93ed2d71055598e", "filename": "tests/ui/associated-inherent-types/regionck-0.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,14 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl S<&'static ()> {\n+    type T = ();\n+}\n+\n+fn user<'a>() {\n+    let _: S::<&'a ()>::T; //~ ERROR lifetime may not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "3a438ee630e1e3eea1f0facfd8713a1a50f01df0", "filename": "tests/ui/associated-inherent-types/regionck-0.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,10 @@\n+error: lifetime may not live long enough\n+  --> $DIR/regionck-0.rs:11:12\n+   |\n+LL | fn user<'a>() {\n+   |         -- lifetime `'a` defined here\n+LL |     let _: S::<&'a ()>::T;\n+   |            ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "ec663cd0f77fa0bedef29f4d0a78560322ce467c", "filename": "tests/ui/associated-inherent-types/regionck-1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,13 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct U;\n+\n+impl U {\n+    // Don't imply any bounds here.\n+\n+    type NoTyOutliv<'a, T> = &'a T; //~ ERROR the parameter type `T` may not live long enough\n+    type NoReOutliv<'a, 'b> = &'a &'b (); //~ ERROR reference has a longer lifetime than the data it references\n+}\n+\n+fn main() {}"}, {"sha": "b17d89ca306f41cf1ea76c5f60116ea4019764fd", "filename": "tests/ui/associated-inherent-types/regionck-1.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,29 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/regionck-1.rs:9:30\n+   |\n+LL |     type NoTyOutliv<'a, T> = &'a T;\n+   |                              ^^^^^- help: consider adding a where clause: `where T: 'a`\n+   |                              |\n+   |                              ...so that the reference type `&'a T` does not outlive the data it points at\n+\n+error[E0491]: in type `&'a &'b ()`, reference has a longer lifetime than the data it references\n+  --> $DIR/regionck-1.rs:10:31\n+   |\n+LL |     type NoReOutliv<'a, 'b> = &'a &'b ();\n+   |                               ^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime `'a` as defined here\n+  --> $DIR/regionck-1.rs:10:21\n+   |\n+LL |     type NoReOutliv<'a, 'b> = &'a &'b ();\n+   |                     ^^\n+note: but the referenced data is only valid for the lifetime `'b` as defined here\n+  --> $DIR/regionck-1.rs:10:25\n+   |\n+LL |     type NoReOutliv<'a, 'b> = &'a &'b ();\n+   |                         ^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0309, E0491.\n+For more information about an error, try `rustc --explain E0309`."}, {"sha": "7a0b8b08300157083bedad04ab32402b2903e4ad", "filename": "tests/ui/associated-inherent-types/regionck-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,14 @@\n+// Regression test for issue #109299.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<'d>(&'d ());\n+\n+impl Lexer<'static> {\n+    type Cursor = ();\n+}\n+\n+fn test(_: Lexer::Cursor) {} //~ ERROR mismatched types\n+\n+fn main() {}"}, {"sha": "b0a4ed35d560973266a21c49da4590808f2a3ab4", "filename": "tests/ui/associated-inherent-types/regionck-2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/regionck-2.rs:12:12\n+   |\n+LL | fn test(_: Lexer::Cursor) {}\n+   |            ^^^^^^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected struct `Lexer<'static>`\n+              found struct `Lexer<'_>`\n+note: the anonymous lifetime defined here...\n+  --> $DIR/regionck-2.rs:12:12\n+   |\n+LL | fn test(_: Lexer::Cursor) {}\n+   |            ^^^^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b32b4288ac9f67cd5bc86efb32dca47833bc0ff6", "filename": "tests/ui/associated-inherent-types/type-alias-bounds-are-enforced.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Ftype-alias-bounds-are-enforced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Ftype-alias-bounds-are-enforced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Ftype-alias-bounds-are-enforced.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+// compile-flags: --crate-type=lib\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Bounds on the self type play a major role in the resolution of inherent associated types (*).\n+// As a result of that, if a type alias contains any then its bounds have to be respected and the\n+// lint `type_alias_bounds` should not fire.\n+//\n+// FIXME(inherent_associated_types): In the current implementation that is. We might move the\n+// selection phase of IATs from hir_typeck to trait_selection resulting in us not requiring the\n+// ParamEnv that early allowing us to ignore bounds on type aliases again.\n+// Triage this before stabilization.\n+\n+#![deny(type_alias_bounds)]\n+\n+pub type Alias<T: Bound> = (Source<T>::Assoc,);\n+\n+\n+pub struct Source<T>(T);\n+pub trait Bound {}\n+\n+impl<T: Bound> Source<T> {\n+    pub type Assoc = ();\n+}"}, {"sha": "d081c4d5b78e6206af5bf1f9c7a2bb823e28aac8", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-inferred-type.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T: Copy> S<T> {\n+    type T = T;\n+}\n+\n+fn main() {\n+    let _: S<_>::T = String::new(); //~ ERROR the trait bound `String: Copy` is not satisfied\n+}"}, {"sha": "ecf30f4cdec58626e3b9714c5832dfabe00f0cf6", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-inferred-type.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/unsatisfied-bounds-inferred-type.rs:11:12\n+   |\n+LL |     let _: S<_>::T = String::new();\n+   |            ^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+note: required by a bound in `S<T>::T`\n+  --> $DIR/unsatisfied-bounds-inferred-type.rs:6:9\n+   |\n+LL | impl<T: Copy> S<T> {\n+   |         ^^^^ required by this bound in `S<T>::T`\n+LL |     type T = T;\n+   |          - required by a bound in this associated type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "97bd2c421604af81da3ab3e050f216ae9e52527b", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-where-clause-on-assoc-ty.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,14 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T> S<T> {\n+    type X = ()\n+    where\n+        T: Copy;\n+}\n+\n+fn main() {\n+    let _: S::<String>::X; //~ ERROR the trait bound `String: Copy` is not satisfied\n+}"}, {"sha": "d4968cd05dceefa000f1f11dd6888f323331d01b", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-where-clause-on-assoc-ty.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/unsatisfied-bounds-where-clause-on-assoc-ty.rs:13:12\n+   |\n+LL |     let _: S::<String>::X;\n+   |            ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+note: required by a bound in `S<T>::X`\n+  --> $DIR/unsatisfied-bounds-where-clause-on-assoc-ty.rs:9:12\n+   |\n+LL |     type X = ()\n+   |          - required by a bound in this associated type\n+LL |     where\n+LL |         T: Copy;\n+   |            ^^^^ required by this bound in `S<T>::X`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "49fe32c71091c68c903df86e89f17c790ceff743", "filename": "tests/ui/structs-enums/issue-103869.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fstructs-enums%2Fissue-103869.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fstructs-enums%2Fissue-103869.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs-enums%2Fissue-103869.fixed?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+\n+struct VecOrMap {\n+    //~^ HELP: perhaps you meant to use `struct` here\n+    vec: Vec<usize>,\n+    //~^ ERROR expected one of `(`, `,`, `=`, `{`, or `}`, found `:`\n+    //~| HELP: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n+}\n+\n+fn main() {\n+    let o = VecOrMap { vec: vec![1, 2, 3] };\n+    println!(\"{:?}\", o.vec);\n+}"}, {"sha": "729079e050115d504d7a946ab954eee89a9fe2f2", "filename": "tests/ui/structs-enums/issue-103869.rs", "status": "renamed", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fstructs-enums%2Fissue-103869.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fstructs-enums%2Fissue-103869.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs-enums%2Fissue-103869.rs?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1,8 +1,13 @@\n-enum VecOrMap{\n+// run-rustfix\n+\n+enum VecOrMap {\n+    //~^ HELP: perhaps you meant to use `struct` here\n     vec: Vec<usize>,\n     //~^ ERROR expected one of `(`, `,`, `=`, `{`, or `}`, found `:`\n     //~| HELP: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n-    map: HashMap<String,usize>\n }\n \n-fn main() {}\n+fn main() {\n+    let o = VecOrMap { vec: vec![1, 2, 3] };\n+    println!(\"{:?}\", o.vec);\n+}", "previous_filename": "tests/ui/parser/issue-103869.rs"}, {"sha": "4665ebf89a3c9356390bcacae0b22e189aef7cdd", "filename": "tests/ui/structs-enums/issue-103869.stderr", "status": "renamed", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fstructs-enums%2Fissue-103869.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f2c438dce75d8cc532c3baa849eeddc0901802c/tests%2Fui%2Fstructs-enums%2Fissue-103869.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstructs-enums%2Fissue-103869.stderr?ref=2f2c438dce75d8cc532c3baa849eeddc0901802c", "patch": "@@ -1,12 +1,17 @@\n error: expected one of `(`, `,`, `=`, `{`, or `}`, found `:`\n-  --> $DIR/issue-103869.rs:2:8\n+  --> $DIR/issue-103869.rs:5:8\n    |\n-LL | enum VecOrMap{\n+LL | enum VecOrMap {\n    |      -------- while parsing this enum\n+LL |\n LL |     vec: Vec<usize>,\n    |        ^ expected one of `(`, `,`, `=`, `{`, or `}`\n    |\n    = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n+help: perhaps you meant to use `struct` here\n+   |\n+LL | struct VecOrMap {\n+   | ~~~~~~\n \n error: aborting due to previous error\n ", "previous_filename": "tests/ui/parser/issue-103869.stderr"}]}