{"sha": "485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NWM1ZmI2ZTFiZjEyY2QxMWE4ZmFjNWVlOTQ5NjJlMTdjZmY3NGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-08T17:55:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-08T17:55:45Z"}, "message": "Auto merge of #70931 - Dylan-DPC:rollup-f8orcao, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #70789 (remove false positives of unused_braces)\n - #70847 (ci: move /var/lib/docker to /mnt on GHA)\n - #70850 (BTreeMap first last proposal tweaks)\n - #70876 (Use a `SmallVec` for `Cache::predecessors`.)\n - #70883 (Clean up E0507 explanation)\n - #70892 (wf: refactor `compute_trait_ref`)\n - #70914 (Corrects a typo in rustdoc documentation.)\n - #70915 (Remove unnecessary TypeFlags::NOMINAL_FLAGS)\n - #70927 (Clean up E0510 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a576971dc9a95edc00323856e06505ee4dae5b00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a576971dc9a95edc00323856e06505ee4dae5b00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "html_url": "https://github.com/rust-lang/rust/commit/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42abbd8878d3b67238f3611b0587c704ba94f39c", "url": "https://api.github.com/repos/rust-lang/rust/commits/42abbd8878d3b67238f3611b0587c704ba94f39c", "html_url": "https://github.com/rust-lang/rust/commit/42abbd8878d3b67238f3611b0587c704ba94f39c"}, {"sha": "1498da87c274508f33aa878e39a8faa3659a4121", "url": "https://api.github.com/repos/rust-lang/rust/commits/1498da87c274508f33aa878e39a8faa3659a4121", "html_url": "https://github.com/rust-lang/rust/commit/1498da87c274508f33aa878e39a8faa3659a4121"}], "stats": {"total": 619, "additions": 346, "deletions": 273}, "files": [{"sha": "50178b9c33ed46eb783c2fd788ec92aba1a84bf6", "filename": "src/ci/scripts/symlink-build-dir.sh", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -24,4 +24,10 @@ elif isLinux && isGitHubActions; then\n     mv \"${current_dir}\" /mnt/more-space/workspace\n     ln -s /mnt/more-space/workspace \"${current_dir}\"\n     cd \"${current_dir}\"\n+\n+    # Move the Docker data directory to /mnt\n+    sudo systemctl stop docker.service\n+    sudo mv /var/lib/docker /mnt/docker\n+    sudo ln -s /mnt/docker /var/lib/docker\n+    sudo systemctl start docker.service\n fi"}, {"sha": "efadae1c5fb9d078f95828120999800f0084ceea", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -352,9 +352,9 @@ are added.\n /// ```\n ```\n \n-`edition2018` tells `rustdoc` that the code sample should be compiled the 2018\n-edition of Rust. Similarly, you can specify `edition2015` to compile the code\n-with the 2015 edition.\n+`edition2018` tells `rustdoc` that the code sample should be compiled using\n+the 2018 edition of Rust. Similarly, you can specify `edition2015` to compile\n+the code with the 2015 edition.\n \n ## Syntax reference\n "}, {"sha": "a1e59b2e6afb33220cfb22c4938339725ee2f080", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 76, "deletions": 48, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -653,11 +653,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn first_key_value(&self) -> Option<(&K, &V)> {\n         let front = self.root.as_ref()?.as_ref().first_leaf_edge();\n         front.right_kv().ok().map(Handle::into_kv)\n     }\n@@ -667,36 +663,54 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// # Examples\n     ///\n-    /// Contrived way to `clear` a map:\n-    ///\n     /// ```\n     /// #![feature(map_first_last)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(2, \"b\");\n-    /// while let Some(entry) = map.first_entry() {\n-    ///     let (key, val) = entry.remove_entry();\n-    ///     assert!(!map.contains_key(&key));\n+    /// if let Some(mut entry) = map.first_entry() {\n+    ///     if *entry.key() > 0 {\n+    ///         entry.insert(\"first\");\n+    ///     }\n     /// }\n+    /// assert_eq!(*map.get(&1).unwrap(), \"first\");\n+    /// assert_eq!(*map.get(&2).unwrap(), \"b\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n         let front = self.root.as_mut()?.as_mut().first_leaf_edge();\n-        if let Ok(kv) = front.right_kv() {\n-            Some(OccupiedEntry {\n-                handle: kv.forget_node_type(),\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+        let kv = front.right_kv().ok()?;\n+        Some(OccupiedEntry {\n+            handle: kv.forget_node_type(),\n+            length: &mut self.length,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    /// Removes and returns the first element in the map.\n+    /// The key of this element is the minimum key that was in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Draining elements in ascending order, while keeping a usable map each iteration.\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// while let Some((key, _val)) = map.pop_first() {\n+    ///     assert!(map.iter().all(|(k, _v)| *k > key));\n+    /// }\n+    /// assert!(map.is_empty());\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn pop_first(&mut self) -> Option<(K, V)> {\n+        self.first_entry().map(|entry| entry.remove_entry())\n     }\n \n     /// Returns the last key-value pair in the map.\n@@ -716,11 +730,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn last_key_value(&self) -> Option<(&K, &V)> {\n         let back = self.root.as_ref()?.as_ref().last_leaf_edge();\n         back.left_kv().ok().map(Handle::into_kv)\n     }\n@@ -730,36 +740,54 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// # Examples\n     ///\n-    /// Contrived way to `clear` a map:\n-    ///\n     /// ```\n     /// #![feature(map_first_last)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(2, \"b\");\n-    /// while let Some(entry) = map.last_entry() {\n-    ///     let (key, val) = entry.remove_entry();\n-    ///     assert!(!map.contains_key(&key));\n+    /// if let Some(mut entry) = map.last_entry() {\n+    ///     if *entry.key() > 0 {\n+    ///         entry.insert(\"last\");\n+    ///     }\n     /// }\n+    /// assert_eq!(*map.get(&1).unwrap(), \"a\");\n+    /// assert_eq!(*map.get(&2).unwrap(), \"last\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n         let back = self.root.as_mut()?.as_mut().last_leaf_edge();\n-        if let Ok(kv) = back.left_kv() {\n-            Some(OccupiedEntry {\n-                handle: kv.forget_node_type(),\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+        let kv = back.left_kv().ok()?;\n+        Some(OccupiedEntry {\n+            handle: kv.forget_node_type(),\n+            length: &mut self.length,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    /// Removes and returns the last element in the map.\n+    /// The key of this element is the maximum key that was in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Draining elements in descending order, while keeping a usable map each iteration.\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// while let Some((key, _val)) = map.pop_last() {\n+    ///     assert!(map.iter().all(|(k, _v)| *k < key));\n+    /// }\n+    /// assert!(map.is_empty());\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn pop_last(&mut self) -> Option<(K, V)> {\n+        self.last_entry().map(|entry| entry.remove_entry())\n     }\n \n     /// Returns `true` if the map contains a value for the specified key."}, {"sha": "254751fc45e305686c311c6f397229659cc7b573", "filename": "src/librustc_error_codes/error_codes/E0507.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -1,9 +1,4 @@\n-You tried to move out of a value which was borrowed.\n-\n-This can also happen when using a type implementing `Fn` or `FnMut`, as neither\n-allows moving out of them (they usually represent closures which can be called\n-more than once). Much of the text following applies equally well to non-`FnOnce`\n-closure bodies.\n+A borrowed value was moved out.\n \n Erroneous code example:\n \n@@ -32,6 +27,11 @@ you have three choices:\n * Somehow reclaim the ownership.\n * Implement the `Copy` trait on the type.\n \n+This can also happen when using a type implementing `Fn` or `FnMut`, as neither\n+allows moving out of them (they usually represent closures which can be called\n+more than once). Much of the text following applies equally well to non-`FnOnce`\n+closure bodies.\n+\n Examples:\n \n ```"}, {"sha": "e045e04bdbe11ac23b981af155fbfa163c581269", "filename": "src/librustc_error_codes/error_codes/E0510.md", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0510.md", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0510.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0510.md?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -1,16 +1,29 @@\n-Cannot mutate place in this match guard.\n+The matched value was assigned in a match guard.\n \n-When matching on a variable it cannot be mutated in the match guards, as this\n-could cause the match to be non-exhaustive:\n+Erroneous code example:\n \n ```compile_fail,E0510\n let mut x = Some(0);\n match x {\n-    None => (),\n-    Some(_) if { x = None; false } => (),\n-    Some(v) => (), // No longer matches\n+    None => {}\n+    Some(_) if { x = None; false } => {} // error!\n+    Some(_) => {}\n }\n ```\n \n+When matching on a variable it cannot be mutated in the match guards, as this\n+could cause the match to be non-exhaustive.\n+\n Here executing `x = None` would modify the value being matched and require us\n-to go \"back in time\" to the `None` arm.\n+to go \"back in time\" to the `None` arm. To fix it, change the value in the match\n+arm:\n+\n+```\n+let mut x = Some(0);\n+match x {\n+    None => {}\n+    Some(_) => {\n+        x = None; // ok!\n+    }\n+}\n+```"}, {"sha": "aa7c87e9f7bd2a12c49fe59cbc158e32c6fc128f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -355,6 +355,19 @@ impl From<UnusedDelimsCtx> for &'static str {\n trait UnusedDelimLint {\n     const DELIM_STR: &'static str;\n \n+    /// Due to `ref` pattern, there can be a difference between using\n+    /// `{ expr }` and `expr` in pattern-matching contexts. This means\n+    /// that we should only lint `unused_parens` and not `unused_braces`\n+    /// in this case.\n+    ///\n+    /// ```rust\n+    /// let mut a = 7;\n+    /// let ref b = { a }; // We actually borrow a copy of `a` here.\n+    /// a += 1; // By mutating `a` we invalidate any borrows of `a`.\n+    /// assert_eq!(b + 1, a); // `b` does not borrow `a`, so we can still use it here.\n+    /// ```\n+    const LINT_EXPR_IN_PATTERN_MATCHING_CTX: bool;\n+\n     // this cannot be a constant is it refers to a static.\n     fn lint(&self) -> &'static Lint;\n \n@@ -454,7 +467,10 @@ trait UnusedDelimLint {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use rustc_ast::ast::ExprKind::*;\n         let (value, ctx, followed_by_block, left_pos, right_pos) = match e.kind {\n-            If(ref cond, ref block, ..) => {\n+            // Do not lint `unused_braces` in `if let` expressions.\n+            If(ref cond, ref block, ..)\n+                if !matches!(cond.kind, Let(_, _)) || Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX =>\n+            {\n                 let left = e.span.lo() + rustc_span::BytePos(2);\n                 let right = block.span.lo();\n                 (cond, UnusedDelimsCtx::IfCond, true, Some(left), Some(right))\n@@ -470,7 +486,7 @@ trait UnusedDelimLint {\n                 (cond, UnusedDelimsCtx::ForIterExpr, true, None, Some(block.span.lo()))\n             }\n \n-            Match(ref head, _) => {\n+            Match(ref head, _) if Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX => {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n                 (head, UnusedDelimsCtx::MatchScrutineeExpr, true, Some(left), None)\n             }\n@@ -512,7 +528,7 @@ trait UnusedDelimLint {\n \n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n         match s.kind {\n-            StmtKind::Local(ref local) => {\n+            StmtKind::Local(ref local) if Self::LINT_EXPR_IN_PATTERN_MATCHING_CTX => {\n                 if let Some(ref value) = local.init {\n                     self.check_unused_delims_expr(\n                         cx,\n@@ -565,6 +581,8 @@ declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n impl UnusedDelimLint for UnusedParens {\n     const DELIM_STR: &'static str = \"parentheses\";\n \n+    const LINT_EXPR_IN_PATTERN_MATCHING_CTX: bool = true;\n+\n     fn lint(&self) -> &'static Lint {\n         UNUSED_PARENS\n     }\n@@ -736,6 +754,8 @@ declare_lint_pass!(UnusedBraces => [UNUSED_BRACES]);\n impl UnusedDelimLint for UnusedBraces {\n     const DELIM_STR: &'static str = \"braces\";\n \n+    const LINT_EXPR_IN_PATTERN_MATCHING_CTX: bool = false;\n+\n     fn lint(&self) -> &'static Lint {\n         UNUSED_BRACES\n     }"}, {"sha": "af0f7efc3e3548ad9781708d3c391c79377f6126", "filename": "src/librustc_middle/mir/cache.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_middle%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_middle%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcache.rs?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -5,13 +5,15 @@ use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_index::vec::IndexVec;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use smallvec::SmallVec;\n use std::iter;\n use std::ops::{Deref, DerefMut, Index, IndexMut};\n use std::vec::IntoIter;\n \n #[derive(Clone, Debug)]\n pub struct Cache {\n-    predecessors: Option<IndexVec<BasicBlock, Vec<BasicBlock>>>,\n+    // Typically 95%+ of the inner vectors have 4 or fewer elements.\n+    predecessors: Option<IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>>,\n }\n \n impl rustc_serialize::Encodable for Cache {\n@@ -44,7 +46,7 @@ impl Cache {\n \n     pub fn ensure_predecessors(&mut self, body: &Body<'_>) {\n         if self.predecessors.is_none() {\n-            let mut result = IndexVec::from_elem(vec![], body.basic_blocks());\n+            let mut result = IndexVec::from_elem(smallvec![], body.basic_blocks());\n             for (bb, data) in body.basic_blocks().iter_enumerated() {\n                 if let Some(ref term) = data.terminator {\n                     for &tgt in term.successors() {\n@@ -58,7 +60,11 @@ impl Cache {\n     }\n \n     /// This will recompute the predecessors cache if it is not available\n-    fn predecessors(&mut self, body: &Body<'_>) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+    // njn: typedef?\n+    fn predecessors(\n+        &mut self,\n+        body: &Body<'_>,\n+    ) -> &IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>> {\n         self.ensure_predecessors(body);\n         self.predecessors.as_ref().unwrap()\n     }\n@@ -137,7 +143,7 @@ impl BodyAndCache<'tcx> {\n         self.cache.ensure_predecessors(&self.body);\n     }\n \n-    pub fn predecessors(&mut self) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+    pub fn predecessors(&mut self) -> &IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>> {\n         self.cache.predecessors(&self.body)\n     }\n \n@@ -199,7 +205,7 @@ impl ReadOnlyBodyAndCache<'a, 'tcx> {\n         Self { body, cache }\n     }\n \n-    pub fn predecessors(&self) -> &IndexVec<BasicBlock, Vec<BasicBlock>> {\n+    pub fn predecessors(&self) -> &IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>> {\n         self.cache.predecessors.as_ref().unwrap()\n     }\n "}, {"sha": "7c3c96348b558433e15b2f3c18d43ff5105ae469", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -28,7 +28,7 @@ impl FlagComputation {\n     }\n \n     fn add_flags(&mut self, flags: TypeFlags) {\n-        self.flags = self.flags | (flags & TypeFlags::NOMINAL_FLAGS);\n+        self.flags = self.flags | flags;\n     }\n \n     /// indicates that `self` refers to something at binding level `binder`"}, {"sha": "57ac18185d0537f1668bbe3b629318df123d8d52", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -598,29 +598,6 @@ bitflags! {\n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n         const STILL_FURTHER_SPECIALIZABLE = 1 << 18;\n-\n-        /// Flags representing the nominal content of a type,\n-        /// computed by FlagsComputation. If you add a new nominal\n-        /// flag, it should be added here too.\n-        const NOMINAL_FLAGS               = TypeFlags::HAS_TY_PARAM.bits\n-                                          | TypeFlags::HAS_RE_PARAM.bits\n-                                          | TypeFlags::HAS_CT_PARAM.bits\n-                                          | TypeFlags::HAS_TY_INFER.bits\n-                                          | TypeFlags::HAS_RE_INFER.bits\n-                                          | TypeFlags::HAS_CT_INFER.bits\n-                                          | TypeFlags::HAS_TY_PLACEHOLDER.bits\n-                                          | TypeFlags::HAS_RE_PLACEHOLDER.bits\n-                                          | TypeFlags::HAS_CT_PLACEHOLDER.bits\n-                                          | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits\n-                                          | TypeFlags::HAS_TY_PROJECTION.bits\n-                                          | TypeFlags::HAS_TY_OPAQUE.bits\n-                                          | TypeFlags::HAS_CT_PROJECTION.bits\n-                                          | TypeFlags::KEEP_IN_LOCAL_TCX.bits\n-                                          | TypeFlags::HAS_TY_ERR.bits\n-                                          | TypeFlags::HAS_FREE_REGIONS.bits\n-                                          | TypeFlags::HAS_RE_LATE_BOUND.bits\n-                                          | TypeFlags::HAS_RE_ERASED.bits\n-                                          | TypeFlags::STILL_FURTHER_SPECIALIZABLE.bits;\n     }\n }\n "}, {"sha": "d506ddab909e752b5aa2d2a7ee71ac2be2ae5e7e", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 151, "deletions": 155, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -134,6 +134,152 @@ enum Elaborate {\n     None,\n }\n \n+fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: &ty::TraitRef<'tcx>,\n+    item: Option<&hir::Item<'tcx>>,\n+    cause: &mut traits::ObligationCause<'tcx>,\n+    pred: &ty::Predicate<'_>,\n+    mut trait_assoc_items: impl Iterator<Item = ty::AssocItem>,\n+) {\n+    let trait_item =\n+        tcx.hir().as_local_hir_id(trait_ref.def_id).and_then(|trait_id| tcx.hir().find(trait_id));\n+    let (trait_name, trait_generics) = match trait_item {\n+        Some(hir::Node::Item(hir::Item {\n+            ident,\n+            kind: hir::ItemKind::Trait(.., generics, _, _),\n+            ..\n+        }))\n+        | Some(hir::Node::Item(hir::Item {\n+            ident,\n+            kind: hir::ItemKind::TraitAlias(generics, _),\n+            ..\n+        })) => (Some(ident), Some(generics)),\n+        _ => (None, None),\n+    };\n+\n+    let item_span = item.map(|i| tcx.sess.source_map().guess_head_span(i.span));\n+    match pred {\n+        ty::Predicate::Projection(proj) => {\n+            // The obligation comes not from the current `impl` nor the `trait` being\n+            // implemented, but rather from a \"second order\" obligation, like in\n+            // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs`:\n+            //\n+            //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+            //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n+            //      |\n+            //   LL |     type Ok;\n+            //      |          -- associated type defined here\n+            //   ...\n+            //   LL | impl Bar for Foo {\n+            //      | ---------------- in this `impl` item\n+            //   LL |     type Ok = ();\n+            //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n+            //      |\n+            //      = note: expected type `u32`\n+            //                 found type `()`\n+            //\n+            // FIXME: we would want to point a span to all places that contributed to this\n+            // obligation. In the case above, it should be closer to:\n+            //\n+            //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+            //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n+            //      |\n+            //   LL |     type Ok;\n+            //      |          -- associated type defined here\n+            //   LL |     type Sibling: Bar2<Ok=Self::Ok>;\n+            //      |     -------------------------------- obligation set here\n+            //   ...\n+            //   LL | impl Bar for Foo {\n+            //      | ---------------- in this `impl` item\n+            //   LL |     type Ok = ();\n+            //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n+            //   ...\n+            //   LL | impl Bar2 for Foo2 {\n+            //      | ---------------- in this `impl` item\n+            //   LL |     type Ok = u32;\n+            //      |     -------------- obligation set here\n+            //      |\n+            //      = note: expected type `u32`\n+            //                 found type `()`\n+            if let Some(hir::ItemKind::Impl { items, .. }) = item.map(|i| &i.kind) {\n+                let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n+                if let Some(impl_item) =\n+                    items.iter().find(|item| item.ident == trait_assoc_item.ident)\n+                {\n+                    cause.span = impl_item.span;\n+                    cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n+                        impl_span: item_span,\n+                        original: trait_assoc_item.ident.span,\n+                        bounds: vec![],\n+                    }));\n+                }\n+            }\n+        }\n+        ty::Predicate::Trait(proj, _) => {\n+            // An associated item obligation born out of the `trait` failed to be met.\n+            // Point at the `impl` that failed the obligation, the associated item that\n+            // needed to meet the obligation, and the definition of that associated item,\n+            // which should hold the obligation in most cases. An example can be seen in\n+            // `src/test/ui/associated-types/point-at-type-on-obligation-failure-2.rs`:\n+            //\n+            //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n+            //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n+            //      |\n+            //   LL |     type Assoc: Bar;\n+            //      |          ----- associated type defined here\n+            //   ...\n+            //   LL | impl Foo for () {\n+            //      | --------------- in this `impl` item\n+            //   LL |     type Assoc = bool;\n+            //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+            //\n+            // If the obligation comes from the where clause in the `trait`, we point at it:\n+            //\n+            //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n+            //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n+            //      |\n+            //      | trait Foo where <Self as Foo>>::Assoc: Bar {\n+            //      |                 -------------------------- restricted in this bound\n+            //   LL |     type Assoc;\n+            //      |          ----- associated type defined here\n+            //   ...\n+            //   LL | impl Foo for () {\n+            //      | --------------- in this `impl` item\n+            //   LL |     type Assoc = bool;\n+            //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+            if let (\n+                ty::Projection(ty::ProjectionTy { item_def_id, .. }),\n+                Some(hir::ItemKind::Impl { items, .. }),\n+            ) = (&proj.skip_binder().self_ty().kind, item.map(|i| &i.kind))\n+            {\n+                if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n+                    .find(|i| i.def_id == *item_def_id)\n+                    .and_then(|trait_assoc_item| {\n+                        items\n+                            .iter()\n+                            .find(|i| i.ident == trait_assoc_item.ident)\n+                            .map(|impl_item| (impl_item, trait_assoc_item))\n+                    })\n+                {\n+                    let bounds = trait_generics\n+                        .map(|generics| {\n+                            get_generic_bound_spans(&generics, trait_name, trait_assoc_item.ident)\n+                        })\n+                        .unwrap_or_else(Vec::new);\n+                    cause.span = impl_item.span;\n+                    cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n+                        impl_span: item_span,\n+                        original: trait_assoc_item.ident.span,\n+                        bounds,\n+                    }));\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n@@ -163,170 +309,20 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let cause = self.cause(traits::MiscObligation);\n         let param_env = self.param_env;\n \n-        let item = &self.item;\n-        let extend_cause_with_original_assoc_item_obligation =\n-            |cause: &mut traits::ObligationCause<'_>,\n-             pred: &ty::Predicate<'_>,\n-             trait_assoc_items: &[ty::AssocItem]| {\n-                let trait_item = tcx\n-                    .hir()\n-                    .as_local_hir_id(trait_ref.def_id)\n-                    .and_then(|trait_id| tcx.hir().find(trait_id));\n-                let (trait_name, trait_generics) = match trait_item {\n-                    Some(hir::Node::Item(hir::Item {\n-                        ident,\n-                        kind: hir::ItemKind::Trait(.., generics, _, _),\n-                        ..\n-                    }))\n-                    | Some(hir::Node::Item(hir::Item {\n-                        ident,\n-                        kind: hir::ItemKind::TraitAlias(generics, _),\n-                        ..\n-                    })) => (Some(ident), Some(generics)),\n-                    _ => (None, None),\n-                };\n-\n-                let item_span = item.map(|i| tcx.sess.source_map().guess_head_span(i.span));\n-                match pred {\n-                    ty::Predicate::Projection(proj) => {\n-                        // The obligation comes not from the current `impl` nor the `trait` being\n-                        // implemented, but rather from a \"second order\" obligation, like in\n-                        // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs`:\n-                        //\n-                        //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n-                        //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n-                        //      |\n-                        //   LL |     type Ok;\n-                        //      |          -- associated type defined here\n-                        //   ...\n-                        //   LL | impl Bar for Foo {\n-                        //      | ---------------- in this `impl` item\n-                        //   LL |     type Ok = ();\n-                        //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n-                        //      |\n-                        //      = note: expected type `u32`\n-                        //                 found type `()`\n-                        //\n-                        // FIXME: we would want to point a span to all places that contributed to this\n-                        // obligation. In the case above, it should be closer to:\n-                        //\n-                        //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n-                        //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n-                        //      |\n-                        //   LL |     type Ok;\n-                        //      |          -- associated type defined here\n-                        //   LL |     type Sibling: Bar2<Ok=Self::Ok>;\n-                        //      |     -------------------------------- obligation set here\n-                        //   ...\n-                        //   LL | impl Bar for Foo {\n-                        //      | ---------------- in this `impl` item\n-                        //   LL |     type Ok = ();\n-                        //      |     ^^^^^^^^^^^^^ expected `u32`, found `()`\n-                        //   ...\n-                        //   LL | impl Bar2 for Foo2 {\n-                        //      | ---------------- in this `impl` item\n-                        //   LL |     type Ok = u32;\n-                        //      |     -------------- obligation set here\n-                        //      |\n-                        //      = note: expected type `u32`\n-                        //                 found type `()`\n-                        if let Some(hir::ItemKind::Impl { items, .. }) = item.map(|i| &i.kind) {\n-                            let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n-                            if let Some(impl_item) =\n-                                items.iter().find(|item| item.ident == trait_assoc_item.ident)\n-                            {\n-                                cause.span = impl_item.span;\n-                                cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n-                                    impl_span: item_span,\n-                                    original: trait_assoc_item.ident.span,\n-                                    bounds: vec![],\n-                                }));\n-                            }\n-                        }\n-                    }\n-                    ty::Predicate::Trait(proj, _) => {\n-                        // An associated item obligation born out of the `trait` failed to be met.\n-                        // Point at the `impl` that failed the obligation, the associated item that\n-                        // needed to meet the obligation, and the definition of that associated item,\n-                        // which should hold the obligation in most cases. An example can be seen in\n-                        // `src/test/ui/associated-types/point-at-type-on-obligation-failure-2.rs`:\n-                        //\n-                        //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n-                        //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n-                        //      |\n-                        //   LL |     type Assoc: Bar;\n-                        //      |          ----- associated type defined here\n-                        //   ...\n-                        //   LL | impl Foo for () {\n-                        //      | --------------- in this `impl` item\n-                        //   LL |     type Assoc = bool;\n-                        //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n-                        //\n-                        // If the obligation comes from the where clause in the `trait`, we point at it:\n-                        //\n-                        //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n-                        //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n-                        //      |\n-                        //      | trait Foo where <Self as Foo>>::Assoc: Bar {\n-                        //      |                 -------------------------- restricted in this bound\n-                        //   LL |     type Assoc;\n-                        //      |          ----- associated type defined here\n-                        //   ...\n-                        //   LL | impl Foo for () {\n-                        //      | --------------- in this `impl` item\n-                        //   LL |     type Assoc = bool;\n-                        //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n-                        if let (\n-                            ty::Projection(ty::ProjectionTy { item_def_id, .. }),\n-                            Some(hir::ItemKind::Impl { items, .. }),\n-                        ) = (&proj.skip_binder().self_ty().kind, item.map(|i| &i.kind))\n-                        {\n-                            if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n-                                .iter()\n-                                .find(|i| i.def_id == *item_def_id)\n-                                .and_then(|trait_assoc_item| {\n-                                    items\n-                                        .iter()\n-                                        .find(|i| i.ident == trait_assoc_item.ident)\n-                                        .map(|impl_item| (impl_item, trait_assoc_item))\n-                                })\n-                            {\n-                                let bounds = trait_generics\n-                                    .map(|generics| {\n-                                        get_generic_bound_spans(\n-                                            &generics,\n-                                            trait_name,\n-                                            trait_assoc_item.ident,\n-                                        )\n-                                    })\n-                                    .unwrap_or_else(Vec::new);\n-                                cause.span = impl_item.span;\n-                                cause.code = traits::AssocTypeBound(Box::new(AssocTypeBoundData {\n-                                    impl_span: item_span,\n-                                    original: trait_assoc_item.ident.span,\n-                                    bounds,\n-                                }));\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            };\n+        let item = self.item;\n \n         if let Elaborate::All = elaborate {\n-            // FIXME: Make `extend_cause_with_original_assoc_item_obligation` take an iterator\n-            // instead of a slice.\n-            let trait_assoc_items: Vec<_> =\n-                tcx.associated_items(trait_ref.def_id).in_definition_order().copied().collect();\n-\n             let predicates = obligations.iter().map(|obligation| obligation.predicate).collect();\n             let implied_obligations = traits::elaborate_predicates(tcx, predicates);\n             let implied_obligations = implied_obligations.map(|pred| {\n                 let mut cause = cause.clone();\n                 extend_cause_with_original_assoc_item_obligation(\n+                    tcx,\n+                    trait_ref,\n+                    item,\n                     &mut cause,\n                     &pred,\n-                    &*trait_assoc_items,\n+                    tcx.associated_items(trait_ref.def_id).in_definition_order().copied(),\n                 );\n                 traits::Obligation::new(cause, param_env, pred)\n             });"}, {"sha": "952398ef0685bd8f0345eb2ac6aa4fe9e7e5b21b", "filename": "src/test/ui/lint/unused_braces.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Ftest%2Fui%2Flint%2Funused_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Ftest%2Fui%2Flint%2Funused_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces.rs?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -1,29 +1,48 @@\n // check-pass\n #![warn(unused_braces, unused_parens)]\n \n+fn consume<T>(_: T) {}\n+\n fn main() {\n     let _ = (7);\n     //~^WARN unnecessary parentheses\n \n-    let _ = { 7 };\n-    //~^ WARN unnecessary braces\n+    // Do not emit a lint in these cases,\n+    // as we have to be careful with\n+    // `ref` patterns.\n+    {\n+        let _ = { 7 };\n+\n+        if let 7 = { 7 } { }\n+\n+        match { 7 } {\n+            _ => (),\n+        }\n+    }\n \n-    if let 7 = { 7 } {\n+    if { true } {\n+        //~^ WARN unnecessary braces\n+    }\n+\n+    while { false } {\n         //~^ WARN unnecessary braces\n     }\n \n     let _: [u8; { 3 }];\n     //~^ WARN unnecessary braces\n \n-    // do not emit error for multiline blocks.\n+    consume({ 7 });\n+    //~^ WARN unnecessary braces\n+\n+    // Do not emit lint for multiline blocks.\n     let _ = {\n         7\n     };\n \n-    // do not emit error for unsafe blocks.\n+    // Do not emit lint for unsafe blocks.\n     let _ = unsafe { 7 };\n \n-    // do not emit error, as the `{` would then\n+    // Do not emit lint, as the `{` would then\n     // be parsed as part of the `return`.\n     if { return } {\n "}, {"sha": "f195c00241836b375e09a4dc55166b9af42c36e7", "filename": "src/test/ui/lint/unused_braces.stderr", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Ftest%2Fui%2Flint%2Funused_braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Ftest%2Fui%2Flint%2Funused_braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces.stderr?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -1,5 +1,5 @@\n warning: unnecessary parentheses around assigned value\n-  --> $DIR/unused_braces.rs:5:13\n+  --> $DIR/unused_braces.rs:7:13\n    |\n LL |     let _ = (7);\n    |             ^^^ help: remove these parentheses\n@@ -10,27 +10,33 @@ note: the lint level is defined here\n LL | #![warn(unused_braces, unused_parens)]\n    |                        ^^^^^^^^^^^^^\n \n-warning: unnecessary braces around assigned value\n-  --> $DIR/unused_braces.rs:8:13\n+warning: unnecessary braces around `if` condition\n+  --> $DIR/unused_braces.rs:23:8\n    |\n-LL |     let _ = { 7 };\n-   |             ^^^^^ help: remove these braces\n+LL |     if { true } {\n+   |        ^^^^^^^^ help: remove these braces\n    |\n note: the lint level is defined here\n   --> $DIR/unused_braces.rs:2:9\n    |\n LL | #![warn(unused_braces, unused_parens)]\n    |         ^^^^^^^^^^^^^\n \n-warning: unnecessary braces around `let` scrutinee expression\n-  --> $DIR/unused_braces.rs:11:16\n+warning: unnecessary braces around `while` condition\n+  --> $DIR/unused_braces.rs:27:11\n    |\n-LL |     if let 7 = { 7 } {\n-   |                ^^^^^ help: remove these braces\n+LL |     while { false } {\n+   |           ^^^^^^^^^ help: remove these braces\n \n warning: unnecessary braces around const expression\n-  --> $DIR/unused_braces.rs:15:17\n+  --> $DIR/unused_braces.rs:31:17\n    |\n LL |     let _: [u8; { 3 }];\n    |                 ^^^^^ help: remove these braces\n \n+warning: unnecessary braces around function argument\n+  --> $DIR/unused_braces.rs:34:13\n+   |\n+LL |     consume({ 7 });\n+   |             ^^^^^ help: remove these braces\n+"}, {"sha": "d0b059744e1fd94e00ba6dd8e2989691c619f227", "filename": "src/test/ui/lint/unused_braces_borrow.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Ftest%2Fui%2Flint%2Funused_braces_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Ftest%2Fui%2Flint%2Funused_braces_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces_borrow.rs?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -10,13 +10,15 @@ struct A {\n     b: u32,\n }\n \n+fn consume<T>(_: T) {}\n+\n fn main() {\n     let a = A {\n         a: 42,\n         b: 1729,\n     };\n \n-    let _ = &{ a.b };\n-    let _ = { a.b };\n+    consume(&{ a.b });\n+    consume({ a.b });\n     //~^ WARN unnecessary braces\n }", "previous_filename": "src/test/ui/lint/unused_parens_borrow.rs"}, {"sha": "82fb4375611c9e4e6ef40b5932c7c7a0fec8c812", "filename": "src/test/ui/lint/unused_braces_borrow.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Ftest%2Fui%2Flint%2Funused_braces_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/485c5fb6e1bf12cd11a8fac5ee94962e17cff74b/src%2Ftest%2Fui%2Flint%2Funused_braces_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces_borrow.stderr?ref=485c5fb6e1bf12cd11a8fac5ee94962e17cff74b", "patch": "@@ -1,11 +1,11 @@\n-warning: unnecessary braces around assigned value\n-  --> $DIR/unused_parens_borrow.rs:20:13\n+warning: unnecessary braces around function argument\n+  --> $DIR/unused_braces_borrow.rs:22:13\n    |\n-LL |     let _ = { a.b };\n+LL |     consume({ a.b });\n    |             ^^^^^^^ help: remove these braces\n    |\n note: the lint level is defined here\n-  --> $DIR/unused_parens_borrow.rs:2:9\n+  --> $DIR/unused_braces_borrow.rs:2:9\n    |\n LL | #![warn(unused_braces)]\n    |         ^^^^^^^^^^^^^", "previous_filename": "src/test/ui/lint/unused_parens_borrow.stderr"}]}