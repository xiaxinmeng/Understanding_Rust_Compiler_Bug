{"sha": "6ecabe352a34a0fb290b2639e2eccd4317c85556", "node_id": "C_kwDOAAsO6NoAKDZlY2FiZTM1MmEzNGEwZmIyOTBiMjYzOWUyZWNjZDQzMTdjODU1NTY", "commit": {"author": {"name": "bitgaoshu", "email": "bitgaoshu@gmail.com", "date": "2022-06-24T11:11:35Z"}, "committer": {"name": "bitgaoshu", "email": "bitgaoshu@gmail.com", "date": "2022-06-24T11:11:35Z"}, "message": "functions resolve to impl", "tree": {"sha": "1c8668453ddefa126fb5c99ce9de17f8d5a35570", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c8668453ddefa126fb5c99ce9de17f8d5a35570"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ecabe352a34a0fb290b2639e2eccd4317c85556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ecabe352a34a0fb290b2639e2eccd4317c85556", "html_url": "https://github.com/rust-lang/rust/commit/6ecabe352a34a0fb290b2639e2eccd4317c85556", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ecabe352a34a0fb290b2639e2eccd4317c85556/comments", "author": {"login": "bitgaoshu", "id": 7943146, "node_id": "MDQ6VXNlcjc5NDMxNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/7943146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitgaoshu", "html_url": "https://github.com/bitgaoshu", "followers_url": "https://api.github.com/users/bitgaoshu/followers", "following_url": "https://api.github.com/users/bitgaoshu/following{/other_user}", "gists_url": "https://api.github.com/users/bitgaoshu/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitgaoshu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitgaoshu/subscriptions", "organizations_url": "https://api.github.com/users/bitgaoshu/orgs", "repos_url": "https://api.github.com/users/bitgaoshu/repos", "events_url": "https://api.github.com/users/bitgaoshu/events{/privacy}", "received_events_url": "https://api.github.com/users/bitgaoshu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bitgaoshu", "id": 7943146, "node_id": "MDQ6VXNlcjc5NDMxNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/7943146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitgaoshu", "html_url": "https://github.com/bitgaoshu", "followers_url": "https://api.github.com/users/bitgaoshu/followers", "following_url": "https://api.github.com/users/bitgaoshu/following{/other_user}", "gists_url": "https://api.github.com/users/bitgaoshu/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitgaoshu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitgaoshu/subscriptions", "organizations_url": "https://api.github.com/users/bitgaoshu/orgs", "repos_url": "https://api.github.com/users/bitgaoshu/repos", "events_url": "https://api.github.com/users/bitgaoshu/events{/privacy}", "received_events_url": "https://api.github.com/users/bitgaoshu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36fadc4224622d8bfd220d37d4c19931f6cfc6c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/36fadc4224622d8bfd220d37d4c19931f6cfc6c6", "html_url": "https://github.com/rust-lang/rust/commit/36fadc4224622d8bfd220d37d4c19931f6cfc6c6"}], "stats": {"total": 152, "additions": 50, "deletions": 102}, "files": [{"sha": "aa10b0f878fdea6fc246986dae4332c22be9c2b7", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ecabe352a34a0fb290b2639e2eccd4317c85556/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecabe352a34a0fb290b2639e2eccd4317c85556/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=6ecabe352a34a0fb290b2639e2eccd4317c85556", "patch": "@@ -348,9 +348,6 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_method_call(call).map(Function::from)\n     }\n \n-    pub fn resolve_impl_method(&self, call: &ast::Expr) -> Option<Function> {\n-        self.imp.resolve_impl_method(call).map(Function::from)\n-    }\n     pub fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         self.imp.resolve_method_call_as_callable(call)\n     }\n@@ -981,10 +978,6 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(call.syntax())?.resolve_method_call(self.db, call).map(|(id, _)| id)\n     }\n \n-    fn resolve_impl_method(&self, call: &ast::Expr) -> Option<FunctionId> {\n-        self.analyze(call.syntax())?.resolve_impl_method(self.db, call)\n-    }\n-\n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         let source_analyzer = self.analyze(call.syntax())?;\n         let (func, subst) = source_analyzer.resolve_method_call(self.db, call)?;"}, {"sha": "3faae8fc4b8bdff26dfefb281962d4c74c43d660", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 48, "deletions": 51, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6ecabe352a34a0fb290b2639e2eccd4317c85556/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecabe352a34a0fb290b2639e2eccd4317c85556/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=6ecabe352a34a0fb290b2639e2eccd4317c85556", "patch": "@@ -21,8 +21,8 @@ use hir_def::{\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n-    AsMacroCall, DefWithBodyId, FieldId, FunctionId, ItemContainerId, LocalFieldId, Lookup,\n-    ModuleDefId, VariantId,\n+    AsMacroCall, AssocItemId, DefWithBodyId, FieldId, FunctionId, ItemContainerId, LocalFieldId,\n+    Lookup, ModuleDefId, VariantId,\n };\n use hir_expand::{\n     builtin_fn_macro::BuiltinFnLikeExpander, hygiene::Hygiene, name::AsName, HirFileId, InFile,\n@@ -245,55 +245,9 @@ impl SourceAnalyzer {\n         call: &ast::MethodCallExpr,\n     ) -> Option<(FunctionId, Substitution)> {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n-        self.infer.as_ref()?.method_resolution(expr_id)\n-    }\n-\n-    pub(crate) fn resolve_impl_method(\n-        &self,\n-        db: &dyn HirDatabase,\n-        call: &ast::Expr,\n-    ) -> Option<FunctionId> {\n-        let infered = self.infer.as_ref()?;\n-        let expr_id = self.expr_id(db, call)?;\n-\n-        let mut fun_info = None;\n-        match call {\n-            &ast::Expr::MethodCallExpr(..) => {\n-                let (func, subs) = infered.method_resolution(expr_id)?;\n-                if subs.is_empty(Interner) {\n-                    return None;\n-                }\n-                fun_info.replace((func, subs.at(Interner, 0).ty(Interner)?.clone()));\n-            }\n-            &ast::Expr::PathExpr(..) => {\n-                let func_ty = infered.type_of_expr.get(expr_id)?;\n-                if let TyKind::FnDef(fn_def, subs) = func_ty.kind(Interner) {\n-                    if subs.is_empty(Interner) {\n-                        return None;\n-                    }\n-                    if let hir_ty::CallableDefId::FunctionId(f_id) =\n-                        db.lookup_intern_callable_def(fn_def.clone().into())\n-                    {\n-                        fun_info.replace((f_id, subs.at(Interner, 0).ty(Interner)?.clone()));\n-                    }\n-                }\n-            }\n-            _ => (),\n-        };\n-        let (func, self_ty) = fun_info?;\n-        let impled_trait = match func.lookup(db.upcast()).container {\n-            ItemContainerId::TraitId(trait_id) => trait_id,\n-            _ => return None,\n-        };\n-\n-        let krate = self.resolver.krate();\n-        let trait_env = self.resolver.body_owner()?.as_generic_def_id().map_or_else(\n-            || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n-            |d| db.trait_environment(d),\n-        );\n-\n-        let fun_data = db.function_data(func);\n-        method_resolution::lookup_impl_method(&self_ty, db, trait_env, impled_trait, &fun_data.name)\n+        let (f_in_trait, substs) = self.infer.as_ref()?.method_resolution(expr_id)?;\n+        let f_in_impl = self.resolve_impl_method(db, f_in_trait, &substs);\n+        Some((f_in_impl.unwrap_or(f_in_trait), substs))\n     }\n \n     pub(crate) fn resolve_field(\n@@ -391,6 +345,25 @@ impl SourceAnalyzer {\n                 let expr_id = self.expr_id(db, &path_expr.into())?;\n                 let infer = self.infer.as_ref()?;\n                 if let Some(assoc) = infer.assoc_resolutions_for_expr(expr_id) {\n+                    let assoc = match assoc {\n+                        AssocItemId::FunctionId(f_in_trait) => {\n+                            match infer.type_of_expr.get(expr_id) {\n+                                None => assoc,\n+                                Some(func_ty) => {\n+                                    if let TyKind::FnDef(_fn_def, subs) = func_ty.kind(Interner) {\n+                                        self.resolve_impl_method(db, f_in_trait, subs)\n+                                            .map(AssocItemId::FunctionId)\n+                                            .unwrap_or(assoc)\n+                                    } else {\n+                                        assoc\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                        _ => assoc,\n+                    };\n+\n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n                 }\n                 if let Some(VariantId::EnumVariantId(variant)) =\n@@ -616,6 +589,30 @@ impl SourceAnalyzer {\n         }\n         false\n     }\n+\n+    fn resolve_impl_method(\n+        &self,\n+        db: &dyn HirDatabase,\n+        func: FunctionId,\n+        substs: &Substitution,\n+    ) -> Option<FunctionId> {\n+        let impled_trait = match func.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(trait_id) => trait_id,\n+            _ => return None,\n+        };\n+        if substs.is_empty(Interner) {\n+            return None;\n+        }\n+        let self_ty = substs.at(Interner, 0).ty(Interner)?;\n+        let krate = self.resolver.krate();\n+        let trait_env = self.resolver.body_owner()?.as_generic_def_id().map_or_else(\n+            || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n+            |d| db.trait_environment(d),\n+        );\n+\n+        let fun_data = db.function_data(func);\n+        method_resolution::lookup_impl_method(self_ty, db, trait_env, impled_trait, &fun_data.name)\n+    }\n }\n \n fn scope_for("}, {"sha": "540cc70dd5228cf9d78898f0f41be98c0fb40512", "filename": "crates/ide-db/src/defs.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6ecabe352a34a0fb290b2639e2eccd4317c85556/crates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecabe352a34a0fb290b2639e2eccd4317c85556/crates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fdefs.rs?ref=6ecabe352a34a0fb290b2639e2eccd4317c85556", "patch": "@@ -162,22 +162,6 @@ impl IdentClass {\n             .or_else(|| NameClass::classify_lifetime(sema, lifetime).map(IdentClass::NameClass))\n     }\n \n-    pub fn classify_token_to_impl(\n-        sema: &Semantics<RootDatabase>,\n-        token: &SyntaxToken,\n-    ) -> Option<Definition> {\n-        let p = token.parent()?;\n-        match_ast! {\n-            match p {\n-                ast::NameRef(name_ref) => match NameRefClass::classify_to_impl(sema, name_ref)? {\n-                    NameRefClass::Definition(d) => Some(d),\n-                    _ => None,\n-                },\n-                _ => None,\n-            }\n-        }\n-    }\n-\n     pub fn definitions(self) -> ArrayVec<Definition, 2> {\n         let mut res = ArrayVec::new();\n         match self {\n@@ -433,29 +417,6 @@ impl NameRefClass {\n         }\n     }\n \n-    fn classify_to_impl(\n-        sema: &Semantics<RootDatabase>,\n-        name_ref: ast::NameRef,\n-    ) -> Option<NameRefClass> {\n-        let parent = name_ref.syntax().parent()?;\n-        let expr = match_ast! {\n-            match parent {\n-                ast::MethodCallExpr(method_call) => {\n-                    Some(ast::Expr::MethodCallExpr(method_call))\n-                },\n-                ast::PathSegment(..) => {\n-                    parent.ancestors()\n-                    .find_map(ast::PathExpr::cast)\n-                    .map(ast::Expr::PathExpr)\n-                },\n-                _=> None\n-            }\n-        };\n-        expr.as_ref()\n-            .and_then(|e| sema.resolve_impl_method(e))\n-            .map(Definition::Function)\n-            .map(NameRefClass::Definition)\n-    }\n     pub fn classify_lifetime(\n         sema: &Semantics<RootDatabase>,\n         lifetime: &ast::Lifetime,"}, {"sha": "e44b5020c373505bfb41b9027012cfb9d3328e28", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ecabe352a34a0fb290b2639e2eccd4317c85556/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecabe352a34a0fb290b2639e2eccd4317c85556/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=6ecabe352a34a0fb290b2639e2eccd4317c85556", "patch": "@@ -65,7 +65,7 @@ pub(crate) fn goto_definition(\n                     .definitions()\n                     .into_iter()\n                     .flat_map(|def| {\n-                        try_filter_trait_item_definition(sema, &def, &token)\n+                        try_filter_trait_item_definition(sema, &def)\n                             .unwrap_or_else(|| def_to_nav(sema.db, def))\n                     })\n                     .collect(),\n@@ -114,14 +114,11 @@ fn try_lookup_include_path(\n fn try_filter_trait_item_definition(\n     sema: &Semantics<RootDatabase>,\n     def: &Definition,\n-    token: &SyntaxToken,\n ) -> Option<Vec<NavigationTarget>> {\n     let db = sema.db;\n     let assoc = def.as_assoc_item(db)?;\n     match assoc {\n-        AssocItem::Function(..) => {\n-            IdentClass::classify_token_to_impl(sema, &token).map(|def| def_to_nav(db, def))\n-        }\n+        AssocItem::Function(..) => None,\n         AssocItem::Const(..) | AssocItem::TypeAlias(..) => {\n             let imp = match assoc.container(db) {\n                 hir::AssocItemContainer::Impl(imp) => imp,"}]}