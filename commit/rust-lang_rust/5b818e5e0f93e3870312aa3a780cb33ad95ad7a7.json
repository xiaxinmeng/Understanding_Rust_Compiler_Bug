{"sha": "5b818e5e0f93e3870312aa3a780cb33ad95ad7a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViODE4ZTVlMGY5M2UzODcwMzEyYWEzYTc4MGNiMzNhZDk1YWQ3YTc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-18T14:06:59Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-18T14:06:59Z"}, "message": "Use native `ar` to create archive files\n\nWorkaround for #672", "tree": {"sha": "3b4d23aa22d2cd0de25279e954e8119bdb785e8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b4d23aa22d2cd0de25279e954e8119bdb785e8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b818e5e0f93e3870312aa3a780cb33ad95ad7a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b818e5e0f93e3870312aa3a780cb33ad95ad7a7", "html_url": "https://github.com/rust-lang/rust/commit/5b818e5e0f93e3870312aa3a780cb33ad95ad7a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b818e5e0f93e3870312aa3a780cb33ad95ad7a7/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2add773752379006f74867eec78fceec2c6403a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2add773752379006f74867eec78fceec2c6403a4", "html_url": "https://github.com/rust-lang/rust/commit/2add773752379006f74867eec78fceec2c6403a4"}], "stats": {"total": 67, "additions": 45, "deletions": 22}, "files": [{"sha": "6d76fb14c97c09babad289c4ed3da743beda175a", "filename": "src/archive.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5b818e5e0f93e3870312aa3a780cb33ad95ad7a7/src%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b818e5e0f93e3870312aa3a780cb33ad95ad7a7/src%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Farchive.rs?ref=5b818e5e0f93e3870312aa3a780cb33ad95ad7a7", "patch": "@@ -9,20 +9,20 @@ use rustc_codegen_ssa::back::archive::{ArchiveBuilder, find_library};\n struct ArchiveConfig<'a> {\n     sess: &'a Session,\n     dst: PathBuf,\n-    src: Option<PathBuf>,\n     lib_search_paths: Vec<PathBuf>,\n+    use_native_ar: bool,\n     use_gnu_style_archive: bool,\n }\n \n #[derive(Debug)]\n enum ArchiveEntry {\n     FromArchive { archive_index: usize, entry_index: usize },\n-    File(File),\n+    File(PathBuf),\n }\n \n pub struct ArArchiveBuilder<'a> {\n     config: ArchiveConfig<'a>,\n-    src_archives: Vec<ar::Archive<File>>,\n+    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n     // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n     // the end of an archive for linkers to not get confused.\n     entries: Vec<(String, ArchiveEntry)>,\n@@ -35,14 +35,14 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         let config = ArchiveConfig {\n             sess,\n             dst: output.to_path_buf(),\n-            src: input.map(|p| p.to_path_buf()),\n             lib_search_paths: archive_search_paths(sess),\n+            use_native_ar: true, // FIXME fix rust-ar to not emit corrupted archive files.\n             // FIXME test for linux and System V derivatives instead\n             use_gnu_style_archive: !sess.target.target.options.is_like_osx,\n         };\n \n-        let (src_archives, entries) = if let Some(src) = &config.src {\n-            let mut archive = ar::Archive::new(File::open(src).unwrap());\n+        let (src_archives, entries) = if let Some(input) = input {\n+            let mut archive = ar::Archive::new(File::open(input).unwrap());\n             let mut entries = Vec::new();\n \n             let mut i = 0;\n@@ -55,7 +55,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 i += 1;\n             }\n \n-            (vec![archive], entries)\n+            (vec![(input.to_owned(), archive)], entries)\n         } else {\n             (vec![], Vec::new())\n         };\n@@ -83,21 +83,21 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     fn add_file(&mut self, file: &Path) {\n         self.entries.push((\n             file.file_name().unwrap().to_str().unwrap().to_string(),\n-            ArchiveEntry::File(File::open(file).unwrap()),\n+            ArchiveEntry::File(file.to_owned()),\n         ));\n     }\n \n     fn add_native_library(&mut self, name: &str) {\n         let location = find_library(name, &self.config.lib_search_paths, self.config.sess);\n-        self.add_archive(&location, |_| false).unwrap_or_else(|e| {\n+        self.add_archive(location.clone(), |_| false).unwrap_or_else(|e| {\n             panic!(\"failed to add native library {}: {}\", location.to_string_lossy(), e);\n         });\n     }\n \n     fn add_rlib(&mut self, rlib: &Path, name: &str, lto: bool, skip_objects: bool) -> std::io::Result<()> {\n         let obj_start = name.to_owned();\n \n-        self.add_archive(rlib, move |fname: &str| {\n+        self.add_archive(rlib.to_owned(), move |fname: &str| {\n             // Ignore bytecode/metadata files, no matter the name.\n             if fname.ends_with(RLIB_BYTECODE_EXTENSION) || fname == METADATA_FILENAME {\n                 return true;\n@@ -124,43 +124,66 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n     }\n \n     fn build(mut self) {\n-        enum BuilderKind {\n+        use std::process::Command;\n+\n+        fn add_file_using_ar(archive: &Path, file: &Path) {\n+            Command::new(\"ar\")\n+                .arg(\"r\") // add or replace file\n+                .arg(\"-c\") // silence created file message\n+                .arg(archive)\n+                .arg(&file)\n+                .status()\n+                .unwrap();\n+        }\n+\n+        enum BuilderKind<'a> {\n             Bsd(ar::Builder<File>),\n             Gnu(ar::GnuBuilder<File>),\n+            NativeAr(&'a Path),\n         }\n \n-        let archive_file = File::create(&self.config.dst).unwrap();\n-        let mut builder = if self.config.use_gnu_style_archive {\n+        let mut builder = if self.config.use_native_ar {\n+            BuilderKind::NativeAr(&self.config.dst)\n+        } else if self.config.use_gnu_style_archive {\n             BuilderKind::Gnu(ar::GnuBuilder::new(\n-                archive_file,\n+                File::create(&self.config.dst).unwrap(),\n                 self.entries.iter().map(|(name, _)| name.as_bytes().to_vec()).collect(),\n             ))\n         } else {\n-            BuilderKind::Bsd(ar::Builder::new(archive_file))\n+            BuilderKind::Bsd(ar::Builder::new(File::create(&self.config.dst).unwrap()))\n         };\n \n         // Add all files\n         for (entry_name, entry) in self.entries.into_iter() {\n             match entry {\n                 ArchiveEntry::FromArchive { archive_index, entry_index } => {\n-                    let entry = self.src_archives[archive_index].jump_to_entry(entry_index).unwrap();\n+                    let (ref src_archive_path, ref mut src_archive) = self.src_archives[archive_index];\n+                    let entry = src_archive.jump_to_entry(entry_index).unwrap();\n                     let orig_header = entry.header();\n \n+                    // FIXME implement clone for `ar::Archive`.\n                     let mut header =\n                         ar::Header::new(orig_header.identifier().to_vec(), orig_header.size());\n                     header.set_mtime(orig_header.mtime());\n                     header.set_uid(orig_header.uid());\n                     header.set_gid(orig_header.gid());\n                     header.set_mode(orig_header.mode());\n+\n                     match builder {\n                         BuilderKind::Bsd(ref mut builder) => builder.append(&header, entry).unwrap(),\n                         BuilderKind::Gnu(ref mut builder) => builder.append(&header, entry).unwrap(),\n+                        BuilderKind::NativeAr(archive_file) => {\n+                            Command::new(\"ar\").arg(\"x\").arg(src_archive_path).arg(&entry_name).status().unwrap();\n+                            add_file_using_ar(archive_file, Path::new(&entry_name));\n+                            std::fs::remove_file(entry_name).unwrap();\n+                        }\n                     }\n                 }\n-                ArchiveEntry::File(mut file) => {\n+                ArchiveEntry::File(file) => {\n                     match builder {\n-                        BuilderKind::Bsd(ref mut builder) => builder.append_file(entry_name.as_bytes(), &mut file).unwrap(),\n-                        BuilderKind::Gnu(ref mut builder) => builder.append_file(entry_name.as_bytes(), &mut file).unwrap(),\n+                        BuilderKind::Bsd(ref mut builder) => builder.append_file(entry_name.as_bytes(), &mut File::open(file).unwrap()).unwrap(),\n+                        BuilderKind::Gnu(ref mut builder) => builder.append_file(entry_name.as_bytes(), &mut File::open(file).unwrap()).unwrap(),\n+                        BuilderKind::NativeAr(archive_file) => add_file_using_ar(archive_file, &file),\n                     }\n                 }\n             }\n@@ -183,10 +206,10 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n }\n \n impl<'a> ArArchiveBuilder<'a> {\n-    fn add_archive<F>(&mut self, archive: &Path, mut skip: F) -> std::io::Result<()>\n+    fn add_archive<F>(&mut self, archive_path: PathBuf, mut skip: F) -> std::io::Result<()>\n         where F: FnMut(&str) -> bool + 'static\n     {\n-        let mut archive = ar::Archive::new(std::fs::File::open(archive)?);\n+        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n         let archive_index = self.src_archives.len();\n \n         let mut i = 0;\n@@ -202,7 +225,7 @@ impl<'a> ArArchiveBuilder<'a> {\n             i += 1;\n         }\n \n-        self.src_archives.push(archive);\n+        self.src_archives.push((archive_path, archive));\n         Ok(())\n     }\n }"}]}