{"sha": "a36dc368d7c914014356c3d1f240f2caaf4692c2", "node_id": "C_kwDOAAsO6NoAKGEzNmRjMzY4ZDdjOTE0MDE0MzU2YzNkMWYyNDBmMmNhYWY0NjkyYzI", "commit": {"author": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2022-03-18T00:08:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-18T00:08:54Z"}, "message": "Merge pull request #5268 from calebcartwright/subtree-sync-2022-03-16\n\nsubtree sync", "tree": {"sha": "4b905feb8309c988eb494c61e0cba4fc54a7c1ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b905feb8309c988eb494c61e0cba4fc54a7c1ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a36dc368d7c914014356c3d1f240f2caaf4692c2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiM82WCRBK7hj4Ov3rIwAA7iEIALIWS1RVjVD+nNGrS1D7QVdr\nX6wYzzlbPc7Ga+A9eb4kSIYXGeO95tHI11EPpJbLiYDn/wGgbeaw8LYQ7ldOXyQz\nX8+uXdf+EEcatxSm6dJy+vVJ9aI80ThMiDV4rWM/Uo5ITNP0t5NabmV3QLXhd2CM\nIKn+w88HlKgMufgqhvMM+j0UalBzok5wF1A6ieECN1feX/IKXXO4D4VYqnq4Tdky\n1l7Wd/mIhfy4djvLVaUvcqLIoNDyPTWJ8j72AH9qxwSP+/81Y3tAs+b3Z9d7qZYN\nxAdeK1LrTBlw7K2SQPfXQqrqnbIGSIU1dRZrIumZKhCAM550SZWJAIsDQrcNB9I=\n=rIte\n-----END PGP SIGNATURE-----\n", "payload": "tree 4b905feb8309c988eb494c61e0cba4fc54a7c1ad\nparent 1bb85bdf6b6dc0e205009b9f531a6220fe2031f9\nparent 432b8dea64b84cec3efc3205bdc9e6687d59812d\nauthor Caleb Cartwright <calebcartwright@users.noreply.github.com> 1647562134 -0500\ncommitter GitHub <noreply@github.com> 1647562134 -0500\n\nMerge pull request #5268 from calebcartwright/subtree-sync-2022-03-16\n\nsubtree sync"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a36dc368d7c914014356c3d1f240f2caaf4692c2", "html_url": "https://github.com/rust-lang/rust/commit/a36dc368d7c914014356c3d1f240f2caaf4692c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a36dc368d7c914014356c3d1f240f2caaf4692c2/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bb85bdf6b6dc0e205009b9f531a6220fe2031f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bb85bdf6b6dc0e205009b9f531a6220fe2031f9", "html_url": "https://github.com/rust-lang/rust/commit/1bb85bdf6b6dc0e205009b9f531a6220fe2031f9"}, {"sha": "432b8dea64b84cec3efc3205bdc9e6687d59812d", "url": "https://api.github.com/repos/rust-lang/rust/commits/432b8dea64b84cec3efc3205bdc9e6687d59812d", "html_url": "https://github.com/rust-lang/rust/commit/432b8dea64b84cec3efc3205bdc9e6687d59812d"}], "stats": {"total": 171, "additions": 100, "deletions": 71}, "files": [{"sha": "b932e15ef7461ce0e9794ddcab0d478b75889344", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -275,9 +275,9 @@ dependencies = [\n \n [[package]]\n name = \"itertools\"\n-version = \"0.9.0\"\n+version = \"0.10.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"284f18f85651fe11e8a991b2adb42cb078325c996ed026d994719efcfca1d54b\"\n+checksum = \"a9a9d19fa1e79b6215ff29b9d6880b706147f16e9b1dbb1e4e5947b5b02bc5e3\"\n dependencies = [\n  \"either\",\n ]"}, {"sha": "764714638a9787c214227c4580ea4203442f071f", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -33,7 +33,7 @@ rustfmt-format-diff = []\n generic-simd = [\"bytecount/generic-simd\"]\n \n [dependencies]\n-itertools = \"0.9\"\n+itertools = \"0.10.1\"\n toml = \"0.5\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\""}, {"sha": "0d407f11994bb182fd4c0e5257f8d03373b6aecc", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-01-23\"\n+channel = \"nightly-2022-03-17\"\n components = [\"rustc-dev\"]"}, {"sha": "4f333cd27cefe5c9a70d1a7e883819f126dcf8de", "filename": "src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -1533,7 +1533,7 @@ fn rewrite_struct_lit<'a>(\n     enum StructLitField<'a> {\n         Regular(&'a ast::ExprField),\n         Base(&'a ast::Expr),\n-        Rest(&'a Span),\n+        Rest(Span),\n     }\n \n     // 2 = \" {\".len()\n@@ -1568,7 +1568,7 @@ fn rewrite_struct_lit<'a>(\n         let field_iter = fields.iter().map(StructLitField::Regular).chain(\n             match struct_rest {\n                 ast::StructRest::Base(expr) => Some(StructLitField::Base(&**expr)),\n-                ast::StructRest::Rest(span) => Some(StructLitField::Rest(span)),\n+                ast::StructRest::Rest(span) => Some(StructLitField::Rest(*span)),\n                 ast::StructRest::None => None,\n             }\n             .into_iter(),"}, {"sha": "9b35d28f1195006c5903359f6f3caf5423d2d5ce", "filename": "src/items.rs", "status": "modified", "additions": 74, "deletions": 34, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -694,7 +694,8 @@ pub(crate) fn format_impl(\n     let where_span_end = context.snippet_provider.opt_span_before(missing_span, \"{\");\n     let where_clause_str = rewrite_where_clause(\n         context,\n-        &generics.where_clause,\n+        &generics.where_clause.predicates,\n+        generics.where_clause.span,\n         context.config.brace_style(),\n         Shape::legacy(where_budget, offset.block_only()),\n         false,\n@@ -1059,7 +1060,8 @@ pub(crate) fn format_trait(\n             let option = WhereClauseOption::snuggled(&generics_str);\n             let where_clause_str = rewrite_where_clause(\n                 context,\n-                &generics.where_clause,\n+                &generics.where_clause.predicates,\n+                generics.where_clause.span,\n                 context.config.brace_style(),\n                 Shape::legacy(where_budget, offset.block_only()),\n                 where_on_new_line,\n@@ -1178,7 +1180,8 @@ impl<'a> Rewrite for TraitAliasBounds<'a> {\n \n         let where_str = rewrite_where_clause(\n             context,\n-            &self.generics.where_clause,\n+            &self.generics.where_clause.predicates,\n+            self.generics.where_clause.span,\n             context.config.brace_style(),\n             shape,\n             false,\n@@ -1441,7 +1444,8 @@ fn format_tuple_struct(\n             let option = WhereClauseOption::new(true, WhereClauseSpace::Newline);\n             rewrite_where_clause(\n                 context,\n-                &generics.where_clause,\n+                &generics.where_clause.predicates,\n+                generics.where_clause.span,\n                 context.config.brace_style(),\n                 Shape::legacy(where_budget, offset.block_only()),\n                 false,\n@@ -1507,6 +1511,8 @@ struct TyAliasRewriteInfo<'c, 'g>(\n     &'c RewriteContext<'c>,\n     Indent,\n     &'g ast::Generics,\n+    (ast::TyAliasWhereClause, ast::TyAliasWhereClause),\n+    usize,\n     symbol::Ident,\n     Span,\n );\n@@ -1525,14 +1531,24 @@ pub(crate) fn rewrite_type_alias<'a, 'b>(\n         ref generics,\n         ref bounds,\n         ref ty,\n+        where_clauses,\n+        where_predicates_split,\n     } = *ty_alias_kind;\n     let ty_opt = ty.as_ref();\n     let (ident, vis) = match visitor_kind {\n         Item(i) => (i.ident, &i.vis),\n         AssocTraitItem(i) | AssocImplItem(i) => (i.ident, &i.vis),\n         ForeignItem(i) => (i.ident, &i.vis),\n     };\n-    let rw_info = &TyAliasRewriteInfo(context, indent, generics, ident, span);\n+    let rw_info = &TyAliasRewriteInfo(\n+        context,\n+        indent,\n+        generics,\n+        where_clauses,\n+        where_predicates_split,\n+        ident,\n+        span,\n+    );\n     let op_ty = opaque_ty(ty);\n     // Type Aliases are formatted slightly differently depending on the context\n     // in which they appear, whether they are opaque, and whether they are associated.\n@@ -1568,7 +1584,22 @@ fn rewrite_ty<R: Rewrite>(\n     vis: &ast::Visibility,\n ) -> Option<String> {\n     let mut result = String::with_capacity(128);\n-    let TyAliasRewriteInfo(context, indent, generics, ident, span) = *rw_info;\n+    let TyAliasRewriteInfo(\n+        context,\n+        indent,\n+        generics,\n+        where_clauses,\n+        where_predicates_split,\n+        ident,\n+        span,\n+    ) = *rw_info;\n+    let (before_where_predicates, after_where_predicates) = generics\n+        .where_clause\n+        .predicates\n+        .split_at(where_predicates_split);\n+    if !after_where_predicates.is_empty() {\n+        return None;\n+    }\n     result.push_str(&format!(\"{}type \", format_visibility(context, vis)));\n     let ident_str = rewrite_ident(context, ident);\n \n@@ -1599,7 +1630,8 @@ fn rewrite_ty<R: Rewrite>(\n     }\n     let where_clause_str = rewrite_where_clause(\n         context,\n-        &generics.where_clause,\n+        before_where_predicates,\n+        where_clauses.0.1,\n         context.config.brace_style(),\n         Shape::legacy(where_budget, indent),\n         false,\n@@ -1613,7 +1645,7 @@ fn rewrite_ty<R: Rewrite>(\n     if let Some(ty) = rhs {\n         // If there's a where clause, add a newline before the assignment. Otherwise just add a\n         // space.\n-        let has_where = !generics.where_clause.predicates.is_empty();\n+        let has_where = !before_where_predicates.is_empty();\n         if has_where {\n             result.push_str(&indent.to_string_with_newline(context.config));\n         } else {\n@@ -1623,7 +1655,7 @@ fn rewrite_ty<R: Rewrite>(\n         let comment_span = context\n             .snippet_provider\n             .opt_span_before(span, \"=\")\n-            .map(|op_lo| mk_sp(generics.where_clause.span.hi(), op_lo));\n+            .map(|op_lo| mk_sp(where_clauses.0.1.hi(), op_lo));\n \n         let lhs = match comment_span {\n             Some(comment_span)\n@@ -2186,7 +2218,7 @@ fn rewrite_fn_base(\n     let generics_str = rewrite_generics(\n         context,\n         rewrite_ident(context, ident),\n-        fn_sig.generics,\n+        &fn_sig.generics,\n         shape,\n     )?;\n     result.push_str(&generics_str);\n@@ -2426,7 +2458,8 @@ fn rewrite_fn_base(\n     }\n     let where_clause_str = rewrite_where_clause(\n         context,\n-        where_clause,\n+        &where_clause.predicates,\n+        where_clause.span,\n         context.config.brace_style(),\n         Shape::indented(indent, context.config),\n         true,\n@@ -2702,7 +2735,8 @@ fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize) -> O\n \n fn rewrite_where_clause_rfc_style(\n     context: &RewriteContext<'_>,\n-    where_clause: &ast::WhereClause,\n+    predicates: &[ast::WherePredicate],\n+    where_span: Span,\n     shape: Shape,\n     terminator: &str,\n     span_end: Option<BytePos>,\n@@ -2711,7 +2745,8 @@ fn rewrite_where_clause_rfc_style(\n ) -> Option<String> {\n     let (where_keyword, allow_single_line) = rewrite_where_keyword(\n         context,\n-        where_clause,\n+        predicates,\n+        where_span,\n         shape,\n         span_end_before_where,\n         where_clause_option,\n@@ -2724,12 +2759,12 @@ fn rewrite_where_clause_rfc_style(\n         .block_left(context.config.tab_spaces())?\n         .sub_width(1)?;\n     let force_single_line = context.config.where_single_line()\n-        && where_clause.predicates.len() == 1\n+        && predicates.len() == 1\n         && !where_clause_option.veto_single_line;\n \n     let preds_str = rewrite_bounds_on_where_clause(\n         context,\n-        where_clause,\n+        predicates,\n         clause_shape,\n         terminator,\n         span_end,\n@@ -2753,7 +2788,8 @@ fn rewrite_where_clause_rfc_style(\n /// Rewrite `where` and comment around it.\n fn rewrite_where_keyword(\n     context: &RewriteContext<'_>,\n-    where_clause: &ast::WhereClause,\n+    predicates: &[ast::WherePredicate],\n+    where_span: Span,\n     shape: Shape,\n     span_end_before_where: BytePos,\n     where_clause_option: WhereClauseOption,\n@@ -2773,7 +2809,7 @@ fn rewrite_where_keyword(\n     };\n \n     let (span_before, span_after) =\n-        missing_span_before_after_where(span_end_before_where, where_clause);\n+        missing_span_before_after_where(span_end_before_where, predicates, where_span);\n     let (comment_before, comment_after) =\n         rewrite_comments_before_after_where(context, span_before, span_after, shape)?;\n \n@@ -2799,22 +2835,22 @@ fn rewrite_where_keyword(\n /// Rewrite bounds on a where clause.\n fn rewrite_bounds_on_where_clause(\n     context: &RewriteContext<'_>,\n-    where_clause: &ast::WhereClause,\n+    predicates: &[ast::WherePredicate],\n     shape: Shape,\n     terminator: &str,\n     span_end: Option<BytePos>,\n     where_clause_option: WhereClauseOption,\n     force_single_line: bool,\n ) -> Option<String> {\n-    let span_start = where_clause.predicates[0].span().lo();\n+    let span_start = predicates[0].span().lo();\n     // If we don't have the start of the next span, then use the end of the\n     // predicates, but that means we miss comments.\n-    let len = where_clause.predicates.len();\n-    let end_of_preds = where_clause.predicates[len - 1].span().hi();\n+    let len = predicates.len();\n+    let end_of_preds = predicates[len - 1].span().hi();\n     let span_end = span_end.unwrap_or(end_of_preds);\n     let items = itemize_list(\n         context.snippet_provider,\n-        where_clause.predicates.iter(),\n+        predicates.iter(),\n         terminator,\n         \",\",\n         |pred| pred.span().lo(),\n@@ -2847,7 +2883,8 @@ fn rewrite_bounds_on_where_clause(\n \n fn rewrite_where_clause(\n     context: &RewriteContext<'_>,\n-    where_clause: &ast::WhereClause,\n+    predicates: &[ast::WherePredicate],\n+    where_span: Span,\n     brace_style: BraceStyle,\n     shape: Shape,\n     on_new_line: bool,\n@@ -2856,14 +2893,15 @@ fn rewrite_where_clause(\n     span_end_before_where: BytePos,\n     where_clause_option: WhereClauseOption,\n ) -> Option<String> {\n-    if where_clause.predicates.is_empty() {\n+    if predicates.is_empty() {\n         return Some(String::new());\n     }\n \n     if context.config.indent_style() == IndentStyle::Block {\n         return rewrite_where_clause_rfc_style(\n             context,\n-            where_clause,\n+            predicates,\n+            where_span,\n             shape,\n             terminator,\n             span_end,\n@@ -2883,15 +2921,15 @@ fn rewrite_where_clause(\n     // be out by a char or two.\n \n     let budget = context.config.max_width() - offset.width();\n-    let span_start = where_clause.predicates[0].span().lo();\n+    let span_start = predicates[0].span().lo();\n     // If we don't have the start of the next span, then use the end of the\n     // predicates, but that means we miss comments.\n-    let len = where_clause.predicates.len();\n-    let end_of_preds = where_clause.predicates[len - 1].span().hi();\n+    let len = predicates.len();\n+    let end_of_preds = predicates[len - 1].span().hi();\n     let span_end = span_end.unwrap_or(end_of_preds);\n     let items = itemize_list(\n         context.snippet_provider,\n-        where_clause.predicates.iter(),\n+        predicates.iter(),\n         terminator,\n         \",\",\n         |pred| pred.span().lo(),\n@@ -2946,12 +2984,13 @@ fn rewrite_where_clause(\n \n fn missing_span_before_after_where(\n     before_item_span_end: BytePos,\n-    where_clause: &ast::WhereClause,\n+    predicates: &[ast::WherePredicate],\n+    where_span: Span,\n ) -> (Span, Span) {\n-    let missing_span_before = mk_sp(before_item_span_end, where_clause.span.lo());\n+    let missing_span_before = mk_sp(before_item_span_end, where_span.lo());\n     // 5 = `where`\n-    let pos_after_where = where_clause.span.lo() + BytePos(5);\n-    let missing_span_after = mk_sp(pos_after_where, where_clause.predicates[0].span().lo());\n+    let pos_after_where = where_span.lo() + BytePos(5);\n+    let missing_span_after = mk_sp(pos_after_where, predicates[0].span().lo());\n     (missing_span_before, missing_span_after)\n }\n \n@@ -3040,7 +3079,8 @@ fn format_generics(\n         }\n         let where_clause_str = rewrite_where_clause(\n             context,\n-            &generics.where_clause,\n+            &generics.where_clause.predicates,\n+            generics.where_clause.span,\n             brace_style,\n             Shape::legacy(budget, offset.block_only()),\n             true,"}, {"sha": "a65dc66f7972e06f3648025b18f5998cff209d64", "filename": "src/modules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -131,7 +131,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         mut self,\n         krate: &'ast ast::Crate,\n     ) -> Result<FileModMap<'ast>, ModuleResolutionError> {\n-        let root_filename = self.parse_sess.span_to_filename(krate.span);\n+        let root_filename = self.parse_sess.span_to_filename(krate.spans.inner_span);\n         self.directory.path = match root_filename {\n             FileName::Real(ref p) => p.parent().unwrap_or(Path::new(\"\")).to_path_buf(),\n             _ => PathBuf::new(),\n@@ -142,7 +142,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             self.visit_mod_from_ast(&krate.items)?;\n         }\n \n-        let snippet_provider = self.parse_sess.snippet_provider(krate.span);\n+        let snippet_provider = self.parse_sess.snippet_provider(krate.spans.inner_span);\n \n         self.file_map.insert(\n             root_filename,\n@@ -446,7 +446,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                 }\n             }\n             Err(mod_err) if !mods_outside_ast.is_empty() => {\n-                if let ModError::ParserError(mut e) = mod_err {\n+                if let ModError::ParserError(e) = mod_err {\n                     e.cancel();\n                 }\n                 Ok(Some(SubModKind::MultiExternal(mods_outside_ast)))"}, {"sha": "306b6bb745ee6d0221571f17ccc32fdad0986336", "filename": "src/parse/macros/cfg_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fparse%2Fmacros%2Fcfg_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fparse%2Fmacros%2Fcfg_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fmacros%2Fcfg_if.rs?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -57,7 +57,7 @@ fn parse_cfg_if_inner<'a>(\n             let item = match parser.parse_item(ForceCollect::No) {\n                 Ok(Some(item_ptr)) => item_ptr.into_inner(),\n                 Ok(None) => continue,\n-                Err(mut err) => {\n+                Err(err) => {\n                     err.cancel();\n                     parser.sess.span_diagnostic.reset_err_count();\n                     return Err("}, {"sha": "4c541de04be0894d4a53ef53890043105b345630", "filename": "src/parse/macros/lazy_static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fparse%2Fmacros%2Flazy_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fparse%2Fmacros%2Flazy_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fmacros%2Flazy_static.rs?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn parse_lazy_static(\n                         val\n                     }\n                 }\n-                Err(mut err) => {\n+                Err(err) => {\n                     err.cancel();\n                     parser.sess.span_diagnostic.reset_err_count();\n                     return None;"}, {"sha": "fd738908170f86ef5264737ae24ab466228c146e", "filename": "src/parse/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fparse%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fparse%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fmacros%2Fmod.rs?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -36,7 +36,7 @@ fn parse_macro_arg<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n                         return Some(MacroArg::$macro_arg($f(x)?));\n                     }\n                 }\n-                Err(mut e) => {\n+                Err(e) => {\n                     e.cancel();\n                     parser.sess.span_diagnostic.reset_err_count();\n                 }"}, {"sha": "268c72649a65a9c93155429dd76e71facc761f2c", "filename": "src/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fparser.rs?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -113,9 +113,9 @@ impl<'a> Parser<'a> {\n         let result = catch_unwind(AssertUnwindSafe(|| {\n             let mut parser = new_parser_from_file(sess.inner(), path, Some(span));\n             match parser.parse_mod(&TokenKind::Eof) {\n-                Ok(result) => Some(result),\n+                Ok((a, i, spans)) => Some((a, i, spans.inner_span)),\n                 Err(mut e) => {\n-                    sess.emit_or_cancel_diagnostic(&mut e);\n+                    e.emit();\n                     if sess.can_reset_errors() {\n                         sess.reset_errors();\n                     }"}, {"sha": "bf9acd435b920caf10188e774c21c5e19e143b13", "filename": "src/parse/session.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fsession.rs?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -61,7 +61,7 @@ impl Emitter for SilentOnIgnoredFilesEmitter {\n         None\n     }\n     fn emit_diagnostic(&mut self, db: &Diagnostic) {\n-        if db.level == DiagnosticLevel::Fatal {\n+        if db.level() == DiagnosticLevel::Fatal {\n             return self.handle_non_ignoreable_error(db);\n         }\n         if let Some(primary_span) = &db.span.primary_span() {\n@@ -260,17 +260,6 @@ impl ParseSess {\n         }\n     }\n \n-    pub(crate) fn emit_or_cancel_diagnostic(&self, diagnostic: &mut Diagnostic) {\n-        self.parse_sess.span_diagnostic.emit_diagnostic(diagnostic);\n-        // The Handler will check whether the diagnostic should be emitted\n-        // based on the user's rustfmt configuration and the originating file\n-        // that caused the parser error. If the Handler determined it should skip\n-        // emission then we need to ensure the diagnostic is cancelled.\n-        if !diagnostic.cancelled() {\n-            diagnostic.cancel();\n-        }\n-    }\n-\n     pub(super) fn can_reset_errors(&self) -> bool {\n         self.can_reset_errors.load(Ordering::Acquire)\n     }\n@@ -322,7 +311,7 @@ mod tests {\n         use super::*;\n         use crate::config::IgnoreList;\n         use crate::utils::mk_sp;\n-        use rustc_span::{FileName as SourceMapFileName, MultiSpan, RealFileName, DUMMY_SP};\n+        use rustc_span::{FileName as SourceMapFileName, MultiSpan, RealFileName};\n         use std::path::PathBuf;\n         use std::sync::atomic::AtomicU32;\n \n@@ -340,16 +329,12 @@ mod tests {\n         }\n \n         fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {\n-            Diagnostic {\n-                level,\n-                code: None,\n-                message: vec![],\n-                children: vec![],\n-                suggestions: vec![],\n-                span: span.unwrap_or_else(MultiSpan::new),\n-                sort_span: DUMMY_SP,\n-                is_lint: false,\n+            let mut diag = Diagnostic::new(level, \"\");\n+            diag.message.clear();\n+            if let Some(span) = span {\n+                diag.span = span;\n             }\n+            diag\n         }\n \n         fn build_emitter("}, {"sha": "3ebfa551d1cbc2e17ca5eac859328fdddb8e3421", "filename": "src/visitor.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36dc368d7c914014356c3d1f240f2caaf4692c2/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=a36dc368d7c914014356c3d1f240f2caaf4692c2", "patch": "@@ -915,7 +915,11 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         let ident_str = rewrite_ident(&self.get_context(), ident).to_owned();\n         self.push_str(&ident_str);\n \n-        if let ast::ModKind::Loaded(ref items, ast::Inline::Yes, inner_span) = mod_kind {\n+        if let ast::ModKind::Loaded(ref items, ast::Inline::Yes, ref spans) = mod_kind {\n+            let ast::ModSpans {\n+                inner_span,\n+                inject_use_span: _,\n+            } = *spans;\n             match self.config.brace_style() {\n                 BraceStyle::AlwaysNextLine => {\n                     let indent_str = self.block_indent.to_string_with_newline(self.config);"}]}