{"sha": "315750ac92a8114a96b35352ec88f82d21d5fbec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNTc1MGFjOTJhODExNGE5NmIzNTM1MmVjODhmODJkMjFkNWZiZWM=", "commit": {"author": {"name": "Ricky Taylor", "email": "rickytaylor26@gmail.com", "date": "2015-03-04T22:58:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-12T21:50:36Z"}, "message": "Very hacky MSVC hacks.\n\nConflicts:\n\tmk/platform.mk\n\tsrc/librustc/session/config.rs\n\tsrc/librustc_back/target/aarch64_apple_ios.rs\n\tsrc/librustc_back/target/aarch64_linux_android.rs\n\tsrc/librustc_back/target/arm_linux_androideabi.rs\n\tsrc/librustc_back/target/arm_unknown_linux_gnueabi.rs\n\tsrc/librustc_back/target/arm_unknown_linux_gnueabihf.rs\n\tsrc/librustc_back/target/armv7_apple_ios.rs\n\tsrc/librustc_back/target/armv7s_apple_ios.rs\n\tsrc/librustc_back/target/i386_apple_ios.rs\n\tsrc/librustc_back/target/i686_apple_darwin.rs\n\tsrc/librustc_back/target/i686_pc_windows_gnu.rs\n\tsrc/librustc_back/target/i686_unknown_dragonfly.rs\n\tsrc/librustc_back/target/i686_unknown_linux_gnu.rs\n\tsrc/librustc_back/target/mips_unknown_linux_gnu.rs\n\tsrc/librustc_back/target/mipsel_unknown_linux_gnu.rs\n\tsrc/librustc_back/target/mod.rs\n\tsrc/librustc_back/target/powerpc_unknown_linux_gnu.rs\n\tsrc/librustc_back/target/x86_64_apple_darwin.rs\n\tsrc/librustc_back/target/x86_64_apple_ios.rs\n\tsrc/librustc_back/target/x86_64_pc_windows_gnu.rs\n\tsrc/librustc_back/target/x86_64_unknown_dragonfly.rs\n\tsrc/librustc_back/target/x86_64_unknown_freebsd.rs\n\tsrc/librustc_back/target/x86_64_unknown_linux_gnu.rs\n\tsrc/librustc_back/target/x86_64_unknown_openbsd.rs\n\tsrc/librustc_llvm/lib.rs\n\tsrc/librustc_trans/back/link.rs\n\tsrc/librustc_trans/trans/base.rs\n\tsrc/libstd/os.rs\n\tsrc/rustllvm/RustWrapper.cpp", "tree": {"sha": "f5ac24a5c9dd7d603909509c0b3c590ca00abab9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5ac24a5c9dd7d603909509c0b3c590ca00abab9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/315750ac92a8114a96b35352ec88f82d21d5fbec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/315750ac92a8114a96b35352ec88f82d21d5fbec", "html_url": "https://github.com/rust-lang/rust/commit/315750ac92a8114a96b35352ec88f82d21d5fbec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/315750ac92a8114a96b35352ec88f82d21d5fbec/comments", "author": {"login": "ricky26", "id": 262786, "node_id": "MDQ6VXNlcjI2Mjc4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/262786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ricky26", "html_url": "https://github.com/ricky26", "followers_url": "https://api.github.com/users/ricky26/followers", "following_url": "https://api.github.com/users/ricky26/following{/other_user}", "gists_url": "https://api.github.com/users/ricky26/gists{/gist_id}", "starred_url": "https://api.github.com/users/ricky26/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ricky26/subscriptions", "organizations_url": "https://api.github.com/users/ricky26/orgs", "repos_url": "https://api.github.com/users/ricky26/repos", "events_url": "https://api.github.com/users/ricky26/events{/privacy}", "received_events_url": "https://api.github.com/users/ricky26/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ca008dcf12283247122f25928630f2a484ff768", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ca008dcf12283247122f25928630f2a484ff768", "html_url": "https://github.com/rust-lang/rust/commit/3ca008dcf12283247122f25928630f2a484ff768"}], "stats": {"total": 1564, "additions": 1535, "deletions": 29}, "files": [{"sha": "4e150488224b8902937a3d19f12254cec79e50d7", "filename": "configure", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/configure", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -610,7 +610,7 @@ CFG_TARGET=$(to_llvm_triple $CFG_TARGET)\n # there's no rpath. This is where the build system itself puts libraries;\n # --libdir is used to configure the installation directory.\n # FIXME: This needs to parameterized over target triples. Do it in platform.mk\n-if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ]\n+if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] || [ \"$CFG_OSTYPE\" = \"pc-windows-msvc\" ]\n then\n     CFG_LIBDIR_RELATIVE=bin\n else\n@@ -628,7 +628,8 @@ esac\n \n CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`\n \n-if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] && [ \"$CFG_LIBDIR_RELATIVE\" != \"bin\" ]; then\n+if ( [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] || [ \"$CFG_OSTYPE\" = \"pc-windows-msvc\" ] ) \\\n+\t&& [ \"$CFG_LIBDIR_RELATIVE\" != \"bin\" ]; then\n     err \"libdir on windows should be set to 'bin'\"\n fi\n \n@@ -803,7 +804,7 @@ then\n fi\n \n BIN_SUF=\n-if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ]\n+if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] || [ \"$CFG_OSTYPE\" = \"pc-windows-msvc\" ]\n then\n     BIN_SUF=.exe\n fi\n@@ -1311,7 +1312,7 @@ do\n         # (llvm's configure tries to find pthread first, so we have to disable it explicitly.)\n         # Also note that pthreads works badly on mingw-w64 systems: #8996\n         case \"$CFG_BUILD\" in\n-            (*-windows-*)\n+            (*-windows-gnu)\n             LLVM_OPTS=\"$LLVM_OPTS --disable-pthreads\"\n             ;;\n         esac"}, {"sha": "8cd09fa9043c8136d1e2d4878f2a1dd304ae8011", "filename": "mk/cfg/aarch64-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Faarch64-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Faarch64-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-apple-ios.mk?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -5,6 +5,7 @@ ifneq ($(findstring darwin,$(CFG_OSTYPE)),)\n CFG_IOS_SDK_aarch64-apple-ios := $(shell xcrun --show-sdk-path -sdk iphoneos 2>/dev/null)\n CFG_IOS_SDK_FLAGS_aarch64-apple-ios := -target aarch64-apple-darwin -isysroot $(CFG_IOS_SDK_aarch64-apple-ios) -mios-version-min=7.0 -arch arm64\n CC_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos clang)\n+LINK_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos clang)\n CXX_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos clang++)\n CPP_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos clang++)\n AR_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos ar)"}, {"sha": "9e0245e093d8abc05196eb52a5b715b41d2987e3", "filename": "mk/cfg/aarch64-linux-android.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Faarch64-linux-android.mk", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Faarch64-linux-android.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-linux-android.mk?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -1,6 +1,7 @@\n # aarch64-linux-android configuration\n # CROSS_PREFIX_aarch64-linux-android-\n CC_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-gcc\n+LINK_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-gcc\n CXX_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-g++\n CPP_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-gcc -E\n AR_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-ar"}, {"sha": "88d7700db820f78d3c439fa07b8ecf03ea56c554", "filename": "mk/cfg/aarch64-unknown-linux-gnu.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Faarch64-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Faarch64-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-unknown-linux-gnu.mk?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -1,6 +1,7 @@\n # aarch64-unknown-linux-gnu configuration\n CROSS_PREFIX_aarch64-unknown-linux-gnu=aarch64-linux-gnu-\n CC_aarch64-unknown-linux-gnu=gcc\n+LINK_aarch64-unknown-linux-gnu=gcc\n CXX_aarch64-unknown-linux-gnu=g++\n CPP_aarch64-unknown-linux-gnu=gcc -E\n AR_aarch64-unknown-linux-gnu=ar"}, {"sha": "a66f70f6305ed6e62b6cce45b45f35c1a5220e0f", "filename": "mk/cfg/arm-linux-androideabi.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Farm-linux-androideabi.mk", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Farm-linux-androideabi.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-linux-androideabi.mk?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -1,4 +1,5 @@\n # arm-linux-androideabi configuration\n+LINK_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-gcc\n CC_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-gcc\n CXX_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-g++\n CPP_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-gcc -E"}, {"sha": "10aaf137e8b3a40e29bb3494a0c0bed60714c3a5", "filename": "mk/cfg/x86_64-pc-windows-gnu.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -1,6 +1,7 @@\n # x86_64-pc-windows-gnu configuration\n CROSS_PREFIX_x86_64-pc-windows-gnu=x86_64-w64-mingw32-\n CC_x86_64-pc-windows-gnu=gcc\n+LINK_x86_64-pc-windows-gnu=gcc\n CXX_x86_64-pc-windows-gnu=g++\n CPP_x86_64-pc-windows-gnu=gcc -E\n AR_x86_64-pc-windows-gnu=ar"}, {"sha": "3235dcece6d49419ecb0918232931cce429eb22f", "filename": "mk/cfg/x86_64-pc-windows-msvc.mk", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -0,0 +1,29 @@\n+# x86_64-pc-windows-msvc configuration\n+CROSS_PREFIX_x86_64-pc-windows-msvc=\n+CC_x86_64-pc-windows-msvc=cl\n+LINK_x86_64-pc-windows-msvc=link\n+CXX_x86_64-pc-windows-msvc=g++\n+CPP_x86_64-pc-windows-msvc=gcc -E\n+AR_x86_64-pc-windows-msvc=llvm-ar\n+CFG_LIB_NAME_x86_64-pc-windows-msvc=$(1).dll\n+CFG_STATIC_LIB_NAME_x86_64-pc-windows-msvc=$(1).lib\n+CFG_LIB_GLOB_x86_64-pc-windows-msvc=$(1)-*.dll\n+CFG_LIB_DSYM_GLOB_x86_64-pc-windows-msvc=$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_x86_64-pc-windows-msvc := $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-pc-windows-msvc := $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_x86_64-pc-windows-msvc := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_x86_64-pc-windows-msvc := -shared -g -m64\n+CFG_GCCISH_DEF_FLAG_x86_64-pc-windows-msvc :=\n+CFG_GCCISH_PRE_LIB_FLAGS_x86_64-pc-windows-msvc :=\n+CFG_GCCISH_POST_LIB_FLAGS_x86_64-pc-windows-msvc :=\n+CFG_DEF_SUFFIX_x86_64-pc-windows-msvc := .windows.def\n+CFG_LLC_FLAGS_x86_64-pc-windows-msvc :=\n+CFG_INSTALL_NAME_x86_64-pc-windows-msvc =\n+CFG_EXE_SUFFIX_x86_64-pc-windows-msvc := .exe\n+CFG_WINDOWSY_x86_64-pc-windows-msvc := 1\n+CFG_UNIXY_x86_64-pc-windows-msvc :=\n+CFG_PATH_MUNGE_x86_64-pc-windows-msvc :=\n+CFG_LDPATH_x86_64-pc-windows-msvc :=\n+CFG_RUN_x86_64-pc-windows-msvc=$(2)\n+CFG_RUN_TARG_x86_64-pc-windows-msvc=$(call CFG_RUN_x86_64-pc-windows-msvc,,$(2))\n+CFG_GNU_TRIPLE_x86_64-pc-windows-msvc := x86_64-w64-mingw32"}, {"sha": "01865319b3fa7313aff64e89692fdbb90a69823d", "filename": "mk/platform.mk", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -145,14 +145,15 @@ FIND_COMPILER = $(word 1,$(1:ccache=))\n define CFG_MAKE_TOOLCHAIN\n   # Prepend the tools with their prefix if cross compiling\n   ifneq ($(CFG_BUILD),$(1))\n-       CC_$(1)=$(CROSS_PREFIX_$(1))$(CC_$(1))\n-       CXX_$(1)=$(CROSS_PREFIX_$(1))$(CXX_$(1))\n-       CPP_$(1)=$(CROSS_PREFIX_$(1))$(CPP_$(1))\n-       AR_$(1)=$(CROSS_PREFIX_$(1))$(AR_$(1))\n-       RUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(CC_$(1))) \\\n-           -C ar=$$(call FIND_COMPILER,$$(AR_$(1))) $(RUSTC_CROSS_FLAGS_$(1))\n-\n-       RUSTC_FLAGS_$(1)=$$(RUSTC_CROSS_FLAGS_$(1)) $(RUSTC_FLAGS_$(1))\n+\tCC_$(1)=$(CROSS_PREFIX_$(1))$(CC_$(1))\n+\tCXX_$(1)=$(CROSS_PREFIX_$(1))$(CXX_$(1))\n+\tCPP_$(1)=$(CROSS_PREFIX_$(1))$(CPP_$(1))\n+\tAR_$(1)=$(CROSS_PREFIX_$(1))$(AR_$(1))\n+\tLINK_$(1)=$(CROSS_PREFIX_$(1))$(LINK_$(1))\n+\tRUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(LINK_$(1))) \\\n+\t    -C ar=$$(call FIND_COMPILER,$$(AR_$(1))) $(RUSTC_CROSS_FLAGS_$(1))\n+\n+\tRUSTC_FLAGS_$(1)=$$(RUSTC_CROSS_FLAGS_$(1)) $(RUSTC_FLAGS_$(1))\n   endif\n \n   CFG_COMPILE_C_$(1) = $$(CC_$(1)) \\"}, {"sha": "4154ee29388c0a29de03314cd8dfd71f1e35c431", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -632,6 +632,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     let mut ret = vec![ // Target bindings.\n          attr::mk_word_item(fam.clone()),\n          mk(InternedString::new(\"target_os\"), intern(os)),\n+         mk(InternedString::new(\"target_abi\"), intern(abi)),\n          mk(InternedString::new(\"target_family\"), fam),\n          mk(InternedString::new(\"target_arch\"), intern(arch)),\n          mk(InternedString::new(\"target_endian\"), intern(end)),"}, {"sha": "796aa3b08ca4ece822626a932843c403085c1c4b", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> Target {\n         target_env: \"gnu\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"linux\".to_string(),\n+        target_abi: \"\".to_string(),\n         options: base,\n     }\n }"}, {"sha": "425077e97388de9c3a6d539627e03043b4723694", "filename": "src/librustc_back/target/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -22,7 +22,11 @@ pub fn target() -> Target {\n         target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"linux\".to_string(),\n+<<<<<<< HEAD\n         target_env: \"gnu\".to_string(),\n+=======\n+        target_abi: \"\".to_string(),\n+>>>>>>> 9f1453c... Very hacky MSVC hacks.\n         options: base,\n     }\n }"}, {"sha": "de8086bec4f671335e33212c6ea58fe85ec466cf", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -145,6 +145,7 @@ pub struct TargetOptions {\n     /// only really used for figuring out how to find libraries, since Windows uses its own\n     /// library naming convention. Defaults to false.\n     pub is_like_windows: bool,\n+    pub is_like_msvc: bool,\n     /// Whether the target toolchain is like Android's. Only useful for compiling against Android.\n     /// Defaults to false.\n     pub is_like_android: bool,\n@@ -188,6 +189,7 @@ impl Default for TargetOptions {\n             is_like_osx: false,\n             is_like_windows: false,\n             is_like_android: false,\n+            is_like_msvc: false,\n             linker_is_gnu: false,\n             has_rpath: false,\n             no_compiler_rt: false,\n@@ -371,7 +373,9 @@ impl Target {\n             armv7s_apple_ios,\n \n             x86_64_pc_windows_gnu,\n-            i686_pc_windows_gnu\n+            i686_pc_windows_gnu,\n+\n+            x86_64_pc_windows_msvc\n         );\n \n "}, {"sha": "f53f0df0e639d50428c76e35a4ba4534e45f707b", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        // FIXME(#13846) this should be enabled for windows\n+        function_sections: false,\n+        linker: \"link\".to_string(),\n+        dynamic_linking: true,\n+        executables: true,\n+        dll_prefix: \"\".to_string(),\n+        dll_suffix: \".dll\".to_string(),\n+        exe_suffix: \".exe\".to_string(),\n+        staticlib_prefix: \"\".to_string(),\n+        staticlib_suffix: \".lib\".to_string(),\n+        morestack: false,\n+        is_like_windows: true,\n+        is_like_msvc: true,\n+        pre_link_args: Vec::new(),\n+\n+        .. Default::default()\n+    }\n+}"}, {"sha": "1cbf7aabeefe0b712c1733572944024d75499a1b", "filename": "src/librustc_back/target/x86_64_pc_windows_msvc.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::windows_msvc_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+\n+    Target {\n+        // FIXME: Test this. Copied from linux (#2398)\n+        data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n+                      s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n+        llvm_target: \"x86_64-pc-windows-msvc\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_abi: \"msvc\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "74d7dc95b24af42e5aa996ccef75563b7447b9fe", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -55,6 +55,7 @@ pub use self::CallConv::*;\n pub use self::Visibility::*;\n pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n+pub use self::DLLStorageClass::*;\n \n use std::ffi::CString;\n use std::cell::RefCell;\n@@ -114,6 +115,13 @@ pub enum Linkage {\n     CommonLinkage = 14,\n }\n \n+#[derive(Copy)]\n+pub enum DLLStorageClass {\n+    DefaultStorageClass = 0,\n+    DLLImportStorageClass = 1,\n+    DLLExportStorageClass = 2,\n+}\n+\n #[repr(C)]\n #[derive(Copy, Clone, Debug)]\n pub enum DiagnosticSeverity {\n@@ -2125,6 +2133,12 @@ pub fn SetLinkage(global: ValueRef, link: Linkage) {\n     }\n }\n \n+pub fn SetDLLStorageClass(global: ValueRef, storage_class: DLLStorageClass) {\n+    unsafe {\n+        LLVMRustSetDLLStorageClass(global, storage_class as c_uint);\n+    }\n+}\n+\n pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n     unsafe {\n         LLVMSetUnnamedAddr(global, unnamed as Bool);"}, {"sha": "aa51afac1a4a476c3f4d996f5e8667170876ba86", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -8,22 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::archive::{Archive, ArchiveBuilder, ArchiveConfig, METADATA_FILENAME};\n-use super::archive;\n-use super::rpath;\n-use super::rpath::RPathConfig;\n+use super::archive::{ArchiveBuilder, ArchiveConfig, METADATA_FILENAME};\n use super::svh::Svh;\n+\n+use super::link_gnu;\n+use super::link_msvc;\n+\n use session::config;\n-use session::config::NoDebugInfo;\n use session::config::{OutputFilenames, Input, OutputTypeBitcode, OutputTypeExe, OutputTypeObject};\n use session::search_paths::PathKind;\n use session::Session;\n use metadata::common::LinkMeta;\n-use metadata::{encoder, cstore, filesearch, csearch, creader};\n+use metadata::{encoder, cstore, csearch, creader};\n use metadata::filesearch::FileDoesntMatch;\n use trans::{CrateContext, CrateTranslation, gensym_name};\n use middle::ty::{self, Ty};\n-use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n use util::fs::fix_windows_verbatim_for_gcc;"}, {"sha": "b1582a1a3c59678393f71c9b7be633f539539e15", "filename": "src/librustc_trans/back/link_gnu.rs", "status": "added", "additions": 568, "deletions": 0, "changes": 568, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Fback%2Flink_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Fback%2Flink_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink_gnu.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -0,0 +1,568 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::archive::{Archive, ArchiveConfig};\n+use super::archive;\n+use super::rpath;\n+use super::rpath::RPathConfig;\n+\n+use session::config;\n+use session::config::NoDebugInfo;\n+use session::search_paths::PathKind;\n+use session::Session;\n+use metadata::{cstore, filesearch, csearch};\n+use metadata::filesearch::FileDoesntMatch;\n+use trans::{CrateTranslation};\n+use util::common::time;\n+\n+use std::str;\n+use std::old_io::{fs, TempDir, Command};\n+use std::old_io;\n+\n+// Create a dynamic library or executable\n+//\n+// This will invoke the system linker/cc to create the resulting file. This\n+// links to all upstream files as well.\n+pub fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n+                 obj_filename: &Path, out_filename: &Path) {\n+    let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n+\n+    // The invocations of cc share some flags across platforms\n+    let pname = super::link::get_cc_prog(sess);\n+    let mut cmd = Command::new(&pname[..]);\n+\n+    cmd.args(&sess.target.target.options.pre_link_args[]);\n+    link_args(&mut cmd, sess, dylib, tmpdir.path(),\n+              trans, obj_filename, out_filename);\n+    cmd.args(&sess.target.target.options.post_link_args[]);\n+    if !sess.target.target.options.no_compiler_rt {\n+        cmd.arg(\"-lcompiler-rt\");\n+    }\n+\n+    if sess.opts.debugging_opts.print_link_args {\n+        println!(\"{:?}\", &cmd);\n+    }\n+\n+    // May have not found libraries in the right formats.\n+    sess.abort_if_errors();\n+\n+    // Invoke the system linker\n+    debug!(\"{:?}\", &cmd);\n+    let prog = time(sess.time_passes(), \"running linker\", (), |()| cmd.output());\n+    match prog {\n+        Ok(prog) => {\n+            if !prog.status.success() {\n+                sess.err(&format!(\"linking with `{}` failed: {}\",\n+                                 pname,\n+                                 prog.status)[]);\n+                sess.note(&format!(\"{:?}\", &cmd)[]);\n+                let mut output = prog.error.clone();\n+                output.push_all(&prog.output[]);\n+                sess.note(str::from_utf8(&output[..]).unwrap());\n+                sess.abort_if_errors();\n+            }\n+            debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n+            debug!(\"linker stdout:\\n{}\", String::from_utf8(prog.output).unwrap());\n+        },\n+        Err(e) => {\n+            sess.err(&format!(\"could not exec the linker `{}`: {}\",\n+                             pname,\n+                             e)[]);\n+            sess.abort_if_errors();\n+        }\n+    }\n+\n+\n+    // On OSX, debuggers need this utility to get run to do some munging of\n+    // the symbols\n+    if sess.target.target.options.is_like_osx && sess.opts.debuginfo != NoDebugInfo {\n+        match Command::new(\"dsymutil\").arg(out_filename).output() {\n+            Ok(..) => {}\n+            Err(e) => {\n+                sess.err(&format!(\"failed to run dsymutil: {}\", e)[]);\n+                sess.abort_if_errors();\n+            }\n+        }\n+    }\n+}\n+\n+fn link_args(cmd: &mut Command,\n+             sess: &Session,\n+             dylib: bool,\n+             tmpdir: &Path,\n+             trans: &CrateTranslation,\n+             obj_filename: &Path,\n+             out_filename: &Path) {\n+\n+    // The default library location, we need this to find the runtime.\n+    // The location of crates will be determined as needed.\n+    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n+\n+    // target descriptor\n+    let t = &sess.target.target;\n+\n+    cmd.arg(\"-L\").arg(&lib_path);\n+\n+    cmd.arg(\"-o\").arg(out_filename).arg(obj_filename);\n+\n+\n+    // Stack growth requires statically linking a __morestack function. Note\n+    // that this is listed *before* all other libraries. Due to the usage of the\n+    // --as-needed flag below, the standard library may only be useful for its\n+    // rust_stack_exhausted function. In this case, we must ensure that the\n+    // libmorestack.a file appears *before* the standard library (so we put it\n+    // at the very front).\n+    //\n+    // Most of the time this is sufficient, except for when LLVM gets super\n+    // clever. If, for example, we have a main function `fn main() {}`, LLVM\n+    // will optimize out calls to `__morestack` entirely because the function\n+    // doesn't need any stack at all!\n+    //\n+    // To get around this snag, we specially tell the linker to always include\n+    // all contents of this library. This way we're guaranteed that the linker\n+    // will include the __morestack symbol 100% of the time, always resolving\n+    // references to it even if the object above didn't use it.\n+    if t.options.morestack {\n+        if t.options.is_like_osx {\n+            let morestack = lib_path.join(\"libmorestack.a\");\n+\n+            let mut v = b\"-Wl,-force_load,\".to_vec();\n+            v.push_all(morestack.as_vec());\n+            cmd.arg(&v[..]);\n+        } else {\n+            cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n+        }\n+    }\n+\n+    // When linking a dynamic library, we put the metadata into a section of the\n+    // executable. This metadata is in a separate object file from the main\n+    // object file, so we link that in here.\n+    if dylib {\n+        cmd.arg(obj_filename.with_extension(\"metadata.o\"));\n+    }\n+\n+    if t.options.is_like_osx {\n+        // The dead_strip option to the linker specifies that functions and data\n+        // unreachable by the entry point will be removed. This is quite useful\n+        // with Rust's compilation model of compiling libraries at a time into\n+        // one object file. For example, this brings hello world from 1.7MB to\n+        // 458K.\n+        //\n+        // Note that this is done for both executables and dynamic libraries. We\n+        // won't get much benefit from dylibs because LLVM will have already\n+        // stripped away as much as it could. This has not been seen to impact\n+        // link times negatively.\n+        //\n+        // -dead_strip can't be part of the pre_link_args because it's also used for partial\n+        // linking when using multiple codegen units (-r). So we insert it here.\n+        cmd.arg(\"-Wl,-dead_strip\");\n+    }\n+\n+    // If we're building a dylib, we don't use --gc-sections because LLVM has\n+    // already done the best it can do, and we also don't want to eliminate the\n+    // metadata. If we're building an executable, however, --gc-sections drops\n+    // the size of hello world from 1.8MB to 597K, a 67% reduction.\n+    if !dylib && !t.options.is_like_osx {\n+        cmd.arg(\"-Wl,--gc-sections\");\n+    }\n+\n+    let used_link_args = sess.cstore.get_used_link_args().borrow();\n+\n+    if t.options.position_independent_executables {\n+        let empty_vec = Vec::new();\n+        let empty_str = String::new();\n+        let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n+        let mut args = args.iter().chain(used_link_args.iter());\n+        if !dylib\n+            && (t.options.relocation_model == \"pic\"\n+                || *sess.opts.cg.relocation_model.as_ref()\n+                   .unwrap_or(&empty_str) == \"pic\")\n+            && !args.any(|x| *x == \"-static\") {\n+            cmd.arg(\"-pie\");\n+        }\n+    }\n+\n+    if t.options.linker_is_gnu {\n+        // GNU-style linkers support optimization with -O. GNU ld doesn't need a\n+        // numeric argument, but other linkers do.\n+        if sess.opts.optimize == config::Default ||\n+           sess.opts.optimize == config::Aggressive {\n+            cmd.arg(\"-Wl,-O1\");\n+        }\n+    }\n+\n+    // We want to prevent the compiler from accidentally leaking in any system\n+    // libraries, so we explicitly ask gcc to not link to any libraries by\n+    // default. Note that this does not happen for windows because windows pulls\n+    // in some large number of libraries and I couldn't quite figure out which\n+    // subset we wanted.\n+    if !t.options.is_like_windows {\n+        cmd.arg(\"-nodefaultlibs\");\n+    }\n+\n+    // Mark all dynamic libraries and executables as compatible with ASLR\n+    // FIXME #17098: ASLR breaks gdb\n+    if t.options.is_like_windows && sess.opts.debuginfo == NoDebugInfo {\n+        // cmd.arg(\"-Wl,--dynamicbase\");\n+    }\n+\n+    // Take careful note of the ordering of the arguments we pass to the linker\n+    // here. Linkers will assume that things on the left depend on things to the\n+    // right. Things on the right cannot depend on things on the left. This is\n+    // all formally implemented in terms of resolving symbols (libs on the right\n+    // resolve unknown symbols of libs on the left, but not vice versa).\n+    //\n+    // For this reason, we have organized the arguments we pass to the linker as\n+    // such:\n+    //\n+    //  1. The local object that LLVM just generated\n+    //  2. Upstream rust libraries\n+    //  3. Local native libraries\n+    //  4. Upstream native libraries\n+    //\n+    // This is generally fairly natural, but some may expect 2 and 3 to be\n+    // swapped. The reason that all native libraries are put last is that it's\n+    // not recommended for a native library to depend on a symbol from a rust\n+    // crate. If this is the case then a staticlib crate is recommended, solving\n+    // the problem.\n+    //\n+    // Additionally, it is occasionally the case that upstream rust libraries\n+    // depend on a local native library. In the case of libraries such as\n+    // lua/glfw/etc the name of the library isn't the same across all platforms,\n+    // so only the consumer crate of a library knows the actual name. This means\n+    // that downstream crates will provide the #[link] attribute which upstream\n+    // crates will depend on. Hence local native libraries are after out\n+    // upstream rust crates.\n+    //\n+    // In theory this means that a symbol in an upstream native library will be\n+    // shadowed by a local native library when it wouldn't have been before, but\n+    // this kind of behavior is pretty platform specific and generally not\n+    // recommended anyway, so I don't think we're shooting ourself in the foot\n+    // much with that.\n+    add_upstream_rust_crates(cmd, sess, dylib, tmpdir, trans);\n+    add_local_native_libraries(cmd, sess);\n+    add_upstream_native_libraries(cmd, sess);\n+\n+    // # Telling the linker what we're doing\n+\n+    if dylib {\n+        // On mac we need to tell the linker to let this library be rpathed\n+        if sess.target.target.options.is_like_osx {\n+            cmd.args(&[\"-dynamiclib\", \"-Wl,-dylib\"]);\n+\n+            if sess.opts.cg.rpath {\n+                let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n+                v.push_all(out_filename.filename().unwrap());\n+                cmd.arg(&v[..]);\n+            }\n+        } else {\n+            cmd.arg(\"-shared\");\n+        }\n+    }\n+\n+    // FIXME (#2397): At some point we want to rpath our guesses as to\n+    // where extern libraries might live, based on the\n+    // addl_lib_search_paths\n+    if sess.opts.cg.rpath {\n+        let sysroot = sess.sysroot();\n+        let target_triple = &sess.opts.target_triple[];\n+        let get_install_prefix_lib_path = || {\n+            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n+            let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n+            let mut path = Path::new(install_prefix);\n+            path.push(&tlib);\n+\n+            path\n+        };\n+        let rpath_config = RPathConfig {\n+            used_crates: sess.cstore.get_used_crates(cstore::RequireDynamic),\n+            out_filename: out_filename.clone(),\n+            has_rpath: sess.target.target.options.has_rpath,\n+            is_like_osx: sess.target.target.options.is_like_osx,\n+            get_install_prefix_lib_path: get_install_prefix_lib_path,\n+            realpath: ::util::fs::realpath\n+        };\n+        cmd.args(&rpath::get_rpath_flags(rpath_config)[]);\n+    }\n+\n+    // Finally add all the linker arguments provided on the command line along\n+    // with any #[link_args] attributes found inside the crate\n+    let empty = Vec::new();\n+    cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n+    cmd.args(&used_link_args[..]);\n+}\n+\n+// # Native library linking\n+//\n+// User-supplied library search paths (-L on the command line). These are\n+// the same paths used to find Rust crates, so some of them may have been\n+// added already by the previous crate linking code. This only allows them\n+// to be found at compile time so it is still entirely up to outside\n+// forces to make sure that library can be found at runtime.\n+//\n+// Also note that the native libraries linked here are only the ones located\n+// in the current crate. Upstream crates with native library dependencies\n+// may have their native library pulled in above.\n+fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n+    sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n+        match k {\n+            PathKind::Framework => { cmd.arg(\"-F\").arg(path); }\n+            _ => { cmd.arg(\"-L\").arg(path); }\n+        }\n+        FileDoesntMatch\n+    });\n+\n+    // Some platforms take hints about whether a library is static or dynamic.\n+    // For those that support this, we ensure we pass the option if the library\n+    // was flagged \"static\" (most defaults are dynamic) to ensure that if\n+    // libfoo.a and libfoo.so both exist that the right one is chosen.\n+    let takes_hints = !sess.target.target.options.is_like_osx;\n+\n+    let libs = sess.cstore.get_used_libraries();\n+    let libs = libs.borrow();\n+\n+    let staticlibs = libs.iter().filter_map(|&(ref l, kind)| {\n+        if kind == cstore::NativeStatic {Some(l)} else {None}\n+    });\n+    let others = libs.iter().filter(|&&(_, kind)| {\n+        kind != cstore::NativeStatic\n+    });\n+\n+    // Platforms that take hints generally also support the --whole-archive\n+    // flag. We need to pass this flag when linking static native libraries to\n+    // ensure the entire library is included.\n+    //\n+    // For more details see #15460, but the gist is that the linker will strip\n+    // away any unused objects in the archive if we don't otherwise explicitly\n+    // reference them. This can occur for libraries which are just providing\n+    // bindings, libraries with generic functions, etc.\n+    if takes_hints {\n+        cmd.arg(\"-Wl,--whole-archive\").arg(\"-Wl,-Bstatic\");\n+    }\n+    let search_path = super::link::archive_search_paths(sess);\n+    for l in staticlibs {\n+        if takes_hints {\n+            cmd.arg(format!(\"-l{}\", l));\n+        } else {\n+            // -force_load is the OSX equivalent of --whole-archive, but it\n+            // involves passing the full path to the library to link.\n+            let lib = archive::find_library(&l[..],\n+                                            &sess.target.target.options.staticlib_prefix,\n+                                            &sess.target.target.options.staticlib_suffix,\n+                                            &search_path[..],\n+                                            &sess.diagnostic().handler);\n+            let mut v = b\"-Wl,-force_load,\".to_vec();\n+            v.push_all(lib.as_vec());\n+            cmd.arg(&v[..]);\n+        }\n+    }\n+    if takes_hints {\n+        cmd.arg(\"-Wl,--no-whole-archive\").arg(\"-Wl,-Bdynamic\");\n+    }\n+\n+    for &(ref l, kind) in others {\n+        match kind {\n+            cstore::NativeUnknown => {\n+                cmd.arg(format!(\"-l{}\", l));\n+            }\n+            cstore::NativeFramework => {\n+                cmd.arg(\"-framework\").arg(&l[..]);\n+            }\n+            cstore::NativeStatic => unreachable!(),\n+        }\n+    }\n+}\n+\n+// # Rust Crate linking\n+//\n+// Rust crates are not considered at all when creating an rlib output. All\n+// dependencies will be linked when producing the final output (instead of\n+// the intermediate rlib version)\n+fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n+                            dylib: bool, tmpdir: &Path,\n+                            trans: &CrateTranslation) {\n+    // All of the heavy lifting has previously been accomplished by the\n+    // dependency_format module of the compiler. This is just crawling the\n+    // output of that module, adding crates as necessary.\n+    //\n+    // Linking to a rlib involves just passing it to the linker (the linker\n+    // will slurp up the object files inside), and linking to a dynamic library\n+    // involves just passing the right -l flag.\n+\n+    let data = if dylib {\n+        &trans.crate_formats[config::CrateTypeDylib]\n+    } else {\n+        &trans.crate_formats[config::CrateTypeExecutable]\n+    };\n+\n+    // Invoke get_used_crates to ensure that we get a topological sorting of\n+    // crates.\n+    let deps = sess.cstore.get_used_crates(cstore::RequireDynamic);\n+\n+    for &(cnum, _) in &deps {\n+        // We may not pass all crates through to the linker. Some crates may\n+        // appear statically in an existing dylib, meaning we'll pick up all the\n+        // symbols from the dylib.\n+        let kind = match data[cnum as uint - 1] {\n+            Some(t) => t,\n+            None => continue\n+        };\n+        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        match kind {\n+            cstore::RequireDynamic => {\n+                add_dynamic_crate(cmd, sess, src.dylib.unwrap().0)\n+            }\n+            cstore::RequireStatic => {\n+                add_static_crate(cmd, sess, tmpdir, src.rlib.unwrap().0)\n+            }\n+        }\n+\n+    }\n+\n+    // Converts a library file-stem into a cc -l argument\n+    fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n+        if stem.starts_with(\"lib\".as_bytes()) && !config.target.options.is_like_windows {\n+            &stem[3..]\n+        } else {\n+            stem\n+        }\n+    }\n+\n+    // Adds the static \"rlib\" versions of all crates to the command line.\n+    fn add_static_crate(cmd: &mut Command, sess: &Session, tmpdir: &Path,\n+                        cratepath: Path) {\n+        // When performing LTO on an executable output, all of the\n+        // bytecode from the upstream libraries has already been\n+        // included in our object file output. We need to modify all of\n+        // the upstream archives to remove their corresponding object\n+        // file to make sure we don't pull the same code in twice.\n+        //\n+        // We must continue to link to the upstream archives to be sure\n+        // to pull in native static dependencies. As the final caveat,\n+        // on Linux it is apparently illegal to link to a blank archive,\n+        // so if an archive no longer has any object files in it after\n+        // we remove `lib.o`, then don't link against it at all.\n+        //\n+        // If we're not doing LTO, then our job is simply to just link\n+        // against the archive.\n+        if sess.lto() {\n+            let name = cratepath.filename_str().unwrap();\n+            let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+            time(sess.time_passes(),\n+                 &format!(\"altering {}.rlib\", name)[],\n+                 (), |()| {\n+                let dst = tmpdir.join(cratepath.filename().unwrap());\n+                match fs::copy(&cratepath, &dst) {\n+                    Ok(..) => {}\n+                    Err(e) => {\n+                        sess.err(&format!(\"failed to copy {} to {}: {}\",\n+                                         cratepath.display(),\n+                                         dst.display(),\n+                                         e)[]);\n+                        sess.abort_if_errors();\n+                    }\n+                }\n+                // Fix up permissions of the copy, as fs::copy() preserves\n+                // permissions, but the original file may have been installed\n+                // by a package manager and may be read-only.\n+                match fs::chmod(&dst, old_io::USER_READ | old_io::USER_WRITE) {\n+                    Ok(..) => {}\n+                    Err(e) => {\n+                        sess.err(&format!(\"failed to chmod {} when preparing \\\n+                                          for LTO: {}\", dst.display(),\n+                                         e)[]);\n+                        sess.abort_if_errors();\n+                    }\n+                }\n+                let handler = &sess.diagnostic().handler;\n+                let config = ArchiveConfig {\n+                    handler: handler,\n+                    dst: dst.clone(),\n+                    lib_search_paths: super::link::archive_search_paths(sess),\n+                    slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n+                    slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n+                    maybe_ar_prog: sess.opts.cg.ar.clone()\n+                };\n+                let mut archive = Archive::open(config);\n+                archive.remove_file(&format!(\"{}.o\", name)[]);\n+                let files = archive.files();\n+                if files.iter().any(|s| s[].ends_with(\".o\")) {\n+                    cmd.arg(dst);\n+                }\n+            });\n+        } else {\n+            cmd.arg(cratepath);\n+        }\n+    }\n+\n+    // Same thing as above, but for dynamic crates instead of static crates.\n+    fn add_dynamic_crate(cmd: &mut Command, sess: &Session, cratepath: Path) {\n+        // If we're performing LTO, then it should have been previously required\n+        // that all upstream rust dependencies were available in an rlib format.\n+        assert!(!sess.lto());\n+\n+        // Just need to tell the linker about where the library lives and\n+        // what its name is\n+        let dir = cratepath.dirname();\n+        if !dir.is_empty() { cmd.arg(\"-L\").arg(dir); }\n+\n+        let mut v = \"-l\".as_bytes().to_vec();\n+        v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n+        cmd.arg(&v[..]);\n+    }\n+}\n+\n+// Link in all of our upstream crates' native dependencies. Remember that\n+// all of these upstream native dependencies are all non-static\n+// dependencies. We've got two cases then:\n+//\n+// 1. The upstream crate is an rlib. In this case we *must* link in the\n+// native dependency because the rlib is just an archive.\n+//\n+// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n+// have the dependency present on the system somewhere. Thus, we don't\n+// gain a whole lot from not linking in the dynamic dependency to this\n+// crate as well.\n+//\n+// The use case for this is a little subtle. In theory the native\n+// dependencies of a crate are purely an implementation detail of the crate\n+// itself, but the problem arises with generic and inlined functions. If a\n+// generic function calls a native function, then the generic function must\n+// be instantiated in the target crate, meaning that the native symbol must\n+// also be resolved in the target crate.\n+fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n+    // Be sure to use a topological sorting of crates because there may be\n+    // interdependencies between native libraries. When passing -nodefaultlibs,\n+    // for example, almost all native libraries depend on libc, so we have to\n+    // make sure that's all the way at the right (liblibc is near the base of\n+    // the dependency chain).\n+    //\n+    // This passes RequireStatic, but the actual requirement doesn't matter,\n+    // we're just getting an ordering of crate numbers, we're not worried about\n+    // the paths.\n+    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n+    for (cnum, _) in crates {\n+        let libs = csearch::get_native_libraries(&sess.cstore, cnum);\n+        for &(kind, ref lib) in &libs {\n+            match kind {\n+                cstore::NativeUnknown => {\n+                    cmd.arg(format!(\"-l{}\", *lib));\n+                }\n+                cstore::NativeFramework => {\n+                    cmd.arg(\"-framework\");\n+                    cmd.arg(&lib[..]);\n+                }\n+                cstore::NativeStatic => {\n+                    sess.bug(\"statics shouldn't be propagated\");\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "0237ac1231cdac334cb983efbc860f000abb9959", "filename": "src/librustc_trans/back/link_msvc.rs", "status": "added", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Fback%2Flink_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Fback%2Flink_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink_msvc.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -0,0 +1,460 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::archive::{Archive, ArchiveConfig};\n+use super::archive;\n+use super::rpath;\n+use super::rpath::RPathConfig;\n+\n+use session::config;\n+use session::config::NoDebugInfo;\n+use session::search_paths::PathKind;\n+use session::Session;\n+use metadata::{cstore, filesearch, csearch};\n+use metadata::filesearch::FileDoesntMatch;\n+use trans::CrateTranslation;\n+use util::common::time;\n+\n+use std::str;\n+use std::old_io::{fs, TempDir, Command};\n+use std::old_io;\n+\n+// Create a dynamic library or executable\n+//\n+// This will invoke the system linker/cc to create the resulting file. This\n+// links to all upstream files as well.\n+pub fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n+                 obj_filename: &Path, out_filename: &Path) {\n+    let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n+\n+    // The invocations of cc share some flags across platforms\n+    let pname = super::link::get_cc_prog(sess);\n+    let mut cmd = Command::new(&pname[..]);\n+\n+    cmd.args(&sess.target.target.options.pre_link_args[]);\n+    link_args(&mut cmd, sess, dylib, tmpdir.path(),\n+              trans, obj_filename, out_filename);\n+    cmd.args(&sess.target.target.options.post_link_args[]);\n+    if !sess.target.target.options.no_compiler_rt {\n+        cmd.arg(\"msvcrt.lib\");\n+        cmd.arg(\"compiler-rt.lib\");\n+    }\n+\n+    if sess.opts.debugging_opts.print_link_args {\n+        println!(\"{:?}\", &cmd);\n+    }\n+\n+    // May have not found libraries in the right formats.\n+    sess.abort_if_errors();\n+\n+    // Invoke the system linker\n+    debug!(\"{:?}\", &cmd);\n+    let prog = time(sess.time_passes(), \"running linker\", (), |()| cmd.output());\n+    match prog {\n+        Ok(prog) => {\n+            if !prog.status.success() {\n+                sess.err(&format!(\"linking with `{}` failed: {}\",\n+                                 pname,\n+                                 prog.status)[]);\n+                sess.note(&format!(\"{:?}\", &cmd)[]);\n+                let mut output = prog.error.clone();\n+                output.push_all(&prog.output[]);\n+                sess.note(str::from_utf8(&output[..]).unwrap());\n+                sess.abort_if_errors();\n+            }\n+            debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n+            debug!(\"linker stdout:\\n{}\", String::from_utf8(prog.output).unwrap());\n+        },\n+        Err(e) => {\n+            sess.err(&format!(\"could not exec the linker `{}`: {}\",\n+                             pname,\n+                             e)[]);\n+            sess.abort_if_errors();\n+        }\n+    }\n+\n+\n+    // On OSX, debuggers need this utility to get run to do some munging of\n+    // the symbols\n+    if sess.target.target.options.is_like_osx && sess.opts.debuginfo != NoDebugInfo {\n+        match Command::new(\"dsymutil\").arg(out_filename).output() {\n+            Ok(..) => {}\n+            Err(e) => {\n+                sess.err(&format!(\"failed to run dsymutil: {}\", e)[]);\n+                sess.abort_if_errors();\n+            }\n+        }\n+    }\n+}\n+\n+fn link_args(cmd: &mut Command,\n+             sess: &Session,\n+             dylib: bool,\n+             tmpdir: &Path,\n+             trans: &CrateTranslation,\n+             obj_filename: &Path,\n+             out_filename: &Path) {\n+\n+    // The default library location, we need this to find the runtime.\n+    // The location of crates will be determined as needed.\n+    let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n+\n+    // target descriptor\n+    let t = &sess.target.target;\n+\n+    lib_path.as_str().map(|lp| cmd.arg(format!(\"/LIBPATH:{}\", lp)));\n+    out_filename.as_str().map(|out| cmd.arg(format!(\"/OUT:{}\", out)));\n+    \n+    cmd.arg(obj_filename);\n+\n+    // Stack growth requires statically linking a __morestack function. Note\n+    // that this is listed *before* all other libraries. Due to the usage of the\n+    // --as-needed flag below, the standard library may only be useful for its\n+    // rust_stack_exhausted function. In this case, we must ensure that the\n+    // libmorestack.a file appears *before* the standard library (so we put it\n+    // at the very front).\n+    //\n+    // Most of the time this is sufficient, except for when LLVM gets super\n+    // clever. If, for example, we have a main function `fn main() {}`, LLVM\n+    // will optimize out calls to `__morestack` entirely because the function\n+    // doesn't need any stack at all!\n+    //\n+    // To get around this snag, we specially tell the linker to always include\n+    // all contents of this library. This way we're guaranteed that the linker\n+    // will include the __morestack symbol 100% of the time, always resolving\n+    // references to it even if the object above didn't use it.\n+    if t.options.morestack {\n+        cmd.arg(\"morestack.lib\");\n+    }\n+\n+    // When linking a dynamic library, we put the metadata into a section of the\n+    // executable. This metadata is in a separate object file from the main\n+    // object file, so we link that in here.\n+    if dylib {\n+        cmd.arg(obj_filename.with_extension(\"metadata.o\"));\n+    }\n+\n+    let used_link_args = sess.cstore.get_used_link_args().borrow();\n+\n+    // We want to prevent the compiler from accidentally leaking in any system\n+    // libraries, so we explicitly ask gcc to not link to any libraries by\n+    // default. Note that this does not happen for windows because windows pulls\n+    // in some large number of libraries and I couldn't quite figure out which\n+    // subset we wanted.\n+\n+    // We have to keep this in for now - since we need to link to the MSVCRT for\n+    // things such as jemalloc.\n+    //cmd.arg(\"/nodefaultlib\");\n+\n+    // Take careful note of the ordering of the arguments we pass to the linker\n+    // here. Linkers will assume that things on the left depend on things to the\n+    // right. Things on the right cannot depend on things on the left. This is\n+    // all formally implemented in terms of resolving symbols (libs on the right\n+    // resolve unknown symbols of libs on the left, but not vice versa).\n+    //\n+    // For this reason, we have organized the arguments we pass to the linker as\n+    // such:\n+    //\n+    //  1. The local object that LLVM just generated\n+    //  2. Upstream rust libraries\n+    //  3. Local native libraries\n+    //  4. Upstream native libraries\n+    //\n+    // This is generally fairly natural, but some may expect 2 and 3 to be\n+    // swapped. The reason that all native libraries are put last is that it's\n+    // not recommended for a native library to depend on a symbol from a rust\n+    // crate. If this is the case then a staticlib crate is recommended, solving\n+    // the problem.\n+    //\n+    // Additionally, it is occasionally the case that upstream rust libraries\n+    // depend on a local native library. In the case of libraries such as\n+    // lua/glfw/etc the name of the library isn't the same across all platforms,\n+    // so only the consumer crate of a library knows the actual name. This means\n+    // that downstream crates will provide the #[link] attribute which upstream\n+    // crates will depend on. Hence local native libraries are after out\n+    // upstream rust crates.\n+    //\n+    // In theory this means that a symbol in an upstream native library will be\n+    // shadowed by a local native library when it wouldn't have been before, but\n+    // this kind of behavior is pretty platform specific and generally not\n+    // recommended anyway, so I don't think we're shooting ourself in the foot\n+    // much with that.\n+    add_upstream_rust_crates(cmd, sess, dylib, tmpdir, trans);\n+    add_local_native_libraries(cmd, sess);\n+    add_upstream_native_libraries(cmd, sess);\n+\n+    // # Telling the linker what we're doing\n+\n+    if dylib {\n+        cmd.arg(\"/DLL\");\n+    }\n+\n+    // FIXME (#2397): At some point we want to rpath our guesses as to\n+    // where extern libraries might live, based on the\n+    // addl_lib_search_paths\n+    if sess.opts.cg.rpath {\n+        let sysroot = sess.sysroot();\n+        let target_triple = &sess.opts.target_triple[];\n+        let get_install_prefix_lib_path = || {\n+            let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n+            let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n+            let mut path = Path::new(install_prefix);\n+            path.push(&tlib);\n+\n+            path\n+        };\n+        let rpath_config = RPathConfig {\n+            used_crates: sess.cstore.get_used_crates(cstore::RequireDynamic),\n+            out_filename: out_filename.clone(),\n+            has_rpath: sess.target.target.options.has_rpath,\n+            is_like_osx: sess.target.target.options.is_like_osx,\n+            get_install_prefix_lib_path: get_install_prefix_lib_path,\n+            realpath: ::util::fs::realpath\n+        };\n+        cmd.args(&rpath::get_rpath_flags(rpath_config)[]);\n+    }\n+\n+    // Finally add all the linker arguments provided on the command line along\n+    // with any #[link_args] attributes found inside the crate\n+    let empty = Vec::new();\n+    cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n+    cmd.args(&used_link_args[..]);\n+}\n+\n+// # Native library linking\n+//\n+// User-supplied library search paths (-L on the command line). These are\n+// the same paths used to find Rust crates, so some of them may have been\n+// added already by the previous crate linking code. This only allows them\n+// to be found at compile time so it is still entirely up to outside\n+// forces to make sure that library can be found at runtime.\n+//\n+// Also note that the native libraries linked here are only the ones located\n+// in the current crate. Upstream crates with native library dependencies\n+// may have their native library pulled in above.\n+fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n+    sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, _k| {\n+        path.as_str().map(|s| cmd.arg(format!(\"/LIBPATH:{}\", s)));\n+        FileDoesntMatch\n+    });\n+\n+    let libs = sess.cstore.get_used_libraries();\n+    let libs = libs.borrow();\n+\n+    let staticlibs = libs.iter().filter_map(|&(ref l, kind)| {\n+        if kind == cstore::NativeStatic {Some(l)} else {None}\n+    });\n+    let others = libs.iter().filter(|&&(_, kind)| {\n+        kind != cstore::NativeStatic\n+    });\n+\n+    let search_path = super::link::archive_search_paths(sess);\n+    for l in staticlibs {\n+        let lib = archive::find_library(&l[..],\n+                                        &sess.target.target.options.staticlib_prefix,\n+                                        &sess.target.target.options.staticlib_suffix,\n+                                        &search_path[..],\n+                                        &sess.diagnostic().handler);\n+        let mut v = Vec::new();\n+        v.push_all(lib.as_vec());\n+        cmd.arg(&v[..]);\n+    }\n+\n+    for &(ref l, kind) in others {\n+        match kind {\n+            cstore::NativeUnknown => {\n+                cmd.arg(format!(\"{}.lib\", l));\n+            }\n+            cstore::NativeFramework => {}\n+            cstore::NativeStatic => unreachable!(),\n+        }\n+    }\n+}\n+\n+// # Rust Crate linking\n+//\n+// Rust crates are not considered at all when creating an rlib output. All\n+// dependencies will be linked when producing the final output (instead of\n+// the intermediate rlib version)\n+fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n+                            dylib: bool, tmpdir: &Path,\n+                            trans: &CrateTranslation) {\n+    // All of the heavy lifting has previously been accomplished by the\n+    // dependency_format module of the compiler. This is just crawling the\n+    // output of that module, adding crates as necessary.\n+    //\n+    // Linking to a rlib involves just passing it to the linker (the linker\n+    // will slurp up the object files inside), and linking to a dynamic library\n+    // involves just passing the right -l flag.\n+\n+    let data = if dylib {\n+        &trans.crate_formats[config::CrateTypeDylib]\n+    } else {\n+        &trans.crate_formats[config::CrateTypeExecutable]\n+    };\n+\n+    // Invoke get_used_crates to ensure that we get a topological sorting of\n+    // crates.\n+    let deps = sess.cstore.get_used_crates(cstore::RequireDynamic);\n+\n+    for &(cnum, _) in &deps {\n+        // We may not pass all crates through to the linker. Some crates may\n+        // appear statically in an existing dylib, meaning we'll pick up all the\n+        // symbols from the dylib.\n+        let kind = match data[cnum as uint - 1] {\n+            Some(t) => t,\n+            None => continue\n+        };\n+        let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n+        match kind {\n+            cstore::RequireDynamic => {\n+                add_dynamic_crate(cmd, sess, src.dylib.unwrap().0)\n+            }\n+            cstore::RequireStatic => {\n+                add_static_crate(cmd, sess, tmpdir, src.rlib.unwrap().0)\n+            }\n+        }\n+\n+    }\n+\n+    // Converts a library file-stem into a cc -l argument\n+    fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n+        if stem.starts_with(\"lib\".as_bytes()) && !config.target.options.is_like_windows {\n+            &stem[3..]\n+        } else {\n+            stem\n+        }\n+    }\n+\n+    // Adds the static \"rlib\" versions of all crates to the command line.\n+    fn add_static_crate(cmd: &mut Command, sess: &Session, tmpdir: &Path,\n+                        cratepath: Path) {\n+        // When performing LTO on an executable output, all of the\n+        // bytecode from the upstream libraries has already been\n+        // included in our object file output. We need to modify all of\n+        // the upstream archives to remove their corresponding object\n+        // file to make sure we don't pull the same code in twice.\n+        //\n+        // We must continue to link to the upstream archives to be sure\n+        // to pull in native static dependencies. As the final caveat,\n+        // on Linux it is apparently illegal to link to a blank archive,\n+        // so if an archive no longer has any object files in it after\n+        // we remove `lib.o`, then don't link against it at all.\n+        //\n+        // If we're not doing LTO, then our job is simply to just link\n+        // against the archive.\n+        if sess.lto() {\n+            let name = cratepath.filename_str().unwrap();\n+            let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+            time(sess.time_passes(),\n+                 &format!(\"altering {}.rlib\", name)[],\n+                 (), |()| {\n+                let dst = tmpdir.join(cratepath.filename().unwrap());\n+                match fs::copy(&cratepath, &dst) {\n+                    Ok(..) => {}\n+                    Err(e) => {\n+                        sess.err(&format!(\"failed to copy {} to {}: {}\",\n+                                         cratepath.display(),\n+                                         dst.display(),\n+                                         e)[]);\n+                        sess.abort_if_errors();\n+                    }\n+                }\n+                // Fix up permissions of the copy, as fs::copy() preserves\n+                // permissions, but the original file may have been installed\n+                // by a package manager and may be read-only.\n+                match fs::chmod(&dst, old_io::USER_READ | old_io::USER_WRITE) {\n+                    Ok(..) => {}\n+                    Err(e) => {\n+                        sess.err(&format!(\"failed to chmod {} when preparing \\\n+                                          for LTO: {}\", dst.display(),\n+                                         e)[]);\n+                        sess.abort_if_errors();\n+                    }\n+                }\n+                let handler = &sess.diagnostic().handler;\n+                let config = ArchiveConfig {\n+                    handler: handler,\n+                    dst: dst.clone(),\n+                    lib_search_paths: super::link::archive_search_paths(sess),\n+                    slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n+                    slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n+                    maybe_ar_prog: sess.opts.cg.ar.clone()\n+                };\n+                let mut archive = Archive::open(config);\n+                archive.remove_file(&format!(\"{}.o\", name)[]);\n+                let files = archive.files();\n+                if files.iter().any(|s| s[].ends_with(\".o\")) {\n+                    cmd.arg(dst);\n+                }\n+            });\n+        } else {\n+            cmd.arg(cratepath);\n+        }\n+    }\n+\n+    // Same thing as above, but for dynamic crates instead of static crates.\n+    fn add_dynamic_crate(cmd: &mut Command, sess: &Session, cratepath: Path) {\n+        // If we're performing LTO, then it should have been previously required\n+        // that all upstream rust dependencies were available in an rlib format.\n+        assert!(!sess.lto());\n+\n+        cratepath.as_str().map(|s| {\n+            let libname = s.replace(\".dll\", \".lib\");\n+            cmd.arg(&libname[]);\n+        });\n+    }\n+}\n+\n+// Link in all of our upstream crates' native dependencies. Remember that\n+// all of these upstream native dependencies are all non-static\n+// dependencies. We've got two cases then:\n+//\n+// 1. The upstream crate is an rlib. In this case we *must* link in the\n+// native dependency because the rlib is just an archive.\n+//\n+// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n+// have the dependency present on the system somewhere. Thus, we don't\n+// gain a whole lot from not linking in the dynamic dependency to this\n+// crate as well.\n+//\n+// The use case for this is a little subtle. In theory the native\n+// dependencies of a crate are purely an implementation detail of the crate\n+// itself, but the problem arises with generic and inlined functions. If a\n+// generic function calls a native function, then the generic function must\n+// be instantiated in the target crate, meaning that the native symbol must\n+// also be resolved in the target crate.\n+fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n+    // Be sure to use a topological sorting of crates because there may be\n+    // interdependencies between native libraries. When passing -nodefaultlibs,\n+    // for example, almost all native libraries depend on libc, so we have to\n+    // make sure that's all the way at the right (liblibc is near the base of\n+    // the dependency chain).\n+    //\n+    // This passes RequireStatic, but the actual requirement doesn't matter,\n+    // we're just getting an ordering of crate numbers, we're not worried about\n+    // the paths.\n+    let crates = sess.cstore.get_used_crates(cstore::RequireStatic);\n+    for (cnum, _) in crates {\n+        let libs = csearch::get_native_libraries(&sess.cstore, cnum);\n+        for &(kind, ref lib) in &libs {\n+            match kind {\n+                cstore::NativeUnknown => {\n+                    cmd.arg(format!(\"{}.lib\", lib));\n+                }\n+                cstore::NativeFramework => {\n+                }\n+                cstore::NativeStatic => {\n+                    sess.bug(\"statics shouldn't be propagated\");\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "97c672df148f07571a06e331e91f1d1fce87ddc7", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -75,6 +75,9 @@ pub mod back {\n     pub use rustc_back::x86_64;\n \n     pub mod link;\n+    mod link_gnu;\n+    mod link_msvc;\n+\n     pub mod lto;\n     pub mod write;\n "}, {"sha": "413e5e1f49ffc6057fa7d2c4398e69334520b0e4", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -1907,6 +1907,16 @@ pub fn update_linkage(ccx: &CrateContext,\n                       llval: ValueRef,\n                       id: Option<ast::NodeId>,\n                       llval_origin: ValueOrigin) {\n+\n+    // TODO: This should be conditionaly set based on whether we're producing a\n+    //       dynamic library or not to follow the conventions on Windows. (ricky26)\n+\n+    if ccx.sess().target.target.options.is_like_msvc {\n+        llvm::SetDLLStorageClass(llval, llvm::DLLExportStorageClass);\n+        llvm::SetLinkage(llval, llvm::ExternalLinkage);\n+        return;\n+    }\n+\n     match llval_origin {\n         InlinedCopy => {\n             // `llval` is a translation of an item defined in a separate\n@@ -2171,7 +2181,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         // FIXME: #16581: Marking a symbol in the executable with `dllexport`\n         // linkage forces MinGW's linker to output a `.reloc` section for ASLR\n         if ccx.sess().target.target.options.is_like_windows {\n-            unsafe { llvm::LLVMRustSetDLLExportStorageClass(llfn) }\n+            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n         }\n \n         let llbb = unsafe {"}, {"sha": "989ef8d8bf45ec458763e4ce1614f80ea691f980", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -863,6 +863,14 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) ->\n         };\n         llvm::LLVMSetInitializer(g, v);\n \n+        // TODO: This should be conditionaly set based on whether we're producing a\n+        //       dynamic library or not to follow the conventions on Windows. (ricky26)\n+        \n+        if ccx.sess().target.target.options.is_like_msvc {\n+            llvm::SetDLLStorageClass(g, llvm::DLLExportStorageClass);\n+            llvm::SetLinkage(g, llvm::ExternalLinkage);\n+        }\n+\n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != ast::MutMutable {"}, {"sha": "934cf056ec19dfaaac565365f05bca46f23dcc2b", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -31,6 +31,8 @@ pub use core::f32::consts;\n #[allow(dead_code)]\n mod cmath {\n     use libc::{c_float, c_int};\n+    #[cfg(windows)]\n+    use libc::c_double;\n \n     #[link_name = \"m\"]\n     extern {\n@@ -44,13 +46,10 @@ mod cmath {\n         pub fn erfcf(n: c_float) -> c_float;\n         pub fn expm1f(n: c_float) -> c_float;\n         pub fn fdimf(a: c_float, b: c_float) -> c_float;\n-        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;\n         pub fn fmaxf(a: c_float, b: c_float) -> c_float;\n         pub fn fminf(a: c_float, b: c_float) -> c_float;\n         pub fn fmodf(a: c_float, b: c_float) -> c_float;\n         pub fn nextafterf(x: c_float, y: c_float) -> c_float;\n-        pub fn hypotf(x: c_float, y: c_float) -> c_float;\n-        pub fn ldexpf(x: c_float, n: c_int) -> c_float;\n         pub fn logbf(n: c_float) -> c_float;\n         pub fn log1pf(n: c_float) -> c_float;\n         pub fn ilogbf(n: c_float) -> c_int;\n@@ -62,11 +61,33 @@ mod cmath {\n \n         #[cfg(unix)]\n         pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;\n+        #[cfg(unix)]\n+        pub fn hypotf(x: c_float, y: c_float) -> c_float;\n+        #[cfg(unix)]\n+        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;\n+        #[cfg(unix)]\n+        pub fn ldexpf(x: c_float, n: c_int) -> c_float;\n \n         #[cfg(windows)]\n         #[link_name=\"__lgammaf_r\"]\n         pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;\n+\n+        #[cfg(windows)]\n+        #[link_name=\"_hypotf\"]\n+        pub fn hypotf(x: c_float, y: c_float) -> c_float;\n+\n+        #[cfg(windows)]\n+        fn frexp(n: c_double, value: &mut c_int) -> c_double;\n+\n+        #[cfg(windows)]\n+        fn ldexp(x: c_double, n: c_int) -> c_double;\n     }\n+\n+    #[cfg(windows)]\n+    pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float { return ldexp(x as c_double, n) as c_float; }\n+\n+    #[cfg(windows)]\n+    pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float { return frexp(x as c_double, value) as c_float; }\n }\n \n #[cfg(not(test))]"}, {"sha": "a09a82b85522ebe94fd5c63e43d76c75c22a4d5a", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -48,7 +48,6 @@ mod cmath {\n         pub fn fmod(a: c_double, b: c_double) -> c_double;\n         pub fn nextafter(x: c_double, y: c_double) -> c_double;\n         pub fn frexp(n: c_double, value: &mut c_int) -> c_double;\n-        pub fn hypot(x: c_double, y: c_double) -> c_double;\n         pub fn ldexp(x: c_double, n: c_int) -> c_double;\n         pub fn logb(n: c_double) -> c_double;\n         pub fn log1p(n: c_double) -> c_double;\n@@ -74,6 +73,13 @@ mod cmath {\n         #[cfg(windows)]\n         #[link_name=\"__lgamma_r\"]\n         pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;\n+\n+        #[cfg(unix)]\n+        pub fn hypot(x: c_double, y: c_double) -> c_double;\n+\n+        #[cfg(windows)]\n+        #[link_name=\"_hypot\"]\n+        pub fn hypot(x: c_double, y: c_double) -> c_double;\n     }\n }\n "}, {"sha": "885adf19ca1fc6e16ffd9d37ebbdeebe3f46f345", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -279,6 +279,7 @@ mod imp {\n     const CRYPT_VERIFYCONTEXT: DWORD = 0xF0000000;\n \n     #[allow(non_snake_case)]\n+    #[link(name = \"advapi32\")]\n     extern \"system\" {\n         fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,\n                                 pszContainer: LPCSTR,"}, {"sha": "d7eede6e953bc35a5a932d550eb558093272bea5", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -39,10 +39,17 @@ mod macros;\n \n // These should be refactored/moved/made private over time\n pub mod util;\n-pub mod unwind;\n pub mod args;\n \n+#[cfg(not(all(target_os = \"windows\", target_abi = \"msvc\")))]\n+pub mod unwind;\n+#[cfg(all(target_os = \"windows\", target_abi = \"msvc\"))]\n+#[path = \"unwind_msvc.rs\"]\n+pub mod unwind;\n+\n mod at_exit_imp;\n+\n+#[cfg(not(all(target_os = \"windows\", target_abi = \"msvc\")))]\n mod libunwind;\n \n /// The default error code of the rust runtime if the main thread panics instead"}, {"sha": "b71db510c00b3e88253fe5b5d94c8c4887a82617", "filename": "src/libstd/rt/unwind_msvc.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibstd%2Frt%2Funwind_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Flibstd%2Frt%2Funwind_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind_msvc.rs?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -0,0 +1,302 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of Rust stack unwinding\n+//!\n+//! For background on exception handling and stack unwinding please see\n+//! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n+//! documents linked from it.\n+//! These are also good reads:\n+//!     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n+//!     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n+//!     http://www.airs.com/blog/index.php?s=exception+frames\n+//!\n+//! ## A brief summary\n+//!\n+//! Exception handling happens in two phases: a search phase and a cleanup phase.\n+//!\n+//! In both phases the unwinder walks stack frames from top to bottom using\n+//! information from the stack frame unwind sections of the current process's\n+//! modules (\"module\" here refers to an OS module, i.e. an executable or a\n+//! dynamic library).\n+//!\n+//! For each stack frame, it invokes the associated \"personality routine\", whose\n+//! address is also stored in the unwind info section.\n+//!\n+//! In the search phase, the job of a personality routine is to examine exception\n+//! object being thrown, and to decide whether it should be caught at that stack\n+//! frame.  Once the handler frame has been identified, cleanup phase begins.\n+//!\n+//! In the cleanup phase, personality routines invoke cleanup code associated\n+//! with their stack frames (i.e. destructors).  Once stack has been unwound down\n+//! to the handler frame level, unwinding stops and the last personality routine\n+//! transfers control to its catch block.\n+//!\n+//! ## Frame unwind info registration\n+//!\n+//! Each module has its own frame unwind info section (usually \".eh_frame\"), and\n+//! unwinder needs to know about all of them in order for unwinding to be able to\n+//! cross module boundaries.\n+//!\n+//! On some platforms, like Linux, this is achieved by dynamically enumerating\n+//! currently loaded modules via the dl_iterate_phdr() API and finding all\n+//! .eh_frame sections.\n+//!\n+//! Others, like Windows, require modules to actively register their unwind info\n+//! sections by calling __register_frame_info() API at startup.  In the latter\n+//! case it is essential that there is only one copy of the unwinder runtime in\n+//! the process.  This is usually achieved by linking to the dynamic version of\n+//! the unwind runtime.\n+//!\n+//! Currently Rust uses unwind runtime provided by libgcc.\n+\n+use prelude::v1::*;\n+\n+use any::Any;\n+use cell::Cell;\n+use cmp;\n+use panicking;\n+use fmt;\n+use intrinsics;\n+use mem;\n+use sync::atomic::{self, Ordering};\n+use sync::{Once, ONCE_INIT};\n+\n+pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n+\n+// Variables used for invoking callbacks when a thread starts to unwind.\n+//\n+// For more information, see below.\n+const MAX_CALLBACKS: uint = 16;\n+static CALLBACKS: [atomic::AtomicUsize; MAX_CALLBACKS] =\n+        [atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT];\n+static CALLBACK_CNT: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+\n+thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n+\n+/// Invoke a closure, capturing the cause of panic if one occurs.\n+///\n+/// This function will return `Ok(())` if the closure did not panic, and will\n+/// return `Err(cause)` if the closure panics. The `cause` returned is the\n+/// object with which panic was originally invoked.\n+///\n+/// This function also is unsafe for a variety of reasons:\n+///\n+/// * This is not safe to call in a nested fashion. The unwinding\n+///   interface for Rust is designed to have at most one try/catch block per\n+///   thread, not multiple. No runtime checking is currently performed to uphold\n+///   this invariant, so this function is not safe. A nested try/catch block\n+///   may result in corruption of the outer try/catch block's state, especially\n+///   if this is used within a thread itself.\n+///\n+/// * It is not sound to trigger unwinding while already unwinding. Rust threads\n+///   have runtime checks in place to ensure this invariant, but it is not\n+///   guaranteed that a rust thread is in place when invoking this function.\n+///   Unwinding twice can lead to resource leaks where some destructors are not\n+///   run.\n+pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n+    f();\n+    Ok(())\n+}\n+\n+/// Determines whether the current thread is unwinding because of panic.\n+pub fn panicking() -> bool {\n+    PANICKING.with(|s| s.get())\n+}\n+\n+// An uninlined, unmangled function upon which to slap yer breakpoints\n+#[inline(never)]\n+#[no_mangle]\n+#[allow(private_no_mangle_fns)]\n+fn rust_panic(_cause: Box<Any + Send + 'static>) -> ! {\n+    loop {}\n+}\n+\n+// See also: rt/rust_try.ll\n+#[cfg(all(not(test)))]\n+#[doc(hidden)]\n+#[allow(non_camel_case_types, non_snake_case)]\n+pub mod eabi {\n+    pub use self::EXCEPTION_DISPOSITION::*;\n+    use libc::c_void;\n+\n+    #[repr(C)]\n+    pub struct EXCEPTION_RECORD;\n+    #[repr(C)]\n+    pub struct CONTEXT;\n+    #[repr(C)]\n+    pub struct DISPATCHER_CONTEXT;\n+\n+    #[repr(C)]\n+    #[derive(Copy)]\n+    pub enum EXCEPTION_DISPOSITION {\n+        ExceptionContinueExecution,\n+        ExceptionContinueSearch,\n+        ExceptionNestedException,\n+        ExceptionCollidedUnwind\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // referenced from rust_try.ll\n+    #[allow(private_no_mangle_fns)]\n+    extern \"C\" fn rust_eh_personality(\n+        _exceptionRecord: *mut EXCEPTION_RECORD,\n+        _establisherFrame: *mut c_void,\n+        _contextRecord: *mut CONTEXT,\n+        _dispatcherContext: *mut DISPATCHER_CONTEXT\n+    ) -> EXCEPTION_DISPOSITION\n+    {\n+        EXCEPTION_DISPOSITION::ExceptionContinueSearch\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        _exceptionRecord: *mut EXCEPTION_RECORD,\n+        _establisherFrame: *mut c_void,\n+        _contextRecord: *mut CONTEXT,\n+        _dispatcherContext: *mut DISPATCHER_CONTEXT\n+    ) -> EXCEPTION_DISPOSITION\n+    {\n+        EXCEPTION_DISPOSITION::ExceptionContinueSearch\n+    }\n+}\n+\n+#[cfg(not(test))]\n+/// Entry point of panic from the libcore crate.\n+#[lang = \"panic_fmt\"]\n+pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n+                                file: &'static str, line: uint) -> ! {\n+    begin_unwind_fmt(msg, &(file, line))\n+}\n+\n+/// The entry point for unwinding with a formatted message.\n+///\n+/// This is designed to reduce the amount of code required at the call\n+/// site as much as possible (so that `panic!()` has as low an impact\n+/// on (e.g.) the inlining of other functions as possible), by moving\n+/// the actual formatting into this shared place.\n+#[inline(never)] #[cold]\n+#[stable(since = \"1.0.0\", feature = \"rust1\")]\n+pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n+    use fmt::Write;\n+\n+    // We do two allocations here, unfortunately. But (a) they're\n+    // required with the current scheme, and (b) we don't handle\n+    // panic + OOM properly anyway (see comment in begin_unwind\n+    // below).\n+\n+    let mut s = String::new();\n+    let _ = write!(&mut s, \"{}\", msg);\n+    begin_unwind_inner(box s, file_line)\n+}\n+\n+/// This is the entry point of unwinding for panic!() and assert!().\n+#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n+#[stable(since = \"1.0.0\", feature = \"rust1\")]\n+pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! {\n+    // Note that this should be the only allocation performed in this code path.\n+    // Currently this means that panic!() on OOM will invoke this code path,\n+    // but then again we're not really ready for panic on OOM anyway. If\n+    // we do start doing this, then we should propagate this allocation to\n+    // be performed in the parent of this thread instead of the thread that's\n+    // panicking.\n+\n+    // see below for why we do the `Any` coercion here.\n+    begin_unwind_inner(box msg, file_line)\n+}\n+\n+/// The core of the unwinding.\n+///\n+/// This is non-generic to avoid instantiation bloat in other crates\n+/// (which makes compilation of small crates noticeably slower). (Note:\n+/// we need the `Any` object anyway, we're not just creating it to\n+/// avoid being generic.)\n+///\n+/// Doing this split took the LLVM IR line counts of `fn main() { panic!()\n+/// }` from ~1900/3700 (-O/no opts) to 180/590.\n+#[inline(never)] #[cold] // this is the slow path, please never inline this\n+fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) -> ! {\n+    // Make sure the default panic handler is registered before we look at the\n+    // callbacks.\n+    static INIT: Once = ONCE_INIT;\n+    INIT.call_once(|| unsafe { register(panicking::on_panic); });\n+\n+    // First, invoke call the user-defined callbacks triggered on thread panic.\n+    //\n+    // By the time that we see a callback has been registered (by reading\n+    // MAX_CALLBACKS), the actual callback itself may have not been stored yet,\n+    // so we just chalk it up to a race condition and move on to the next\n+    // callback. Additionally, CALLBACK_CNT may briefly be higher than\n+    // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n+    let callbacks = {\n+        let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n+        &CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n+    };\n+    for cb in callbacks {\n+        match cb.load(Ordering::SeqCst) {\n+            0 => {}\n+            n => {\n+                let f: Callback = unsafe { mem::transmute(n) };\n+                let (file, line) = *file_line;\n+                f(&*msg, file, line);\n+            }\n+        }\n+    };\n+\n+    // Now that we've run all the necessary unwind callbacks, we actually\n+    // perform the unwinding.\n+    if panicking() {\n+        // If a thread panics while it's already unwinding then we\n+        // have limited options. Currently our preference is to\n+        // just abort. In the future we may consider resuming\n+        // unwinding or otherwise exiting the thread cleanly.\n+        rterrln!(\"thread panicked while panicking. aborting.\");\n+        unsafe { intrinsics::abort() }\n+    }\n+    PANICKING.with(|s| s.set(true));\n+    rust_panic(msg);\n+}\n+\n+/// Register a callback to be invoked when a thread unwinds.\n+///\n+/// This is an unsafe and experimental API which allows for an arbitrary\n+/// callback to be invoked when a thread panics. This callback is invoked on both\n+/// the initial unwinding and a double unwinding if one occurs. Additionally,\n+/// the local `Task` will be in place for the duration of the callback, and\n+/// the callback must ensure that it remains in place once the callback returns.\n+///\n+/// Only a limited number of callbacks can be registered, and this function\n+/// returns whether the callback was successfully registered or not. It is not\n+/// currently possible to unregister a callback once it has been registered.\n+#[unstable(feature = \"std_misc\")]\n+pub unsafe fn register(f: Callback) -> bool {\n+    match CALLBACK_CNT.fetch_add(1, Ordering::SeqCst) {\n+        // The invocation code has knowledge of this window where the count has\n+        // been incremented, but the callback has not been stored. We're\n+        // guaranteed that the slot we're storing into is 0.\n+        n if n < MAX_CALLBACKS => {\n+            let prev = CALLBACKS[n].swap(mem::transmute(f), Ordering::SeqCst);\n+            rtassert!(prev == 0);\n+            true\n+        }\n+        // If we accidentally bumped the count too high, pull it back.\n+        _ => {\n+            CALLBACK_CNT.store(MAX_CALLBACKS, Ordering::SeqCst);\n+            false\n+        }\n+    }\n+}"}, {"sha": "ac925e4260a5423ed98ab3a36ed604e0ef17fc43", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/315750ac92a8114a96b35352ec88f82d21d5fbec/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=315750ac92a8114a96b35352ec88f82d21d5fbec", "patch": "@@ -191,9 +191,7 @@ rust_dbg_abi_2(struct floats f) {\n }\n \n int\n-rust_dbg_static_mut;\n-\n-int rust_dbg_static_mut = 3;\n+rust_dbg_static_mut = 3;\n \n void\n rust_dbg_static_mut_check_four() {"}]}