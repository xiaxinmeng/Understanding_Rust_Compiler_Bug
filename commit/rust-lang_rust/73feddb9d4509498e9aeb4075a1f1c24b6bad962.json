{"sha": "73feddb9d4509498e9aeb4075a1f1c24b6bad962", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZmVkZGI5ZDQ1MDk0OThlOWFlYjQwNzVhMWYxYzI0YjZiYWQ5NjI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-13T02:33:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-13T02:33:57Z"}, "message": "Rollup merge of #59138 - timvermeulen:simplify_select_fold1, r=sfackler\n\nSimplify Iterator::{min, max}\n\nThis PR simplifies the `select_fold1` helper method used to implmement `Iterator::{min, min_by, min_by_key, max, max_by, max_by_key}` by removing the projection argument, which was only used by the implementations of `min_by_key` and `max_by_key`.\n\nI also added tests to ensure that the stability as mentioned in the comments of `min` and `max` is preserved, and fixed the `iter::{bench_max, bench_max_by_key}` benchmarks which the compiler presumably was able to collapse into closed-form expressions. None of the benchmark results were impacted, I suspect their generated assembly didn't change.", "tree": {"sha": "a7eefc25327ab135d272d3464e8ed88ac09def91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7eefc25327ab135d272d3464e8ed88ac09def91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73feddb9d4509498e9aeb4075a1f1c24b6bad962", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJciGwWCRBK7hj4Ov3rIwAAdHIIAHDV1yNqlat9yCifABlClV4V\nx79klGpAIJDqYp+X+FmmBOLbXufh3hhsZtcQFz43DqPktA12EHqKCgPLkHYVKFzl\neej+rU93Lz+iQ3oMoveuOzqKmb8rkS5+P2n2RyzXlY48DK43Pq8Dp14uqNVuZbiV\nfd/NL/qgVxfYGT+YBGkFdw9WQuRU5dUTVhvFG9/R5zpBrQkPrQETePG3VDsjE/Gu\nBYW6TM7VWMGRSRaYqtbATD06p6t7FRbfojXzRujSlawLYMh7BnT+NfgNMIMP3erD\nRdIw78f3jjTsxY/PF+lWXpDkkVdpvKT1aEL6qDjOmpOg0ygmInhIS9Sj7yepFiU=\n=B0gb\n-----END PGP SIGNATURE-----\n", "payload": "tree a7eefc25327ab135d272d3464e8ed88ac09def91\nparent c22566d96dc69975570caa8e2c2a82fbfbfd9ae2\nparent 6cc5a3d9cc470e2db2b2a45fcddb2350ac0b039e\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1552444437 +0100\ncommitter GitHub <noreply@github.com> 1552444437 +0100\n\nRollup merge of #59138 - timvermeulen:simplify_select_fold1, r=sfackler\n\nSimplify Iterator::{min, max}\n\nThis PR simplifies the `select_fold1` helper method used to implmement `Iterator::{min, min_by, min_by_key, max, max_by, max_by_key}` by removing the projection argument, which was only used by the implementations of `min_by_key` and `max_by_key`.\n\nI also added tests to ensure that the stability as mentioned in the comments of `min` and `max` is preserved, and fixed the `iter::{bench_max, bench_max_by_key}` benchmarks which the compiler presumably was able to collapse into closed-form expressions. None of the benchmark results were impacted, I suspect their generated assembly didn't change.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73feddb9d4509498e9aeb4075a1f1c24b6bad962", "html_url": "https://github.com/rust-lang/rust/commit/73feddb9d4509498e9aeb4075a1f1c24b6bad962", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73feddb9d4509498e9aeb4075a1f1c24b6bad962/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c22566d96dc69975570caa8e2c2a82fbfbfd9ae2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c22566d96dc69975570caa8e2c2a82fbfbfd9ae2", "html_url": "https://github.com/rust-lang/rust/commit/c22566d96dc69975570caa8e2c2a82fbfbfd9ae2"}, {"sha": "6cc5a3d9cc470e2db2b2a45fcddb2350ac0b039e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc5a3d9cc470e2db2b2a45fcddb2350ac0b039e", "html_url": "https://github.com/rust-lang/rust/commit/6cc5a3d9cc470e2db2b2a45fcddb2350ac0b039e"}], "stats": {"total": 107, "additions": 49, "deletions": 58}, "files": [{"sha": "825bd368bdf1d944edb3bb807b93a4d70104a18c", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73feddb9d4509498e9aeb4075a1f1c24b6bad962/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73feddb9d4509498e9aeb4075a1f1c24b6bad962/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=73feddb9d4509498e9aeb4075a1f1c24b6bad962", "patch": "@@ -35,7 +35,7 @@ fn scatter(x: i32) -> i32 { (x * 31) % 127 }\n fn bench_max_by_key(b: &mut Bencher) {\n     b.iter(|| {\n         let it = 0..100;\n-        it.max_by_key(|&x| scatter(x))\n+        it.map(black_box).max_by_key(|&x| scatter(x))\n     })\n }\n \n@@ -56,7 +56,7 @@ fn bench_max_by_key2(b: &mut Bencher) {\n fn bench_max(b: &mut Bencher) {\n     b.iter(|| {\n         let it = 0..100;\n-        it.map(scatter).max()\n+        it.map(black_box).map(scatter).max()\n     })\n }\n "}, {"sha": "ca7feed0712d1e72cc76faa39aec7c1a82f632f8", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 19, "deletions": 56, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/73feddb9d4509498e9aeb4075a1f1c24b6bad962/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73feddb9d4509498e9aeb4075a1f1c24b6bad962/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=73feddb9d4509498e9aeb4075a1f1c24b6bad962", "patch": "@@ -2008,12 +2008,7 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |_, x, _, y| *x <= *y)\n-            .map(|(_, x)| x)\n+        self.max_by(Ord::cmp)\n     }\n \n     /// Returns the minimum element of an iterator.\n@@ -2038,12 +2033,7 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // only switch to y if it is strictly smaller, to\n-                     // preserve stability.\n-                     |_, x, _, y| *x > *y)\n-            .map(|(_, x)| x)\n+        self.min_by(Ord::cmp)\n     }\n \n     /// Returns the element that gives the maximum value from the\n@@ -2062,15 +2052,11 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+    fn max_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n-        select_fold1(self,\n-                     f,\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |x_p, _, y_p, _| x_p <= y_p)\n-            .map(|(_, x)| x)\n+        // switch to y even if it is only equal, to preserve stability.\n+        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p <= y_p).map(|(_, x)| x)\n     }\n \n     /// Returns the element that gives the maximum value with respect to the\n@@ -2092,12 +2078,8 @@ pub trait Iterator {\n     fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |_, x, _, y| Ordering::Greater != compare(x, y))\n-            .map(|(_, x)| x)\n+        // switch to y even if it is only equal, to preserve stability.\n+        select_fold1(self, |x, y| compare(x, y) != Ordering::Greater)\n     }\n \n     /// Returns the element that gives the minimum value from the\n@@ -2115,15 +2097,11 @@ pub trait Iterator {\n     /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+    fn min_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n-        select_fold1(self,\n-                     f,\n-                     // only switch to y if it is strictly smaller, to\n-                     // preserve stability.\n-                     |x_p, _, y_p, _| x_p > y_p)\n-            .map(|(_, x)| x)\n+        // only switch to y if it is strictly smaller, to preserve stability.\n+        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p > y_p).map(|(_, x)| x)\n     }\n \n     /// Returns the element that gives the minimum value with respect to the\n@@ -2145,12 +2123,8 @@ pub trait Iterator {\n     fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is strictly smaller, to\n-                     // preserve stability.\n-                     |_, x, _, y| Ordering::Greater == compare(x, y))\n-            .map(|(_, x)| x)\n+        // only switch to y if it is strictly smaller, to preserve stability.\n+        select_fold1(self, |x, y| compare(x, y) == Ordering::Greater)\n     }\n \n \n@@ -2693,34 +2667,23 @@ pub trait Iterator {\n     }\n }\n \n-/// Select an element from an iterator based on the given \"projection\"\n-/// and \"comparison\" function.\n+/// Select an element from an iterator based on the given \"comparison\"\n+/// function.\n ///\n /// This is an idiosyncratic helper to try to factor out the\n /// commonalities of {max,min}{,_by}. In particular, this avoids\n /// having to implement optimizations several times.\n #[inline]\n-fn select_fold1<I, B, FProj, FCmp>(mut it: I,\n-                                   mut f_proj: FProj,\n-                                   mut f_cmp: FCmp) -> Option<(B, I::Item)>\n-    where I: Iterator,\n-          FProj: FnMut(&I::Item) -> B,\n-          FCmp: FnMut(&B, &I::Item, &B, &I::Item) -> bool\n+fn select_fold1<I, F>(mut it: I, mut f: F) -> Option<I::Item>\n+    where\n+        I: Iterator,\n+        F: FnMut(&I::Item, &I::Item) -> bool,\n {\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n     it.next().map(|first| {\n-        let first_p = f_proj(&first);\n-\n-        it.fold((first_p, first), |(sel_p, sel), x| {\n-            let x_p = f_proj(&x);\n-            if f_cmp(&sel_p, &sel, &x_p, &x) {\n-                (x_p, x)\n-            } else {\n-                (sel_p, sel)\n-            }\n-        })\n+        it.fold(first, |sel, x| if f(&sel, &x) { x } else { sel })\n     })\n }\n "}, {"sha": "a9db9b35d8d80e3be984a78d7b385d7243b48e98", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/73feddb9d4509498e9aeb4075a1f1c24b6bad962/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73feddb9d4509498e9aeb4075a1f1c24b6bad962/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=73feddb9d4509498e9aeb4075a1f1c24b6bad962", "patch": "@@ -1082,12 +1082,39 @@ fn test_iterator_product_result() {\n     assert_eq!(v.iter().cloned().product::<Result<i32, _>>(), Err(()));\n }\n \n+/// A wrapper struct that implements `Eq` and `Ord` based on the wrapped\n+/// integer modulo 3. Used to test that `Iterator::max` and `Iterator::min`\n+/// return the correct element if some of them are equal.\n+#[derive(Debug)]\n+struct Mod3(i32);\n+\n+impl PartialEq for Mod3 {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0 % 3 == other.0 % 3\n+    }\n+}\n+\n+impl Eq for Mod3 {}\n+\n+impl PartialOrd for Mod3 {\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for Mod3 {\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        (self.0 % 3).cmp(&(other.0 % 3))\n+    }\n+}\n+\n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(v[..4].iter().cloned().max(), Some(3));\n     assert_eq!(v.iter().cloned().max(), Some(10));\n     assert_eq!(v[..0].iter().cloned().max(), None);\n+    assert_eq!(v.iter().cloned().map(Mod3).max().map(|x| x.0), Some(8));\n }\n \n #[test]\n@@ -1096,6 +1123,7 @@ fn test_iterator_min() {\n     assert_eq!(v[..4].iter().cloned().min(), Some(0));\n     assert_eq!(v.iter().cloned().min(), Some(0));\n     assert_eq!(v[..0].iter().cloned().min(), None);\n+    assert_eq!(v.iter().cloned().map(Mod3).min().map(|x| x.0), Some(0));\n }\n \n #[test]"}]}