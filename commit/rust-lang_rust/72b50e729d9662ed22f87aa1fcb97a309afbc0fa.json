{"sha": "72b50e729d9662ed22f87aa1fcb97a309afbc0fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYjUwZTcyOWQ5NjYyZWQyMmY4N2FhMWZjYjk3YTMwOWFmYmMwZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-16T08:56:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-16T08:56:16Z"}, "message": "auto merge of #8526 : blake2-ppc/rust/either-result, r=catamorphism\n\nRetry of PR #8471\r\n\r\nReplace the remaining functions marked for issue #8228 with similar functions that are iterator-based.\r\n\r\nChange `either::{lefts, rights}` to be iterator-filtering instead of returning a vector.\r\n\r\nReplace `map_vec`, `map_vec2`, `iter_vec2` in std::result with three functions:\r\n\r\n* `result::collect` gathers `Iterator<Result<V, U>>` to `Result<~[V], U>`\r\n* `result::fold` folds `Iterator<Result<T, E>>` to `Result<V, E>`\r\n* `result::fold_` folds `Iterator<Result<T, E>>` to `Result<(), E>`", "tree": {"sha": "c47e2e3115f2e08a621b0825533e457e3a9f6a68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c47e2e3115f2e08a621b0825533e457e3a9f6a68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72b50e729d9662ed22f87aa1fcb97a309afbc0fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72b50e729d9662ed22f87aa1fcb97a309afbc0fa", "html_url": "https://github.com/rust-lang/rust/commit/72b50e729d9662ed22f87aa1fcb97a309afbc0fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92af0db0a3919f5371de362cb6060ff87190aafe", "url": "https://api.github.com/repos/rust-lang/rust/commits/92af0db0a3919f5371de362cb6060ff87190aafe", "html_url": "https://github.com/rust-lang/rust/commit/92af0db0a3919f5371de362cb6060ff87190aafe"}, {"sha": "88c149195af66c95d94db30bc55de6204ad82f8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/88c149195af66c95d94db30bc55de6204ad82f8f", "html_url": "https://github.com/rust-lang/rust/commit/88c149195af66c95d94db30bc55de6204ad82f8f"}], "stats": {"total": 233, "additions": 130, "deletions": 103}, "files": [{"sha": "c8c4a396c87af99c0041f1274fcd3acf92b353c7", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=72b50e729d9662ed22f87aa1fcb97a309afbc0fa", "patch": "@@ -57,6 +57,7 @@ pub fn read_crates(diag: @mut span_handler,\n     warn_if_multiple_versions(e, diag, *e.crate_cache);\n }\n \n+#[deriving(Clone)]\n struct cache_entry {\n     cnum: int,\n     span: span,\n@@ -76,22 +77,13 @@ fn dump_crates(crate_cache: &[cache_entry]) {\n fn warn_if_multiple_versions(e: @mut Env,\n                              diag: @mut span_handler,\n                              crate_cache: &[cache_entry]) {\n-    use std::either::*;\n-\n     if crate_cache.len() != 0u {\n         let name = loader::crate_name_from_metas(\n             *crate_cache[crate_cache.len() - 1].metas\n         );\n \n-        let vec: ~[Either<cache_entry, cache_entry>] = crate_cache.iter().map(|&entry| {\n-            let othername = loader::crate_name_from_metas(*entry.metas);\n-            if name == othername {\n-                Left(entry)\n-            } else {\n-                Right(entry)\n-            }\n-        }).collect();\n-        let (matches, non_matches) = partition(vec);\n+        let (matches, non_matches) = crate_cache.partitioned(|entry|\n+            name == loader::crate_name_from_metas(*entry.metas));\n \n         assert!(!matches.is_empty());\n "}, {"sha": "161d96d828b47c8830c1fd0f3406bb76cf7d1b28", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=72b50e729d9662ed22f87aa1fcb97a309afbc0fa", "patch": "@@ -68,7 +68,7 @@ use middle::typeck::infer::{InferCtxt, cres, ures};\n use middle::typeck::infer::{TypeTrace};\n use util::common::indent;\n \n-use std::result::{iter_vec2, map_vec2};\n+use std::result;\n use std::vec;\n use syntax::ast::{Onceness, purity};\n use syntax::ast;\n@@ -275,9 +275,9 @@ pub fn super_tps<C:Combine>(\n     // variance.\n \n     if vec::same_length(as_, bs) {\n-        iter_vec2(as_, bs, |a, b| {\n-            eq_tys(this, *a, *b)\n-        }).then(|| Ok(as_.to_owned()) )\n+        result::fold_(as_.iter().zip(bs.iter())\n+                      .map(|(a, b)| eq_tys(this, *a, *b)))\n+            .then(|| Ok(as_.to_owned()))\n     } else {\n         Err(ty::terr_ty_param_size(\n             expected_found(this, as_.len(), bs.len())))\n@@ -427,7 +427,8 @@ pub fn super_fn_sigs<C:Combine>(\n {\n     fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<~[ty::t]> {\n         if vec::same_length(a_args, b_args) {\n-            map_vec2(a_args, b_args, |a, b| this.args(*a, *b))\n+            result::collect(a_args.iter().zip(b_args.iter())\n+                            .map(|(a, b)| this.args(*a, *b)))\n         } else {\n             Err(ty::terr_arg_count)\n         }\n@@ -586,8 +587,9 @@ pub fn super_tys<C:Combine>(\n \n       (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n         if as_.len() == bs.len() {\n-            map_vec2(*as_, *bs, |a, b| this.tys(*a, *b) )\n-                .chain(|ts| Ok(ty::mk_tup(tcx, ts)) )\n+            result::collect(as_.iter().zip(bs.iter())\n+                            .map(|(a, b)| this.tys(*a, *b)))\n+                    .chain(|ts| Ok(ty::mk_tup(tcx, ts)) )\n         } else {\n             Err(ty::terr_tuple_size(\n                 expected_found(this, as_.len(), bs.len())))"}, {"sha": "5d988965e8cccc9ce61eb583530b63225b58caae", "filename": "src/libstd/either.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=72b50e729d9662ed22f87aa1fcb97a309afbc0fa", "patch": "@@ -16,7 +16,7 @@ use option::{Some, None};\n use clone::Clone;\n use container::Container;\n use cmp::Eq;\n-use iterator::Iterator;\n+use iterator::{Iterator, FilterMap};\n use result::Result;\n use result;\n use str::StrSlice;\n@@ -116,40 +116,44 @@ impl<L, R> Either<L, R> {\n     }\n }\n \n-// FIXME: #8228 Replaceable by an external iterator?\n-/// Extracts from a vector of either all the left values\n-pub fn lefts<L: Clone, R>(eithers: &[Either<L, R>]) -> ~[L] {\n-    do vec::build_sized(eithers.len()) |push| {\n-        for elt in eithers.iter() {\n-            match *elt {\n-                Left(ref l) => { push((*l).clone()); }\n-                _ => { /* fallthrough */ }\n-            }\n+/// An iterator yielding the `Left` values of its source\n+pub type Lefts<L, R, Iter> = FilterMap<'static, Either<L, R>, L, Iter>;\n+\n+/// An iterator yielding the `Right` values of its source\n+pub type Rights<L, R, Iter> = FilterMap<'static, Either<L, R>, R, Iter>;\n+\n+/// Extracts all the left values\n+pub fn lefts<L, R, Iter: Iterator<Either<L, R>>>(eithers: Iter)\n+    -> Lefts<L, R, Iter> {\n+    do eithers.filter_map |elt| {\n+        match elt {\n+            Left(x) => Some(x),\n+            _ => None,\n         }\n     }\n }\n \n-// FIXME: #8228 Replaceable by an external iterator?\n-/// Extracts from a vector of either all the right values\n-pub fn rights<L, R: Clone>(eithers: &[Either<L, R>]) -> ~[R] {\n-    do vec::build_sized(eithers.len()) |push| {\n-        for elt in eithers.iter() {\n-            match *elt {\n-                Right(ref r) => { push((*r).clone()); }\n-                _ => { /* fallthrough */ }\n-            }\n+/// Extracts all the right values\n+pub fn rights<L, R, Iter: Iterator<Either<L, R>>>(eithers: Iter)\n+    -> Rights<L, R, Iter> {\n+    do eithers.filter_map |elt| {\n+        match elt {\n+            Right(x) => Some(x),\n+            _ => None,\n         }\n     }\n }\n \n+\n // FIXME: #8228 Replaceable by an external iterator?\n /// Extracts from a vector of either all the left values and right values\n ///\n /// Returns a structure containing a vector of left values and a vector of\n /// right values.\n pub fn partition<L, R>(eithers: ~[Either<L, R>]) -> (~[L], ~[R]) {\n-    let mut lefts: ~[L] = ~[];\n-    let mut rights: ~[R] = ~[];\n+    let n_lefts = eithers.iter().count(|elt| elt.is_left());\n+    let mut lefts = vec::with_capacity(n_lefts);\n+    let mut rights = vec::with_capacity(eithers.len() - n_lefts);\n     for elt in eithers.move_iter() {\n         match elt {\n             Left(l) => lefts.push(l),\n@@ -182,42 +186,42 @@ mod tests {\n     #[test]\n     fn test_lefts() {\n         let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-        let result = lefts(input);\n+        let result = lefts(input.move_iter()).to_owned_vec();\n         assert_eq!(result, ~[10, 12, 14]);\n     }\n \n     #[test]\n     fn test_lefts_none() {\n         let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n-        let result = lefts(input);\n+        let result = lefts(input.move_iter()).to_owned_vec();\n         assert_eq!(result.len(), 0u);\n     }\n \n     #[test]\n     fn test_lefts_empty() {\n         let input: ~[Either<int, int>] = ~[];\n-        let result = lefts(input);\n+        let result = lefts(input.move_iter()).to_owned_vec();\n         assert_eq!(result.len(), 0u);\n     }\n \n     #[test]\n     fn test_rights() {\n         let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n-        let result = rights(input);\n+        let result = rights(input.move_iter()).to_owned_vec();\n         assert_eq!(result, ~[11, 13]);\n     }\n \n     #[test]\n     fn test_rights_none() {\n         let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n-        let result = rights(input);\n+        let result = rights(input.move_iter()).to_owned_vec();\n         assert_eq!(result.len(), 0u);\n     }\n \n     #[test]\n     fn test_rights_empty() {\n         let input: ~[Either<int, int>] = ~[];\n-        let result = rights(input);\n+        let result = rights(input.move_iter()).to_owned_vec();\n         assert_eq!(result.len(), 0u);\n     }\n "}, {"sha": "9ae901d60bc46ee755f13a98c8495b9b9d3a51e5", "filename": "src/libstd/result.rs", "status": "modified", "additions": 84, "deletions": 55, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=72b50e729d9662ed22f87aa1fcb97a309afbc0fa", "patch": "@@ -18,8 +18,7 @@ use either;\n use iterator::Iterator;\n use option::{None, Option, Some, OptionIterator};\n use vec;\n-use vec::{OwnedVector, ImmutableVector};\n-use container::Container;\n+use vec::OwnedVector;\n use to_str::ToStr;\n use str::StrSlice;\n \n@@ -269,86 +268,76 @@ pub fn map_opt<T, U: ToStr, V>(o_t: &Option<T>,\n     }\n }\n \n-// FIXME: #8228 Replaceable by an external iterator?\n-/// Maps each element in the vector `ts` using the operation `op`.  Should an\n-/// error occur, no further mappings are performed and the error is returned.\n-/// Should no error occur, a vector containing the result of each map is\n-/// returned.\n+/// Takes each element in the iterator: if it is an error, no further\n+/// elements are taken, and the error is returned.\n+/// Should no error occur, a vector containing the values of each Result\n+/// is returned.\n ///\n /// Here is an example which increments every integer in a vector,\n /// checking for overflow:\n ///\n-///     fn inc_conditionally(x: uint) -> result<uint,str> {\n+///     fn inc_conditionally(x: uint) -> Result<uint, &'static str> {\n ///         if x == uint::max_value { return Err(\"overflow\"); }\n ///         else { return Ok(x+1u); }\n ///     }\n-///     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n-///         assert!(incd == ~[2u, 3u, 4u]);\n-///     }\n+///     let v = [1u, 2, 3];\n+///     let res = collect(v.iter().map(|&x| inc_conditionally(x)));\n+///     assert!(res == Ok(~[2u, 3, 4]));\n #[inline]\n-pub fn map_vec<T,U,V>(ts: &[T], op: &fn(&T) -> Result<V,U>)\n-                      -> Result<~[V],U> {\n-    let mut vs: ~[V] = vec::with_capacity(ts.len());\n-    for t in ts.iter() {\n-        match op(t) {\n-          Ok(v) => vs.push(v),\n-          Err(u) => return Err(u)\n+pub fn collect<T, E, Iter: Iterator<Result<T, E>>>(mut iterator: Iter)\n+    -> Result<~[T], E> {\n+    let (lower, _) = iterator.size_hint();\n+    let mut vs: ~[T] = vec::with_capacity(lower);\n+    for t in iterator {\n+        match t {\n+            Ok(v) => vs.push(v),\n+            Err(u) => return Err(u)\n         }\n     }\n-    return Ok(vs);\n+    Ok(vs)\n }\n \n-// FIXME: #8228 Replaceable by an external iterator?\n-/// Same as map, but it operates over two parallel vectors.\n+/// Perform a fold operation over the result values from an iterator.\n ///\n-/// A precondition is used here to ensure that the vectors are the same\n-/// length.  While we do not often use preconditions in the standard\n-/// library, a precondition is used here because result::t is generally\n-/// used in 'careful' code contexts where it is both appropriate and easy\n-/// to accommodate an error like the vectors being of different lengths.\n+/// If an `Err` is encountered, it is immediately returned.\n+/// Otherwise, the folded value is returned.\n #[inline]\n-pub fn map_vec2<S, T, U: ToStr, V>(ss: &[S], ts: &[T],\n-                                   op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n-    assert!(vec::same_length(ss, ts));\n-    let n = ts.len();\n-    let mut vs = vec::with_capacity(n);\n-    let mut i = 0u;\n-    while i < n {\n-        match op(&ss[i],&ts[i]) {\n-          Ok(v) => vs.push(v),\n-          Err(u) => return Err(u)\n+pub fn fold<T, V, E,\n+            Iter: Iterator<Result<T, E>>>(\n+            mut iterator: Iter,\n+            mut init: V,\n+            f: &fn(V, T) -> V)\n+         -> Result<V, E> {\n+    for t in iterator {\n+        match t {\n+            Ok(v) => init = f(init, v),\n+            Err(u) => return Err(u)\n         }\n-        i += 1u;\n     }\n-    return Ok(vs);\n+    Ok(init)\n }\n \n-// FIXME: #8228 Replaceable by an external iterator?\n-/// Applies op to the pairwise elements from `ss` and `ts`, aborting on\n-/// error.  This could be implemented using `map_zip()` but it is more efficient\n-/// on its own as no result vector is built.\n+/// Perform a trivial fold operation over the result values\n+/// from an iterator.\n+///\n+/// If an `Err` is encountered, it is immediately returned.\n+/// Otherwise, a simple `Ok(())` is returned.\n #[inline]\n-pub fn iter_vec2<S, T, U: ToStr>(ss: &[S], ts: &[T],\n-                                 op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n-    assert!(vec::same_length(ss, ts));\n-    let n = ts.len();\n-    let mut i = 0u;\n-    while i < n {\n-        match op(&ss[i],&ts[i]) {\n-          Ok(()) => (),\n-          Err(u) => return Err(u)\n-        }\n-        i += 1u;\n-    }\n-    return Ok(());\n+pub fn fold_<T, E, Iter: Iterator<Result<T, E>>>(\n+             iterator: Iter)\n+          -> Result<(), E> {\n+    fold(iterator, (), |_, _| ())\n }\n \n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     use either;\n+    use iterator::range;\n     use str::OwnedStr;\n+    use vec::ImmutableVector;\n \n     pub fn op1() -> Result<int, ~str> { Ok(666) }\n \n@@ -431,4 +420,44 @@ mod tests {\n         assert_eq!(r.to_either(), either::Right(100));\n         assert_eq!(err.to_either(), either::Left(404));\n     }\n+\n+    #[test]\n+    fn test_collect() {\n+        assert_eq!(collect(range(0, 0)\n+                           .map(|_| Ok::<int, ()>(0))),\n+                   Ok(~[]));\n+        assert_eq!(collect(range(0, 3)\n+                           .map(|x| Ok::<int, ()>(x))),\n+                   Ok(~[0, 1, 2]));\n+        assert_eq!(collect(range(0, 3)\n+                           .map(|x| if x > 1 { Err(x) } else { Ok(x) })),\n+                   Err(2));\n+\n+        // test that it does not take more elements than it needs\n+        let functions = [|| Ok(()), || Err(1), || fail!()];\n+\n+        assert_eq!(collect(functions.iter().map(|f| (*f)())),\n+                   Err(1));\n+    }\n+\n+    #[test]\n+    fn test_fold() {\n+        assert_eq!(fold_(range(0, 0)\n+                        .map(|_| Ok::<(), ()>(()))),\n+                   Ok(()));\n+        assert_eq!(fold(range(0, 3)\n+                        .map(|x| Ok::<int, ()>(x)),\n+                        0, |a, b| a + b),\n+                   Ok(3));\n+        assert_eq!(fold_(range(0, 3)\n+                        .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n+                   Err(2));\n+\n+        // test that it does not take more elements than it needs\n+        let functions = [|| Ok(()), || Err(1), || fail!()];\n+\n+        assert_eq!(fold_(functions.iter()\n+                        .map(|f| (*f)())),\n+                   Err(1));\n+    }\n }"}, {"sha": "a2664dcf890ad3b3a44d035c05399b291e8c7dc6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72b50e729d9662ed22f87aa1fcb97a309afbc0fa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=72b50e729d9662ed22f87aa1fcb97a309afbc0fa", "patch": "@@ -3445,7 +3445,7 @@ impl Parser {\n                 |p| p.parse_arg()\n             );\n \n-        let inputs = either::lefts(args_or_capture_items);\n+        let inputs = either::lefts(args_or_capture_items.move_iter()).collect();\n \n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ast::fn_decl {\n@@ -3608,7 +3608,7 @@ impl Parser {\n \n         let hi = self.span.hi;\n \n-        let inputs = either::lefts(args_or_capture_items);\n+        let inputs = either::lefts(args_or_capture_items.move_iter()).collect();\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n \n         let fn_decl = ast::fn_decl {\n@@ -3641,7 +3641,7 @@ impl Parser {\n         };\n \n         ast::fn_decl {\n-            inputs: either::lefts(inputs_captures),\n+            inputs: either::lefts(inputs_captures.move_iter()).collect(),\n             output: output,\n             cf: return_val,\n         }"}]}