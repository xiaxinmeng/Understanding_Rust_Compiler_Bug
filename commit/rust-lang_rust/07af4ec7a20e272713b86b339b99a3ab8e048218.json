{"sha": "07af4ec7a20e272713b86b339b99a3ab8e048218", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YWY0ZWM3YTIwZTI3MjcxM2I4NmIzMzliOTlhM2FiOGUwNDgyMTg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-08T22:29:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-18T10:51:43Z"}, "message": "resolve: Resolve single-segment imports using in-scope resolution on 2018 edition", "tree": {"sha": "7cc43114dfce029afe75f5d69bc9f8e35f7713c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cc43114dfce029afe75f5d69bc9f8e35f7713c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07af4ec7a20e272713b86b339b99a3ab8e048218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07af4ec7a20e272713b86b339b99a3ab8e048218", "html_url": "https://github.com/rust-lang/rust/commit/07af4ec7a20e272713b86b339b99a3ab8e048218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07af4ec7a20e272713b86b339b99a3ab8e048218/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f", "html_url": "https://github.com/rust-lang/rust/commit/1cfd08c0c439d7a867239b0b99f54e249ea6ed5f"}], "stats": {"total": 272, "additions": 148, "deletions": 124}, "files": [{"sha": "bbbeb369844bc172c97416f0a6c7cb7d89c4bcfa", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=07af4ec7a20e272713b86b339b99a3ab8e048218", "patch": "@@ -809,6 +809,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n+                    None,\n                     false,\n                     span,\n                 );"}, {"sha": "525c75d15c4bbf46e8a4e549f27bd5033a4ae93f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=07af4ec7a20e272713b86b339b99a3ab8e048218", "patch": "@@ -103,6 +103,15 @@ enum DeterminacyExt {\n     WeakUndetermined,\n }\n \n+impl DeterminacyExt {\n+    fn to_determinacy(self) -> Determinacy {\n+        match self {\n+            DeterminacyExt::Determined => Determined,\n+            DeterminacyExt::Undetermined | DeterminacyExt::WeakUndetermined => Undetermined,\n+        }\n+    }\n+}\n+\n /// A free importable items suggested in case of resolution failure.\n struct ImportSuggestion {\n     path: Path,\n@@ -998,15 +1007,22 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n+\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+enum UniformRootKind {\n+    CurrentScope,\n+    ExternPrelude,\n+}\n+\n #[derive(Copy, Clone, Debug)]\n-pub enum ModuleOrUniformRoot<'a> {\n+enum ModuleOrUniformRoot<'a> {\n     /// Regular module.\n     Module(Module<'a>),\n \n-    /// The `{{root}}` (`CrateRoot` aka \"global\") / `extern` initial segment\n-    /// in which external crates resolve, and also `crate` (only in `{{root}}`,\n-    /// but *not* `extern`), in the Rust 2018 edition.\n-    UniformRoot(Name),\n+    /// This \"virtual module\" denotes either resolution in extern prelude\n+    /// for paths starting with `::` on 2018 edition or `extern::`,\n+    /// or resolution in current scope for single-segment imports.\n+    UniformRoot(UniformRootKind),\n }\n \n #[derive(Clone, Debug)]\n@@ -2158,23 +2174,31 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         None\n     }\n \n-    fn resolve_ident_in_module(&mut self,\n-                               module: ModuleOrUniformRoot<'a>,\n-                               mut ident: Ident,\n-                               ns: Namespace,\n-                               record_used: bool,\n-                               span: Span)\n-                               -> Result<&'a NameBinding<'a>, Determinacy> {\n+    fn resolve_ident_in_module(\n+        &mut self,\n+        module: ModuleOrUniformRoot<'a>,\n+        mut ident: Ident,\n+        ns: Namespace,\n+        parent_scope: Option<&ParentScope<'a>>,\n+        record_used: bool,\n+        path_span: Span\n+    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         ident.span = ident.span.modern();\n         let orig_current_module = self.current_module;\n-        if let ModuleOrUniformRoot::Module(module) = module {\n-            if let Some(def) = ident.span.adjust(module.expansion) {\n-                self.current_module = self.macro_def_scope(def);\n+        match module {\n+            ModuleOrUniformRoot::Module(module) => {\n+                if let Some(def) = ident.span.adjust(module.expansion) {\n+                    self.current_module = self.macro_def_scope(def);\n+                }\n+            }\n+            ModuleOrUniformRoot::UniformRoot(UniformRootKind::ExternPrelude) => {\n+                ident.span.adjust(Mark::root());\n             }\n+            _ => {}\n         }\n-        let result = self.resolve_ident_in_module_unadjusted(\n-            module, ident, ns, record_used, span,\n-        );\n+        let result = self.resolve_ident_in_module_unadjusted_ext(\n+            module, ident, ns, parent_scope, false, record_used, path_span,\n+        ).map_err(DeterminacyExt::to_determinacy);\n         self.current_module = orig_current_module;\n         result\n     }\n@@ -2671,6 +2695,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n+                None,\n                 false,\n                 span,\n             ).is_err() {\n@@ -3699,9 +3724,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                         continue;\n                     }\n                     if name == keywords::Extern.name() ||\n-                       name == keywords::CrateRoot.name() &&\n-                       self.session.rust_2018() {\n-                        module = Some(ModuleOrUniformRoot::UniformRoot(name));\n+                       name == keywords::CrateRoot.name() && self.session.rust_2018() {\n+                        module =\n+                            Some(ModuleOrUniformRoot::UniformRoot(UniformRootKind::ExternPrelude));\n                         continue;\n                     }\n                     if name == keywords::CrateRoot.name() ||\n@@ -3731,7 +3756,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n \n             let binding = if let Some(module) = module {\n-                self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n+                self.resolve_ident_in_module(module, ident, ns, None, record_used, path_span)\n             } else if opt_ns.is_none() || opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n                 self.early_resolve_ident_in_lexical_scope(ident, ns, None, opt_ns.is_none(),\n@@ -3751,7 +3776,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             def, path.len() - 1\n                         ));\n                     }\n-                    _ => Err(if record_used { Determined } else { Undetermined }),\n+                    _ => Err(Determinacy::determined(record_used)),\n                 }\n             };\n \n@@ -3825,7 +3850,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         PathResult::Module(match module {\n             Some(module) => module,\n-            None if path.is_empty() => ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name()),\n+            None if path.is_empty() =>\n+                ModuleOrUniformRoot::UniformRoot(UniformRootKind::CurrentScope),\n             _ => span_bug!(path_span, \"resolve_path: non-empty path `{:?}` has no module\", path),\n         })\n     }\n@@ -4037,6 +4063,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     ns,\n+                    None,\n                     false,\n                     module.span,\n                 ) {\n@@ -4359,6 +4386,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n+                None,\n                 false,\n                 module.span,\n             ).is_ok() {\n@@ -4945,6 +4973,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n     fn extern_prelude_get(&mut self, ident: Ident, speculative: bool, skip_feature_gate: bool)\n                           -> Option<&'a NameBinding<'a>> {\n+        if ident.is_path_segment_keyword() {\n+            // Make sure `self`, `super` etc produce an error when passed to here.\n+            return None;\n+        }\n         self.extern_prelude.get(&ident.modern()).cloned().and_then(|entry| {\n             if let Some(binding) = entry.extern_crate_item {\n                 if !speculative && !skip_feature_gate && entry.introduced_by_item &&"}, {"sha": "37d6773c9c4f81e1173e849e877b29a7ee24cf4a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=07af4ec7a20e272713b86b339b99a3ab8e048218", "patch": "@@ -371,11 +371,11 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n }\n \n impl<'a, 'cl> Resolver<'a, 'cl> {\n-    pub fn dummy_parent_scope(&mut self) -> ParentScope<'a> {\n+    pub fn dummy_parent_scope(&self) -> ParentScope<'a> {\n         self.invoc_parent_scope(Mark::root(), Vec::new())\n     }\n \n-    fn invoc_parent_scope(&mut self, invoc_id: Mark, derives: Vec<ast::Path>) -> ParentScope<'a> {\n+    fn invoc_parent_scope(&self, invoc_id: Mark, derives: Vec<ast::Path>) -> ParentScope<'a> {\n         let invoc = self.invocations[&invoc_id];\n         ParentScope {\n             module: invoc.module.get().nearest_item_scope(),\n@@ -610,6 +610,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         assert!(macro_kind.is_none() || !is_import); // `is_import` implies no macro kind\n         ident = ident.modern();\n \n+        // Make sure `self`, `super` etc produce an error when passed to here.\n+        if ident.is_path_segment_keyword() {\n+            return Err(Determinacy::Determined);\n+        }\n+\n         // This is *the* result, resolution from the scope closest to the resolved identifier.\n         // However, sometimes this result is \"weak\" because it comes from a glob import or\n         // a macro expansion, and in this case it cannot shadow names from outer scopes, e.g.\n@@ -671,6 +676,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         ModuleOrUniformRoot::Module(module),\n                         ident,\n                         ns,\n+                        None,\n                         true,\n                         record_used,\n                         path_span,"}, {"sha": "15cf95b7ba74dac920c932395e7e05377c837112", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 68, "deletions": 95, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=07af4ec7a20e272713b86b339b99a3ab8e048218", "patch": "@@ -11,7 +11,7 @@\n use self::ImportDirectiveSubclass::*;\n \n use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use {CrateLint, DeterminacyExt, Module, ModuleOrUniformRoot, PerNS};\n+use {CrateLint, DeterminacyExt, Module, ModuleOrUniformRoot, PerNS, UniformRootKind};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use {Resolver, Segment};\n@@ -23,7 +23,7 @@ use rustc_data_structures::ptr_key::PtrKey;\n use rustc::ty;\n use rustc::lint::builtin::BuiltinLintDiagnostics;\n use rustc::lint::builtin::{DUPLICATE_MACRO_EXPORTS, PUB_USE_OF_PRIVATE_EXTERN_CRATE};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::def::*;\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n@@ -61,7 +61,7 @@ pub enum ImportDirectiveSubclass<'a> {\n \n /// One import directive.\n #[derive(Debug,Clone)]\n-pub struct ImportDirective<'a> {\n+crate struct ImportDirective<'a> {\n     /// The id of the `extern crate`, `UseTree` etc that imported this `ImportDirective`.\n     ///\n     /// In the case where the `ImportDirective` was expanded from a \"nested\" use tree,\n@@ -144,11 +144,8 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         path_span: Span,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.resolve_ident_in_module_unadjusted_ext(\n-            module, ident, ns, false, record_used, path_span\n-        ).map_err(|determinacy_ext| match determinacy_ext {\n-            DeterminacyExt::Determined => Determined,\n-            DeterminacyExt::Undetermined | DeterminacyExt::WeakUndetermined => Undetermined,\n-        })\n+            module, ident, ns, None, false, record_used, path_span\n+        ).map_err(DeterminacyExt::to_determinacy)\n     }\n \n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n@@ -158,87 +155,55 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n         ns: Namespace,\n+        parent_scope: Option<&ParentScope<'a>>,\n         restricted_shadowing: bool,\n         record_used: bool,\n         path_span: Span,\n     ) -> Result<&'a NameBinding<'a>, DeterminacyExt> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n-            ModuleOrUniformRoot::UniformRoot(root) => {\n-                // HACK(eddyb): `resolve_path` uses `keywords::Invalid` to indicate\n-                // paths of length 0, and currently these are relative `use` paths.\n-                let can_be_relative = !ident.is_path_segment_keyword() &&\n-                    root == keywords::Invalid.name();\n-                if can_be_relative {\n-                    // Try first to resolve relatively.\n-                    let mut ctxt = ident.span.ctxt().modern();\n-                    let self_module = self.resolve_self(&mut ctxt, self.current_module);\n-\n-                    let binding = self.resolve_ident_in_module_unadjusted_ext(\n-                        ModuleOrUniformRoot::Module(self_module),\n-                        ident,\n-                        ns,\n-                        restricted_shadowing,\n-                        record_used,\n-                        path_span,\n-                    );\n-\n-                    // FIXME(eddyb) This may give false negatives, specifically\n-                    // if a crate with the same name is found in `extern_prelude`,\n-                    // preventing the check below this one from returning `binding`\n-                    // in all cases.\n-                    //\n-                    // That is, if there's no crate with the same name, `binding`\n-                    // is always returned, which is the result of doing the exact\n-                    // same lookup of `ident`, in the `self` module.\n-                    // But when a crate does exist, it will get chosen even when\n-                    // macro expansion could result in a success from the lookup\n-                    // in the `self` module, later on.\n-                    if binding.is_ok() {\n-                        return binding;\n+            ModuleOrUniformRoot::UniformRoot(uniform_root_kind) => {\n+                assert!(!restricted_shadowing);\n+                match uniform_root_kind {\n+                    UniformRootKind::ExternPrelude => {\n+                        return if let Some(binding) =\n+                                self.extern_prelude_get(ident, !record_used, false) {\n+                            Ok(binding)\n+                        } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n+                            // Macro-expanded `extern crate` items can add names to extern prelude.\n+                            Err(DeterminacyExt::Undetermined)\n+                        } else {\n+                            Err(DeterminacyExt::Determined)\n+                        }\n                     }\n+                    UniformRootKind::CurrentScope => {\n+                        let parent_scope =\n+                            parent_scope.expect(\"no parent scope for a single-segment import\");\n+\n+                        if ns == TypeNS {\n+                            if ident.name == keywords::Crate.name() ||\n+                               ident.name == keywords::DollarCrate.name() {\n+                                let module = self.resolve_crate_root(ident);\n+                                let binding = (module, ty::Visibility::Public,\n+                                               module.span, Mark::root())\n+                                               .to_name_binding(self.arenas);\n+                                return Ok(binding);\n+                            } else if ident.name == keywords::Super.name() ||\n+                                      ident.name == keywords::SelfValue.name() {\n+                                // FIXME: Implement these with renaming requirements so that e.g.\n+                                // `use super;` doesn't work, but `use super as name;` does.\n+                            }\n+                        }\n \n-                    // Fall back to resolving to an external crate.\n-                    if !(\n-                        ns == TypeNS &&\n-                        !ident.is_path_segment_keyword() &&\n-                        self.extern_prelude.contains_key(&ident.modern())\n-                    ) {\n-                        // ... unless the crate name is not in the `extern_prelude`.\n-                        return binding;\n+                        let binding = self.early_resolve_ident_in_lexical_scope(\n+                            ident, ns, None, true, parent_scope, record_used, record_used, path_span\n+                        );\n+                        return binding.map_err(|determinacy| match determinacy {\n+                            Determined => DeterminacyExt::Determined,\n+                            Undetermined => DeterminacyExt::Undetermined,\n+                        });\n                     }\n                 }\n-\n-                let crate_root = if\n-                    ns == TypeNS &&\n-                    root != keywords::Extern.name() &&\n-                    (\n-                        ident.name == keywords::Crate.name() ||\n-                        ident.name == keywords::DollarCrate.name()\n-                    )\n-                {\n-                    self.resolve_crate_root(ident)\n-                } else if\n-                    ns == TypeNS &&\n-                    !ident.is_path_segment_keyword()\n-                {\n-                    if let Some(binding) = self.extern_prelude_get(ident, !record_used, false) {\n-                        let module = self.get_module(binding.def().def_id());\n-                        self.populate_module_if_necessary(module);\n-                        return Ok(binding);\n-                    } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n-                        // Macro-expanded `extern crate`items still can add names to extern prelude.\n-                        return Err(DeterminacyExt::Undetermined);\n-                    } else {\n-                        return Err(DeterminacyExt::Determined);\n-                    }\n-                } else {\n-                    return Err(DeterminacyExt::Determined);\n-                };\n-                self.populate_module_if_necessary(crate_root);\n-                let binding = (crate_root, ty::Visibility::Public,\n-                               crate_root.span, Mark::root()).to_name_binding(self.arenas);\n-                return Ok(binding);\n             }\n         };\n \n@@ -312,7 +277,8 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 SingleImport { source, .. } => source,\n                 _ => unreachable!(),\n             };\n-            match self.resolve_ident_in_module(module, ident, ns, false, path_span) {\n+            match self.resolve_ident_in_module(module, ident, ns, Some(&single_import.parent_scope),\n+                                               false, path_span) {\n                 Err(Determined) => continue,\n                 Ok(binding) if !self.is_accessible_from(\n                     binding.vis, single_import.parent_scope.module\n@@ -439,8 +405,8 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n \n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n-    pub fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n-                  -> &'a NameBinding<'a> {\n+    crate fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n+                    -> &'a NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n                      // c.f. `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n                      !directive.is_glob() && binding.is_extern_crate() {\n@@ -768,10 +734,9 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let module = if let Some(module) = directive.imported_module.get() {\n             module\n         } else {\n-            let vis = directive.vis.get();\n-            // For better failure detection, pretend that the import will not define any names\n-            // while resolving its module path.\n-            directive.vis.set(ty::Visibility::Invisible);\n+            // For better failure detection, pretend that the import will\n+            // not define any names while resolving its module path.\n+            let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n             let result = self.resolve_path(\n                 &directive.module_path[..],\n                 None,\n@@ -780,7 +745,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 directive.span,\n                 directive.crate_lint(),\n             );\n-            directive.vis.set(vis);\n+            directive.vis.set(orig_vis);\n \n             match result {\n                 PathResult::Module(module) => module,\n@@ -803,11 +768,15 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let mut indeterminate = false;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set(this.resolve_ident_in_module(module,\n-                                                            source,\n-                                                            ns,\n-                                                            false,\n-                                                            directive.span));\n+                // For better failure detection, pretend that the import will\n+                // not define any names while resolving its module path.\n+                let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+                let binding = this.resolve_ident_in_module(\n+                    module, source, ns, Some(&directive.parent_scope), false, directive.span\n+                );\n+                directive.vis.set(orig_vis);\n+\n+                result[ns].set(binding);\n             } else {\n                 return\n             };\n@@ -940,7 +909,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                if this.resolve_ident_in_module(module, ident, ns, true, span).is_ok() {\n+                let binding = this.resolve_ident_in_module(\n+                    module, ident, ns, Some(&directive.parent_scope), true, span\n+                );\n+                if binding.is_ok() {\n                     all_ns_failed = false;\n                 }\n             });\n@@ -1140,8 +1112,9 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             if binding.is_import() || binding.is_macro_def() {\n                 let def = binding.def();\n                 if def != Def::Err {\n-                    if !def.def_id().is_local() {\n-                        self.cstore.export_macros_untracked(def.def_id().krate);\n+                    let def_id = def.def_id();\n+                    if !def_id.is_local() && def_id.krate != CrateNum::BuiltinMacros {\n+                        self.cstore.export_macros_untracked(def_id.krate);\n                     }\n                     reexports.push(Export {\n                         ident: ident.modern(),"}, {"sha": "27b9a34ff4eb769f229f6e2581532648925c2c9d", "filename": "src/test/ui/feature-gates/feature-gate-extern_crate_item_prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.rs?ref=07af4ec7a20e272713b86b339b99a3ab8e048218", "patch": "@@ -1,6 +1,6 @@\n // edition:2018\n \n-#![feature(alloc)]\n+#![feature(alloc, underscore_imports)]\n \n extern crate alloc;\n \n@@ -23,7 +23,7 @@ mod absolute {\n }\n \n mod import_in_scope {\n-    use alloc;\n+    use alloc as _;\n     //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable\n     use alloc::boxed;\n     //~^ ERROR use of extern prelude names introduced with `extern crate` items is unstable"}, {"sha": "103ab79ef84cb2fa96602e5d578547837071f203", "filename": "src/test/ui/feature-gates/feature-gate-extern_crate_item_prelude.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-extern_crate_item_prelude.stderr?ref=07af4ec7a20e272713b86b339b99a3ab8e048218", "patch": "@@ -1,7 +1,7 @@\n error[E0658]: use of extern prelude names introduced with `extern crate` items is unstable (see issue #55599)\n   --> $DIR/feature-gate-extern_crate_item_prelude.rs:26:9\n    |\n-LL |     use alloc;\n+LL |     use alloc as _;\n    |         ^^^^^\n    |\n    = help: add #![feature(extern_crate_item_prelude)] to the crate attributes to enable"}, {"sha": "5c3c753f9a7857eb5399e42a8dc5a9010bc0e167", "filename": "src/test/ui/rust-2018/uniform-paths/from-decl-macro.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffrom-decl-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07af4ec7a20e272713b86b339b99a3ab8e048218/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffrom-decl-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffrom-decl-macro.rs?ref=07af4ec7a20e272713b86b339b99a3ab8e048218", "patch": "@@ -0,0 +1,12 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(decl_macro)]\n+\n+macro check() {\n+    ::std::vec::Vec::<u8>::new()\n+}\n+\n+fn main() {\n+    check!();\n+}"}]}