{"sha": "405fe11b249988b39b6213a4b9912ae132c0ae3c", "node_id": "C_kwDOAAsO6NoAKDQwNWZlMTFiMjQ5OTg4YjM5YjYyMTNhNGI5OTEyYWUxMzJjMGFlM2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-13T18:21:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-13T18:21:08Z"}, "message": "Auto merge of #2895 - RalfJung:simd_bitmask, r=RalfJung\n\nsupport array return types in simd_bitmask\n\nFixes https://github.com/rust-lang/miri/issues/2734\n\nAs usual I am stomped by the simd_bitmask behavior wrt endianess. I confirmed that for little endian, Miri matches what rustc currently does, but I can't test rustc on big endian. `@workingjubilee` `@calebzulawski` could you have a look whether those new tests make sense?", "tree": {"sha": "cc5e2c438289433a334fa24a095a4f78f16e421d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc5e2c438289433a334fa24a095a4f78f16e421d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/405fe11b249988b39b6213a4b9912ae132c0ae3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/405fe11b249988b39b6213a4b9912ae132c0ae3c", "html_url": "https://github.com/rust-lang/rust/commit/405fe11b249988b39b6213a4b9912ae132c0ae3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/405fe11b249988b39b6213a4b9912ae132c0ae3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68941d4f68b94b6312fa4306d2e384da5b08b50f", "url": "https://api.github.com/repos/rust-lang/rust/commits/68941d4f68b94b6312fa4306d2e384da5b08b50f", "html_url": "https://github.com/rust-lang/rust/commit/68941d4f68b94b6312fa4306d2e384da5b08b50f"}, {"sha": "e75d91d22ddf9820ac3bc379b586d1d07e032568", "url": "https://api.github.com/repos/rust-lang/rust/commits/e75d91d22ddf9820ac3bc379b586d1d07e032568", "html_url": "https://github.com/rust-lang/rust/commit/e75d91d22ddf9820ac3bc379b586d1d07e032568"}], "stats": {"total": 44, "additions": 42, "deletions": 2}, "files": [{"sha": "4acb2201adecd354756ad5242baddbeb2d688bec", "filename": "src/tools/miri/src/shims/intrinsics/simd.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/405fe11b249988b39b6213a4b9912ae132c0ae3c/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/405fe11b249988b39b6213a4b9912ae132c0ae3c/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs?ref=405fe11b249988b39b6213a4b9912ae132c0ae3c", "patch": "@@ -563,7 +563,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let (op, op_len) = this.operand_to_simd(op)?;\n                 let bitmask_len = op_len.max(8);\n \n-                assert!(dest.layout.ty.is_integral());\n+                // Returns either an unsigned integer or array of `u8`.\n+                assert!(\n+                    dest.layout.ty.is_integral()\n+                        || matches!(dest.layout.ty.kind(), ty::Array(elemty, _) if elemty == &this.tcx.types.u8)\n+                );\n                 assert!(bitmask_len <= 64);\n                 assert_eq!(bitmask_len, dest.layout.size.bits());\n                 let op_len = u32::try_from(op_len).unwrap();\n@@ -577,7 +581,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                             .unwrap();\n                     }\n                 }\n-                this.write_int(res, dest)?;\n+                // We have to force the place type to be an int so that we can write `res` into it.\n+                let mut dest = this.force_allocation(dest)?;\n+                dest.layout = this.machine.layouts.uint(dest.layout.size).unwrap();\n+                this.write_int(res, &dest.into())?;\n             }\n \n             name => throw_unsup_format!(\"unimplemented intrinsic: `simd_{name}`\"),"}, {"sha": "ee67a65a4f9a206d37293456ac238295de4e7c3c", "filename": "src/tools/miri/tests/pass/portable-simd.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/405fe11b249988b39b6213a4b9912ae132c0ae3c/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/405fe11b249988b39b6213a4b9912ae132c0ae3c/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fportable-simd.rs?ref=405fe11b249988b39b6213a4b9912ae132c0ae3c", "patch": "@@ -2,6 +2,10 @@\n #![feature(portable_simd, platform_intrinsics)]\n use std::simd::*;\n \n+extern \"platform-intrinsic\" {\n+    pub(crate) fn simd_bitmask<T, U>(x: T) -> U;\n+}\n+\n fn simd_ops_f32() {\n     let a = f32x4::splat(10.0);\n     let b = f32x4::from_array([1.0, 2.0, 3.0, -4.0]);\n@@ -208,11 +212,40 @@ fn simd_mask() {\n     assert_eq!(bitmask, 0b1010001101001001);\n     assert_eq!(Mask::<i64, 16>::from_bitmask(bitmask), mask);\n \n+    // Also directly call intrinsic, to test both kinds of return types.\n+    unsafe {\n+        let bitmask1: u16 = simd_bitmask(mask.to_int());\n+        let bitmask2: [u8; 2] = simd_bitmask(mask.to_int());\n+        if cfg!(target_endian = \"little\") {\n+            assert_eq!(bitmask1, 0b1010001101001001);\n+            assert_eq!(bitmask2, [0b01001001, 0b10100011]);\n+        } else {\n+            // All the bitstrings are reversed compared to above, but the array elements are in the\n+            // same order.\n+            assert_eq!(bitmask1, 0b1001001011000101);\n+            assert_eq!(bitmask2, [0b10010010, 0b11000101]);\n+        }\n+    }\n+\n+    // Mask less than 8 bits long, which is a special case (padding with 0s).\n     let values = [false, false, false, true];\n     let mask = Mask::<i64, 4>::from_array(values);\n     let bitmask = mask.to_bitmask();\n     assert_eq!(bitmask, 0b1000);\n     assert_eq!(Mask::<i64, 4>::from_bitmask(bitmask), mask);\n+\n+    // Also directly call intrinsic, to test both kinds of return types.\n+    unsafe {\n+        let bitmask1: u8 = simd_bitmask(mask.to_int());\n+        let bitmask2: [u8; 1] = simd_bitmask(mask.to_int());\n+        if cfg!(target_endian = \"little\") {\n+            assert_eq!(bitmask1, 0b1000);\n+            assert_eq!(bitmask2, [0b1000]);\n+        } else {\n+            assert_eq!(bitmask1, 0b0001);\n+            assert_eq!(bitmask2, [0b0001]);\n+        }\n+    }\n }\n \n fn simd_cast() {"}]}