{"sha": "c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYWRiZDM0YzRlNjM3ZDIwYTE4NGViMDNmMDliMzBjNjlkZThiNmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-24T19:16:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-05T17:12:25Z"}, "message": "Fall out of the std::sync rewrite", "tree": {"sha": "7be3d3a9b5bf062fcffc8aa0b9e0de8267ab41c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7be3d3a9b5bf062fcffc8aa0b9e0de8267ab41c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "html_url": "https://github.com/rust-lang/rust/commit/c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71d4e77db8ad4b6d821da7e5d5300134ac95974e", "url": "https://api.github.com/repos/rust-lang/rust/commits/71d4e77db8ad4b6d821da7e5d5300134ac95974e", "html_url": "https://github.com/rust-lang/rust/commit/71d4e77db8ad4b6d821da7e5d5300134ac95974e"}], "stats": {"total": 287, "additions": 99, "deletions": 188}, "files": [{"sha": "7669df36b041d9282aea7e22d7b0f771d7332e86", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -38,9 +38,8 @@\n     \"rt/isaac/randport.cpp\", # public domain\n     \"rt/isaac/rand.h\", # public domain\n     \"rt/isaac/standard.h\", # public domain\n-    \"libstd/sync/mpsc_queue.rs\", # BSD\n-    \"libstd/sync/spsc_queue.rs\", # BSD\n-    \"libstd/sync/mpmc_bounded_queue.rs\", # BSD\n+    \"libstd/comm/mpsc_queue.rs\", # BSD\n+    \"libstd/comm/spsc_queue.rs\", # BSD\n     \"test/bench/shootout-binarytrees.rs\", # BSD\n     \"test/bench/shootout-chameneos-redux.rs\", # BSD\n     \"test/bench/shootout-fannkuch-redux.rs\", # BSD"}, {"sha": "d291ed7256743b224a8e4a4806ce5fb3a6871973", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -354,6 +354,8 @@ mod select;\n mod shared;\n mod stream;\n mod sync;\n+mod mpsc_queue;\n+mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n@@ -628,24 +630,26 @@ impl<T: Send> Sender<T> {\n #[unstable]\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n-        let (packet, sleeper) = match *unsafe { self.inner() } {\n+        let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n             Oneshot(ref p) => {\n                 let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n                 unsafe {\n-                    (*a.get()).postinit_lock();\n+                    let guard = (*a.get()).postinit_lock();\n                     match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n-                        oneshot::UpSuccess | oneshot::UpDisconnected => (a, None),\n-                        oneshot::UpWoke(task) => (a, Some(task))\n+                        oneshot::UpSuccess |\n+                        oneshot::UpDisconnected => (a, None, guard),\n+                        oneshot::UpWoke(task) => (a, Some(task), guard)\n                     }\n                 }\n             }\n             Stream(ref p) => {\n                 let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n                 unsafe {\n-                    (*a.get()).postinit_lock();\n+                    let guard = (*a.get()).postinit_lock();\n                     match (*p.get()).upgrade(Receiver::new(Shared(a.clone()))) {\n-                        stream::UpSuccess | stream::UpDisconnected => (a, None),\n-                        stream::UpWoke(task) => (a, Some(task)),\n+                        stream::UpSuccess |\n+                        stream::UpDisconnected => (a, None, guard),\n+                        stream::UpWoke(task) => (a, Some(task), guard),\n                     }\n                 }\n             }\n@@ -657,7 +661,7 @@ impl<T: Send> Clone for Sender<T> {\n         };\n \n         unsafe {\n-            (*packet.get()).inherit_blocker(sleeper);\n+            (*packet.get()).inherit_blocker(sleeper, guard);\n \n             let tmp = Sender::new(Shared(packet.clone()));\n             mem::swap(self.inner_mut(), tmp.inner_mut());"}, {"sha": "13b5e10fcd3dcd02cbf2ffb3a95a82cc005fb984", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -26,12 +26,11 @@ use alloc::boxed::Box;\n use core::cmp;\n use core::int;\n use rustrt::local::Local;\n-use rustrt::mutex::NativeMutex;\n use rustrt::task::{Task, BlockedTask};\n use rustrt::thread::Thread;\n \n-use sync::atomic;\n-use sync::mpsc_queue as mpsc;\n+use sync::{atomic, Mutex, MutexGuard};\n+use comm::mpsc_queue as mpsc;\n \n const DISCONNECTED: int = int::MIN;\n const FUDGE: int = 1024;\n@@ -56,7 +55,7 @@ pub struct Packet<T> {\n \n     // this lock protects various portions of this implementation during\n     // select()\n-    select_lock: NativeMutex,\n+    select_lock: Mutex<()>,\n }\n \n pub enum Failure {\n@@ -76,7 +75,7 @@ impl<T: Send> Packet<T> {\n             channels: atomic::AtomicInt::new(2),\n             port_dropped: atomic::AtomicBool::new(false),\n             sender_drain: atomic::AtomicInt::new(0),\n-            select_lock: unsafe { NativeMutex::new() },\n+            select_lock: Mutex::new(()),\n         };\n         return p;\n     }\n@@ -86,16 +85,18 @@ impl<T: Send> Packet<T> {\n     // In other case mutex data will be duplicated while cloning\n     // and that could cause problems on platforms where it is\n     // represented by opaque data structure\n-    pub fn postinit_lock(&mut self) {\n-        unsafe { self.select_lock.lock_noguard() }\n+    pub fn postinit_lock(&self) -> MutexGuard<()> {\n+        self.select_lock.lock()\n     }\n \n     // This function is used at the creation of a shared packet to inherit a\n     // previously blocked task. This is done to prevent spurious wakeups of\n     // tasks in select().\n     //\n     // This can only be called at channel-creation time\n-    pub fn inherit_blocker(&mut self, task: Option<BlockedTask>) {\n+    pub fn inherit_blocker(&mut self,\n+                           task: Option<BlockedTask>,\n+                           guard: MutexGuard<()>) {\n         match task {\n             Some(task) => {\n                 assert_eq!(self.cnt.load(atomic::SeqCst), 0);\n@@ -135,7 +136,7 @@ impl<T: Send> Packet<T> {\n         // interfere with this method. After we unlock this lock, we're\n         // signifying that we're done modifying self.cnt and self.to_wake and\n         // the port is ready for the world to continue using it.\n-        unsafe { self.select_lock.unlock_noguard() }\n+        drop(guard);\n     }\n \n     pub fn send(&mut self, t: T) -> Result<(), T> {\n@@ -441,7 +442,7 @@ impl<T: Send> Packet<T> {\n         // done with. Without this bounce, we can race with inherit_blocker\n         // about looking at and dealing with to_wake. Once we have acquired the\n         // lock, we are guaranteed that inherit_blocker is done.\n-        unsafe {\n+        {\n             let _guard = self.select_lock.lock();\n         }\n "}, {"sha": "06ab4f4427aa664a1e5c8b1edfc7c4bc903bcabf", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -32,7 +32,7 @@ use rustrt::task::{Task, BlockedTask};\n use rustrt::thread::Thread;\n \n use sync::atomic;\n-use sync::spsc_queue as spsc;\n+use comm::spsc_queue as spsc;\n use comm::Receiver;\n \n const DISCONNECTED: int = int::MIN;"}, {"sha": "160365dac361223453acc70d19c9b4790edece75", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -225,8 +225,8 @@ pub mod dl {\n     }\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n-        use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        use sync::{StaticMutex, MUTEX_INIT};\n+        static LOCK: StaticMutex = MUTEX_INIT;\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence"}, {"sha": "d4274d7e4017e2a1b8dd9a461957f57099dc339a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -106,7 +106,7 @@\n #![allow(unknown_features)]\n #![feature(macro_rules, globs, linkage)]\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n-#![feature(import_shadowing, slicing_syntax)]\n+#![feature(import_shadowing, slicing_syntax, tuple_indexing)]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "a8adfec34ed683c48ed07f56e5244e4d14d4bd10", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -209,14 +209,12 @@ Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: || -> T) -> T {\n-    use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use sync::{StaticMutex, MUTEX_INIT};\n \n-    static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+    static LOCK: StaticMutex = MUTEX_INIT;\n \n-    unsafe {\n-        let _guard = LOCK.lock();\n-        f()\n-    }\n+    let _guard = LOCK.lock();\n+    f()\n }\n \n /// Returns a vector of (variable, value) pairs, for all the environment"}, {"sha": "159fc3080e836aba0adfbcb74a53d15e6c5a8233", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -238,7 +238,7 @@ mod imp {\n     use mem;\n     use option::{Some, None, Option};\n     use result::{Ok, Err};\n-    use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use sync::{StaticMutex, MUTEX_INIT};\n \n     /// As always - iOS on arm uses SjLj exceptions and\n     /// _Unwind_Backtrace is even not available there. Still,\n@@ -264,8 +264,8 @@ mod imp {\n         // while it doesn't requires lock for work as everything is\n         // local, it still displays much nicer backtraces when a\n         // couple of tasks panic simultaneously\n-        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        let _g = unsafe { LOCK.lock() };\n+        static LOCK: StaticMutex = MUTEX_INIT;\n+        let _g = LOCK.lock();\n \n         try!(writeln!(w, \"stack backtrace:\"));\n         // 100 lines should be enough\n@@ -297,8 +297,8 @@ mod imp {\n         // is semi-reasonable in terms of printing anyway, and we know that all\n         // I/O done here is blocking I/O, not green I/O, so we don't have to\n         // worry about this being a native vs green mutex.\n-        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        let _g = unsafe { LOCK.lock() };\n+        static LOCK: StaticMutex = MUTEX_INIT;\n+        let _g = LOCK.lock();\n \n         try!(writeln!(w, \"stack backtrace:\"));\n \n@@ -667,7 +667,7 @@ mod imp {\n     use option::{Some, None};\n     use path::Path;\n     use result::{Ok, Err};\n-    use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use sync::{StaticMutex, MUTEX_INIT};\n     use slice::SlicePrelude;\n     use str::StrPrelude;\n     use dynamic_lib::DynamicLibrary;\n@@ -928,8 +928,8 @@ mod imp {\n     pub fn write(w: &mut Writer) -> IoResult<()> {\n         // According to windows documentation, all dbghelp functions are\n         // single-threaded.\n-        static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-        let _g = unsafe { LOCK.lock() };\n+        static LOCK: StaticMutex = MUTEX_INIT;\n+        let _g = LOCK.lock();\n \n         // Open up dbghelp.dll, we don't link to it explicitly because it can't\n         // always be found. Additionally, it's nice having fewer dependencies."}, {"sha": "0fdd57b27922c50d5e9068eb8a20bc413e1f45cb", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -143,8 +143,14 @@ impl Condvar {\n     ///\n     /// Like `wait`, the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n-    pub fn wait_timeout<T: AsMutexGuard>(&self, mutex_guard: &T,\n-                                         dur: Duration) -> bool {\n+    // Note that this method is *not* public, and this is quite intentional\n+    // because we're not quite sure about the semantics of relative vs absolute\n+    // durations or how the timing guarantees play into what the system APIs\n+    // provide. There are also additional concerns about the unix-specific\n+    // implementation which may need to be addressed.\n+    #[allow(dead_code)]\n+    fn wait_timeout<T: AsMutexGuard>(&self, mutex_guard: &T,\n+                                     dur: Duration) -> bool {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n             me.inner.wait_timeout(mutex_guard, dur)\n@@ -195,8 +201,9 @@ impl StaticCondvar {\n     /// specified duration.\n     ///\n     /// See `Condvar::wait_timeout`.\n-    pub fn wait_timeout<T: AsMutexGuard>(&'static self, mutex_guard: &T,\n-                                         dur: Duration) -> bool {\n+    #[allow(dead_code)] // may want to stabilize this later, see wait_timeout above\n+    fn wait_timeout<T: AsMutexGuard>(&'static self, mutex_guard: &T,\n+                                     dur: Duration) -> bool {\n         unsafe {\n             let lock = mutex_guard.as_mutex_guard();\n             let sys = mutex::guard_lock(lock);"}, {"sha": "4e07d54c57e7d6b79b20be42006e4492180b05d1", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -45,7 +45,7 @@ use sys_common::mutex as sys;\n /// let data = Arc::new(Mutex::new(0));\n ///\n /// let (tx, rx) = channel();\n-/// for _ in range(0, 10) {\n+/// for _ in range(0u, 10) {\n ///     let (data, tx) = (data.clone(), tx.clone());\n ///     spawn(proc() {\n ///         // The shared static can only be accessed once the lock is held."}, {"sha": "c0018c5d970421086eb86d70ad6ef17bf7f6254c", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -20,13 +20,14 @@\n //! can be created in the future and there must be no active timers at that\n //! time.\n \n+use prelude::*;\n+\n+use cell::UnsafeCell;\n use mem;\n use rustrt::bookkeeping;\n-use rustrt::mutex::StaticNativeMutex;\n use rustrt;\n-use cell::UnsafeCell;\n+use sync::{StaticMutex, StaticCondvar};\n use sys::helper_signal;\n-use prelude::*;\n \n use task;\n \n@@ -39,7 +40,8 @@ use task;\n /// is for static initialization.\n pub struct Helper<M> {\n     /// Internal lock which protects the remaining fields\n-    pub lock: StaticNativeMutex,\n+    pub lock: StaticMutex,\n+    pub cond: StaticCondvar,\n \n     // You'll notice that the remaining fields are UnsafeCell<T>, and this is\n     // because all helper thread operations are done through &self, but we need\n@@ -53,6 +55,9 @@ pub struct Helper<M> {\n \n     /// Flag if this helper thread has booted and been initialized yet.\n     pub initialized: UnsafeCell<bool>,\n+\n+    /// Flag if this helper thread has shut down\n+    pub shutdown: UnsafeCell<bool>,\n }\n \n impl<M: Send> Helper<M> {\n@@ -80,7 +85,9 @@ impl<M: Send> Helper<M> {\n                 task::spawn(proc() {\n                     bookkeeping::decrement();\n                     helper(receive, rx, t);\n-                    self.lock.lock().signal()\n+                    let _g = self.lock.lock();\n+                    *self.shutdown.get() = true;\n+                    self.cond.notify_one()\n                 });\n \n                 rustrt::at_exit(proc() { self.shutdown() });\n@@ -119,7 +126,9 @@ impl<M: Send> Helper<M> {\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n \n             // Wait for the child to exit\n-            guard.wait();\n+            while !*self.shutdown.get() {\n+                self.cond.wait(&guard);\n+            }\n             drop(guard);\n \n             // Clean up after ourselves"}, {"sha": "ddc6dd021c30f7b178b2e7623e70639a6dc5b3c3", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -16,13 +16,13 @@ use libc::{mod, c_char, c_int};\n use mem;\n use num::Int;\n use ptr::{mod, null, null_mut};\n-use rustrt::mutex;\n use io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n use io::net::addrinfo;\n use io::{IoResult, IoError};\n use sys::{mod, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n           wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n           decode_error_detailed};\n+use sync::{Mutex, MutexGuard};\n use sys_common::{mod, keep_going, short_write, timeout};\n use prelude::*;\n use cmp;\n@@ -557,12 +557,12 @@ struct Inner {\n \n     // Unused on Linux, where this lock is not necessary.\n     #[allow(dead_code)]\n-    lock: mutex::NativeMutex\n+    lock: Mutex<()>,\n }\n \n impl Inner {\n     fn new(fd: sock_t) -> Inner {\n-        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+        Inner { fd: fd, lock: Mutex::new(()) }\n     }\n }\n \n@@ -572,7 +572,7 @@ impl Drop for Inner {\n \n pub struct Guard<'a> {\n     pub fd: sock_t,\n-    pub guard: mutex::LockGuard<'a>,\n+    pub guard: MutexGuard<'a, ()>,\n }\n \n #[unsafe_destructor]\n@@ -666,7 +666,7 @@ impl TcpStream {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: unsafe { self.inner.lock.lock() },\n+            guard: self.inner.lock.lock(),\n         };\n         assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret\n@@ -805,7 +805,7 @@ impl UdpSocket {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: unsafe { self.inner.lock.lock() },\n+            guard: self.inner.lock.lock(),\n         };\n         assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret"}, {"sha": "4effedbe3abd83635f0107bc2988572d74b25ee4", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -25,10 +25,12 @@ use sys_common::mkerr_libc;\n \n macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n     static $name: Helper<$m> = Helper {\n-        lock: ::rustrt::mutex::NATIVE_MUTEX_INIT,\n+        lock: ::sync::MUTEX_INIT,\n+        cond: ::sync::CONDVAR_INIT,\n         chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n         signal: ::cell::UnsafeCell { value: 0 },\n         initialized: ::cell::UnsafeCell { value: false },\n+        shutdown: ::cell::UnsafeCell { value: false },\n     };\n ) )\n "}, {"sha": "08e6f7059d8c678c4d843f2faa1a3af3366b6ea0", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -12,8 +12,7 @@ use alloc::arc::Arc;\n use libc;\n use c_str::CString;\n use mem;\n-use rustrt::mutex;\n-use sync::atomic;\n+use sync::{atomic, Mutex};\n use io::{mod, IoResult, IoError};\n use prelude::*;\n \n@@ -60,12 +59,12 @@ struct Inner {\n \n     // Unused on Linux, where this lock is not necessary.\n     #[allow(dead_code)]\n-    lock: mutex::NativeMutex\n+    lock: Mutex<()>,\n }\n \n impl Inner {\n     fn new(fd: fd_t) -> Inner {\n-        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+        Inner { fd: fd, lock: Mutex::new(()) }\n     }\n }\n "}, {"sha": "9fce308cb9468cad60def633aa6a3825ff412858", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -26,10 +26,12 @@ use sync::{Once, ONCE_INIT};\n \n macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n     static $name: Helper<$m> = Helper {\n-        lock: ::rustrt::mutex::NATIVE_MUTEX_INIT,\n+        lock: ::sync::MUTEX_INIT,\n+        cond: ::sync::CONDVAR_INIT,\n         chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n         signal: ::cell::UnsafeCell { value: 0 },\n         initialized: ::cell::UnsafeCell { value: false },\n+        shutdown: ::cell::UnsafeCell { value: false },\n     };\n ) )\n "}, {"sha": "ddd89070ed53d56ecff1c531f998a4d0022310d5", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::*;\n+\n use sync::atomic;\n use alloc::{mod, heap};\n \n@@ -21,8 +23,8 @@ pub struct Mutex { inner: atomic::AtomicUint }\n pub const MUTEX_INIT: Mutex = Mutex { inner: atomic::INIT_ATOMIC_UINT };\n \n #[inline]\n-pub unsafe fn raw(m: &super::Mutex) -> ffi::LPCRITICAL_SECTION {\n-    m.0.get()\n+pub unsafe fn raw(m: &Mutex) -> ffi::LPCRITICAL_SECTION {\n+    m.get()\n }\n \n impl Mutex {"}, {"sha": "bf658d0efd0290bd15345070f4e2f3cbbbd924b8", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -89,8 +89,7 @@ use libc;\n use c_str::CString;\n use mem;\n use ptr;\n-use sync::atomic;\n-use rustrt::mutex;\n+use sync::{atomic, Mutex};\n use io::{mod, IoError, IoResult};\n use prelude::*;\n \n@@ -126,7 +125,7 @@ impl Drop for Event {\n \n struct Inner {\n     handle: libc::HANDLE,\n-    lock: mutex::NativeMutex,\n+    lock: Mutex<()>,\n     read_closed: atomic::AtomicBool,\n     write_closed: atomic::AtomicBool,\n }\n@@ -135,7 +134,7 @@ impl Inner {\n     fn new(handle: libc::HANDLE) -> Inner {\n         Inner {\n             handle: handle,\n-            lock: unsafe { mutex::NativeMutex::new() },\n+            lock: Mutex::new(()),\n             read_closed: atomic::AtomicBool::new(false),\n             write_closed: atomic::AtomicBool::new(false),\n         }"}, {"sha": "863c3c879a7c108009e14604233c2dddfd962168", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3adbd34c4e637d20a184eb03f09b30c69de8b6e/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=c3adbd34c4e637d20a184eb03f09b30c69de8b6e", "patch": "@@ -19,28 +19,30 @@\n // ignore-lexer-test FIXME #15679\n \n use std::os;\n-use std::sync::{Arc, Future, Mutex};\n+use std::sync::{Arc, Future, Mutex, Condvar};\n use std::time::Duration;\n use std::uint;\n \n // A poor man's pipe.\n-type pipe = Arc<Mutex<Vec<uint>>>;\n+type pipe = Arc<(Mutex<Vec<uint>>, Condvar)>;\n \n fn send(p: &pipe, msg: uint) {\n-    let mut arr = p.lock();\n+    let &(ref lock, ref cond) = &**p;\n+    let mut arr = lock.lock();\n     arr.push(msg);\n-    arr.cond.signal();\n+    cond.notify_one();\n }\n fn recv(p: &pipe) -> uint {\n-    let mut arr = p.lock();\n+    let &(ref lock, ref cond) = &**p;\n+    let mut arr = lock.lock();\n     while arr.is_empty() {\n-        arr.cond.wait();\n+        cond.wait(&arr);\n     }\n     arr.pop().unwrap()\n }\n \n fn init() -> (pipe,pipe) {\n-    let m = Arc::new(Mutex::new(Vec::new()));\n+    let m = Arc::new((Mutex::new(Vec::new()), Condvar::new()));\n     ((&m).clone(), m)\n }\n "}, {"sha": "03066d40512f3cec8b91fb6af081ec0f870cd039", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/71d4e77db8ad4b6d821da7e5d5300134ac95974e/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d4e77db8ad4b6d821da7e5d5300134ac95974e/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=71d4e77db8ad4b6d821da7e5d5300134ac95974e", "patch": "@@ -1,113 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This test creates a bunch of tasks that simultaneously send to each\n-// other in a ring. The messages should all be basically\n-// independent.\n-// This is like msgsend-ring-pipes but adapted to use Arcs.\n-\n-// This also serves as a pipes test, because Arcs are implemented with pipes.\n-\n-// no-pretty-expanded FIXME #15189\n-// ignore-lexer-test FIXME #15679\n-\n-use std::os;\n-use std::sync::{RWLock, Arc, Future};\n-use std::time::Duration;\n-use std::uint;\n-\n-// A poor man's pipe.\n-type pipe = Arc<RWLock<Vec<uint>>>;\n-\n-fn send(p: &pipe, msg: uint) {\n-    let mut arr = p.write();\n-    arr.push(msg);\n-    arr.cond.signal();\n-}\n-fn recv(p: &pipe) -> uint {\n-    let mut arr = p.write();\n-    while arr.is_empty() {\n-        arr.cond.wait();\n-    }\n-    arr.pop().unwrap()\n-}\n-\n-fn init() -> (pipe,pipe) {\n-    let x = Arc::new(RWLock::new(Vec::new()));\n-    ((&x).clone(), x)\n-}\n-\n-\n-fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n-    let mut num_chan = Some(num_chan);\n-    let mut num_port = Some(num_port);\n-    // Send/Receive lots of messages.\n-    for j in range(0u, count) {\n-        //println!(\"task %?, iter %?\", i, j);\n-        let num_chan2 = num_chan.take().unwrap();\n-        let num_port2 = num_port.take().unwrap();\n-        send(&num_chan2, i * j);\n-        num_chan = Some(num_chan2);\n-        let _n = recv(&num_port2);\n-        //log(error, _n);\n-        num_port = Some(num_port2);\n-    };\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        vec!(\"\".to_string(), \"100\".to_string(), \"10000\".to_string())\n-    } else if args.len() <= 1u {\n-        vec!(\"\".to_string(), \"10\".to_string(), \"100\".to_string())\n-    } else {\n-        args.clone().into_iter().collect()\n-    };\n-\n-    let num_tasks = from_str::<uint>(args[1].as_slice()).unwrap();\n-    let msg_per_task = from_str::<uint>(args[2].as_slice()).unwrap();\n-\n-    let (mut num_chan, num_port) = init();\n-\n-    let mut p = Some((num_chan, num_port));\n-    let dur = Duration::span(|| {\n-        let (mut num_chan, num_port) = p.take().unwrap();\n-\n-        // create the ring\n-        let mut futures = Vec::new();\n-\n-        for i in range(1u, num_tasks) {\n-            //println!(\"spawning %?\", i);\n-            let (new_chan, num_port) = init();\n-            let num_chan_2 = num_chan.clone();\n-            let new_future = Future::spawn(proc() {\n-                thread_ring(i, msg_per_task, num_chan_2, num_port)\n-            });\n-            futures.push(new_future);\n-            num_chan = new_chan;\n-        };\n-\n-        // do our iteration\n-        thread_ring(0, msg_per_task, num_chan, num_port);\n-\n-        // synchronize\n-        for f in futures.iter_mut() {\n-            let _ = f.get();\n-        }\n-    });\n-\n-    // all done, report stats.\n-    let num_msgs = num_tasks * msg_per_task;\n-    let rate = (num_msgs as f64) / (dur.num_milliseconds() as f64);\n-\n-    println!(\"Sent {} messages in {} ms\", num_msgs, dur.num_milliseconds());\n-    println!(\"  {} messages / second\", rate / 1000.0);\n-    println!(\"  {} \u03bcs / message\", 1000000. / rate / 1000.0);\n-}"}]}