{"sha": "627515a7ff4fe12084d7e95969bda307849b4d0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNzUxNWE3ZmY0ZmUxMjA4NGQ3ZTk1OTY5YmRhMzA3ODQ5YjRkMGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-04T02:09:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-10T17:28:48Z"}, "message": "std: Push Child's exit status to sys::process\n\nOn Unix we have to be careful to not call `waitpid` twice, but we don't have to\nbe careful on Windows due to the way process handles work there. As a result the\ncached `Option<ExitStatus>` is only necessary on Unix, and it's also just an\nimplementation detail of the Unix module.\n\nAt the same time. also update some code in `kill` on Unix to avoid a wonky\nwaitpid with WNOHANG. This was added in 0e190b9a to solve #13124, but the\n`signal(0)` method is not supported any more so there's no need to for this\nworkaround. I believe that this is no longer necessary as it's not really doing\nanything.", "tree": {"sha": "afbfe3723becc8e32d58cf7668fb066a063b8daf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afbfe3723becc8e32d58cf7668fb066a063b8daf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/627515a7ff4fe12084d7e95969bda307849b4d0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/627515a7ff4fe12084d7e95969bda307849b4d0e", "html_url": "https://github.com/rust-lang/rust/commit/627515a7ff4fe12084d7e95969bda307849b4d0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/627515a7ff4fe12084d7e95969bda307849b4d0e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1898db0f10f9641c7616e93499348d4fe743ddd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1898db0f10f9641c7616e93499348d4fe743ddd", "html_url": "https://github.com/rust-lang/rust/commit/b1898db0f10f9641c7616e93499348d4fe743ddd"}], "stats": {"total": 99, "additions": 30, "deletions": 69}, "files": [{"sha": "819643f20fe8109ac1aaa1d6e9e8a9e4778870f7", "filename": "src/libstd/process.rs", "status": "modified", "additions": 5, "deletions": 44, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/627515a7ff4fe12084d7e95969bda307849b4d0e/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627515a7ff4fe12084d7e95969bda307849b4d0e/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=627515a7ff4fe12084d7e95969bda307849b4d0e", "patch": "@@ -11,15 +11,14 @@\n //! Working with processes.\n \n #![stable(feature = \"process\", since = \"1.0.0\")]\n-#![allow(non_upper_case_globals)]\n \n use prelude::v1::*;\n use io::prelude::*;\n \n use ffi::OsStr;\n use fmt;\n-use io::{self, Error, ErrorKind};\n-use path;\n+use io;\n+use path::Path;\n use str;\n use sys::pipe::{self, AnonPipe};\n use sys::process as imp;\n@@ -61,9 +60,6 @@ use thread::{self, JoinHandle};\n pub struct Child {\n     handle: imp::Process,\n \n-    /// None until wait() or wait_with_output() is called.\n-    status: Option<imp::ExitStatus>,\n-\n     /// The handle for writing to the child's stdin, if it has been captured\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdin: Option<ChildStdin>,\n@@ -243,7 +239,7 @@ impl Command {\n \n     /// Sets the working directory for the child process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn current_dir<P: AsRef<path::Path>>(&mut self, dir: P) -> &mut Command {\n+    pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command {\n         self.inner.cwd(dir.as_ref().as_ref());\n         self\n     }\n@@ -288,7 +284,6 @@ impl Command {\n             Err(e) => Err(e),\n             Ok(handle) => Ok(Child {\n                 handle: handle,\n-                status: None,\n                 stdin: our_stdin.map(|fd| ChildStdin { inner: fd }),\n                 stdout: our_stdout.map(|fd| ChildStdout { inner: fd }),\n                 stderr: our_stderr.map(|fd| ChildStderr { inner: fd }),\n@@ -508,34 +503,7 @@ impl Child {\n     /// SIGKILL on unix platforms.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn kill(&mut self) -> io::Result<()> {\n-        #[cfg(unix)] fn collect_status(p: &mut Child) {\n-            // On Linux (and possibly other unices), a process that has exited will\n-            // continue to accept signals because it is \"defunct\". The delivery of\n-            // signals will only fail once the child has been reaped. For this\n-            // reason, if the process hasn't exited yet, then we attempt to collect\n-            // their status with WNOHANG.\n-            if p.status.is_none() {\n-                match p.handle.try_wait() {\n-                    Some(status) => { p.status = Some(status); }\n-                    None => {}\n-                }\n-            }\n-        }\n-        #[cfg(windows)] fn collect_status(_p: &mut Child) {}\n-\n-        collect_status(self);\n-\n-        // if the process has finished, and therefore had waitpid called,\n-        // and we kill it, then on unix we might ending up killing a\n-        // newer process that happens to have the same (re-used) id\n-        if self.status.is_some() {\n-            return Err(Error::new(\n-                ErrorKind::InvalidInput,\n-                \"invalid argument: can't kill an exited process\",\n-            ))\n-        }\n-\n-        unsafe { self.handle.kill() }\n+        self.handle.kill()\n     }\n \n     /// Returns the OS-assigned process identifier associated with this child.\n@@ -555,14 +523,7 @@ impl Child {\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         drop(self.stdin.take());\n-        match self.status {\n-            Some(code) => Ok(ExitStatus(code)),\n-            None => {\n-                let status = try!(self.handle.wait());\n-                self.status = Some(status);\n-                Ok(ExitStatus(status))\n-            }\n-        }\n+        self.handle.wait().map(ExitStatus)\n     }\n \n     /// Simultaneously waits for the child to exit and collect all remaining"}, {"sha": "41b9b3ef126325ae1fe6d0ce201bd26a638099a8", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/627515a7ff4fe12084d7e95969bda307849b4d0e/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627515a7ff4fe12084d7e95969bda307849b4d0e/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=627515a7ff4fe12084d7e95969bda307849b4d0e", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_snake_case)]\n-\n use prelude::v1::*;\n use os::unix::prelude::*;\n \n@@ -271,7 +269,8 @@ impl fmt::Display for ExitStatus {\n \n /// The unique id of the process (this should never be negative).\n pub struct Process {\n-    pid: pid_t\n+    pid: pid_t,\n+    status: Option<ExitStatus>,\n }\n \n pub enum Stdio {\n@@ -285,11 +284,6 @@ pub type RawStdio = FileDesc;\n const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n \n impl Process {\n-    pub unsafe fn kill(&self) -> io::Result<()> {\n-        try!(cvt(libc::kill(self.pid, libc::SIGKILL)));\n-        Ok(())\n-    }\n-\n     pub fn spawn(cfg: &mut Command,\n                  in_fd: Stdio,\n                  out_fd: Stdio,\n@@ -324,7 +318,7 @@ impl Process {\n             }\n         };\n \n-        let p = Process{ pid: pid };\n+        let mut p = Process { pid: pid, status: None };\n         drop(output);\n         let mut bytes = [0; 8];\n \n@@ -516,22 +510,26 @@ impl Process {\n         self.pid as u32\n     }\n \n-    pub fn wait(&self) -> io::Result<ExitStatus> {\n-        let mut status = 0 as c_int;\n-        try!(cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) }));\n-        Ok(ExitStatus(status))\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        // If we've already waited on this process then the pid can be recycled\n+        // and used for another process, and we probably shouldn't be killing\n+        // random processes, so just return an error.\n+        if self.status.is_some() {\n+            Err(Error::new(ErrorKind::InvalidInput,\n+                           \"invalid argument: can't kill an exited process\"))\n+        } else {\n+            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n+        }\n     }\n \n-    pub fn try_wait(&self) -> Option<ExitStatus> {\n-        let mut status = 0 as c_int;\n-        match cvt_r(|| unsafe {\n-            libc::waitpid(self.pid, &mut status, libc::WNOHANG)\n-        }) {\n-            Ok(0) => None,\n-            Ok(n) if n == self.pid => Some(ExitStatus(status)),\n-            Ok(n) => panic!(\"unknown pid: {}\", n),\n-            Err(e) => panic!(\"unknown waitpid error: {}\", e),\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        if let Some(status) = self.status {\n+            return Ok(status)\n         }\n+        let mut status = 0 as c_int;\n+        try!(cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) }));\n+        self.status = Some(ExitStatus(status));\n+        Ok(ExitStatus(status))\n     }\n }\n "}, {"sha": "e5e4187d228e93343b37db59eb6dac8590403b63", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/627515a7ff4fe12084d7e95969bda307849b4d0e/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/627515a7ff4fe12084d7e95969bda307849b4d0e/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=627515a7ff4fe12084d7e95969bda307849b4d0e", "patch": "@@ -202,8 +202,10 @@ impl Process {\n         Ok(Process { handle: Handle::new(pi.hProcess) })\n     }\n \n-    pub unsafe fn kill(&self) -> io::Result<()> {\n-        try!(cvt(c::TerminateProcess(self.handle.raw(), 1)));\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        try!(cvt(unsafe {\n+            c::TerminateProcess(self.handle.raw(), 1)\n+        }));\n         Ok(())\n     }\n \n@@ -213,7 +215,7 @@ impl Process {\n         }\n     }\n \n-    pub fn wait(&self) -> io::Result<ExitStatus> {\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         unsafe {\n             let res = c::WaitForSingleObject(self.handle.raw(), c::INFINITE);\n             if res != c::WAIT_OBJECT_0 {"}]}