{"sha": "f216f1fc5357a03044b4245f728ea61b355a9221", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMTZmMWZjNTM1N2EwMzA0NGI0MjQ1ZjcyOGVhNjFiMzU1YTkyMjE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-11-24T20:21:53Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-11-27T12:00:31Z"}, "message": "Add examples for TcpListener struct", "tree": {"sha": "2a3f896638d034f3573a0b897dc7f7e8b494dad8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a3f896638d034f3573a0b897dc7f7e8b494dad8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f216f1fc5357a03044b4245f728ea61b355a9221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f216f1fc5357a03044b4245f728ea61b355a9221", "html_url": "https://github.com/rust-lang/rust/commit/f216f1fc5357a03044b4245f728ea61b355a9221", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f216f1fc5357a03044b4245f728ea61b355a9221/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29abe6f9e86829d55ba180a5957f203a64a96b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/29abe6f9e86829d55ba180a5957f203a64a96b65", "html_url": "https://github.com/rust-lang/rust/commit/29abe6f9e86829d55ba180a5957f203a64a96b65"}], "stats": {"total": 121, "additions": 118, "deletions": 3}, "files": [{"sha": "2e0ed1eb73ecd0f950ab3c5d707d99888cdc8f80", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 118, "deletions": 3, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f216f1fc5357a03044b4245f728ea61b355a9221/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f216f1fc5357a03044b4245f728ea61b355a9221/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=f216f1fc5357a03044b4245f728ea61b355a9221", "patch": "@@ -297,12 +297,30 @@ impl TcpListener {\n     ///\n     /// The address type can be any implementor of `ToSocketAddrs` trait. See\n     /// its documentation for concrete examples.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n         super::each_addr(addr, net_imp::TcpListener::bind).map(TcpListener)\n     }\n \n     /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpListener};\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n+    /// assert_eq!(listener.local_addr().unwrap(),\n+    ///            SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 8080)));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         self.0.socket_addr()\n@@ -313,6 +331,15 @@ impl TcpListener {\n     /// The returned `TcpListener` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n     /// connections and options set on one listener will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n+    /// let listener_clone = listener.try_clone().unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_clone(&self) -> io::Result<TcpListener> {\n         self.0.duplicate().map(TcpListener)\n@@ -323,6 +350,18 @@ impl TcpListener {\n     /// This function will block the calling thread until a new TCP connection\n     /// is established. When established, the corresponding `TcpStream` and the\n     /// remote peer's address will be returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n+    /// match listener.accept() {\n+    ///     Ok((_socket, addr)) => println!(\"new client: {:?}\", addr),\n+    ///     Err(e) => println!(\"couldn't get client: {:?}\", e),\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n         self.0.accept().map(|(a, b)| (TcpStream(a), b))\n@@ -331,8 +370,28 @@ impl TcpListener {\n     /// Returns an iterator over the connections being received on this\n     /// listener.\n     ///\n-    /// The returned iterator will never return `None` and will also not yield\n-    /// the peer's `SocketAddr` structure.\n+    /// The returned iterator will never return [`None`] and will also not yield\n+    /// the peer's [`SocketAddr`] structure.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    ///\n+    /// for stream in listener.incoming() {\n+    ///     match stream {\n+    ///         Ok(stream) => {\n+    ///             println!(\"new client!\");\n+    ///         }\n+    ///         Err(e) => { /* connection failed */ }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn incoming(&self) -> Incoming {\n         Incoming { listener: self }\n@@ -342,16 +401,35 @@ impl TcpListener {\n     ///\n     /// This value sets the time-to-live field that is used in every packet sent\n     /// from this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.set_ttl(100).expect(\"could not set TTL\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n         self.0.set_ttl(ttl)\n     }\n \n     /// Gets the value of the `IP_TTL` option for this socket.\n     ///\n-    /// For more information about this option, see [`set_ttl`][link].\n+    /// For more information about this option, see [`set_ttl()`][link].\n     ///\n     /// [link]: #method.set_ttl\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.set_ttl(100).expect(\"could not set TTL\");\n+    /// assert_eq!(listener.ttl().unwrap_or(0), 100);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn ttl(&self) -> io::Result<u32> {\n         self.0.ttl()\n@@ -365,6 +443,15 @@ impl TcpListener {\n     ///\n     /// If this is set to `false` then the socket can be used to send and\n     /// receive packets from an IPv4-mapped IPv6 address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.set_only_v6(true).expect(\"Cannot set to IPv6\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n         self.0.set_only_v6(only_v6)\n@@ -375,6 +462,16 @@ impl TcpListener {\n     /// For more information about this option, see [`set_only_v6`][link].\n     ///\n     /// [link]: #method.set_only_v6\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.set_only_v6(true).expect(\"Cannot set to IPv6\");\n+    /// assert_eq!(listener.only_v6().unwrap_or(false), true);\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn only_v6(&self) -> io::Result<bool> {\n         self.0.only_v6()\n@@ -385,6 +482,15 @@ impl TcpListener {\n     /// This will retrieve the stored error in the underlying socket, clearing\n     /// the field in the process. This can be useful for checking errors between\n     /// calls.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.take_error().expect(\"No error was expected\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -394,6 +500,15 @@ impl TcpListener {\n     ///\n     /// On Unix this corresponds to calling fcntl, and on Windows this\n     /// corresponds to calling ioctlsocket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::net::TcpListener;\n+    ///\n+    /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    /// listener.set_nonblocking(true).expect(\"Cannot set non-blocking\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)"}]}