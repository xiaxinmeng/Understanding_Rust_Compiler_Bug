{"sha": "0195f8d3751ed2c14c405686c41064c4c41baa39", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxOTVmOGQzNzUxZWQyYzE0YzQwNTY4NmM0MTA2NGM0YzQxYmFhMzk=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-03-30T02:53:48Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-03-30T03:39:42Z"}, "message": "Hide unnecessary reference to trait\n\nWhen the problem for a method not being found in its receiver is due to\narbitrary self-types, we don't want to mention importing or implementing\nthe trait, instead we suggest wrapping.", "tree": {"sha": "335a4d63ce882d4bbd3f452a4254168c00bbd74b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/335a4d63ce882d4bbd3f452a4254168c00bbd74b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0195f8d3751ed2c14c405686c41064c4c41baa39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0195f8d3751ed2c14c405686c41064c4c41baa39", "html_url": "https://github.com/rust-lang/rust/commit/0195f8d3751ed2c14c405686c41064c4c41baa39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0195f8d3751ed2c14c405686c41064c4c41baa39/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f2d8a018e4ff062032608a30615129230490b0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f2d8a018e4ff062032608a30615129230490b0d", "html_url": "https://github.com/rust-lang/rust/commit/6f2d8a018e4ff062032608a30615129230490b0d"}], "stats": {"total": 194, "additions": 98, "deletions": 96}, "files": [{"sha": "30d60514063d993b29f6c1de36075c9d8c288b89", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 16, "deletions": 80, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0195f8d3751ed2c14c405686c41064c4c41baa39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0195f8d3751ed2c14c405686c41064c4c41baa39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=0195f8d3751ed2c14c405686c41064c4c41baa39", "patch": "@@ -6,7 +6,7 @@ use crate::astconv::AstConv as _;\n use crate::check::cast;\n use crate::check::coercion::CoerceMany;\n use crate::check::fatally_break_rust;\n-use crate::check::method::{probe, MethodError, SelfSource};\n+use crate::check::method::SelfSource;\n use crate::check::report_unexpected_variant_res;\n use crate::check::BreakableCtxt;\n use crate::check::Diverges;\n@@ -30,7 +30,6 @@ use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder,\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -461,7 +460,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.resolve_lang_item_path(lang_item, expr.span, expr.hir_id).1\n     }\n \n-    fn check_expr_path(&self, qpath: &hir::QPath<'_>, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_path(\n+        &self,\n+        qpath: &'tcx hir::QPath<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n@@ -947,7 +950,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             Err(error) => {\n                 if segment.ident.name != kw::Empty {\n-                    self.report_extended_method_error(segment, span, args, rcvr_t, error);\n+                    if let Some(mut err) = self.report_method_error(\n+                        span,\n+                        rcvr_t,\n+                        segment.ident,\n+                        SelfSource::MethodCall(&args[0]),\n+                        error,\n+                        Some(args),\n+                    ) {\n+                        err.emit();\n+                    }\n                 }\n                 Err(())\n             }\n@@ -964,82 +976,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n-    fn report_extended_method_error(\n-        &self,\n-        segment: &hir::PathSegment<'_>,\n-        span: Span,\n-        args: &'tcx [hir::Expr<'tcx>],\n-        rcvr_t: Ty<'tcx>,\n-        error: MethodError<'tcx>,\n-    ) {\n-        let rcvr = &args[0];\n-        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, new_rcvr_t, pre: &str, post: &str| {\n-            if let Some(new_rcvr_t) = new_rcvr_t {\n-                if let Ok(pick) = self.lookup_probe(\n-                    span,\n-                    segment.ident,\n-                    new_rcvr_t,\n-                    rcvr,\n-                    probe::ProbeScope::AllTraits,\n-                ) {\n-                    debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n-                    // Make sure the method is defined for the *actual* receiver:\n-                    // we don't want to treat `Box<Self>` as a receiver if\n-                    // it only works because of an autoderef to `&self`\n-                    if pick.autoderefs == 0\n-                        // We don't want to suggest a container type when the missing method is\n-                        // `.clone()`, otherwise we'd suggest `Arc::new(foo).clone()`, which is\n-                        // far from what the user really wants.\n-                        && Some(pick.item.container.id()) != self.tcx.lang_items().clone_trait()\n-                    {\n-                        err.span_label(\n-                            pick.item.ident.span,\n-                            &format!(\"the method is available for `{}` here\", new_rcvr_t),\n-                        );\n-                        err.multipart_suggestion(\n-                            \"consider wrapping the receiver expression with the appropriate type\",\n-                            vec![\n-                                (rcvr.span.shrink_to_lo(), format!(\"{}({}\", pre, post)),\n-                                (rcvr.span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n-        };\n-\n-        if let Some(mut err) = self.report_method_error(\n-            span,\n-            rcvr_t,\n-            segment.ident,\n-            SelfSource::MethodCall(rcvr),\n-            error,\n-            Some(args),\n-        ) {\n-            if let ty::Adt(..) = rcvr_t.kind() {\n-                // Try alternative arbitrary self types that could fulfill this call.\n-                // FIXME: probe for all types that *could* be arbitrary self-types, not\n-                // just this list.\n-                for (rcvr_t, post) in &[\n-                    (rcvr_t, \"\"),\n-                    (self.tcx.mk_mut_ref(&ty::ReErased, rcvr_t), \"&mut \"),\n-                    (self.tcx.mk_imm_ref(&ty::ReErased, rcvr_t), \"&\"),\n-                ] {\n-                    for (rcvr_t, pre) in &[\n-                        (self.tcx.mk_lang_item(rcvr_t, LangItem::OwnedBox), \"Box::new\"),\n-                        (self.tcx.mk_lang_item(rcvr_t, LangItem::Pin), \"Pin::new\"),\n-                        (self.tcx.mk_diagnostic_item(rcvr_t, sym::Arc), \"Arc::new\"),\n-                        (self.tcx.mk_diagnostic_item(rcvr_t, sym::Rc), \"Rc::new\"),\n-                    ] {\n-                        try_alt_rcvr(&mut err, *rcvr_t, pre, post);\n-                    }\n-                }\n-            }\n-            err.emit();\n-        }\n-    }\n-\n     fn check_expr_cast(\n         &self,\n         e: &'tcx hir::Expr<'tcx>,"}, {"sha": "a7a412f06becc706a24d9f6c294162de27bc6f78", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0195f8d3751ed2c14c405686c41064c4c41baa39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0195f8d3751ed2c14c405686c41064c4c41baa39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=0195f8d3751ed2c14c405686c41064c4c41baa39", "patch": "@@ -905,12 +905,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Resolves an associated value path into a base type and associated constant, or method\n     /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n-    pub fn resolve_ty_and_res_ufcs<'b>(\n+    pub fn resolve_ty_and_res_ufcs(\n         &self,\n-        qpath: &'b QPath<'b>,\n+        qpath: &'tcx QPath<'tcx>,\n         hir_id: hir::HirId,\n         span: Span,\n-    ) -> (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]) {\n+    ) -> (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]) {\n         debug!(\"resolve_ty_and_res_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {"}, {"sha": "72eff009473a11b26b2c6d8ad6b4392cc0cc417a", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 78, "deletions": 9, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/0195f8d3751ed2c14c405686c41064c4c41baa39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0195f8d3751ed2c14c405686c41064c4c41baa39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0195f8d3751ed2c14c405686c41064c4c41baa39", "patch": "@@ -68,12 +68,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn report_method_error<'b>(\n+    pub fn report_method_error(\n         &self,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n-        source: SelfSource<'b>,\n+        source: SelfSource<'tcx>,\n         error: MethodError<'tcx>,\n         args: Option<&'tcx [hir::Expr<'tcx>]>,\n     ) -> Option<DiagnosticBuilder<'_>> {\n@@ -323,8 +323,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 err.span_suggestion(\n                                     lit.span,\n                                     &format!(\n-                                        \"you must specify a concrete type for \\\n-                                              this numeric value, like `{}`\",\n+                                        \"you must specify a concrete type for this numeric value, \\\n+                                         like `{}`\",\n                                         concrete_type\n                                     ),\n                                     format!(\"{}_{}\", snippet, concrete_type),\n@@ -975,17 +975,78 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_traits_to_import<'b>(\n+    fn suggest_traits_to_import(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n-        source: SelfSource<'b>,\n+        source: SelfSource<'tcx>,\n         valid_out_of_scope_traits: Vec<DefId>,\n         unsatisfied_predicates: &[(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)],\n     ) {\n-        if self.suggest_valid_traits(err, valid_out_of_scope_traits) {\n+        let mut alt_rcvr_sugg = false;\n+        if let SelfSource::MethodCall(rcvr) = source {\n+            info!(?span, ?item_name, ?rcvr_ty, ?rcvr);\n+            if let ty::Adt(..) = rcvr_ty.kind() {\n+                // Try alternative arbitrary self types that could fulfill this call.\n+                // FIXME: probe for all types that *could* be arbitrary self-types, not\n+                // just this list.\n+                for (rcvr_ty, post) in &[\n+                    (rcvr_ty, \"\"),\n+                    (self.tcx.mk_mut_ref(&ty::ReErased, rcvr_ty), \"&mut \"),\n+                    (self.tcx.mk_imm_ref(&ty::ReErased, rcvr_ty), \"&\"),\n+                ] {\n+                    for (rcvr_ty, pre) in &[\n+                        (self.tcx.mk_lang_item(rcvr_ty, LangItem::OwnedBox), \"Box::new\"),\n+                        (self.tcx.mk_lang_item(rcvr_ty, LangItem::Pin), \"Pin::new\"),\n+                        (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Arc), \"Arc::new\"),\n+                        (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Rc), \"Rc::new\"),\n+                    ] {\n+                        if let Some(new_rcvr_t) = *rcvr_ty {\n+                            if let Ok(pick) = self.lookup_probe(\n+                                span,\n+                                item_name,\n+                                new_rcvr_t,\n+                                rcvr,\n+                                crate::check::method::probe::ProbeScope::AllTraits,\n+                            ) {\n+                                debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n+                                // Make sure the method is defined for the *actual* receiver:\n+                                // we don't want to treat `Box<Self>` as a receiver if\n+                                // it only works because of an autoderef to `&self`\n+                                if pick.autoderefs == 0\n+                                    // We don't want to suggest a container type when the missing method is\n+                                    // `.clone()`, otherwise we'd suggest `Arc::new(foo).clone()`, which is\n+                                    // far from what the user really wants.\n+                                    && Some(pick.item.container.id()) != self.tcx.lang_items().clone_trait()\n+                                {\n+                                    err.span_label(\n+                                        pick.item.ident.span,\n+                                        &format!(\n+                                            \"the method is available for `{}` here\",\n+                                            new_rcvr_t\n+                                        ),\n+                                    );\n+                                    err.multipart_suggestion(\n+                                        \"consider wrapping the receiver expression with the \\\n+                                         appropriate type\",\n+                                        vec![\n+                                            (rcvr.span.shrink_to_lo(), format!(\"{}({}\", pre, post)),\n+                                            (rcvr.span.shrink_to_hi(), \")\".to_string()),\n+                                        ],\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                    // We don't care about the other suggestions.\n+                                    alt_rcvr_sugg = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if !alt_rcvr_sugg && self.suggest_valid_traits(err, valid_out_of_scope_traits) {\n             return;\n         }\n \n@@ -1075,6 +1136,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 \"the method might not be found because of this arbitrary self type\",\n             );\n         }\n+        if alt_rcvr_sugg {\n+            return;\n+        }\n \n         if !candidates.is_empty() {\n             // Sort from most relevant to least relevant.\n@@ -1284,7 +1348,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Checks whether there is a local type somewhere in the chain of\n     /// autoderefs of `rcvr_ty`.\n-    fn type_derefs_to_local(&self, span: Span, rcvr_ty: Ty<'tcx>, source: SelfSource<'_>) -> bool {\n+    fn type_derefs_to_local(\n+        &self,\n+        span: Span,\n+        rcvr_ty: Ty<'tcx>,\n+        source: SelfSource<'tcx>,\n+    ) -> bool {\n         fn is_local(ty: Ty<'_>) -> bool {\n             match ty.kind() {\n                 ty::Adt(def, _) => def.did.is_local(),\n@@ -1310,7 +1379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum SelfSource<'a> {\n     QPath(&'a hir::Ty<'a>),\n     MethodCall(&'a hir::Expr<'a> /* rcvr */),"}, {"sha": "53593b9bab4b82a184704ebbc1c2d611e91e1109", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0195f8d3751ed2c14c405686c41064c4c41baa39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0195f8d3751ed2c14c405686c41064c4c41baa39/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=0195f8d3751ed2c14c405686c41064c4c41baa39", "patch": "@@ -861,7 +861,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_tuple_struct(\n         &self,\n         pat: &'tcx Pat<'tcx>,\n-        qpath: &hir::QPath<'_>,\n+        qpath: &'tcx hir::QPath<'tcx>,\n         subpats: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,"}, {"sha": "0756a4d59c19b1fe3d19f16d72d540a7bb1d9e70", "filename": "src/test/ui/async-await/pin-needed-to-poll.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0195f8d3751ed2c14c405686c41064c4c41baa39/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0195f8d3751ed2c14c405686c41064c4c41baa39/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr?ref=0195f8d3751ed2c14c405686c41064c4c41baa39", "patch": "@@ -12,9 +12,6 @@ LL |         self.sleep.poll(cx)\n LL |     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n    |        ---- the method is available for `Pin<&mut Sleep>` here\n    |\n-   = help: items from traits can only be used if the trait is implemented and in scope\n-   = note: the following trait defines an item `poll`, perhaps you need to implement it:\n-           candidate #1: `Future`\n help: consider wrapping the receiver expression with the appropriate type\n    |\n LL |         Pin::new(&mut self.sleep).poll(cx)"}]}