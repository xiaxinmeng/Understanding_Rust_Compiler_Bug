{"sha": "944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NGZmYmY1YjU1MGI0ZTZlMmZhNTA5ZDU5YWUxYWU1ZDcyZDEwZWE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-07T17:54:29Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-07T17:54:29Z"}, "message": "initialize unsized locals when copying to the for the first time", "tree": {"sha": "e39cd381adc851403089e32ba84c6bf023722a9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e39cd381adc851403089e32ba84c6bf023722a9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea", "html_url": "https://github.com/rust-lang/rust/commit/944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae1f8ab4aa6775ae589929a0921f794b1d31c161", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae1f8ab4aa6775ae589929a0921f794b1d31c161", "html_url": "https://github.com/rust-lang/rust/commit/ae1f8ab4aa6775ae589929a0921f794b1d31c161"}], "stats": {"total": 90, "additions": 57, "deletions": 33}, "files": [{"sha": "7c900bd596ac8ab737962ff97ef40e7ca5a9040e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea", "patch": "@@ -702,10 +702,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n                     LocalValue::Dead => write!(msg, \" is dead\").unwrap(),\n                     LocalValue::Uninitialized => write!(msg, \" is uninitialized\").unwrap(),\n                     LocalValue::Live(Operand::Indirect(mplace)) => {\n-                        let (ptr, align) = mplace.to_scalar_ptr_align();\n-                        match ptr {\n+                        match mplace.ptr {\n                             Scalar::Ptr(ptr) => {\n-                                write!(msg, \" by align({}) ref:\", align.bytes()).unwrap();\n+                                write!(msg, \" by align({}){} ref:\",\n+                                    mplace.align.bytes(),\n+                                    match mplace.meta {\n+                                        Some(meta) => format!(\" meta({:?})\", meta),\n+                                        None => String::new()\n+                                    }\n+                                ).unwrap();\n                                 allocs.push(ptr.alloc_id);\n                             }\n                             ptr => write!(msg, \" by integral ref: {:?}\", ptr).unwrap(),"}, {"sha": "93bef813ba691803df88f72b198048782bb333f0", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=944ffbf5b550b4e6e2fa509d59ae1ae5d72d10ea", "patch": "@@ -826,8 +826,6 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        debug_assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n-            \"Cannot copy unsized data\");\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n         assert!(src.layout.details == dest.layout.details,\n@@ -836,6 +834,7 @@ where\n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n         let src = match self.try_read_immediate(src)? {\n             Ok(src_val) => {\n+                assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n                 // Yay, we got a value that we can write directly.\n                 // FIXME: Add a check to make sure that if `src` is indirect,\n                 // it does not overlap with `dest`.\n@@ -846,13 +845,19 @@ where\n         // Slow path, this does not fit into an immediate. Just memcpy.\n         trace!(\"copy_op: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n-        let dest = self.force_allocation(dest)?;\n-        let (src_ptr, src_align) = src.to_scalar_ptr_align();\n-        let (dest_ptr, dest_align) = dest.to_scalar_ptr_align();\n+        // This interprets `src.meta` with the `dest` local's layout, if an unsized local\n+        // is being initialized!\n+        let (dest, size) = self.force_allocation_maybe_sized(dest, src.meta)?;\n+        let size = size.unwrap_or_else(|| {\n+            assert!(!dest.layout.is_unsized(),\n+                \"Cannot copy into already initialized unsized place\");\n+            dest.layout.size\n+        });\n+        assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n         self.memory.copy(\n-            src_ptr, src_align,\n-            dest_ptr, dest_align,\n-            dest.layout.size,\n+            src.ptr, src.align,\n+            dest.ptr, dest.align,\n+            size,\n             /*nonoverlapping*/ true,\n         )?;\n \n@@ -870,11 +875,13 @@ where\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }\n-        // We still require the sizes to match\n-        debug_assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n-            \"Cannot copy unsized data\");\n+        // We still require the sizes to match.\n         assert!(src.layout.size == dest.layout.size,\n             \"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+        // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want\n+        // to avoid that here.\n+        assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n+            \"Cannot transmute unsized data\");\n \n         // The hard case is `ScalarPair`.  `src` is already read from memory in this case,\n         // using `src.layout` to figure out which bytes to use for the 1st and 2nd field.\n@@ -902,11 +909,16 @@ where\n     /// If the place currently refers to a local that doesn't yet have a matching allocation,\n     /// create such an allocation.\n     /// This is essentially `force_to_memplace`.\n-    pub fn force_allocation(\n+    ///\n+    /// This supports unsized types and returnes the computed size to avoid some\n+    /// redundant computation when copying; use `force_allocation` for a simpler, sized-only\n+    /// version.\n+    pub fn force_allocation_maybe_sized(\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let mplace = match place.place {\n+        meta: Option<Scalar<M::PointerTag>>,\n+    ) -> EvalResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n+        let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n                 match self.stack[frame].locals[local].access_mut()? {\n                     Ok(local_val) => {\n@@ -926,44 +938,51 @@ where\n                         // We need the layout of the local.  We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n+                        // We also need to support unsized types, and hence cannot use `allocate`.\n                         let local_layout = self.layout_of_local(&self.stack[frame], local, None)?;\n-                        let ptr = self.allocate(local_layout, MemoryKind::Stack);\n+                        let (size, align) = self.size_and_align_of(meta, local_layout)?\n+                            .expect(\"Cannot allocate for non-dyn-sized type\");\n+                        let ptr = self.memory.allocate(size, align, MemoryKind::Stack);\n+                        let ptr = M::tag_new_allocation(self, ptr, MemoryKind::Stack);\n+                        let mplace = MemPlace { ptr: ptr.into(), align, meta };\n                         if let Some(value) = old_val {\n                             // Preserve old value.\n                             // We don't have to validate as we can assume the local\n                             // was already valid for its type.\n-                            self.write_immediate_to_mplace_no_validate(value, ptr)?;\n+                            let mplace = MPlaceTy { mplace, layout: local_layout };\n+                            self.write_immediate_to_mplace_no_validate(value, mplace)?;\n                         }\n-                        let mplace = ptr.mplace;\n                         // Now we can call `access_mut` again, asserting it goes well,\n                         // and actually overwrite things.\n                         *self.stack[frame].locals[local].access_mut().unwrap().unwrap() =\n                             LocalValue::Live(Operand::Indirect(mplace));\n-                        mplace\n+                        (mplace, Some(size))\n                     }\n-                    Err(mplace) => mplace, // this already was an indirect local\n+                    Err(mplace) => (mplace, None), // this already was an indirect local\n                 }\n             }\n-            Place::Ptr(mplace) => mplace\n+            Place::Ptr(mplace) => (mplace, None)\n         };\n         // Return with the original layout, so that the caller can go on\n-        Ok(MPlaceTy { mplace, layout: place.layout })\n+        Ok((MPlaceTy { mplace, layout: place.layout }, size))\n+    }\n+\n+    #[inline(always)]\n+    pub fn force_allocation(\n+        &mut self,\n+        place: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        Ok(self.force_allocation_maybe_sized(place, None)?.0)\n     }\n \n     pub fn allocate(\n         &mut self,\n         layout: TyLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n-        if layout.is_unsized() {\n-            assert!(self.tcx.features().unsized_locals, \"cannot alloc memory for unsized type\");\n-            // FIXME: What should we do here? We should definitely also tag!\n-            MPlaceTy::dangling(layout, self)\n-        } else {\n-            let ptr = self.memory.allocate(layout.size, layout.align.abi, kind);\n-            let ptr = M::tag_new_allocation(self, ptr, kind);\n-            MPlaceTy::from_aligned_ptr(ptr, layout)\n-        }\n+        let ptr = self.memory.allocate(layout.size, layout.align.abi, kind);\n+        let ptr = M::tag_new_allocation(self, ptr, kind);\n+        MPlaceTy::from_aligned_ptr(ptr, layout)\n     }\n \n     pub fn write_discriminant_index("}]}