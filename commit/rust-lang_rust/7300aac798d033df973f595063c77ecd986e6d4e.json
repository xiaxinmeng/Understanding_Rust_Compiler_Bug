{"sha": "7300aac798d033df973f595063c77ecd986e6d4e", "node_id": "C_kwDOAAsO6NoAKDczMDBhYWM3OThkMDMzZGY5NzNmNTk1MDYzYzc3ZWNkOTg2ZTZkNGU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-21T12:12:19Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-21T12:22:12Z"}, "message": "split libc tests from stdlib tests", "tree": {"sha": "8438183004b1d362489f59758c2d8fe862b79e17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8438183004b1d362489f59758c2d8fe862b79e17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7300aac798d033df973f595063c77ecd986e6d4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7300aac798d033df973f595063c77ecd986e6d4e", "html_url": "https://github.com/rust-lang/rust/commit/7300aac798d033df973f595063c77ecd986e6d4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7300aac798d033df973f595063c77ecd986e6d4e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a1edc3c061021a48ffbd149340d7ce059faa97c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a1edc3c061021a48ffbd149340d7ce059faa97c", "html_url": "https://github.com/rust-lang/rust/commit/9a1edc3c061021a48ffbd149340d7ce059faa97c"}], "stats": {"total": 296, "additions": 176, "deletions": 120}, "files": [{"sha": "f1838cf64f7feefbf5d5b0a01f7e8c5e3fe7fd9a", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs-with-isolation.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs?ref=7300aac798d033df973f595063c77ecd986e6d4e", "patch": "@@ -0,0 +1,28 @@\n+//@ignore-target-windows: no libc on Windows\n+//@compile-flags: -Zmiri-isolation-error=warn-nobacktrace\n+//@normalize-stderr-test: \"(stat(x)?)\" -> \"$$STAT\"\n+\n+use std::ffi::CString;\n+use std::fs;\n+use std::io::{Error, ErrorKind};\n+\n+fn main() {\n+    // test `fcntl`\n+    unsafe {\n+        assert_eq!(libc::fcntl(1, libc::F_DUPFD, 0), -1);\n+        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EPERM));\n+    }\n+\n+    // test `readlink`\n+    let symlink_c_str = CString::new(\"foo.txt\").unwrap();\n+    let mut buf = vec![0; \"foo_link.txt\".len() + 1];\n+    unsafe {\n+        assert_eq!(libc::readlink(symlink_c_str.as_ptr(), buf.as_mut_ptr(), buf.len()), -1);\n+        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+    }\n+\n+    // test `stat`\n+    assert_eq!(fs::metadata(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+    // check that it is the right kind of `PermissionDenied`\n+    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+}"}, {"sha": "21fcb65243e26160f321b44e3d2df0cad808ea17", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs-with-isolation.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.stderr?ref=7300aac798d033df973f595063c77ecd986e6d4e", "patch": "@@ -0,0 +1,6 @@\n+warning: `fcntl` was made to return an error due to isolation\n+\n+warning: `readlink` was made to return an error due to isolation\n+\n+warning: `$STAT` was made to return an error due to isolation\n+"}, {"sha": "acf16ecb7e06dff5c69ae9aa4624aa02f80c5d58", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs?ref=7300aac798d033df973f595063c77ecd986e6d4e", "patch": "@@ -0,0 +1,137 @@\n+//@ignore-target-windows: no libc on Windows\n+//@compile-flags: -Zmiri-disable-isolation\n+\n+#![feature(io_error_more)]\n+#![feature(io_error_uncategorized)]\n+\n+use std::convert::TryInto;\n+use std::ffi::CString;\n+use std::fs::{canonicalize, remove_file, File};\n+use std::io::{Error, ErrorKind, Write};\n+use std::os::unix::ffi::OsStrExt;\n+use std::path::PathBuf;\n+\n+fn main() {\n+    test_dup_stdout_stderr();\n+    test_canonicalize_too_long();\n+    test_readlink();\n+    test_file_open_unix_allow_two_args();\n+    test_file_open_unix_needs_three_args();\n+    test_file_open_unix_extra_third_arg();\n+}\n+\n+fn tmp() -> PathBuf {\n+    std::env::var(\"MIRI_TEMP\")\n+        .map(|tmp| {\n+            // MIRI_TEMP is set outside of our emulated\n+            // program, so it may have path separators that don't\n+            // correspond to our target platform. We normalize them here\n+            // before constructing a `PathBuf`\n+\n+            #[cfg(windows)]\n+            return PathBuf::from(tmp.replace(\"/\", \"\\\\\"));\n+\n+            #[cfg(not(windows))]\n+            return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n+        })\n+        .unwrap_or_else(|_| std::env::temp_dir())\n+}\n+\n+/// Prepare: compute filename and make sure the file does not exist.\n+fn prepare(filename: &str) -> PathBuf {\n+    let path = tmp().join(filename);\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+    path\n+}\n+\n+/// Prepare like above, and also write some initial content to the file.\n+fn prepare_with_content(filename: &str, content: &[u8]) -> PathBuf {\n+    let path = prepare(filename);\n+    let mut file = File::create(&path).unwrap();\n+    file.write(content).unwrap();\n+    path\n+}\n+\n+fn test_file_open_unix_allow_two_args() {\n+    let path = prepare_with_content(\"test_file_open_unix_allow_two_args.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY) };\n+}\n+\n+fn test_file_open_unix_needs_three_args() {\n+    let path = prepare_with_content(\"test_file_open_unix_needs_three_args.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_CREAT, 0o666) };\n+}\n+\n+fn test_file_open_unix_extra_third_arg() {\n+    let path = prepare_with_content(\"test_file_open_unix_extra_third_arg.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY, 42) };\n+}\n+\n+fn test_dup_stdout_stderr() {\n+    let bytes = b\"hello dup fd\\n\";\n+    unsafe {\n+        let new_stdout = libc::fcntl(1, libc::F_DUPFD, 0);\n+        let new_stderr = libc::fcntl(2, libc::F_DUPFD, 0);\n+        libc::write(new_stdout, bytes.as_ptr() as *const libc::c_void, bytes.len());\n+        libc::write(new_stderr, bytes.as_ptr() as *const libc::c_void, bytes.len());\n+    }\n+}\n+\n+fn test_canonicalize_too_long() {\n+    // Make sure we get an error for long paths.\n+    let too_long = \"x/\".repeat(libc::PATH_MAX.try_into().unwrap());\n+    assert!(canonicalize(too_long).is_err());\n+}\n+\n+fn test_readlink() {\n+    let bytes = b\"Hello, World!\\n\";\n+    let path = prepare_with_content(\"miri_test_fs_link_target.txt\", bytes);\n+    let expected_path = path.as_os_str().as_bytes();\n+\n+    let symlink_path = prepare(\"miri_test_fs_symlink.txt\");\n+    std::os::unix::fs::symlink(&path, &symlink_path).unwrap();\n+\n+    // Test that the expected string gets written to a buffer of proper\n+    // length, and that a trailing null byte is not written.\n+    let symlink_c_str = CString::new(symlink_path.as_os_str().as_bytes()).unwrap();\n+    let symlink_c_ptr = symlink_c_str.as_ptr();\n+\n+    // Make the buf one byte larger than it needs to be,\n+    // and check that the last byte is not overwritten.\n+    let mut large_buf = vec![0xFF; expected_path.len() + 1];\n+    let res =\n+        unsafe { libc::readlink(symlink_c_ptr, large_buf.as_mut_ptr().cast(), large_buf.len()) };\n+    // Check that the resovled path was properly written into the buf.\n+    assert_eq!(&large_buf[..(large_buf.len() - 1)], expected_path);\n+    assert_eq!(large_buf.last(), Some(&0xFF));\n+    assert_eq!(res, large_buf.len() as isize - 1);\n+\n+    // Test that the resolved path is truncated if the provided buffer\n+    // is too small.\n+    let mut small_buf = [0u8; 2];\n+    let res =\n+        unsafe { libc::readlink(symlink_c_ptr, small_buf.as_mut_ptr().cast(), small_buf.len()) };\n+    assert_eq!(small_buf, &expected_path[..small_buf.len()]);\n+    assert_eq!(res, small_buf.len() as isize);\n+\n+    // Test that we report a proper error for a missing path.\n+    let bad_path = CString::new(\"MIRI_MISSING_FILE_NAME\").unwrap();\n+    let res = unsafe {\n+        libc::readlink(bad_path.as_ptr(), small_buf.as_mut_ptr().cast(), small_buf.len())\n+    };\n+    assert_eq!(res, -1);\n+    assert_eq!(Error::last_os_error().kind(), ErrorKind::NotFound);\n+}"}, {"sha": "b6fa69e3d5d2e8c4626550dcb2c413f91dfcd156", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stderr?ref=7300aac798d033df973f595063c77ecd986e6d4e", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs.stderr"}, {"sha": "b6fa69e3d5d2e8c4626550dcb2c413f91dfcd156", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.stdout", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stdout?ref=7300aac798d033df973f595063c77ecd986e6d4e", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs.stdout"}, {"sha": "b6fa69e3d5d2e8c4626550dcb2c413f91dfcd156", "filename": "src/tools/miri/tests/pass-dep/shims/libc-rsfs.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-rsfs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-rsfs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-rsfs.stdout?ref=7300aac798d033df973f595063c77ecd986e6d4e", "patch": "@@ -0,0 +1 @@\n+hello dup fd"}, {"sha": "8fa683085b98bb6fc03cf65dd048a658082e2fb9", "filename": "src/tools/miri/tests/pass/shims/fs-with-isolation.rs", "status": "renamed", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.rs?ref=7300aac798d033df973f595063c77ecd986e6d4e", "patch": "@@ -2,21 +2,14 @@\n //@compile-flags: -Zmiri-isolation-error=warn-nobacktrace\n //@normalize-stderr-test: \"(stat(x)?)\" -> \"$$STAT\"\n \n-use std::ffi::CString;\n use std::fs::{self, File};\n-use std::io::{Error, ErrorKind};\n+use std::io::ErrorKind;\n use std::os::unix;\n \n fn main() {\n     // test `open`\n     assert_eq!(File::create(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n \n-    // test `fcntl`\n-    unsafe {\n-        assert_eq!(libc::fcntl(1, libc::F_DUPFD, 0), -1);\n-        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EPERM));\n-    }\n-\n     // test `unlink`\n     assert_eq!(fs::remove_file(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n \n@@ -26,17 +19,8 @@ fn main() {\n         ErrorKind::PermissionDenied\n     );\n \n-    // test `readlink`\n-    let symlink_c_str = CString::new(\"foo.txt\").unwrap();\n-    let mut buf = vec![0; \"foo_link.txt\".len() + 1];\n-    unsafe {\n-        assert_eq!(libc::readlink(symlink_c_str.as_ptr(), buf.as_mut_ptr(), buf.len()), -1);\n-        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n-    }\n-\n     // test `stat`\n     assert_eq!(fs::metadata(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n-    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n \n     // test `rename`\n     assert_eq!(fs::rename(\"a.txt\", \"b.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n@@ -49,5 +33,4 @@ fn main() {\n \n     // test `opendir`\n     assert_eq!(fs::read_dir(\"foo/bar\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n-    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n }", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs_with_isolation.rs"}, {"sha": "452c5b9b772aa6ad3720957df9eb17dce9ca0849", "filename": "src/tools/miri/tests/pass/shims/fs-with-isolation.stderr", "status": "renamed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.stderr?ref=7300aac798d033df973f595063c77ecd986e6d4e", "patch": "@@ -1,13 +1,9 @@\n warning: `open` was made to return an error due to isolation\n \n-warning: `fcntl` was made to return an error due to isolation\n-\n warning: `unlink` was made to return an error due to isolation\n \n warning: `symlink` was made to return an error due to isolation\n \n-warning: `readlink` was made to return an error due to isolation\n-\n warning: `$STAT` was made to return an error due to isolation\n \n warning: `rename` was made to return an error due to isolation", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs_with_isolation.stderr"}, {"sha": "1758e486ac3f5ba093180c80fa8f1b08ec985d43", "filename": "src/tools/miri/tests/pass/shims/fs.rs", "status": "renamed", "additions": 3, "deletions": 98, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7300aac798d033df973f595063c77ecd986e6d4e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs?ref=7300aac798d033df973f595063c77ecd986e6d4e", "patch": "@@ -5,10 +5,10 @@\n #![feature(io_error_uncategorized)]\n \n use std::collections::HashMap;\n-use std::ffi::{CString, OsString};\n+use std::ffi::OsString;\n use std::fs::{\n-    create_dir, read_dir, read_link, remove_dir, remove_dir_all, remove_file, rename, File,\n-    OpenOptions,\n+    canonicalize, create_dir, read_dir, read_link, remove_dir, remove_dir_all, remove_file, rename,\n+    File, OpenOptions,\n };\n use std::io::{Error, ErrorKind, Read, Result, Seek, SeekFrom, Write};\n use std::path::{Path, PathBuf};\n@@ -26,13 +26,7 @@ fn main() {\n     test_rename();\n     test_directory();\n     test_canonicalize();\n-    test_dup_stdout_stderr();\n     test_from_raw_os_error();\n-\n-    // These all require unix, if the test is changed to no longer `ignore-windows`, move these to a unix test\n-    test_file_open_unix_allow_two_args();\n-    test_file_open_unix_needs_three_args();\n-    test_file_open_unix_extra_third_arg();\n }\n \n fn tmp() -> PathBuf {\n@@ -101,39 +95,6 @@ fn test_file() {\n     remove_file(&path).unwrap();\n }\n \n-fn test_file_open_unix_allow_two_args() {\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let path = prepare_with_content(\"test_file_open_unix_allow_two_args.txt\", &[]);\n-\n-    let mut name = path.into_os_string();\n-    name.push(\"\\0\");\n-    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY) };\n-}\n-\n-fn test_file_open_unix_needs_three_args() {\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let path = prepare_with_content(\"test_file_open_unix_needs_three_args.txt\", &[]);\n-\n-    let mut name = path.into_os_string();\n-    name.push(\"\\0\");\n-    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_CREAT, 0o666) };\n-}\n-\n-fn test_file_open_unix_extra_third_arg() {\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let path = prepare_with_content(\"test_file_open_unix_extra_third_arg.txt\", &[]);\n-\n-    let mut name = path.into_os_string();\n-    name.push(\"\\0\");\n-    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY, 42) };\n-}\n-\n fn test_file_clone() {\n     let bytes = b\"Hello, World!\\n\";\n     let path = prepare_with_content(\"miri_test_fs_file_clone.txt\", bytes);\n@@ -279,46 +240,6 @@ fn test_symlink() {\n     symlink_file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n \n-    #[cfg(unix)]\n-    {\n-        use std::os::unix::ffi::OsStrExt;\n-\n-        let expected_path = path.as_os_str().as_bytes();\n-\n-        // Test that the expected string gets written to a buffer of proper\n-        // length, and that a trailing null byte is not written.\n-        let symlink_c_str = CString::new(symlink_path.as_os_str().as_bytes()).unwrap();\n-        let symlink_c_ptr = symlink_c_str.as_ptr();\n-\n-        // Make the buf one byte larger than it needs to be,\n-        // and check that the last byte is not overwritten.\n-        let mut large_buf = vec![0xFF; expected_path.len() + 1];\n-        let res = unsafe {\n-            libc::readlink(symlink_c_ptr, large_buf.as_mut_ptr().cast(), large_buf.len())\n-        };\n-        // Check that the resovled path was properly written into the buf.\n-        assert_eq!(&large_buf[..(large_buf.len() - 1)], expected_path);\n-        assert_eq!(large_buf.last(), Some(&0xFF));\n-        assert_eq!(res, large_buf.len() as isize - 1);\n-\n-        // Test that the resolved path is truncated if the provided buffer\n-        // is too small.\n-        let mut small_buf = [0u8; 2];\n-        let res = unsafe {\n-            libc::readlink(symlink_c_ptr, small_buf.as_mut_ptr().cast(), small_buf.len())\n-        };\n-        assert_eq!(small_buf, &expected_path[..small_buf.len()]);\n-        assert_eq!(res, small_buf.len() as isize);\n-\n-        // Test that we report a proper error for a missing path.\n-        let bad_path = CString::new(\"MIRI_MISSING_FILE_NAME\").unwrap();\n-        let res = unsafe {\n-            libc::readlink(bad_path.as_ptr(), small_buf.as_mut_ptr().cast(), small_buf.len())\n-        };\n-        assert_eq!(res, -1);\n-        assert_eq!(Error::last_os_error().kind(), ErrorKind::NotFound);\n-    }\n-\n     // Test that metadata of a symbolic link (i.e., the file it points to) is correct.\n     check_metadata(bytes, &symlink_path).unwrap();\n     // Test that the metadata of a symbolic link is correct when not following it.\n@@ -369,7 +290,6 @@ fn test_rename() {\n }\n \n fn test_canonicalize() {\n-    use std::fs::canonicalize;\n     let dir_path = prepare_dir(\"miri_test_fs_dir\");\n     create_dir(&dir_path).unwrap();\n     let path = dir_path.join(\"test_file\");\n@@ -379,11 +299,6 @@ fn test_canonicalize() {\n     assert_eq!(p.to_string_lossy().find('.'), None);\n \n     remove_dir_all(&dir_path).unwrap();\n-\n-    // Make sure we get an error for long paths.\n-    use std::convert::TryInto;\n-    let too_long = \"x/\".repeat(libc::PATH_MAX.try_into().unwrap());\n-    assert!(canonicalize(too_long).is_err());\n }\n \n fn test_directory() {\n@@ -440,16 +355,6 @@ fn test_directory() {\n     remove_dir_all(&dir_path).unwrap();\n }\n \n-fn test_dup_stdout_stderr() {\n-    let bytes = b\"hello dup fd\\n\";\n-    unsafe {\n-        let new_stdout = libc::fcntl(1, libc::F_DUPFD, 0);\n-        let new_stderr = libc::fcntl(2, libc::F_DUPFD, 0);\n-        libc::write(new_stdout, bytes.as_ptr() as *const libc::c_void, bytes.len());\n-        libc::write(new_stderr, bytes.as_ptr() as *const libc::c_void, bytes.len());\n-    }\n-}\n-\n fn test_from_raw_os_error() {\n     let code = 6; // not a code that std or Miri know\n     let error = Error::from_raw_os_error(code);", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs.rs"}]}