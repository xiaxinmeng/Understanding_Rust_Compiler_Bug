{"sha": "95b892c8a723ad88e868e3914c3d29a585008ac2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1Yjg5MmM4YTcyM2FkODhlODY4ZTM5MTRjM2QyOWE1ODUwMDhhYzI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T21:54:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T21:55:30Z"}, "message": "libsyntax: De-export a lot of libsyntax. rs=de\u00ebxporting", "tree": {"sha": "fba7ee4b435c020fb862bda4c932f80bdbf1caf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fba7ee4b435c020fb862bda4c932f80bdbf1caf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95b892c8a723ad88e868e3914c3d29a585008ac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95b892c8a723ad88e868e3914c3d29a585008ac2", "html_url": "https://github.com/rust-lang/rust/commit/95b892c8a723ad88e868e3914c3d29a585008ac2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95b892c8a723ad88e868e3914c3d29a585008ac2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66b07f1e5dd5767ae6aa238a00490f1493c5d443", "url": "https://api.github.com/repos/rust-lang/rust/commits/66b07f1e5dd5767ae6aa238a00490f1493c5d443", "html_url": "https://github.com/rust-lang/rust/commit/66b07f1e5dd5767ae6aa238a00490f1493c5d443"}], "stats": {"total": 1071, "additions": 502, "deletions": 569}, "files": [{"sha": "8736074a5c468061437a3d93eb91cfda5acb0e60", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 157, "deletions": 157, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -23,7 +23,7 @@ use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n #[auto_encode]\n #[auto_decode]\n-struct spanned<T> { node: T, span: span }\n+pub struct spanned<T> { node: T, span: span }\n \n /* can't import macros yet, so this is copied from token.rs. See its comment\n  * there. */\n@@ -33,9 +33,9 @@ macro_rules! interner_key (\n         (-3 as uint, 0u)))\n )\n \n-struct ident { repr: uint }\n+pub struct ident { repr: uint }\n \n-impl<S: Encoder> ident: Encodable<S> {\n+pub impl<S: Encoder> ident: Encodable<S> {\n     fn encode(&self, s: &S) {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n@@ -48,7 +48,7 @@ impl<S: Encoder> ident: Encodable<S> {\n     }\n }\n \n-impl<D: Decoder> ident: Decodable<D> {\n+pub impl<D: Decoder> ident: Decodable<D> {\n     static fn decode(d: &D) -> ident {\n         let intr = match unsafe {\n             task::local_data::local_data_get(interner_key!())\n@@ -61,73 +61,73 @@ impl<D: Decoder> ident: Decodable<D> {\n     }\n }\n \n-impl ident: cmp::Eq {\n+pub impl ident: cmp::Eq {\n     pure fn eq(&self, other: &ident) -> bool { (*self).repr == other.repr }\n     pure fn ne(&self, other: &ident) -> bool { !(*self).eq(other) }\n }\n \n-impl ident: to_bytes::IterBytes {\n+pub impl ident: to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }\n \n // Functions may or may not have names.\n-type fn_ident = Option<ident>;\n+pub type fn_ident = Option<ident>;\n \n #[auto_encode]\n #[auto_decode]\n-struct path {\n+pub struct path {\n     span: span,\n     global: bool,\n     idents: ~[ident],\n     rp: Option<@region>,\n     types: ~[@Ty],\n }\n \n-type crate_num = int;\n+pub type crate_num = int;\n \n-type node_id = int;\n+pub type node_id = int;\n \n #[auto_encode]\n #[auto_decode]\n-struct def_id {\n+pub struct def_id {\n     crate: crate_num,\n     node: node_id,\n }\n \n-impl def_id : cmp::Eq {\n+pub impl def_id : cmp::Eq {\n     pure fn eq(&self, other: &def_id) -> bool {\n         (*self).crate == (*other).crate && (*self).node == (*other).node\n     }\n     pure fn ne(&self, other: &def_id) -> bool { !(*self).eq(other) }\n }\n \n-const local_crate: crate_num = 0;\n-const crate_node_id: node_id = 0;\n+pub const local_crate: crate_num = 0;\n+pub const crate_node_id: node_id = 0;\n \n #[auto_encode]\n #[auto_decode]\n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Owned, and Const.\n-enum ty_param_bound {\n+pub enum ty_param_bound {\n     TraitTyParamBound(@Ty),\n     RegionTyParamBound\n }\n \n #[auto_encode]\n #[auto_decode]\n-struct ty_param {\n+pub struct ty_param {\n     ident: ident,\n     id: node_id,\n     bounds: @~[ty_param_bound]\n }\n \n #[auto_encode]\n #[auto_decode]\n-enum def {\n+pub enum def {\n     def_fn(def_id, purity),\n     def_static_method(/* method */ def_id,\n                       /* trait */  Option<def_id>,\n@@ -155,7 +155,7 @@ enum def {\n     def_label(node_id)\n }\n \n-impl def : cmp::Eq {\n+pub impl def : cmp::Eq {\n     pure fn eq(&self, other: &def) -> bool {\n         match (*self) {\n             def_fn(e0a, e1a) => {\n@@ -288,31 +288,31 @@ impl def : cmp::Eq {\n \n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n-type crate_cfg = ~[@meta_item];\n+pub type crate_cfg = ~[@meta_item];\n \n-type crate = spanned<crate_>;\n+pub type crate = spanned<crate_>;\n \n-struct crate_ {\n+pub struct crate_ {\n     module: _mod,\n     attrs: ~[attribute],\n     config: crate_cfg,\n }\n \n-type meta_item = spanned<meta_item_>;\n+pub type meta_item = spanned<meta_item_>;\n \n #[auto_encode]\n #[auto_decode]\n-enum meta_item_ {\n+pub enum meta_item_ {\n     meta_word(~str),\n     meta_list(~str, ~[@meta_item]),\n     meta_name_value(~str, lit),\n }\n \n-type blk = spanned<blk_>;\n+pub type blk = spanned<blk_>;\n \n #[auto_encode]\n #[auto_decode]\n-struct blk_ {\n+pub struct blk_ {\n     view_items: ~[@view_item],\n     stmts: ~[@stmt],\n     expr: Option<@expr>,\n@@ -322,29 +322,29 @@ struct blk_ {\n \n #[auto_encode]\n #[auto_decode]\n-struct pat {\n+pub struct pat {\n     id: node_id,\n     node: pat_,\n     span: span,\n }\n \n #[auto_encode]\n #[auto_decode]\n-struct field_pat {\n+pub struct field_pat {\n     ident: ident,\n     pat: @pat,\n }\n \n #[auto_encode]\n #[auto_decode]\n-enum binding_mode {\n+pub enum binding_mode {\n     bind_by_value,\n     bind_by_move,\n     bind_by_ref(mutability),\n     bind_infer\n }\n \n-impl binding_mode : to_bytes::IterBytes {\n+pub impl binding_mode : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           bind_by_value => 0u8.iter_bytes(lsb0, f),\n@@ -360,7 +360,7 @@ impl binding_mode : to_bytes::IterBytes {\n     }\n }\n \n-impl binding_mode : cmp::Eq {\n+pub impl binding_mode : cmp::Eq {\n     pure fn eq(&self, other: &binding_mode) -> bool {\n         match (*self) {\n             bind_by_value => {\n@@ -394,7 +394,7 @@ impl binding_mode : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-enum pat_ {\n+pub enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n     // or a nullary enum (in which case the second field\n@@ -419,15 +419,15 @@ enum pat_ {\n \n #[auto_encode]\n #[auto_decode]\n-enum mutability { m_mutbl, m_imm, m_const, }\n+pub enum mutability { m_mutbl, m_imm, m_const, }\n \n-impl mutability : to_bytes::IterBytes {\n+pub impl mutability : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-impl mutability : cmp::Eq {\n+pub impl mutability : cmp::Eq {\n     pure fn eq(&self, other: &mutability) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n@@ -444,15 +444,15 @@ pub enum Proto {\n     ProtoBorrowed, // &fn\n }\n \n-impl Proto : to_bytes::IterBytes {\n+pub impl Proto : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n \n #[auto_encode]\n #[auto_decode]\n-enum vstore {\n+pub enum vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(Option<uint>),   // [1,2,3,4]\n     vstore_uniq,                  // ~[1,2,3,4]\n@@ -462,7 +462,7 @@ enum vstore {\n \n #[auto_encode]\n #[auto_decode]\n-enum expr_vstore {\n+pub enum expr_vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     expr_vstore_fixed(Option<uint>),   // [1,2,3,4]\n     expr_vstore_uniq,                  // ~[1,2,3,4]\n@@ -472,7 +472,7 @@ enum expr_vstore {\n     expr_vstore_mut_slice,             // &mut [1,2,3,4]\n }\n \n-pure fn is_blockish(p: Proto) -> bool {\n+pub pure fn is_blockish(p: Proto) -> bool {\n     match p {\n         ProtoBorrowed => true,\n         ProtoBare | ProtoUniq | ProtoBox => false\n@@ -481,7 +481,7 @@ pure fn is_blockish(p: Proto) -> bool {\n \n #[auto_encode]\n #[auto_decode]\n-enum binop {\n+pub enum binop {\n     add,\n     subtract,\n     mul,\n@@ -502,7 +502,7 @@ enum binop {\n     gt,\n }\n \n-impl binop : cmp::Eq {\n+pub impl binop : cmp::Eq {\n     pure fn eq(&self, other: &binop) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n@@ -511,15 +511,15 @@ impl binop : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-enum unop {\n+pub enum unop {\n     box(mutability),\n     uniq(mutability),\n     deref,\n     not,\n     neg\n }\n \n-impl unop : cmp::Eq {\n+pub impl unop : cmp::Eq {\n     pure fn eq(&self, other: &unop) -> bool {\n         match (*self) {\n             box(e0a) => {\n@@ -563,12 +563,12 @@ impl unop : cmp::Eq {\n // using ty::resolved_T(...).\n #[auto_encode]\n #[auto_decode]\n-enum inferable<T> {\n+pub enum inferable<T> {\n     expl(T),\n     infer(node_id)\n }\n \n-impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n+pub impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           expl(ref t) =>\n@@ -580,7 +580,7 @@ impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n     }\n }\n \n-impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n+pub impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n     pure fn eq(&self, other: &inferable<T>) -> bool {\n         match (*self) {\n             expl(ref e0a) => {\n@@ -603,30 +603,30 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n // \"resolved\" mode: the real modes.\n #[auto_encode]\n #[auto_decode]\n-enum rmode { by_ref, by_val, by_move, by_copy }\n+pub enum rmode { by_ref, by_val, by_move, by_copy }\n \n-impl rmode : to_bytes::IterBytes {\n+pub impl rmode : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n \n-impl rmode : cmp::Eq {\n+pub impl rmode : cmp::Eq {\n     pure fn eq(&self, other: &rmode) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n     pure fn ne(&self, other: &rmode) -> bool { !(*self).eq(other) }\n }\n \n // inferable mode.\n-type mode = inferable<rmode>;\n+pub type mode = inferable<rmode>;\n \n-type stmt = spanned<stmt_>;\n+pub type stmt = spanned<stmt_>;\n \n #[auto_encode]\n #[auto_decode]\n-enum stmt_ {\n+pub enum stmt_ {\n     stmt_decl(@decl, node_id),\n \n     // expr without trailing semi-colon (must have unit type):\n@@ -643,45 +643,45 @@ enum stmt_ {\n // a refinement on pat.\n #[auto_encode]\n #[auto_decode]\n-struct local_ {\n+pub struct local_ {\n     is_mutbl: bool,\n     ty: @Ty,\n     pat: @pat,\n     init: Option<@expr>,\n     id: node_id,\n }\n \n-type local = spanned<local_>;\n+pub type local = spanned<local_>;\n \n-type decl = spanned<decl_>;\n+pub type decl = spanned<decl_>;\n \n #[auto_encode]\n #[auto_decode]\n-enum decl_ { decl_local(~[@local]), decl_item(@item), }\n+pub enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n #[auto_encode]\n #[auto_decode]\n-struct arm {\n+pub struct arm {\n     pats: ~[@pat],\n     guard: Option<@expr>,\n     body: blk,\n }\n \n #[auto_encode]\n #[auto_decode]\n-struct field_ {\n+pub struct field_ {\n     mutbl: mutability,\n     ident: ident,\n     expr: @expr,\n }\n \n-type field = spanned<field_>;\n+pub type field = spanned<field_>;\n \n #[auto_encode]\n #[auto_decode]\n-enum blk_check_mode { default_blk, unsafe_blk, }\n+pub enum blk_check_mode { default_blk, unsafe_blk, }\n \n-impl blk_check_mode : cmp::Eq {\n+pub impl blk_check_mode : cmp::Eq {\n     pure fn eq(&self, other: &blk_check_mode) -> bool {\n         match ((*self), (*other)) {\n             (default_blk, default_blk) => true,\n@@ -695,7 +695,7 @@ impl blk_check_mode : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-struct expr {\n+pub struct expr {\n     id: node_id,\n     // Extra node ID is only used for index, assign_op, unary, binary, method\n     // call\n@@ -706,12 +706,12 @@ struct expr {\n \n #[auto_encode]\n #[auto_decode]\n-enum log_level { error, debug, log_other }\n+pub enum log_level { error, debug, log_other }\n // 0 = error, 1 = debug, 2 = log_other\n \n #[auto_encode]\n #[auto_decode]\n-enum expr_ {\n+pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n     expr_rec(~[field], Option<@expr>),\n@@ -771,16 +771,16 @@ enum expr_ {\n \n #[auto_encode]\n #[auto_decode]\n-struct capture_item_ {\n+pub struct capture_item_ {\n     id: int,\n     is_move: bool,\n     name: ident, // Currently, can only capture a local var.\n     span: span,\n }\n \n-type capture_item = @capture_item_;\n+pub type capture_item = @capture_item_;\n \n-type capture_clause = @~[capture_item];\n+pub type capture_clause = @~[capture_item];\n \n //\n // When the main rust parser encounters a syntax-extension invocation, it\n@@ -801,7 +801,7 @@ type capture_clause = @~[capture_item];\n #[auto_encode]\n #[auto_decode]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n-enum token_tree {\n+pub enum token_tree {\n     tt_tok(span, ::parse::token::Token),\n     tt_delim(~[token_tree]),\n     // These only make sense for right-hand-sides of MBE macros\n@@ -861,11 +861,11 @@ enum token_tree {\n // If you understand that, you have closed to loop and understand the whole\n // macro system. Congratulations.\n //\n-type matcher = spanned<matcher_>;\n+pub type matcher = spanned<matcher_>;\n \n #[auto_encode]\n #[auto_decode]\n-enum matcher_ {\n+pub enum matcher_ {\n     // match one token\n     match_tok(::parse::token::Token),\n     // match repetitions of a sequence: body, separator, zero ok?,\n@@ -875,19 +875,19 @@ enum matcher_ {\n     match_nonterminal(ident, ident, uint)\n }\n \n-type mac = spanned<mac_>;\n+pub type mac = spanned<mac_>;\n \n #[auto_encode]\n #[auto_decode]\n-enum mac_ {\n+pub enum mac_ {\n     mac_invoc_tt(@path,~[token_tree]),   // new macro-invocation\n }\n \n-type lit = spanned<lit_>;\n+pub type lit = spanned<lit_>;\n \n #[auto_encode]\n #[auto_decode]\n-enum lit_ {\n+pub enum lit_ {\n     lit_str(@~str),\n     lit_int(i64, int_ty),\n     lit_uint(u64, uint_ty),\n@@ -898,7 +898,7 @@ enum lit_ {\n     lit_bool(bool),\n }\n \n-impl lit_: cmp::Eq {\n+pub impl lit_: cmp::Eq {\n     pure fn eq(&self, other: &lit_) -> bool {\n         match ((*self), *other) {\n             (lit_str(a), lit_str(b)) => a == b,\n@@ -932,23 +932,23 @@ impl lit_: cmp::Eq {\n // type structure in middle/ty.rs as well.\n #[auto_encode]\n #[auto_decode]\n-struct mt {\n+pub struct mt {\n     ty: @Ty,\n     mutbl: mutability,\n }\n \n #[auto_encode]\n #[auto_decode]\n-struct ty_field_ {\n+pub struct ty_field_ {\n     ident: ident,\n     mt: mt,\n }\n \n-type ty_field = spanned<ty_field_>;\n+pub type ty_field = spanned<ty_field_>;\n \n #[auto_encode]\n #[auto_decode]\n-struct ty_method {\n+pub struct ty_method {\n     ident: ident,\n     attrs: ~[attribute],\n     purity: purity,\n@@ -964,28 +964,28 @@ struct ty_method {\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n-enum trait_method {\n+pub enum trait_method {\n     required(ty_method),\n     provided(@method),\n }\n \n #[auto_encode]\n #[auto_decode]\n-enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n+pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n-impl int_ty : ToStr {\n+pub impl int_ty : ToStr {\n     pure fn to_str() -> ~str {\n         ::ast_util::int_ty_to_str(self)\n     }\n }\n \n-impl int_ty : to_bytes::IterBytes {\n+pub impl int_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-impl int_ty : cmp::Eq {\n+pub impl int_ty : cmp::Eq {\n     pure fn eq(&self, other: &int_ty) -> bool {\n         match ((*self), (*other)) {\n             (ty_i, ty_i) => true,\n@@ -1007,21 +1007,21 @@ impl int_ty : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n+pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n-impl uint_ty : ToStr {\n+pub impl uint_ty : ToStr {\n     pure fn to_str() -> ~str {\n         ::ast_util::uint_ty_to_str(self)\n     }\n }\n \n-impl uint_ty : to_bytes::IterBytes {\n+pub impl uint_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-impl uint_ty : cmp::Eq {\n+pub impl uint_ty : cmp::Eq {\n     pure fn eq(&self, other: &uint_ty) -> bool {\n         match ((*self), (*other)) {\n             (ty_u, ty_u) => true,\n@@ -1041,21 +1041,21 @@ impl uint_ty : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-enum float_ty { ty_f, ty_f32, ty_f64, }\n+pub enum float_ty { ty_f, ty_f32, ty_f64, }\n \n-impl float_ty : ToStr {\n+pub impl float_ty : ToStr {\n     pure fn to_str() -> ~str {\n         ::ast_util::float_ty_to_str(self)\n     }\n }\n \n-impl float_ty : to_bytes::IterBytes {\n+pub impl float_ty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-impl float_ty : cmp::Eq {\n+pub impl float_ty : cmp::Eq {\n     pure fn eq(&self, other: &float_ty) -> bool {\n         match ((*self), (*other)) {\n             (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n@@ -1067,7 +1067,7 @@ impl float_ty : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-struct Ty {\n+pub struct Ty {\n     id: node_id,\n     node: ty_,\n     span: span,\n@@ -1076,15 +1076,15 @@ struct Ty {\n // Not represented directly in the AST, referred to by name through a ty_path.\n #[auto_encode]\n #[auto_decode]\n-enum prim_ty {\n+pub enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n     ty_float(float_ty),\n     ty_str,\n     ty_bool,\n }\n \n-impl prim_ty : cmp::Eq {\n+pub impl prim_ty : cmp::Eq {\n     pure fn eq(&self, other: &prim_ty) -> bool {\n         match (*self) {\n             ty_int(e0a) => {\n@@ -1124,14 +1124,14 @@ impl prim_ty : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-struct region {\n+pub struct region {\n     id: node_id,\n     node: region_,\n }\n \n #[auto_encode]\n #[auto_decode]\n-enum region_ {\n+pub enum region_ {\n     re_anon,\n     re_static,\n     re_self,\n@@ -1141,12 +1141,12 @@ enum region_ {\n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]\n-enum Onceness {\n+pub enum Onceness {\n     Once,\n     Many\n }\n \n-impl Onceness : ToStr {\n+pub impl Onceness : ToStr {\n     pure fn to_str() -> ~str {\n         match self {\n             Once => ~\"once\",\n@@ -1155,15 +1155,15 @@ impl Onceness : ToStr {\n     }\n }\n \n-impl Onceness : to_bytes::IterBytes {\n+pub impl Onceness : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n \n #[auto_encode]\n #[auto_decode]\n-struct TyFn {\n+pub struct TyFn {\n     proto: Proto,\n     region: Option<@region>,\n     purity: purity,\n@@ -1174,7 +1174,7 @@ struct TyFn {\n \n #[auto_encode]\n #[auto_decode]\n-enum ty_ {\n+pub enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n     ty_box(mt),\n@@ -1196,7 +1196,7 @@ enum ty_ {\n \n // Equality and byte-iter (hashing) can be quite approximate for AST types.\n // since we only care about this for normalizing them to \"real\" types.\n-impl Ty : cmp::Eq {\n+pub impl Ty : cmp::Eq {\n     pure fn eq(&self, other: &Ty) -> bool {\n         ptr::addr_of(&(*self)) == ptr::addr_of(&(*other))\n     }\n@@ -1205,15 +1205,15 @@ impl Ty : cmp::Eq {\n     }\n }\n \n-impl Ty : to_bytes::IterBytes {\n+pub impl Ty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n }\n \n #[auto_encode]\n #[auto_decode]\n-struct arg {\n+pub struct arg {\n     mode: mode,\n     is_mutbl: bool,\n     ty: @Ty,\n@@ -1223,7 +1223,7 @@ struct arg {\n \n #[auto_encode]\n #[auto_decode]\n-struct fn_decl {\n+pub struct fn_decl {\n     inputs: ~[arg],\n     output: @Ty,\n     cf: ret_style,\n@@ -1238,7 +1238,7 @@ pub enum purity {\n     extern_fn, // declared with \"extern fn\"\n }\n \n-impl purity : ToStr {\n+pub impl purity : ToStr {\n     pure fn to_str() -> ~str {\n         match self {\n             impure_fn => ~\"impure\",\n@@ -1249,13 +1249,13 @@ impl purity : ToStr {\n     }\n }\n \n-impl purity : to_bytes::IterBytes {\n+pub impl purity : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-impl purity : cmp::Eq {\n+pub impl purity : cmp::Eq {\n     pure fn eq(&self, other: &purity) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n@@ -1264,19 +1264,19 @@ impl purity : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-enum ret_style {\n+pub enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val, // everything else\n }\n \n-impl ret_style : to_bytes::IterBytes {\n+pub impl ret_style : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-impl ret_style : cmp::Eq {\n+pub impl ret_style : cmp::Eq {\n     pure fn eq(&self, other: &ret_style) -> bool {\n         match ((*self), (*other)) {\n             (noreturn, noreturn) => true,\n@@ -1290,7 +1290,7 @@ impl ret_style : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-enum self_ty_ {\n+pub enum self_ty_ {\n     sty_static,                         // no self: static method\n     sty_by_ref,                         // old by-reference self: ``\n     sty_value,                          // by-value self: `self`\n@@ -1299,7 +1299,7 @@ enum self_ty_ {\n     sty_uniq(mutability)                // by-unique-pointer self: `~self`\n }\n \n-impl self_ty_ : cmp::Eq {\n+pub impl self_ty_ : cmp::Eq {\n     pure fn eq(&self, other: &self_ty_) -> bool {\n         match (*self) {\n             sty_static => {\n@@ -1343,11 +1343,11 @@ impl self_ty_ : cmp::Eq {\n     pure fn ne(&self, other: &self_ty_) -> bool { !(*self).eq(other) }\n }\n \n-type self_ty = spanned<self_ty_>;\n+pub type self_ty = spanned<self_ty_>;\n \n #[auto_encode]\n #[auto_decode]\n-struct method {\n+pub struct method {\n     ident: ident,\n     attrs: ~[attribute],\n     tps: ~[ty_param],\n@@ -1363,14 +1363,14 @@ struct method {\n \n #[auto_encode]\n #[auto_decode]\n-struct _mod {\n+pub struct _mod {\n     view_items: ~[@view_item],\n     items: ~[@item],\n }\n \n #[auto_encode]\n #[auto_decode]\n-enum foreign_abi {\n+pub enum foreign_abi {\n     foreign_abi_rust_intrinsic,\n     foreign_abi_cdecl,\n     foreign_abi_stdcall,\n@@ -1379,16 +1379,16 @@ enum foreign_abi {\n // Foreign mods can be named or anonymous\n #[auto_encode]\n #[auto_decode]\n-enum foreign_mod_sort { named, anonymous }\n+pub enum foreign_mod_sort { named, anonymous }\n \n-impl foreign_mod_sort : cmp::Eq {\n+pub impl foreign_mod_sort : cmp::Eq {\n     pure fn eq(&self, other: &foreign_mod_sort) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n     pure fn ne(&self, other: &foreign_mod_sort) -> bool { !(*self).eq(other) }\n }\n \n-impl foreign_abi : cmp::Eq {\n+pub impl foreign_abi : cmp::Eq {\n     pure fn eq(&self, other: &foreign_abi) -> bool {\n         match ((*self), (*other)) {\n             (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n@@ -1404,7 +1404,7 @@ impl foreign_abi : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-struct foreign_mod {\n+pub struct foreign_mod {\n     sort: foreign_mod_sort,\n     abi: ident,\n     view_items: ~[@view_item],\n@@ -1413,33 +1413,33 @@ struct foreign_mod {\n \n #[auto_encode]\n #[auto_decode]\n-struct variant_arg {\n+pub struct variant_arg {\n     ty: @Ty,\n     id: node_id,\n }\n \n #[auto_encode]\n #[auto_decode]\n-enum variant_kind {\n+pub enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n     enum_variant_kind(enum_def)\n }\n \n #[auto_encode]\n #[auto_decode]\n-struct enum_def_ {\n+pub struct enum_def_ {\n     variants: ~[variant],\n     common: Option<@struct_def>,\n }\n \n #[auto_encode]\n #[auto_decode]\n-enum enum_def = enum_def_;\n+pub enum enum_def = enum_def_;\n \n #[auto_encode]\n #[auto_decode]\n-struct variant_ {\n+pub struct variant_ {\n     name: ident,\n     attrs: ~[attribute],\n     kind: variant_kind,\n@@ -1448,33 +1448,33 @@ struct variant_ {\n     vis: visibility,\n }\n \n-type variant = spanned<variant_>;\n+pub type variant = spanned<variant_>;\n \n #[auto_encode]\n #[auto_decode]\n-struct path_list_ident_ {\n+pub struct path_list_ident_ {\n     name: ident,\n     id: node_id,\n }\n \n-type path_list_ident = spanned<path_list_ident_>;\n+pub type path_list_ident = spanned<path_list_ident_>;\n \n #[auto_encode]\n #[auto_decode]\n-enum namespace { module_ns, type_value_ns }\n+pub enum namespace { module_ns, type_value_ns }\n \n-impl namespace : cmp::Eq {\n+pub impl namespace : cmp::Eq {\n     pure fn eq(&self, other: &namespace) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n     pure fn ne(&self, other: &namespace) -> bool { !(*self).eq(other) }\n }\n \n-type view_path = spanned<view_path_>;\n+pub type view_path = spanned<view_path_>;\n \n #[auto_encode]\n #[auto_decode]\n-enum view_path_ {\n+pub enum view_path_ {\n \n     // quux = foo::bar::baz\n     //\n@@ -1492,7 +1492,7 @@ enum view_path_ {\n \n #[auto_encode]\n #[auto_decode]\n-struct view_item {\n+pub struct view_item {\n     node: view_item_,\n     attrs: ~[attribute],\n     vis: visibility,\n@@ -1501,23 +1501,23 @@ struct view_item {\n \n #[auto_encode]\n #[auto_decode]\n-enum view_item_ {\n+pub enum view_item_ {\n     view_item_use(ident, ~[@meta_item], node_id),\n     view_item_import(~[@view_path]),\n     view_item_export(~[@view_path])\n }\n \n // Meta-data associated with an item\n-type attribute = spanned<attribute_>;\n+pub type attribute = spanned<attribute_>;\n \n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n #[auto_encode]\n #[auto_decode]\n-enum attr_style { attr_outer, attr_inner, }\n+pub enum attr_style { attr_outer, attr_inner, }\n \n-impl attr_style : cmp::Eq {\n+pub impl attr_style : cmp::Eq {\n     pure fn eq(&self, other: &attr_style) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n@@ -1527,7 +1527,7 @@ impl attr_style : cmp::Eq {\n // doc-comments are promoted to attributes that have is_sugared_doc = true\n #[auto_encode]\n #[auto_decode]\n-struct attribute_ {\n+pub struct attribute_ {\n     style: attr_style,\n     value: meta_item,\n     is_sugared_doc: bool,\n@@ -1542,16 +1542,16 @@ struct attribute_ {\n  */\n #[auto_encode]\n #[auto_decode]\n-struct trait_ref {\n+pub struct trait_ref {\n     path: @path,\n     ref_id: node_id,\n }\n \n #[auto_encode]\n #[auto_decode]\n-enum visibility { public, private, inherited }\n+pub enum visibility { public, private, inherited }\n \n-impl visibility : cmp::Eq {\n+pub impl visibility : cmp::Eq {\n     pure fn eq(&self, other: &visibility) -> bool {\n         match ((*self), (*other)) {\n             (public, public) => true,\n@@ -1567,22 +1567,22 @@ impl visibility : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-struct struct_field_ {\n+pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n     ty: @Ty,\n }\n \n-type struct_field = spanned<struct_field_>;\n+pub type struct_field = spanned<struct_field_>;\n \n #[auto_encode]\n #[auto_decode]\n-enum struct_field_kind {\n+pub enum struct_field_kind {\n     named_field(ident, struct_mutability, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n-impl struct_field_kind : cmp::Eq {\n+pub impl struct_field_kind : cmp::Eq {\n     pure fn eq(&self, other: &struct_field_kind) -> bool {\n         match (*self) {\n             named_field(ident_a, struct_mutability_a, visibility_a) => {\n@@ -1611,7 +1611,7 @@ impl struct_field_kind : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n-struct struct_def {\n+pub struct struct_def {\n     fields: ~[@struct_field], /* fields */\n     /* (not including ctor or dtor) */\n     /* dtor is optional */\n@@ -1627,7 +1627,7 @@ struct struct_def {\n  */\n #[auto_encode]\n #[auto_decode]\n-struct item {\n+pub struct item {\n     ident: ident,\n     attrs: ~[attribute],\n     id: node_id,\n@@ -1638,7 +1638,7 @@ struct item {\n \n #[auto_encode]\n #[auto_decode]\n-enum item_ {\n+pub enum item_ {\n     item_const(@Ty, @expr),\n     item_fn(fn_decl, purity, ~[ty_param], blk),\n     item_mod(_mod),\n@@ -1656,15 +1656,15 @@ enum item_ {\n \n #[auto_encode]\n #[auto_decode]\n-enum struct_mutability { struct_mutable, struct_immutable }\n+pub enum struct_mutability { struct_mutable, struct_immutable }\n \n-impl struct_mutability : to_bytes::IterBytes {\n+pub impl struct_mutability : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-impl struct_mutability : cmp::Eq {\n+pub impl struct_mutability : cmp::Eq {\n     pure fn eq(&self, other: &struct_mutability) -> bool {\n         match ((*self), (*other)) {\n             (struct_mutable, struct_mutable) => true,\n@@ -1678,11 +1678,11 @@ impl struct_mutability : cmp::Eq {\n     }\n }\n \n-type struct_dtor = spanned<struct_dtor_>;\n+pub type struct_dtor = spanned<struct_dtor_>;\n \n #[auto_encode]\n #[auto_decode]\n-struct struct_dtor_ {\n+pub struct struct_dtor_ {\n     id: node_id,\n     attrs: ~[attribute],\n     self_id: node_id,\n@@ -1691,7 +1691,7 @@ struct struct_dtor_ {\n \n #[auto_encode]\n #[auto_decode]\n-struct foreign_item {\n+pub struct foreign_item {\n     ident: ident,\n     attrs: ~[attribute],\n     node: foreign_item_,\n@@ -1702,7 +1702,7 @@ struct foreign_item {\n \n #[auto_encode]\n #[auto_decode]\n-enum foreign_item_ {\n+pub enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, ~[ty_param]),\n     foreign_item_const(@Ty)\n }\n@@ -1712,7 +1712,7 @@ enum foreign_item_ {\n // that we trans.\n #[auto_encode]\n #[auto_decode]\n-enum inlined_item {\n+pub enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_foreign(@foreign_item),"}, {"sha": "773e3754e263988f70d3820f1df34330964fb3aa", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -29,12 +29,12 @@ use std::map::HashMap;\n use std::map;\n use std;\n \n-enum path_elt {\n+pub enum path_elt {\n     path_mod(ident),\n     path_name(ident)\n }\n \n-impl path_elt : cmp::Eq {\n+pub impl path_elt : cmp::Eq {\n     pure fn eq(&self, other: &path_elt) -> bool {\n         match (*self) {\n             path_mod(e0a) => {\n@@ -54,10 +54,10 @@ impl path_elt : cmp::Eq {\n     pure fn ne(&self, other: &path_elt) -> bool { !(*self).eq(other) }\n }\n \n-type path = ~[path_elt];\n+pub type path = ~[path_elt];\n \n-fn path_to_str_with_sep(p: &[path_elt], sep: ~str, itr: @ident_interner)\n-    -> ~str {\n+pub fn path_to_str_with_sep(p: &[path_elt], sep: ~str, itr: @ident_interner)\n+                         -> ~str {\n     let strs = do p.map |e| {\n         match *e {\n           path_mod(s) => *itr.get(s),\n@@ -67,7 +67,7 @@ fn path_to_str_with_sep(p: &[path_elt], sep: ~str, itr: @ident_interner)\n     str::connect(strs, sep)\n }\n \n-fn path_ident_to_str(p: path, i: ident, itr: @ident_interner) -> ~str {\n+pub fn path_ident_to_str(p: path, i: ident, itr: @ident_interner) -> ~str {\n     if vec::is_empty(p) {\n         //FIXME /* FIXME (#2543) */ copy *i\n         *itr.get(i)\n@@ -76,18 +76,18 @@ fn path_ident_to_str(p: path, i: ident, itr: @ident_interner) -> ~str {\n     }\n }\n \n-fn path_to_str(p: &[path_elt], itr: @ident_interner) -> ~str {\n+pub fn path_to_str(p: &[path_elt], itr: @ident_interner) -> ~str {\n     path_to_str_with_sep(p, ~\"::\", itr)\n }\n \n-fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n+pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n     match pe {\n         path_mod(s) => *itr.get(s),\n         path_name(s) => *itr.get(s)\n     }\n }\n \n-enum ast_node {\n+pub enum ast_node {\n     node_item(@item, @path),\n     node_foreign_item(@foreign_item, foreign_abi, @path),\n     node_trait_method(@trait_method, def_id /* trait did */,\n@@ -107,20 +107,20 @@ enum ast_node {\n     node_struct_ctor(@struct_def, @item, @path),\n }\n \n-type map = std::map::HashMap<node_id, ast_node>;\n-struct ctx {\n+pub type map = std::map::HashMap<node_id, ast_node>;\n+pub struct ctx {\n     map: map,\n     mut path: path,\n     mut local_id: uint,\n     diag: span_handler,\n }\n-type vt = visit::vt<ctx>;\n+pub type vt = visit::vt<ctx>;\n \n-fn extend(cx: ctx, +elt: ident) -> @path {\n+pub fn extend(cx: ctx, +elt: ident) -> @path {\n     @(vec::append(cx.path, ~[path_name(elt)]))\n }\n \n-fn mk_ast_map_visitor() -> vt {\n+pub fn mk_ast_map_visitor() -> vt {\n     return visit::mk_vt(@visit::Visitor {\n         visit_item: map_item,\n         visit_expr: map_expr,\n@@ -134,7 +134,7 @@ fn mk_ast_map_visitor() -> vt {\n     });\n }\n \n-fn map_crate(diag: span_handler, c: crate) -> map {\n+pub fn map_crate(diag: span_handler, c: crate) -> map {\n     let cx = ctx {\n         map: std::map::HashMap(),\n         mut path: ~[],\n@@ -148,8 +148,8 @@ fn map_crate(diag: span_handler, c: crate) -> map {\n // Used for items loaded from external crate that are being inlined into this\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n-fn map_decoded_item(diag: span_handler,\n-                    map: map, path: path, ii: inlined_item) {\n+pub fn map_decoded_item(diag: span_handler,\n+                        map: map, path: path, ii: inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.  (In particular, I think these ids are only used in\n@@ -182,8 +182,8 @@ fn map_decoded_item(diag: span_handler,\n     ii.accept(cx, v);\n }\n \n-fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n-          sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n+pub fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n+              sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n     for decl.inputs.each |a| {\n         cx.map.insert(a.id,\n                       node_arg(/* FIXME (#2543) */\n@@ -210,12 +210,12 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n-fn map_block(b: blk, cx: ctx, v: vt) {\n+pub fn map_block(b: blk, cx: ctx, v: vt) {\n     cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy b));\n     visit::visit_block(b, cx, v);\n }\n \n-fn number_pat(cx: ctx, pat: @pat) {\n+pub fn number_pat(cx: ctx, pat: @pat) {\n     do ast_util::walk_pat(pat) |p| {\n         match p.node {\n           pat_ident(*) => {\n@@ -227,24 +227,24 @@ fn number_pat(cx: ctx, pat: @pat) {\n     };\n }\n \n-fn map_local(loc: @local, cx: ctx, v: vt) {\n+pub fn map_local(loc: @local, cx: ctx, v: vt) {\n     number_pat(cx, loc.node.pat);\n     visit::visit_local(loc, cx, v);\n }\n \n-fn map_arm(arm: arm, cx: ctx, v: vt) {\n+pub fn map_arm(arm: arm, cx: ctx, v: vt) {\n     number_pat(cx, arm.pats[0]);\n     visit::visit_arm(arm, cx, v);\n }\n \n-fn map_method(impl_did: def_id, impl_path: @path,\n-              m: @method, cx: ctx) {\n+pub fn map_method(impl_did: def_id, impl_path: @path,\n+                  m: @method, cx: ctx) {\n     cx.map.insert(m.id, node_method(m, impl_did, impl_path));\n     cx.map.insert(m.self_id, node_local(cx.local_id));\n     cx.local_id += 1u;\n }\n \n-fn map_item(i: @item, cx: ctx, v: vt) {\n+pub fn map_item(i: @item, cx: ctx, v: vt) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     match i.node {\n@@ -306,8 +306,8 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     cx.path.pop();\n }\n \n-fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n-                  ident: ast::ident, cx: ctx, _v: vt) {\n+pub fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n+                      ident: ast::ident, cx: ctx, _v: vt) {\n     let p = extend(cx, ident);\n     // If this is a tuple-like struct, register the constructor.\n     match struct_def.ctor_id {\n@@ -324,7 +324,7 @@ fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n     }\n }\n \n-fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n+pub fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n     match vi.node {\n       view_item_export(vps) => for vps.each |vp| {\n         let (id, name) = match vp.node {\n@@ -341,17 +341,17 @@ fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {\n     }\n }\n \n-fn map_expr(ex: @expr, cx: ctx, v: vt) {\n+pub fn map_expr(ex: @expr, cx: ctx, v: vt) {\n     cx.map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, cx, v);\n }\n \n-fn map_stmt(stmt: @stmt, cx: ctx, v: vt) {\n+pub fn map_stmt(stmt: @stmt, cx: ctx, v: vt) {\n     cx.map.insert(stmt_id(*stmt), node_stmt(stmt));\n     visit::visit_stmt(stmt, cx, v);\n }\n \n-fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n+pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n     match map.find(id) {\n       None => {\n         fmt!(\"unknown node (id=%d)\", id)\n@@ -419,7 +419,7 @@ fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n     }\n }\n \n-fn node_item_query<Result>(items: map, id: node_id,\n+pub fn node_item_query<Result>(items: map, id: node_id,\n                            query: fn(@item) -> Result,\n                            error_msg: ~str) -> Result {\n     match items.find(id) {"}, {"sha": "ac0a54c582ca8f23cc6b49fa0b3d0182ff18f074", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 59, "deletions": 56, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -24,43 +24,44 @@ use core::str;\n use core::to_bytes;\n use core::vec;\n \n-pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n+pub pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n     respan(mk_sp(lo, hi), move t)\n }\n \n-pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n+pub pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n     spanned {node: t, span: sp}\n }\n \n-pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n+pub pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n     respan(dummy_sp(), move t)\n }\n \n /* assuming that we're not in macro expansion */\n-pure fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n+pub pure fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n     span {lo: lo, hi: hi, expn_info: None}\n }\n \n // make this a const, once the compiler supports it\n-pure fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n+pub pure fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n \n \n \n-pure fn path_name_i(idents: &[ident], intr: @token::ident_interner) -> ~str {\n+pub pure fn path_name_i(idents: &[ident], intr: @token::ident_interner)\n+                     -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     str::connect(idents.map(|i| *intr.get(*i)), ~\"::\")\n }\n \n \n-pure fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }\n+pub pure fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }\n \n-pure fn local_def(id: node_id) -> def_id {\n+pub pure fn local_def(id: node_id) -> def_id {\n     ast::def_id { crate: local_crate, node: id }\n }\n \n-pure fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n+pub pure fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n \n-pure fn stmt_id(s: stmt) -> node_id {\n+pub pure fn stmt_id(s: stmt) -> node_id {\n     match s.node {\n       stmt_decl(_, id) => id,\n       stmt_expr(_, id) => id,\n@@ -69,7 +70,7 @@ pure fn stmt_id(s: stmt) -> node_id {\n     }\n }\n \n-fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n+pub fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n     match d {\n       def_variant(enum_id, var_id) => {\n         return {enm: enum_id, var: var_id}\n@@ -78,7 +79,7 @@ fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n     }\n }\n \n-pure fn def_id_of_def(d: def) -> def_id {\n+pub pure fn def_id_of_def(d: def) -> def_id {\n     match d {\n       def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n@@ -96,7 +97,7 @@ pure fn def_id_of_def(d: def) -> def_id {\n     }\n }\n \n-pure fn binop_to_str(op: binop) -> ~str {\n+pub pure fn binop_to_str(op: binop) -> ~str {\n     match op {\n       add => return ~\"+\",\n       subtract => return ~\"-\",\n@@ -119,7 +120,7 @@ pure fn binop_to_str(op: binop) -> ~str {\n     }\n }\n \n-pure fn binop_to_method_name(op: binop) -> Option<~str> {\n+pub pure fn binop_to_method_name(op: binop) -> Option<~str> {\n     match op {\n       add => return Some(~\"add\"),\n       subtract => return Some(~\"sub\"),\n@@ -141,23 +142,23 @@ pure fn binop_to_method_name(op: binop) -> Option<~str> {\n     }\n }\n \n-pure fn lazy_binop(b: binop) -> bool {\n+pub pure fn lazy_binop(b: binop) -> bool {\n     match b {\n       and => true,\n       or => true,\n       _ => false\n     }\n }\n \n-pure fn is_shift_binop(b: binop) -> bool {\n+pub pure fn is_shift_binop(b: binop) -> bool {\n     match b {\n       shl => true,\n       shr => true,\n       _ => false\n     }\n }\n \n-pure fn unop_to_str(op: unop) -> ~str {\n+pub pure fn unop_to_str(op: unop) -> ~str {\n     match op {\n       box(mt) => if mt == m_mutbl { ~\"@mut \" } else { ~\"@\" },\n       uniq(mt) => if mt == m_mutbl { ~\"~mut \" } else { ~\"~\" },\n@@ -167,11 +168,11 @@ pure fn unop_to_str(op: unop) -> ~str {\n     }\n }\n \n-pure fn is_path(e: @expr) -> bool {\n+pub pure fn is_path(e: @expr) -> bool {\n     return match e.node { expr_path(_) => true, _ => false };\n }\n \n-pure fn int_ty_to_str(t: int_ty) -> ~str {\n+pub pure fn int_ty_to_str(t: int_ty) -> ~str {\n     match t {\n       ty_char => ~\"u8\", // ???\n       ty_i => ~\"\",\n@@ -182,7 +183,7 @@ pure fn int_ty_to_str(t: int_ty) -> ~str {\n     }\n }\n \n-pure fn int_ty_max(t: int_ty) -> u64 {\n+pub pure fn int_ty_max(t: int_ty) -> u64 {\n     match t {\n       ty_i8 => 0x80u64,\n       ty_i16 => 0x8000u64,\n@@ -191,7 +192,7 @@ pure fn int_ty_max(t: int_ty) -> u64 {\n     }\n }\n \n-pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n+pub pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n     match t {\n       ty_u => ~\"u\",\n       ty_u8 => ~\"u8\",\n@@ -201,7 +202,7 @@ pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n     }\n }\n \n-pure fn uint_ty_max(t: uint_ty) -> u64 {\n+pub pure fn uint_ty_max(t: uint_ty) -> u64 {\n     match t {\n       ty_u8 => 0xffu64,\n       ty_u16 => 0xffffu64,\n@@ -210,11 +211,11 @@ pure fn uint_ty_max(t: uint_ty) -> u64 {\n     }\n }\n \n-pure fn float_ty_to_str(t: float_ty) -> ~str {\n+pub pure fn float_ty_to_str(t: float_ty) -> ~str {\n     match t { ty_f => ~\"f\", ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n }\n \n-fn is_exported(i: ident, m: _mod) -> bool {\n+pub fn is_exported(i: ident, m: _mod) -> bool {\n     let mut local = false;\n     let mut parent_enum : Option<ident> = None;\n     for m.items.each |it| {\n@@ -272,24 +273,24 @@ fn is_exported(i: ident, m: _mod) -> bool {\n     return !has_explicit_exports && local;\n }\n \n-pure fn is_call_expr(e: @expr) -> bool {\n+pub pure fn is_call_expr(e: @expr) -> bool {\n     match e.node { expr_call(_, _, _) => true, _ => false }\n }\n \n // This makes def_id hashable\n-impl def_id : to_bytes::IterBytes {\n+pub impl def_id : to_bytes::IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n     }\n }\n \n-fn block_from_expr(e: @expr) -> blk {\n+pub fn block_from_expr(e: @expr) -> blk {\n     let blk_ = default_block(~[], option::Some::<@expr>(e), e.id);\n     return spanned {node: blk_, span: e.span};\n }\n \n-fn default_block(\n+pub fn default_block(\n     +stmts1: ~[@stmt],\n     expr1: Option<@expr>,\n     id1: node_id\n@@ -303,32 +304,32 @@ fn default_block(\n     }\n }\n \n-fn ident_to_path(s: span, +i: ident) -> @path {\n+pub fn ident_to_path(s: span, +i: ident) -> @path {\n     @ast::path { span: s,\n                  global: false,\n                  idents: ~[i],\n                  rp: None,\n                  types: ~[] }\n }\n \n-fn ident_to_pat(id: node_id, s: span, +i: ident) -> @pat {\n+pub fn ident_to_pat(id: node_id, s: span, +i: ident) -> @pat {\n     @ast::pat { id: id,\n                 node: pat_ident(bind_by_value, ident_to_path(s, i), None),\n                 span: s }\n }\n \n-pure fn is_unguarded(a: &arm) -> bool {\n+pub pure fn is_unguarded(a: &arm) -> bool {\n     match a.guard {\n       None => true,\n       _    => false\n     }\n }\n \n-pure fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n+pub pure fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n     if is_unguarded(a) { Some(/* FIXME (#2543) */ copy a.pats) } else { None }\n }\n \n-fn public_methods(ms: ~[@method]) -> ~[@method] {\n+pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n     do ms.filtered |m| {\n         match m.vis {\n             public => true,\n@@ -339,7 +340,7 @@ fn public_methods(ms: ~[@method]) -> ~[@method] {\n \n // extract a ty_method from a trait_method. if the trait_method is\n // a default, pull out the useful fields to make a ty_method\n-fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n+pub fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n     match method {\n         required(ref m) => (*m),\n         provided(m) => {\n@@ -357,7 +358,7 @@ fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n     }\n }\n \n-fn split_trait_methods(trait_methods: ~[trait_method])\n+pub fn split_trait_methods(trait_methods: ~[trait_method])\n     -> (~[ty_method], ~[@method]) {\n     let mut reqd = ~[], provd = ~[];\n     for trait_methods.each |trt_method| {\n@@ -369,7 +370,7 @@ fn split_trait_methods(trait_methods: ~[trait_method])\n     (reqd, provd)\n }\n \n-pure fn struct_field_visibility(field: ast::struct_field) -> visibility {\n+pub pure fn struct_field_visibility(field: ast::struct_field) -> visibility {\n     match field.node.kind {\n         ast::named_field(_, _, visibility) => visibility,\n         ast::unnamed_field => ast::public\n@@ -382,7 +383,7 @@ pub trait inlined_item_utils {\n     fn accept<E>(e: E, v: visit::vt<E>);\n }\n \n-impl inlined_item: inlined_item_utils {\n+pub impl inlined_item: inlined_item_utils {\n     fn ident() -> ident {\n         match self {\n           ii_item(i) => /* FIXME (#2543) */ copy i.ident,\n@@ -415,7 +416,7 @@ impl inlined_item: inlined_item_utils {\n \n /* True if d is either a def_self, or a chain of def_upvars\n  referring to a def_self */\n-fn is_self(d: ast::def) -> bool {\n+pub fn is_self(d: ast::def) -> bool {\n   match d {\n     def_self(*)           => true,\n     def_upvar(_, d, _, _) => is_self(*d),\n@@ -424,7 +425,7 @@ fn is_self(d: ast::def) -> bool {\n }\n \n /// Maps a binary operator to its precedence\n-fn operator_prec(op: ast::binop) -> uint {\n+pub fn operator_prec(op: ast::binop) -> uint {\n   match op {\n       mul | div | rem   => 12u,\n       // 'as' sits between here with 11\n@@ -440,9 +441,11 @@ fn operator_prec(op: ast::binop) -> uint {\n   }\n }\n \n-fn dtor_ty() -> @ast::Ty { @ast::Ty {id: 0, node: ty_nil, span: dummy_sp()} }\n+pub fn dtor_ty() -> @ast::Ty {\n+    @ast::Ty {id: 0, node: ty_nil, span: dummy_sp()}\n+}\n \n-fn dtor_dec() -> fn_decl {\n+pub fn dtor_dec() -> fn_decl {\n     let nil_t = dtor_ty();\n     // dtor has no args\n     ast::fn_decl {\n@@ -457,16 +460,16 @@ fn dtor_dec() -> fn_decl {\n \n #[auto_encode]\n #[auto_decode]\n-struct id_range {\n+pub struct id_range {\n     min: node_id,\n     max: node_id,\n }\n \n-fn empty(range: id_range) -> bool {\n+pub fn empty(range: id_range) -> bool {\n     range.min >= range.max\n }\n \n-fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n+pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n     visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_mod: |_m, _sp, id| vfn(id),\n \n@@ -590,11 +593,11 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n     })\n }\n \n-fn visit_ids_for_inlined_item(item: inlined_item, vfn: fn@(node_id)) {\n+pub fn visit_ids_for_inlined_item(item: inlined_item, vfn: fn@(node_id)) {\n     item.accept((), id_visitor(vfn));\n }\n \n-fn compute_id_range(visit_ids_fn: fn(fn@(node_id))) -> id_range {\n+pub fn compute_id_range(visit_ids_fn: fn(fn@(node_id))) -> id_range {\n     let min = @mut int::max_value;\n     let max = @mut int::min_value;\n     do visit_ids_fn |id| {\n@@ -604,18 +607,18 @@ fn compute_id_range(visit_ids_fn: fn(fn@(node_id))) -> id_range {\n     id_range { min: *min, max: *max }\n }\n \n-fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n+pub fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n     compute_id_range(|f| visit_ids_for_inlined_item(item, f))\n }\n \n-pure fn is_item_impl(item: @ast::item) -> bool {\n+pub pure fn is_item_impl(item: @ast::item) -> bool {\n     match item.node {\n        item_impl(*) => true,\n        _            => false\n     }\n }\n \n-fn walk_pat(pat: @pat, it: fn(@pat)) {\n+pub fn walk_pat(pat: @pat, it: fn(@pat)) {\n     it(pat);\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),\n@@ -646,7 +649,7 @@ fn walk_pat(pat: @pat, it: fn(@pat)) {\n     }\n }\n \n-fn view_path_id(p: @view_path) -> node_id {\n+pub fn view_path_id(p: @view_path) -> node_id {\n     match p.node {\n       view_path_simple(_, _, _, id) | view_path_glob(_, id) |\n       view_path_list(_, _, id) => id\n@@ -655,13 +658,13 @@ fn view_path_id(p: @view_path) -> node_id {\n \n /// Returns true if the given struct def is tuple-like; i.e. that its fields\n /// are unnamed.\n-fn struct_def_is_tuple_like(struct_def: @ast::struct_def) -> bool {\n+pub fn struct_def_is_tuple_like(struct_def: @ast::struct_def) -> bool {\n     struct_def.ctor_id.is_some()\n }\n \n \n-fn visibility_to_privacy(visibility: visibility,\n-                         legacy_exports: bool) -> Privacy {\n+pub fn visibility_to_privacy(visibility: visibility,\n+                             legacy_exports: bool) -> Privacy {\n     if legacy_exports {\n         match visibility {\n             inherited | public => Public,\n@@ -675,19 +678,19 @@ fn visibility_to_privacy(visibility: visibility,\n     }\n }\n \n-enum Privacy {\n+pub enum Privacy {\n     Private,\n     Public\n }\n \n-impl Privacy : cmp::Eq {\n+pub impl Privacy : cmp::Eq {\n     pure fn eq(&self, other: &Privacy) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n     pure fn ne(&self, other: &Privacy) -> bool { !(*self).eq(other) }\n }\n \n-fn has_legacy_export_attr(attrs: &[attribute]) -> bool {\n+pub fn has_legacy_export_attr(attrs: &[attribute]) -> bool {\n     for attrs.each |attribute| {\n         match attribute.node.value.node {\n           meta_word(ref w) if (*w) == ~\"legacy_exports\" => {"}, {"sha": "60b1b98915f5ea84797fbf65053371b5cee00d28", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 40, "deletions": 74, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -28,76 +28,36 @@ use std::map::HashMap;\n use std::map;\n use std;\n \n-// Constructors\n-export mk_name_value_item_str;\n-export mk_name_value_item;\n-export mk_list_item;\n-export mk_word_item;\n-export mk_attr;\n-export mk_sugared_doc_attr;\n-\n-// Conversion\n-export attr_meta;\n-export attr_metas;\n-export desugar_doc_attr;\n-\n-// Accessors\n-export get_attr_name;\n-export get_meta_item_name;\n-export get_meta_item_value_str;\n-export get_meta_item_list;\n-export get_name_value_str_pair;\n-\n-// Searching\n-export find_attrs_by_name;\n-export find_meta_items_by_name;\n-export contains;\n-export contains_name;\n-export attrs_contains_name;\n-export first_attr_value_str_by_name;\n-export last_meta_item_value_str_by_name;\n-export last_meta_item_list_by_name;\n-\n-// Higher-level applications\n-export sort_meta_items;\n-export remove_meta_items_by_name;\n-export find_linkage_attrs;\n-export find_linkage_metas;\n-export foreign_abi;\n-export inline_attr;\n-export find_inline_attr;\n-export require_unique_names;\n-\n /* Constructors */\n \n-fn mk_name_value_item_str(name: ~str, value: ~str) ->\n-    @ast::meta_item {\n+pub fn mk_name_value_item_str(name: ~str, value: ~str)\n+                           -> @ast::meta_item {\n     let value_lit = dummy_spanned(ast::lit_str(@value));\n     return mk_name_value_item(name, value_lit);\n }\n \n-fn mk_name_value_item(name: ~str, +value: ast::lit)\n+pub fn mk_name_value_item(name: ~str, +value: ast::lit)\n         -> @ast::meta_item {\n     return @dummy_spanned(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(name: ~str, +items: ~[@ast::meta_item]) ->\n+pub fn mk_list_item(name: ~str, +items: ~[@ast::meta_item]) ->\n    @ast::meta_item {\n     return @dummy_spanned(ast::meta_list(name, items));\n }\n \n-fn mk_word_item(name: ~str) -> @ast::meta_item {\n+pub fn mk_word_item(name: ~str) -> @ast::meta_item {\n     return @dummy_spanned(ast::meta_word(name));\n }\n \n-fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n+pub fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n     dummy_spanned(ast::attribute_ { style: ast::attr_inner,\n                                     value: *item,\n                                     is_sugared_doc: false })\n }\n \n-fn mk_sugared_doc_attr(text: ~str,\n-                       +lo: BytePos, +hi: BytePos) -> ast::attribute {\n+pub fn mk_sugared_doc_attr(text: ~str,\n+                           +lo: BytePos, +hi: BytePos) -> ast::attribute {\n     let lit = spanned(lo, hi, ast::lit_str(@text));\n     let attr = ast::attribute_ {\n         style: doc_comment_style(text),\n@@ -109,14 +69,16 @@ fn mk_sugared_doc_attr(text: ~str,\n \n /* Conversion */\n \n-fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n+pub fn attr_meta(attr: ast::attribute) -> @ast::meta_item {\n+    @attr.node.value\n+}\n \n // Get the meta_items from inside a vector of attributes\n-fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n+pub fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     do attrs.map |a| { attr_meta(*a) }\n }\n \n-fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n+pub fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n     if attr.node.is_sugared_doc {\n         let comment = get_meta_item_value_str(@attr.node.value).get();\n         let meta = mk_name_value_item_str(~\"doc\",\n@@ -129,11 +91,11 @@ fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n \n /* Accessors */\n \n-fn get_attr_name(attr: ast::attribute) -> ~str {\n+pub fn get_attr_name(attr: ast::attribute) -> ~str {\n     get_meta_item_name(@attr.node.value)\n }\n \n-fn get_meta_item_name(meta: @ast::meta_item) -> ~str {\n+pub fn get_meta_item_name(meta: @ast::meta_item) -> ~str {\n     match meta.node {\n       ast::meta_word(ref n) => (*n),\n       ast::meta_name_value(ref n, _) => (*n),\n@@ -145,7 +107,7 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ~str {\n  * Gets the string value if the meta_item is a meta_name_value variant\n  * containing a string, otherwise none\n  */\n-fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<~str> {\n+pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<~str> {\n     match meta.node {\n         ast::meta_name_value(_, v) => match v.node {\n             ast::lit_str(s) => option::Some(*s),\n@@ -156,7 +118,8 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<~str> {\n }\n \n /// Gets a list of inner meta items from a list meta_item type\n-fn get_meta_item_list(meta: @ast::meta_item) -> Option<~[@ast::meta_item]> {\n+pub fn get_meta_item_list(meta: @ast::meta_item)\n+                       -> Option<~[@ast::meta_item]> {\n     match meta.node {\n       ast::meta_list(_, l) => option::Some(/* FIXME (#2543) */ copy l),\n       _ => option::None\n@@ -167,7 +130,8 @@ fn get_meta_item_list(meta: @ast::meta_item) -> Option<~[@ast::meta_item]> {\n  * If the meta item is a nam-value type with a string value then returns\n  * a tuple containing the name and string value, otherwise `none`\n  */\n-fn get_name_value_str_pair(item: @ast::meta_item) -> Option<(~str, ~str)> {\n+pub fn get_name_value_str_pair(item: @ast::meta_item)\n+                            -> Option<(~str, ~str)> {\n     match attr::get_meta_item_value_str(item) {\n       Some(ref value) => {\n         let name = attr::get_meta_item_name(item);\n@@ -181,7 +145,7 @@ fn get_name_value_str_pair(item: @ast::meta_item) -> Option<(~str, ~str)> {\n /* Searching */\n \n /// Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n+pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n    ~[ast::attribute] {\n     let filter: &fn(a: &ast::attribute) -> Option<ast::attribute> = |a| {\n         if name == get_attr_name(*a) {\n@@ -194,7 +158,7 @@ fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n }\n \n /// Search a list of meta items and return only those with a specific name\n-fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n+pub fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n     let mut rs = ~[];\n     for metas.each |mi| {\n@@ -209,7 +173,8 @@ fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n  * Returns true if a list of meta items contains another meta item. The\n  * comparison is performed structurally.\n  */\n-fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n+pub fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item)\n+             -> bool {\n     for haystack.each |item| {\n         if eq(*item, needle) { return true; }\n     }\n@@ -239,17 +204,17 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains_name(metas: &[@ast::meta_item], name: &str) -> bool {\n+pub fn contains_name(metas: &[@ast::meta_item], name: &str) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     return vec::len(matches) > 0u;\n }\n \n-fn attrs_contains_name(attrs: &[ast::attribute], name: &str) -> bool {\n+pub fn attrs_contains_name(attrs: &[ast::attribute], name: &str) -> bool {\n     !find_attrs_by_name(attrs, name).is_empty()\n }\n \n-fn first_attr_value_str_by_name(attrs: ~[ast::attribute], name: ~str)\n-    -> Option<~str> {\n+pub fn first_attr_value_str_by_name(attrs: ~[ast::attribute], name: ~str)\n+                                 -> Option<~str> {\n \n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n@@ -265,8 +230,8 @@ fn last_meta_item_by_name(items: ~[@ast::meta_item], name: ~str)\n     vec::last_opt(items)\n }\n \n-fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: ~str)\n-    -> Option<~str> {\n+pub fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: ~str)\n+                                     -> Option<~str> {\n \n     match last_meta_item_by_name(items, name) {\n       Some(item) => match attr::get_meta_item_value_str(item) {\n@@ -277,7 +242,7 @@ fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: ~str)\n     }\n }\n \n-fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n+pub fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n     -> Option<~[@ast::meta_item]> {\n \n     match last_meta_item_by_name(items, name) {\n@@ -291,7 +256,7 @@ fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n \n // FIXME (#607): This needs to sort by meta_item variant in addition to\n // the item name (See [Fixme-sorting])\n-fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n+pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     pure fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n         pure fn key(m: &ast::meta_item) -> ~str {\n             match m.node {\n@@ -309,7 +274,7 @@ fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     vec::cast_from_mut(move v)\n }\n \n-fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n+pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n    ~[@ast::meta_item] {\n \n     return vec::filter_map(items, |item| {\n@@ -325,7 +290,7 @@ fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n  * From a list of crate attributes get only the meta_items that affect crate\n  * linkage\n  */\n-fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n+pub fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n     do find_attrs_by_name(attrs, ~\"link\").flat_map |attr| {\n         match attr.node.value.node {\n             ast::meta_list(_, items) => /* FIXME (#2543) */ copy items,\n@@ -334,7 +299,8 @@ fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n     }\n }\n \n-fn foreign_abi(attrs: ~[ast::attribute]) -> Either<~str, ast::foreign_abi> {\n+pub fn foreign_abi(attrs: ~[ast::attribute])\n+                -> Either<~str, ast::foreign_abi> {\n     return match attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n       option::None => {\n         either::Right(ast::foreign_abi_cdecl)\n@@ -354,7 +320,7 @@ fn foreign_abi(attrs: ~[ast::attribute]) -> Either<~str, ast::foreign_abi> {\n     };\n }\n \n-enum inline_attr {\n+pub enum inline_attr {\n     ia_none,\n     ia_hint,\n     ia_always,\n@@ -369,7 +335,7 @@ impl inline_attr : cmp::Eq {\n }\n \n /// True if something like #[inline] is found in the list of attrs.\n-fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n+pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n     do vec::foldl(ia_none, attrs) |ia,attr| {\n         match attr.node.value.node {\n@@ -390,8 +356,8 @@ fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n }\n \n \n-fn require_unique_names(diagnostic: span_handler,\n-                        metas: &[@ast::meta_item]) {\n+pub fn require_unique_names(diagnostic: span_handler,\n+                            metas: &[@ast::meta_item]) {\n     let map = map::HashMap();\n     for metas.each |meta| {\n         let name = get_meta_item_name(*meta);"}, {"sha": "584b2bcfdc6624bb81a43d3be07789d62342de06", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -48,71 +48,71 @@ pub enum CharPos = uint;\n // XXX: Lots of boilerplate in these impls, but so far my attempts to fix\n // have been unsuccessful\n \n-impl BytePos: Pos {\n+pub impl BytePos: Pos {\n     static pure fn from_uint(n: uint) -> BytePos { BytePos(n) }\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-impl BytePos: cmp::Eq {\n+pub impl BytePos: cmp::Eq {\n     pure fn eq(&self, other: &BytePos) -> bool { **self == **other }\n     pure fn ne(&self, other: &BytePos) -> bool { !(*self).eq(other) }\n }\n \n-impl BytePos: cmp::Ord {\n+pub impl BytePos: cmp::Ord {\n     pure fn lt(&self, other: &BytePos) -> bool { **self < **other }\n     pure fn le(&self, other: &BytePos) -> bool { **self <= **other }\n     pure fn ge(&self, other: &BytePos) -> bool { **self >= **other }\n     pure fn gt(&self, other: &BytePos) -> bool { **self > **other }\n }\n \n-impl BytePos: Add<BytePos, BytePos> {\n+pub impl BytePos: Add<BytePos, BytePos> {\n     pure fn add(&self, rhs: &BytePos) -> BytePos {\n         BytePos(**self + **rhs)\n     }\n }\n \n-impl BytePos: Sub<BytePos, BytePos> {\n+pub impl BytePos: Sub<BytePos, BytePos> {\n     pure fn sub(&self, rhs: &BytePos) -> BytePos {\n         BytePos(**self - **rhs)\n     }\n }\n \n-impl BytePos: to_bytes::IterBytes {\n+pub impl BytePos: to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n-impl CharPos: Pos {\n+pub impl CharPos: Pos {\n     static pure fn from_uint(n: uint) -> CharPos { CharPos(n) }\n     pure fn to_uint(&self) -> uint { **self }\n }\n \n-impl CharPos: cmp::Eq {\n+pub impl CharPos: cmp::Eq {\n     pure fn eq(&self, other: &CharPos) -> bool { **self == **other }\n     pure fn ne(&self, other: &CharPos) -> bool { !(*self).eq(other) }\n }\n \n-impl CharPos: cmp::Ord {\n+pub impl CharPos: cmp::Ord {\n     pure fn lt(&self, other: &CharPos) -> bool { **self < **other }\n     pure fn le(&self, other: &CharPos) -> bool { **self <= **other }\n     pure fn ge(&self, other: &CharPos) -> bool { **self >= **other }\n     pure fn gt(&self, other: &CharPos) -> bool { **self > **other }\n }\n \n-impl CharPos: to_bytes::IterBytes {\n+pub impl CharPos: to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n-impl CharPos: Add<CharPos, CharPos> {\n+pub impl CharPos: Add<CharPos, CharPos> {\n     pure fn add(&self, rhs: &CharPos) -> CharPos {\n         CharPos(**self + **rhs)\n     }\n }\n \n-impl CharPos: Sub<CharPos, CharPos> {\n+pub impl CharPos: Sub<CharPos, CharPos> {\n     pure fn sub(&self, rhs: &CharPos) -> CharPos {\n         CharPos(**self - **rhs)\n     }\n@@ -130,19 +130,19 @@ pub struct span {\n     expn_info: Option<@ExpnInfo>\n }\n \n-impl span : cmp::Eq {\n+pub impl span : cmp::Eq {\n     pure fn eq(&self, other: &span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n     }\n     pure fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n \n-impl<S: Encoder> span: Encodable<S> {\n+pub impl<S: Encoder> span: Encodable<S> {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode(&self, _s: &S) { }\n }\n \n-impl<D: Decoder> span: Decodable<D> {\n+pub impl<D: Decoder> span: Decodable<D> {\n     static fn decode(_d: &D) -> span {\n         ast_util::dummy_sp()\n     }"}, {"sha": "d2f6b7956ef48669d1a62fd9d4a929d87b78f939", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -23,18 +23,11 @@ use core::dvec::DVec;\n \n use std::term;\n \n-export emitter, collect, emit;\n-export level, fatal, error, warning, note;\n-export span_handler, handler, mk_span_handler, mk_handler;\n-export codemap_span_handler, codemap_handler;\n-export ice_msg;\n-export expect;\n-\n-type emitter = fn@(cmsp: Option<(@codemap::CodeMap, span)>,\n+pub type emitter = fn@(cmsp: Option<(@codemap::CodeMap, span)>,\n                    msg: &str, lvl: level);\n \n \n-trait span_handler {\n+pub trait span_handler {\n     fn span_fatal(sp: span, msg: &str) -> !;\n     fn span_err(sp: span, msg: &str);\n     fn span_warn(sp: span, msg: &str);\n@@ -44,7 +37,7 @@ trait span_handler {\n     fn handler() -> handler;\n }\n \n-trait handler {\n+pub trait handler {\n     fn fatal(msg: &str) -> !;\n     fn err(msg: &str);\n     fn bump_err_count();\n@@ -133,15 +126,16 @@ impl handler_t: handler {\n     }\n }\n \n-fn ice_msg(msg: &str) -> ~str {\n+pub fn ice_msg(msg: &str) -> ~str {\n     fmt!(\"internal compiler error: %s\", msg)\n }\n \n-fn mk_span_handler(handler: handler, cm: @codemap::CodeMap) -> span_handler {\n+pub fn mk_span_handler(handler: handler, cm: @codemap::CodeMap)\n+                    -> span_handler {\n     @codemap_t { handler: handler, cm: cm } as span_handler\n }\n \n-fn mk_handler(emitter: Option<emitter>) -> handler {\n+pub fn mk_handler(emitter: Option<emitter>) -> handler {\n \n     let emit = match emitter {\n       Some(e) => e,\n@@ -157,7 +151,7 @@ fn mk_handler(emitter: Option<emitter>) -> handler {\n     @handler_t { mut err_count: 0, emit: emit } as handler\n }\n \n-enum level {\n+pub enum level {\n     fatal,\n     error,\n     warning,\n@@ -205,15 +199,15 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: &str) {\n     io::stderr().write_str(fmt!(\" %s\\n\", msg));\n }\n \n-fn collect(messages: @DVec<~str>)\n+pub fn collect(messages: @DVec<~str>)\n     -> fn@(Option<(@codemap::CodeMap, span)>, &str, level)\n {\n     let f: @fn(Option<(@codemap::CodeMap, span)>, &str, level) =\n         |_o, msg: &str, _l| { messages.push(msg.to_str()); };\n     f\n }\n \n-fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n+pub fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n     match cmsp {\n       Some((cm, sp)) => {\n         let sp = cm.adjust_span(sp);\n@@ -296,8 +290,9 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n     }\n }\n \n-fn expect<T: Copy>(diag: span_handler,\n-                   opt: Option<T>, msg: fn() -> ~str) -> T {\n+pub fn expect<T: Copy>(diag: span_handler,\n+                       opt: Option<T>,\n+                       msg: fn() -> ~str) -> T {\n     match opt {\n        Some(ref t) => (*t),\n        None => diag.handler().bug(msg())"}, {"sha": "a85898390a4256c4543a0c7af3f3fcb8c85baa2c", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -28,33 +28,32 @@ use core::vec;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n-    #[legacy_exports];\n     pub use ext;\n     pub use parse;\n }\n \n-fn path(ids: ~[ident], span: span) -> @ast::path {\n+pub fn path(ids: ~[ident], span: span) -> @ast::path {\n     @ast::path { span: span,\n                  global: false,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n-fn path_global(ids: ~[ident], span: span) -> @ast::path {\n+pub fn path_global(ids: ~[ident], span: span) -> @ast::path {\n     @ast::path { span: span,\n                  global: true,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n-trait append_types {\n+pub trait append_types {\n     fn add_ty(ty: @ast::Ty) -> @ast::path;\n     fn add_tys(+tys: ~[@ast::Ty]) -> @ast::path;\n }\n \n-impl @ast::path: append_types {\n+pub impl @ast::path: append_types {\n     fn add_ty(ty: @ast::Ty) -> @ast::path {\n         @ast::path { types: vec::append_one(self.types, ty),\n                      .. *self}\n@@ -113,7 +112,7 @@ pub trait ext_ctxt_ast_builder {\n     fn strip_bounds(bounds: &[ast::ty_param]) -> ~[ast::ty_param];\n }\n \n-impl ext_ctxt: ext_ctxt_ast_builder {\n+pub impl ext_ctxt: ext_ctxt_ast_builder {\n     fn ty_option(ty: @ast::Ty) -> @ast::Ty {\n         self.ty_path_ast_builder(path_global(~[\n             self.ident_of(~\"core\"),"}, {"sha": "cde6a581dced0c59deeb0e460273b2864f786439", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -37,7 +37,7 @@ use ext::base::ext_ctxt;\n use ext::pipes::proto::{state, protocol, next_state};\n use ext::pipes::proto;\n \n-impl ext_ctxt: proto::visitor<(), (), ()>  {\n+pub impl ext_ctxt: proto::visitor<(), (), ()>  {\n     fn visit_proto(_proto: protocol,\n                    _states: &[()]) { }\n \n@@ -82,3 +82,4 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n         }\n     }\n }\n+"}, {"sha": "2e73002a8903b3a6f01c083570dfb09b6b97fbe5", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -45,7 +45,7 @@ use ext::pipes::protocol;\n use core::str;\n use std::bitv::{Bitv};\n \n-fn analyze(proto: protocol, _cx: ext_ctxt) {\n+pub fn analyze(proto: protocol, _cx: ext_ctxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n     let colive = do (copy proto.states).map_to_vec |state| {\n@@ -103,3 +103,4 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n         proto.bounded = Some(true);\n     }\n }\n+"}, {"sha": "c84ab54af2bfd22912e1872e180effa756def32c", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -56,17 +56,11 @@ use parse::parser::Parser;\n \n use core::option::None;\n \n-#[legacy_exports]\n mod ast_builder;\n-#[legacy_exports]\n mod parse_proto;\n-#[legacy_exports]\n mod pipec;\n-#[legacy_exports]\n mod proto;\n-#[legacy_exports]\n mod check;\n-#[legacy_exports]\n mod liveness;\n \n "}, {"sha": "a74214c87588dbdebb7218bff58a1a4ccd757d14", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -16,13 +16,13 @@ use parse::token;\n \n use core::prelude::*;\n \n-trait proto_parser {\n+pub trait proto_parser {\n     fn parse_proto(id: ~str) -> protocol;\n     fn parse_state(proto: protocol);\n     fn parse_message(state: state);\n }\n \n-impl parser::Parser: proto_parser {\n+pub impl parser::Parser: proto_parser {\n     fn parse_proto(id: ~str) -> protocol {\n         let proto = protocol(id, self.span);\n "}, {"sha": "928885cf81759d16a517185d0641285d07c73b4e", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -26,12 +26,12 @@ use core::str;\n use core::to_str::ToStr;\n use core::vec;\n \n-trait gen_send {\n+pub trait gen_send {\n     fn gen_send(cx: ext_ctxt, try: bool) -> @ast::item;\n     fn to_ty(cx: ext_ctxt) -> @ast::Ty;\n }\n \n-trait to_type_decls {\n+pub trait to_type_decls {\n     fn to_type_decls(cx: ext_ctxt) -> ~[@ast::item];\n     fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item];\n }\n@@ -45,7 +45,7 @@ pub trait gen_init {\n     fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr;\n }\n \n-impl message: gen_send {\n+pub impl message: gen_send {\n     fn gen_send(cx: ext_ctxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n         match self {\n@@ -201,7 +201,7 @@ impl message: gen_send {\n     }\n }\n \n-impl state: to_type_decls {\n+pub impl state: to_type_decls {\n     fn to_type_decls(cx: ext_ctxt) -> ~[@ast::item] {\n         debug!(\"pipec: to_type_decls\");\n         // This compiles into two different type declarations. Say the\n@@ -305,7 +305,7 @@ impl state: to_type_decls {\n     }\n }\n \n-impl protocol: gen_init {\n+pub impl protocol: gen_init {\n \n     fn gen_init(cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n@@ -445,4 +445,4 @@ impl protocol: gen_init {\n \n         cx.item_mod(cx.ident_of(self.name), self.span, items)\n     }\n-    }\n+}"}, {"sha": "5c2dd82eb7f712bb47755e30afaf15602a3caae5", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -19,9 +19,9 @@ use core::cmp;\n use core::dvec::DVec;\n use core::to_str::ToStr;\n \n-enum direction { send, recv }\n+pub enum direction { send, recv }\n \n-impl direction : cmp::Eq {\n+pub impl direction : cmp::Eq {\n     pure fn eq(&self, other: &direction) -> bool {\n         match ((*self), (*other)) {\n             (send, send) => true,\n@@ -33,7 +33,7 @@ impl direction : cmp::Eq {\n     pure fn ne(&self, other: &direction) -> bool { !(*self).eq(other) }\n }\n \n-impl direction: ToStr {\n+pub impl direction: ToStr {\n     pure fn to_str() -> ~str {\n         match self {\n           send => ~\"Send\",\n@@ -42,7 +42,7 @@ impl direction: ToStr {\n     }\n }\n \n-impl direction {\n+pub impl direction {\n     fn reverse() -> direction {\n         match self {\n           send => recv,\n@@ -51,17 +51,17 @@ impl direction {\n     }\n }\n \n-struct next_state {\n+pub struct next_state {\n     state: ~str,\n     tys: ~[@ast::Ty],\n }\n \n-enum message {\n+pub enum message {\n     // name, span, data, current state, next state\n     message(~str, span, ~[@ast::Ty], state, Option<next_state>)\n }\n \n-impl message {\n+pub impl message {\n     fn name() -> ~str {\n         match self {\n           message(ref id, _, _, _, _) => (*id)\n@@ -82,7 +82,7 @@ impl message {\n     }\n }\n \n-enum state {\n+pub enum state {\n     state_(@{\n         id: uint,\n         name: ~str,\n@@ -95,7 +95,7 @@ enum state {\n     }),\n }\n \n-impl state {\n+pub impl state {\n     fn add_message(name: ~str, span: span,\n                    +data: ~[@ast::Ty], next: Option<next_state>) {\n         self.messages.push(message(name, span, data, self,\n@@ -132,13 +132,13 @@ impl state {\n     }\n }\n \n-type protocol = @protocol_;\n+pub type protocol = @protocol_;\n \n-fn protocol(name: ~str, +span: span) -> protocol {\n+pub fn protocol(name: ~str, +span: span) -> protocol {\n     @protocol_(name, span)\n }\n \n-fn protocol_(name: ~str, span: span) -> protocol_ {\n+pub fn protocol_(name: ~str, span: span) -> protocol_ {\n     protocol_ {\n         name: name,\n         span: span,\n@@ -147,15 +147,15 @@ fn protocol_(name: ~str, span: span) -> protocol_ {\n     }\n }\n \n-struct protocol_ {\n+pub struct protocol_ {\n     name: ~str,\n     span: span,\n     states: DVec<state>,\n \n     mut bounded: Option<bool>,\n }\n \n-impl protocol_ {\n+pub impl protocol_ {\n \n     /// Get a state.\n     fn get_state(name: ~str) -> state {\n@@ -195,7 +195,7 @@ impl protocol_ {\n     }\n }\n \n-impl protocol {\n+pub impl protocol {\n     fn add_state_poly(name: ~str, ident: ast::ident, dir: direction,\n                       +ty_params: ~[ast::ty_param]) -> state {\n         let messages = DVec();\n@@ -216,14 +216,14 @@ impl protocol {\n     }\n }\n \n-trait visitor<Tproto, Tstate, Tmessage> {\n+pub trait visitor<Tproto, Tstate, Tmessage> {\n     fn visit_proto(proto: protocol, st: &[Tstate]) -> Tproto;\n     fn visit_state(state: state, m: &[Tmessage]) -> Tstate;\n     fn visit_message(name: ~str, spane: span, tys: &[@ast::Ty],\n                      this: state, next: Option<next_state>) -> Tmessage;\n }\n \n-fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n+pub fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n     proto: protocol, visitor: V) -> Tproto {\n \n     // the copy keywords prevent recursive use of dvec\n@@ -236,3 +236,4 @@ fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n     };\n     visitor.visit_proto(proto, states)\n }\n+"}, {"sha": "a990e53c1a7d4cf937437d1f69dc1305165a3fe1", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -189,13 +189,15 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n     fn n_rec(p_s: parse_sess, m: matcher, res: ~[@named_match],\n              ret_val: HashMap<ident, @named_match>) {\n         match m {\n-          spanned {node: match_tok(_), _} => (),\n-          spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n+          ast::spanned {node: match_tok(_), _} => (),\n+          ast::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n             for (*more_ms).each() |next_m| {\n                 n_rec(p_s, *next_m, res, ret_val)\n             };\n           }\n-          spanned {node: match_nonterminal(bind_name, _, idx), span: sp} => {\n+          ast::spanned {\n+                node: match_nonterminal(bind_name, _, idx), span: sp\n+          } => {\n             if ret_val.contains_key(bind_name) {\n                 p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n                                                *p_s.interner.get(bind_name))"}, {"sha": "3ed31c0953c95e0b7cfccb8c1d4802a6e66c860e", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -18,9 +18,7 @@ use parse::token;\n \n use core::either::{Either, Left, Right};\n \n-export parser_attr;\n-\n-trait parser_attr {\n+pub trait parser_attr {\n     fn parse_outer_attributes() -> ~[ast::attribute];\n     fn parse_attribute(style: ast::attr_style) -> ast::attribute;\n     fn parse_attribute_naked(style: ast::attr_style, lo: BytePos) ->"}, {"sha": "afe6823e76d0ebdb961b42c9304d0c9dc52a15cf", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -15,7 +15,7 @@\n use ast;\n use ast_util::operator_prec;\n \n-fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n+pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     match e.node {\n       ast::expr_if(*)\n       | ast::expr_match(*)\n@@ -28,7 +28,7 @@ fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     }\n }\n \n-fn expr_is_simple_block(e: @ast::expr) -> bool {\n+pub fn expr_is_simple_block(e: @ast::expr) -> bool {\n     match e.node {\n         ast::expr_block(\n             ast::spanned { node: ast::blk_ { rules: ast::default_blk, _ }, _ }\n@@ -37,7 +37,7 @@ fn expr_is_simple_block(e: @ast::expr) -> bool {\n     }\n }\n \n-fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n+pub fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n     return match stmt.node {\n         ast::stmt_decl(d, _) => {\n             match d.node {"}, {"sha": "26de85548e13c353ee395b5985f8672d32764125", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -27,14 +27,7 @@ use core::str;\n use core::uint;\n use core::vec;\n \n-export cmnt;\n-export lit;\n-export cmnt_style;\n-export gather_comments_and_literals;\n-export is_doc_comment, doc_comment_style, strip_doc_comment_decoration;\n-export isolated, trailing, mixed, blank_line;\n-\n-enum cmnt_style {\n+pub enum cmnt_style {\n     isolated, // No code on either side of each line of the comment\n     trailing, // Code exists to the left of the comment\n     mixed, // Code before /* foo */ and after the comment\n@@ -50,16 +43,16 @@ impl cmnt_style : cmp::Eq {\n     }\n }\n \n-type cmnt = {style: cmnt_style, lines: ~[~str], pos: BytePos};\n+pub type cmnt = {style: cmnt_style, lines: ~[~str], pos: BytePos};\n \n-fn is_doc_comment(s: ~str) -> bool {\n+pub fn is_doc_comment(s: ~str) -> bool {\n     s.starts_with(~\"///\") ||\n     s.starts_with(~\"//!\") ||\n     s.starts_with(~\"/**\") ||\n     s.starts_with(~\"/*!\")\n }\n \n-fn doc_comment_style(comment: ~str) -> ast::attr_style {\n+pub fn doc_comment_style(comment: ~str) -> ast::attr_style {\n     assert is_doc_comment(comment);\n     if comment.starts_with(~\"//!\") || comment.starts_with(~\"/*!\") {\n         ast::attr_inner\n@@ -68,7 +61,7 @@ fn doc_comment_style(comment: ~str) -> ast::attr_style {\n     }\n }\n \n-fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n+pub fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n \n     /// remove whitespace-only lines from the start/end of lines\n     fn vertical_trim(lines: ~[~str]) -> ~[~str] {\n@@ -306,11 +299,11 @@ fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n     debug!(\"<<< consume comment\");\n }\n \n-type lit = {lit: ~str, pos: BytePos};\n+pub type lit = {lit: ~str, pos: BytePos};\n \n-fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n-                                path: ~str,\n-                                srdr: io::Reader) ->\n+pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n+                                    path: ~str,\n+                                    srdr: io::Reader) ->\n    {cmnts: ~[cmnt], lits: ~[lit]} {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = parse::token::mk_fake_ident_interner();"}, {"sha": "583ad98200078b76089248bc22ef13e6c9dc3026", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -21,26 +21,26 @@ use core::option::{None, Option, Some};\n use core::option;\n use std::map::HashMap;\n \n-type seq_sep = {\n+pub type seq_sep = {\n     sep: Option<token::Token>,\n     trailing_sep_allowed: bool\n };\n \n-fn seq_sep_trailing_disallowed(t: token::Token) -> seq_sep {\n+pub fn seq_sep_trailing_disallowed(t: token::Token) -> seq_sep {\n     return {sep: option::Some(t), trailing_sep_allowed: false};\n }\n-fn seq_sep_trailing_allowed(t: token::Token) -> seq_sep {\n+pub fn seq_sep_trailing_allowed(t: token::Token) -> seq_sep {\n     return {sep: option::Some(t), trailing_sep_allowed: true};\n }\n-fn seq_sep_none() -> seq_sep {\n+pub fn seq_sep_none() -> seq_sep {\n     return {sep: option::None, trailing_sep_allowed: false};\n }\n \n-fn token_to_str(reader: reader, ++token: token::Token) -> ~str {\n+pub fn token_to_str(reader: reader, ++token: token::Token) -> ~str {\n     token::to_str(reader.interner(), token)\n }\n \n-impl Parser {\n+pub impl Parser {\n     fn unexpected_last(t: token::Token) -> ! {\n         self.span_fatal(\n             copy self.last_span,\n@@ -229,7 +229,7 @@ impl Parser {\n     }\n \n     fn parse_seq_lt_gt<T: Copy>(sep: Option<token::Token>,\n-                                f: fn(Parser) -> T) -> spanned<~[T]> {\n+                                f: fn(Parser) -> T) -> ast::spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(token::LT);\n         let result = self.parse_seq_to_before_gt::<T>(sep, f);\n@@ -277,7 +277,7 @@ impl Parser {\n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n     fn parse_seq<T: Copy>(bra: token::Token, ket: token::Token, sep: seq_sep,\n-                          f: fn(Parser) -> T) -> spanned<~[T]> {\n+                          f: fn(Parser) -> T) -> ast::spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end::<T>(ket, sep, f);"}, {"sha": "c3b94182cc2d2377d19786e4b8594488c9ee1eb8", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -16,22 +16,19 @@ use codemap::{BytePos, CharPos, CodeMap, Pos, span};\n use codemap;\n use diagnostic::span_handler;\n use ext::tt::transcribe::{tt_next_token};\n-use ext::tt::transcribe::{tt_reader, new_tt_reader, dup_tt_reader};\n+use ext::tt::transcribe::{dup_tt_reader};\n use parse::token;\n \n use core::char;\n use core::either;\n use core::str;\n use core::u64;\n \n-use std;\n+pub use ext::tt::transcribe::{tt_reader, new_tt_reader};\n \n-export reader, string_reader, new_string_reader, is_whitespace;\n-export tt_reader,  new_tt_reader;\n-export nextch, is_eof, bump, get_str_from, new_low_level_string_reader;\n-export string_reader_as_reader, tt_reader_as_reader;\n+use std;\n \n-trait reader {\n+pub trait reader {\n     fn is_eof() -> bool;\n     fn next_token() -> {tok: token::Token, sp: span};\n     fn fatal(~str) -> !;\n@@ -41,7 +38,7 @@ trait reader {\n     fn dup() -> reader;\n }\n \n-type string_reader = @{\n+pub type string_reader = @{\n     span_diagnostic: span_handler,\n     src: @~str,\n     // The absolute offset within the codemap of the next character to read\n@@ -59,18 +56,18 @@ type string_reader = @{\n     mut peek_span: span\n };\n \n-fn new_string_reader(span_diagnostic: span_handler,\n-                     filemap: @codemap::FileMap,\n-                     itr: @token::ident_interner) -> string_reader {\n+pub fn new_string_reader(span_diagnostic: span_handler,\n+                         filemap: @codemap::FileMap,\n+                         itr: @token::ident_interner) -> string_reader {\n     let r = new_low_level_string_reader(span_diagnostic, filemap, itr);\n     string_advance_token(r); /* fill in peek_* */\n     return r;\n }\n \n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n-fn new_low_level_string_reader(span_diagnostic: span_handler,\n-                               filemap: @codemap::FileMap,\n-                               itr: @token::ident_interner)\n+pub fn new_low_level_string_reader(span_diagnostic: span_handler,\n+                                   filemap: @codemap::FileMap,\n+                                   itr: @token::ident_interner)\n     -> string_reader {\n     // Force the initial reader bump to start on a fresh line\n     let initial_char = '\\n';\n@@ -114,7 +111,7 @@ impl string_reader: reader {\n     fn dup() -> reader { dup_string_reader(self) as reader }\n }\n \n-impl tt_reader: reader {\n+pub impl tt_reader: reader {\n     fn is_eof() -> bool { self.cur_tok == token::EOF }\n     fn next_token() -> {tok: token::Token, sp: span} {\n         /* weird resolve bug: if the following `if`, or any of its\n@@ -157,7 +154,7 @@ fn byte_offset(rdr: string_reader) -> BytePos {\n     (rdr.pos - rdr.filemap.start_pos)\n }\n \n-fn get_str_from(rdr: string_reader, start: BytePos) -> ~str {\n+pub fn get_str_from(rdr: string_reader, start: BytePos) -> ~str {\n     unsafe {\n         // I'm pretty skeptical about this subtraction. What if there's a\n         // multi-byte character before the mark?\n@@ -166,7 +163,7 @@ fn get_str_from(rdr: string_reader, start: BytePos) -> ~str {\n     }\n }\n \n-fn bump(rdr: string_reader) {\n+pub fn bump(rdr: string_reader) {\n     rdr.last_pos = rdr.pos;\n     let current_byte_offset = byte_offset(rdr).to_uint();;\n     if current_byte_offset < (*rdr.src).len() {\n@@ -190,10 +187,10 @@ fn bump(rdr: string_reader) {\n         rdr.curr = -1 as char;\n     }\n }\n-fn is_eof(rdr: string_reader) -> bool {\n+pub fn is_eof(rdr: string_reader) -> bool {\n     rdr.curr == -1 as char\n }\n-fn nextch(rdr: string_reader) -> char {\n+pub fn nextch(rdr: string_reader) -> char {\n     let offset = byte_offset(rdr).to_uint();\n     if offset < (*rdr.src).len() {\n         return str::char_at(*rdr.src, offset);\n@@ -211,7 +208,7 @@ fn hex_digit_val(c: char) -> int {\n \n fn bin_digit_value(c: char) -> int { if c == '0' { return 0; } return 1; }\n \n-fn is_whitespace(c: char) -> bool {\n+pub fn is_whitespace(c: char) -> bool {\n     return c == ' ' || c == '\\t' || c == '\\r' || c == '\\n';\n }\n "}, {"sha": "f9088bfd6354ffed5aadae6f062aec791e2e1e79", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -27,32 +27,22 @@ use core::path::Path;\n use core::result::{Err, Ok, Result};\n use core::result;\n \n-#[legacy_exports]\n pub mod lexer;\n-#[legacy_exports]\n pub mod parser;\n-#[legacy_exports]\n pub mod token;\n-#[legacy_exports]\n pub mod comments;\n-#[legacy_exports]\n pub mod attr;\n-#[legacy_exports]\n \n /// Common routines shared by parser mods\n-#[legacy_exports]\n pub mod common;\n \n /// Functions dealing with operator precedence\n-#[legacy_exports]\n pub mod prec;\n \n /// Routines the parser uses to classify AST nodes\n-#[legacy_exports]\n pub mod classify;\n \n /// Reporting obsolete syntax\n-#[legacy_exports]\n pub mod obsolete;\n \n pub type parse_sess = @{"}, {"sha": "7dad15f9dfc4335c205d11dd1bc9857ee46dc7c6", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -50,14 +50,14 @@ pub enum ObsoleteSyntax {\n     ObsoleteUnenforcedBound\n }\n \n-impl ObsoleteSyntax: to_bytes::IterBytes {\n+pub impl ObsoleteSyntax: to_bytes::IterBytes {\n     #[inline(always)]\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n \n-impl Parser {\n+pub impl Parser {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(sp: span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {"}, {"sha": "25fd13a59999fdd3d54549e99c4d238b85c6c954", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -88,10 +88,6 @@ use core::vec::push;\n use core::vec;\n use std::map::HashMap;\n \n-export Parser;\n-\n-export item_or_view_item, iovi_none, iovi_view_item, iovi_item;\n-\n enum restriction {\n     UNRESTRICTED,\n     RESTRICT_STMT_EXPR,\n@@ -108,7 +104,7 @@ enum class_contents { dtor_decl(blk, ~[attribute], codemap::span),\n type arg_or_capture_item = Either<arg, capture_item>;\n type item_info = (ident, item_, Option<~[attribute]>);\n \n-enum item_or_view_item {\n+pub enum item_or_view_item {\n     iovi_none,\n     iovi_item(@item),\n     iovi_foreign_item(@foreign_item),\n@@ -180,8 +176,9 @@ pure fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n \n /* ident is handled by common.rs */\n \n-fn Parser(sess: parse_sess, cfg: ast::crate_cfg,\n-          +rdr: reader) -> Parser {\n+pub fn Parser(sess: parse_sess,\n+              cfg: ast::crate_cfg,\n+              +rdr: reader) -> Parser {\n \n     let tok0 = rdr.next_token();\n     let span0 = tok0.sp;\n@@ -209,7 +206,7 @@ fn Parser(sess: parse_sess, cfg: ast::crate_cfg,\n     }\n }\n \n-struct Parser {\n+pub struct Parser {\n     sess: parse_sess,\n     cfg: crate_cfg,\n     mut token: token::Token,\n@@ -235,7 +232,7 @@ struct Parser {\n     drop {} /* do not copy the parser; its state is tied to outside state */\n }\n \n-impl Parser {\n+pub impl Parser {\n     fn bump() {\n         self.last_span = self.span;\n         let next = if self.buffer_start == self.buffer_end {\n@@ -813,7 +810,7 @@ impl Parser {\n             self.bump();\n             self.lit_from_token(tok)\n         };\n-        spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n+        ast::spanned { node: lit, span: mk_sp(lo, self.last_span.hi) }\n     }\n \n     fn parse_path_without_tps() -> @path {\n@@ -888,7 +885,7 @@ impl Parser {\n                 self.parse_seq_lt_gt(Some(token::COMMA),\n                                      |p| p.parse_ty(false))\n             } else {\n-                spanned {node: ~[], span: path.span}\n+                ast::spanned {node: ~[], span: path.span}\n             }\n         };\n \n@@ -930,15 +927,15 @@ impl Parser {\n         @expr {\n             id: self.get_id(),\n             callee_id: self.get_id(),\n-            node: expr_mac(spanned {node: m, span: mk_sp(lo, hi)}),\n+            node: expr_mac(ast::spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n         }\n     }\n \n     fn mk_lit_u32(i: u32) -> @expr {\n         let span = self.span;\n-        let lv_lit = @spanned { node: lit_uint(i as u64, ty_u32),\n-                                span: span };\n+        let lv_lit = @ast::spanned { node: lit_uint(i as u64, ty_u32),\n+                                     span: span };\n \n         @expr {\n             id: self.get_id(),\n@@ -1418,7 +1415,9 @@ impl Parser {\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n                 ex = match e.node {\n-                  expr_vec(*) | expr_lit(@spanned {node: lit_str(_), span: _})\n+                  expr_vec(*) | expr_lit(@ast::spanned {\n+                    node: lit_str(_), span: _\n+                  })\n                   if m == m_imm => {\n                     expr_vstore(e, expr_vstore_slice)\n                   }\n@@ -1441,7 +1440,8 @@ impl Parser {\n               expr_vec(*) if m == m_mutbl =>\n                 expr_vstore(e, expr_vstore_mut_box),\n               expr_vec(*) if m == m_imm => expr_vstore(e, expr_vstore_box),\n-              expr_lit(@spanned {node: lit_str(_), span: _}) if m == m_imm =>\n+              expr_lit(@ast::spanned {\n+                  node: lit_str(_), span: _}) if m == m_imm =>\n                 expr_vstore(e, expr_vstore_box),\n               _ => expr_unary(box(m), e)\n             };\n@@ -1453,7 +1453,8 @@ impl Parser {\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n             ex = match e.node {\n-              expr_vec(*) | expr_lit(@spanned {node: lit_str(_), span: _})\n+              expr_vec(*) | expr_lit(@ast::spanned {\n+                node: lit_str(_), span: _})\n               if m == m_imm => expr_vstore(e, expr_vstore_uniq),\n               _ => expr_unary(uniq(m), e)\n             };\n@@ -1808,7 +1809,7 @@ impl Parser {\n                 self.eat(token::COMMA);\n             }\n \n-            let blk = spanned {\n+            let blk = ast::spanned {\n                 node: ast::blk_ {\n                     view_items: ~[],\n                     stmts: ~[],\n@@ -1957,7 +1958,7 @@ impl Parser {\n             // HACK: parse @\"...\" as a literal of a vstore @str\n             pat = match sub.node {\n               pat_lit(e@@expr {\n-                node: expr_lit(@spanned {node: lit_str(_), span: _}), _\n+                node: expr_lit(@ast::spanned {node: lit_str(_), span: _}), _\n               }) => {\n                 let vst = @expr {\n                     id: self.get_id(),\n@@ -1977,7 +1978,7 @@ impl Parser {\n             // HACK: parse ~\"...\" as a literal of a vstore ~str\n             pat = match sub.node {\n               pat_lit(e@@expr {\n-                node: expr_lit(@spanned {node: lit_str(_), span: _}), _\n+                node: expr_lit(@ast::spanned {node: lit_str(_), span: _}), _\n               }) => {\n                 let vst = @expr {\n                     id: self.get_id(),\n@@ -1999,7 +2000,8 @@ impl Parser {\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n                   pat_lit(e@@expr {\n-                      node: expr_lit(@spanned {node: lit_str(_), span: _}), _\n+                      node: expr_lit(@ast::spanned {\n+                            node: lit_str(_), span: _}), _\n                   }) => {\n                       let vst = @expr {\n                           id: self.get_id(),\n@@ -2024,7 +2026,7 @@ impl Parser {\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = @spanned {node: lit_nil, span: mk_sp(lo, hi)};\n+                let lit = @ast::spanned {node: lit_nil, span: mk_sp(lo, hi)};\n                 let expr = self.mk_expr(lo, hi, expr_lit(lit));\n                 pat = pat_lit(expr);\n             } else {\n@@ -2400,7 +2402,7 @@ impl Parser {\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@spanned {\n+                                    stmts.push(@ast::spanned {\n                                         node: stmt_semi(e, stmt_id),\n                                         .. *stmt});\n                                 }\n@@ -2425,7 +2427,7 @@ impl Parser {\n                             match self.token {\n                                 token::SEMI => {\n                                     self.bump();\n-                                    stmts.push(@spanned {\n+                                    stmts.push(@ast::spanned {\n                                         node: stmt_mac((*m), true),\n                                         .. *stmt});\n                                 }\n@@ -2967,10 +2969,10 @@ impl Parser {\n \n         let actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = *dtor;\n-            spanned { node: ast::struct_dtor_ { id: self.get_id(),\n-                                                attrs: d_attrs,\n-                                                self_id: self.get_id(),\n-                                                body: d_body},\n+            ast::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n+                                                     attrs: d_attrs,\n+                                                     self_id: self.get_id(),\n+                                                     body: d_body},\n                        span: d_s}};\n         let _ = self.get_id();  // XXX: Workaround for crazy bug.\n         let new_id = self.get_id();\n@@ -3472,10 +3474,10 @@ impl Parser {\n         self.bump();\n         let mut actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = *dtor;\n-            spanned { node: ast::struct_dtor_ { id: self.get_id(),\n-                                                attrs: d_attrs,\n-                                                self_id: self.get_id(),\n-                                                body: d_body },\n+            ast::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n+                                                     attrs: d_attrs,\n+                                                     self_id: self.get_id(),\n+                                                     body: d_body },\n                       span: d_s }\n         };\n \n@@ -3773,9 +3775,9 @@ impl Parser {\n               _ => self.fatal(~\"expected open delimiter\")\n             };\n             let m = ast::mac_invoc_tt(pth, tts);\n-            let m: ast::mac = spanned { node: m,\n-                                        span: mk_sp(self.span.lo,\n-                                                    self.span.hi) };\n+            let m: ast::mac = ast::spanned { node: m,\n+                                             span: mk_sp(self.span.lo,\n+                                                         self.span.hi) };\n             let item_ = item_mac(m);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, id, item_,\n                                           visibility, attrs));"}, {"sha": "fff222876aa1912d0752612a09f91439cf15b5d7", "filename": "src/libsyntax/parse/prec.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fprec.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -8,30 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-export as_prec;\n-export unop_prec;\n-export token_to_binop;\n-\n use ast::*;\n use parse::token::*;\n use parse::token::Token;\n \n use core::prelude::*;\n \n /// Unary operators have higher precedence than binary\n-const unop_prec: uint = 100u;\n+pub const unop_prec: uint = 100u;\n \n /**\n  * Precedence of the `as` operator, which is a binary operator\n  * but is not represented in the precedence table.\n  */\n-const as_prec: uint = 11u;\n+pub const as_prec: uint = 11u;\n \n /**\n  * Maps a token to a record specifying the corresponding binary\n  * operator and its precedence\n  */\n-fn token_to_binop(tok: Token) -> Option<ast::binop> {\n+pub fn token_to_binop(tok: Token) -> Option<ast::binop> {\n   match tok {\n       BINOP(STAR)    => Some(mul),\n       BINOP(SLASH)   => Some(div),"}, {"sha": "30d2489a5eeb2180827c5945b36b57bc3cdb152b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 62, "deletions": 61, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -25,7 +25,7 @@ use std::map::HashMap;\n \n #[auto_encode]\n #[auto_decode]\n-enum binop {\n+pub enum binop {\n     PLUS,\n     MINUS,\n     STAR,\n@@ -40,7 +40,7 @@ enum binop {\n \n #[auto_encode]\n #[auto_decode]\n-enum Token {\n+pub enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n     LT,\n@@ -99,7 +99,7 @@ enum Token {\n #[auto_encode]\n #[auto_decode]\n /// For interpolation during macro expansion.\n-enum nonterminal {\n+pub enum nonterminal {\n     nt_item(@ast::item),\n     nt_block(ast::blk),\n     nt_stmt(@ast::stmt),\n@@ -112,7 +112,7 @@ enum nonterminal {\n     nt_matchers(~[ast::matcher])\n }\n \n-fn binop_to_str(o: binop) -> ~str {\n+pub fn binop_to_str(o: binop) -> ~str {\n     match o {\n       PLUS => ~\"+\",\n       MINUS => ~\"-\",\n@@ -127,7 +127,7 @@ fn binop_to_str(o: binop) -> ~str {\n     }\n }\n \n-fn to_str(in: @ident_interner, t: Token) -> ~str {\n+pub fn to_str(in: @ident_interner, t: Token) -> ~str {\n     match t {\n       EQ => ~\"=\",\n       LT => ~\"<\",\n@@ -222,7 +222,7 @@ fn to_str(in: @ident_interner, t: Token) -> ~str {\n     }\n }\n \n-pure fn can_begin_expr(t: Token) -> bool {\n+pub pure fn can_begin_expr(t: Token) -> bool {\n     match t {\n       LPAREN => true,\n       LBRACE => true,\n@@ -254,7 +254,7 @@ pure fn can_begin_expr(t: Token) -> bool {\n }\n \n /// what's the opposite delimiter?\n-fn flip_delimiter(t: token::Token) -> token::Token {\n+pub fn flip_delimiter(t: token::Token) -> token::Token {\n     match t {\n       token::LPAREN => token::RPAREN,\n       token::LBRACE => token::RBRACE,\n@@ -268,7 +268,7 @@ fn flip_delimiter(t: token::Token) -> token::Token {\n \n \n \n-fn is_lit(t: Token) -> bool {\n+pub fn is_lit(t: Token) -> bool {\n     match t {\n       LIT_INT(_, _) => true,\n       LIT_UINT(_, _) => true,\n@@ -280,79 +280,80 @@ fn is_lit(t: Token) -> bool {\n     }\n }\n \n-pure fn is_ident(t: Token) -> bool {\n+pub pure fn is_ident(t: Token) -> bool {\n     match t { IDENT(_, _) => true, _ => false }\n }\n \n-pure fn is_ident_or_path(t: Token) -> bool {\n+pub pure fn is_ident_or_path(t: Token) -> bool {\n     match t {\n       IDENT(_, _) | INTERPOLATED(nt_path(*)) => true,\n       _ => false\n     }\n }\n \n-pure fn is_plain_ident(t: Token) -> bool {\n+pub pure fn is_plain_ident(t: Token) -> bool {\n     match t { IDENT(_, false) => true, _ => false }\n }\n \n-pure fn is_bar(t: Token) -> bool {\n+pub pure fn is_bar(t: Token) -> bool {\n     match t { BINOP(OR) | OROR => true, _ => false }\n }\n \n \n-mod special_idents {\n-    #[legacy_exports];\n+pub mod special_idents {\n     use ast::ident;\n-    const underscore : ident = ident { repr: 0u };\n-    const anon : ident = ident { repr: 1u };\n-    const dtor : ident = ident { repr: 2u }; // 'drop', but that's reserved\n-    const invalid : ident = ident { repr: 3u }; // ''\n-    const unary : ident = ident { repr: 4u };\n-    const not_fn : ident = ident { repr: 5u };\n-    const idx_fn : ident = ident { repr: 6u };\n-    const unary_minus_fn : ident = ident { repr: 7u };\n-    const clownshoes_extensions : ident = ident { repr: 8u };\n-\n-    const self_ : ident = ident { repr: 9u }; // 'self'\n+\n+    pub const underscore : ident = ident { repr: 0u };\n+    pub const anon : ident = ident { repr: 1u };\n+    pub const dtor : ident = ident { repr: 2u }; // 'drop', but that's\n+                                                 // reserved\n+    pub const invalid : ident = ident { repr: 3u }; // ''\n+    pub const unary : ident = ident { repr: 4u };\n+    pub const not_fn : ident = ident { repr: 5u };\n+    pub const idx_fn : ident = ident { repr: 6u };\n+    pub const unary_minus_fn : ident = ident { repr: 7u };\n+    pub const clownshoes_extensions : ident = ident { repr: 8u };\n+\n+    pub const self_ : ident = ident { repr: 9u }; // 'self'\n \n     /* for matcher NTs */\n-    const item : ident = ident { repr: 10u };\n-    const block : ident = ident { repr: 11u };\n-    const stmt : ident = ident { repr: 12u };\n-    const pat : ident = ident { repr: 13u };\n-    const expr : ident = ident { repr: 14u };\n-    const ty : ident = ident { repr: 15u };\n-    const ident : ident = ident { repr: 16u };\n-    const path : ident = ident { repr: 17u };\n-    const tt : ident = ident { repr: 18u };\n-    const matchers : ident = ident { repr: 19u };\n-\n-    const str : ident = ident { repr: 20u }; // for the type\n+    pub const item : ident = ident { repr: 10u };\n+    pub const block : ident = ident { repr: 11u };\n+    pub const stmt : ident = ident { repr: 12u };\n+    pub const pat : ident = ident { repr: 13u };\n+    pub const expr : ident = ident { repr: 14u };\n+    pub const ty : ident = ident { repr: 15u };\n+    pub const ident : ident = ident { repr: 16u };\n+    pub const path : ident = ident { repr: 17u };\n+    pub const tt : ident = ident { repr: 18u };\n+    pub const matchers : ident = ident { repr: 19u };\n+\n+    pub const str : ident = ident { repr: 20u }; // for the type\n \n     /* outside of libsyntax */\n-    const ty_visitor : ident = ident { repr: 21u };\n-    const arg : ident = ident { repr: 22u };\n-    const descrim : ident = ident { repr: 23u };\n-    const clownshoe_abi : ident = ident { repr: 24u };\n-    const clownshoe_stack_shim : ident = ident { repr: 25u };\n-    const tydesc : ident = ident { repr: 26u };\n-    const literally_dtor : ident = ident { repr: 27u };\n-    const main : ident = ident { repr: 28u };\n-    const opaque : ident = ident { repr: 29u };\n-    const blk : ident = ident { repr: 30u };\n-    const static : ident = ident { repr: 31u };\n-    const intrinsic : ident = ident { repr: 32u };\n-    const clownshoes_foreign_mod: ident = ident { repr: 33 };\n-    const unnamed_field: ident = ident { repr: 34 };\n-    const c_abi: ident = ident { repr: 35 };\n-    const type_self: ident = ident { repr: 36 };    // `Self`\n+    pub const ty_visitor : ident = ident { repr: 21u };\n+    pub const arg : ident = ident { repr: 22u };\n+    pub const descrim : ident = ident { repr: 23u };\n+    pub const clownshoe_abi : ident = ident { repr: 24u };\n+    pub const clownshoe_stack_shim : ident = ident { repr: 25u };\n+    pub const tydesc : ident = ident { repr: 26u };\n+    pub const literally_dtor : ident = ident { repr: 27u };\n+    pub const main : ident = ident { repr: 28u };\n+    pub const opaque : ident = ident { repr: 29u };\n+    pub const blk : ident = ident { repr: 30u };\n+    pub const static : ident = ident { repr: 31u };\n+    pub const intrinsic : ident = ident { repr: 32u };\n+    pub const clownshoes_foreign_mod: ident = ident { repr: 33 };\n+    pub const unnamed_field: ident = ident { repr: 34 };\n+    pub const c_abi: ident = ident { repr: 35 };\n+    pub const type_self: ident = ident { repr: 36 };    // `Self`\n }\n \n-struct ident_interner {\n+pub struct ident_interner {\n     priv interner: Interner<@~str>,\n }\n \n-impl ident_interner {\n+pub impl ident_interner {\n     fn intern(val: @~str) -> ast::ident {\n         ast::ident { repr: self.interner.intern(val) }\n     }\n@@ -377,7 +378,7 @@ macro_rules! interner_key (\n         (-3 as uint, 0u)))\n )\n \n-fn mk_ident_interner() -> @ident_interner {\n+pub fn mk_ident_interner() -> @ident_interner {\n     unsafe {\n         match task::local_data::local_data_get(interner_key!()) {\n             Some(interner) => *interner,\n@@ -438,7 +439,7 @@ fn mk_ident_interner() -> @ident_interner {\n \n /* for when we don't care about the contents; doesn't interact with TLD or\n    serialization */\n-fn mk_fake_ident_interner() -> @ident_interner {\n+pub fn mk_fake_ident_interner() -> @ident_interner {\n     @ident_interner { interner: interner::mk::<@~str>() }\n }\n \n@@ -451,7 +452,7 @@ fn mk_fake_ident_interner() -> @ident_interner {\n  * appear as identifiers at all. Reserved keywords are not used anywhere in\n  * the language and may not appear as identifiers.\n  */\n-fn keyword_table() -> HashMap<~str, ()> {\n+pub fn keyword_table() -> HashMap<~str, ()> {\n     let keywords = HashMap();\n     for temporary_keyword_table().each_key |word| {\n         keywords.insert(word, ());\n@@ -466,7 +467,7 @@ fn keyword_table() -> HashMap<~str, ()> {\n }\n \n /// Keywords that may be used as identifiers\n-fn temporary_keyword_table() -> HashMap<~str, ()> {\n+pub fn temporary_keyword_table() -> HashMap<~str, ()> {\n     let words = HashMap();\n     let keys = ~[\n         ~\"self\", ~\"static\",\n@@ -478,7 +479,7 @@ fn temporary_keyword_table() -> HashMap<~str, ()> {\n }\n \n /// Full keywords. May not appear anywhere else.\n-fn strict_keyword_table() -> HashMap<~str, ()> {\n+pub fn strict_keyword_table() -> HashMap<~str, ()> {\n     let words = HashMap();\n     let keys = ~[\n         ~\"as\", ~\"assert\",\n@@ -504,7 +505,7 @@ fn strict_keyword_table() -> HashMap<~str, ()> {\n     words\n }\n \n-fn reserved_keyword_table() -> HashMap<~str, ()> {\n+pub fn reserved_keyword_table() -> HashMap<~str, ()> {\n     let words = HashMap();\n     let keys = ~[\n         ~\"be\""}, {"sha": "632e50176e9216623254957522fcf0a078e0e131", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -593,7 +593,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n \n fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n                   params: ~[ast::ty_param], ident: ast::ident,\n-                  span: ast::span, visibility: ast::visibility) {\n+                  span: codemap::span, visibility: ast::visibility) {\n     let mut newtype =\n         vec::len(enum_definition.variants) == 1u &&\n         ident == enum_definition.variants[0].node.name;\n@@ -626,7 +626,7 @@ fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n     }\n }\n \n-fn print_variants(s: ps, variants: ~[ast::variant], span: ast::span) {\n+fn print_variants(s: ps, variants: ~[ast::variant], span: codemap::span) {\n     bopen(s);\n     for variants.each |v| {\n         space_if_not_bol(s);\n@@ -666,7 +666,7 @@ fn print_visibility(s: ps, vis: ast::visibility) {\n }\n \n fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n-                ident: ast::ident, span: ast::span) {\n+                ident: ast::ident, span: codemap::span) {\n     print_ident(s, ident);\n     nbsp(s);\n     print_type_params(s, tps);"}, {"sha": "474b1f3b240f11dcb83cf5feaddf686fc225a517", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/95b892c8a723ad88e868e3914c3d29a585008ac2/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=95b892c8a723ad88e868e3914c3d29a585008ac2", "patch": "@@ -38,17 +38,11 @@ pub mod syntax {\n     pub use parse;\n }\n \n-#[legacy_exports]\n mod attr;\n-#[legacy_exports]\n mod diagnostic;\n-#[legacy_records]\n mod codemap;\n-#[legacy_exports]\n mod ast;\n-#[legacy_exports]\n mod ast_util;\n-#[legacy_exports]\n mod ast_map;\n #[legacy_exports]\n mod visit;"}]}