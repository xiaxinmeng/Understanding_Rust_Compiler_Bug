{"sha": "485aec41affd054cecc70a73d424b6f4c0f59b98", "node_id": "C_kwDOAAsO6NoAKDQ4NWFlYzQxYWZmZDA1NGNlY2M3MGE3M2Q0MjRiNmY0YzBmNTliOTg", "commit": {"author": {"name": "Kai Luo", "email": "lkail@cn.ibm.com", "date": "2023-03-23T07:00:46Z"}, "committer": {"name": "Kai Luo", "email": "lkail@cn.ibm.com", "date": "2023-03-23T07:00:46Z"}, "message": "Add AixLinker to support linking on AIX", "tree": {"sha": "b05e7b7f4d89d8fb281ebc1651f9a80073c082db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b05e7b7f4d89d8fb281ebc1651f9a80073c082db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/485aec41affd054cecc70a73d424b6f4c0f59b98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/485aec41affd054cecc70a73d424b6f4c0f59b98", "html_url": "https://github.com/rust-lang/rust/commit/485aec41affd054cecc70a73d424b6f4c0f59b98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/485aec41affd054cecc70a73d424b6f4c0f59b98/comments", "author": {"login": "bzEq", "id": 3006405, "node_id": "MDQ6VXNlcjMwMDY0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/3006405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bzEq", "html_url": "https://github.com/bzEq", "followers_url": "https://api.github.com/users/bzEq/followers", "following_url": "https://api.github.com/users/bzEq/following{/other_user}", "gists_url": "https://api.github.com/users/bzEq/gists{/gist_id}", "starred_url": "https://api.github.com/users/bzEq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bzEq/subscriptions", "organizations_url": "https://api.github.com/users/bzEq/orgs", "repos_url": "https://api.github.com/users/bzEq/repos", "events_url": "https://api.github.com/users/bzEq/events{/privacy}", "received_events_url": "https://api.github.com/users/bzEq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bzEq", "id": 3006405, "node_id": "MDQ6VXNlcjMwMDY0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/3006405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bzEq", "html_url": "https://github.com/bzEq", "followers_url": "https://api.github.com/users/bzEq/followers", "following_url": "https://api.github.com/users/bzEq/following{/other_user}", "gists_url": "https://api.github.com/users/bzEq/gists{/gist_id}", "starred_url": "https://api.github.com/users/bzEq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bzEq/subscriptions", "organizations_url": "https://api.github.com/users/bzEq/orgs", "repos_url": "https://api.github.com/users/bzEq/repos", "events_url": "https://api.github.com/users/bzEq/events{/privacy}", "received_events_url": "https://api.github.com/users/bzEq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c771fec3329ef1d8c66697daf9517501d0c129a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c771fec3329ef1d8c66697daf9517501d0c129a", "html_url": "https://github.com/rust-lang/rust/commit/1c771fec3329ef1d8c66697daf9517501d0c129a"}], "stats": {"total": 173, "additions": 173, "deletions": 0}, "files": [{"sha": "9b46e1115e7664db63396bfe71f81a06a9a89852", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/485aec41affd054cecc70a73d424b6f4c0f59b98/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/485aec41affd054cecc70a73d424b6f4c0f59b98/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=485aec41affd054cecc70a73d424b6f4c0f59b98", "patch": "@@ -133,6 +133,9 @@ pub fn get_linker<'a>(\n         LinkerFlavor::Unix(Cc::No) if sess.target.os == \"l4re\" => {\n             Box::new(L4Bender::new(cmd, sess)) as Box<dyn Linker>\n         }\n+        LinkerFlavor::Unix(Cc::No) if sess.target.os == \"aix\" => {\n+            Box::new(AixLinker::new(cmd, sess)) as Box<dyn Linker>\n+        }\n         LinkerFlavor::WasmLld(Cc::No) => Box::new(WasmLd::new(cmd, sess)) as Box<dyn Linker>,\n         LinkerFlavor::Gnu(cc, _)\n         | LinkerFlavor::Darwin(cc, _)\n@@ -1474,6 +1477,176 @@ impl<'a> L4Bender<'a> {\n     }\n }\n \n+/// Linker for AIX.\n+pub struct AixLinker<'a> {\n+    cmd: Command,\n+    sess: &'a Session,\n+    hinted_static: bool,\n+}\n+\n+impl<'a> AixLinker<'a> {\n+    pub fn new(cmd: Command, sess: &'a Session) -> AixLinker<'a> {\n+        AixLinker { cmd: cmd, sess: sess, hinted_static: false }\n+    }\n+\n+    fn hint_static(&mut self) {\n+        if !self.hinted_static {\n+            self.cmd.arg(\"-bstatic\");\n+            self.hinted_static = true;\n+        }\n+    }\n+\n+    fn hint_dynamic(&mut self) {\n+        if self.hinted_static {\n+            self.cmd.arg(\"-bdynamic\");\n+            self.hinted_static = false;\n+        }\n+    }\n+\n+    fn build_dylib(&mut self, _out_filename: &Path) {\n+        self.cmd.arg(\"-bM:SRE\");\n+        self.cmd.arg(\"-bnoentry\");\n+        // FIXME: Use CreateExportList utility to create export list\n+        // and remove -bexpfull.\n+        self.cmd.arg(\"-bexpfull\");\n+    }\n+}\n+\n+impl<'a> Linker for AixLinker<'a> {\n+    fn link_dylib(&mut self, lib: &str, _verbatim: bool, _as_needed: bool) {\n+        self.hint_dynamic();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n+    }\n+\n+    fn link_staticlib(&mut self, lib: &str, _verbatim: bool) {\n+        self.hint_static();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n+    }\n+\n+    fn link_rlib(&mut self, lib: &Path) {\n+        self.hint_static();\n+        self.cmd.arg(lib);\n+    }\n+\n+    fn include_path(&mut self, path: &Path) {\n+        self.cmd.arg(\"-L\").arg(path);\n+    }\n+\n+    fn framework_path(&mut self, _: &Path) {\n+        bug!(\"frameworks are not supported on L4Re\");\n+    }\n+\n+    fn output_filename(&mut self, path: &Path) {\n+        self.cmd.arg(\"-o\").arg(path);\n+    }\n+\n+    fn add_object(&mut self, path: &Path) {\n+        self.cmd.arg(path);\n+    }\n+\n+    fn full_relro(&mut self) {}\n+\n+    fn partial_relro(&mut self) {}\n+\n+    fn no_relro(&mut self) {}\n+\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicDylib => {\n+                self.hint_dynamic();\n+                self.build_dylib(out_filename);\n+            }\n+            LinkOutputKind::StaticDylib => {\n+                self.hint_static();\n+                self.build_dylib(out_filename);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn link_rust_dylib(&mut self, lib: &str, _: &Path) {\n+        self.hint_dynamic();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n+    }\n+\n+    fn link_framework(&mut self, _framework: &str, _as_needed: bool) {\n+        bug!(\"frameworks not supported on AIX\");\n+    }\n+\n+    fn link_whole_staticlib(&mut self, lib: &str, verbatim: bool, search_path: &[PathBuf]) {\n+        self.hint_static();\n+        let lib = find_native_static_library(lib, verbatim, search_path, &self.sess);\n+        self.cmd.arg(format!(\"-bkeepfile:{}\", lib.to_str().unwrap()));\n+    }\n+\n+    fn link_whole_rlib(&mut self, lib: &Path) {\n+        self.hint_static();\n+        self.cmd.arg(format!(\"-bkeepfile:{}\", lib.to_str().unwrap()));\n+    }\n+\n+    fn gc_sections(&mut self, _keep_metadata: bool) {\n+        self.cmd.arg(\"-bgc\");\n+    }\n+\n+    fn no_gc_sections(&mut self) {\n+        self.cmd.arg(\"-bnogc\");\n+    }\n+\n+    fn optimize(&mut self) {}\n+\n+    fn pgo_gen(&mut self) {}\n+\n+    fn control_flow_guard(&mut self) {}\n+\n+    fn debuginfo(&mut self, strip: Strip, _: &[PathBuf]) {\n+        match strip {\n+            Strip::None => {}\n+            Strip::Debuginfo => {}\n+            Strip::Symbols => {\n+                self.cmd.arg(\"-s\");\n+            }\n+        }\n+    }\n+\n+    fn no_crt_objects(&mut self) {}\n+\n+    fn no_default_libraries(&mut self) {}\n+\n+    fn export_symbols(&mut self, tmpdir: &Path, _crate_type: CrateType, symbols: &[String]) {\n+        let path = tmpdir.join(\"list.exp\");\n+        let res: io::Result<()> = try {\n+            let mut f = BufWriter::new(File::create(&path)?);\n+            // TODO: use llvm-nm to generate export list.\n+            for symbol in symbols {\n+                debug!(\"  _{}\", symbol);\n+                writeln!(f, \"  {}\", symbol)?;\n+            }\n+        };\n+        if let Err(e) = res {\n+            self.sess.fatal(&format!(\"failed to write export file: {}\", e));\n+        }\n+        self.cmd.arg(format!(\"-bE:{}\", path.to_str().unwrap()));\n+    }\n+\n+    fn subsystem(&mut self, _subsystem: &str) {}\n+\n+    fn reset_per_library_state(&mut self) {\n+        self.hint_dynamic();\n+    }\n+\n+    fn linker_plugin_lto(&mut self) {}\n+\n+    fn add_eh_frame_header(&mut self) {}\n+\n+    fn add_no_exec(&mut self) {}\n+\n+    fn add_as_needed(&mut self) {}\n+}\n+\n fn for_each_exported_symbols_include_dep<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     crate_type: CrateType,"}]}