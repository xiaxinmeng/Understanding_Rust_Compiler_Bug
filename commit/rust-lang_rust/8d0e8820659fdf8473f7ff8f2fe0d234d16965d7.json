{"sha": "8d0e8820659fdf8473f7ff8f2fe0d234d16965d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMGU4ODIwNjU5ZmRmODQ3M2Y3ZmY4ZjJmZTBkMjM0ZDE2OTY1ZDc=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-06-21T14:34:18Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-06-21T19:10:19Z"}, "message": "Fix handling of reserved registers for ARM inline asm", "tree": {"sha": "baede91eed4a2c747954540a0222c93e41e02e3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baede91eed4a2c747954540a0222c93e41e02e3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7", "html_url": "https://github.com/rust-lang/rust/commit/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7adbc0dfeffcb6c2ae489cc97d28f76612c7cdf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7adbc0dfeffcb6c2ae489cc97d28f76612c7cdf3", "html_url": "https://github.com/rust-lang/rust/commit/7adbc0dfeffcb6c2ae489cc97d28f76612c7cdf3"}], "stats": {"total": 85, "additions": 67, "deletions": 18}, "files": [{"sha": "23e0da4cf32a0e1b6b304b0e6d66b8c63cfb14cc", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=8d0e8820659fdf8473f7ff8f2fe0d234d16965d7", "patch": "@@ -1004,6 +1004,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             asm::InlineAsmReg::parse(\n                                 sess.asm_arch?,\n                                 |feature| sess.target_features.contains(&Symbol::intern(feature)),\n+                                &sess.target.target,\n                                 s,\n                             )\n                             .map_err(|e| {"}, {"sha": "80278bb9f53d8196b71d3c0ea64fe185844cdd4f", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=8d0e8820659fdf8473f7ff8f2fe0d234d16965d7", "patch": "@@ -156,6 +156,10 @@ const ARM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n     (\"vfp2\", Some(sym::arm_target_feature)),\n     (\"vfp3\", Some(sym::arm_target_feature)),\n     (\"vfp4\", Some(sym::arm_target_feature)),\n+    // This is needed for inline assembly, but shouldn't be stabilized as-is\n+    // since it should be enabled per-function using #[instruction_set], not\n+    // #[target_feature].\n+    (\"thumb-mode\", Some(sym::arm_target_feature)),\n ];\n \n const AARCH64_WHITELIST: &[(&str, Option<Symbol>)] = &["}, {"sha": "85a136b94aa7998bad3523bdac5468ab718d7389", "filename": "src/librustc_target/asm/arm.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_target%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_target%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Farm.rs?ref=8d0e8820659fdf8473f7ff8f2fe0d234d16965d7", "patch": "@@ -1,4 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n+use crate::spec::Target;\n use rustc_macros::HashStable_Generic;\n use std::fmt;\n \n@@ -58,6 +59,37 @@ impl ArmInlineAsmRegClass {\n     }\n }\n \n+// This uses the same logic as useR7AsFramePointer in LLVM\n+fn frame_pointer_is_r7(mut has_feature: impl FnMut(&str) -> bool, target: &Target) -> bool {\n+    target.options.is_like_osx || (!target.options.is_like_windows && has_feature(\"thumb-mode\"))\n+}\n+\n+fn frame_pointer_r11(\n+    _arch: InlineAsmArch,\n+    has_feature: impl FnMut(&str) -> bool,\n+    target: &Target,\n+    _allocating: bool,\n+) -> Result<(), &'static str> {\n+    if !frame_pointer_is_r7(has_feature, target) {\n+        Err(\"the frame pointer (r11) cannot be used as an operand for inline asm\")\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n+fn frame_pointer_r7(\n+    _arch: InlineAsmArch,\n+    has_feature: impl FnMut(&str) -> bool,\n+    target: &Target,\n+    _allocating: bool,\n+) -> Result<(), &'static str> {\n+    if frame_pointer_is_r7(has_feature, target) {\n+        Err(\"the frame pointer (r7) cannot be used as an operand for inline asm\")\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n def_regs! {\n     Arm ArmInlineAsmReg ArmInlineAsmRegClass {\n         r0: reg, reg_thumb = [\"r0\", \"a1\"],\n@@ -66,11 +98,11 @@ def_regs! {\n         r3: reg, reg_thumb = [\"r3\", \"a4\"],\n         r4: reg, reg_thumb = [\"r4\", \"v1\"],\n         r5: reg, reg_thumb = [\"r5\", \"v2\"],\n-        r6: reg, reg_thumb = [\"r6\", \"v3\"],\n-        r7: reg, reg_thumb = [\"r7\", \"v4\"],\n+        r7: reg, reg_thumb = [\"r7\", \"v4\"] % frame_pointer_r7,\n         r8: reg = [\"r8\", \"v5\"],\n         r9: reg = [\"r9\", \"v6\", \"rfp\"],\n         r10: reg = [\"r10\", \"sl\"],\n+        r11: reg = [\"r11\", \"fp\"] % frame_pointer_r11,\n         r12: reg = [\"r12\", \"ip\"],\n         r14: reg = [\"r14\", \"lr\"],\n         s0: sreg, sreg_low16 = [\"s0\"],\n@@ -153,8 +185,8 @@ def_regs! {\n         q13: qreg = [\"q13\"],\n         q14: qreg = [\"q14\"],\n         q15: qreg = [\"q15\"],\n-        #error = [\"r11\", \"fp\"] =>\n-            \"the frame pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r6\", \"v3\"] =>\n+            \"r6 is used internally by LLVM and cannot be used as an operand for inline asm\",\n         #error = [\"r13\", \"sp\"] =>\n             \"the stack pointer cannot be used as an operand for inline asm\",\n         #error = [\"r15\", \"pc\"] =>"}, {"sha": "ccec17817d37df6b0de2920cbe2a7d95fb862fef", "filename": "src/librustc_target/asm/mod.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=8d0e8820659fdf8473f7ff8f2fe0d234d16965d7", "patch": "@@ -1,4 +1,5 @@\n use crate::abi::Size;\n+use crate::spec::Target;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_macros::HashStable_Generic;\n use rustc_span::Symbol;\n@@ -83,12 +84,13 @@ macro_rules! def_regs {\n             pub fn parse(\n                 _arch: super::InlineAsmArch,\n                 mut _has_feature: impl FnMut(&str) -> bool,\n+                _target: &crate::spec::Target,\n                 name: &str,\n             ) -> Result<Self, &'static str> {\n                 match name {\n                     $(\n                         $($alias)|* | $reg_name => {\n-                            $($filter(_arch, &mut _has_feature, false)?;)?\n+                            $($filter(_arch, &mut _has_feature, _target, false)?;)?\n                             Ok(Self::$reg)\n                         }\n                     )*\n@@ -103,6 +105,7 @@ macro_rules! def_regs {\n         pub(super) fn fill_reg_map(\n             _arch: super::InlineAsmArch,\n             mut _has_feature: impl FnMut(&str) -> bool,\n+            _target: &crate::spec::Target,\n             _map: &mut rustc_data_structures::fx::FxHashMap<\n                 super::InlineAsmRegClass,\n                 rustc_data_structures::fx::FxHashSet<super::InlineAsmReg>,\n@@ -111,7 +114,7 @@ macro_rules! def_regs {\n             #[allow(unused_imports)]\n             use super::{InlineAsmReg, InlineAsmRegClass};\n             $(\n-                if $($filter(_arch, &mut _has_feature, true).is_ok() &&)? true {\n+                if $($filter(_arch, &mut _has_feature, _target, true).is_ok() &&)? true {\n                     if let Some(set) = _map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n                         set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n                     }\n@@ -234,27 +237,30 @@ impl InlineAsmReg {\n     pub fn parse(\n         arch: InlineAsmArch,\n         has_feature: impl FnMut(&str) -> bool,\n+        target: &Target,\n         name: Symbol,\n     ) -> Result<Self, &'static str> {\n         // FIXME: use direct symbol comparison for register names\n         // Use `Symbol::as_str` instead of `Symbol::with` here because `has_feature` may access `Symbol`.\n         let name = name.as_str();\n         Ok(match arch {\n             InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n-                Self::X86(X86InlineAsmReg::parse(arch, has_feature, &name)?)\n+                Self::X86(X86InlineAsmReg::parse(arch, has_feature, target, &name)?)\n+            }\n+            InlineAsmArch::Arm => {\n+                Self::Arm(ArmInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n-            InlineAsmArch::Arm => Self::Arm(ArmInlineAsmReg::parse(arch, has_feature, &name)?),\n             InlineAsmArch::AArch64 => {\n-                Self::AArch64(AArch64InlineAsmReg::parse(arch, has_feature, &name)?)\n+                Self::AArch64(AArch64InlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n-                Self::RiscV(RiscVInlineAsmReg::parse(arch, has_feature, &name)?)\n+                Self::RiscV(RiscVInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n             InlineAsmArch::Nvptx64 => {\n-                Self::Nvptx(NvptxInlineAsmReg::parse(arch, has_feature, &name)?)\n+                Self::Nvptx(NvptxInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n             InlineAsmArch::Hexagon => {\n-                Self::Hexagon(HexagonInlineAsmReg::parse(arch, has_feature, &name)?)\n+                Self::Hexagon(HexagonInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n         })\n     }\n@@ -536,36 +542,37 @@ impl fmt::Display for InlineAsmType {\n pub fn allocatable_registers(\n     arch: InlineAsmArch,\n     has_feature: impl FnMut(&str) -> bool,\n+    target: &crate::spec::Target,\n ) -> FxHashMap<InlineAsmRegClass, FxHashSet<InlineAsmReg>> {\n     match arch {\n         InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n             let mut map = x86::regclass_map();\n-            x86::fill_reg_map(arch, has_feature, &mut map);\n+            x86::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n         InlineAsmArch::Arm => {\n             let mut map = arm::regclass_map();\n-            arm::fill_reg_map(arch, has_feature, &mut map);\n+            arm::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n         InlineAsmArch::AArch64 => {\n             let mut map = aarch64::regclass_map();\n-            aarch64::fill_reg_map(arch, has_feature, &mut map);\n+            aarch64::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n         InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n             let mut map = riscv::regclass_map();\n-            riscv::fill_reg_map(arch, has_feature, &mut map);\n+            riscv::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n         InlineAsmArch::Nvptx64 => {\n             let mut map = nvptx::regclass_map();\n-            nvptx::fill_reg_map(arch, has_feature, &mut map);\n+            nvptx::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n         InlineAsmArch::Hexagon => {\n             let mut map = hexagon::regclass_map();\n-            hexagon::fill_reg_map(arch, has_feature, &mut map);\n+            hexagon::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n     }"}, {"sha": "ced7483b00571580ea8879be8d511013bbfda31e", "filename": "src/librustc_target/asm/riscv.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_target%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_target%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Friscv.rs?ref=8d0e8820659fdf8473f7ff8f2fe0d234d16965d7", "patch": "@@ -1,4 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n+use crate::spec::Target;\n use rustc_macros::HashStable_Generic;\n use std::fmt;\n \n@@ -50,6 +51,7 @@ impl RiscVInlineAsmRegClass {\n fn not_e(\n     _arch: InlineAsmArch,\n     mut has_feature: impl FnMut(&str) -> bool,\n+    _target: &Target,\n     _allocating: bool,\n ) -> Result<(), &'static str> {\n     if has_feature(\"e\") {"}, {"sha": "0f62c19e1a3cde0ec0fcef2ff01bf788cfb34004", "filename": "src/librustc_target/asm/x86.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_target%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0e8820659fdf8473f7ff8f2fe0d234d16965d7/src%2Flibrustc_target%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fx86.rs?ref=8d0e8820659fdf8473f7ff8f2fe0d234d16965d7", "patch": "@@ -1,4 +1,5 @@\n use super::{InlineAsmArch, InlineAsmType};\n+use crate::spec::Target;\n use rustc_macros::HashStable_Generic;\n use std::fmt;\n \n@@ -131,6 +132,7 @@ impl X86InlineAsmRegClass {\n fn x86_64_only(\n     arch: InlineAsmArch,\n     _has_feature: impl FnMut(&str) -> bool,\n+    _target: &Target,\n     _allocating: bool,\n ) -> Result<(), &'static str> {\n     match arch {\n@@ -143,6 +145,7 @@ fn x86_64_only(\n fn high_byte(\n     arch: InlineAsmArch,\n     _has_feature: impl FnMut(&str) -> bool,\n+    _target: &Target,\n     allocating: bool,\n ) -> Result<(), &'static str> {\n     match arch {"}]}