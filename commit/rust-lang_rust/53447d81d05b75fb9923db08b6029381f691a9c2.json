{"sha": "53447d81d05b75fb9923db08b6029381f691a9c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNDQ3ZDgxZDA1Yjc1ZmI5OTIzZGIwOGI2MDI5MzgxZjY5MWE5YzI=", "commit": {"author": {"name": "Fran\u00e7ois Mockers", "email": "mockersf@gmail.com", "date": "2021-06-27T09:10:36Z"}, "committer": {"name": "Fran\u00e7ois Mockers", "email": "mockersf@gmail.com", "date": "2021-07-06T20:13:03Z"}, "message": "fix dead link for method in trait of blanket impl from third party crate", "tree": {"sha": "153d584acfab48b03a8c482578f76eaf436ed5ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/153d584acfab48b03a8c482578f76eaf436ed5ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53447d81d05b75fb9923db08b6029381f691a9c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53447d81d05b75fb9923db08b6029381f691a9c2", "html_url": "https://github.com/rust-lang/rust/commit/53447d81d05b75fb9923db08b6029381f691a9c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53447d81d05b75fb9923db08b6029381f691a9c2/comments", "author": {"login": "mockersf", "id": 8672791, "node_id": "MDQ6VXNlcjg2NzI3OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/8672791?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mockersf", "html_url": "https://github.com/mockersf", "followers_url": "https://api.github.com/users/mockersf/followers", "following_url": "https://api.github.com/users/mockersf/following{/other_user}", "gists_url": "https://api.github.com/users/mockersf/gists{/gist_id}", "starred_url": "https://api.github.com/users/mockersf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mockersf/subscriptions", "organizations_url": "https://api.github.com/users/mockersf/orgs", "repos_url": "https://api.github.com/users/mockersf/repos", "events_url": "https://api.github.com/users/mockersf/events{/privacy}", "received_events_url": "https://api.github.com/users/mockersf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mockersf", "id": 8672791, "node_id": "MDQ6VXNlcjg2NzI3OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/8672791?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mockersf", "html_url": "https://github.com/mockersf", "followers_url": "https://api.github.com/users/mockersf/followers", "following_url": "https://api.github.com/users/mockersf/following{/other_user}", "gists_url": "https://api.github.com/users/mockersf/gists{/gist_id}", "starred_url": "https://api.github.com/users/mockersf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mockersf/subscriptions", "organizations_url": "https://api.github.com/users/mockersf/orgs", "repos_url": "https://api.github.com/users/mockersf/repos", "events_url": "https://api.github.com/users/mockersf/events{/privacy}", "received_events_url": "https://api.github.com/users/mockersf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "238fd72880776c5dbd3b067acb096562e6af5399", "url": "https://api.github.com/repos/rust-lang/rust/commits/238fd72880776c5dbd3b067acb096562e6af5399", "html_url": "https://github.com/rust-lang/rust/commit/238fd72880776c5dbd3b067acb096562e6af5399"}], "stats": {"total": 78, "additions": 47, "deletions": 31}, "files": [{"sha": "859746b6a2df77f8cc4e082bd557b4674b0d6203", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53447d81d05b75fb9923db08b6029381f691a9c2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53447d81d05b75fb9923db08b6029381f691a9c2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=53447d81d05b75fb9923db08b6029381f691a9c2", "patch": "@@ -459,7 +459,7 @@ impl Item {\n             .filter_map(|ItemLink { link: s, link_text, did, ref fragment }| {\n                 match did {\n                     Some(did) => {\n-                        if let Some((mut href, ..)) = href(did.clone(), cx) {\n+                        if let Ok((mut href, ..)) = href(did.clone(), cx) {\n                             if let Some(ref fragment) = *fragment {\n                                 href.push('#');\n                                 href.push_str(fragment);"}, {"sha": "bed4bae2492c667cb7fc5130a03cd486b0536be6", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/53447d81d05b75fb9923db08b6029381f691a9c2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53447d81d05b75fb9923db08b6029381f691a9c2/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=53447d81d05b75fb9923db08b6029381f691a9c2", "patch": "@@ -472,15 +472,26 @@ impl clean::GenericArgs {\n     }\n }\n \n-crate fn href(did: DefId, cx: &Context<'_>) -> Option<(String, ItemType, Vec<String>)> {\n+// Possible errors when computing href link source for a `DefId`\n+crate enum HrefError {\n+    // `DefId` is in an unknown location. This seems to happen when building without dependencies\n+    // but a trait from a dependency is still visible\n+    UnknownLocation,\n+    // Unavailable because private\n+    Unavailable,\n+    // Not in external cache, href link should be in same page\n+    NotInExternalCache,\n+}\n+\n+crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<String>), HrefError> {\n     let cache = &cx.cache();\n     let relative_to = &cx.current;\n     fn to_module_fqp(shortty: ItemType, fqp: &[String]) -> &[String] {\n         if shortty == ItemType::Module { &fqp[..] } else { &fqp[..fqp.len() - 1] }\n     }\n \n     if !did.is_local() && !cache.access_levels.is_public(did) && !cache.document_private {\n-        return None;\n+        return Err(HrefError::Unavailable);\n     }\n \n     let (fqp, shortty, mut url_parts) = match cache.paths.get(&did) {\n@@ -489,22 +500,25 @@ crate fn href(did: DefId, cx: &Context<'_>) -> Option<(String, ItemType, Vec<Str\n             href_relative_parts(module_fqp, relative_to)\n         }),\n         None => {\n-            let &(ref fqp, shortty) = cache.external_paths.get(&did)?;\n-            let module_fqp = to_module_fqp(shortty, fqp);\n-            (\n-                fqp,\n-                shortty,\n-                match cache.extern_locations[&did.krate] {\n-                    ExternalLocation::Remote(ref s) => {\n-                        let s = s.trim_end_matches('/');\n-                        let mut s = vec![&s[..]];\n-                        s.extend(module_fqp[..].iter().map(String::as_str));\n-                        s\n-                    }\n-                    ExternalLocation::Local => href_relative_parts(module_fqp, relative_to),\n-                    ExternalLocation::Unknown => return None,\n-                },\n-            )\n+            if let Some(&(ref fqp, shortty)) = cache.external_paths.get(&did) {\n+                let module_fqp = to_module_fqp(shortty, fqp);\n+                (\n+                    fqp,\n+                    shortty,\n+                    match cache.extern_locations[&did.krate] {\n+                        ExternalLocation::Remote(ref s) => {\n+                            let s = s.trim_end_matches('/');\n+                            let mut s = vec![&s[..]];\n+                            s.extend(module_fqp[..].iter().map(String::as_str));\n+                            s\n+                        }\n+                        ExternalLocation::Local => href_relative_parts(module_fqp, relative_to),\n+                        ExternalLocation::Unknown => return Err(HrefError::UnknownLocation),\n+                    },\n+                )\n+            } else {\n+                return Err(HrefError::NotInExternalCache);\n+            }\n         }\n     };\n     let last = &fqp.last().unwrap()[..];\n@@ -518,7 +532,7 @@ crate fn href(did: DefId, cx: &Context<'_>) -> Option<(String, ItemType, Vec<Str\n             url_parts.push(&filename);\n         }\n     }\n-    Some((url_parts.join(\"/\"), shortty, fqp.to_vec()))\n+    Ok((url_parts.join(\"/\"), shortty, fqp.to_vec()))\n }\n \n /// Both paths should only be modules.\n@@ -567,7 +581,7 @@ fn resolved_path<'a, 'cx: 'a>(\n         write!(w, \"{}{:#}\", &last.name, last.args.print(cx))?;\n     } else {\n         let path = if use_absolute {\n-            if let Some((_, _, fqp)) = href(did, cx) {\n+            if let Ok((_, _, fqp)) = href(did, cx) {\n                 format!(\n                     \"{}::{}\",\n                     fqp[..fqp.len() - 1].join(\"::\"),\n@@ -675,7 +689,7 @@ crate fn anchor<'a, 'cx: 'a>(\n ) -> impl fmt::Display + 'a {\n     let parts = href(did.into(), cx);\n     display_fn(move |f| {\n-        if let Some((url, short_ty, fqp)) = parts {\n+        if let Ok((url, short_ty, fqp)) = parts {\n             write!(\n                 f,\n                 r#\"<a class=\"{}\" href=\"{}\" title=\"{} {}\">{}</a>\"#,\n@@ -907,7 +921,7 @@ fn fmt_type<'cx>(\n                 //        look at).\n                 box clean::ResolvedPath { did, .. } => {\n                     match href(did.into(), cx) {\n-                        Some((ref url, _, ref path)) if !f.alternate() => {\n+                        Ok((ref url, _, ref path)) if !f.alternate() => {\n                             write!(\n                                 f,\n                                 \"<a class=\\\"type\\\" href=\\\"{url}#{shortty}.{name}\\\" \\"}, {"sha": "c814ff3075d0594297bda9576718345327ca63c3", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/53447d81d05b75fb9923db08b6029381f691a9c2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53447d81d05b75fb9923db08b6029381f691a9c2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=53447d81d05b75fb9923db08b6029381f691a9c2", "patch": "@@ -62,7 +62,7 @@ use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n     href, print_abi_with_space, print_constness_with_space, print_default_space,\n-    print_generic_bounds, print_where_clause, Buffer, PrintWithSpace,\n+    print_generic_bounds, print_where_clause, Buffer, HrefError, PrintWithSpace,\n };\n use crate::html::markdown::{Markdown, MarkdownHtml, MarkdownSummaryLine};\n \n@@ -856,8 +856,8 @@ fn render_assoc_item(\n     ) {\n         let name = meth.name.as_ref().unwrap();\n         let href = match link {\n-            AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n-            AssocItemLink::Anchor(None) => format!(\"#{}.{}\", meth.type_(), name),\n+            AssocItemLink::Anchor(Some(ref id)) => Some(format!(\"#{}\", id)),\n+            AssocItemLink::Anchor(None) => Some(format!(\"#{}.{}\", meth.type_(), name)),\n             AssocItemLink::GotoSource(did, provided_methods) => {\n                 // We're creating a link from an impl-item to the corresponding\n                 // trait-item and need to map the anchored type accordingly.\n@@ -867,9 +867,11 @@ fn render_assoc_item(\n                     ItemType::TyMethod\n                 };\n \n-                href(did.expect_def_id(), cx)\n-                    .map(|p| format!(\"{}#{}.{}\", p.0, ty, name))\n-                    .unwrap_or_else(|| format!(\"#{}.{}\", ty, name))\n+                match href(did.expect_def_id(), cx) {\n+                    Ok(p) => Some(format!(\"{}#{}.{}\", p.0, ty, name)),\n+                    Err(HrefError::UnknownLocation) => None,\n+                    Err(_) => Some(format!(\"#{}.{}\", ty, name)),\n+                }\n             }\n         };\n         let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n@@ -904,7 +906,7 @@ fn render_assoc_item(\n         w.reserve(header_len + \"<a href=\\\"\\\" class=\\\"fnname\\\">{\".len() + \"</a>\".len());\n         write!(\n             w,\n-            \"{indent}{vis}{constness}{asyncness}{unsafety}{defaultness}{abi}fn <a href=\\\"{href}\\\" class=\\\"fnname\\\">{name}</a>\\\n+            \"{indent}{vis}{constness}{asyncness}{unsafety}{defaultness}{abi}fn <a {href} class=\\\"fnname\\\">{name}</a>\\\n              {generics}{decl}{notable_traits}{where_clause}\",\n             indent = indent_str,\n             vis = vis,\n@@ -913,7 +915,7 @@ fn render_assoc_item(\n             unsafety = unsafety,\n             defaultness = defaultness,\n             abi = abi,\n-            href = href,\n+            href = href.map(|href| format!(\"href=\\\"{}\\\"\", href)).unwrap_or_else(|| \"\".to_string()),\n             name = name,\n             generics = g.print(cx),\n             decl = d.full_print(header_len, indent, header.asyncness, cx),"}]}