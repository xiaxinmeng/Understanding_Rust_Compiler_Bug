{"sha": "3ee61373fe056efb46b6b1b243b31cec0d7e6099", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZTYxMzczZmUwNTZlZmI0NmI2YjFiMjQzYjMxY2VjMGQ3ZTYwOTk=", "commit": {"author": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-07-23T05:46:23Z"}, "committer": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-08-03T04:34:17Z"}, "message": "Write the lint and write tests", "tree": {"sha": "d54f6d7838e7f1bc2b5a90d0728ac11199fd16d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d54f6d7838e7f1bc2b5a90d0728ac11199fd16d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ee61373fe056efb46b6b1b243b31cec0d7e6099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee61373fe056efb46b6b1b243b31cec0d7e6099", "html_url": "https://github.com/rust-lang/rust/commit/3ee61373fe056efb46b6b1b243b31cec0d7e6099", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ee61373fe056efb46b6b1b243b31cec0d7e6099/comments", "author": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05bb6e6bdb1894de5803f729339a631a9222499f", "url": "https://api.github.com/repos/rust-lang/rust/commits/05bb6e6bdb1894de5803f729339a631a9222499f", "html_url": "https://github.com/rust-lang/rust/commit/05bb6e6bdb1894de5803f729339a631a9222499f"}], "stats": {"total": 153, "additions": 137, "deletions": 16}, "files": [{"sha": "231c440463d64469a96327135ca6bc7a5867b78e", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 101, "deletions": 6, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/3ee61373fe056efb46b6b1b243b31cec0d7e6099/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee61373fe056efb46b6b1b243b31cec0d7e6099/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=3ee61373fe056efb46b6b1b243b31cec0d7e6099", "patch": "@@ -1,14 +1,15 @@\n use crate::consts::constant;\n use crate::reexport::Name;\n use crate::utils::paths;\n+use crate::utils::sugg::Sugg;\n use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::{\n     get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    is_integer_const, is_no_std_crate, is_refutable, last_path_segment, match_trait_method, match_type, match_var,\n-    multispan_sugg, snippet, snippet_opt, snippet_with_applicability, span_lint, span_lint_and_help,\n-    span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n+    is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_path,\n+    match_trait_method, match_type, match_var, multispan_sugg, qpath_res, snippet, snippet_opt,\n+    snippet_with_applicability, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg,\n+    SpanlessEq,\n };\n-use crate::utils::{is_type_diagnostic_item, qpath_res, sugg};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -17,7 +18,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     def_id, BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, GenericArg, HirId, InlineAsmOperand,\n-    LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n+    Local, LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -27,7 +28,7 @@ use rustc_middle::middle::region;\n use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use std::iter::{once, Iterator};\n use std::mem;\n@@ -2358,6 +2359,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    // Check for direct, immediate usage\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n         if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;\n@@ -2423,6 +2425,99 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n             }\n         }\n     }\n+    // Check for collecting it and then turning it back into an iterator later\n+    if let ExprKind::Block(ref block, _) = expr.kind {\n+        for ref stmt in block.stmts {\n+            if_chain! {\n+                // TODO also work for assignments to an existing variable\n+                if let StmtKind::Local(\n+                    Local { pat: Pat { kind: PatKind::Binding(_, _, ident, .. ), .. },\n+                    init: Some(ref init_expr), .. }\n+                ) = stmt.kind;\n+                if let ExprKind::MethodCall(ref method_name, _, &[ref iter_source], ..) = init_expr.kind;\n+                if method_name.ident.name == sym!(collect) && match_trait_method(cx, &init_expr, &paths::ITERATOR);\n+                if let Some(ref generic_args) = method_name.args;\n+                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+                if let ty = cx.typeck_results().node_type(ty.hir_id);\n+                if is_type_diagnostic_item(cx, ty, sym!(vec_type)) ||\n+                    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                    match_type(cx, ty, &paths::LINKED_LIST);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if iter_calls.len() == 1;\n+                then {\n+                    // Suggest replacing iter_call with iter_replacement, and removing stmt\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        stmt.span,\n+                        NEEDLESS_COLLECT_MSG,\n+                        |diag| {\n+                            let iter_replacement = Sugg::hir(cx, iter_source, \"..\").to_string();\n+                            diag.multipart_suggestion(\n+                                \"Use the original Iterator instead of collecting it and then producing a new one\",\n+                                vec![\n+                                    (stmt.span, String::new()),\n+                                    (iter_calls[0].span, iter_replacement)\n+                                ],\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct IntoIterVisitor<'tcx> {\n+    iters: Vec<&'tcx Expr<'tcx>>,\n+    seen_other: bool,\n+    target: String,\n+}\n+impl<'tcx> Visitor<'tcx> for IntoIterVisitor<'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        match &expr.kind {\n+            ExprKind::MethodCall(\n+                method_name,\n+                _,\n+                &[Expr {\n+                    kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                    ..\n+                }],\n+                _,\n+            ) if match_path(path, &[&self.target]) => {\n+                // TODO Check what method is being called, if it's called on target, and act\n+                // accordingly\n+                if method_name.ident.name == sym!(into_iter) {\n+                    self.iters.push(expr);\n+                } else {\n+                    self.seen_other = true;\n+                }\n+            },\n+            _ => walk_expr(self, expr),\n+        }\n+    }\n+\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Detect the occurences of calls to `iter` or `into_iter` for the\n+/// given identifier\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<&'tcx Expr<'tcx>>> {\n+    let mut visitor = IntoIterVisitor {\n+        iters: Vec::new(),\n+        target: identifier.name.to_ident_string(),\n+        seen_other: false,\n+    };\n+    visitor.visit_block(block);\n+    if visitor.seen_other {\n+        None\n+    } else {\n+        Some(visitor.iters)\n+    }\n }\n \n fn shorten_span(expr: &Expr<'_>, target_fn_name: Symbol) -> Span {"}, {"sha": "60a3e206283f96b4d3299c27a39ef27d6efd430a", "filename": "tests/ui/needless_collect.fixed", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ee61373fe056efb46b6b1b243b31cec0d7e6099/tests%2Fui%2Fneedless_collect.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3ee61373fe056efb46b6b1b243b31cec0d7e6099/tests%2Fui%2Fneedless_collect.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.fixed?ref=3ee61373fe056efb46b6b1b243b31cec0d7e6099", "patch": "@@ -18,4 +18,15 @@ fn main() {\n     sample.iter().collect::<HashSet<_>>().len();\n     // Neither should this\n     sample.iter().collect::<BTreeSet<_>>().len();\n+    let indirect_positive = sample.iter().collect::<Vec<_>>();\n+    indirect_positive\n+        .into_iter()\n+        .map(|x| (x, x + 1))\n+        .collect::<HashMap<_, _>>();\n+    let indirect_negative = sample.iter().collect::<Vec<_>>();\n+    indirect_negative.len();\n+    indirect_negative\n+        .iter()\n+        .map(|x| (*x, *x + 1))\n+        .collect::<HashMap<_, _>>();\n }"}, {"sha": "33a1ea36095930134f1e80ebd06bb9b94b4a1c92", "filename": "tests/ui/needless_collect.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ee61373fe056efb46b6b1b243b31cec0d7e6099/tests%2Fui%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ee61373fe056efb46b6b1b243b31cec0d7e6099/tests%2Fui%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.rs?ref=3ee61373fe056efb46b6b1b243b31cec0d7e6099", "patch": "@@ -8,9 +8,6 @@ use std::collections::{BTreeSet, HashMap, HashSet};\n #[allow(unused_variables, clippy::iter_cloned_collect)]\n fn main() {\n     let sample = [1; 5];\n-    let indirect_with_into_iter = sample.iter().collect::<Vec<_>>();\n-    let indirect_with_iter = sample.iter().collect::<Vec<_>>();;\n-    let indirect_negative = sample.iter().collect::<Vec<_>>();;\n     let len = sample.iter().collect::<Vec<_>>().len();\n     if sample.iter().collect::<Vec<_>>().is_empty() {\n         // Empty\n@@ -21,8 +18,15 @@ fn main() {\n     sample.iter().collect::<HashSet<_>>().len();\n     // Neither should this\n     sample.iter().collect::<BTreeSet<_>>().len();\n-    indirect_with_into_iter.into_iter().map(|x| (x, x+1)).collect::<HashMap<_, _>>();\n-    indirect_with_iter.iter().map(|x| (x, x+1)).collect::<HashMap<_, _>>();\n-    indirect_negative.iter().map(|x| (x, x+1)).collect::<HashMap<_, _>>();\n-    indirect_negative.iter().map(|x| (x, x+1)).collect::<HashMap<_, _>>();\n+    let indirect_positive = sample.iter().collect::<Vec<_>>();\n+    indirect_positive\n+        .into_iter()\n+        .map(|x| (x, x + 1))\n+        .collect::<HashMap<_, _>>();\n+    let indirect_negative = sample.iter().collect::<Vec<_>>();\n+    indirect_negative.len();\n+    indirect_negative\n+        .iter()\n+        .map(|x| (*x, *x + 1))\n+        .collect::<HashMap<_, _>>();\n }"}, {"sha": "bb67bfa83e9170514fbd712c2638c2780398729a", "filename": "tests/ui/needless_collect.stderr", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ee61373fe056efb46b6b1b243b31cec0d7e6099/tests%2Fui%2Fneedless_collect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ee61373fe056efb46b6b1b243b31cec0d7e6099/tests%2Fui%2Fneedless_collect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.stderr?ref=3ee61373fe056efb46b6b1b243b31cec0d7e6099", "patch": "@@ -1,10 +1,21 @@\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:21:5\n+   |\n+LL |     let indirect_positive = sample.iter().collect::<Vec<_>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::needless-collect` implied by `-D warnings`\n+help: Use the original Iterator instead of collecting it and then producing a new one\n+   |\n+LL |     \n+LL |     sample.iter()\n+   |\n+\n error: avoid using `collect()` when not needed\n   --> $DIR/needless_collect.rs:11:29\n    |\n LL |     let len = sample.iter().collect::<Vec<_>>().len();\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `count()`\n-   |\n-   = note: `-D clippy::needless-collect` implied by `-D warnings`\n \n error: avoid using `collect()` when not needed\n   --> $DIR/needless_collect.rs:12:15\n@@ -24,5 +35,5 @@ error: avoid using `collect()` when not needed\n LL |     sample.iter().map(|x| (x, x)).collect::<HashMap<_, _>>().len();\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `count()`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n "}]}