{"sha": "d87edae73ba93a3171903fd6889c554d34d5a3ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4N2VkYWU3M2JhOTNhMzE3MTkwM2ZkNjg4OWM1NTRkMzRkNWEzZWU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-22T10:35:07Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-22T10:35:07Z"}, "message": "Add CValue variant ByValPair", "tree": {"sha": "b5ab3581daedf7061b3462813b3188b2ea26b53a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5ab3581daedf7061b3462813b3188b2ea26b53a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d87edae73ba93a3171903fd6889c554d34d5a3ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d87edae73ba93a3171903fd6889c554d34d5a3ee", "html_url": "https://github.com/rust-lang/rust/commit/d87edae73ba93a3171903fd6889c554d34d5a3ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d87edae73ba93a3171903fd6889c554d34d5a3ee/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65641b887270da200d4ea83f8f968ad67de16401", "url": "https://api.github.com/repos/rust-lang/rust/commits/65641b887270da200d4ea83f8f968ad67de16401", "html_url": "https://github.com/rust-lang/rust/commit/65641b887270da200d4ea83f8f968ad67de16401"}], "stats": {"total": 168, "additions": 105, "deletions": 63}, "files": [{"sha": "b1ad63135c575810cfcfeaca826e6db76041875d", "filename": "src/base.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d87edae73ba93a3171903fd6889c554d34d5a3ee/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87edae73ba93a3171903fd6889c554d34d5a3ee/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=d87edae73ba93a3171903fd6889c554d34d5a3ee", "patch": "@@ -727,15 +727,15 @@ pub fn trans_int_binop<'a, 'tcx: 'a>(\n pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     bin_op: BinOp,\n-    lhs: CValue<'tcx>,\n-    rhs: CValue<'tcx>,\n+    in_lhs: CValue<'tcx>,\n+    in_rhs: CValue<'tcx>,\n     out_ty: Ty<'tcx>,\n     signed: bool,\n ) -> CValue<'tcx> {\n     if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n         assert_eq!(\n-            lhs.layout().ty,\n-            rhs.layout().ty,\n+            in_lhs.layout().ty,\n+            in_rhs.layout().ty,\n             \"checked int binop requires lhs and rhs of same type\"\n         );\n     }\n@@ -747,40 +747,32 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n         ),\n     };\n \n-    let res = binop_match! {\n-        fx, bin_op, signed, lhs, rhs, res_ty, \"checked int/uint\";\n-        Add (_) iadd;\n-        Sub (_) isub;\n-        Mul (_) imul;\n-        Div (_) bug;\n-        Rem (_) bug;\n-        BitXor (_) bug;\n-        BitAnd (_) bug;\n-        BitOr (_) bug;\n-        Shl (_) ishl;\n-        Shr (false) ushr;\n-        Shr (true) sshr;\n-\n-        Eq (_) bug;\n-        Lt (_) bug;\n-        Le (_) bug;\n-        Ne (_) bug;\n-        Ge (_) bug;\n-        Gt (_) bug;\n-\n-        Offset (_) bug;\n+    let lhs = in_lhs.load_value(fx);\n+    let rhs = in_rhs.load_value(fx);\n+    let res = match bin_op {\n+        BinOp::Add => fx.bcx.ins().iadd(lhs, rhs),\n+        BinOp::Sub => fx.bcx.ins().isub(lhs, rhs),\n+        BinOp::Mul => fx.bcx.ins().imul(lhs, rhs),\n+        BinOp::Shl => fx.bcx.ins().ishl(lhs, rhs),\n+        BinOp::Shr => if !signed {\n+            fx.bcx.ins().ushr(lhs, rhs)\n+        } else {\n+            fx.bcx.ins().sshr(lhs, rhs)\n+        },\n+        _ => bug!(\n+            \"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\",\n+            bin_op,\n+            in_lhs,\n+            in_rhs\n+        ),\n     };\n \n     // TODO: check for overflow\n-    let has_overflow = CValue::const_val(fx, fx.tcx.types.bool, 0);\n+    let has_overflow = fx.bcx.ins().iconst(types::I8, 0);\n \n     let out_place = CPlace::temp(fx, out_ty);\n-    out_place\n-        .place_field(fx, mir::Field::new(0))\n-        .write_cvalue(fx, res);\n-    out_place\n-        .place_field(fx, mir::Field::new(1))\n-        .write_cvalue(fx, has_overflow);\n+    let out_layout = out_place.layout();\n+    out_place.write_cvalue(fx, CValue::ByValPair(res, has_overflow, out_layout));\n \n     out_place.to_cvalue(fx)\n }"}, {"sha": "a4d3f81bb5d554a72542ddbc47ef93bacb003024", "filename": "src/common.rs", "status": "modified", "additions": 80, "deletions": 30, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d87edae73ba93a3171903fd6889c554d34d5a3ee/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87edae73ba93a3171903fd6889c554d34d5a3ee/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=d87edae73ba93a3171903fd6889c554d34d5a3ee", "patch": "@@ -82,12 +82,15 @@ fn codegen_field<'a, 'tcx: 'a>(\n pub enum CValue<'tcx> {\n     ByRef(Value, TyLayout<'tcx>),\n     ByVal(Value, TyLayout<'tcx>),\n+    ByValPair(Value, Value, TyLayout<'tcx>),\n }\n \n impl<'tcx> CValue<'tcx> {\n     pub fn layout(&self) -> TyLayout<'tcx> {\n         match *self {\n-            CValue::ByRef(_, layout) | CValue::ByVal(_, layout) => layout,\n+            CValue::ByRef(_, layout)\n+            | CValue::ByVal(_, layout)\n+            | CValue::ByValPair(_, _, layout) => layout,\n         }\n     }\n \n@@ -108,6 +111,19 @@ impl<'tcx> CValue<'tcx> {\n                     .ins()\n                     .stack_addr(fx.module.pointer_type(), stack_slot, 0)\n             }\n+            CValue::ByValPair(value, extra, layout) => {\n+                let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    size: layout.size.bytes() as u32,\n+                    offset: None,\n+                });\n+                let base = fx.bcx.ins().stack_addr(types::I64, stack_slot, 0);\n+                let a_addr = codegen_field(fx, base, layout, mir::Field::new(0)).0;\n+                let b_addr = codegen_field(fx, base, layout, mir::Field::new(1)).0;\n+                fx.bcx.ins().store(MemFlags::new(), value, a_addr, 0);\n+                fx.bcx.ins().store(MemFlags::new(), extra, b_addr, 0);\n+                base\n+            }\n         }\n     }\n \n@@ -123,13 +139,45 @@ impl<'tcx> CValue<'tcx> {\n                 fx.bcx.ins().load(cton_ty, MemFlags::new(), addr, 0)\n             }\n             CValue::ByVal(value, _layout) => value,\n+            CValue::ByValPair(_, _, _layout) => bug!(\"Please use load_value_pair for ByValPair\"),\n+        }\n+    }\n+\n+    pub fn load_value_pair<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> (Value, Value)\n+    where\n+        'tcx: 'a,\n+    {\n+        match self {\n+            CValue::ByRef(addr, layout) => {\n+                assert_eq!(\n+                    layout.size.bytes(),\n+                    fx.tcx.data_layout.pointer_size.bytes() * 2\n+                );\n+                let val1_offset = layout.fields.offset(0).bytes() as i32;\n+                let val2_offset = layout.fields.offset(1).bytes() as i32;\n+                let val1 =\n+                    fx.bcx\n+                        .ins()\n+                        .load(fx.module.pointer_type(), MemFlags::new(), addr, val1_offset);\n+                let val2 =\n+                    fx.bcx\n+                        .ins()\n+                        .load(fx.module.pointer_type(), MemFlags::new(), addr, val2_offset);\n+                (val1, val2)\n+            }\n+            CValue::ByVal(_, _layout) => bug!(\"Please use load_value for ByVal\"),\n+            CValue::ByValPair(val1, val2, _layout) => (val1, val2),\n         }\n     }\n \n     pub fn expect_byref(self) -> (Value, TyLayout<'tcx>) {\n         match self {\n             CValue::ByRef(value, layout) => (value, layout),\n             CValue::ByVal(_, _) => bug!(\"Expected CValue::ByRef, found CValue::ByVal: {:?}\", self),\n+            CValue::ByValPair(_, _, _) => bug!(\n+                \"Expected CValue::ByRef, found CValue::ByValPair: {:?}\",\n+                self\n+            ),\n         }\n     }\n \n@@ -167,6 +215,7 @@ impl<'tcx> CValue<'tcx> {\n         match self {\n             CValue::ByRef(addr, _) => CValue::ByRef(addr, layout),\n             CValue::ByVal(val, _) => CValue::ByVal(val, layout),\n+            CValue::ByValPair(val, extra, _) => CValue::ByValPair(val, extra, layout),\n         }\n     }\n }\n@@ -262,37 +311,38 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             CPlace::Addr(addr, layout) => {\n                 let size = layout.size.bytes() as i32;\n \n-                if let Some(_) = fx.cton_type(layout.ty) {\n-                    let data = from.load_value(fx);\n-                    fx.bcx.ins().store(MemFlags::new(), data, addr, 0);\n-                } else {\n-                    let from = from.expect_byref();\n-                    let mut offset = 0;\n-                    while size - offset >= 8 {\n-                        let byte = fx.bcx.ins().load(\n-                            fx.module.pointer_type(),\n-                            MemFlags::new(),\n-                            from.0,\n-                            offset,\n-                        );\n-                        fx.bcx.ins().store(MemFlags::new(), byte, addr, offset);\n-                        offset += 8;\n+                match from {\n+                    CValue::ByVal(val, _layout) => {\n+                        fx.bcx.ins().store(MemFlags::new(), val, addr, 0);\n                     }\n-                    while size - offset >= 4 {\n-                        let byte = fx\n-                            .bcx\n-                            .ins()\n-                            .load(types::I32, MemFlags::new(), from.0, offset);\n-                        fx.bcx.ins().store(MemFlags::new(), byte, addr, offset);\n-                        offset += 4;\n+                    CValue::ByValPair(val1, val2, _layout) => {\n+                        let val1_offset = layout.fields.offset(0).bytes() as i32;\n+                        let val2_offset = layout.fields.offset(1).bytes() as i32;\n+                        fx.bcx.ins().store(MemFlags::new(), val1, addr, val1_offset);\n+                        fx.bcx.ins().store(MemFlags::new(), val2, addr, val2_offset);\n                     }\n-                    while offset < size {\n-                        let byte = fx\n-                            .bcx\n-                            .ins()\n-                            .load(types::I8, MemFlags::new(), from.0, offset);\n-                        fx.bcx.ins().store(MemFlags::new(), byte, addr, offset);\n-                        offset += 1;\n+                    CValue::ByRef(from, _layout) => {\n+                        let mut offset = 0;\n+                        while size - offset >= 8 {\n+                            let byte = fx.bcx.ins().load(\n+                                fx.module.pointer_type(),\n+                                MemFlags::new(),\n+                                from,\n+                                offset,\n+                            );\n+                            fx.bcx.ins().store(MemFlags::new(), byte, addr, offset);\n+                            offset += 8;\n+                        }\n+                        while size - offset >= 4 {\n+                            let byte = fx.bcx.ins().load(types::I32, MemFlags::new(), from, offset);\n+                            fx.bcx.ins().store(MemFlags::new(), byte, addr, offset);\n+                            offset += 4;\n+                        }\n+                        while offset < size {\n+                            let byte = fx.bcx.ins().load(types::I8, MemFlags::new(), from, offset);\n+                            fx.bcx.ins().store(MemFlags::new(), byte, addr, offset);\n+                            offset += 1;\n+                        }\n                     }\n                 }\n             }"}]}