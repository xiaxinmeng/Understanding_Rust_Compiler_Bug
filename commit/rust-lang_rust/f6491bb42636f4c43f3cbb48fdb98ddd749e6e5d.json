{"sha": "f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NDkxYmI0MjYzNmY0YzQzZjNjYmI0OGZkYjk4ZGRkNzQ5ZTZlNWQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-18T11:39:20Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-18T11:49:01Z"}, "message": "Update stdlib, compiler, and tests to new kind system\n\nThis involved adding 'copy' to more generics than I hoped, but an\nexperiment with making it implicit showed that that way lies madness --\nunless enforced, you will not remember to mark functions that don't\ncopy as not requiring copyable kind.\n\nIssue #1177", "tree": {"sha": "c22607ada38b85ce4fadda6cf89998f6684a4964", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c22607ada38b85ce4fadda6cf89998f6684a4964"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "html_url": "https://github.com/rust-lang/rust/commit/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "html_url": "https://github.com/rust-lang/rust/commit/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab"}], "stats": {"total": 790, "additions": 314, "deletions": 476}, "files": [{"sha": "0c3fac3b46f15ccefe9db62aa3acef359212fb17", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -199,7 +199,7 @@ fn require_unique_names(sess: session::session, metas: [@ast::meta_item]) {\n     }\n }\n \n-fn span<T>(item: T) -> ast::spanned<T> {\n+fn span<copy T>(item: T) -> ast::spanned<T> {\n     ret {node: item, span: ast_util::dummy_sp()};\n }\n "}, {"sha": "95c592eeada356d6ed192b48b057128637f738fa", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -196,7 +196,9 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     ret @item;\n }\n \n-fn nospan<T>(t: T) -> ast::spanned<T> { ret {node: t, span: dummy_sp()}; }\n+fn nospan<copy T>(t: T) -> ast::spanned<T> {\n+    ret {node: t, span: dummy_sp()};\n+}\n \n fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let ret_ty = mk_test_desc_vec_ty(cx);"}, {"sha": "8eb0ea64e49b0836d43c4574303d2f4c82e3d01d", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -389,7 +389,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer) ->\n \n // Path and definition ID indexing\n \n-fn create_index<T>(index: [entry<T>], hash_fn: fn(T) -> uint) ->\n+fn create_index<copy T>(index: [entry<T>], hash_fn: fn(T) -> uint) ->\n    [@[entry<T>]] {\n     let buckets: [@mutable [entry<T>]] = [];\n     uint::range(0u, 256u) {|_i| buckets += [@mutable []]; };"}, {"sha": "9034e5bb2611cc9806f8aa961c219c3e792fc2ee", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -150,7 +150,7 @@ fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n     }\n }\n \n-fn parse_constr<T>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n+fn parse_constr<copy T>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n    @ty::constr_general<T> {\n     let sp = ast_util::dummy_sp(); // FIXME: use a real span\n     let args: [@sp_constr_arg<T>] = [];"}, {"sha": "af4a527224603ed8a1d28f918c4f931d62260648", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -74,7 +74,7 @@ fn map_expr(cx: ctx, ex: @expr) {\n     cx.map.insert(ex.id, node_expr(ex));\n }\n \n-fn new_smallintmap_int_adapter<V>() -> std::map::hashmap<int, V> {\n+fn new_smallintmap_int_adapter<copy V>() -> std::map::hashmap<int, V> {\n     let key_idx = fn (&&key: int) -> uint { key as uint };\n     let idx_key = fn (idx: uint) -> int { idx as int };\n     ret new_smallintmap_adapter(key_idx, idx_key);\n@@ -85,11 +85,11 @@ fn new_smallintmap_int_adapter<V>() -> std::map::hashmap<int, V> {\n // the entire codebase adapting all the callsites to the different\n // interface.\n // FIXME: hashmap and smallintmap should support the same interface.\n-fn new_smallintmap_adapter<K, V>(key_idx: fn(K) -> uint,\n-                                   idx_key: fn(uint) -> K)\n+fn new_smallintmap_adapter<copy K, copy V>(key_idx: fn(K) -> uint,\n+                                           idx_key: fn(uint) -> K)\n     -> std::map::hashmap<K, V> {\n \n-    obj adapter<shar K, shar V>(map: smallintmap::smallintmap<V>,\n+    obj adapter<copy K, copy V>(map: smallintmap::smallintmap<V>,\n                                 key_idx: fn(K) -> uint,\n                                 idx_key: fn(uint) -> K) {\n "}, {"sha": "9733d6e53fa6aa0c96724a5f883641c1b20718f8", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -23,9 +23,7 @@ type def_id = {crate: crate_num, node: node_id};\n \n const local_crate: crate_num = 0;\n \n-tag plicit<T> { explicit(T); implicit(T); }\n-\n-type ty_param = {ident: ident, kind: plicit<kind>};\n+type ty_param = {ident: ident, kind: kind};\n \n tag def {\n     def_fn(def_id, purity);"}, {"sha": "2af904bdef0db8315e3a1353e9fd27cf9d0659ef", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -2,7 +2,9 @@ import std::{str, option};\n import codemap::span;\n import ast::*;\n \n-fn respan<T>(sp: span, t: T) -> spanned<T> { ret {node: t, span: sp}; }\n+fn respan<copy T>(sp: span, t: T) -> spanned<T> {\n+    ret {node: t, span: sp};\n+}\n \n /* assuming that we're not in macro expansion */\n fn mk_sp(lo: uint, hi: uint) -> span {\n@@ -186,7 +188,7 @@ fn eq_def_id(&&a: def_id, &&b: def_id) -> bool {\n     a == b\n }\n \n-fn new_def_id_hash<T>() -> std::map::hashmap<def_id, T> {\n+fn new_def_id_hash<copy T>() -> std::map::hashmap<def_id, T> {\n     std::map::mk_hashmap(hash_def_id, eq_def_id)\n }\n \n@@ -228,9 +230,7 @@ fn ret_by_ref(style: ret_style) -> bool {\n     }\n }\n \n-fn ty_param_kind(tp: ty_param) -> kind {\n-    alt tp.kind { ast::implicit(x) | ast::explicit(x) { x } }\n-}\n+fn ty_param_kind(tp: ty_param) -> kind { tp.kind }\n \n // Local Variables:\n // mode: rust"}, {"sha": "dd66c1bef92fc99b6c2fd276ac4935be767487c6", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -103,7 +103,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n         }\n }\n \n-fn option_flatten_map<T, U>(f: fn@(T) -> option::t<U>, v: [T]) ->\n+fn option_flatten_map<copy T, copy U>(f: fn@(T) -> option::t<U>, v: [T]) ->\n    option::t<[U]> {\n     let res = [];\n     for elem: T in v {"}, {"sha": "2f6257f1064087273e80dd6de9e71a5ceef072ee", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -219,7 +219,7 @@ fn expect_gt(p: parser) {\n     }\n }\n \n-fn spanned<T>(lo: uint, hi: uint, node: T) -> spanned<T> {\n+fn spanned<copy T>(lo: uint, hi: uint, node: T) -> spanned<T> {\n     ret {node: node, span: ast_util::mk_sp(lo, hi)};\n }\n \n@@ -394,8 +394,8 @@ fn parse_constr_in_type(p: parser) -> @ast::ty_constr {\n }\n \n \n-fn parse_constrs<T>(pser: block(parser) -> @ast::constr_general<T>,\n-                    p: parser) ->\n+fn parse_constrs<copy T>(pser: block(parser) -> @ast::constr_general<T>,\n+                         p: parser) ->\n    [@ast::constr_general<T>] {\n     let constrs: [@ast::constr_general<T>] = [];\n     while true {\n@@ -595,9 +595,9 @@ fn parse_fn_block_arg(p: parser) -> ast::arg {\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n-fn parse_seq_to_before_gt<T>(sep: option::t<token::token>,\n-                              f: block(parser) -> T,\n-                              p: parser) -> [T] {\n+fn parse_seq_to_before_gt<copy T>(sep: option::t<token::token>,\n+                                  f: block(parser) -> T,\n+                                  p: parser) -> [T] {\n     let first = true;\n     let v = [];\n     while p.peek() != token::GT && p.peek() != token::BINOP(token::LSR) &&\n@@ -612,16 +612,17 @@ fn parse_seq_to_before_gt<T>(sep: option::t<token::token>,\n     ret v;\n }\n \n-fn parse_seq_to_gt<T>(sep: option::t<token::token>, f: block(parser) -> T,\n-                      p: parser) -> [T] {\n+fn parse_seq_to_gt<copy T>(sep: option::t<token::token>,\n+                           f: block(parser) -> T, p: parser) -> [T] {\n     let v = parse_seq_to_before_gt(sep, f, p);\n     expect_gt(p);\n \n     ret v;\n }\n \n-fn parse_seq_lt_gt<T>(sep: option::t<token::token>, f: block(parser) -> T,\n-                      p: parser) -> spanned<[T]> {\n+fn parse_seq_lt_gt<copy T>(sep: option::t<token::token>,\n+                           f: block(parser) -> T,\n+                           p: parser) -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, token::LT);\n     let result = parse_seq_to_before_gt::<T>(sep, f, p);\n@@ -630,16 +631,16 @@ fn parse_seq_lt_gt<T>(sep: option::t<token::token>, f: block(parser) -> T,\n     ret spanned(lo, hi, result);\n }\n \n-fn parse_seq_to_end<T>(ket: token::token, sep: option::t<token::token>,\n-                       f: block(parser) -> T, p: parser) -> [T] {\n+fn parse_seq_to_end<copy T>(ket: token::token, sep: option::t<token::token>,\n+                            f: block(parser) -> T, p: parser) -> [T] {\n     let val = parse_seq_to_before_end(ket, sep, f, p);\n     p.bump();\n     ret val;\n }\n \n-fn parse_seq_to_before_end<T>(ket: token::token,\n-                               sep: option::t<token::token>,\n-                               f: block(parser) -> T, p: parser) -> [T] {\n+fn parse_seq_to_before_end<copy T>(ket: token::token,\n+                                   sep: option::t<token::token>,\n+                                   f: block(parser) -> T, p: parser) -> [T] {\n     let first: bool = true;\n     let v: [T] = [];\n     while p.peek() != ket {\n@@ -653,9 +654,9 @@ fn parse_seq_to_before_end<T>(ket: token::token,\n }\n \n \n-fn parse_seq<T>(bra: token::token, ket: token::token,\n-                sep: option::t<token::token>, f: block(parser) -> T,\n-                p: parser) -> spanned<[T]> {\n+fn parse_seq<copy T>(bra: token::token, ket: token::token,\n+                     sep: option::t<token::token>, f: block(parser) -> T,\n+                     p: parser) -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, bra);\n     let result = parse_seq_to_before_end::<T>(ket, sep, f, p);\n@@ -1741,24 +1742,18 @@ fn parse_block_tail(p: parser, lo: uint, s: ast::blk_check_mode) -> ast::blk {\n     ret spanned(lo, hi, bloc);\n }\n \n-fn parse_ty_param(p: parser, def: ast::kind) -> ast::ty_param {\n-    // Accept both old and new kind names for now. FIXME remove this\n-    let k = if eat_word(p, \"send\") | eat_word(p, \"uniq\")\n-                { ast::explicit(ast::kind_sendable) }\n-            else if eat_word(p, \"copy\") | eat_word(p, \"shar\")\n-                { ast::explicit(ast::kind_copyable) }\n-            else if eat_word(p, \"nocopy\") | eat_word(p, \"pin\")\n-                { ast::explicit(ast::kind_noncopyable) }\n-            else { ast::implicit(def) };\n+fn parse_ty_param(p: parser) -> ast::ty_param {\n+    let k = if eat_word(p, \"send\") { ast::kind_sendable }\n+            else if eat_word(p, \"copy\") { ast::kind_copyable }\n+            else { ast::kind_noncopyable };\n     ret {ident: parse_ident(p), kind: k};\n }\n \n-fn parse_ty_params(p: parser, def: ast::kind) -> [ast::ty_param] {\n+fn parse_ty_params(p: parser) -> [ast::ty_param] {\n     let ty_params: [ast::ty_param] = [];\n     if p.peek() == token::LT {\n         p.bump();\n-        ty_params = parse_seq_to_gt(some(token::COMMA),\n-                                    {|p| parse_ty_param(p, def)}, p);\n+        ty_params = parse_seq_to_gt(some(token::COMMA), parse_ty_param, p);\n     }\n     ret ty_params;\n }\n@@ -1811,7 +1806,7 @@ fn parse_fn(p: parser, proto: ast::proto, purity: ast::purity,\n \n fn parse_fn_header(p: parser) -> {ident: ast::ident, tps: [ast::ty_param]} {\n     let id = parse_value_ident(p);\n-    let ty_params = parse_ty_params(p, ast::kind_copyable);\n+    let ty_params = parse_ty_params(p);\n     ret {ident: id, tps: ty_params};\n }\n \n@@ -1864,7 +1859,7 @@ fn parse_method(p: parser) -> @ast::method {\n fn parse_item_obj(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n-    let ty_params = parse_ty_params(p, ast::kind_copyable);\n+    let ty_params = parse_ty_params(p);\n     let fields: ast::spanned<[ast::obj_field]> =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                   parse_obj_field, p);\n@@ -1881,7 +1876,7 @@ fn parse_item_obj(p: parser, attrs: [ast::attribute]) -> @ast::item {\n fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n-    let ty_params = parse_ty_params(p, ast::kind_noncopyable);\n+    let ty_params = parse_ty_params(p);\n     expect(p, token::LPAREN);\n     let arg_ident = parse_value_ident(p);\n     expect(p, token::COLON);\n@@ -2045,7 +2040,7 @@ fn parse_type_decl(p: parser) -> {lo: uint, ident: ast::ident} {\n \n fn parse_item_type(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let t = parse_type_decl(p);\n-    let tps = parse_ty_params(p, ast::kind_noncopyable);\n+    let tps = parse_ty_params(p);\n     expect(p, token::EQ);\n     let ty = parse_ty(p, false);\n     let hi = p.get_hi_pos();\n@@ -2056,7 +2051,7 @@ fn parse_item_type(p: parser, attrs: [ast::attribute]) -> @ast::item {\n fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let id = parse_ident(p);\n-    let ty_params = parse_ty_params(p, ast::kind_noncopyable);\n+    let ty_params = parse_ty_params(p);\n     let variants: [ast::variant] = [];\n     // Newtype syntax\n     if p.peek() == token::EQ {"}, {"sha": "bf87410b885cbf7162c89650f7925961fef8a47c", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1167,12 +1167,11 @@ fn print_arg_mode(s: ps, m: ast::mode) {\n     }\n }\n \n-fn print_kind(s: ps, kind: ast::plicit<ast::kind>) {\n+fn print_kind(s: ps, kind: ast::kind) {\n     alt kind {\n-      ast::explicit(ast::kind_sendable.) { word_nbsp(s, \"send\"); }\n-      ast::explicit(ast::kind_copyable.) { word_nbsp(s, \"copy\"); }\n-      ast::explicit(ast::kind_noncopyable.) { word_nbsp(s, \"nocopy\"); }\n-      ast::implicit(_) {}\n+      ast::kind_sendable. { word_nbsp(s, \"send\"); }\n+      ast::kind_copyable. { word_nbsp(s, \"copy\"); }\n+      ast::kind_noncopyable. {}\n     }\n }\n "}, {"sha": "6993eeee35ee09b66c6b2204bac159f011d0ea54", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -11,12 +11,12 @@ type interner<T> =\n      hasher: hashfn<T>,\n      eqer: eqfn<T>};\n \n-fn mk<T>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n+fn mk<copy T>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n     let m = map::mk_hashmap::<T, uint>(hasher, eqer);\n     ret {map: m, mutable vect: [], hasher: hasher, eqer: eqer};\n }\n \n-fn intern<T>(itr: interner<T>, val: T) -> uint {\n+fn intern<copy T>(itr: interner<T>, val: T) -> uint {\n     alt itr.map.find(val) {\n       some(idx) { ret idx; }\n       none. {\n@@ -31,7 +31,7 @@ fn intern<T>(itr: interner<T>, val: T) -> uint {\n // |get| isn't \"pure\" in the traditional sense, because it can go from\n // failing to returning a value as items are interned. But for typestate,\n // where we first check a pred and then rely on it, ceasing to fail is ok.\n-pure fn get<T>(itr: interner<T>, idx: uint) -> T {\n+pure fn get<copy T>(itr: interner<T>, idx: uint) -> T {\n     unchecked {\n         itr.vect[idx]\n     }"}, {"sha": "22c344e6200fc5d4b349c305efaed505d3fbbf84", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -21,7 +21,7 @@ fn hash_def(d: ast::def_id) -> uint {\n     ret h;\n }\n \n-fn new_def_hash<V>() -> std::map::hashmap<ast::def_id, V> {\n+fn new_def_hash<copy V>() -> std::map::hashmap<ast::def_id, V> {\n     let hasher: std::map::hashfn<ast::def_id> = hash_def;\n     let eqer: std::map::eqfn<ast::def_id> = def_eq;\n     ret std::map::mk_hashmap::<ast::def_id, V>(hasher, eqer);\n@@ -162,7 +162,7 @@ fn lit_in_range(l: @ast::lit, m1: @ast::lit, m2: @ast::lit) -> bool {\n     }\n }\n \n-fn ranges_overlap<T>(a1: T, a2: T, b1: T, b2: T) -> bool {\n+fn ranges_overlap<copy T>(a1: T, a2: T, b1: T, b2: T) -> bool {\n     let min1 = min(a1, a2);\n     let max1 = max(a1, a2);\n     let min2 = min(b1, b2);"}, {"sha": "bd9735034e3fba9b2b0fd7aad8690cd0943d718c", "filename": "src/comp/util/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Fcomp%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ffilesearch.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -55,7 +55,7 @@ fn mk_filesearch(maybe_sysroot: option::t<fs::path>,\n }\n \n // FIXME #1001: This can't be an obj method\n-fn search<T>(filesearch: filesearch, pick: pick<T>) -> option::t<T> {\n+fn search<copy T>(filesearch: filesearch, pick: pick<T>) -> option::t<T> {\n     for lib_search_path in filesearch.lib_search_paths() {\n         log #fmt[\"searching %s\", lib_search_path];\n         for path in fs::list_dir(lib_search_path) {"}, {"sha": "d6c57424b1e8eef70fa010f228f2025218d47fa3", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -224,7 +224,7 @@ fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n     check_variants_T(crate, codemap, filename, \"ty\", stolen.tys, pprust::ty_to_str, replace_ty_in_crate, cx);\n }\n \n-fn check_variants_T<T>(\n+fn check_variants_T<copy T>(\n   crate: ast::crate,\n   codemap: codemap::codemap,\n   filename: str,"}, {"sha": "caa43bab29cf7090be9e8e9d5572fc3e3ffcf7d0", "filename": "src/lib/comm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -39,7 +39,7 @@ native mod rustrt {\n     type void;\n     type rust_port;\n \n-    fn chan_id_send<uniq T>(t: *sys::type_desc,\n+    fn chan_id_send<send T>(t: *sys::type_desc,\n                             target_task: task::task, target_port: port_id,\n                             data: T) -> ctypes::uintptr_t;\n \n@@ -52,7 +52,7 @@ native mod rustrt {\n \n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n-    fn recv<uniq T>(port: *rustrt::rust_port) -> T;\n+    fn recv<send T>(port: *rustrt::rust_port) -> T;\n }\n \n type port_id = int;\n@@ -75,11 +75,11 @@ dropped.\n \n Channels may be duplicated and themselves transmitted over other channels.\n */\n-tag chan<uniq T> {\n+tag chan<send T> {\n     chan_t(task::task, port_id);\n }\n \n-resource port_ptr<uniq T>(po: *rustrt::rust_port) {\n+resource port_ptr<send T>(po: *rustrt::rust_port) {\n     // Once the port is detached it's guaranteed not to receive further\n     // messages\n     rustrt::rust_port_detach(po);\n@@ -103,7 +103,7 @@ transmitted. If a port value is copied, both copies refer to the same port.\n \n Ports may be associated with multiple <chan>s.\n */\n-tag port<uniq T> { port_t(@port_ptr<T>); }\n+tag port<send T> { port_t(@port_ptr<T>); }\n \n /*\n Function: send\n@@ -113,7 +113,7 @@ Sends data over a channel.\n The sent data is moved into the channel, whereupon the caller loses access\n to it.\n */\n-fn send<uniq T>(ch: chan<T>, -data: T) {\n+fn send<send T>(ch: chan<T>, -data: T) {\n     let chan_t(t, p) = ch;\n     let res = rustrt::chan_id_send(sys::get_type_desc::<T>(), t, p, data);\n     if res != 0u unsafe {\n@@ -128,7 +128,7 @@ Function: port\n \n Constructs a port.\n */\n-fn port<uniq T>() -> port<T> {\n+fn port<send T>() -> port<T> {\n     port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n }\n \n@@ -140,7 +140,7 @@ Receive from a port.\n If no data is available on the port then the task will block until data\n becomes available.\n */\n-fn recv<uniq T>(p: port<T>) -> T { ret rusti::recv(***p) }\n+fn recv<send T>(p: port<T>) -> T { ret rusti::recv(***p) }\n \n /*\n Function: chan\n@@ -149,6 +149,6 @@ Constructs a channel.\n \n The channel is bound to the port used to construct it.\n */\n-fn chan<uniq T>(p: port<T>) -> chan<T> {\n+fn chan<send T>(p: port<T>) -> chan<T> {\n     chan_t(task::get_task(), rustrt::get_port_id(***p))\n }"}, {"sha": "7c0a13bb5f8ab2ed3bf8102c6c23d2a80a7f6465", "filename": "src/lib/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -33,15 +33,15 @@ Section: Functions\n /*\n Function: create\n */\n-fn create<T>() -> t<T> {\n+fn create<copy T>() -> t<T> {\n     type cell<T> = option::t<T>;\n \n     let initial_capacity: uint = 32u; // 2^5\n      /**\n       * Grow is only called on full elts, so nelts is also len(elts), unlike\n       * elsewhere.\n       */\n-    fn grow<T>(nelts: uint, lo: uint, elts: [mutable cell<T>]) ->\n+    fn grow<copy T>(nelts: uint, lo: uint, elts: [mutable cell<T>]) ->\n        [mutable cell<T>] {\n         assert (nelts == vec::len(elts));\n         let rv = [mutable];\n@@ -60,7 +60,7 @@ fn create<T>() -> t<T> {\n     fn get<T>(elts: [mutable cell<T>], i: uint) -> T {\n         ret alt elts[i] { option::some(t) { t } _ { fail } };\n     }\n-    obj deque<shar T>(mutable nelts: uint,\n+    obj deque<copy T>(mutable nelts: uint,\n                       mutable lo: uint,\n                       mutable hi: uint,\n                       mutable elts: [mutable cell<T>]) {"}, {"sha": "89d47b20746a0c9d6f2a58a5595e5f273f73d893", "filename": "src/lib/either.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -39,7 +39,7 @@ Function: lefts\n \n Extracts from a vector of either all the left values.\n */\n-fn lefts<T, U>(eithers: [t<T, U>]) -> [T] {\n+fn lefts<copy T, U>(eithers: [t<T, U>]) -> [T] {\n     let result: [T] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { left(l) { result += [l]; } _ {/* fallthrough */ } }\n@@ -52,7 +52,7 @@ Function: rights\n \n Extracts from a vector of either all the right values\n */\n-fn rights<T, U>(eithers: [t<T, U>]) -> [U] {\n+fn rights<T, copy U>(eithers: [t<T, U>]) -> [U] {\n     let result: [U] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { right(r) { result += [r]; } _ {/* fallthrough */ } }\n@@ -68,7 +68,8 @@ Extracts from a vector of either all the left values and right values\n Returns a structure containing a vector of left values and a vector of\n right values.\n */\n-fn partition<T, U>(eithers: [t<T, U>]) -> {lefts: [T], rights: [U]} {\n+fn partition<copy T, copy U>(eithers: [t<T, U>])\n+    -> {lefts: [T], rights: [U]} {\n     let lefts: [T] = [];\n     let rights: [U] = [];\n     for elt: t<T, U> in eithers {"}, {"sha": "1f4e6b9491ad0bd8193d00ba1bc64841ca6b182c", "filename": "src/lib/fun_treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffun_treemap.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -50,7 +50,7 @@ Function: insert\n \n Insert a value into the map\n */\n-fn insert<K, V>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n+fn insert<copy K, copy V>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n     @alt m {\n        @empty. { node(@k, @v, @empty, @empty) }\n        @node(@kk, vv, left, right) {\n@@ -68,7 +68,7 @@ Function: find\n \n Find a value based on the key\n */\n-fn find<K, V>(m: treemap<K, V>, k: K) -> option<V> {\n+fn find<K, copy V>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty. { none }\n       node(@kk, @v, left, right) {\n@@ -84,7 +84,7 @@ Function: traverse\n \n Visit all pairs in the map in order.\n */\n-fn traverse<K, V>(m: treemap<K, V>, f: block(K, V)) {\n+fn traverse<K, copy V>(m: treemap<K, V>, f: block(K, V)) {\n     alt *m {\n       empty. { }\n       node(@k, @v, _, _) {"}, {"sha": "ab71209181917ab92915c62bdfc122e9494beb5c", "filename": "src/lib/list.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -25,7 +25,7 @@ Function: from_vec\n \n Create a list from a vector\n */\n-fn from_vec<T>(v: [const T]) -> list<T> {\n+fn from_vec<copy T>(v: [const T]) -> list<T> {\n     *vec::foldr({ |h, t| @cons(h, t) }, @nil::<T>, v)\n }\n \n@@ -44,7 +44,7 @@ ls - The list to fold\n z - The initial value\n f - The function to apply\n */\n-fn foldl<T, U>(ls: list<U>, z: T, f: block(T, U) -> T) -> T {\n+fn foldl<copy T, copy U>(ls: list<U>, z: T, f: block(T, U) -> T) -> T {\n     let accum: T = z;\n     let ls = ls;\n     while true {\n@@ -65,7 +65,8 @@ Apply function `f` to each element of `v`, starting from the first.\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n */\n-fn find<T, U>(ls: list<T>, f: block(T) -> option::t<U>) -> option::t<U> {\n+fn find<copy T, copy U>(ls: list<T>, f: block(T) -> option::t<U>)\n+    -> option::t<U> {\n     let ls = ls;\n     while true {\n         alt ls {\n@@ -83,7 +84,7 @@ Function: has\n \n Returns true if a list contains an element with the given value\n */\n-fn has<T>(ls: list<T>, elt: T) -> bool {\n+fn has<copy T>(ls: list<T>, elt: T) -> bool {\n     let ls = ls;\n     while true {\n         alt ls {\n@@ -99,7 +100,7 @@ Function: len\n \n Returns the length of a list\n */\n-fn len<T>(ls: list<T>) -> uint {\n+fn len<copy T>(ls: list<T>) -> uint {\n     fn count<T>(&&u: uint, _t: T) -> uint { ret u + 1u; }\n     ret foldl(ls, 0u, bind count(_, _));\n }\n@@ -109,7 +110,7 @@ Function: tail\n \n Returns all but the first element of a list\n */\n-fn tail<T>(ls: list<T>) -> list<T> {\n+fn tail<copy T>(ls: list<T>) -> list<T> {\n     alt ls { cons(_, tl) { ret *tl; } nil. { fail \"list empty\" } }\n }\n \n@@ -118,7 +119,7 @@ Function: head\n \n Returns the first element of a list\n */\n-fn head<T>(ls: list<T>) -> T {\n+fn head<copy T>(ls: list<T>) -> T {\n     alt ls { cons(hd, _) { ret hd; } nil. { fail \"list empty\" } }\n }\n \n@@ -127,7 +128,7 @@ Function: append\n \n Appends one list to another\n */\n-fn append<T>(l: list<T>, m: list<T>) -> list<T> {\n+fn append<copy T>(l: list<T>, m: list<T>) -> list<T> {\n     alt l {\n       nil. { ret m; }\n       cons(x, xs) { let rest = append(*xs, m); ret cons(x, @rest); }"}, {"sha": "c802b5b889ffa9c2eb77ead7e53338b8840b55ab", "filename": "src/lib/map.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -114,12 +114,13 @@ Parameters:\n hasher - The hash function for key type K\n eqer - The equality function for key type K\n */\n-fn mk_hashmap<K, V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n+fn mk_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n+    -> hashmap<K, V> {\n     let initial_capacity: uint = 32u; // 2^5\n \n     let load_factor: util::rational = {num: 3, den: 4};\n-    tag bucket<K, V> { nil; deleted; some(K, V); }\n-    fn make_buckets<K, V>(nbkts: uint) -> [mutable bucket<K, V>] {\n+    tag bucket<copy K, copy V> { nil; deleted; some(K, V); }\n+    fn make_buckets<copy K, copy V>(nbkts: uint) -> [mutable bucket<K, V>] {\n         ret vec::init_elt_mut::<bucket<K, V>>(nil::<K, V>, nbkts);\n     }\n     // Derive two hash functions from the one given by taking the upper\n@@ -146,9 +147,9 @@ fn mk_hashmap<K, V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n      * will fail.\n      */\n \n-    fn insert_common<K, V>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                           bkts: [mutable bucket<K, V>], nbkts: uint, key: K,\n-                           val: V) -> bool {\n+    fn insert_common<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>,\n+                                     bkts: [mutable bucket<K, V>],\n+                                     nbkts: uint, key: K, val: V) -> bool {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n         while i < nbkts {\n@@ -166,9 +167,9 @@ fn mk_hashmap<K, V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n         }\n         fail; // full table\n     }\n-    fn find_common<K, V>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                         bkts: [mutable bucket<K, V>], nbkts: uint, key: K) ->\n-       option::t<V> {\n+    fn find_common<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>,\n+                                   bkts: [mutable bucket<K, V>],\n+                                   nbkts: uint, key: K) -> option::t<V> {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n         while i < nbkts {\n@@ -187,9 +188,11 @@ fn mk_hashmap<K, V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n         }\n         ret option::none;\n     }\n-    fn rehash<K, V>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                    oldbkts: [mutable bucket<K, V>], _noldbkts: uint,\n-                    newbkts: [mutable bucket<K, V>], nnewbkts: uint) {\n+    fn rehash<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>,\n+                              oldbkts: [mutable bucket<K, V>],\n+                              _noldbkts: uint,\n+                              newbkts: [mutable bucket<K, V>],\n+                              nnewbkts: uint) {\n         for b: bucket<K, V> in oldbkts {\n             alt b {\n               some(k_, v_) {\n@@ -201,7 +204,7 @@ fn mk_hashmap<K, V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n             }\n         }\n     }\n-    obj hashmap<shar K, shar V>(hasher: hashfn<K>,\n+    obj hashmap<copy K, copy V>(hasher: hashfn<K>,\n                                 eqer: eqfn<K>,\n                                 mutable bkts: [mutable bucket<K, V>],\n                                 mutable nbkts: uint,\n@@ -291,7 +294,7 @@ Function: new_str_hash\n \n Construct a hashmap for string keys\n */\n-fn new_str_hash<V>() -> hashmap<str, V> {\n+fn new_str_hash<copy V>() -> hashmap<str, V> {\n     ret mk_hashmap(str::hash, str::eq);\n }\n \n@@ -300,7 +303,7 @@ Function: new_int_hash\n \n Construct a hashmap for int keys\n */\n-fn new_int_hash<V>() -> hashmap<int, V> {\n+fn new_int_hash<copy V>() -> hashmap<int, V> {\n     fn hash_int(&&x: int) -> uint { ret x as uint; }\n     fn eq_int(&&a: int, &&b: int) -> bool { ret a == b; }\n     ret mk_hashmap(hash_int, eq_int);\n@@ -311,7 +314,7 @@ Function: new_uint_hash\n \n Construct a hashmap for uint keys\n */\n-fn new_uint_hash<V>() -> hashmap<uint, V> {\n+fn new_uint_hash<copy V>() -> hashmap<uint, V> {\n     fn hash_uint(&&x: uint) -> uint { ret x; }\n     fn eq_uint(&&a: uint, &&b: uint) -> bool { ret a == b; }\n     ret mk_hashmap(hash_uint, eq_uint);"}, {"sha": "47cfdef323ed81bdd23dba42e3509c97609a438d", "filename": "src/lib/math.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmath.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -73,11 +73,11 @@ Function: min\n \n Returns the minimum of two values\n */\n-fn min<T>(x: T, y: T) -> T { x < y ? x : y }\n+fn min<copy T>(x: T, y: T) -> T { x < y ? x : y }\n \n /*\n Function: max\n \n Returns the maximum of two values\n */\n-fn max<T>(x: T, y: T) -> T { x < y ? y : x }\n+fn max<copy T>(x: T, y: T) -> T { x < y ? y : x }"}, {"sha": "550f53470bbe8d0e9db5cc7924859abbf808a739", "filename": "src/lib/result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fresult.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -103,7 +103,8 @@ Example:\n > })\n \n */\n-fn chain<T, U, V>(res: t<T, V>, op: block(T) -> t<U, V>) -> t<U, V> {\n+fn chain<T, copy U, copy V>(res: t<T, V>, op: block(T) -> t<U, V>)\n+    -> t<U, V> {\n     alt res {\n       ok(t) { op(t) }\n       err(e) { err(e) }"}, {"sha": "4702a2adab49bc01986319a4b41b6f734837a038", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -29,7 +29,7 @@ Function: insert\n Add a value to the map. If the map already contains a value for\n the specified key then the original value is replaced.\n */\n-fn insert<T>(m: smallintmap<T>, key: uint, val: T) {\n+fn insert<copy T>(m: smallintmap<T>, key: uint, val: T) {\n     vec::grow_set::<option::t<T>>(m.v, key, none::<T>, some::<T>(val));\n }\n \n@@ -39,7 +39,7 @@ Function: find\n Get the value for the specified key. If the key does not exist\n in the map then returns none.\n */\n-fn find<T>(m: smallintmap<T>, key: uint) -> option::t<T> {\n+fn find<copy T>(m: smallintmap<T>, key: uint) -> option::t<T> {\n     if key < vec::len::<option::t<T>>(m.v) { ret m.v[key]; }\n     ret none::<T>;\n }\n@@ -53,10 +53,10 @@ Failure:\n \n If the key does not exist in the map\n */\n-fn get<T>(m: smallintmap<T>, key: uint) -> T {\n-    alt find::<T>(m, key) {\n-      none::<T>. { log_err \"smallintmap::get(): key not present\"; fail; }\n-      some::<T>(v) { ret v; }\n+fn get<copy T>(m: smallintmap<T>, key: uint) -> T {\n+    alt find(m, key) {\n+      none. { log_err \"smallintmap::get(): key not present\"; fail; }\n+      some(v) { ret v; }\n     }\n }\n \n@@ -65,13 +65,13 @@ Method: contains_key\n \n Returns true if the map contains a value for the specified key\n */\n-fn contains_key<T>(m: smallintmap<T>, key: uint) -> bool {\n+fn contains_key<copy T>(m: smallintmap<T>, key: uint) -> bool {\n     ret !option::is_none(find::<T>(m, key));\n }\n \n // FIXME: Are these really useful?\n \n-fn truncate<T>(m: smallintmap<T>, len: uint) {\n+fn truncate<copy T>(m: smallintmap<T>, len: uint) {\n     m.v = vec::slice_mut::<option::t<T>>(m.v, 0u, len);\n }\n "}, {"sha": "38ab4f3cfb1897d98e2ff0929aa0600268fd8c4f", "filename": "src/lib/sort.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -20,8 +20,8 @@ Merge sort. Returns a new vector containing the sorted list.\n Has worst case O(n log n) performance, best case O(n), but\n is not space efficient. This is a stable sort.\n */\n-fn merge_sort<T>(le: lteq<T>, v: [const T]) -> [T] {\n-    fn merge<T>(le: lteq<T>, a: [T], b: [T]) -> [T] {\n+fn merge_sort<copy T>(le: lteq<T>, v: [const T]) -> [T] {\n+    fn merge<copy T>(le: lteq<T>, a: [T], b: [T]) -> [T] {\n         let rs: [T] = [];\n         let a_len: uint = len::<T>(a);\n         let a_ix: uint = 0u;\n@@ -46,30 +46,24 @@ fn merge_sort<T>(le: lteq<T>, v: [const T]) -> [T] {\n     ret merge::<T>(le, merge_sort::<T>(le, a), merge_sort::<T>(le, b));\n }\n \n-fn swap<T>(arr: [mutable T], x: uint, y: uint) {\n-    let a = arr[x];\n-    arr[x] = arr[y];\n-    arr[y] = a;\n-}\n-\n-fn part<T>(compare_func: lteq<T>, arr: [mutable T], left: uint, right: uint,\n-            pivot: uint) -> uint {\n+fn part<copy T>(compare_func: lteq<T>, arr: [mutable T], left: uint,\n+                right: uint, pivot: uint) -> uint {\n     let pivot_value = arr[pivot];\n-    swap::<T>(arr, pivot, right);\n+    arr[pivot] <-> arr[right];\n     let storage_index: uint = left;\n     let i: uint = left;\n     while i < right {\n-        if compare_func({ arr[i] }, pivot_value) {\n-            swap::<T>(arr, i, storage_index);\n+        if compare_func(copy arr[i], pivot_value) {\n+            arr[i] <-> arr[storage_index];\n             storage_index += 1u;\n         }\n         i += 1u;\n     }\n-    swap::<T>(arr, storage_index, right);\n+    arr[storage_index] <-> arr[right];\n     ret storage_index;\n }\n \n-fn qsort<T>(compare_func: lteq<T>, arr: [mutable T], left: uint,\n+fn qsort<copy T>(compare_func: lteq<T>, arr: [mutable T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -90,13 +84,13 @@ Quicksort. Sorts a mutable vector in place.\n Has worst case O(n^2) performance, average case O(n log n).\n This is an unstable sort.\n */\n-fn quick_sort<T>(compare_func: lteq<T>, arr: [mutable T]) {\n+fn quick_sort<copy T>(compare_func: lteq<T>, arr: [mutable T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n \n-fn qsort3<T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n-              arr: [mutable T], left: int, right: int) {\n+fn qsort3<copy T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n+                  arr: [mutable T], left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr[right];\n     let i: int = left - 1;\n@@ -105,36 +99,36 @@ fn qsort3<T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n     let q: int = j;\n     while true {\n         i += 1;\n-        while compare_func_lt({ arr[i] }, v) { i += 1; }\n+        while compare_func_lt(copy arr[i], v) { i += 1; }\n         j -= 1;\n-        while compare_func_lt(v, { arr[j] }) {\n+        while compare_func_lt(v, copy arr[j]) {\n             if j == left { break; }\n             j -= 1;\n         }\n         if i >= j { break; }\n-        swap::<T>(arr, i as uint, j as uint);\n-        if compare_func_eq({ arr[i] }, v) {\n+        arr[i] <-> arr[j];\n+        if compare_func_eq(copy arr[i], v) {\n             p += 1;\n-            swap::<T>(arr, p as uint, i as uint);\n+            arr[p] <-> arr[i];\n         }\n-        if compare_func_eq(v, { arr[j] }) {\n+        if compare_func_eq(v, copy arr[j]) {\n             q -= 1;\n-            swap::<T>(arr, j as uint, q as uint);\n+            arr[j] <-> arr[q];\n         }\n     }\n-    swap::<T>(arr, i as uint, right as uint);\n+    arr[i] <-> arr[right];\n     j = i - 1;\n     i += 1;\n     let k: int = left;\n     while k < p {\n-        swap::<T>(arr, k as uint, j as uint);\n+        arr[k] <-> arr[j];\n         k += 1;\n         j -= 1;\n         if k == len::<T>(arr) as int { break; }\n     }\n     k = right - 1;\n     while k > q {\n-        swap::<T>(arr, i as uint, k as uint);\n+        arr[i] <-> arr[k];\n         k -= 1;\n         i += 1;\n         if k == 0 { break; }\n@@ -156,8 +150,8 @@ According to these slides this is the algorithm of choice for\n \n This is an unstable sort.\n */\n-fn quick_sort3<T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n-                  arr: [mutable T]) {\n+fn quick_sort3<copy T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n+                       arr: [mutable T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, 0,\n                 (len::<T>(arr) as int) - 1);"}, {"sha": "d5cda975a3a8b9eb97cb1640c7196e01a54e79d3", "filename": "src/lib/task.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -232,7 +232,7 @@ Returns:\n \n A handle to the new task\n */\n-fn spawn<uniq T>(-data: T, f: fn(T)) -> task {\n+fn spawn<send T>(-data: T, f: fn(T)) -> task {\n     spawn_inner(data, f, none)\n }\n \n@@ -245,7 +245,7 @@ termination\n Immediately before termination, either on success or failure, the spawned\n task will send a <task_notification> message on the provided channel.\n */\n-fn spawn_notify<uniq T>(-data: T, f: fn(T),\n+fn spawn_notify<send T>(-data: T, f: fn(T),\n                          notify: comm::chan<task_notification>) -> task {\n     spawn_inner(data, f, some(notify))\n }\n@@ -259,7 +259,7 @@ This is a convenience wrapper around spawn_notify which, when paired\n with <join> can be easily used to spawn a task then wait for it to\n complete.\n */\n-fn spawn_joinable<uniq T>(-data: T, f: fn(T)) -> joinable_task {\n+fn spawn_joinable<send T>(-data: T, f: fn(T)) -> joinable_task {\n     let p = comm::port::<task_notification>();\n     let id = spawn_notify(data, f, comm::chan::<task_notification>(p));\n     ret (id, p);\n@@ -275,11 +275,11 @@ fn spawn_joinable<uniq T>(-data: T, f: fn(T)) -> joinable_task {\n //\n // After the transition this should all be rewritten.\n \n-fn spawn_inner<uniq T>(-data: T, f: fn(T),\n+fn spawn_inner<send T>(-data: T, f: fn(T),\n                           notify: option<comm::chan<task_notification>>)\n     -> task unsafe {\n \n-    fn wrapper<uniq T>(-data: *u8, f: fn(T)) unsafe {\n+    fn wrapper<send T>(-data: *u8, f: fn(T)) unsafe {\n         let data: ~T = unsafe::reinterpret_cast(data);\n         f(*data);\n     }"}, {"sha": "d827d77583176fed5f5c4612499b2d1d99956d51", "filename": "src/lib/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -109,8 +109,8 @@ fn run_tests_console(opts: test_opts,\n     run_tests_console_(opts, tests, default_test_to_task)\n }\n \n-fn run_tests_console_<T>(opts: test_opts, tests: [test_desc<T>],\n-                          to_task: test_to_task<T>) -> bool {\n+fn run_tests_console_<copy T>(opts: test_opts, tests: [test_desc<T>],\n+                              to_task: test_to_task<T>) -> bool {\n \n     type test_state =\n         @{out: io::writer,\n@@ -121,7 +121,7 @@ fn run_tests_console_<T>(opts: test_opts, tests: [test_desc<T>],\n           mutable ignored: uint,\n           mutable failures: [test_desc<T>]};\n \n-    fn callback<T>(event: testevent<T>, st: test_state) {\n+    fn callback<copy T>(event: testevent<T>, st: test_state) {\n         alt event {\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n@@ -214,9 +214,9 @@ tag testevent<T> {\n     te_result(test_desc<T>, test_result);\n }\n \n-fn run_tests<T>(opts: test_opts, tests: [test_desc<T>],\n-                 to_task: test_to_task<T>,\n-                 callback: fn@(testevent<T>)) {\n+fn run_tests<copy T>(opts: test_opts, tests: [test_desc<T>],\n+                     to_task: test_to_task<T>,\n+                     callback: fn@(testevent<T>)) {\n \n     let filtered_tests = filter_tests(opts, tests);\n     callback(te_filtered(filtered_tests));\n@@ -248,8 +248,8 @@ fn run_tests<T>(opts: test_opts, tests: [test_desc<T>],\n \n fn get_concurrency() -> uint { rustrt::sched_threads() }\n \n-fn filter_tests<T>(opts: test_opts,\n-                    tests: [test_desc<T>]) -> [test_desc<T>] {\n+fn filter_tests<copy T>(opts: test_opts,\n+                        tests: [test_desc<T>]) -> [test_desc<T>] {\n     let filtered = tests;\n \n     // Remove tests that don't match the test filter\n@@ -262,7 +262,7 @@ fn filter_tests<T>(opts: test_opts,\n           option::none. { \"\" }\n         };\n \n-        fn filter_fn<T>(test: test_desc<T>, filter_str: str) ->\n+        fn filter_fn<copy T>(test: test_desc<T>, filter_str: str) ->\n             option::t<test_desc<T>> {\n             if str::find(test.name, filter_str) >= 0 {\n                 ret option::some(test);\n@@ -278,7 +278,7 @@ fn filter_tests<T>(opts: test_opts,\n     filtered = if !opts.run_ignored {\n         filtered\n     } else {\n-        fn filter<T>(test: test_desc<T>) -> option::t<test_desc<T>> {\n+        fn filter<copy T>(test: test_desc<T>) -> option::t<test_desc<T>> {\n             if test.ignore {\n                 ret option::some({name: test.name,\n                                   fn: test.fn,\n@@ -304,8 +304,8 @@ fn filter_tests<T>(opts: test_opts,\n \n type test_future<T> = {test: test_desc<T>, wait: fn@() -> test_result};\n \n-fn run_test<T>(test: test_desc<T>,\n-                to_task: test_to_task<T>) -> test_future<T> {\n+fn run_test<copy T>(test: test_desc<T>,\n+                    to_task: test_to_task<T>) -> test_future<T> {\n     if test.ignore {\n         ret {test: test, wait: fn () -> test_result { tr_ignored }};\n     }"}, {"sha": "35d87cd518f391e9aa5fa670527393afa3246427", "filename": "src/lib/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftreemap.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -44,7 +44,7 @@ Function: insert\n \n Insert a value into the map\n */\n-fn insert<K, V>(m: treemap<K, V>, k: K, v: V) {\n+fn insert<copy K, copy V>(m: treemap<K, V>, k: K, v: V) {\n     alt m {\n       @empty. { *m = node(@k, @v, @mutable empty, @mutable empty); }\n       @node(@kk, _, _, _) {\n@@ -63,7 +63,7 @@ Function: find\n \n Find a value based on the key\n */\n-fn find<K, V>(m: treemap<K, V>, k: K) -> option<V> {\n+fn find<copy K, copy V>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty. { none }\n       node(@kk, @v, _, _) {"}, {"sha": "77d4c10dbe05a5985f1b45b9044351c7e247b59f", "filename": "src/lib/vec.rs", "status": "modified", "additions": 38, "deletions": 44, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -121,7 +121,7 @@ Creates and initializes an immutable vector.\n Creates an immutable vector of size `n_elts` and initializes the elements\n to the value `t`.\n */\n-fn init_elt<T>(t: T, n_elts: uint) -> [T] {\n+fn init_elt<copy T>(t: T, n_elts: uint) -> [T] {\n     let v = [];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -138,7 +138,7 @@ Creates and initializes a mutable vector.\n Creates a mutable vector of size `n_elts` and initializes the elements\n to the value `t`.\n */\n-fn init_elt_mut<T>(t: T, n_elts: uint) -> [mutable T] {\n+fn init_elt_mut<copy T>(t: T, n_elts: uint) -> [mutable T] {\n     let v = [mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -153,7 +153,7 @@ Function: to_mut\n \n Produces a mutable vector from an immutable vector.\n */\n-fn to_mut<T>(v: [T]) -> [mutable T] {\n+fn to_mut<copy T>(v: [T]) -> [mutable T] {\n     let vres = [mutable];\n     for t: T in v { vres += [mutable t]; }\n     ret vres;\n@@ -165,7 +165,7 @@ Function: from_mut\n \n Produces an immutable vector from a mutable vector.\n */\n-fn from_mut<T>(v: [mutable T]) -> [T] {\n+fn from_mut<copy T>(v: [mutable T]) -> [T] {\n     let vres = [];\n     for t: T in v { vres += [t]; }\n     ret vres;\n@@ -181,7 +181,7 @@ Returns the first element of a vector\n Predicates:\n <is_not_empty> (v)\n */\n-fn head<T>(v: [const T]) : is_not_empty(v) -> T { ret v[0]; }\n+fn head<copy T>(v: [const T]) : is_not_empty(v) -> T { ret v[0]; }\n \n /*\n Function: tail\n@@ -191,7 +191,7 @@ Returns all but the first element of a vector\n Predicates:\n <is_not_empty> (v)\n */\n-fn tail<T>(v: [const T]) : is_not_empty(v) -> [T] {\n+fn tail<copy T>(v: [const T]) : is_not_empty(v) -> [T] {\n     ret slice(v, 1u, len(v));\n }\n \n@@ -206,7 +206,7 @@ Returns all but the last elemnt of a vector\n Preconditions:\n `v` is not empty\n */\n-fn init<T>(v: [const T]) -> [T] {\n+fn init<copy T>(v: [const T]) -> [T] {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u)\n }\n@@ -221,7 +221,7 @@ Returns:\n An option containing the last element of `v` if `v` is not empty, or\n none if `v` is empty.\n */\n-fn last<T>(v: [const T]) -> option::t<T> {\n+fn last<copy T>(v: [const T]) -> option::t<T> {\n     if len(v) == 0u { ret none; }\n     ret some(v[len(v) - 1u]);\n }\n@@ -234,7 +234,7 @@ Returns the last element of a non-empty vector `v`\n Predicates:\n <is_not_empty> (v)\n */\n-fn last_total<T>(v: [const T]) : is_not_empty(v) -> T {\n+fn last_total<copy T>(v: [const T]) : is_not_empty(v) -> T {\n     ret v[len(v) - 1u];\n }\n \n@@ -243,7 +243,7 @@ Function: slice\n \n Returns a copy of the elements from [`start`..`end`) from `v`.\n */\n-fn slice<T>(v: [const T], start: uint, end: uint) -> [T] {\n+fn slice<copy T>(v: [const T], start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = [];\n@@ -259,7 +259,7 @@ Function: slice_mut\n \n Returns a copy of the elements from [`start`..`end`) from `v`.\n */\n-fn slice_mut<T>(v: [const T], start: uint, end: uint) -> [mutable T] {\n+fn slice_mut<copy T>(v: [const T], start: uint, end: uint) -> [mutable T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = [mutable];\n@@ -277,7 +277,7 @@ Function: shift\n \n Removes the first element from a vector and return it\n */\n-fn shift<T>(&v: [const T]) -> T {\n+fn shift<copy T>(&v: [const T]) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n     let e = v[0];\n@@ -291,7 +291,7 @@ Function: pop\n \n Remove the last element from a vector and return it\n */\n-fn pop<T>(&v: [const T]) -> T {\n+fn pop<copy T>(&v: [const T]) -> T {\n     let ln = len(v);\n     assert (ln > 0u);\n     ln -= 1u;\n@@ -316,7 +316,7 @@ v - The vector to grow\n n - The number of elements to add\n initval - The value for the new elements\n */\n-fn grow<T>(&v: [T], n: uint, initval: T) {\n+fn grow<copy T>(&v: [T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [initval]; i += 1u; }\n@@ -335,7 +335,7 @@ v - The vector to grow\n n - The number of elements to add\n initval - The value for the new elements\n */\n-fn grow_mut<T>(&v: [mutable T], n: uint, initval: T) {\n+fn grow_mut<copy T>(&v: [mutable T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [mutable initval]; i += 1u; }\n@@ -371,7 +371,7 @@ Sets the element at position `index` to `val`. If `index` is past the end\n of the vector, expands the vector by replicating `initval` to fill the\n intervening space.\n */\n-fn grow_set<T>(&v: [mutable T], index: uint, initval: T, val: T) {\n+fn grow_set<copy T>(&v: [mutable T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n }\n@@ -384,12 +384,12 @@ Function: map\n \n Apply a function to each element of a vector and return the results\n */\n-fn map<T, U>(f: block(T) -> U, v: [const T]) -> [U] {\n+fn map<copy T, U>(f: block(T) -> U, v: [const T]) -> [U] {\n     let result = [];\n     reserve(result, len(v));\n     for elem: T in v {\n-        let elem2 = elem; // satisfies alias checker\n-        result += [f(elem2)];\n+        // copy satisfies alias checker\n+        result += [f(copy elem)];\n     }\n     ret result;\n }\n@@ -399,12 +399,12 @@ Function: map2\n \n Apply a function to each pair of elements and return the results\n */\n-fn map2<T, U, V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n-    let v0_len = len::<T>(v0);\n-    if v0_len != len::<U>(v1) { fail; }\n+fn map2<copy T, copy U, V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n+    let v0_len = len(v0);\n+    if v0_len != len(v1) { fail; }\n     let u: [V] = [];\n     let i = 0u;\n-    while i < v0_len { u += [f({ v0[i] }, { v1[i] })]; i += 1u; }\n+    while i < v0_len { u += [f(copy v0[i], copy v1[i])]; i += 1u; }\n     ret u;\n }\n \n@@ -416,11 +416,11 @@ Apply a function to each element of a vector and return the results\n If function `f` returns `none` then that element is excluded from\n the resulting vector.\n */\n-fn filter_map<T, U>(f: block(T) -> option::t<U>, v: [const T]) -> [U] {\n+fn filter_map<copy T, copy U>(f: block(T) -> option::t<U>, v: [const T])\n+    -> [U] {\n     let result = [];\n     for elem: T in v {\n-        let elem2 = elem; // satisfies alias checker\n-        alt f(elem2) {\n+        alt f(copy elem) {\n           none. {/* no-op */ }\n           some(result_elem) { result += [result_elem]; }\n         }\n@@ -437,13 +437,10 @@ holds.\n Apply function `f` to each element of `v` and return a vector containing\n only those elements for which `f` returned true.\n */\n-fn filter<T>(f: block(T) -> bool, v: [const T]) -> [T] {\n+fn filter<copy T>(f: block(T) -> bool, v: [T]) -> [T] {\n     let result = [];\n     for elem: T in v {\n-        let elem2 = elem; // satisfies alias checker\n-        if f(elem2) {\n-            result += [elem2];\n-        }\n+        if f(elem) { result += [elem]; }\n     }\n     ret result;\n }\n@@ -454,8 +451,7 @@ Function: concat\n Concatenate a vector of vectors. Flattens a vector of vectors of T into\n a single vector of T.\n */\n-fn concat<T>(v: [const [const T]]) -> [T] {\n-    // FIXME: So much copying\n+fn concat<copy T>(v: [const [const T]]) -> [T] {\n     let new: [T] = [];\n     for inner: [T] in v { new += inner; }\n     ret new;\n@@ -466,7 +462,7 @@ Function: foldl\n \n Reduce a vector from left to right\n */\n-fn foldl<T, U>(p: block(T, U) -> T, z: T, v: [const U]) -> T {\n+fn foldl<copy T, U>(p: block(T, U) -> T, z: T, v: [const U]) -> T {\n     let accum = z;\n     iter(v) { |elt|\n         accum = p(accum, elt);\n@@ -479,7 +475,7 @@ Function: foldr\n \n Reduce a vector from right to left\n */\n-fn foldr<T, U>(p: block(T, U) -> U, z: U, v: [const T]) -> U {\n+fn foldr<T, copy U>(p: block(T, U) -> U, z: U, v: [const T]) -> U {\n     let accum = z;\n     riter(v) { |elt|\n         accum = p(elt, accum);\n@@ -541,7 +537,7 @@ Apply function `f` to each element of `v`, starting from the first.\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n */\n-fn find<T>(f: block(T) -> bool, v: [T]) -> option::t<T> {\n+fn find<copy T>(f: block(T) -> bool, v: [T]) -> option::t<T> {\n     for elt: T in v { if f(elt) { ret some(elt); } }\n     ret none;\n }\n@@ -587,7 +583,7 @@ vector contains the first element of the i-th tuple of the input vector,\n and the i-th element of the second vector contains the second element\n of the i-th tuple of the input vector.\n */\n-fn unzip<T, U>(v: [(T, U)]) -> ([T], [U]) {\n+fn unzip<copy T, copy U>(v: [(T, U)]) -> ([T], [U]) {\n     let as = [], bs = [];\n     for (a, b) in v { as += [a]; bs += [b]; }\n     ret (as, bs);\n@@ -605,7 +601,7 @@ Preconditions:\n \n <same_length> (v, u)\n */\n-fn zip<T, U>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n+fn zip<copy T, copy U>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n     let zipped = [];\n     let sz = len(v), i = 0u;\n     assert (sz == len(u));\n@@ -624,9 +620,7 @@ a - The index of the first element\n b - The index of the second element\n */\n fn swap<T>(v: [mutable T], a: uint, b: uint) {\n-    let t: T = v[a];\n-    v[a] = v[b];\n-    v[b] = t;\n+    v[a] <-> v[b];\n }\n \n /*\n@@ -637,7 +631,7 @@ Reverse the order of elements in a vector, in place\n fn reverse<T>(v: [mutable T]) {\n     let i: uint = 0u;\n     let ln = len::<T>(v);\n-    while i < ln / 2u { swap(v, i, ln - i - 1u); i += 1u; }\n+    while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n }\n \n \n@@ -646,7 +640,7 @@ Function: reversed\n \n Returns a vector with the order of elements reversed\n */\n-fn reversed<T>(v: [const T]) -> [T] {\n+fn reversed<copy T>(v: [const T]) -> [T] {\n     let rs: [T] = [];\n     let i = len::<T>(v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n@@ -746,7 +740,7 @@ is sorted then the permutations are lexicographically sorted).\n The total number of permutations produced is `len(v)!`.  If `v` contains\n repeated elements, then some permutations are repeated.\n */\n-fn permute<T>(v: [const T], put: block([T])) {\n+fn permute<copy T>(v: [const T], put: block([T])) {\n   let ln = len(v);\n   if ln == 0u {\n     put([]);"}, {"sha": "5f6c1e92309f99b028038a4ea3e841ef590cff4e", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -55,25 +55,25 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter<uniq K, uniq V> = fn(K, V);\n+    type putter<send K, send V> = fn(K, V);\n \n     // FIXME: the first K1 parameter should probably be a -, but that\n     // doesn't parse at the moment.\n-    type mapper<uniq K1, uniq K2, uniq V> = fn(K1, putter<K2, V>);\n+    type mapper<send K1, send K2, send V> = fn(K1, putter<K2, V>);\n \n-    type getter<uniq V> = fn() -> option<V>;\n+    type getter<send V> = fn() -> option<V>;\n \n-    type reducer<uniq K, uniq V> = fn(K, getter<V>);\n+    type reducer<send K, send V> = fn(K, getter<V>);\n \n-    tag ctrl_proto<uniq K, uniq V> {\n+    tag ctrl_proto<send K, send V> {\n         find_reducer(K, chan<chan<reduce_proto<V>>>);\n         mapper_done;\n     }\n \n-    tag reduce_proto<uniq V> { emit_val(V); done; ref; release; }\n+    tag reduce_proto<send V> { emit_val(V); done; ref; release; }\n \n-    fn start_mappers<uniq K1, uniq K2,\n-                     uniq V>(map: mapper<K1, K2, V>,\n+    fn start_mappers<send K1, send K2,\n+                     send V>(map: mapper<K1, K2, V>,\n                          ctrl: chan<ctrl_proto<K2, V>>, inputs: [K1]) ->\n        [joinable_task] {\n         let tasks = [];\n@@ -84,15 +84,15 @@ mod map_reduce {\n         ret tasks;\n     }\n \n-    fn map_task<uniq K1, uniq K2,\n-                uniq V>(-map: mapper<K1, K2, V>,\n+    fn map_task<send K1, send K2,\n+                send V>(-map: mapper<K1, K2, V>,\n                           -ctrl: chan<ctrl_proto<K2, V>>,\n                     -input: K1) {\n         // log_err \"map_task \" + input;\n         let intermediates = treemap::init();\n \n-        fn emit<uniq K2,\n-                uniq V>(im: treemap::treemap<K2, chan<reduce_proto<V>>>,\n+        fn emit<send K2,\n+                send V>(im: treemap::treemap<K2, chan<reduce_proto<V>>>,\n                     ctrl: chan<ctrl_proto<K2, V>>, key: K2, val: V) {\n             let c;\n             alt treemap::find(im, key) {\n@@ -110,15 +110,15 @@ mod map_reduce {\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n \n-        fn finish<uniq K, uniq V>(_k: K, v: chan<reduce_proto<V>>) {\n+        fn finish<send K, send V>(_k: K, v: chan<reduce_proto<V>>) {\n             send(v, release);\n         }\n         treemap::traverse(intermediates, finish);\n         send(ctrl, mapper_done);\n     }\n \n-    fn reduce_task<uniq K,\n-                   uniq V>(-reduce: reducer<K, V>, -key: K,\n+    fn reduce_task<send K,\n+                   send V>(-reduce: reducer<K, V>, -key: K,\n                        -out: chan<chan<reduce_proto<V>>>) {\n         let p = port();\n \n@@ -127,7 +127,7 @@ mod map_reduce {\n         let ref_count = 0;\n         let is_done = false;\n \n-        fn get<uniq V>(p: port<reduce_proto<V>>,\n+        fn get<send V>(p: port<reduce_proto<V>>,\n                          &ref_count: int, &is_done: bool)\n            -> option<V> {\n             while !is_done || ref_count > 0 {\n@@ -150,8 +150,8 @@ mod map_reduce {\n         reduce(key, bind get(p, ref_count, is_done));\n     }\n \n-    fn map_reduce<uniq K1, uniq K2,\n-                  uniq V>(map: mapper<K1, K2, V>, reduce: reducer<K2, V>,\n+    fn map_reduce<send K1, send K2,\n+                  send V>(map: mapper<K1, K2, V>, reduce: reducer<K2, V>,\n                       inputs: [K1]) {\n         let ctrl = port();\n \n@@ -194,7 +194,7 @@ mod map_reduce {\n             }\n         }\n \n-        fn finish<uniq K, uniq V>(_k: K, v: chan<reduce_proto<V>>) {\n+        fn finish<send K, send V>(_k: K, v: chan<reduce_proto<V>>) {\n             send(v, done);\n         }\n         treemap::traverse(reducers, finish);"}, {"sha": "b14bb3ddeddbb14f20fb7f894eb5e9a3d5444493", "filename": "src/test/compile-fail/block-copy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,5 +1,4 @@\n-// error-pattern: needed shared type, got pinned type block\n-// xfail-test\n+// error-pattern: copying a noncopyable value\n \n fn lol(f: block()) -> block() { ret f; }\n fn main() { let i = 8; let f = lol(block () { log_err i; }); f(); }"}, {"sha": "46807e05252bac3ae295e45b7fde93b2cc966814", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,5 @@\n-// error-pattern:cannot copy pinned type foo\n-// xfail-test\n+// error-pattern: copying a noncopyable value\n \n resource foo(i: int) { }\n \n-fn main() { let x <- foo(10); let y = x; }\n+fn main() { let x <- foo(10); let y = x; log_err x; }"}, {"sha": "b4038b61d3e246f81963e894e60f6bce0c351112", "filename": "src/test/compile-fail/copy-res-into-box.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-box.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -1,16 +0,0 @@\n-// error-pattern:mismatched kinds for '@' operand\n-// xfail-test\n-resource r(i: @mutable int) {\n-    *i = *i + 1;\n-}\n-\n-fn main() {\n-    let i = @mutable 0;\n-    {\n-        let j <- r(i);\n-        // No no no no no\n-        let k <- @j;\n-    }\n-    log_err *i;\n-    assert *i == 2;\n-}\n\\ No newline at end of file"}, {"sha": "0fec1ba8a0429bb7fc95883c682a68a3fa24a1db", "filename": "src/test/compile-fail/copy-res-into-rec.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-rec.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -1,16 +0,0 @@\n-// error-pattern:mismatched kinds for record field\n-// xfail-test\n-resource r(i: @mutable int) {\n-    *i = *i + 1;\n-}\n-\n-fn main() {\n-    let i = @mutable 0;\n-    {\n-        let j <- r(i);\n-        // No no no no no\n-        let k <- {x: j};\n-    }\n-    log_err *i;\n-    assert *i == 2;\n-}\n\\ No newline at end of file"}, {"sha": "e9318ae428049f5668be8603e509f0065ebf69b3", "filename": "src/test/compile-fail/copy-res-into-tup.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-tup.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -1,16 +0,0 @@\n-// error-pattern:mismatched kinds for tuple parameter\n-// xfail-test\n-resource r(i: @mutable int) {\n-    *i = *i + 1;\n-}\n-\n-fn main() {\n-    let i = @mutable 0;\n-    {\n-        let j <- r(i);\n-        // No no no no no\n-        let k <- (j, 0);\n-    }\n-    log_err *i;\n-    assert *i == 2;\n-}\n\\ No newline at end of file"}, {"sha": "6fa1e852b4a49ed10ad02d603e48947c468408df", "filename": "src/test/compile-fail/copy-res-into-unique.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-res-into-unique.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -1,16 +0,0 @@\n-// error-pattern:mismatched kinds for '~' operand\n-// xfail-test\n-resource r(i: @mutable int) {\n-    *i = *i + 1;\n-}\n-\n-fn main() {\n-    let i = @mutable 0;\n-    {\n-        let j <- r(i);\n-        // No no no no no\n-        let k <- ~j;\n-    }\n-    log_err *i;\n-    assert *i == 2;\n-}\n\\ No newline at end of file"}, {"sha": "56238a6026fbdbbb7c120cde6beee72d89562583", "filename": "src/test/compile-fail/fn-compare-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-compare-mismatch.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:expected fn() but found fn(+int)\n+// error-pattern:expected fn() but found fn(++int)\n \n fn main() {\n     fn f() { }"}, {"sha": "2587e35219c6d59ad13a3470e728483236f4493d", "filename": "src/test/compile-fail/param-by-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fparam-by-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fparam-by-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fparam-by-value.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,4 +1,4 @@\n // error-pattern:can not pass a dynamically-sized type by value\n \n-fn f<T>(+_x: T) {}\n+fn f<T>(++_x: T) {}\n fn main() {}"}, {"sha": "3d6c6f0c6eb6a4b97f92fe34b31e4a2646c8f48b", "filename": "src/test/compile-fail/pinned-deep-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpinned-deep-copy.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,5 +1,4 @@\n-// error-pattern: cannot copy pinned type ~~~{y: r}\n-// xfail-test\n+// error-pattern: copying a noncopyable value\n \n resource r(i: @mutable int) {\n     *i = *i + 1;\n@@ -11,6 +10,7 @@ fn main() {\n         // Can't do this copy\n         let x = ~~~{y: r(i)};\n         let z = x;\n+        log x;\n     }\n     log_err *i;\n }\n\\ No newline at end of file"}, {"sha": "17855a30bd08d4aa5ddc7f02c5733c46b20b46cc", "filename": "src/test/compile-fail/resource-let2.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fresource-let2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fresource-let2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresource-let2.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -1,10 +0,0 @@\n-// error-pattern: mismatched kind\n-// xfail-test\n-\n-resource r(b: bool) {\n-}\n-\n-fn main() {\n-    let i <- r(true);\n-    let j = i;\n-}\n\\ No newline at end of file"}, {"sha": "6bde4cbc6a4bba61657a9779520d08b42a7f6173", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,11 +1,10 @@\n-// error-pattern: mismatched kind\n-// xfail-test\n+// error-pattern: copying a noncopyable value\n \n resource r(b: bool) {\n }\n \n fn main() {\n     let i <- ~r(true);\n-    let j;\n-    j = i;\n+    let j = i;\n+    log i;\n }\n\\ No newline at end of file"}, {"sha": "2a6530107017ec7c692934155ec5a0b0dcf8e02a", "filename": "src/test/compile-fail/unique-swap2.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Funique-swap2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Funique-swap2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-swap2.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -1,37 +0,0 @@\n-// error-pattern:needed shared type, got pinned type ~r\n-// xfail-test\n-\n-resource r(i: @mutable int) {\n-    *i += 1;\n-}\n-\n-fn test1() {\n-    let i = @mutable 100;\n-    let j = @mutable 200;\n-    {\n-        let x <- ~r(i);\n-        let y <- ~r(j);\n-        // This is currently not allowed because ~resource is pinned.\n-        // Note that ~resource is supposed to be shared.\n-        x <-> y;\n-        assert ***x == 200;\n-        assert ***y == 100;\n-    }\n-    assert *i == 101;\n-    assert *j == 201;\n-}\n-\n-fn test2() {\n-    let i = @mutable 0;\n-    {\n-        let x <- ~r(i);\n-        let y <- ~r(i);\n-        x <-> y;\n-    }\n-    assert *i == 2;\n-}\n-\n-fn main() {\n-    test1();\n-    test2();\n-}\n\\ No newline at end of file"}, {"sha": "ad172f7ae83d5effecceb7eb637dee204724d8dc", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,7 +1,6 @@\n-// error-pattern: needed unique type\n-// xfail-test\n+// error-pattern: instantiating a sendable type parameter with a copyable type\n \n-fn f<uniq T>(i: T) {\n+fn f<send T>(i: T) {\n }\n \n fn main() {"}, {"sha": "0b16c513350965992cc6a26981f3ac75f61a3f1a", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,12 +1,10 @@\n-// error-pattern: needed shared type, got pinned type ~r\n-// xfail-test\n+// error-pattern: copying a noncopyable value\n \n resource r(i: @mutable int) {\n     *i = *i + 1;\n }\n \n-fn f<T>(i: [T], j: [T]) {\n-    // Shouldn't be able to do this copy of j\n+fn f<T>(+i: [T], +j: [T]) {\n     let k = i + j;\n }\n \n@@ -16,6 +14,6 @@ fn main() {\n     let r1 <- [~r(i1)];\n     let r2 <- [~r(i2)];\n     f(r1, r2);\n-    log_err *i1;\n-    log_err *i2;\n+    log (r2, *i1);\n+    log (r1, *i2);\n }\n\\ No newline at end of file"}, {"sha": "e625ef138d45644e510f4956cd053776229d0e6c", "filename": "src/test/compile-fail/use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,5 +1,5 @@\n // error-pattern: Unsatisfied precondition constraint\n-fn send<uniq T>(ch: _chan<T>, -data: T) { log ch; log data; fail; }\n+fn send<send T>(ch: _chan<T>, -data: T) { log ch; log data; fail; }\n type _chan<T> = int;\n \n // Tests that \"log message;\" is flagged as using"}, {"sha": "168429b6c8fcc2c5766a354fd5593cb684dde3df", "filename": "src/test/compile-fail/vec-pinned-nocopy-2.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fvec-pinned-nocopy-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fvec-pinned-nocopy-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-pinned-nocopy-2.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -1,10 +0,0 @@\n-// error-pattern: mismatched kind\n-// xfail-test\n-\n-resource r(b: bool) {\n-}\n-\n-fn main() {\n-    let i <- [r(true)];\n-    i += [r(true)];\n-}\n\\ No newline at end of file"}, {"sha": "54493ea453605ab303ece6e2312dabc4c816dfee", "filename": "src/test/compile-fail/vec-pinned-nocopy-3.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fvec-pinned-nocopy-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fvec-pinned-nocopy-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-pinned-nocopy-3.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -1,11 +0,0 @@\n-// error-pattern: mismatched kind\n-// xfail-test\n-\n-resource r(b: bool) {\n-}\n-\n-fn main() {\n-    let i <- [r(true)];\n-    let j;\n-    j <- copy [r(true)];\n-}\n\\ No newline at end of file"}, {"sha": "91dfb4fd6f0634084b74165b733653ace5d70a2b", "filename": "src/test/compile-fail/vec-pinned-nocopy.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fvec-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f8ebb550cf7e641d7dedd56e08efd4f0e15afab/src%2Ftest%2Fcompile-fail%2Fvec-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-pinned-nocopy.rs?ref=8f8ebb550cf7e641d7dedd56e08efd4f0e15afab", "patch": "@@ -1,11 +0,0 @@\n-// error-pattern: mismatched kind\n-// xfail-test\n-\n-resource r(b: bool) {\n-}\n-\n-fn main() {\n-    let i <- [r(true)];\n-    let j;\n-    j = i;\n-}\n\\ No newline at end of file"}, {"sha": "818080a6e5589be4bbd6a791cb27604654f3178f", "filename": "src/test/compile-fail/vec-res-add.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,12 +1,11 @@\n-// error-pattern:mismatched kinds\n-// xfail-test\n+// error-pattern: copying a noncopyable value\n \n-resource r(i: int) {\n-}\n+resource r(_i: int) { }\n \n fn main() {\n     // This can't make sense as it would copy the resources\n     let i <- [r(0)];\n     let j <- [r(1)];\n     let k = i + j;\n-}\n\\ No newline at end of file\n+    log j;\n+}"}, {"sha": "a257a903fd24dce0e820dc3f97942756f8e23aae", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -4,8 +4,8 @@ fn test00_start(ch: chan_t<int>, message: int) { send(ch, copy message); }\n type task_id = int;\n type port_id = int;\n \n-type chan_t<uniq T> = {task: task_id, port: port_id};\n+type chan_t<send T> = {task: task_id, port: port_id};\n \n-fn send<uniq T>(ch: chan_t<T>, -data: T) { fail; }\n+fn send<send T>(ch: chan_t<T>, -data: T) { fail; }\n \n fn main() { fail \"quux\"; }"}, {"sha": "e227b3d4c930257868728a7e7dfbc0089cc1e49f", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -5,7 +5,7 @@ import std::comm::port;\n import std::comm::send;\n import std::comm::recv;\n \n-fn echo<uniq T>(c: chan<T>, oc: chan<chan<T>>) {\n+fn echo<send T>(c: chan<T>, oc: chan<chan<T>>) {\n     // Tests that the type argument in port gets\n     // visited\n     let p = port::<T>();"}, {"sha": "e701427a8a3a555a9387cee9771deb305a0abcb5", "filename": "src/test/run-pass/auto-instantiate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -2,6 +2,6 @@\n \n \n // -*- rust -*-\n-fn f<T, U>(x: T, y: U) -> {a: T, b: U} { ret {a: x, b: y}; }\n+fn f<copy T, copy U>(x: T, y: U) -> {a: T, b: U} { ret {a: x, b: y}; }\n \n fn main() { log f({x: 3, y: 4, z: 5}, 4).a.x; log f(5, 6).a; }"}, {"sha": "882a54f603b3ae616aa7b8a17d7193817c66d44e", "filename": "src/test/run-pass/bind-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fbind-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fbind-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-generic.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,12 +1,12 @@\n-fn wrapper3<T>(i: T, j: int) {\n+fn wrapper3<copy T>(i: T, j: int) {\n     log i;\n     log j;\n     // This is a regression test that the spawn3 thunk to wrapper3\n     // correctly finds the value of j\n     assert j == 123456789;\n }\n \n-fn spawn3<T>(i: T, j: int) {\n+fn spawn3<copy T>(i: T, j: int) {\n     let wrapped = bind wrapper3(i, j);\n     wrapped();\n }"}, {"sha": "56bcbb717adc5b70c2e9ca1232b81d47c36446ab", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,8 +1,8 @@\n \n \n-type box<T> = {c: @T};\n+type box<copy T> = {c: @T};\n \n-fn unbox<T>(b: box<T>) -> T { ret *b.c; }\n+fn unbox<copy T>(b: box<T>) -> T { ret *b.c; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "ba98b8546a11e67a9e933d2a8db78b4f95f28e00", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T>(expected: T, eq: compare<T>) {\n+fn test_generic<copy T>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "436689f68aac70e1b8aaead636ee5ec93f1a4876", "filename": "src/test/run-pass/expr-block-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -3,7 +3,7 @@\n // -*- rust -*-\n type compare<T> = fn@(~T, ~T) -> bool;\n \n-fn test_generic<T>(expected: ~T, eq: compare<T>) {\n+fn test_generic<copy T>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "fba64608186a86d78ce0f2ffe0c571bfacca2df8", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T>(expected: T, eq: compare<T>) {\n+fn test_generic<copy T>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "4424d144e150d39f9819520b9236c329227927a4", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -6,7 +6,7 @@\n // Tests for standalone blocks as expressions with dynamic type sizes\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T>(expected: T, eq: compare<T>) {\n+fn test_generic<copy T>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "da00556eb4e71634ae92df86cb84beff595b3f27", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T>(expected: T, not_expected: T, eq: compare<T>) {\n+fn test_generic<copy T>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "f98a8742cc2d9374e52d7b73d74343684c4d68b3", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -6,7 +6,7 @@\n // Tests for if as expressions with dynamic type sizes\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T>(expected: T, not_expected: T, eq: compare<T>) {\n+fn test_generic<copy T>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "bbfc3f53f26388512d4cfce2c965f92b1d486a67", "filename": "src/test/run-pass/fixed-point-bind-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,8 +1,8 @@\n-fn fix_help<A, uniq B>(f: fn(fn@(A) -> B, A) -> B, x: A) -> B {\n+fn fix_help<A, send B>(f: fn(fn@(A) -> B, A) -> B, x: A) -> B {\n     ret f(bind fix_help(f, _), x);\n }\n \n-fn fix<A, uniq B>(f: fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n+fn fix<A, send B>(f: fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n     ret bind fix_help(f, _);\n }\n "}, {"sha": "59a57b8597ce1e488d516706df2163be543376fc", "filename": "src/test/run-pass/fn-bare-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n // This is what the signature to spawn should look like with bare functions\n \n-fn spawn<uniq T>(val: T, f: fn(T)) {\n+fn spawn<send T>(val: T, f: fn(T)) {\n     f(val);\n }\n "}, {"sha": "5b696a0efe9c7a89567dfcab4e3b451e381be192", "filename": "src/test/run-pass/foreach-unique-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fforeach-unique-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fforeach-unique-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-unique-drop.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,5 +1,5 @@\n \n-obj ob<shar K>(k: K) {\n+obj ob<copy K>(k: K) {\n     fn foo(it: block(~{a: K})) { it(~{a: k}); }\n }\n "}, {"sha": "470815996ce6d64dae384dc62e2e7708e2e7eaa0", "filename": "src/test/run-pass/generic-alias-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<T>(t: T) -> T { ret t; }\n+fn id<copy T>(t: T) -> T { ret t; }\n \n fn main() {\n     let expected = @100;"}, {"sha": "1ca044ef1621d1f5aeb82540ba9e79bec7f9761c", "filename": "src/test/run-pass/generic-alias-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<uniq T>(t: T) -> T { ret t; }\n+fn id<send T>(t: T) -> T { ret t; }\n \n fn main() {\n     let expected = ~100;"}, {"sha": "c633cb2d08a5da5230842956101207199bf2beac", "filename": "src/test/run-pass/generic-bind-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<T>(t: T) -> T { ret t; }\n+fn id<copy T>(t: T) -> T { ret t; }\n \n fn main() {\n     let t = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7};"}, {"sha": "8464bfb02415ae8442c791333574514d85fecf06", "filename": "src/test/run-pass/generic-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<T>(t: T) -> T { ret t; }\n+fn id<copy T>(t: T) -> T { ret t; }\n \n fn main() {\n     let t = {_0: 1, _1: 2, _2: 3, _3: 4, _4: 5, _5: 6, _6: 7};"}, {"sha": "87465ae6a93d6c2f32248fa7568a086e856ba5cc", "filename": "src/test/run-pass/generic-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-box.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn box<T>(x: {x: T, y: T, z: T}) -> @{x: T, y: T, z: T} { ret @x; }\n+fn box<copy T>(x: {x: T, y: T, z: T}) -> @{x: T, y: T, z: T} { ret @x; }\n \n fn main() {\n     let x: @{x: int, y: int, z: int} = box::<int>({x: 1, y: 2, z: 3});"}, {"sha": "05f311167cf33b7c8a1b7bb7f2cf36918c2edcca", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,8 +1,8 @@\n \n \n-fn g<X>(x: X) -> X { ret x; }\n+fn g<copy X>(x: X) -> X { ret x; }\n \n-fn f<T>(t: T) -> {a: T, b: T} {\n+fn f<copy T>(t: T) -> {a: T, b: T} {\n     type pair = {a: T, b: T};\n \n     let x: pair = {a: t, b: t};"}, {"sha": "ced0ecfbe9e06ae43f5028589ad9be90f945f324", "filename": "src/test/run-pass/generic-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,5 +1,5 @@\n \n \n-fn f<T>(t: T) { let t1: T = t; }\n+fn f<copy T>(t: T) { let t1: T = t; }\n \n fn main() { let x = {x: @10, y: @12}; f(x); }"}, {"sha": "41315e1564303488d51310344c59a420fc44568c", "filename": "src/test/run-pass/generic-exterior-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,8 +1,8 @@\n \n \n-type recbox<T> = {x: @T};\n+type recbox<copy T> = {x: @T};\n \n-fn reclift<T>(t: T) -> recbox<T> { ret {x: @t}; }\n+fn reclift<copy T>(t: T) -> recbox<T> { ret {x: @t}; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "1a97c1347481938710e8af34b1f8aea414d026f1", "filename": "src/test/run-pass/generic-exterior-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n-type recbox<T> = {x: ~T};\n+type recbox<copy T> = {x: ~T};\n \n-fn reclift<T>(t: T) -> recbox<T> { ret {x: ~t}; }\n+fn reclift<copy T>(t: T) -> recbox<T> { ret {x: ~t}; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "57d4052e5a076e56429d7ff862c0b0f529040222", "filename": "src/test/run-pass/generic-fn-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -4,6 +4,6 @@\n // -*- rust -*-\n \n // Issue #45: infer type parameters in function applications\n-fn id<T>(x: T) -> T { ret x; }\n+fn id<copy T>(x: T) -> T { ret x; }\n \n fn main() { let x: int = 42; let y: int = id(x); assert (x == y); }"}, {"sha": "49cc760031513548096a9d0a7c0928bb6a35a649", "filename": "src/test/run-pass/generic-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,4 +1,4 @@\n \n-fn f<T>(x: ~T) -> ~T { ret x; }\n+fn f<copy T>(x: ~T) -> ~T { ret x; }\n \n fn main() { let x = f(~3); log *x; }"}, {"sha": "63350c44273ce6ec64068a1bfc668b71952c44b7", "filename": "src/test/run-pass/generic-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -2,7 +2,7 @@\n \n \n // -*- rust -*-\n-fn id<T>(x: T) -> T { ret x; }\n+fn id<copy T>(x: T) -> T { ret x; }\n \n type triple = {x: int, y: int, z: int};\n "}, {"sha": "5aa6769da642606ed5302b75c5d4917243983f8b", "filename": "src/test/run-pass/generic-obj-with-derived-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n \n \n-obj handle<shar T>(data: T) {\n+obj handle<copy T>(data: T) {\n     fn get() -> T { ret data; }\n }\n "}, {"sha": "fa90e5863b6733597d5a76d0c40ea01efc97d12b", "filename": "src/test/run-pass/generic-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n \n \n-obj buf<shar T>(data: {_0: T, _1: T, _2: T}) {\n+obj buf<copy T>(data: {_0: T, _1: T, _2: T}) {\n     fn get(i: int) -> T {\n         if i == 0 {\n             ret data._0;"}, {"sha": "7134c96d4e2d767411e07a3e92a6b0028570a402", "filename": "src/test/run-pass/generic-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,4 +1,4 @@\n-fn get_third<T>(t: (T, T, T)) -> T { let (_, _, x) = t; ret x; }\n+fn get_third<copy T>(t: (T, T, T)) -> T { let (_, _, x) = t; ret x; }\n \n fn main() {\n     log get_third((1, 2, 3));"}, {"sha": "3b6b19ce450d0cc854cc142bba02857b617e530a", "filename": "src/test/run-pass/generic-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,5 +1,5 @@\n \n-fn box<T>(x: {x: T, y: T, z: T}) -> ~{x: T, y: T, z: T} { ret ~x; }\n+fn box<copy T>(x: {x: T, y: T, z: T}) -> ~{x: T, y: T, z: T} { ret ~x; }\n \n fn main() {\n     let x: ~{x: int, y: int, z: int} = box::<int>({x: 1, y: 2, z: 3});"}, {"sha": "793df760b4b3bf239e55d116e611cfa62ec0be16", "filename": "src/test/run-pass/issue-333.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fissue-333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fissue-333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-333.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,5 +1,5 @@\n-fn quux<T>(x: T) -> T { let f = bind id::<T>(_); ret f(x); }\n+fn quux<copy T>(x: T) -> T { let f = bind id::<T>(_); ret f(x); }\n \n-fn id<T>(x: T) -> T { ret x; }\n+fn id<copy T>(x: T) -> T { ret x; }\n \n fn main() { assert (quux(10) == 10); }"}, {"sha": "9e45b0283866844ee99694715b894347c7add5ec", "filename": "src/test/run-pass/ivec-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fivec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fivec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-add.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,4 +1,4 @@\n-fn double<T>(a: T) -> [T] { ret [a] + [a]; }\n+fn double<copy T>(a: T) -> [T] { ret [a] + [a]; }\n \n fn double_int(a: int) -> [int] { ret [a] + [a]; }\n "}, {"sha": "5bb2171dfd2ea0d2881e749be13119d7478f1194", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,8 +1,8 @@\n tag myvec<X> = [X];\n \n-fn myvec_deref<X>(mv: myvec<X>) -> [X] { ret *mv; }\n+fn myvec_deref<copy X>(mv: myvec<X>) -> [X] { ret *mv; }\n \n-fn myvec_elt<X>(mv: myvec<X>) -> X { ret mv[0]; }\n+fn myvec_elt<copy X>(mv: myvec<X>) -> X { ret mv[0]; }\n \n fn main() {\n     let mv = myvec([1, 2, 3]);"}, {"sha": "3a85cba61621d9e63cd1918bdadb2e198e29737b", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -2,19 +2,19 @@ use std;\n \n import std::list::*;\n \n-pure fn pure_length_go<T>(ls: list<T>, acc: uint) -> uint {\n+pure fn pure_length_go<copy T>(ls: list<T>, acc: uint) -> uint {\n     alt ls { nil. { acc } cons(_, tl) { pure_length_go(*tl, acc + 1u) } }\n }\n \n-pure fn pure_length<T>(ls: list<T>) -> uint { pure_length_go(ls, 0u) }\n+pure fn pure_length<copy T>(ls: list<T>) -> uint { pure_length_go(ls, 0u) }\n \n-pure fn nonempty_list<T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<copy T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n \n // Of course, the compiler can't take advantage of the\n // knowledge that ls is a cons node. Future work.\n // Also, this is pretty contrived since nonempty_list\n // could be a \"tag refinement\", if we implement those.\n-fn safe_head<T>(ls: list<T>) : nonempty_list(ls) -> T { head(ls) }\n+fn safe_head<copy T>(ls: list<T>) : nonempty_list(ls) -> T { head(ls) }\n \n fn main() {\n     let mylist = cons(@1u, @nil);"}, {"sha": "ebfcf37e79d8a4681ef2c530bff894a936581b76", "filename": "src/test/run-pass/obj-return-polytypes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fobj-return-polytypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fobj-return-polytypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-return-polytypes.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -6,7 +6,7 @@ tag clam<T> { signed(int); unsigned(uint); }\n \n fn getclam<T>() -> clam<T> { ret signed::<T>(42); }\n \n-obj impatience<shar T>() {\n+obj impatience<copy T>() {\n     fn moreclam() -> clam<T> { be getclam::<T>(); }\n }\n "}, {"sha": "758beb3d9e12f3ca462dbe837d8c44d0fb4b222c", "filename": "src/test/run-pass/resource-in-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fresource-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fresource-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-in-struct.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -5,7 +5,7 @@ type closable = @mutable bool;\n \n resource close_res(i: closable) { *i = false; }\n \n-tag option<pin T> { none; some(T); }\n+tag option<T> { none; some(T); }\n \n fn sink(res: option<close_res>) { }\n "}, {"sha": "fe91c15c72dee636b8a9e1c2d198abefe89b6b23", "filename": "src/test/run-pass/ret-none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fret-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fret-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-none.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -2,6 +2,6 @@\n \n tag option<T> { none; some(T); }\n \n-fn f<T>() -> option<T> { ret none; }\n+fn f<copy T>() -> option<T> { ret none; }\n \n fn main() { f::<int>(); }"}, {"sha": "aad9a0696d11e841e49e9531cd1801e455c3ffe3", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -4,9 +4,9 @@ import std::comm::send;\n import std::comm::port;\n \n // tests that ctrl's type gets inferred properly\n-type command<uniq K, uniq V> = {key: K, val: V};\n+type command<send K, send V> = {key: K, val: V};\n \n-fn cache_server<uniq K, uniq V>(c: chan<chan<command<K, V>>>) {\n+fn cache_server<send K, send V>(c: chan<chan<command<K, V>>>) {\n     let ctrl = port();\n     send(c, chan(ctrl));\n }"}, {"sha": "b6d76bc9d7cc0097bdba037a50a792769c121c7f", "filename": "src/test/run-pass/type-param-constraints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n-fn p_foo<pin T>(pinned: T) { }\n-fn s_foo<T>(shared: T) { }\n-fn u_foo<uniq T>(unique: T) { }\n+fn p_foo<T>(pinned: T) { }\n+fn s_foo<copy T>(shared: T) { }\n+fn u_foo<send T>(unique: T) { }\n \n resource r(i: int) { }\n "}, {"sha": "a4c80b575499cc0757259ee49d3819de6b3ce354", "filename": "src/test/run-pass/unchecked-predicates.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -5,24 +5,24 @@ import std::list::*;\n \n // Can't easily be written as a \"pure fn\" because there's\n // no syntax for specifying that f is pure.\n-fn pure_foldl<T, U>(ls: list<T>, u: U, f: block(T, U) -> U) -> U {\n+fn pure_foldl<copy T, copy U>(ls: list<T>, u: U, f: block(T, U) -> U) -> U {\n     alt ls { nil. { u } cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) } }\n }\n \n // Shows how to use an \"unchecked\" block to call a general\n // fn from a pure fn\n-pure fn pure_length<T>(ls: list<T>) -> uint {\n+pure fn pure_length<copy T>(ls: list<T>) -> uint {\n     fn count<T>(_t: T, &&u: uint) -> uint { u + 1u }\n     unchecked{ pure_foldl(ls, 0u, bind count(_, _)) }\n }\n \n-pure fn nonempty_list<T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<copy T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n \n // Of course, the compiler can't take advantage of the\n // knowledge that ls is a cons node. Future work.\n // Also, this is pretty contrived since nonempty_list\n // could be a \"tag refinement\", if we implement those.\n-fn safe_head<T>(ls: list<T>) : nonempty_list(ls) -> T { head(ls) }\n+fn safe_head<copy T>(ls: list<T>) : nonempty_list(ls) -> T { head(ls) }\n \n fn main() {\n     let mylist = cons(@1u, @nil);"}, {"sha": "372cca1c667c0d56f3b7c013ebaffdc434b1ca45", "filename": "src/test/run-pass/unique-assign-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,4 +1,4 @@\n-fn f<T>(t: T) -> T {\n+fn f<copy T>(t: T) -> T {\n     let t1 = t;\n     t1\n }"}, {"sha": "4370bb4a791ddbcb7ee08670810d1da65af384f3", "filename": "src/test/run-pass/unique-generic-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,6 +1,6 @@\n // Issue #976\n \n-fn f<T>(x: ~T) {\n+fn f<copy T>(x: ~T) {\n     let _x2 = x;\n }\n fn main() { }"}, {"sha": "ab88437331cbdefb4a8869d99881251236039e53", "filename": "src/test/run-pass/unique-kinds.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-kinds.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,10 +1,10 @@\n-fn unique() {\n+fn sendable() {\n \n-    fn f<uniq T>(i: T, j: T) {\n+    fn f<send T>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<uniq T>(i: T, j: T) {\n+    fn g<send T>(i: T, j: T) {\n         assert i != j;\n     }\n \n@@ -16,13 +16,13 @@ fn unique() {\n     g(i, j);\n }\n \n-fn shared() {\n+fn copyable() {\n \n-    fn f<T>(i: T, j: T) {\n+    fn f<copy T>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<T>(i: T, j: T) {\n+    fn g<copy T>(i: T, j: T) {\n         assert i != j;\n     }\n \n@@ -34,13 +34,13 @@ fn shared() {\n     g(i, j);\n }\n \n-fn pinned() {\n+fn noncopyable() {\n \n-    fn f<pin T>(i: T, j: T) {\n+    fn f<T>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<pin T>(i: T, j: T) {\n+    fn g<T>(i: T, j: T) {\n         assert i != j;\n     }\n \n@@ -53,7 +53,7 @@ fn pinned() {\n }\n \n fn main() {\n-    unique();\n-    shared();\n-    pinned();\n-}\n\\ No newline at end of file\n+    sendable();\n+    copyable();\n+    noncopyable();\n+}"}, {"sha": "92da692e482d4dd2f323ff2ea95ec2da42907316", "filename": "src/test/run-pass/vec-push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fvec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Frun-pass%2Fvec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-push.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -1,5 +1,5 @@\n \n \n-fn push<T>(&v: [const T], t: T) { v += [t]; }\n+fn push<copy T>(&v: [const T], t: T) { v += [t]; }\n \n fn main() { let v = [1, 2, 3]; push(v, 1); }"}, {"sha": "7a488475b9d840aa60db805c914877eb2e155270", "filename": "src/test/stdtest/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fstdtest%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fstdtest%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fdeque.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -81,7 +81,7 @@ fn test_boxes(a: @int, b: @int, c: @int, d: @int) {\n \n type eqfn<T> = fn@(T, T) -> bool;\n \n-fn test_parameterized<T>(e: eqfn<T>, a: T, b: T, c: T, d: T) {\n+fn test_parameterized<copy T>(e: eqfn<T>, a: T, b: T, c: T, d: T) {\n     let deq: deque::t<T> = deque::create::<T>();\n     assert (deq.size() == 0u);\n     deq.add_front(a);"}, {"sha": "a444fbbcc0889a54d56696e6b2d6d7ce570a6373", "filename": "src/test/stdtest/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fstdtest%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d/src%2Ftest%2Fstdtest%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftask.rs?ref=f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "patch": "@@ -68,7 +68,7 @@ fn test_join_convenient() {\n #[ignore]\n fn spawn_polymorphic() {\n     // FIXME #1038: Can't spawn palymorphic functions\n-    /*fn foo<uniq T>(x: T) { log_err x; }\n+    /*fn foo<send T>(x: T) { log_err x; }\n \n     task::spawn(true, foo);\n     task::spawn(42, foo);*/"}]}