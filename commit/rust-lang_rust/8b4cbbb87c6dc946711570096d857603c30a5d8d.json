{"sha": "8b4cbbb87c6dc946711570096d857603c30a5d8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNGNiYmI4N2M2ZGM5NDY3MTE1NzAwOTZkODU3NjAzYzMwYTVkOGQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-03-15T00:39:23Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-03-15T00:39:41Z"}, "message": "Redo it properly and add a quickfix", "tree": {"sha": "90f05142189ae325232cf28d7ee05509fda0266f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90f05142189ae325232cf28d7ee05509fda0266f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b4cbbb87c6dc946711570096d857603c30a5d8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b4cbbb87c6dc946711570096d857603c30a5d8d", "html_url": "https://github.com/rust-lang/rust/commit/8b4cbbb87c6dc946711570096d857603c30a5d8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b4cbbb87c6dc946711570096d857603c30a5d8d/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b1a0d5fb724d3f802fe23f9b4455ffd6d7e114f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b1a0d5fb724d3f802fe23f9b4455ffd6d7e114f", "html_url": "https://github.com/rust-lang/rust/commit/7b1a0d5fb724d3f802fe23f9b4455ffd6d7e114f"}], "stats": {"total": 316, "additions": 309, "deletions": 7}, "files": [{"sha": "6ae7c9e6cc4edf531ab3f9c8a3cc21867c783c9d", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b4cbbb87c6dc946711570096d857603c30a5d8d/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8b4cbbb87c6dc946711570096d857603c30a5d8d/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=8b4cbbb87c6dc946711570096d857603c30a5d8d", "patch": "@@ -38,3 +38,4 @@ hir = { path = \"../hir\", version = \"0.0.0\" }\n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }\n expect-test = \"1.1\"\n+cov-mark = \"1.1.0\""}, {"sha": "22697a5374a317a98a00bb015e52293eb0c62b2a", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 154, "deletions": 7, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8b4cbbb87c6dc946711570096d857603c30a5d8d/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b4cbbb87c6dc946711570096d857603c30a5d8d/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=8b4cbbb87c6dc946711570096d857603c30a5d8d", "patch": "@@ -6,6 +6,7 @@\n \n mod fixes;\n mod field_shorthand;\n+mod unlinked_file;\n \n use std::cell::RefCell;\n \n@@ -22,6 +23,7 @@ use syntax::{\n     SyntaxNode, SyntaxNodePtr, TextRange,\n };\n use text_edit::TextEdit;\n+use unlinked_file::UnlinkedFile;\n \n use crate::{FileId, Label, SourceChange};\n \n@@ -156,6 +158,18 @@ pub(crate) fn diagnostics(\n                 .with_code(Some(d.code())),\n             );\n         })\n+        .on::<UnlinkedFile, _>(|d| {\n+            // Override severity and mark as unused.\n+            res.borrow_mut().push(\n+                Diagnostic::hint(\n+                    sema.diagnostics_display_range(d.display_source()).range,\n+                    d.message(),\n+                )\n+                .with_unused(true)\n+                .with_fix(d.fix(&sema))\n+                .with_code(Some(d.code())),\n+            );\n+        })\n         .on::<hir::diagnostics::UnresolvedProcMacro, _>(|d| {\n             // Use more accurate position if available.\n             let display_range = d\n@@ -200,13 +214,7 @@ pub(crate) fn diagnostics(\n     match sema.to_module_def(file_id) {\n         Some(m) => m.diagnostics(db, &mut sink),\n         None => {\n-            res.borrow_mut().push(\n-                Diagnostic::hint(\n-                    parse.tree().syntax().text_range(),\n-                    \"file not included in module tree\".to_string(),\n-                )\n-                .with_unused(true),\n-            );\n+            sink.push(UnlinkedFile { file_id, node: SyntaxNodePtr::new(&parse.tree().syntax()) });\n         }\n     }\n \n@@ -317,6 +325,17 @@ mod tests {\n         );\n     }\n \n+    /// Checks that there's a diagnostic *without* fix at `$0`.\n+    fn check_no_fix(ra_fixture: &str) {\n+        let (analysis, file_position) = fixture::position(ra_fixture);\n+        let diagnostic = analysis\n+            .diagnostics(&DiagnosticsConfig::default(), file_position.file_id)\n+            .unwrap()\n+            .pop()\n+            .unwrap();\n+        assert!(diagnostic.fix.is_none(), \"got a fix when none was expected: {:?}\", diagnostic);\n+    }\n+\n     /// Takes a multi-file input fixture with annotated cursor position and checks that no diagnostics\n     /// apply to the file containing the cursor.\n     pub(crate) fn check_no_diagnostics(ra_fixture: &str) {\n@@ -985,4 +1004,132 @@ impl TestStruct {\n \n         check_fix(input, expected);\n     }\n+\n+    #[test]\n+    fn unlinked_file_prepend_first_item() {\n+        cov_mark::check!(unlinked_file_prepend_before_first_item);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+fn f() {}\n+//- /foo.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo;\n+\n+fn f() {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_append_mod() {\n+        cov_mark::check!(unlinked_file_append_to_existing_mods);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+//! Comment on top\n+\n+mod preexisting;\n+\n+mod preexisting2;\n+\n+struct S;\n+\n+mod preexisting_bottom;)\n+//- /foo.rs\n+$0\n+\"#,\n+            r#\"\n+//! Comment on top\n+\n+mod preexisting;\n+\n+mod preexisting2;\n+mod foo;\n+\n+struct S;\n+\n+mod preexisting_bottom;)\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_in_empty_file() {\n+        cov_mark::check!(unlinked_file_empty_file);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+//- /foo.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_old_style_modrs() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod submod;\n+//- /submod/mod.rs\n+// in mod.rs\n+//- /submod/foo.rs\n+$0\n+\"#,\n+            r#\"\n+// in mod.rs\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_new_style_mod() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod submod;\n+//- /submod.rs\n+//- /submod/foo.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_with_cfg_off() {\n+        cov_mark::check!(unlinked_file_skip_fix_when_mod_already_exists);\n+        check_no_fix(\n+            r#\"\n+//- /main.rs\n+#[cfg(never)]\n+mod foo;\n+\n+//- /foo.rs\n+$0\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_with_cfg_on() {\n+        check_no_diagnostics(\n+            r#\"\n+//- /main.rs\n+#[cfg(not(never))]\n+mod foo;\n+\n+//- /foo.rs\n+\"#,\n+        );\n+    }\n }"}, {"sha": "f6dc671b9d072d9cf57bac823403e3a650b2140c", "filename": "crates/ide/src/diagnostics/unlinked_file.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/8b4cbbb87c6dc946711570096d857603c30a5d8d/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b4cbbb87c6dc946711570096d857603c30a5d8d/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs?ref=8b4cbbb87c6dc946711570096d857603c30a5d8d", "patch": "@@ -0,0 +1,154 @@\n+use hir::{\n+    db::DefDatabase,\n+    diagnostics::{Diagnostic, DiagnosticCode},\n+    InFile,\n+};\n+use ide_db::{\n+    base_db::{FileId, FileLoader, SourceDatabase, SourceDatabaseExt},\n+    source_change::SourceChange,\n+    RootDatabase,\n+};\n+use syntax::{\n+    ast::{self, ModuleItemOwner, NameOwner},\n+    AstNode, SyntaxNodePtr,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::Fix;\n+\n+use super::fixes::DiagnosticWithFix;\n+\n+#[derive(Debug)]\n+pub struct UnlinkedFile {\n+    pub file_id: FileId,\n+    pub node: SyntaxNodePtr,\n+}\n+\n+impl Diagnostic for UnlinkedFile {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unlinked-file\")\n+    }\n+\n+    fn message(&self) -> String {\n+        \"file not included in module tree\".to_string()\n+    }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file_id.into(), self.node.clone())\n+    }\n+\n+    fn as_any(&self) -> &(dyn std::any::Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl DiagnosticWithFix for UnlinkedFile {\n+    fn fix(&self, sema: &hir::Semantics<RootDatabase>) -> Option<Fix> {\n+        // If there's an existing module that could add a `mod` item to include the unlinked file,\n+        // suggest that as a fix.\n+\n+        let source_root = sema.db.source_root(sema.db.file_source_root(self.file_id));\n+        let our_path = source_root.path_for_file(&self.file_id)?;\n+        let module_name = our_path.name_and_extension()?.0;\n+\n+        // Candidates to look for:\n+        // - `mod.rs` in the same folder\n+        //   - we also check `main.rs` and `lib.rs`\n+        // - `$dir.rs` in the parent folder, where `$dir` is the directory containing `self.file_id`\n+        let parent = our_path.parent()?;\n+        let mut paths =\n+            vec![parent.join(\"mod.rs\")?, parent.join(\"main.rs\")?, parent.join(\"lib.rs\")?];\n+\n+        // `submod/bla.rs` -> `submod.rs`\n+        if let Some(newmod) = (|| {\n+            let name = parent.name_and_extension()?.0;\n+            parent.parent()?.join(&format!(\"{}.rs\", name))\n+        })() {\n+            paths.push(newmod);\n+        }\n+\n+        for path in &paths {\n+            if let Some(parent_id) = source_root.file_for_path(path) {\n+                for krate in sema.db.relevant_crates(*parent_id).iter() {\n+                    let crate_def_map = sema.db.crate_def_map(*krate);\n+                    for (_, module) in crate_def_map.modules() {\n+                        if module.origin.is_inline() {\n+                            // We don't handle inline `mod parent {}`s, they use different paths.\n+                            continue;\n+                        }\n+\n+                        if module.origin.file_id() == Some(*parent_id) {\n+                            return make_fix(sema.db, *parent_id, module_name, self.file_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+fn make_fix(\n+    db: &RootDatabase,\n+    parent_file_id: FileId,\n+    new_mod_name: &str,\n+    added_file_id: FileId,\n+) -> Option<Fix> {\n+    fn is_outline_mod(item: &ast::Item) -> bool {\n+        matches!(item, ast::Item::Module(m) if m.item_list().is_none())\n+    }\n+\n+    let mod_decl = format!(\"mod {};\", new_mod_name);\n+    let ast: ast::SourceFile = db.parse(parent_file_id).tree();\n+\n+    let mut builder = TextEdit::builder();\n+\n+    // If there's an existing `mod m;` statement matching the new one, don't emit a fix (it's\n+    // probably `#[cfg]`d out).\n+    for item in ast.items() {\n+        if let ast::Item::Module(m) = item {\n+            if let Some(name) = m.name() {\n+                if m.item_list().is_none() && name.to_string() == new_mod_name {\n+                    cov_mark::hit!(unlinked_file_skip_fix_when_mod_already_exists);\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+\n+    // If there are existing `mod m;` items, append after them (after the first group of them, rather).\n+    match ast\n+        .items()\n+        .skip_while(|item| !is_outline_mod(item))\n+        .take_while(|item| is_outline_mod(item))\n+        .last()\n+    {\n+        Some(last) => {\n+            cov_mark::hit!(unlinked_file_append_to_existing_mods);\n+            builder.insert(last.syntax().text_range().end(), format!(\"\\n{}\", mod_decl));\n+        }\n+        None => {\n+            // Prepend before the first item in the file.\n+            match ast.items().next() {\n+                Some(item) => {\n+                    cov_mark::hit!(unlinked_file_prepend_before_first_item);\n+                    builder.insert(item.syntax().text_range().start(), format!(\"{}\\n\\n\", mod_decl));\n+                }\n+                None => {\n+                    // No items in the file, so just append at the end.\n+                    cov_mark::hit!(unlinked_file_empty_file);\n+                    builder.insert(ast.syntax().text_range().end(), format!(\"{}\\n\", mod_decl));\n+                }\n+            }\n+        }\n+    }\n+\n+    let edit = builder.finish();\n+    let trigger_range = db.parse(added_file_id).tree().syntax().text_range();\n+    Some(Fix::new(\n+        &format!(\"Insert `{}`\", mod_decl),\n+        SourceChange::from_text_edit(parent_file_id, edit),\n+        trigger_range,\n+    ))\n+}"}]}