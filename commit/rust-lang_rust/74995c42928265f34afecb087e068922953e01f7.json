{"sha": "74995c42928265f34afecb087e068922953e01f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0OTk1YzQyOTI4MjY1ZjM0YWZlY2IwODdlMDY4OTIyOTUzZTAxZjc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-17T09:29:49Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-18T17:33:55Z"}, "message": "reduce number of allocation lookups during copy", "tree": {"sha": "bad1b1ac9cd851e2b42c43ca7e36db4cf19c4ee3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bad1b1ac9cd851e2b42c43ca7e36db4cf19c4ee3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74995c42928265f34afecb087e068922953e01f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74995c42928265f34afecb087e068922953e01f7", "html_url": "https://github.com/rust-lang/rust/commit/74995c42928265f34afecb087e068922953e01f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74995c42928265f34afecb087e068922953e01f7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46c228639533712826fcd58efbd136054e771d8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/46c228639533712826fcd58efbd136054e771d8d", "html_url": "https://github.com/rust-lang/rust/commit/46c228639533712826fcd58efbd136054e771d8d"}], "stats": {"total": 12, "additions": 6, "deletions": 6}, "files": [{"sha": "d82837abfd2724b6e8448d3b5e360ec6fa33cbf5", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74995c42928265f34afecb087e068922953e01f7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74995c42928265f34afecb087e068922953e01f7/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=74995c42928265f34afecb087e068922953e01f7", "patch": "@@ -934,6 +934,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(a) => a,\n             None => return Ok(&[]), // zero-sized access\n         };\n+        // Side-step AllocRef and directly access the underlying bytes more efficiently.\n+        // (We are staying inside the bounds here so all is good.)\n         Ok(alloc_ref\n             .alloc\n             .get_bytes(&alloc_ref.tcx, alloc_ref.range)\n@@ -1006,7 +1008,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let src = self.check_ptr_access(src, size, src_align)?;\n         let dest = self.check_ptr_access(dest, size * num_copies, dest_align)?; // `Size` multiplication\n \n-        // FIXME: avoid looking up allocations more often than necessary.\n+        // FIXME: we look up both allocations twice here, once ebfore for the `check_ptr_access`\n+        // and once below to get the underlying `&[mut] Allocation`.\n \n         // Source alloc preparations and access hooks.\n         let src = match src {\n@@ -1033,6 +1036,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             dest.offset,\n             num_copies,\n         );\n+        // Prepare a copy of the initialization mask.\n+        let compressed = src_alloc.compress_uninit_range(src, size);\n         // This checks relocation edges on the src.\n         let src_bytes = src_alloc\n             .get_bytes_with_uninit_and_ptr(&tcx, alloc_range(src.offset, size))\n@@ -1046,17 +1051,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             .get_bytes_mut_ptr(&tcx, alloc_range(dest.offset, size * num_copies))\n             .as_mut_ptr();\n \n-        // Prepare a copy of the initialization mask.\n-        let compressed = self.get_raw(src.alloc_id)?.compress_uninit_range(src, size);\n-\n         if compressed.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range\n             // is marked as uninitialized but we otherwise omit changing the byte representation which may\n             // be arbitrary for uninitialized bytes.\n             // This also avoids writing to the target bytes so that the backing allocation is never\n             // touched if the bytes stay uninitialized for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n-            let dest_alloc = self.get_raw_mut(dest.alloc_id)?.0;\n             dest_alloc.mark_init(alloc_range(dest.offset, size * num_copies), false); // `Size` multiplication\n             dest_alloc.mark_relocation_range(relocations);\n             return Ok(());\n@@ -1096,7 +1097,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n         }\n \n-        let dest_alloc = self.get_raw_mut(dest.alloc_id)?.0;\n         // now fill in all the \"init\" data\n         dest_alloc.mark_compressed_init_range(&compressed, dest, size, num_copies);\n         // copy the relocations to the destination"}]}