{"sha": "c2ce2741a773b94d3a8f7293cb598322bc61f89d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyY2UyNzQxYTc3M2I5NGQzYThmNzI5M2NiNTk4MzIyYmM2MWY4OWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-31T21:02:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-31T22:07:09Z"}, "message": "allow mutable vectors and so forth to be used as immutable slices", "tree": {"sha": "8736739f4af685ecab254939ea9e288dbaff82df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8736739f4af685ecab254939ea9e288dbaff82df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2ce2741a773b94d3a8f7293cb598322bc61f89d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ce2741a773b94d3a8f7293cb598322bc61f89d", "html_url": "https://github.com/rust-lang/rust/commit/c2ce2741a773b94d3a8f7293cb598322bc61f89d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2ce2741a773b94d3a8f7293cb598322bc61f89d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0470abe1d290ef28fa72693b70f955328656e471", "url": "https://api.github.com/repos/rust-lang/rust/commits/0470abe1d290ef28fa72693b70f955328656e471", "html_url": "https://github.com/rust-lang/rust/commit/0470abe1d290ef28fa72693b70f955328656e471"}], "stats": {"total": 179, "additions": 121, "deletions": 58}, "files": [{"sha": "2fd59cb2166255dc335a54e0eba0a9de97bd2b62", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=c2ce2741a773b94d3a8f7293cb598322bc61f89d", "patch": "@@ -562,6 +562,17 @@ impl of tr for method_origin {\n     }\n }\n \n+// ______________________________________________________________________\n+// Encoding and decoding of borrow\n+\n+impl helper for ebml::ebml_deserializer {\n+    fn read_borrow(xcx: extended_decode_ctxt) -> ty::borrow {\n+        let borrow = ty::deserialize_borrow(self);\n+        {scope_id: xcx.tr_id(borrow.scope_id),\n+         mutbl: borrow.mutbl}\n+    }\n+}\n+\n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n@@ -866,10 +877,12 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    option::iter(tcx.borrowings.find(id)) {|s|\n+    option::iter(tcx.borrowings.find(id)) {|borrow|\n         ebml_w.tag(c::tag_table_borrowings) {||\n             ebml_w.id(id);\n-            ebml_w.wr_tagged_i64(c::tag_table_val as uint, s as i64);\n+            ebml_w.tag(c::tag_table_val) {||\n+                ty::serialize_borrow(ebml_w, borrow)\n+            }\n         }\n     }\n }\n@@ -979,8 +992,8 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 dcx.maps.vtable_map.insert(id,\n                                            val_dsr.read_vtable_res(xcx));\n             } else if tag == (c::tag_table_borrowings as uint) {\n-                let scope_id = ebml::doc_as_i64(val_doc) as int;\n-                dcx.tcx.borrowings.insert(id, scope_id);\n+                let borrow = val_dsr.read_borrow(xcx);\n+                dcx.tcx.borrowings.insert(id, borrow);\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n                     #fmt[\"unknown tag found in side tables: %x\", tag]);"}, {"sha": "bc7cd7a55c3f06b979de23c3ef83b46f1ffacb50", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=c2ce2741a773b94d3a8f7293cb598322bc61f89d", "patch": "@@ -190,10 +190,10 @@ fn req_loans_in_expr(ex: @ast::expr,\n     let tcx = bccx.tcx;\n \n     // If this expression is borrowed, have to ensure it remains valid:\n-    for tcx.borrowings.find(ex.id).each { |scope_id|\n+    for tcx.borrowings.find(ex.id).each { |borrow|\n         let cmt = self.bccx.cat_borrow_of_expr(ex);\n-        let scope_r = ty::re_scope(scope_id);\n-        self.guarantee_valid(cmt, m_const, scope_r);\n+        let scope_r = ty::re_scope(borrow.scope_id);\n+        self.guarantee_valid(cmt, borrow.mutbl, scope_r);\n     }\n \n     // Special checks for various kinds of expressions:"}, {"sha": "04ea9fe01bb6807c9c3356bab6f366c322ea122c", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=c2ce2741a773b94d3a8f7293cb598322bc61f89d", "patch": "@@ -158,6 +158,7 @@ export mach_sty;\n export ty_sort_str;\n export normalize_ty;\n export to_str;\n+export borrow, serialize_borrow, deserialize_borrow;\n \n // Data types\n \n@@ -204,6 +205,12 @@ enum ast_ty_to_ty_cache_entry {\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n }\n \n+#[auto_serialize]\n+type borrow = {\n+    scope_id: ast::node_id,\n+    mutbl: ast::mutability\n+};\n+\n type ctxt =\n     @{diag: syntax::diagnostic::span_handler,\n       interner: hashmap<intern_key, t_box>,\n@@ -239,7 +246,7 @@ type ctxt =\n       ty_param_bounds: hashmap<ast::node_id, param_bounds>,\n       inferred_modes: hashmap<ast::node_id, ast::mode>,\n       // maps the id of borrowed expr to scope of borrowed ptr\n-      borrowings: hashmap<ast::node_id, ast::node_id>,\n+      borrowings: hashmap<ast::node_id, borrow>,\n       normalized_cache: hashmap<t, t>};\n \n enum tbox_flag {"}, {"sha": "38466400e57b6d2179bbc9ffc8bb48d63b87466a", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=c2ce2741a773b94d3a8f7293cb598322bc61f89d", "patch": "@@ -157,6 +157,7 @@ import check::regionmanip::{replace_bound_regions_in_fn_ty};\n import driver::session::session;\n import util::common::{indent, indenter};\n import ast::{unsafe_fn, impure_fn, pure_fn, crust_fn};\n+import ast::{m_const, m_imm, m_mutbl};\n \n export infer_ctxt;\n export new_infer_ctxt;\n@@ -961,24 +962,27 @@ impl methods for resolve_state {\n // we just fall back to requiring that a <: b.\n //\n // Assuming we have a bound from both sides, we will then examine\n-// these bounds and see if they have the form (@MT_a, &rb.MT_b)\n-// (resp. ~MT_a).  If they do not, we fall back to subtyping.\n+// these bounds and see if they have the form (@M_a T_a, &rb.M_b T_b)\n+// (resp. ~M_a T_a, [M_a T_a], etc).  If they do not, we fall back to\n+// subtyping.\n //\n // If they *do*, then we know that the two types could never be\n-// subtypes of one another.  We will then construct a type @MT_b and\n-// ensure that type a is a subtype of that.  This allows for the\n+// subtypes of one another.  We will then construct a type @const T_b\n+// and ensure that type a is a subtype of that.  This allows for the\n // possibility of assigning from a type like (say) @[mut T1] to a type\n-// &[const T2] where T1 <: T2.  Basically we would require that @[mut\n-// T1] <: @[const T2].  Next we require that the region for the\n-// enclosing scope be a superregion of the region r.  These two checks\n-// together guarantee that the type A would be a subtype of the type B\n-// if the @ were converted to a region r.\n+// &[T2] where T1 <: T2.  This might seem surprising, since the `@`\n+// points at mutable memory but the `&` points at immutable memory.\n+// This would in fact be unsound, except for the borrowck, which comes\n+// later and guarantees that such mutability conversions are safe.\n+// See borrowck for more details.  Next we require that the region for\n+// the enclosing scope be a superregion of the region r.\n //\n-// You might wonder why we don't just make the type &e.MT_a where e is\n-// the enclosing region and check that &e.MT_a <: B.  The reason is\n-// that the type @MT_a is (generally) just a *lower-bound*, so this\n-// would be imposing @MT_a also as the upper-bound on type A.  But\n-// this upper-bound might be stricter than what is truly needed.\n+// You might wonder why we don't make the type &e.const T_a where e is\n+// the enclosing region and check that &e.const T_a <: B.  The reason\n+// is that the type of A is (generally) just a *lower-bound*, so this\n+// would be imposing that lower-bound also as the upper-bound on type\n+// A.  But this upper-bound might be stricter than what is truly\n+// needed.\n \n impl assignment for infer_ctxt {\n     fn assign_tys(anmnt: assignment, a: ty::t, b: ty::t) -> ures {\n@@ -1051,35 +1055,39 @@ impl assignment for infer_ctxt {\n           (some(a_bnd), some(b_bnd)) {\n             alt (ty::get(a_bnd).struct, ty::get(b_bnd).struct) {\n               (ty::ty_box(mt_a), ty::ty_rptr(r_b, mt_b)) {\n-                let nr_b = ty::mk_box(self.tcx, mt_b);\n-                self.crosspollinate(anmnt, a, nr_b, r_b)\n+                let nr_b = ty::mk_box(self.tcx, {ty: mt_b.ty,\n+                                                 mutbl: m_const});\n+                self.crosspollinate(anmnt, a, nr_b, mt_b.mutbl, r_b)\n               }\n               (ty::ty_uniq(mt_a), ty::ty_rptr(r_b, mt_b)) {\n-                let nr_b = ty::mk_uniq(self.tcx, mt_b);\n-                self.crosspollinate(anmnt, a, nr_b, r_b)\n+                let nr_b = ty::mk_uniq(self.tcx, {ty: mt_b.ty,\n+                                                  mutbl: m_const});\n+                self.crosspollinate(anmnt, a, nr_b, mt_b.mutbl, r_b)\n               }\n               (ty::ty_estr(vs_a),\n                ty::ty_estr(ty::vstore_slice(r_b)))\n               if is_borrowable(vs_a) {\n                 let nr_b = ty::mk_estr(self.tcx, vs_a);\n-                self.crosspollinate(anmnt, a, nr_b, r_b)\n+                self.crosspollinate(anmnt, a, nr_b, m_imm, r_b)\n               }\n               (ty::ty_str,\n                ty::ty_estr(ty::vstore_slice(r_b))) {\n                 let nr_b = ty::mk_str(self.tcx);\n-                self.crosspollinate(anmnt, a, nr_b, r_b)\n+                self.crosspollinate(anmnt, a, nr_b, m_imm, r_b)\n               }\n \n               (ty::ty_evec(mt_a, vs_a),\n                ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n               if is_borrowable(vs_a) {\n-                let nr_b = ty::mk_evec(self.tcx, mt_b, vs_a);\n-                self.crosspollinate(anmnt, a, nr_b, r_b)\n+                let nr_b = ty::mk_evec(self.tcx, {ty: mt_b.ty,\n+                                                  mutbl: m_const}, vs_a);\n+                self.crosspollinate(anmnt, a, nr_b, mt_b.mutbl, r_b)\n               }\n               (ty::ty_vec(mt_a),\n                ty::ty_evec(mt_b, ty::vstore_slice(r_b))) {\n-                let nr_b = ty::mk_vec(self.tcx, mt_b);\n-                self.crosspollinate(anmnt, a, nr_b, r_b)\n+                let nr_b = ty::mk_vec(self.tcx, {ty: mt_b.ty,\n+                                                 mutbl: m_const});\n+                self.crosspollinate(anmnt, a, nr_b, mt_b.mutbl, r_b)\n               }\n               _ {\n                 self.sub_tys(a, b)\n@@ -1093,9 +1101,10 @@ impl assignment for infer_ctxt {\n     }\n \n     fn crosspollinate(anmnt: assignment,\n-                     a: ty::t,\n-                     nr_b: ty::t,\n-                     r_b: ty::region) -> ures {\n+                      a: ty::t,\n+                      nr_b: ty::t,\n+                      m: ast::mutability,\n+                      r_b: ty::region) -> ures {\n \n         #debug[\"crosspollinate(anmnt=%?, a=%s, nr_b=%s, r_b=%s)\",\n                anmnt, a.to_str(self), nr_b.to_str(self),\n@@ -1109,8 +1118,9 @@ impl assignment for infer_ctxt {\n                     // if successful, add an entry indicating that\n                     // borrowing occurred\n                     #debug[\"borrowing expression #%?\", anmnt];\n-                    self.tcx.borrowings.insert(anmnt.expr_id,\n-                                               anmnt.borrow_scope);\n+                    let borrow = {scope_id: anmnt.borrow_scope,\n+                                  mutbl: m};\n+                    self.tcx.borrowings.insert(anmnt.expr_id, borrow);\n                     uok()\n                 }\n             }\n@@ -1561,17 +1571,17 @@ impl of combine for sub {\n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         #debug(\"mts(%s <: %s)\", a.to_str(*self), b.to_str(*self));\n \n-        if a.mutbl != b.mutbl && b.mutbl != ast::m_const {\n+        if a.mutbl != b.mutbl && b.mutbl != m_const {\n             ret err(ty::terr_mutability);\n         }\n \n         alt b.mutbl {\n-          ast::m_mutbl {\n+          m_mutbl {\n             // If supertype is mut, subtype must match exactly\n             // (i.e., invariant if mut):\n             self.infcx().eq_tys(a.ty, b.ty).then {|| ok(a) }\n           }\n-          ast::m_imm | ast::m_const {\n+          m_imm | m_const {\n             // Otherwise we can be covariant:\n             self.tys(a.ty, b.ty).chain {|_t| ok(a) }\n           }\n@@ -1710,24 +1720,24 @@ impl of combine for lub {\n         let m = if a.mutbl == b.mutbl {\n             a.mutbl\n         } else {\n-            ast::m_const\n+            m_const\n         };\n \n         alt m {\n-          ast::m_imm | ast::m_const {\n+          m_imm | m_const {\n             self.tys(a.ty, b.ty).chain {|t|\n                 ok({ty: t, mutbl: m})\n             }\n           }\n \n-          ast::m_mutbl {\n+          m_mutbl {\n             self.infcx().try {||\n                 self.infcx().eq_tys(a.ty, b.ty).then {||\n                     ok({ty: a.ty, mutbl: m})\n                 }\n             }.chain_err {|_e|\n                 self.tys(a.ty, b.ty).chain {|t|\n-                    ok({ty: t, mutbl: ast::m_const})\n+                    ok({ty: t, mutbl: m_const})\n                 }\n             }\n           }\n@@ -1893,43 +1903,43 @@ impl of combine for glb {\n         alt (a.mutbl, b.mutbl) {\n           // If one side or both is mut, then the GLB must use\n           // the precise type from the mut side.\n-          (ast::m_mutbl, ast::m_const) {\n+          (m_mutbl, m_const) {\n             sub(*self).tys(a.ty, b.ty).chain {|_t|\n-                ok({ty: a.ty, mutbl: ast::m_mutbl})\n+                ok({ty: a.ty, mutbl: m_mutbl})\n             }\n           }\n-          (ast::m_const, ast::m_mutbl) {\n+          (m_const, m_mutbl) {\n             sub(*self).tys(b.ty, a.ty).chain {|_t|\n-                ok({ty: b.ty, mutbl: ast::m_mutbl})\n+                ok({ty: b.ty, mutbl: m_mutbl})\n             }\n           }\n-          (ast::m_mutbl, ast::m_mutbl) {\n+          (m_mutbl, m_mutbl) {\n             self.infcx().eq_tys(a.ty, b.ty).then {||\n-                ok({ty: a.ty, mutbl: ast::m_mutbl})\n+                ok({ty: a.ty, mutbl: m_mutbl})\n             }\n           }\n \n           // If one side or both is immutable, we can use the GLB of\n           // both sides but mutbl must be `m_imm`.\n-          (ast::m_imm, ast::m_const) |\n-          (ast::m_const, ast::m_imm) |\n-          (ast::m_imm, ast::m_imm) {\n+          (m_imm, m_const) |\n+          (m_const, m_imm) |\n+          (m_imm, m_imm) {\n             self.tys(a.ty, b.ty).chain {|t|\n-                ok({ty: t, mutbl: ast::m_imm})\n+                ok({ty: t, mutbl: m_imm})\n             }\n           }\n \n           // If both sides are const, then we can use GLB of both\n           // sides and mutbl of only `m_const`.\n-          (ast::m_const, ast::m_const) {\n+          (m_const, m_const) {\n             self.tys(a.ty, b.ty).chain {|t|\n-                ok({ty: t, mutbl: ast::m_const})\n+                ok({ty: t, mutbl: m_const})\n             }\n           }\n \n           // There is no mutual subtype of these combinations.\n-          (ast::m_mutbl, ast::m_imm) |\n-          (ast::m_imm, ast::m_mutbl) {\n+          (m_mutbl, m_imm) |\n+          (m_imm, m_mutbl) {\n               err(ty::terr_mutability)\n           }\n         }"}, {"sha": "803f30f8e33a7e4cd48d59a5dfbeb1c4e99ce125", "filename": "src/test/compile-fail/borrowck-mut-vec-as-imm-slice-bad.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs?ref=c2ce2741a773b94d3a8f7293cb598322bc61f89d", "patch": "@@ -0,0 +1,17 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n+fn want_slice(v: [int]/&) -> int {\n+    let mut sum = 0;\n+    for vec::each(v) { |i| sum += i; }\n+    ret sum;\n+}\n+\n+fn has_mut_vec(+v: @[mut int]) -> int {\n+    want_slice(*v) //! ERROR illegal borrow unless pure: creating immutable alias to aliasable, mutable memory\n+        //!^ NOTE impure due to access to impure function\n+}\n+\n+fn main() {\n+    assert has_mut_vec(@[mut 1, 2, 3]) == 6;\n+}\n\\ No newline at end of file"}, {"sha": "e6e4c36db35db07c66b12388e03a33ca99fde53c", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2ce2741a773b94d3a8f7293cb598322bc61f89d/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=c2ce2741a773b94d3a8f7293cb598322bc61f89d", "patch": "@@ -0,0 +1,16 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n+fn want_slice(v: [int]/&) -> int {\n+    let mut sum = 0;\n+    for vec::each(v) { |i| sum += i; }\n+    ret sum;\n+}\n+\n+fn has_mut_vec(+v: [mut int]) -> int {\n+    want_slice(v)\n+}\n+\n+fn main() {\n+    assert has_mut_vec([mut 1, 2, 3]) == 6;\n+}\n\\ No newline at end of file"}]}