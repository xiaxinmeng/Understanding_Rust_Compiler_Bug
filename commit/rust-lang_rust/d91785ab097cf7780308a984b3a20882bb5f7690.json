{"sha": "d91785ab097cf7780308a984b3a20882bb5f7690", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MTc4NWFiMDk3Y2Y3NzgwMzA4YTk4NGIzYTIwODgyYmI1Zjc2OTA=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-10-26T20:34:47Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-10-27T16:00:10Z"}, "message": "Adds tons of documentation for Iterator\n\nThis adds lots of examples, clarifies text, and just generally improves\nthe documentation for Iterator.", "tree": {"sha": "f32e84ef635b42046302293077f75b73f6a739ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f32e84ef635b42046302293077f75b73f6a739ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d91785ab097cf7780308a984b3a20882bb5f7690", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d91785ab097cf7780308a984b3a20882bb5f7690", "html_url": "https://github.com/rust-lang/rust/commit/d91785ab097cf7780308a984b3a20882bb5f7690", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d91785ab097cf7780308a984b3a20882bb5f7690/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0152a93bb41ba360b41dd62451c2472fc5978d0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0152a93bb41ba360b41dd62451c2472fc5978d0c", "html_url": "https://github.com/rust-lang/rust/commit/0152a93bb41ba360b41dd62451c2472fc5978d0c"}], "stats": {"total": 1444, "additions": 1183, "deletions": 261}, "files": [{"sha": "262bfd5de992a89b75be4e3080a8ab992a287240", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1183, "deletions": 261, "changes": 1444, "blob_url": "https://github.com/rust-lang/rust/blob/d91785ab097cf7780308a984b3a20882bb5f7690/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91785ab097cf7780308a984b3a20882bb5f7690/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=d91785ab097cf7780308a984b3a20882bb5f7690", "patch": "@@ -312,46 +312,110 @@ use usize;\n \n fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n \n-/// An interface for dealing with \"external iterators\". These types of iterators\n-/// can be resumed at any time as all state is stored internally as opposed to\n-/// being located on the call stack.\n-///\n-/// The Iterator protocol states that an iterator yields a (potentially-empty,\n-/// potentially-infinite) sequence of values, and returns `None` to signal that\n-/// it's finished. The Iterator protocol does not define behavior after `None`\n-/// is returned. A concrete Iterator implementation may choose to behave however\n-/// it wishes, either by returning `None` infinitely, or by doing something\n-/// else.\n+/// An interface for dealing with iterators.\n+///\n+/// This is the main iterator trait. For more about the concept of iterators\n+/// generally, please see the [module-level documentation]. In particular, you\n+/// may want to know how to [implement `Iterator`][impl].\n+///\n+/// [module-level documentation]: index.html\n+/// [impl]: index.html#implementing-iterator\n #[lang = \"iterator\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling \\\n                             `.iter()` or a similar method\"]\n pub trait Iterator {\n-    /// The type of the elements being iterated\n+    /// The type of the elements being iterated over.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n-    /// Advances the iterator and returns the next value. Returns `None` when the\n-    /// end is reached.\n+    /// Advances the iterator and returns the next value.\n+    ///\n+    /// Returns `None` when iteration is finished. Individual iterator\n+    /// implementations may choose to resume iteration, and so calling `next()`\n+    /// again may or may not eventually start returning `Some(Item)` again at some\n+    /// point.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// // A call to next() returns the next value...\n+    /// assert_eq!(Some(&1), iter.next());\n+    /// assert_eq!(Some(&2), iter.next());\n+    /// assert_eq!(Some(&3), iter.next());\n+    ///\n+    /// // ... and then None once it's over.\n+    /// assert_eq!(None, iter.next());\n+    ///\n+    /// // More calls may or may not return None. Here, they always will.\n+    /// assert_eq!(None, iter.next());\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next(&mut self) -> Option<Self::Item>;\n \n-    /// Returns a lower and upper bound on the remaining length of the iterator.\n+    /// Returns the bounds on the remaining length of the iterator.\n+    ///\n+    /// Specifically, `size_hint()` returns a tuple where the first element\n+    /// is the lower bound, and the second element is the upper bound.\n     ///\n-    /// An upper bound of `None` means either there is no known upper bound, or\n-    /// the upper bound does not fit within a `usize`.\n+    /// The second half of the tuple that is returned is an `Option<usize>`. A\n+    /// `None` here means that either there is no known upper bound, or the\n+    /// upper bound is larger than `usize`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// let iter = a.iter();\n+    ///\n+    /// assert_eq!((3, Some(3)), iter.size_hint());\n     /// ```\n-    /// let it = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n-    /// assert_eq!((5, Some(15)), it.size_hint());\n+    ///\n+    /// A more complex example:\n+    ///\n+    /// ```\n+    /// // The even numbers from zero to ten.\n+    /// let iter = (0..10).filter(|x| x % 2 == 0);\n+    ///\n+    /// // We might iterate from zero to ten times. Knowing that it's five\n+    /// // exactly wouldn't be possible without executing filter().\n+    /// assert_eq!((0, Some(10)), iter.size_hint());\n+    ///\n+    /// // Let's add one five more numbers with chain()\n+    /// let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n+    ///\n+    /// // now both bounds are increased by five\n+    /// assert_eq!((5, Some(15)), iter.size_hint());\n+    /// ```\n+    ///\n+    /// Returning `None` for an upper bound:\n+    ///\n+    /// ```\n+    /// // an infinite iterator has no upper bound\n+    /// let iter = (0..);\n+    ///\n+    /// assert_eq!((0, None), iter.size_hint());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n \n-    /// Counts the number of elements in this iterator.\n+    /// Consumes the iterator, counting the number of iterations and returning it.\n+    ///\n+    /// This method will evaluate the iterator until its [`next()`] returns\n+    /// `None`. Once `None` is encountered, `count()` returns the number of\n+    /// times it called [`next()`].\n+    ///\n+    /// [`next()`]: #method.next\n     ///\n     /// # Overflow Behavior\n     ///\n@@ -362,12 +426,17 @@ pub trait Iterator {\n     ///\n     /// # Panics\n     ///\n-    /// This functions might panic if the iterator has more than `usize::MAX`\n+    /// This function might panic if the iterator has more than `usize::MAX`\n     /// elements.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().count(), 3);\n+    ///\n     /// let a = [1, 2, 3, 4, 5];\n     /// assert_eq!(a.iter().count(), 5);\n     /// ```\n@@ -378,11 +447,20 @@ pub trait Iterator {\n         self.fold(0, |cnt, _| cnt + 1)\n     }\n \n-    /// Loops through the entire iterator, returning the last element.\n+    /// Consumes the iterator, returning the last element.\n+    ///\n+    /// This method will evaluate the iterator until it returns `None`. While\n+    /// doing so, it keeps track of the current element. After `None` is\n+    /// returned, `last()` will then return the last element it saw.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().last(), Some(&3));\n+    ///\n     /// let a = [1, 2, 3, 4, 5];\n     /// assert_eq!(a.iter().last(), Some(&5));\n     /// ```\n@@ -394,15 +472,45 @@ pub trait Iterator {\n         last\n     }\n \n-    /// Skips the `n` first elements of the iterator and returns the next one.\n+    /// Consumes the `n` first elements of the iterator, then returns the\n+    /// `next()` one.\n+    ///\n+    /// This method will evaluate the iterator `n` times, discarding those elements.\n+    /// After it does so, it will call [`next()`] and return its value.\n+    ///\n+    /// [`next()`]: #method.next\n+    ///\n+    /// Like most indexing operations, the count starts from zero, so `nth(0)`\n+    /// returns the first value, `nth(1)` the second, and so on.\n+    ///\n+    /// `nth()` will return `None` if `n` is larger than the length of the\n+    /// iterator.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert_eq!(it.nth(2), Some(&3));\n-    /// assert_eq!(it.nth(2), None);\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth(1), Some(&2));\n+    /// ```\n+    ///\n+    /// Calling `nth()` multiple times doesn't rewind the iterator:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.nth(1), Some(&2));\n+    /// assert_eq!(iter.nth(1), None);\n+    /// ```\n+    ///\n+    /// Returning `None` if there are less than `n` elements:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth(10), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -414,19 +522,54 @@ pub trait Iterator {\n         None\n     }\n \n-    /// Chain this iterator with another, returning a new iterator that will\n-    /// finish iterating over the current iterator, and then iterate\n-    /// over the other specified iterator.\n+    /// Takes two iterators and creates a new iterator over both in sequence.\n+    ///\n+    /// `chain()` will return a new iterator which will first iterate over\n+    /// values from the first iterator and then over values from the second\n+    /// iterator.\n+    ///\n+    /// In other words, it links two iterators together, in a chain. \ud83d\udd17\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [0];\n-    /// let b = [1];\n-    /// let mut it = a.iter().chain(&b);\n-    /// assert_eq!(it.next(), Some(&0));\n-    /// assert_eq!(it.next(), Some(&1));\n-    /// assert!(it.next().is_none());\n+    /// let a1 = [1, 2, 3];\n+    /// let a2 = [4, 5, 6];\n+    ///\n+    /// let mut iter = a1.iter().chain(a2.iter());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), Some(&4));\n+    /// assert_eq!(iter.next(), Some(&5));\n+    /// assert_eq!(iter.next(), Some(&6));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Since the argument to `chain()` uses [`IntoIterator`], we can pass\n+    /// anything that can be converted into an [`Iterator`], not just an\n+    /// [`Iterator`] itself. For example, slices (`&[T]`) implement\n+    /// [`IntoIterator`], and so can be passed to `chain()` directly:\n+    ///\n+    /// [`IntoIterator`]: trait.IntoIterator.html\n+    /// [`Iterator`]: trait.Iterator.html\n+    ///\n+    /// ```\n+    /// let s1 = &[1, 2, 3];\n+    /// let s2 = &[4, 5, 6];\n+    ///\n+    /// let mut iter = s1.iter().chain(s2);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), Some(&4));\n+    /// assert_eq!(iter.next(), Some(&5));\n+    /// assert_eq!(iter.next(), Some(&6));\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -436,34 +579,73 @@ pub trait Iterator {\n         Chain{a: self, b: other.into_iter(), state: ChainState::Both}\n     }\n \n-    /// Creates an iterator that iterates over both this and the specified\n-    /// iterators simultaneously, yielding the two elements as pairs. When\n-    /// either iterator returns `None`, all further invocations of `next()`\n+    /// 'Zips up' two iterators into a single iterator of pairs.\n+    ///\n+    /// `zip()` returns a new iterator that will iterate over two other\n+    /// iterators, returning a tuple where the first element comes from the\n+    /// first iterator, and the second element comes from the second iterator.\n+    ///\n+    /// In other words, it zips two iterators together, into a single one. \ud83e\udd10\n+    ///\n+    /// When either iterator returns `None`, all further calls to `next()`\n     /// will return `None`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [0];\n-    /// let b = [1];\n-    /// let mut it = a.iter().zip(&b);\n-    /// assert_eq!(it.next(), Some((&0, &1)));\n-    /// assert!(it.next().is_none());\n+    /// let a1 = [1, 2, 3];\n+    /// let a2 = [4, 5, 6];\n+    ///\n+    /// let mut iter = a1.iter().zip(a2.iter());\n+    ///\n+    /// assert_eq!(iter.next(), Some((&1, &4)));\n+    /// assert_eq!(iter.next(), Some((&2, &5)));\n+    /// assert_eq!(iter.next(), Some((&3, &6)));\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     ///\n-    /// `zip` can provide similar functionality to `enumerate`:\n+    /// Since the argument to `zip()` uses [`IntoIterator`], we can pass\n+    /// anything that can be converted into an [`Iterator`], not just an\n+    /// [`Iterator`] itself. For example, slices (`&[T]`) implement\n+    /// [`IntoIterator`], and so can be passed to `zip()` directly:\n+    ///\n+    /// [`IntoIterator`]: trait.IntoIterator.html\n+    /// [`Iterator`]: trait.Iterator.html\n     ///\n     /// ```\n-    /// for pair in \"foo\".chars().enumerate() {\n-    ///     println!(\"{:?}\", pair);\n-    /// }\n+    /// let s1 = &[1, 2, 3];\n+    /// let s2 = &[4, 5, 6];\n+    ///\n+    /// let mut iter = s1.iter().zip(s2);\n+    ///\n+    /// assert_eq!(iter.next(), Some((&1, &4)));\n+    /// assert_eq!(iter.next(), Some((&2, &5)));\n+    /// assert_eq!(iter.next(), Some((&3, &6)));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// `zip()` is often used to zip an infinite iterator to a finite one.\n+    /// This works because the finite iterator will eventually return `None`,\n+    /// ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate()`]:\n     ///\n-    /// for pair in (0..).zip(\"foo\".chars()) {\n-    ///     println!(\"{:?}\", pair);\n-    /// }\n     /// ```\n+    /// let enumerate: Vec<_> = \"foo\".chars().enumerate().collect();\n+    ///\n+    /// let zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();\n+    ///\n+    /// assert_eq!((0, 'f'), enumerate[0]);\n+    /// assert_eq!((0, 'f'), zipper[0]);\n+    ///\n+    /// assert_eq!((1, 'o'), enumerate[1]);\n+    /// assert_eq!((1, 'o'), zipper[1]);\n     ///\n-    /// both produce the same output.\n+    /// assert_eq!((2, 'o'), enumerate[2]);\n+    /// assert_eq!((2, 'o'), zipper[2]);\n+    /// ```\n+    ///\n+    /// [`enumerate()`]: trait.Iterator.html#method.enumerate\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where\n@@ -472,17 +654,52 @@ pub trait Iterator {\n         Zip{a: self, b: other.into_iter()}\n     }\n \n-    /// Creates a new iterator that will apply the specified function to each\n-    /// element returned by the first, yielding the mapped element instead.\n+    /// Takes a closure and creates an iterator which calls that closure on each\n+    /// element.\n+    ///\n+    /// `map()` transforms one iterator into another, by means of its argument:\n+    /// something that implements `FnMut`. It produces a new iterator which\n+    /// calls this closure on each element of the original iterator.\n+    ///\n+    /// If you are good at thinking in types, you can think of `map()` like this:\n+    /// If you have an iterator that gives you elements of some type `A`, and\n+    /// you want an iterator of some other type `B`, you can use `map()`,\n+    /// passing a closure that takes an `A` and returns a `B`.\n+    ///\n+    /// `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n+    /// lazy, it is best used when you're already working with other iterators.\n+    /// If you're doing some sort of looping for a side effect, it's considered\n+    /// more idiomatic to use [`for`] than `map()`.\n+    ///\n+    /// [`for`]: ../../book/loops.html#for\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.into_iter().map(|x| 2 * x);\n+    ///\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), Some(6));\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n-    /// let a = [1, 2];\n-    /// let mut it = a.iter().map(|&x| 2 * x);\n-    /// assert_eq!(it.next(), Some(2));\n-    /// assert_eq!(it.next(), Some(4));\n-    /// assert!(it.next().is_none());\n+    ///\n+    /// If you're doing some sort of side effect, prefer [`for`] to `map()`:\n+    ///\n+    /// ```\n+    /// // don't do this:\n+    /// (0..5).map(|x| println!(\"{}\", x));\n+    ///\n+    /// // it won't even execute, as it is lazy. Rust will warn you about this.\n+    ///\n+    /// // Instead, use for:\n+    /// for x in 0..5 {\n+    ///     println!(\"{}\", x);\n+    /// }\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -492,18 +709,66 @@ pub trait Iterator {\n         Map{iter: self, f: f}\n     }\n \n-    /// Creates an iterator that applies the predicate to each element returned\n-    /// by this iterator. The only elements that will be yielded are those that\n-    /// make the predicate evaluate to `true`.\n+    /// Creates an iterator which uses a closure to determine if an element\n+    /// should be yielded.\n+    ///\n+    /// The closure must return `true` or `false`. `filter()` creates an\n+    /// iterator which calls this closure on each element. If the closure\n+    /// returns `true`, then the element is returned. If the closure returns\n+    /// `false`, it will try again, and call the closure on the next element,\n+    /// seeing if it passes the test.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2];\n-    /// let mut it = a.iter().filter(|&x| *x > 1);\n-    /// assert_eq!(it.next(), Some(&2));\n-    /// assert!(it.next().is_none());\n+    /// let a = [0i32, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|x| x.is_positive());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n+    ///\n+    /// Because the closure passed to `filter()` takes a reference, and many\n+    /// iterators iterate over references, this leads to a possibly confusing\n+    /// situation, where the type of the closure is a double reference:\n+    ///\n+    /// ```\n+    /// let a = [0, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|x| **x > 1); // need two *s!\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// It's common to instead use destructuring on the argument to strip away\n+    /// one:\n+    ///\n+    /// ```\n+    /// let a = [0, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|&x| *x > 1); // both & and *\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// or both:\n+    ///\n+    /// ```\n+    /// let a = [0, 1, 2];\n+    ///\n+    /// let mut iter = a.into_iter().filter(|&&x| x > 1); // two &s\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// of these layers.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter<P>(self, predicate: P) -> Filter<Self, P> where\n@@ -512,18 +777,57 @@ pub trait Iterator {\n         Filter{iter: self, predicate: predicate}\n     }\n \n-    /// Creates an iterator that both filters and maps elements.\n-    /// If the specified function returns `None`, the element is skipped.\n-    /// Otherwise the option is unwrapped and the new value is yielded.\n+    /// Creates an iterator that both filters and maps.\n+    ///\n+    /// The closure must return an [`Option<T>`]. `filter_map()` creates an\n+    /// iterator which calls this closure on each element. If the closure\n+    /// returns `Some(element)`, then that element is returned. If the\n+    /// closure returns `None`, it will try again, and call the closure on the\n+    /// next element, seeing if it will return `Some`.\n+    ///\n+    /// [`Option<T>`]: ../option/enum.Option.html\n+    ///\n+    /// Why `filter_map()` and not just [`filter()`].[`map()`]? The key is in this\n+    /// part:\n+    ///\n+    /// [`filter()`]: #method.filter\n+    /// [`map()`]: #method.map\n+    ///\n+    /// > If the closure returns `Some(element)`, then that element is returned.\n+    ///\n+    /// In other words, it removes the [`Option<T>`] layer automatically. If your\n+    /// mapping is already returning an [`Option<T>`] and you want to skip over\n+    /// `None`s, then `filter_map()` is much, much nicer to use.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2];\n-    /// let mut it = a.iter().filter_map(|&x| if x > 1 {Some(2 * x)} else {None});\n-    /// assert_eq!(it.next(), Some(4));\n-    /// assert!(it.next().is_none());\n+    /// let a = [\"1\", \"2\", \"lol\"];\n+    ///\n+    /// let mut iter = a.iter().filter_map(|s| s.parse().ok());\n+    ///\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Here's the same example, but with [`filter()`] and [`map()`]:\n+    ///\n     /// ```\n+    /// let a = [\"1\", \"2\", \"lol\"];\n+    ///\n+    /// let mut iter = a.iter()\n+    ///                 .map(|s| s.parse().ok())\n+    ///                 .filter(|s| s.is_some());\n+    ///\n+    /// assert_eq!(iter.next(), Some(Some(1)));\n+    /// assert_eq!(iter.next(), Some(Some(2)));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// There's an extra layer of `Some` in there.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n@@ -532,20 +836,28 @@ pub trait Iterator {\n         FilterMap { iter: self, f: f }\n     }\n \n-    /// Creates an iterator that yields pairs `(i, val)` where `i` is the\n+    /// Creates an iterator which gives the current iteration count as well as\n+    /// the next value.\n+    ///\n+    /// The iterator returned yields pairs `(i, val)`, where `i` is the\n     /// current index of iteration and `val` is the value returned by the\n     /// iterator.\n     ///\n-    /// `enumerate` keeps its count as a `usize`. If you want to count by a\n-    /// different sized integer, the `zip` function provides similar\n+    /// `enumerate()` keeps its count as a [`usize`]. If you want to count by a\n+    /// different sized integer, the [`zip()`] function provides similar\n     /// functionality.\n     ///\n+    /// [`usize`]: ../primitive.usize.html\n+    /// [`zip()`]: #method.zip\n+    ///\n     /// # Overflow Behavior\n     ///\n     /// The method does no guarding against overflows, so enumerating more than\n-    /// `usize::MAX` elements either produces the wrong result or panics. If\n+    /// [`usize::MAX`] elements either produces the wrong result or panics. If\n     /// debug assertions are enabled, a panic is guaranteed.\n     ///\n+    /// [`usize::MAX`]: ../usize/constant.MAX.html\n+    ///\n     /// # Panics\n     ///\n     /// The returned iterator might panic if the to-be-returned index would\n@@ -554,54 +866,114 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// let a = [100, 200];\n-    /// let mut it = a.iter().enumerate();\n-    /// assert_eq!(it.next(), Some((0, &100)));\n-    /// assert_eq!(it.next(), Some((1, &200)));\n-    /// assert!(it.next().is_none());\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().enumerate();\n+    ///\n+    /// assert_eq!(iter.next(), Some((0, &1)));\n+    /// assert_eq!(iter.next(), Some((1, &2)));\n+    /// assert_eq!(iter.next(), Some((2, &3)));\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn enumerate(self) -> Enumerate<Self> where Self: Sized {\n         Enumerate { iter: self, count: 0 }\n     }\n \n-    /// Creates an iterator that has a `.peek()` method\n-    /// that returns an optional reference to the next element.\n+    /// Creates an iterator which can look at the `next()` element without\n+    /// consuming it.\n+    ///\n+    /// Adds a [`peek()`] method to an iterator. See its documentation for\n+    /// more information.\n+    ///\n+    /// [`peek()`]: struct.Peekable.html#method.peek\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let xs = [100, 200, 300];\n-    /// let mut it = xs.iter().cloned().peekable();\n-    /// assert_eq!(*it.peek().unwrap(), 100);\n-    /// assert_eq!(it.next().unwrap(), 100);\n-    /// assert_eq!(it.next().unwrap(), 200);\n-    /// assert_eq!(*it.peek().unwrap(), 300);\n-    /// assert_eq!(*it.peek().unwrap(), 300);\n-    /// assert_eq!(it.next().unwrap(), 300);\n-    /// assert!(it.peek().is_none());\n-    /// assert!(it.next().is_none());\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // we can peek() multiple times, the itererator won't advance\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // after the itererator is finished, so is peek()\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn peekable(self) -> Peekable<Self> where Self: Sized {\n         Peekable{iter: self, peeked: None}\n     }\n \n-    /// Creates an iterator that invokes the predicate on elements\n-    /// until it returns false. Once the predicate returns false, that\n-    /// element and all further elements are yielded.\n+    /// Creates an iterator that [`skip()`]s elements based on a predicate.\n+    ///\n+    /// [`skip()`]: #method.skip\n+    ///\n+    /// `skip_while()` takes a closure as an argument. It will call this\n+    /// closure on each element of the iterator, and ignore elements\n+    /// until it returns `false`.\n+    ///\n+    /// After `false` is returned, `skip_while()`'s job is over, and the\n+    /// rest of the elements are yielded.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter().skip_while(|&a| *a < 3);\n-    /// assert_eq!(it.next(), Some(&3));\n-    /// assert_eq!(it.next(), Some(&4));\n-    /// assert_eq!(it.next(), Some(&5));\n-    /// assert!(it.next().is_none());\n+    /// let a = [-1i32, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().skip_while(|x| x.is_negative());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because the closure passed to `skip_while()` takes a reference, and many\n+    /// iterators iterate over references, this leads to a possibly confusing\n+    /// situation, where the type of the closure is a double reference:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().skip_while(|x| **x < 0); // need two *s!\n+    ///\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Stopping after an initial `false`:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1, -2];\n+    ///\n+    /// let mut iter = a.into_iter().skip_while(|x| **x < 0);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// // while this would have been false, since we already got a false,\n+    /// // skip_while() isn't used any more\n+    /// assert_eq!(iter.next(), Some(&-2));\n+    ///\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -611,18 +983,53 @@ pub trait Iterator {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n-    /// Creates an iterator that yields elements so long as the predicate\n-    /// returns true. After the predicate returns false for the first time, no\n-    /// further elements will be yielded.\n+    /// Creates an iterator that yields elements based on a predicate.\n+    ///\n+    /// `take_while()` takes a closure as an argument. It will call this\n+    /// closure on each element of the iterator, and yield elements\n+    /// while it returns `true`.\n+    ///\n+    /// After `false` is returned, `take_while()`'s job is over, and the\n+    /// rest of the elements are ignored.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter().take_while(|&a| *a < 3);\n-    /// assert_eq!(it.next(), Some(&1));\n-    /// assert_eq!(it.next(), Some(&2));\n-    /// assert!(it.next().is_none());\n+    /// let a = [-1i32, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().take_while(|x| x.is_negative());\n+    ///\n+    /// assert_eq!(iter.next(), Some(&-1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Because the closure passed to `take_while()` takes a reference, and many\n+    /// iterators iterate over references, this leads to a possibly confusing\n+    /// situation, where the type of the closure is a double reference:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1];\n+    ///\n+    /// let mut iter = a.into_iter().take_while(|x| **x < 0); // need two *s!\n+    ///\n+    /// assert_eq!(iter.next(), Some(&-1));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// Stopping after an initial `false`:\n+    ///\n+    /// ```\n+    /// let a = [-1, 0, 1, -2];\n+    ///\n+    /// let mut iter = a.into_iter().take_while(|x| **x < 0);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&-1));\n+    ///\n+    /// // We have more elements that are less than zero, but since we already\n+    /// // got a false, take_while() isn't used any more\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -632,62 +1039,90 @@ pub trait Iterator {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n-    /// Creates an iterator that skips the first `n` elements of this iterator,\n-    /// and then yields all further items.\n+    /// Creates an iterator that skips the first `n` elements.\n+    ///\n+    /// After they have been consumed, the rest of the elements are yielded.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter().skip(3);\n-    /// assert_eq!(it.next(), Some(&4));\n-    /// assert_eq!(it.next(), Some(&5));\n-    /// assert!(it.next().is_none());\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().skip(2);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn skip(self, n: usize) -> Skip<Self> where Self: Sized {\n         Skip{iter: self, n: n}\n     }\n \n-    /// Creates an iterator that yields the first `n` elements of this\n-    /// iterator.\n+    /// Creates an iterator that yields its first `n` elements.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter().take(3);\n-    /// assert_eq!(it.next(), Some(&1));\n-    /// assert_eq!(it.next(), Some(&2));\n-    /// assert_eq!(it.next(), Some(&3));\n-    /// assert!(it.next().is_none());\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().take(2);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&1));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// `take()` is often used with an infinite iterator, to make it finite:\n+    ///\n+    /// ```\n+    /// let mut iter = (0..).take(3);\n+    ///\n+    /// assert_eq!(iter.next(), Some(0));\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, n: usize) -> Take<Self> where Self: Sized, {\n         Take{iter: self, n: n}\n     }\n \n-    /// Creates a new iterator that behaves in a similar fashion to fold.\n-    /// There is a state which is passed between each iteration and can be\n-    /// mutated as necessary. The yielded values from the closure are yielded\n-    /// from the Scan instance when not `None`.\n+    /// An iterator similar to `fold()`, with internal state.\n+    ///\n+    /// `scan()` accumulates a final value, similar to [`fold()`], but instead\n+    /// of passing along an accumulator, it maintains the accumulator internally.\n+    ///\n+    /// [`fold()`]: #method.fold\n+    ///\n+    /// On each iteraton of `scan()`, you can assign to the internal state, and\n+    /// a mutable reference to the state is passed as the first argument to the\n+    /// closure, allowing you to modify it on each iteration.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter().scan(1, |fac, &x| {\n-    ///   *fac = *fac * x;\n-    ///   Some(*fac)\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().scan(1, |state, &x| {\n+    ///     // each iteration, we'll multiply the state by the element\n+    ///     *state = *state * x;\n+    ///\n+    ///     // the value passed on to the next iteration\n+    ///     Some(*state)\n     /// });\n-    /// assert_eq!(it.next(), Some(1));\n-    /// assert_eq!(it.next(), Some(2));\n-    /// assert_eq!(it.next(), Some(6));\n-    /// assert_eq!(it.next(), Some(24));\n-    /// assert_eq!(it.next(), Some(120));\n-    /// assert!(it.next().is_none());\n+    ///\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), Some(6));\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -697,15 +1132,27 @@ pub trait Iterator {\n         Scan{iter: self, f: f, state: initial_state}\n     }\n \n-    /// Takes a function that maps each element to a new iterator and yields\n-    /// all the elements of the produced iterators.\n+    /// Creates an iterator that works like map, but flattens nested structure.\n+    ///\n+    /// The [`map()`] adapter is very useful, but only when the closure\n+    /// argument produces values. If it produces an iterator instead, there's\n+    /// an extra layer of indirection. `flat_map()` will remove this extra layer\n+    /// on its own.\n+    ///\n+    /// [`map()`]: #method.map\n     ///\n-    /// This is useful for unraveling nested structures.\n+    /// Another way of thinking about `flat_map()`: [`map()`]'s closure returns\n+    /// one item for each element, and `flat_map()`'s closure returns an\n+    /// iterator for each element.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let words = [\"alpha\", \"beta\", \"gamma\"];\n+    ///\n+    /// // chars() returns an iterator\n     /// let merged: String = words.iter()\n     ///                           .flat_map(|s| s.chars())\n     ///                           .collect();\n@@ -719,54 +1166,109 @@ pub trait Iterator {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n \n-    /// Creates an iterator that yields `None` forever after the underlying\n-    /// iterator yields `None`. Random-access iterator behavior is not\n-    /// affected, only single and double-ended iterator behavior.\n+    /// Creates an iterator which ends after the first `None`.\n+    ///\n+    /// After an iterator returns `None`, future calls may or may not yield\n+    /// `Some(T)` again. `fuse()` adapts an iterator, ensuring that after a\n+    /// `None` is given, it will always return `None` forever.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// fn process<U: Iterator<Item=i32>>(it: U) -> i32 {\n-    ///     let mut it = it.fuse();\n-    ///     let mut sum = 0;\n-    ///     for x in it.by_ref() {\n-    ///         if x > 5 {\n-    ///             break;\n+    /// // an iterator which alternates between Some and None\n+    /// struct Alternate {\n+    ///     state: i32,\n+    /// }\n+    ///\n+    /// impl Iterator for Alternate {\n+    ///     type Item = i32;\n+    ///\n+    ///     fn next(&mut self) -> Option<i32> {\n+    ///         let val = self.state;\n+    ///         self.state = self.state + 1;\n+    ///\n+    ///         // if it's even, Some(i32), else None\n+    ///         if val % 2 == 0 {\n+    ///             Some(val)\n+    ///         } else {\n+    ///             None\n     ///         }\n-    ///         sum += x;\n-    ///     }\n-    ///     // did we exhaust the iterator?\n-    ///     if it.next().is_none() {\n-    ///         sum += 1000;\n     ///     }\n-    ///     sum\n     /// }\n-    /// let x = vec![1, 2, 3, 7, 8, 9];\n-    /// assert_eq!(process(x.into_iter()), 6);\n-    /// let x = vec![1, 2, 3];\n-    /// assert_eq!(process(x.into_iter()), 1006);\n+    ///\n+    /// let mut iter = Alternate { state: 0 };\n+    ///\n+    /// // we can see our iterator going back and forth\n+    /// assert_eq!(iter.next(), Some(0));\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n+    ///\n+    /// // however, once we fuse it...\n+    /// let mut iter = iter.fuse();\n+    ///\n+    /// assert_eq!(iter.next(), Some(4));\n+    /// assert_eq!(iter.next(), None);\n+    ///\n+    /// // it will always return None after the first time.\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fuse(self) -> Fuse<Self> where Self: Sized {\n         Fuse{iter: self, done: false}\n     }\n \n-    /// Creates an iterator that calls a function with a reference to each\n-    /// element before yielding it. This is often useful for debugging an\n-    /// iterator pipeline.\n+    /// Do something with each element of an iterator, passing the value on.\n+    ///\n+    /// When using iterators, you'll often chain several of them together.\n+    /// While working on such code, you might want to check out what's\n+    /// happening at various parts in the pipeline. To do that, insert\n+    /// a call to `inspect()`.\n+    ///\n+    /// It's much more common for `inspect()` to be used as a debugging tool\n+    /// than to exist in your final code, but never say never.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 4, 2, 3, 8, 9, 6];\n-    /// let sum: i32 = a.iter()\n-    ///                 .map(|x| *x)\n-    ///                 .inspect(|&x| println!(\"filtering {}\", x))\n-    ///                 .filter(|&x| x % 2 == 0)\n-    ///                 .inspect(|&x| println!(\"{} made it through\", x))\n-    ///                 .fold(0, |sum, i| sum + i);\n+    /// let a = [1, 4, 2, 3];\n+    ///\n+    /// // this iterator sequence is complex.\n+    /// let sum = a.iter()\n+    ///             .cloned()\n+    ///             .filter(|&x| x % 2 == 0)\n+    ///             .fold(0, |sum, i| sum + i);\n+    ///\n     /// println!(\"{}\", sum);\n+    ///\n+    /// // let's add some inspect() calls to investigate what's happening\n+    /// let sum = a.iter()\n+    ///             .cloned()\n+    ///             .inspect(|x| println!(\"about to filter: {}\", x))\n+    ///             .filter(|&x| x % 2 == 0)\n+    ///             .inspect(|x| println!(\"made it through filter: {}\", x))\n+    ///             .fold(0, |sum, i| sum + i);\n+    ///\n+    /// println!(\"{}\", sum);\n+    /// ```\n+    ///\n+    /// This will print:\n+    ///\n+    /// ```text\n+    /// about to filter: 1\n+    /// about to filter: 4\n+    /// made it through filter: 4\n+    /// about to filter: 2\n+    /// made it through filter: 2\n+    /// about to filter: 3\n+    /// 6\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -776,49 +1278,187 @@ pub trait Iterator {\n         Inspect{iter: self, f: f}\n     }\n \n-    /// Creates a wrapper around a mutable reference to the iterator.\n+    /// Borrows an iterator, rather than consuming it.\n     ///\n     /// This is useful to allow applying iterator adaptors while still\n-    /// retaining ownership of the original iterator value.\n+    /// retaining ownership of the original iterator.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let mut it = 0..10;\n-    /// // sum the first five values\n-    /// let partial_sum = it.by_ref().take(5).fold(0, |a, b| a + b);\n-    /// assert_eq!(partial_sum, 10);\n-    /// assert_eq!(it.next(), Some(5));\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let iter = a.into_iter();\n+    ///\n+    /// let sum: i32 = iter.take(5)\n+    ///                    .fold(0, |acc, &i| acc + i );\n+    ///\n+    /// assert_eq!(sum, 6);\n+    ///\n+    /// // if we try to use iter again, it won't work. The following line\n+    /// // gives \"error: use of moved value: `iter`\n+    /// // assert_eq!(iter.next(), None);\n+    ///\n+    /// // let's try that again\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.into_iter();\n+    ///\n+    /// // instead, we add in a .by_ref()\n+    /// let sum: i32 = iter.by_ref()\n+    ///                    .take(2)\n+    ///                    .fold(0, |acc, &i| acc + i );\n+    ///\n+    /// assert_eq!(sum, 3);\n+    ///\n+    /// // now this is just fine:\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n \n-    /// Loops through the entire iterator, collecting all of the elements into\n-    /// a container implementing `FromIterator`.\n+    /// Transforms an iterator into a collection.\n+    ///\n+    /// `collect()` can take anything iterable, and turn it into a relevant\n+    /// collection. This is one of the more powerful methods in the standard\n+    /// library, used in a variety of contexts.\n+    ///\n+    /// The most basic pattern in which `collect()` is used is to turn one\n+    /// collection into another. You take a collection, call `iter()` on it,\n+    /// do a bunch of transformations, and then `collect()` at the end.\n+    ///\n+    /// One of the keys to `collect()`'s power is that many things you might\n+    /// not think of as 'collections' actually are. For example, a [`String`]\n+    /// is a collection of [`char`]s. And a collection of [`Result<T, E>`] can\n+    /// be thought of as single [`Result<Collection<T>, E>`]. See the examples\n+    /// below for more.\n+    ///\n+    /// [`String`]: ../string/struct.String.html\n+    /// [`Result<T, E>`]: ../result/enum.Result.html\n+    /// [`char`]: ../primitive.char.html\n+    ///\n+    /// Because `collect()` is so general, it can cause problems with type\n+    /// inference. As such, `collect()` is one of the few times you'll see\n+    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n+    /// helps the inference algorithm understand specifically which collection\n+    /// you're trying to collect into.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled: Vec<i32> = a.iter()\n+    ///                          .map(|&x| x * 2)\n+    ///                          .collect();\n+    ///\n+    /// assert_eq!(vec![2, 4, 6], doubled);\n+    /// ```\n+    ///\n+    /// Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n+    /// we could collect into, for example, a [`VecDeque<T>`] instead:\n+    ///\n+    /// [`VecDeque<T>`]: ../collections/struct.VecDeque.html\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled: VecDeque<i32> = a.iter()\n+    ///                               .map(|&x| x * 2)\n+    ///                               .collect();\n+    ///\n+    /// assert_eq!(2, doubled[0]);\n+    /// assert_eq!(4, doubled[1]);\n+    /// assert_eq!(6, doubled[2]);\n+    /// ```\n+    ///\n+    /// Using the 'turbofish' instead of annotationg `doubled`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled = a.iter()\n+    ///                .map(|&x| x * 2)\n+    ///                .collect::<Vec<i32>>();\n+    ///\n+    /// assert_eq!(vec![2, 4, 6], doubled);\n+    /// ```\n+    ///\n+    /// Because `collect()` cares about what you're collecting into, you can\n+    /// still use a partial type hint, `_`, with the turbofish:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let doubled = a.iter()\n+    ///                .map(|&x| x * 2)\n+    ///                .collect::<Vec<_>>();\n+    ///\n+    /// assert_eq!(vec![2, 4, 6], doubled);\n+    /// ```\n+    ///\n+    /// Using `collect()` to make a [`String`]:\n+    ///\n+    /// ```\n+    /// let chars = ['g', 'd', 'k', 'k', 'n'];\n+    ///\n+    /// let hello: String = chars.iter()\n+    ///                          .map(|&x| x as u8)\n+    ///                          .map(|x| (x + 1) as char)\n+    ///                          .collect();\n+    ///\n+    /// assert_eq!(\"hello\", hello);\n     /// ```\n-    /// let expected = [1, 2, 3, 4, 5];\n-    /// let actual: Vec<_> = expected.iter().cloned().collect();\n-    /// assert_eq!(actual, expected);\n+    ///\n+    /// If you have a list of [`Result<T, E>`]s, you can use `collect()` to\n+    /// see if any of them failed:\n+    ///\n+    /// ```\n+    /// let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n+    ///\n+    /// let result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n+    ///\n+    /// // gives us the first error\n+    /// assert_eq!(Err(\"nope\"), result);\n+    ///\n+    /// let results = [Ok(1), Ok(3)];\n+    ///\n+    /// let result: Result<Vec<_>, &str> = results.iter().cloned().collect();\n+    ///\n+    /// // gives us the list of answers\n+    /// assert_eq!(Ok(vec![1, 3]), result);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn collect<B: FromIterator<Self::Item>>(self) -> B where Self: Sized {\n         FromIterator::from_iter(self)\n     }\n \n-    /// Loops through the entire iterator, collecting all of the elements into\n-    /// one of two containers, depending on a predicate. The elements of the\n-    /// first container satisfy the predicate, while the elements of the second\n-    /// do not.\n+    /// Consumes an iterator, creating two collections from it.\n+    ///\n+    /// The predicate passed to `partition()` can return `true`, or `false`.\n+    /// `partition()` returns a pair, all of the elements for which it returned\n+    /// `true`, and all of the elements for which it returned `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n     ///\n     /// ```\n-    /// let vec = vec![1, 2, 3, 4];\n-    /// let (even, odd): (Vec<_>, Vec<_>) = vec.into_iter().partition(|&n| n % 2 == 0);\n-    /// assert_eq!(even, [2, 4]);\n-    /// assert_eq!(odd, [1, 3]);\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let (even, odd): (Vec<i32>, Vec<i32>) = a.into_iter()\n+    ///                                          .partition(|&n| n % 2 == 0);\n+    ///\n+    /// assert_eq!(even, vec![2]);\n+    /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partition<B, F>(self, mut f: F) -> (B, B) where\n@@ -840,16 +1480,67 @@ pub trait Iterator {\n         (left, right)\n     }\n \n-    /// Performs a fold operation over the entire iterator, returning the\n-    /// eventual state at the end of the iteration.\n+    /// An iterator adaptor that applies a function, producing a single, final value.\n+    ///\n+    /// `fold()` takes two arguments: an initial value, and a closure with two\n+    /// arguments: an 'accumulator', and an element. It returns the value that\n+    /// the accumulator should have for the next iteration.\n+    ///\n+    /// The initial value is the value the accumulator will have on the first\n+    /// call.\n+    ///\n+    /// After applying this closure to every element of the iterator, `fold()`\n+    /// returns the accumulator.\n     ///\n     /// This operation is sometimes called 'reduce' or 'inject'.\n     ///\n+    /// Folding is useful whenever you have a collection of something, and want\n+    /// to produce a single value from it.\n+    ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// assert_eq!(a.iter().fold(0, |acc, &item| acc + item), 15);\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// // the sum of all of the elements of a\n+    /// let sum = a.iter()\n+    ///            .fold(0, |acc, &x| acc + x);\n+    ///\n+    /// assert_eq!(sum, 6);\n+    /// ```\n+    ///\n+    /// Let's walk through each step of the iteration here:\n+    ///\n+    /// | element | acc | x | result |\n+    /// |---------|-----|---|--------|\n+    /// |         | 0   |   |        |\n+    /// | 1       | 0   | 1 | 1      |\n+    /// | 2       | 1   | 2 | 3      |\n+    /// | 3       | 3   | 3 | 6      |\n+    ///\n+    /// And so, our final result, `6`.\n+    ///\n+    /// It's common for people who haven't used iterators a lot to\n+    /// use a `for` loop with a list of things to build up a result. Those\n+    /// can be turned into `fold()`s:\n+    ///\n+    /// ```\n+    /// let numbers = [1, 2, 3, 4, 5];\n+    ///\n+    /// let mut result = 0;\n+    ///\n+    /// // for loop:\n+    /// for i in &numbers {\n+    ///     result = result + i;\n+    /// }\n+    ///\n+    /// // fold:\n+    /// let result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n+    ///\n+    /// // they're the same\n+    /// assert_eq!(result, result2);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -863,16 +1554,40 @@ pub trait Iterator {\n         accum\n     }\n \n-    /// Tests whether the predicate holds true for all elements in the iterator.\n+    /// Tests if every element of the iterator matches a predicate.\n+    ///\n+    /// `all()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if they all return\n+    /// `true`, then so does `all()`. If any of them return `false`, it\n+    /// returns `false`.\n     ///\n-    /// Does not consume the iterator past the first non-matching element.\n+    /// `all()` is short-circuting; in other words, it will stop processing\n+    /// as soon as it finds a `false`, given that no matter what else happens,\n+    /// the result will also be `false`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// assert!(a.iter().all(|x| *x > 0));\n-    /// assert!(!a.iter().all(|x| *x > 2));\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert!(a.iter().all(|&x| x > 0));\n+    ///\n+    /// assert!(!a.iter().all(|&x| x > 2));\n+    /// ```\n+    ///\n+    /// Stopping at the first `false`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert!(!iter.all(|&x| x != 2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&3));\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -887,18 +1602,40 @@ pub trait Iterator {\n         true\n     }\n \n-    /// Tests whether any element of an iterator satisfies the specified\n-    /// predicate.\n+    /// Tests if any element of the iterator matches a predicate.\n     ///\n-    /// Does not consume the iterator past the first found element.\n+    /// `any()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if any of them return\n+    /// `true`, then so does `any()`. If they all return `false`, it\n+    /// returns `false`.\n+    ///\n+    /// `any()` is short-circuting; in other words, it will stop processing\n+    /// as soon as it finds a `true`, given that no matter what else happens,\n+    /// the result will also be `true`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert!(it.any(|x| *x == 3));\n-    /// assert_eq!(it.collect::<Vec<_>>(), [&4, &5]);\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert!(a.iter().any(|&x| x > 0));\n+    ///\n+    /// assert!(!a.iter().any(|&x| x > 5));\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert!(iter.any(|&x| x != 2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&2));\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -914,17 +1651,45 @@ pub trait Iterator {\n         false\n     }\n \n-    /// Returns the first element satisfying the specified predicate.\n+    /// Searches for an element of an iterator that satisfies a predicate.\n     ///\n-    /// Does not consume the iterator past the first found element.\n+    /// `find()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if any of them return\n+    /// `true`, then `find()` returns `Some(element)`. If they all return\n+    /// `false`, it returns `None`.\n+    ///\n+    /// `find()` is short-circuting; in other words, it will stop processing\n+    /// as soon as the closure returns `true`.\n+    ///\n+    /// Because `find()` takes a reference, and many iterators iterate over\n+    /// references, this leads to a possibly confusing situation where the\n+    /// argument is a double reference. You can see this effect in the\n+    /// examples below, with `&&x`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().find(|&&x| x == 2), Some(&2));\n+    ///\n+    /// assert_eq!(a.iter().find(|&&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.find(|&&x| x == 2), Some(&2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&3));\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert_eq!(it.find(|&x| *x == 3), Some(&3));\n-    /// assert_eq!(it.collect::<Vec<_>>(), [&4, &5]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n@@ -937,9 +1702,15 @@ pub trait Iterator {\n         None\n     }\n \n-    /// Returns the index of the first element satisfying the specified predicate\n+    /// Searches for an element in an iterator, returning its index.\n+    ///\n+    /// `position()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, and if if one of them\n+    /// returns `true`, then `position()` returns `Some(index)`. If all of\n+    /// them return `false`, it returns `None`.\n     ///\n-    /// Does not consume the iterator past the first found element.\n+    /// `position()` is short-circuting; in other words, it will stop\n+    /// processing as soon as it finds a `true`.\n     ///\n     /// # Overflow Behavior\n     ///\n@@ -950,16 +1721,33 @@ pub trait Iterator {\n     ///\n     /// # Panics\n     ///\n-    /// This functions might panic if the iterator has more than `usize::MAX`\n+    /// This function might panic if the iterator has more than `usize::MAX`\n     /// non-matching elements.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().position(|&x| x == 2), Some(1));\n+    ///\n+    /// assert_eq!(a.iter().position(|&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.position(|&x| x == 2), Some(1));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&3));\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert_eq!(it.position(|x| *x == 3), Some(2));\n-    /// assert_eq!(it.collect::<Vec<_>>(), [&4, &5]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n@@ -975,19 +1763,41 @@ pub trait Iterator {\n         None\n     }\n \n-    /// Returns the index of the last element satisfying the specified predicate\n+    /// Searches for an element in an iterator from the right, returning its\n+    /// index.\n     ///\n-    /// If no element matches, `None` is returned.\n+    /// `rposition()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, starting from the end,\n+    /// and if if one of them returns `true`, then `rposition()` returns\n+    /// `Some(index)`. If all of them return `false`, it returns `None`.\n     ///\n-    /// Does not consume the iterator *before* the first found element.\n+    /// `rposition()` is short-circuting; in other words, it will stop\n+    /// processing as soon as it finds a `true`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().rposition(|&x| x == 3), Some(2));\n+    ///\n+    /// assert_eq!(a.iter().rposition(|&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.rposition(|&x| x == 2), Some(1));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next(), Some(&1));\n     /// ```\n-    /// let a = [1, 2, 2, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert_eq!(it.rposition(|x| *x == 2), Some(2));\n-    /// assert_eq!(it.collect::<Vec<_>>(), [&1, &2]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n@@ -1007,16 +1817,19 @@ pub trait Iterator {\n         None\n     }\n \n-    /// Consumes the entire iterator to return the maximum element.\n+    /// Returns the maximum element of an iterator.\n     ///\n-    /// Returns the rightmost element if the comparison determines two elements\n-    /// to be equally maximum.\n+    /// If the two elements are equally maximum, the latest element is\n+    /// returned.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// assert_eq!(a.iter().max(), Some(&5));\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().max(), Some(&3));\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1030,15 +1843,18 @@ pub trait Iterator {\n             .map(|(_, x)| x)\n     }\n \n-    /// Consumes the entire iterator to return the minimum element.\n+    /// Returns the minimum element of an iterator.\n     ///\n-    /// Returns the leftmost element if the comparison determines two elements\n-    /// to be equally minimum.\n+    /// If the two elements are equally minimum, the first element is\n+    /// returned.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3];\n+    ///\n     /// assert_eq!(a.iter().min(), Some(&1));\n     /// ```\n     #[inline]\n@@ -1086,7 +1902,7 @@ pub trait Iterator {\n     /// Returns the element that gives the minimum value from the\n     /// specified function.\n     ///\n-    /// Returns the leftmost element if the comparison determines two elements\n+    /// Returns the latest element if the comparison determines two elements\n     /// to be equally minimum.\n     ///\n     /// # Examples\n@@ -1113,18 +1929,29 @@ pub trait Iterator {\n             .map(|(_, x)| x)\n     }\n \n-    /// Change the direction of the iterator\n+    /// Reverses an iterator's direction.\n+    ///\n+    /// Usually, iterators iterate from left to right. After using `rev()`,\n+    /// an iterator will instead iterate from right to left.\n     ///\n-    /// The flipped iterator swaps the ends on an iterator that can already\n-    /// be iterated from the front and from the back.\n+    /// This is only possible if the iterator has an end, so `rev()` only\n+    /// works on [`DoubleEndedIterator`]s.\n     ///\n+    /// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n     ///\n-    /// If the iterator also implements RandomAccessIterator, the flipped\n-    /// iterator is also random access, with the indices starting at the back\n-    /// of the original iterator.\n+    /// # Examples\n     ///\n-    /// Note: Random access with flipped indices still only applies to the first\n-    /// `std::usize::MAX` elements of the original iterator.\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter().rev();\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rev(self) -> Rev<Self> where Self: Sized + DoubleEndedIterator {\n@@ -1133,14 +1960,23 @@ pub trait Iterator {\n \n     /// Converts an iterator of pairs into a pair of containers.\n     ///\n-    /// Loops through the entire iterator, collecting the first component of\n-    /// each item into one new container, and the second component into another.\n+    /// `unzip()` consumes an entire iterator of pairs, producing two\n+    /// collections: one from the left elements of the pairs, and one\n+    /// from the right elements.\n+    ///\n+    /// This function is, in some sense, the opposite of [`zip()`].\n+    ///\n+    /// [`zip()`]: #method.zip\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let a = [(1, 2), (3, 4)];\n+    ///\n     /// let (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();\n+    ///\n     /// assert_eq!(left, [1, 3]);\n     /// assert_eq!(right, [2, 4]);\n     /// ```\n@@ -1175,18 +2011,25 @@ pub trait Iterator {\n         (ts, us)\n     }\n \n-    /// Creates an iterator that clones the elements it yields.\n+    /// Creates an iterator which clone()s all of its elements.\n     ///\n-    /// This is useful for converting an `Iterator<&T>` to an`Iterator<T>`,\n-    /// so it's a more convenient form of `map(|&x| x)`.\n+    /// This is useful when you have an iterator over `&T`, but you need an\n+    /// iterator over `T`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [0, 1, 2];\n+    /// let a = [1, 2, 3];\n+    ///\n     /// let v_cloned: Vec<_> = a.iter().cloned().collect();\n+    ///\n+    /// // cloned is the same as .map(|&x| x), for integers\n     /// let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n-    /// assert_eq!(v_cloned, v_map);\n+    ///\n+    /// assert_eq!(v_cloned, vec![1, 2, 3]);\n+    /// assert_eq!(v_map, vec![1, 2, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cloned<'a, T: 'a>(self) -> Cloned<Self>\n@@ -1195,15 +2038,27 @@ pub trait Iterator {\n         Cloned { it: self }\n     }\n \n-    /// Repeats an iterator endlessly\n+    /// Repeats an iterator endlessly.\n+    ///\n+    /// Instead of stopping at `None`, the iterator will instead start again,\n+    /// from the beginning. After iterating again, it will start at the\n+    /// beginning again. And again. And again. Forever.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = [1, 2];\n+    /// let a = [1, 2, 3];\n+    ///\n     /// let mut it = a.iter().cycle();\n+    ///\n     /// assert_eq!(it.next(), Some(&1));\n     /// assert_eq!(it.next(), Some(&2));\n+    /// assert_eq!(it.next(), Some(&3));\n+    /// assert_eq!(it.next(), Some(&1));\n+    /// assert_eq!(it.next(), Some(&2));\n+    /// assert_eq!(it.next(), Some(&3));\n     /// assert_eq!(it.next(), Some(&1));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1212,16 +2067,21 @@ pub trait Iterator {\n         Cycle{orig: self.clone(), iter: self}\n     }\n \n-    /// Iterates over the entire iterator, summing up all the elements\n+    /// Sums the elements of an iterator.\n+    ///\n+    /// Takes each element, adds them together, and returns the result.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// #![feature(iter_arith)]\n     ///\n-    /// let a = [1, 2, 3, 4, 5];\n-    /// let it = a.iter();\n-    /// assert_eq!(it.sum::<i32>(), 15);\n+    /// let a = [1, 2, 3];\n+    /// let sum: i32 = a.iter().sum();\n+    ///\n+    /// assert_eq!(sum, 6);\n     /// ```\n     #[unstable(feature = \"iter_arith\", reason = \"bounds recently changed\",\n                issue = \"27739\")]\n@@ -2520,8 +3380,45 @@ impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator> Peekable<I> {\n-    /// Returns a reference to the next element of the iterator with out\n-    /// advancing it, or None if the iterator is exhausted.\n+    /// Returns a reference to the next() value without advancing the iterator.\n+    ///\n+    /// The `peek()` method will return the value that a call to [`next()`] would\n+    /// return, but does not advance the iterator. Like [`next()`], if there is\n+    /// a value, it's wrapped in a `Some(T)`, but if the iterator is over, it\n+    /// will return `None`.\n+    ///\n+    /// [`next()`]: trait.Iterator.html#tymethod.next\n+    ///\n+    /// Because `peek()` returns reference, and many iterators iterate over\n+    /// references, this leads to a possibly confusing situation where the\n+    /// return value is a double reference. You can see this effect in the\n+    /// examples below, with `&&i32`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // we can peek() multiple times, the itererator won't advance\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // after the itererator is finished, so is peek()\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&mut self) -> Option<&I::Item> {\n@@ -2534,7 +3431,32 @@ impl<I: Iterator> Peekable<I> {\n         }\n     }\n \n-    /// Checks whether peekable iterator is empty or not.\n+    /// Checks if the iterator has finished iterating.\n+    ///\n+    /// Returns `true` if there are no more elements in the iterator, and\n+    /// `false` if there are.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(core)]\n+    ///\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // there are still elements to iterate over\n+    /// assert_eq!(iter.is_empty(), false);\n+    ///\n+    /// // let's consume the iterator\n+    /// iter.next();\n+    /// iter.next();\n+    /// iter.next();\n+    ///\n+    /// assert_eq!(iter.is_empty(), true);\n+    /// ```\n     #[inline]\n     pub fn is_empty(&mut self) -> bool {\n         self.peek().is_none()"}]}