{"sha": "40e05413096bbd5f35e566e796f525742076600f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZTA1NDEzMDk2YmJkNWYzNWU1NjZlNzk2ZjUyNTc0MjA3NjYwMGY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-06-26T11:46:54Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-07-02T11:32:57Z"}, "message": "debuginfo: Make names of types in debuginfo reliable and omit source locations from debug info type descriptions.\n\nSo far, type names generated for debuginfo where a bit sketchy. It was not clearly defined when a name should be fully qualified and when not, if region parameters should be shown or not, and other things like that.\nThis commit makes the debuginfo module responsible for creating type names instead of using ppaux::ty_to_str() and brings type names, as they show up in the DWARF information, in line with GCC and Clang:\n\n* The name of the type being described is unqualified. It's path is defined by its position in the namespace hierarchy.\n* Type arguments are always fully qualified, no matter if they would actually be in scope at the type definition location.\n\nCare is also taken to reliably make type names consistent across crate boundaries. That is, the code now tries make the type name the same, regardless if the type is in the local crate or reconstructed from metadata. Otherwise LLVM will complain about violating the one-definition-rule when using link-time-optimization.\n\nThis commit also removes all source location information from type descriptions because these cannot be reconstructed for types instantiated from metadata. Again, with LTO enabled, this can lead to two versions of the debuginfo type description, one with and one without source location information, which then triggers the LLVM ODR assertion.\nFortunately, source location information about types is rarely used, so this has little impact. Once source location information is preserved in metadata (#1972) it can also be reenabled for type descriptions.", "tree": {"sha": "d44abb6ace437606184f73bd6dd78d8bac3ae9dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d44abb6ace437606184f73bd6dd78d8bac3ae9dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40e05413096bbd5f35e566e796f525742076600f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40e05413096bbd5f35e566e796f525742076600f", "html_url": "https://github.com/rust-lang/rust/commit/40e05413096bbd5f35e566e796f525742076600f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40e05413096bbd5f35e566e796f525742076600f/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89259b34c04aff7052dd122552fac3070c830f4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/89259b34c04aff7052dd122552fac3070c830f4f", "html_url": "https://github.com/rust-lang/rust/commit/89259b34c04aff7052dd122552fac3070c830f4f"}], "stats": {"total": 928, "additions": 744, "deletions": 184}, "files": [{"sha": "f4019898003762f2f531259f605da2b4d0ffcadb", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 411, "deletions": 184, "changes": 595, "blob_url": "https://github.com/rust-lang/rust/blob/40e05413096bbd5f35e566e796f525742076600f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e05413096bbd5f35e566e796f525742076600f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=40e05413096bbd5f35e566e796f525742076600f", "patch": "@@ -222,6 +222,13 @@ static DW_ATE_signed: c_uint = 0x05;\n static DW_ATE_unsigned: c_uint = 0x07;\n static DW_ATE_unsigned_char: c_uint = 0x08;\n \n+static UNKNOWN_LINE_NUMBER: c_uint = 0;\n+static UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n+\n+// ptr::null() doesn't work :(\n+static UNKNOWN_FILE_METADATA: DIFile = (0 as DIFile);\n+static UNKNOWN_SCOPE_METADATA: DIScope = (0 as DIScope);\n+\n //=-----------------------------------------------------------------------------\n //  Public Interface of debuginfo module\n //=-----------------------------------------------------------------------------\n@@ -330,15 +337,15 @@ impl TypeMap {\n         unique_type_id.push_char('{');\n \n         match ty::get(type_).sty {\n-            ty::ty_nil                |\n-            ty::ty_bot                |\n-            ty::ty_bool               |\n-            ty::ty_char               |\n-            ty::ty_str                |\n-            ty::ty_int(_)             |\n-            ty::ty_uint(_)            |\n+            ty::ty_nil      |\n+            ty::ty_bot      |\n+            ty::ty_bool     |\n+            ty::ty_char     |\n+            ty::ty_str      |\n+            ty::ty_int(_)   |\n+            ty::ty_uint(_)  |\n             ty::ty_float(_) => {\n-                unique_type_id.push_str(ppaux::ty_to_str(cx.tcx(), type_).as_slice());\n+                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n             ty::ty_enum(def_id, ref substs) => {\n                 unique_type_id.push_str(\"enum \");\n@@ -587,7 +594,7 @@ impl TypeMap {\n                                           element_type: ty::t)\n                                        -> UniqueTypeId {\n         let element_type_id = self.get_unique_type_id_of_type(cx, element_type);\n-        let heap_vec_box_type_id = format!(\"$$HEAP_VEC_BOX<{}>$$\",\n+        let heap_vec_box_type_id = format!(\"{{HEAP_VEC_BOX<{}>}}\",\n                                            self.get_unique_type_id_as_string(element_type_id)\n                                                .as_slice());\n         let interner_key = self.unique_id_interner.intern(Rc::new(heap_vec_box_type_id));\n@@ -599,14 +606,27 @@ impl TypeMap {\n                                     element_type: ty::t)\n                                  -> UniqueTypeId {\n         let element_type_id = self.get_unique_type_id_of_type(cx, element_type);\n-        let gc_box_type_id = format!(\"$$GC_BOX<{}>$$\",\n+        let gc_box_type_id = format!(\"{{GC_BOX<{}>}}\",\n                                      self.get_unique_type_id_as_string(element_type_id)\n                                          .as_slice());\n         let interner_key = self.unique_id_interner.intern(Rc::new(gc_box_type_id));\n         UniqueTypeId(interner_key)\n     }\n }\n \n+// Returns from the enclosing function if the type metadata with the given\n+// unique id can be found in the type map\n+macro_rules! return_if_metadata_created_in_meantime(\n+    ($cx: expr, $unique_type_id: expr) => (\n+        match debug_context($cx).type_map\n+                                .borrow()\n+                                .find_metadata_for_unique_id($unique_type_id) {\n+            Some(metadata) => return MetadataCreationResult::new(metadata, true),\n+            None => { /* proceed normally */ }\n+        };\n+    )\n+)\n+\n \n /// A context object for maintaining all state needed by the debuginfo module.\n pub struct CrateDebugContext {\n@@ -1304,9 +1324,12 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         if has_self_type {\n             let actual_self_type = self_type.unwrap();\n             // Add self type name to <...> clause of function name\n-            let actual_self_type_name = ppaux::ty_to_str(cx.tcx(), actual_self_type);\n-            name_to_append_suffix_to.push_str(\n-                actual_self_type_name.as_slice());\n+            let actual_self_type_name = compute_debuginfo_type_name(\n+                cx,\n+                actual_self_type,\n+                true);\n+\n+            name_to_append_suffix_to.push_str(actual_self_type_name.as_slice());\n \n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1343,7 +1366,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         for (index, &ast::TyParam{ ident: ident, .. }) in generics.ty_params.iter().enumerate() {\n             let actual_type = *actual_types.get(index);\n             // Add actual type name to <...> clause of function name\n-            let actual_type_name = ppaux::ty_to_str(cx.tcx(), actual_type);\n+            let actual_type_name = compute_debuginfo_type_name(cx,\n+                                                               actual_type,\n+                                                               true);\n             name_to_append_suffix_to.push_str(actual_type_name.as_slice());\n \n             if index != generics.ty_params.len() - 1 {\n@@ -1646,7 +1671,7 @@ fn pointer_type_metadata(cx: &CrateContext,\n                       -> DIType {\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n-    let name = ppaux::ty_to_str(cx.tcx(), pointer_type);\n+    let name = compute_debuginfo_type_name(cx, pointer_type, false);\n     let ptr_metadata = name.as_slice().with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n@@ -1719,7 +1744,6 @@ enum RecursiveTypeDescription {\n         unique_type_id: UniqueTypeId,\n         metadata_stub: DICompositeType,\n         llvm_type: Type,\n-        file_metadata: DIFile,\n         member_description_factory: MemberDescriptionFactory,\n     },\n     FinalMetadata(DICompositeType)\n@@ -1731,7 +1755,6 @@ fn create_and_register_recursive_type_forward_declaration(\n     unique_type_id: UniqueTypeId,\n     metadata_stub: DICompositeType,\n     llvm_type: Type,\n-    file_metadata: DIFile,\n     member_description_factory: MemberDescriptionFactory)\n  -> RecursiveTypeDescription {\n \n@@ -1745,7 +1768,6 @@ fn create_and_register_recursive_type_forward_declaration(\n         unique_type_id: unique_type_id,\n         metadata_stub: metadata_stub,\n         llvm_type: llvm_type,\n-        file_metadata: file_metadata,\n         member_description_factory: member_description_factory,\n     }\n }\n@@ -1761,8 +1783,8 @@ impl RecursiveTypeDescription {\n                 unique_type_id,\n                 metadata_stub,\n                 llvm_type,\n-                file_metadata,\n-                ref member_description_factory\n+                ref member_description_factory,\n+                ..\n             } => {\n                 // Make sure that we have a forward declaration of the type in\n                 // the TypeMap so that recursive references are possible. This\n@@ -1788,9 +1810,7 @@ impl RecursiveTypeDescription {\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n                                               llvm_type,\n-                                              member_descriptions.as_slice(),\n-                                              file_metadata,\n-                                              codemap::DUMMY_SP);\n+                                              member_descriptions.as_slice());\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n@@ -1845,28 +1865,24 @@ impl StructMemberDescriptionFactory {\n     }\n }\n \n+\n fn prepare_struct_metadata(cx: &CrateContext,\n                            struct_type: ty::t,\n                            def_id: ast::DefId,\n                            substs: &subst::Substs,\n                            unique_type_id: UniqueTypeId,\n                            span: Span)\n                         -> RecursiveTypeDescription {\n-    let struct_name = ppaux::ty_to_str(cx.tcx(), struct_type);\n+    let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n-    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n-\n-    let file_name = span_start(cx, definition_span).file.name.clone();\n-    let file_metadata = file_metadata(cx, file_name.as_slice());\n+    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n                                                   struct_name.as_slice(),\n                                                   unique_type_id,\n-                                                  containing_scope,\n-                                                  file_metadata,\n-                                                  definition_span);\n+                                                  containing_scope);\n \n     let fields = ty::struct_fields(cx.tcx(), def_id, substs);\n \n@@ -1876,7 +1892,6 @@ fn prepare_struct_metadata(cx: &CrateContext,\n         unique_type_id,\n         struct_metadata_stub,\n         struct_llvm_type,\n-        file_metadata,\n         StructMDF(StructMemberDescriptionFactory {\n             fields: fields,\n             is_simd: ty::type_is_simd(cx.tcx(), struct_type),\n@@ -1916,12 +1931,9 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n                           unique_type_id: UniqueTypeId,\n                           span: Span)\n                        -> RecursiveTypeDescription {\n-    let tuple_name = ppaux::ty_to_str(cx.tcx(), tuple_type);\n+    let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n-\n     create_and_register_recursive_type_forward_declaration(\n         cx,\n         tuple_type,\n@@ -1930,11 +1942,8 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n                            tuple_llvm_type,\n                            tuple_name.as_slice(),\n                            unique_type_id,\n-                           file_metadata,\n-                           file_metadata,\n-                           span),\n+                           UNKNOWN_SCOPE_METADATA),\n         tuple_llvm_type,\n-        file_metadata,\n         TupleMDF(TupleMemberDescriptionFactory {\n             component_types: Vec::from_slice(component_types),\n             span: span,\n@@ -1982,7 +1991,6 @@ impl EnumMemberDescriptionFactory {\n                                                   &**self.variants.get(i),\n                                                   discriminant_info,\n                                                   self.containing_scope,\n-                                                  self.file_metadata,\n                                                   self.span);\n \n                         let member_descriptions = member_desc_factory\n@@ -1991,9 +1999,7 @@ impl EnumMemberDescriptionFactory {\n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n                                                       variant_llvm_type,\n-                                                      member_descriptions.as_slice(),\n-                                                      self.file_metadata,\n-                                                      codemap::DUMMY_SP);\n+                                                      member_descriptions.as_slice());\n                         MemberDescription {\n                             name: \"\".to_string(),\n                             llvm_type: variant_llvm_type,\n@@ -2017,7 +2023,6 @@ impl EnumMemberDescriptionFactory {\n                                               &**self.variants.get(0),\n                                               NoDiscriminant,\n                                               self.containing_scope,\n-                                              self.file_metadata,\n                                               self.span);\n \n                     let member_descriptions =\n@@ -2026,9 +2031,7 @@ impl EnumMemberDescriptionFactory {\n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n                                                   variant_llvm_type,\n-                                                  member_descriptions.as_slice(),\n-                                                  self.file_metadata,\n-                                                  codemap::DUMMY_SP);\n+                                                  member_descriptions.as_slice());\n                     vec![\n                         MemberDescription {\n                             name: \"\".to_string(),\n@@ -2119,7 +2122,6 @@ impl EnumMemberDescriptionFactory {\n                                           &**self.variants.get(nndiscr as uint),\n                                           OptimizedDiscriminant(ptrfield),\n                                           self.containing_scope,\n-                                          self.file_metadata,\n                                           self.span);\n \n                 let variant_member_descriptions =\n@@ -2128,9 +2130,7 @@ impl EnumMemberDescriptionFactory {\n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              variant_member_descriptions.as_slice(),\n-                                              self.file_metadata,\n-                                              codemap::DUMMY_SP);\n+                                              variant_member_descriptions.as_slice());\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n@@ -2195,7 +2195,6 @@ fn describe_enum_variant(cx: &CrateContext,\n                          variant_info: &ty::VariantInfo,\n                          discriminant_info: EnumDiscriminantInfo,\n                          containing_scope: DIScope,\n-                         file_metadata: DIFile,\n                          span: Span)\n                       -> (DICompositeType, Type, MemberDescriptionFactory) {\n     let variant_llvm_type =\n@@ -2207,14 +2206,6 @@ fn describe_enum_variant(cx: &CrateContext,\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n-    // Find the source code location of the variant's definition\n-    let variant_definition_span = if variant_info.id.krate == ast::LOCAL_CRATE {\n-        cx.tcx.map.span(variant_info.id.node)\n-    } else {\n-        // For definitions from other crates we have no location information available.\n-        codemap::DUMMY_SP\n-    };\n-\n     let variant_name = token::get_ident(variant_info.name);\n     let variant_name = variant_name.get();\n     let unique_type_id = debug_context(cx).type_map\n@@ -2228,9 +2219,7 @@ fn describe_enum_variant(cx: &CrateContext,\n                                            variant_llvm_type,\n                                            variant_name,\n                                            unique_type_id,\n-                                           containing_scope,\n-                                           file_metadata,\n-                                           variant_definition_span);\n+                                           containing_scope);\n \n     // Get the argument names from the enum variant info\n     let mut arg_names: Vec<_> = match variant_info.arg_names {\n@@ -2276,7 +2265,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                          unique_type_id: UniqueTypeId,\n                          span: Span)\n                       -> RecursiveTypeDescription {\n-    let enum_name = ppaux::ty_to_str(cx.tcx(), enum_type);\n+    let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n@@ -2323,8 +2312,8 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                             DIB(cx),\n                             containing_scope,\n                             name,\n-                            file_metadata,\n-                            loc.line as c_uint,\n+                            UNKNOWN_FILE_METADATA,\n+                            UNKNOWN_LINE_NUMBER,\n                             bytes_to_bits(discriminant_size),\n                             bytes_to_bits(discriminant_align),\n                             create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n@@ -2368,8 +2357,8 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 DIB(cx),\n                 containing_scope,\n                 enum_name,\n-                file_metadata,\n-                loc.line as c_uint,\n+                UNKNOWN_FILE_METADATA,\n+                UNKNOWN_LINE_NUMBER,\n                 bytes_to_bits(enum_type_size),\n                 bytes_to_bits(enum_type_align),\n                 0, // Flags\n@@ -2386,7 +2375,6 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         unique_type_id,\n         enum_metadata,\n         enum_llvm_type,\n-        file_metadata,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type: enum_type,\n             type_rep: type_rep.clone(),\n@@ -2421,34 +2409,31 @@ fn composite_type_metadata(cx: &CrateContext,\n                            composite_type_unique_id: UniqueTypeId,\n                            member_descriptions: &[MemberDescription],\n                            containing_scope: DIScope,\n-                           file_metadata: DIFile,\n-                           definition_span: Span)\n+\n+                           // Ignore source location information as long as it\n+                           // can't be reconstructed for non-local crates.\n+                           _file_metadata: DIFile,\n+                           _definition_span: Span)\n                         -> DICompositeType {\n     // Create the (empty) struct metadata node ...\n     let composite_type_metadata = create_struct_stub(cx,\n                                                      composite_llvm_type,\n                                                      composite_type_name,\n                                                      composite_type_unique_id,\n-                                                     containing_scope,\n-                                                     file_metadata,\n-                                                     definition_span);\n+                                                     containing_scope);\n     // ... and immediately create and add the member descriptions.\n     set_members_of_composite_type(cx,\n                                   composite_type_metadata,\n                                   composite_llvm_type,\n-                                  member_descriptions,\n-                                  file_metadata,\n-                                  definition_span);\n+                                  member_descriptions);\n \n     return composite_type_metadata;\n }\n \n fn set_members_of_composite_type(cx: &CrateContext,\n                                  composite_type_metadata: DICompositeType,\n                                  composite_llvm_type: Type,\n-                                 member_descriptions: &[MemberDescription],\n-                                 file_metadata: DIFile,\n-                                 definition_span: Span) {\n+                                 member_descriptions: &[MemberDescription]) {\n     // In some rare cases LLVM metadata uniquing would lead to an existing type\n     // description being used instead of a new one created in create_struct_stub.\n     // This would cause a hard to trace assertion in DICompositeType::SetTypeArray().\n@@ -2483,8 +2468,6 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         }\n     }\n \n-    let loc = span_start(cx, definition_span);\n-\n     let member_metadata: Vec<DIDescriptor> = member_descriptions\n         .iter()\n         .enumerate()\n@@ -2501,8 +2484,8 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                         DIB(cx),\n                         composite_type_metadata,\n                         member_name,\n-                        file_metadata,\n-                        loc.line as c_uint,\n+                        UNKNOWN_FILE_METADATA,\n+                        UNKNOWN_LINE_NUMBER,\n                         bytes_to_bits(member_size),\n                         bytes_to_bits(member_align),\n                         bytes_to_bits(member_offset),\n@@ -2526,11 +2509,8 @@ fn create_struct_stub(cx: &CrateContext,\n                       struct_llvm_type: Type,\n                       struct_type_name: &str,\n                       unique_type_id: UniqueTypeId,\n-                      containing_scope: DIScope,\n-                      file_metadata: DIFile,\n-                      definition_span: Span)\n+                      containing_scope: DIScope)\n                    -> DICompositeType {\n-    let loc = span_start(cx, definition_span);\n     let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n \n     let unique_type_id_str = debug_context(cx).type_map\n@@ -2548,8 +2528,8 @@ fn create_struct_stub(cx: &CrateContext,\n                     DIB(cx),\n                     containing_scope,\n                     name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n+                    UNKNOWN_FILE_METADATA,\n+                    UNKNOWN_LINE_NUMBER,\n                     bytes_to_bits(struct_size),\n                     bytes_to_bits(struct_align),\n                     0,\n@@ -2572,12 +2552,9 @@ fn at_box_metadata(cx: &CrateContext,\n                 -> MetadataCreationResult {\n     let content_type_metadata = type_metadata(cx, content_type, codemap::DUMMY_SP);\n \n-    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n-        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n-        None => { /* proceed */ }\n-    };\n+    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n-    let content_type_name = ppaux::ty_to_str(cx.tcx(), content_type);\n+    let content_type_name = compute_debuginfo_type_name(cx, content_type, true);\n     let content_type_name = content_type_name.as_slice();\n     let content_llvm_type = type_of::type_of(cx, content_type);\n \n@@ -2593,7 +2570,6 @@ fn at_box_metadata(cx: &CrateContext,\n     let nil_pointer_type_metadata = type_metadata(cx,\n                                                   nil_pointer_type,\n                                                   codemap::DUMMY_SP);\n-\n     let member_descriptions = [\n         MemberDescription {\n             name: \"refcnt\".to_string(),\n@@ -2627,9 +2603,6 @@ fn at_box_metadata(cx: &CrateContext,\n         }\n     ];\n \n-    let loc = span_start(cx, codemap::DUMMY_SP);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n-\n     let gc_box_unique_id = debug_context(cx).type_map\n                                             .borrow_mut()\n                                             .get_unique_type_id_of_gc_box(cx, content_type);\n@@ -2640,8 +2613,8 @@ fn at_box_metadata(cx: &CrateContext,\n         box_type_name.as_slice(),\n         gc_box_unique_id,\n         member_descriptions,\n-        file_metadata,\n-        file_metadata,\n+        UNKNOWN_SCOPE_METADATA,\n+        UNKNOWN_FILE_METADATA,\n         codemap::DUMMY_SP);\n \n     let gc_pointer_metadata = pointer_type_metadata(cx,\n@@ -2674,10 +2647,7 @@ fn fixed_vec_metadata(cx: &CrateContext,\n                    -> MetadataCreationResult {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n \n-    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n-        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n-        None => { /* proceed */ }\n-    };\n+    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_type_size, element_type_align) = size_and_align_of(cx, element_llvm_type);\n@@ -2712,13 +2682,12 @@ fn heap_vec_metadata(cx: &CrateContext,\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n-    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n-        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n-        None => { /* proceed */ }\n-    };\n+    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n     let vecbox_llvm_type = Type::vec(cx, &element_llvm_type);\n-    let vec_pointer_type_name = ppaux::ty_to_str(cx.tcx(), vec_pointer_type);\n+    let vec_pointer_type_name = compute_debuginfo_type_name(cx,\n+                                                            vec_pointer_type,\n+                                                            true);\n     let vec_pointer_type_name = vec_pointer_type_name.as_slice();\n \n     let member_llvm_types = vecbox_llvm_type.field_types();\n@@ -2769,7 +2738,7 @@ fn heap_vec_metadata(cx: &CrateContext,\n                                                   vec_pointer_type_name,\n                                                   vec_box_unique_id,\n                                                   member_descriptions,\n-                                                  file_metadata,\n+                                                  UNKNOWN_SCOPE_METADATA,\n                                                   file_metadata,\n                                                   span);\n \n@@ -2791,13 +2760,10 @@ fn vec_slice_metadata(cx: &CrateContext,\n \n     let element_type_metadata = type_metadata(cx, data_ptr_type, span);\n \n-    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n-        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n-        None => { /* proceed */ }\n-    };\n+    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n-    let slice_type_name = ppaux::ty_to_str(cx.tcx(), vec_type);\n+    let slice_type_name = compute_debuginfo_type_name(cx, vec_type, true);\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx,\n@@ -2828,7 +2794,7 @@ fn vec_slice_metadata(cx: &CrateContext,\n                                            slice_type_name.as_slice(),\n                                            unique_type_id,\n                                            member_descriptions,\n-                                           file_metadata,\n+                                           UNKNOWN_SCOPE_METADATA,\n                                            file_metadata,\n                                            span);\n     return MetadataCreationResult::new(metadata, false);\n@@ -2848,8 +2814,6 @@ fn subroutine_type_metadata(cx: &CrateContext,\n                             signature: &ty::FnSig,\n                             span: Span)\n                          -> MetadataCreationResult {\n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n@@ -2863,57 +2827,64 @@ fn subroutine_type_metadata(cx: &CrateContext,\n         signature_metadata.push(type_metadata(cx, argument_type, span));\n     }\n \n-    match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n-        Some(metadata) => return MetadataCreationResult::new(metadata, true),\n-        None => { /* proceed */ }\n-    };\n+    return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n     return MetadataCreationResult::new(\n         unsafe {\n             llvm::LLVMDIBuilderCreateSubroutineType(\n                 DIB(cx),\n-                file_metadata,\n+                UNKNOWN_FILE_METADATA,\n                 create_DIArray(DIB(cx), signature_metadata.as_slice()))\n         },\n         false);\n }\n \n-fn trait_metadata(cx: &CrateContext,\n-                  def_id: ast::DefId,\n-                  trait_type: ty::t,\n-                  substs: &subst::Substs,\n-                  trait_store: ty::TraitStore,\n-                  _: &ty::BuiltinBounds,\n-                  unique_type_id: UniqueTypeId)\n-               -> DIType {\n+fn trait_pointer_metadata(cx: &CrateContext,\n+                          // trait_pointer_type must be the type of the fat\n+                          // pointer to the concrete trait object\n+                          trait_pointer_type: ty::t,\n+                          unique_type_id: UniqueTypeId)\n+                       -> DIType {\n     // The implementation provided here is a stub. It makes sure that the trait\n     // type is assigned the correct name, size, namespace, and source location.\n     // But it does not describe the trait's methods.\n-    let last = ty::with_path(cx.tcx(), def_id, |mut path| path.last().unwrap());\n-    let ident_string = token::get_name(last.name());\n-    let mut name = ppaux::trait_store_to_str(cx.tcx(), trait_store);\n-    name.push_str(ident_string.get());\n \n-    // Add type and region parameters\n-    let trait_def = ty::lookup_trait_def(cx.tcx(), def_id);\n-    let name = ppaux::parameterized(cx.tcx(), name.as_slice(),\n-                                    substs, &trait_def.generics);\n+    let trait_object_type = match ty::get(trait_pointer_type).sty {\n+        ty::ty_uniq(pointee_type) => pointee_type,\n+        ty::ty_rptr(_, ty::mt { ty, .. }) => ty,\n+        _ => {\n+            let pp_type_name = ppaux::ty_to_str(cx.tcx(), trait_pointer_type);\n+            cx.sess().bug(format!(\"debuginfo: Unexpected trait-pointer type in \\\n+                                   trait_pointer_metadata(): {}\",\n+                                   pp_type_name.as_slice()).as_slice());\n+        }\n+    };\n+\n+    let def_id = match ty::get(trait_object_type).sty {\n+        ty::ty_trait(box ty::TyTrait { def_id, .. }) => def_id,\n+        _ => {\n+            let pp_type_name = ppaux::ty_to_str(cx.tcx(), trait_object_type);\n+            cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n+                                   trait_pointer_metadata(): {}\",\n+                                   pp_type_name.as_slice()).as_slice());\n+        }\n+    };\n \n-    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n+    let trait_pointer_type_name =\n+        compute_debuginfo_type_name(cx, trait_pointer_type, false);\n \n-    let file_name = span_start(cx, definition_span).file.name.clone();\n-    let file_metadata = file_metadata(cx, file_name.as_slice());\n+    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n \n-    let trait_llvm_type = type_of::type_of(cx, trait_type);\n+    let trait_pointer_llvm_type = type_of::type_of(cx, trait_pointer_type);\n \n     composite_type_metadata(cx,\n-                            trait_llvm_type,\n-                            name.as_slice(),\n+                            trait_pointer_llvm_type,\n+                            trait_pointer_type_name.as_slice(),\n                             unique_type_id,\n                             [],\n                             containing_scope,\n-                            file_metadata,\n-                            definition_span)\n+                            UNKNOWN_FILE_METADATA,\n+                            codemap::DUMMY_SP)\n }\n \n fn type_metadata(cx: &CrateContext,\n@@ -2955,15 +2926,6 @@ fn type_metadata(cx: &CrateContext,\n \n     debug!(\"type_metadata: {:?}\", ty::get(t));\n \n-    macro_rules! return_if_created_in_meantime(\n-        () => (\n-            match debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id) {\n-                Some(metadata) => return metadata,\n-                None => { /* proceed normally */ }\n-            };\n-        )\n-    )\n-\n     let sty = &ty::get(t).sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n         ty::ty_nil      |\n@@ -2993,19 +2955,22 @@ fn type_metadata(cx: &CrateContext,\n                     let i8_t = ty::mk_i8();\n                     heap_vec_metadata(cx, pointee_type, i8_t, unique_type_id, usage_site_span)\n                 }\n-                ty::ty_trait(box ty::TyTrait {\n-                        def_id,\n-                        ref substs,\n-                        ref bounds\n-                    }) => {\n+                ty::ty_trait(..) => {\n                     MetadataCreationResult::new(\n-                        trait_metadata(cx, def_id, t, substs, ty::UniqTraitStore,\n-                                       bounds, unique_type_id),\n-                    false)\n+                        trait_pointer_metadata(cx, t, unique_type_id),\n+                        false)\n                 }\n                 _ => {\n-                    let pointee_metadata = type_metadata(cx, pointee_type, usage_site_span);\n-                    return_if_created_in_meantime!();\n+                    let pointee_metadata = type_metadata(cx,\n+                                                         pointee_type,\n+                                                         usage_site_span);\n+                    match debug_context(cx).type_map\n+                                           .borrow()\n+                                           .find_metadata_for_unique_id(unique_type_id) {\n+                        Some(metadata) => return metadata,\n+                        None => { /* proceed normally */ }\n+                    };\n+\n                     MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee_metadata),\n                                                 false)\n                 }\n@@ -3017,22 +2982,23 @@ fn type_metadata(cx: &CrateContext,\n                     vec_slice_metadata(cx, t, mt.ty, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_str => {\n-                    vec_slice_metadata(cx, t, ty::mk_i8(), unique_type_id, usage_site_span)\n+                    vec_slice_metadata(cx, t, ty::mk_u8(), unique_type_id, usage_site_span)\n                 }\n-                ty::ty_trait(box ty::TyTrait {\n-                        def_id,\n-                        ref substs,\n-                        ref bounds\n-                    }) => {\n+                ty::ty_trait(..) => {\n                     MetadataCreationResult::new(\n-                        trait_metadata(cx, def_id, t, substs,\n-                                       ty::RegionTraitStore(ty::ReStatic, mt.mutbl),\n-                                       bounds, unique_type_id),\n-                    false)\n+                        trait_pointer_metadata(cx, t, unique_type_id),\n+                        false)\n                 }\n                 _ => {\n                     let pointee = type_metadata(cx, mt.ty, usage_site_span);\n-                    return_if_created_in_meantime!();\n+\n+                    match debug_context(cx).type_map\n+                                           .borrow()\n+                                           .find_metadata_for_unique_id(unique_type_id) {\n+                        Some(metadata) => return metadata,\n+                        None => { /* proceed normally */ }\n+                    };\n+\n                     MetadataCreationResult::new(pointer_type_metadata(cx, t, pointee), false)\n                 }\n             }\n@@ -3150,7 +3116,8 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n \n     match debug_location {\n         KnownLocation { scope, line, .. } => {\n-            let col = 0u; // Always set the column to zero like Clang and GCC\n+            // Always set the column to zero like Clang and GCC\n+            let col = UNKNOWN_COLUMN_NUMBER;\n             debug!(\"setting debug location to {} {}\", line, col);\n             let elements = [C_i32(cx, line as i32), C_i32(cx, col as i32),\n                             scope, ptr::mut_null()];\n@@ -3700,6 +3667,265 @@ fn populate_scope_map(cx: &CrateContext,\n }\n \n \n+//=-----------------------------------------------------------------------------\n+// Type Names for Debug Info\n+//=-----------------------------------------------------------------------------\n+\n+// Compute the name of the type as it should be stored in debuginfo. Does not do\n+// any caching, i.e. calling the function twice with the same type will also do\n+// the work twice. The `qualified` parameter only affects the first level of the\n+// type name, further levels (i.e. type parameters) are always fully qualified.\n+fn compute_debuginfo_type_name(cx: &CrateContext,\n+                               t: ty::t,\n+                               qualified: bool)\n+                            -> String {\n+    let mut result = String::with_capacity(64);\n+    push_debuginfo_type_name(cx, t, qualified, &mut result);\n+    result\n+}\n+\n+// Pushes the name of the type as it should be stored in debuginfo on the\n+// `output` String. See also compute_debuginfo_type_name().\n+fn push_debuginfo_type_name(cx: &CrateContext,\n+                            t: ty::t,\n+                            qualified: bool,\n+                            output:&mut String) {\n+    match ty::get(t).sty {\n+        ty::ty_nil               => output.push_str(\"()\"),\n+        ty::ty_bot               => output.push_str(\"!\"),\n+        ty::ty_bool              => output.push_str(\"bool\"),\n+        ty::ty_char              => output.push_str(\"char\"),\n+        ty::ty_str               => output.push_str(\"str\"),\n+        ty::ty_int(ast::TyI)     => output.push_str(\"int\"),\n+        ty::ty_int(ast::TyI8)    => output.push_str(\"i8\"),\n+        ty::ty_int(ast::TyI16)   => output.push_str(\"i16\"),\n+        ty::ty_int(ast::TyI32)   => output.push_str(\"i32\"),\n+        ty::ty_int(ast::TyI64)   => output.push_str(\"i64\"),\n+        ty::ty_uint(ast::TyU)    => output.push_str(\"uint\"),\n+        ty::ty_uint(ast::TyU8)   => output.push_str(\"u8\"),\n+        ty::ty_uint(ast::TyU16)  => output.push_str(\"u16\"),\n+        ty::ty_uint(ast::TyU32)  => output.push_str(\"u32\"),\n+        ty::ty_uint(ast::TyU64)  => output.push_str(\"u64\"),\n+        ty::ty_float(ast::TyF32) => output.push_str(\"f32\"),\n+        ty::ty_float(ast::TyF64) => output.push_str(\"f64\"),\n+        ty::ty_struct(def_id, ref substs) |\n+        ty::ty_enum(def_id, ref substs) => {\n+            push_item_name(cx, def_id, qualified, output);\n+            push_type_params(cx, substs, output);\n+        },\n+        ty::ty_tup(ref component_types) => {\n+            output.push_char('(');\n+            for &component_type in component_types.iter() {\n+                push_debuginfo_type_name(cx, component_type, true, output);\n+                output.push_str(\", \");\n+            }\n+            output.pop_char();\n+            output.pop_char();\n+            output.push_char(')');\n+        },\n+        ty::ty_uniq(inner_type) => {\n+            output.push_str(\"Box<\");\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+            output.push_char('>');\n+        },\n+        ty::ty_box(inner_type) => {\n+            output.push_char('@');\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n+            output.push_char('*');\n+            match mutbl {\n+                ast::MutImmutable => output.push_str(\"const \"),\n+                ast::MutMutable => output.push_str(\"mut \"),\n+            }\n+\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n+            output.push_char('&');\n+            if mutbl == ast::MutMutable {\n+                output.push_str(\"mut \");\n+            }\n+\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_vec(ty::mt { ty: inner_type, .. }, optional_length) => {\n+            output.push_char('[');\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+\n+            match optional_length {\n+                Some(len) => {\n+                    output.push_str(format!(\", ..{}\", len).as_slice());\n+                }\n+                None => { /* nothing to do */ }\n+            };\n+\n+            output.push_char(']');\n+        },\n+        ty::ty_trait(ref trait_data) => {\n+            push_item_name(cx, trait_data.def_id, false, output);\n+            push_type_params(cx, &trait_data.substs, output);\n+        },\n+        ty::ty_bare_fn(ty::BareFnTy{ fn_style, abi, ref sig } ) => {\n+            if fn_style == ast::UnsafeFn {\n+                output.push_str(\"unsafe \");\n+            }\n+\n+            if abi != ::syntax::abi::Rust {\n+                output.push_str(\"extern \\\"\");\n+                output.push_str(abi.name());\n+                output.push_str(\"\\\" \");\n+            }\n+\n+            output.push_str(\"fn(\");\n+\n+            if sig.inputs.len() > 0 {\n+                for &parameter_type in sig.inputs.iter() {\n+                    push_debuginfo_type_name(cx, parameter_type, true, output);\n+                    output.push_str(\", \");\n+                }\n+                output.pop_char();\n+                output.pop_char();\n+            }\n+\n+            if sig.variadic {\n+                if sig.inputs.len() > 0 {\n+                    output.push_str(\", ...\");\n+                } else {\n+                    output.push_str(\"...\");\n+                }\n+            }\n+\n+            output.push_char(')');\n+\n+            if !ty::type_is_nil(sig.output) {\n+                output.push_str(\" -> \");\n+                push_debuginfo_type_name(cx, sig.output, true, output);\n+            }\n+        },\n+        ty::ty_closure(box ty::ClosureTy { fn_style,\n+                                           onceness,\n+                                           store,\n+                                           ref sig,\n+                                           .. // omitting bounds ...\n+                                           }) => {\n+            if fn_style == ast::UnsafeFn {\n+                output.push_str(\"unsafe \");\n+            }\n+\n+            if onceness == ast::Once {\n+                output.push_str(\"once \");\n+            }\n+\n+            let param_list_closing_char;\n+            match store {\n+                ty::UniqTraitStore => {\n+                    output.push_str(\"proc(\");\n+                    param_list_closing_char = ')';\n+                }\n+                ty::RegionTraitStore(_, ast::MutMutable) => {\n+                    output.push_str(\"&mut|\");\n+                    param_list_closing_char = '|';\n+                }\n+                ty::RegionTraitStore(_, ast::MutImmutable) => {\n+                    output.push_str(\"&|\");\n+                    param_list_closing_char = '|';\n+                }\n+            };\n+\n+            if sig.inputs.len() > 0 {\n+                for &parameter_type in sig.inputs.iter() {\n+                    push_debuginfo_type_name(cx, parameter_type, true, output);\n+                    output.push_str(\", \");\n+                }\n+                output.pop_char();\n+                output.pop_char();\n+            }\n+\n+            if sig.variadic {\n+                if sig.inputs.len() > 0 {\n+                    output.push_str(\", ...\");\n+                } else {\n+                    output.push_str(\"...\");\n+                }\n+            }\n+\n+            output.push_char(param_list_closing_char);\n+\n+            if !ty::type_is_nil(sig.output) {\n+                output.push_str(\" -> \");\n+                push_debuginfo_type_name(cx, sig.output, true, output);\n+            }\n+        },\n+        ty::ty_err      |\n+        ty::ty_infer(_) |\n+        ty::ty_param(_) => {\n+            cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n+                unexpected type: {}\", ppaux::ty_to_str(cx.tcx(), t)).as_slice());\n+        }\n+    }\n+\n+    fn push_item_name(cx: &CrateContext,\n+                      def_id: ast::DefId,\n+                      qualified: bool,\n+                      output: &mut String) {\n+        ty::with_path(cx.tcx(), def_id, |mut path| {\n+            if qualified {\n+                if def_id.krate == ast::LOCAL_CRATE {\n+                    output.push_str(crate_root_namespace(cx));\n+                    output.push_str(\"::\");\n+                }\n+\n+                let mut path_element_count = 0u;\n+                for path_element in path {\n+                    let name = token::get_name(path_element.name());\n+                    output.push_str(name.get());\n+                    output.push_str(\"::\");\n+                    path_element_count += 1;\n+                }\n+\n+                if path_element_count == 0 {\n+                    cx.sess().bug(\"debuginfo: Encountered empty item path!\");\n+                }\n+\n+                output.pop_char();\n+                output.pop_char();\n+            } else {\n+                let name = token::get_name(path.last()\n+                                               .expect(\"debuginfo: Empty item path?\")\n+                                               .name());\n+                output.push_str(name.get());\n+            }\n+        });\n+    }\n+\n+    // Pushes the type parameters in the given `Substs` to the output string.\n+    // This ignores region parameters, since they can't reliably be\n+    // reconstructed for items from non-local crates. For local crates, this\n+    // would be possible but with inlining and LTO we have to use the least\n+    // common denominator - otherwise we would run into conflicts.\n+    fn push_type_params(cx: &CrateContext,\n+                        substs: &subst::Substs,\n+                        output: &mut String) {\n+        if substs.types.is_empty() {\n+            return;\n+        }\n+\n+        output.push_char('<');\n+\n+        for &type_parameter in substs.types.iter() {\n+            push_debuginfo_type_name(cx, type_parameter, true, output);\n+            output.push_str(\", \");\n+        }\n+\n+        output.pop_char();\n+        output.pop_char();\n+\n+        output.push_char('>');\n+    }\n+}\n+\n+\n //=-----------------------------------------------------------------------------\n // Namespace Handling\n //=-----------------------------------------------------------------------------\n@@ -3731,14 +3957,15 @@ impl NamespaceTreeNode {\n     }\n }\n \n+fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n+    cx.link_meta.crateid.name.as_slice()\n+}\n+\n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n     ty::with_path(cx.tcx(), def_id, |path| {\n         // prepend crate name if not already present\n         let krate = if def_id.krate == ast::LOCAL_CRATE {\n-            let crate_namespace_ident = token::str_to_ident(cx.link_meta\n-                                                              .crateid\n-                                                              .name\n-                                                              .as_slice());\n+            let crate_namespace_ident = token::str_to_ident(crate_root_namespace(cx));\n             Some(ast_map::PathMod(crate_namespace_ident.name))\n         } else {\n             None"}, {"sha": "ac5fe8302752726b97a82eb222c69fd02053eff2", "filename": "src/test/debuginfo/type-names.rs", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/40e05413096bbd5f35e566e796f525742076600f/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40e05413096bbd5f35e566e796f525742076600f/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=40e05413096bbd5f35e566e796f525742076600f", "patch": "@@ -0,0 +1,333 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// ignore-lldb\n+// ignore-android: FIXME(#10381)\n+\n+// compile-flags:-g\n+// gdb-command:rbreak zzz\n+// gdb-command:run\n+// gdb-command:finish\n+\n+\n+// STRUCTS\n+// gdb-command:whatis simple_struct\n+// gdb-check:type = struct Struct1\n+\n+// gdb-command:whatis generic_struct1\n+// gdb-check:type = struct GenericStruct<type-names::Mod1::Struct2, type-names::Mod1::Mod2::Struct3>\n+\n+// gdb-command:whatis generic_struct2\n+// gdb-check:type = struct GenericStruct<type-names::Struct1, extern \"fastcall\" fn(int) -> uint>\n+\n+// gdb-command:whatis mod_struct\n+// gdb-check:type = struct Struct2\n+\n+\n+// ENUMS\n+// gdb-command:whatis simple_enum_1\n+// gdb-check:type = union Enum1\n+\n+// gdb-command:whatis simple_enum_2\n+// gdb-check:type = union Enum1\n+\n+// gdb-command:whatis simple_enum_3\n+// gdb-check:type = union Enum2\n+\n+// gdb-command:whatis generic_enum_1\n+// gdb-check:type = union Enum3<type-names::Mod1::Struct2>\n+\n+// gdb-command:whatis generic_enum_2\n+// gdb-check:type = union Enum3<type-names::Struct1>\n+\n+\n+// TUPLES\n+// gdb-command:whatis tuple1\n+// gdb-check:type = struct (u32, type-names::Struct1, type-names::Mod1::Mod2::Enum3<type-names::Mod1::Struct2>)\n+\n+// gdb-command:whatis tuple2\n+// gdb-check:type = struct ((type-names::Struct1, type-names::Mod1::Mod2::Struct3), type-names::Mod1::Enum2, char)\n+\n+\n+// BOX\n+// gdb-command:whatis box1\n+// gdb-check:type = struct (Box<f32>, i32)\n+\n+// gdb-command:whatis box2\n+// gdb-check:type = struct (Box<type-names::Mod1::Mod2::Enum3<f32>>, i32)\n+\n+\n+// REFERENCES\n+// gdb-command:whatis ref1\n+// gdb-check:type = struct (&type-names::Struct1, i32)\n+\n+// gdb-command:whatis ref2\n+// gdb-check:type = struct (&type-names::GenericStruct<char, type-names::Struct1>, i32)\n+\n+// gdb-command:whatis mut_ref1\n+// gdb-check:type = struct (&mut type-names::Struct1, i32)\n+\n+// gdb-command:whatis mut_ref2\n+// gdb-check:type = struct (&mut type-names::GenericStruct<type-names::Mod1::Enum2, f64>, i32)\n+\n+\n+// RAW POINTERS\n+// gdb-command:whatis mut_ptr1\n+// gdb-check:type = struct (*mut type-names::Struct1, int)\n+\n+// gdb-command:whatis mut_ptr2\n+// gdb-check:type = struct (*mut int, int)\n+\n+// gdb-command:whatis mut_ptr3\n+// gdb-check:type = struct (*mut type-names::Mod1::Mod2::Enum3<type-names::Struct1>, int)\n+\n+// gdb-command:whatis const_ptr1\n+// gdb-check:type = struct (*const type-names::Struct1, int)\n+\n+// gdb-command:whatis const_ptr2\n+// gdb-check:type = struct (*const int, int)\n+\n+// gdb-command:whatis const_ptr3\n+// gdb-check:type = struct (*const type-names::Mod1::Mod2::Enum3<type-names::Struct1>, int)\n+\n+\n+// VECTORS\n+// gdb-command:whatis fixed_size_vec1\n+// gdb-check:type = struct ([type-names::Struct1, ..3], i16)\n+\n+// gdb-command:whatis fixed_size_vec2\n+// gdb-check:type = struct ([uint, ..3], i16)\n+\n+// gdb-command:whatis slice1\n+// gdb-check:type = struct &[uint]\n+\n+// gdb-command:whatis slice2\n+// gdb-check:type = struct &[type-names::Mod1::Enum2]\n+\n+\n+// TRAITS\n+// gdb-command:whatis box_trait\n+// gdb-check:type = struct Box<Trait1>\n+\n+// gdb-command:whatis ref_trait\n+// gdb-check:type = struct &Trait1\n+\n+// gdb-command:whatis mut_ref_trait\n+// gdb-check:type = struct &mut Trait1\n+\n+// gdb-command:whatis generic_box_trait\n+// gdb-check:type = struct Box<Trait2<i32, type-names::Mod1::Struct2>>\n+\n+// gdb-command:whatis generic_ref_trait\n+// gdb-check:type = struct &Trait2<type-names::Struct1, type-names::Struct1>\n+\n+// gdb-command:whatis generic_mut_ref_trait\n+// gdb-check:type = struct &mut Trait2<type-names::Mod1::Mod2::Struct3, type-names::GenericStruct<uint, int>>\n+\n+\n+// BARE FUNCTIONS\n+// gdb-command:whatis rust_fn\n+// gdb-check:type = struct (fn(core::option::Option<int>, core::option::Option<&type-names::Mod1::Struct2>), uint)\n+\n+// gdb-command:whatis extern_c_fn\n+// gdb-check:type = struct (extern \"C\" fn(int), uint)\n+\n+// gdb-command:whatis unsafe_fn\n+// gdb-check:type = struct (unsafe fn(core::result::Result<char, f64>), uint)\n+\n+// gdb-command:whatis extern_stdcall_fn\n+// gdb-check:type = struct (extern \"stdcall\" fn(), uint)\n+\n+// gdb-command:whatis rust_fn_with_return_value\n+// gdb-check:type = struct (fn(f64) -> uint, uint)\n+\n+// gdb-command:whatis extern_c_fn_with_return_value\n+// gdb-check:type = struct (extern \"C\" fn() -> type-names::Struct1, uint)\n+\n+// gdb-command:whatis unsafe_fn_with_return_value\n+// gdb-check:type = struct (unsafe fn(type-names::GenericStruct<u16, u8>) -> type-names::Mod1::Struct2, uint)\n+\n+// gdb-command:whatis extern_stdcall_fn_with_return_value\n+// gdb-check:type = struct (extern \"stdcall\" fn(Box<int>) -> uint, uint)\n+\n+// gdb-command:whatis generic_function_int\n+// gdb-check:type = struct (fn(int) -> int, uint)\n+\n+// gdb-command:whatis generic_function_struct3\n+// gdb-check:type = struct (fn(type-names::Mod1::Mod2::Struct3) -> type-names::Mod1::Mod2::Struct3, uint)\n+\n+// gdb-command:whatis variadic_function\n+// gdb-check:type = struct (unsafe extern \"C\" fn(*const u8, ...) -> int, uint)\n+\n+\n+// CLOSURES\n+// gdb-command:whatis some_proc\n+// gdb-check:type = struct (once proc(int, u8) -> (int, u8), uint)\n+\n+// gdb-command:whatis stack_closure1\n+// gdb-check:type = struct (&mut|int|, uint)\n+\n+// gdb-command:whatis stack_closure2\n+// gdb-check:type = struct (&mut|i8, f32| -> f32, uint)\n+\n+use std::ptr;\n+\n+struct Struct1;\n+struct GenericStruct<T1, T2>;\n+\n+enum Enum1 {\n+    Variant1_1,\n+    Variant1_2(int)\n+}\n+\n+mod Mod1 {\n+    pub struct Struct2;\n+\n+    pub enum Enum2 {\n+        Variant2_1,\n+        Variant2_2(super::Struct1)\n+    }\n+\n+    pub mod Mod2 {\n+        pub struct Struct3;\n+\n+        pub enum Enum3<T> {\n+            Variant3_1,\n+            Variant3_2(T),\n+        }\n+    }\n+}\n+\n+trait Trait1 { }\n+trait Trait2<T1, T2> { }\n+\n+impl Trait1 for int {}\n+impl<T1, T2> Trait2<T1, T2> for int {}\n+\n+fn rust_fn(_: Option<int>, _: Option<&Mod1::Struct2>) {}\n+extern \"C\" fn extern_c_fn(_: int) {}\n+unsafe fn unsafe_fn(_: Result<char, f64>) {}\n+extern \"stdcall\" fn extern_stdcall_fn() {}\n+\n+fn rust_fn_with_return_value(_: f64) -> uint { 4 }\n+extern \"C\" fn extern_c_fn_with_return_value() -> Struct1 { Struct1 }\n+unsafe fn unsafe_fn_with_return_value(_: GenericStruct<u16, u8>) -> Mod1::Struct2 { Mod1::Struct2 }\n+extern \"stdcall\" fn extern_stdcall_fn_with_return_value(_: Box<int>) -> uint { 0 }\n+\n+fn generic_function<T>(x: T) -> T { x }\n+\n+extern {\n+    fn printf(_:*const u8, ...) -> int;\n+}\n+\n+// In many of the cases below, the type that is actually under test is wrapped\n+// in a tuple, e.g. Box<T>, references, raw pointers, fixed-size vectors, ...\n+// This is because GDB will not print the type name from DWARF debuginfo for\n+// some kinds of types (pointers, arrays, functions, ...)\n+// Since tuples are structs as far as GDB is concerned, their name will be\n+// printed correctly, so the tests below just construct a tuple type that will\n+// then *contain* the type name that we want to see.\n+fn main() {\n+\n+    // Structs\n+    let simple_struct = Struct1;\n+    let generic_struct1: GenericStruct<Mod1::Struct2, Mod1::Mod2::Struct3> = GenericStruct;\n+    let generic_struct2: GenericStruct<Struct1, extern \"fastcall\" fn(int) -> uint> = GenericStruct;\n+    let mod_struct = Mod1::Struct2;\n+\n+    // Enums\n+    let simple_enum_1 = Variant1_1;\n+    let simple_enum_2 = Variant1_2(0);\n+    let simple_enum_3 = Mod1::Variant2_2(Struct1);\n+\n+    let generic_enum_1: Mod1::Mod2::Enum3<Mod1::Struct2> = Mod1::Mod2::Variant3_1;\n+    let generic_enum_2 = Mod1::Mod2::Variant3_2(Struct1);\n+\n+    // Tuples\n+    let tuple1 = (8u32, Struct1, Mod1::Mod2::Variant3_2(Mod1::Struct2));\n+    let tuple2 = ((Struct1, Mod1::Mod2::Struct3), Mod1::Variant2_1, 'x');\n+\n+    // Box\n+    let box1 = (box 1f32, 0i32);\n+    let box2 = (box Mod1::Mod2::Variant3_2(1f32), 0i32);\n+\n+    // References\n+    let ref1 = (&Struct1, 0i32);\n+    let ref2 = (&GenericStruct::<char, Struct1>, 0i32);\n+\n+    let mut mut_struct1 = Struct1;\n+    let mut mut_generic_struct = GenericStruct::<Mod1::Enum2, f64>;\n+    let mut_ref1 = (&mut mut_struct1, 0i32);\n+    let mut_ref2 = (&mut mut_generic_struct, 0i32);\n+\n+    // Raw Pointers\n+    let mut_ptr1: (*mut Struct1, int) = (ptr::mut_null(), 0);\n+    let mut_ptr2: (*mut int, int) = (ptr::mut_null(), 0);\n+    let mut_ptr3: (*mut Mod1::Mod2::Enum3<Struct1>, int) = (ptr::mut_null(), 0);\n+\n+    let const_ptr1: (*const Struct1, int) = (ptr::null(), 0);\n+    let const_ptr2: (*const int, int) = (ptr::null(), 0);\n+    let const_ptr3: (*const Mod1::Mod2::Enum3<Struct1>, int) = (ptr::null(), 0);\n+\n+    // Vectors\n+    let fixed_size_vec1 = ([Struct1, Struct1, Struct1], 0i16);\n+    let fixed_size_vec2 = ([0u, 1u, 2u], 0i16);\n+\n+    let vec1 = vec![0u, 2u, 3u];\n+    let slice1 = vec1.as_slice();\n+    let vec2 = vec![Mod1::Variant2_2(Struct1)];\n+    let slice2 = vec2.as_slice();\n+\n+    // Trait Objects\n+    let box_trait = (box 0i) as Box<Trait1>;\n+    let ref_trait = &0i as &Trait1;\n+    let mut mut_int1 = 0i;\n+    let mut_ref_trait = (&mut mut_int1) as &mut Trait1;\n+\n+    let generic_box_trait = (box 0i) as Box<Trait2<i32, Mod1::Struct2>>;\n+    let generic_ref_trait  = (&0i) as &Trait2<Struct1, Struct1>;\n+\n+    let mut generic_mut_ref_trait_impl = 0i;\n+    let generic_mut_ref_trait = (&mut generic_mut_ref_trait_impl) as\n+        &mut Trait2<Mod1::Mod2::Struct3, GenericStruct<uint, int>>;\n+\n+    // Bare Functions\n+    let rust_fn = (rust_fn, 0u);\n+    let extern_c_fn = (extern_c_fn, 0u);\n+    let unsafe_fn = (unsafe_fn, 0u);\n+    let extern_stdcall_fn = (extern_stdcall_fn, 0u);\n+\n+    let rust_fn_with_return_value = (rust_fn_with_return_value, 0u);\n+    let extern_c_fn_with_return_value = (extern_c_fn_with_return_value, 0u);\n+    let unsafe_fn_with_return_value = (unsafe_fn_with_return_value, 0u);\n+    let extern_stdcall_fn_with_return_value = (extern_stdcall_fn_with_return_value, 0u);\n+\n+    let generic_function_int = (generic_function::<int>, 0u);\n+    let generic_function_struct3 = (generic_function::<Mod1::Mod2::Struct3>, 0u);\n+\n+    let variadic_function = (printf, 0u);\n+\n+    // Closures\n+    // I (mw) am a bit unclear about the current state of closures, their\n+    // various forms (boxed, unboxed, proc, capture-by-ref, by-val, once) and\n+    // how that maps to rustc's internal representation of these forms.\n+    // Once closures have reached their 1.0 form, the tests below should\n+    // probably be expanded.\n+    let some_proc = (proc(a:int, b:u8) (a, b), 0u);\n+\n+    let stack_closure1 = (|x:int| {}, 0u);\n+    let stack_closure2 = (|x:i8, y: f32| { (x as f32) + y }, 0u);\n+\n+    zzz();\n+}\n+\n+#[inline(never)]\n+fn zzz() { () }"}]}