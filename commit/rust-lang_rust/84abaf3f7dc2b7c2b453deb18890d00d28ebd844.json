{"sha": "84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "node_id": "C_kwDOAAsO6NoAKDg0YWJhZjNmN2RjMmI3YzJiNDUzZGViMTg4OTBkMDBkMjhlYmQ4NDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-08T06:01:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-08T06:01:37Z"}, "message": "Auto merge of #92664 - ehuss:rollup-t9yrvk5, r=ehuss\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #84640 (Implement `TryFrom<char>` for `u8`)\n - #92336 (Remove &self from PrintState::to_string)\n - #92375 (Consolidate checking for msvc when generating debuginfo)\n - #92568 (Add note about non_exhaustive to variant_count)\n - #92600 (Add some missing `#[must_use]` to some `f{32,64}` operations)\n - #92610 (Create CSS class instead of using inline style for search results)\n - #92632 (Implement stabilization of `#[feature(available_parallelism)]`)\n - #92650 (Fix typo in `StableCrateId` docs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c5b746f779fe6bd06d5859d8dcd95a7fddd60fa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5b746f779fe6bd06d5859d8dcd95a7fddd60fa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "html_url": "https://github.com/rust-lang/rust/commit/84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e012a191d768adeda1ee36a99ef8b92d51920154", "url": "https://api.github.com/repos/rust-lang/rust/commits/e012a191d768adeda1ee36a99ef8b92d51920154", "html_url": "https://github.com/rust-lang/rust/commit/e012a191d768adeda1ee36a99ef8b92d51920154"}, {"sha": "05cfc4f4a90bb87288d5a85df401af452f2269e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/05cfc4f4a90bb87288d5a85df401af452f2269e0", "html_url": "https://github.com/rust-lang/rust/commit/05cfc4f4a90bb87288d5a85df401af452f2269e0"}], "stats": {"total": 237, "additions": 142, "deletions": 95}, "files": [{"sha": "ac9e7d06c4e4006fb9563cd55fe0af516869272b", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -73,11 +73,11 @@ pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n }\n \n pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n-    State::new().to_string(f)\n+    State::to_string(f)\n }\n \n pub fn crate_to_string_for_macros(krate: &ast::Crate) -> String {\n-    State::new().to_string(|s| {\n+    State::to_string(|s| {\n         s.print_inner_attributes(&krate.attrs);\n         for item in &krate.items {\n             s.print_item(item);"}, {"sha": "fa9a20f2e03584192cd6ac3dfdd55bcbf93bebf1", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -211,7 +211,7 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n }\n \n fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n-    format!(\"{}{}\", State::new().to_string(|s| s.print_visibility(vis)), s)\n+    format!(\"{}{}\", State::to_string(|s| s.print_visibility(vis)), s)\n }\n \n impl std::ops::Deref for State<'_> {\n@@ -793,55 +793,55 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     }\n \n     fn ty_to_string(&self, ty: &ast::Ty) -> String {\n-        self.to_string(|s| s.print_type(ty))\n+        Self::to_string(|s| s.print_type(ty))\n     }\n \n     fn bounds_to_string(&self, bounds: &[ast::GenericBound]) -> String {\n-        self.to_string(|s| s.print_type_bounds(\"\", bounds))\n+        Self::to_string(|s| s.print_type_bounds(\"\", bounds))\n     }\n \n     fn pat_to_string(&self, pat: &ast::Pat) -> String {\n-        self.to_string(|s| s.print_pat(pat))\n+        Self::to_string(|s| s.print_pat(pat))\n     }\n \n     fn expr_to_string(&self, e: &ast::Expr) -> String {\n-        self.to_string(|s| s.print_expr(e))\n+        Self::to_string(|s| s.print_expr(e))\n     }\n \n     fn tt_to_string(&self, tt: &TokenTree) -> String {\n-        self.to_string(|s| s.print_tt(tt, false))\n+        Self::to_string(|s| s.print_tt(tt, false))\n     }\n \n     fn tts_to_string(&self, tokens: &TokenStream) -> String {\n-        self.to_string(|s| s.print_tts(tokens, false))\n+        Self::to_string(|s| s.print_tts(tokens, false))\n     }\n \n     fn stmt_to_string(&self, stmt: &ast::Stmt) -> String {\n-        self.to_string(|s| s.print_stmt(stmt))\n+        Self::to_string(|s| s.print_stmt(stmt))\n     }\n \n     fn item_to_string(&self, i: &ast::Item) -> String {\n-        self.to_string(|s| s.print_item(i))\n+        Self::to_string(|s| s.print_item(i))\n     }\n \n     fn generic_params_to_string(&self, generic_params: &[ast::GenericParam]) -> String {\n-        self.to_string(|s| s.print_generic_params(generic_params))\n+        Self::to_string(|s| s.print_generic_params(generic_params))\n     }\n \n     fn path_to_string(&self, p: &ast::Path) -> String {\n-        self.to_string(|s| s.print_path(p, false, 0))\n+        Self::to_string(|s| s.print_path(p, false, 0))\n     }\n \n     fn path_segment_to_string(&self, p: &ast::PathSegment) -> String {\n-        self.to_string(|s| s.print_path_segment(p, false))\n+        Self::to_string(|s| s.print_path_segment(p, false))\n     }\n \n     fn vis_to_string(&self, v: &ast::Visibility) -> String {\n-        self.to_string(|s| s.print_visibility(v))\n+        Self::to_string(|s| s.print_visibility(v))\n     }\n \n     fn block_to_string(&self, blk: &ast::Block) -> String {\n-        self.to_string(|s| {\n+        Self::to_string(|s| {\n             // Containing cbox, will be closed by `print_block` at `}`.\n             s.cbox(INDENT_UNIT);\n             // Head-ibox, will be closed by `print_block` after `{`.\n@@ -851,22 +851,22 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     }\n \n     fn meta_list_item_to_string(&self, li: &ast::NestedMetaItem) -> String {\n-        self.to_string(|s| s.print_meta_list_item(li))\n+        Self::to_string(|s| s.print_meta_list_item(li))\n     }\n \n     fn attr_item_to_string(&self, ai: &ast::AttrItem) -> String {\n-        self.to_string(|s| s.print_attr_item(ai, ai.path.span))\n+        Self::to_string(|s| s.print_attr_item(ai, ai.path.span))\n     }\n \n     fn attribute_to_string(&self, attr: &ast::Attribute) -> String {\n-        self.to_string(|s| s.print_attribute(attr))\n+        Self::to_string(|s| s.print_attribute(attr))\n     }\n \n     fn param_to_string(&self, arg: &ast::Param) -> String {\n-        self.to_string(|s| s.print_param(arg, false))\n+        Self::to_string(|s| s.print_param(arg, false))\n     }\n \n-    fn to_string(&self, f: impl FnOnce(&mut State<'_>)) -> String {\n+    fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n         let mut printer = State::new();\n         f(&mut printer);\n         printer.s.eof()\n@@ -1202,7 +1202,7 @@ impl<'a> State<'a> {\n                 );\n             }\n             ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n-                self.head(self.to_string(|s| {\n+                self.head(Self::to_string(|s| {\n                     s.print_visibility(&item.vis);\n                     s.print_unsafety(unsafety);\n                     s.word(\"mod\");\n@@ -1228,7 +1228,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n-                self.head(self.to_string(|s| {\n+                self.head(Self::to_string(|s| {\n                     s.print_unsafety(nmod.unsafety);\n                     s.word(\"extern\");\n                 }));\n@@ -1450,7 +1450,7 @@ impl<'a> State<'a> {\n                 ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\"),\n             },\n             ast::VisibilityKind::Restricted { ref path, .. } => {\n-                let path = self.to_string(|s| s.print_path(path, false, 0));\n+                let path = Self::to_string(|s| s.print_path(path, false, 0));\n                 if path == \"self\" || path == \"super\" {\n                     self.word_nbsp(format!(\"pub({})\", path))\n                 } else {"}, {"sha": "60ff18af0a97e8f1e34bc225d7d09e5294874356", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -18,6 +18,7 @@ use crate::llvm::debuginfo::{\n use crate::value::Value;\n \n use cstr::cstr;\n+use rustc_codegen_ssa::debuginfo::type_names::cpp_like_debuginfo;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n@@ -933,16 +934,16 @@ fn basic_type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'l\n \n     // When targeting MSVC, emit MSVC style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n-    let msvc_like_names = cx.tcx.sess.target.is_like_msvc;\n+    let cpp_like_debuginfo = cpp_like_debuginfo(cx.tcx);\n \n     let (name, encoding) = match t.kind() {\n         ty::Never => (\"!\", DW_ATE_unsigned),\n         ty::Tuple(elements) if elements.is_empty() => (\"()\", DW_ATE_unsigned),\n         ty::Bool => (\"bool\", DW_ATE_boolean),\n         ty::Char => (\"char\", DW_ATE_unsigned_char),\n-        ty::Int(int_ty) if msvc_like_names => (int_ty.msvc_basic_name(), DW_ATE_signed),\n-        ty::Uint(uint_ty) if msvc_like_names => (uint_ty.msvc_basic_name(), DW_ATE_unsigned),\n-        ty::Float(float_ty) if msvc_like_names => (float_ty.msvc_basic_name(), DW_ATE_float),\n+        ty::Int(int_ty) if cpp_like_debuginfo => (int_ty.msvc_basic_name(), DW_ATE_signed),\n+        ty::Uint(uint_ty) if cpp_like_debuginfo => (uint_ty.msvc_basic_name(), DW_ATE_unsigned),\n+        ty::Float(float_ty) if cpp_like_debuginfo => (float_ty.msvc_basic_name(), DW_ATE_float),\n         ty::Int(int_ty) => (int_ty.name_str(), DW_ATE_signed),\n         ty::Uint(uint_ty) => (uint_ty.name_str(), DW_ATE_unsigned),\n         ty::Float(float_ty) => (float_ty.name_str(), DW_ATE_float),\n@@ -959,7 +960,7 @@ fn basic_type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'l\n         )\n     };\n \n-    if !msvc_like_names {\n+    if !cpp_like_debuginfo {\n         return ty_metadata;\n     }\n \n@@ -1525,13 +1526,6 @@ fn prepare_union_metadata<'ll, 'tcx>(\n // Enums\n //=-----------------------------------------------------------------------------\n \n-/// DWARF variant support is only available starting in LLVM 8, but\n-/// on MSVC we have to use the fallback mode, because LLVM doesn't\n-/// lower variant parts to PDB.\n-fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n-    cx.sess().target.is_like_msvc\n-}\n-\n // FIXME(eddyb) maybe precompute this? Right now it's computed once\n // per generator monomorphization, but it doesn't depend on substs.\n fn generator_layout_and_saved_local_names<'tcx>(\n@@ -1606,7 +1600,10 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n             _ => bug!(),\n         };\n \n-        let fallback = use_enum_fallback(cx);\n+        // While LLVM supports generating debuginfo for variant types (enums), it doesn't support\n+        // lowering that debuginfo to CodeView records for msvc targets. So if we are targeting\n+        // msvc, then we need to use a different, fallback encoding of the debuginfo.\n+        let fallback = cpp_like_debuginfo(cx.tcx);\n         // This will always find the metadata in the type map.\n         let self_metadata = type_metadata(cx, self.enum_type, self.span);\n \n@@ -2159,7 +2156,10 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n         return FinalMetadata(discriminant_type_metadata(tag.value));\n     }\n \n-    if use_enum_fallback(cx) {\n+    // While LLVM supports generating debuginfo for variant types (enums), it doesn't support\n+    // lowering that debuginfo to CodeView records for msvc targets. So if we are targeting\n+    // msvc, then we need to use a different encoding of the debuginfo.\n+    if cpp_like_debuginfo(tcx) {\n         let discriminant_type_metadata = match layout.variants {\n             Variants::Single { .. } => None,\n             Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, tag, .. }"}, {"sha": "93bb1aee25f7d25d9aca664a58275d30fa9c3f17", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -53,14 +53,14 @@ fn push_debuginfo_type_name<'tcx>(\n ) {\n     // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n-    let cpp_like_names = cpp_like_names(tcx);\n+    let cpp_like_debuginfo = cpp_like_debuginfo(tcx);\n \n     match *t.kind() {\n         ty::Bool => output.push_str(\"bool\"),\n         ty::Char => output.push_str(\"char\"),\n         ty::Str => output.push_str(\"str\"),\n         ty::Never => {\n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 output.push_str(\"never$\");\n             } else {\n                 output.push('!');\n@@ -71,36 +71,36 @@ fn push_debuginfo_type_name<'tcx>(\n         ty::Float(float_ty) => output.push_str(float_ty.name_str()),\n         ty::Foreign(def_id) => push_item_name(tcx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n-            if def.is_enum() && cpp_like_names {\n+            if def.is_enum() && cpp_like_debuginfo {\n                 msvc_enum_fallback(tcx, t, def, substs, output, visited);\n             } else {\n                 push_item_name(tcx, def.did, qualified, output);\n                 push_generic_params_internal(tcx, substs, output, visited);\n             }\n         }\n         ty::Tuple(component_types) => {\n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 output.push_str(\"tuple$<\");\n             } else {\n                 output.push('(');\n             }\n \n             for component_type in component_types {\n                 push_debuginfo_type_name(tcx, component_type.expect_ty(), true, output, visited);\n-                push_arg_separator(cpp_like_names, output);\n+                push_arg_separator(cpp_like_debuginfo, output);\n             }\n             if !component_types.is_empty() {\n                 pop_arg_separator(output);\n             }\n \n-            if cpp_like_names {\n-                push_close_angle_bracket(cpp_like_names, output);\n+            if cpp_like_debuginfo {\n+                push_close_angle_bracket(cpp_like_debuginfo, output);\n             } else {\n                 output.push(')');\n             }\n         }\n         ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 match mutbl {\n                     hir::Mutability::Not => output.push_str(\"ptr_const$<\"),\n                     hir::Mutability::Mut => output.push_str(\"ptr_mut$<\"),\n@@ -115,8 +115,8 @@ fn push_debuginfo_type_name<'tcx>(\n \n             push_debuginfo_type_name(tcx, inner_type, qualified, output, visited);\n \n-            if cpp_like_names {\n-                push_close_angle_bracket(cpp_like_names, output);\n+            if cpp_like_debuginfo {\n+                push_close_angle_bracket(cpp_like_debuginfo, output);\n             }\n         }\n         ty::Ref(_, inner_type, mutbl) => {\n@@ -126,7 +126,7 @@ fn push_debuginfo_type_name<'tcx>(\n             // types out to aid debugging in MSVC.\n             let is_slice_or_str = matches!(*inner_type.kind(), ty::Slice(_) | ty::Str);\n \n-            if !cpp_like_names {\n+            if !cpp_like_debuginfo {\n                 output.push('&');\n                 output.push_str(mutbl.prefix_str());\n             } else if !is_slice_or_str {\n@@ -138,12 +138,12 @@ fn push_debuginfo_type_name<'tcx>(\n \n             push_debuginfo_type_name(tcx, inner_type, qualified, output, visited);\n \n-            if cpp_like_names && !is_slice_or_str {\n-                push_close_angle_bracket(cpp_like_names, output);\n+            if cpp_like_debuginfo && !is_slice_or_str {\n+                push_close_angle_bracket(cpp_like_debuginfo, output);\n             }\n         }\n         ty::Array(inner_type, len) => {\n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 output.push_str(\"array$<\");\n                 push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n                 match len.val {\n@@ -162,24 +162,24 @@ fn push_debuginfo_type_name<'tcx>(\n             }\n         }\n         ty::Slice(inner_type) => {\n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 output.push_str(\"slice$<\");\n             } else {\n                 output.push('[');\n             }\n \n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n \n-            if cpp_like_names {\n-                push_close_angle_bracket(cpp_like_names, output);\n+            if cpp_like_debuginfo {\n+                push_close_angle_bracket(cpp_like_debuginfo, output);\n             } else {\n                 output.push(']');\n             }\n         }\n         ty::Dynamic(ref trait_data, ..) => {\n             let auto_traits: SmallVec<[DefId; 4]> = trait_data.auto_traits().collect();\n \n-            let has_enclosing_parens = if cpp_like_names {\n+            let has_enclosing_parens = if cpp_like_debuginfo {\n                 output.push_str(\"dyn$<\");\n                 false\n             } else {\n@@ -216,26 +216,26 @@ fn push_debuginfo_type_name<'tcx>(\n                     }\n \n                     for (item_def_id, ty) in projection_bounds {\n-                        push_arg_separator(cpp_like_names, output);\n+                        push_arg_separator(cpp_like_debuginfo, output);\n \n-                        if cpp_like_names {\n+                        if cpp_like_debuginfo {\n                             output.push_str(\"assoc$<\");\n                             push_item_name(tcx, item_def_id, false, output);\n-                            push_arg_separator(cpp_like_names, output);\n+                            push_arg_separator(cpp_like_debuginfo, output);\n                             push_debuginfo_type_name(tcx, ty, true, output, visited);\n-                            push_close_angle_bracket(cpp_like_names, output);\n+                            push_close_angle_bracket(cpp_like_debuginfo, output);\n                         } else {\n                             push_item_name(tcx, item_def_id, false, output);\n                             output.push('=');\n                             push_debuginfo_type_name(tcx, ty, true, output, visited);\n                         }\n                     }\n \n-                    push_close_angle_bracket(cpp_like_names, output);\n+                    push_close_angle_bracket(cpp_like_debuginfo, output);\n                 }\n \n                 if auto_traits.len() != 0 {\n-                    push_auto_trait_separator(cpp_like_names, output);\n+                    push_auto_trait_separator(cpp_like_debuginfo, output);\n                 }\n             }\n \n@@ -252,14 +252,14 @@ fn push_debuginfo_type_name<'tcx>(\n \n                 for auto_trait in auto_traits {\n                     output.push_str(&auto_trait);\n-                    push_auto_trait_separator(cpp_like_names, output);\n+                    push_auto_trait_separator(cpp_like_debuginfo, output);\n                 }\n \n                 pop_auto_trait_separator(output);\n             }\n \n-            if cpp_like_names {\n-                push_close_angle_bracket(cpp_like_names, output);\n+            if cpp_like_debuginfo {\n+                push_close_angle_bracket(cpp_like_debuginfo, output);\n             } else if has_enclosing_parens {\n                 output.push(')');\n             }\n@@ -279,7 +279,7 @@ fn push_debuginfo_type_name<'tcx>(\n             // use a dummy string that should make it clear\n             // that something unusual is going on\n             if !visited.insert(t) {\n-                output.push_str(if cpp_like_names {\n+                output.push_str(if cpp_like_debuginfo {\n                     \"recursive_type$\"\n                 } else {\n                     \"<recursive_type>\"\n@@ -290,7 +290,7 @@ fn push_debuginfo_type_name<'tcx>(\n             let sig =\n                 tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), t.fn_sig(tcx));\n \n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 // Format as a C++ function pointer: return_type (*)(params...)\n                 if sig.output().is_unit() {\n                     output.push_str(\"void\");\n@@ -313,7 +313,7 @@ fn push_debuginfo_type_name<'tcx>(\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n                     push_debuginfo_type_name(tcx, parameter_type, true, output, visited);\n-                    push_arg_separator(cpp_like_names, output);\n+                    push_arg_separator(cpp_like_debuginfo, output);\n                 }\n                 pop_arg_separator(output);\n             }\n@@ -328,7 +328,7 @@ fn push_debuginfo_type_name<'tcx>(\n \n             output.push(')');\n \n-            if !cpp_like_names && !sig.output().is_unit() {\n+            if !cpp_like_debuginfo && !sig.output().is_unit() {\n                 output.push_str(\" -> \");\n                 push_debuginfo_type_name(tcx, sig.output(), true, output, visited);\n             }\n@@ -426,9 +426,9 @@ fn push_debuginfo_type_name<'tcx>(\n \n     const NON_CPP_AUTO_TRAIT_SEPARATOR: &str = \" + \";\n \n-    fn push_auto_trait_separator(cpp_like_names: bool, output: &mut String) {\n-        if cpp_like_names {\n-            push_arg_separator(cpp_like_names, output);\n+    fn push_auto_trait_separator(cpp_like_debuginfo: bool, output: &mut String) {\n+        if cpp_like_debuginfo {\n+            push_arg_separator(cpp_like_debuginfo, output);\n         } else {\n             output.push_str(NON_CPP_AUTO_TRAIT_SEPARATOR);\n         }\n@@ -457,11 +457,11 @@ pub fn compute_debuginfo_vtable_name<'tcx>(\n     t: Ty<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> String {\n-    let cpp_like_names = cpp_like_names(tcx);\n+    let cpp_like_debuginfo = cpp_like_debuginfo(tcx);\n \n     let mut vtable_name = String::with_capacity(64);\n \n-    if cpp_like_names {\n+    if cpp_like_debuginfo {\n         vtable_name.push_str(\"impl$<\");\n     } else {\n         vtable_name.push('<');\n@@ -470,7 +470,7 @@ pub fn compute_debuginfo_vtable_name<'tcx>(\n     let mut visited = FxHashSet::default();\n     push_debuginfo_type_name(tcx, t, true, &mut vtable_name, &mut visited);\n \n-    if cpp_like_names {\n+    if cpp_like_debuginfo {\n         vtable_name.push_str(\", \");\n     } else {\n         vtable_name.push_str(\" as \");\n@@ -486,9 +486,9 @@ pub fn compute_debuginfo_vtable_name<'tcx>(\n         vtable_name.push_str(\"_\");\n     }\n \n-    push_close_angle_bracket(cpp_like_names, &mut vtable_name);\n+    push_close_angle_bracket(cpp_like_debuginfo, &mut vtable_name);\n \n-    let suffix = if cpp_like_names { \"::vtable$\" } else { \"::{vtable}\" };\n+    let suffix = if cpp_like_debuginfo { \"::vtable$\" } else { \"::{vtable}\" };\n \n     vtable_name.reserve_exact(suffix.len());\n     vtable_name.push_str(suffix);\n@@ -521,7 +521,7 @@ fn push_unqualified_item_name(\n         DefPathData::ClosureExpr if tcx.generator_kind(def_id).is_some() => {\n             // Generators look like closures, but we want to treat them differently\n             // in the debug info.\n-            if cpp_like_names(tcx) {\n+            if cpp_like_debuginfo(tcx) {\n                 write!(output, \"generator${}\", disambiguated_data.disambiguator).unwrap();\n             } else {\n                 write!(output, \"{{generator#{}}}\", disambiguated_data.disambiguator).unwrap();\n@@ -532,7 +532,7 @@ fn push_unqualified_item_name(\n                 output.push_str(name.as_str());\n             }\n             DefPathDataName::Anon { namespace } => {\n-                if cpp_like_names(tcx) {\n+                if cpp_like_debuginfo(tcx) {\n                     write!(output, \"{}${}\", namespace, disambiguated_data.disambiguator).unwrap();\n                 } else {\n                     write!(output, \"{{{}#{}}}\", namespace, disambiguated_data.disambiguator)\n@@ -560,7 +560,7 @@ fn push_generic_params_internal<'tcx>(\n \n     debug_assert_eq!(substs, tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substs));\n \n-    let cpp_like_names = cpp_like_names(tcx);\n+    let cpp_like_debuginfo = cpp_like_debuginfo(tcx);\n \n     output.push('<');\n \n@@ -575,10 +575,10 @@ fn push_generic_params_internal<'tcx>(\n             other => bug!(\"Unexpected non-erasable generic: {:?}\", other),\n         }\n \n-        push_arg_separator(cpp_like_names, output);\n+        push_arg_separator(cpp_like_debuginfo, output);\n     }\n     pop_arg_separator(output);\n-    push_close_angle_bracket(cpp_like_names, output);\n+    push_close_angle_bracket(cpp_like_debuginfo, output);\n \n     true\n }\n@@ -617,7 +617,7 @@ fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: &'tcx ty::Const<'tcx>, output:\n                 // avoiding collisions and will make the emitted type names shorter.\n                 let hash: u64 = hasher.finish();\n \n-                if cpp_like_names(tcx) {\n+                if cpp_like_debuginfo(tcx) {\n                     write!(output, \"CONST${:x}\", hash)\n                 } else {\n                     write!(output, \"{{CONST#{:x}}}\", hash)\n@@ -634,10 +634,10 @@ pub fn push_generic_params<'tcx>(tcx: TyCtxt<'tcx>, substs: SubstsRef<'tcx>, out\n     push_generic_params_internal(tcx, substs, output, &mut visited);\n }\n \n-fn push_close_angle_bracket(cpp_like_names: bool, output: &mut String) {\n+fn push_close_angle_bracket(cpp_like_debuginfo: bool, output: &mut String) {\n     // MSVC debugger always treats `>>` as a shift, even when parsing templates,\n     // so add a space to avoid confusion.\n-    if cpp_like_names && output.ends_with('>') {\n+    if cpp_like_debuginfo && output.ends_with('>') {\n         output.push(' ')\n     };\n \n@@ -652,11 +652,11 @@ fn pop_close_angle_bracket(output: &mut String) {\n     }\n }\n \n-fn push_arg_separator(cpp_like_names: bool, output: &mut String) {\n+fn push_arg_separator(cpp_like_debuginfo: bool, output: &mut String) {\n     // Natvis does not always like having spaces between parts of the type name\n     // and this causes issues when we need to write a typename in natvis, for example\n     // as part of a cast like the `HashMap` visualizer does.\n-    if cpp_like_names {\n+    if cpp_like_debuginfo {\n         output.push(',');\n     } else {\n         output.push_str(\", \");\n@@ -673,6 +673,7 @@ fn pop_arg_separator(output: &mut String) {\n     output.pop();\n }\n \n-fn cpp_like_names(tcx: TyCtxt<'_>) -> bool {\n+/// Check if we should generate C++ like names and debug information.\n+pub fn cpp_like_debuginfo(tcx: TyCtxt<'_>) -> bool {\n     tcx.sess.target.is_like_msvc\n }"}, {"sha": "24d2a8ac0738295d5c457797895843a950d98e1f", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -136,8 +136,8 @@ impl Borrow<Fingerprint> for DefPathHash {\n /// collisions when loading crates and abort compilation in order to avoid\n /// further trouble.\n ///\n-/// See the discussion in [`DefId`] for more information\n-/// on the possibility of hash collisions in rustc,\n+/// For more information on the possibility of hash collisions in rustc,\n+/// see the discussion in [`DefId`].\n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub struct StableCrateId(pub(crate) u64);"}, {"sha": "1774ddd7cbb2cde9e61ff732a8f25860b798c0f9", "filename": "library/core/src/char/convert.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -1,5 +1,6 @@\n //! Character conversions.\n \n+use crate::char::TryFromCharError;\n use crate::convert::TryFrom;\n use crate::fmt;\n use crate::mem::transmute;\n@@ -166,6 +167,20 @@ impl const From<char> for u128 {\n     }\n }\n \n+/// Map `char` with code point in U+0000..=U+00FF to byte in 0x00..=0xFF with same value, failing\n+/// if the code point is greater than U+00FF.\n+///\n+/// See [`impl From<u8> for char`](char#impl-From<u8>) for details on the encoding.\n+#[stable(feature = \"u8_from_char\", since = \"1.59.0\")]\n+impl TryFrom<char> for u8 {\n+    type Error = TryFromCharError;\n+\n+    #[inline]\n+    fn try_from(c: char) -> Result<u8, Self::Error> {\n+        u8::try_from(u32::from(c)).map_err(|_| TryFromCharError(()))\n+    }\n+}\n+\n /// Maps a byte in 0x00..=0xFF to a `char` whose code point has the same value, in U+0000..=U+00FF.\n ///\n /// Unicode is designed such that this effectively decodes bytes"}, {"sha": "f65f84e93aebe6a369fa9c7d27d6d405ba49903e", "filename": "library/core/src/char/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmod.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -544,3 +544,15 @@ impl fmt::Display for ToUppercase {\n         fmt::Display::fmt(&self.0, f)\n     }\n }\n+\n+/// The error type returned when a checked char conversion fails.\n+#[stable(feature = \"u8_from_char\", since = \"1.59.0\")]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub struct TryFromCharError(pub(crate) ());\n+\n+#[stable(feature = \"u8_from_char\", since = \"1.59.0\")]\n+impl fmt::Display for TryFromCharError {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        \"unicode code point out of range\".fmt(fmt)\n+    }\n+}"}, {"sha": "989ec0639cd6b37ac89b0a8922f1472e828600ef", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -1045,6 +1045,10 @@ pub const fn discriminant<T>(v: &T) -> Discriminant<T> {\n /// return value is unspecified. Equally, if `T` is an enum with more variants than `usize::MAX`\n /// the return value is unspecified. Uninhabited variants will be counted.\n ///\n+/// Note that an enum may be expanded with additional variants in the future\n+/// as a non-breaking change, for example if it is marked `#[non_exhaustive]`,\n+/// which will change the result of this function.\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "85ceede5b9e3a1b227888b4fa1044d7a01111f67", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -628,6 +628,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[must_use = \"this returns the result of the operation, without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn recip(self) -> f32 {\n@@ -684,6 +685,7 @@ impl f32 {\n     /// ```\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n+    #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f32) -> f32 {\n@@ -703,6 +705,7 @@ impl f32 {\n     /// ```\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n+    #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f32) -> f32 {\n@@ -726,6 +729,7 @@ impl f32 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n     pub fn maximum(self, other: f32) -> f32 {\n@@ -757,6 +761,7 @@ impl f32 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n     pub fn minimum(self, other: f32) -> f32 {"}, {"sha": "4049c95b130f2a6bdc771a61ed13739ba240e647", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -643,6 +643,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[must_use = \"this returns the result of the operation, without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn recip(self) -> f64 {\n@@ -700,6 +701,7 @@ impl f64 {\n     /// ```\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n+    #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f64) -> f64 {\n@@ -719,6 +721,7 @@ impl f64 {\n     /// ```\n     ///\n     /// If one of the arguments is NaN, then the other argument is returned.\n+    #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f64) -> f64 {\n@@ -742,6 +745,7 @@ impl f64 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n     pub fn maximum(self, other: f64) -> f64 {\n@@ -773,6 +777,7 @@ impl f64 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n     pub fn minimum(self, other: f64) -> f64 {"}, {"sha": "ea0c230fa42db7438021169ccac9a0dfe6d366d2", "filename": "library/std/src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -478,6 +478,9 @@ impl Error for char::DecodeUtf16Error {\n     }\n }\n \n+#[stable(feature = \"u8_from_char\", since = \"1.59.0\")]\n+impl Error for char::TryFromCharError {}\n+\n #[unstable(feature = \"map_try_insert\", issue = \"82766\")]\n impl<'a, K: Debug + Ord, V: Debug> Error\n     for crate::collections::btree_map::OccupiedError<'a, K, V>"}, {"sha": "ae4b65871ecb15d8ee39c2fbf9a80ac4ee5b5ae4", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -1504,7 +1504,6 @@ fn _assert_sync_and_send() {\n ///\n /// ```\n /// # #![allow(dead_code)]\n-/// #![feature(available_parallelism)]\n /// use std::{io, thread};\n ///\n /// fn main() -> io::Result<()> {\n@@ -1516,7 +1515,7 @@ fn _assert_sync_and_send() {\n #[doc(alias = \"available_concurrency\")] // Alias for a previous name we gave this API on unstable.\n #[doc(alias = \"hardware_concurrency\")] // Alias for C++ `std::thread::hardware_concurrency`.\n #[doc(alias = \"num_cpus\")] // Alias for a popular ecosystem crate which provides similar functionality.\n-#[unstable(feature = \"available_parallelism\", issue = \"74479\")]\n+#[stable(feature = \"available_parallelism\", since = \"1.59.0\")]\n pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n     imp::available_parallelism()\n }"}, {"sha": "fad83094cdf8aa8c6a3956ed2f659cf220418bb0", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -16,7 +16,6 @@\n #![unstable(feature = \"test\", issue = \"50297\")]\n #![doc(test(attr(deny(warnings))))]\n #![feature(nll)]\n-#![feature(available_parallelism)]\n #![feature(bench_black_box)]\n #![feature(internal_output_capture)]\n #![feature(staged_api)]"}, {"sha": "83df3ac94a2c141b11b6d6a83c3763496c989007", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -545,6 +545,10 @@ nav.sub {\n \tposition: relative;\n }\n \n+.search-loading {\n+\ttext-align: center;\n+}\n+\n #results > table {\n \twidth: 100%;\n \ttable-layout: fixed;"}, {"sha": "f41c1bd817ab284f3afb2a58eb804a45208fbc54", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/84abaf3f7dc2b7c2b453deb18890d00d28ebd844/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=84abaf3f7dc2b7c2b453deb18890d00d28ebd844", "patch": "@@ -289,8 +289,8 @@ function hideThemeButtonState() {\n             var params = searchState.getQueryStringParams();\n             if (params.search !== undefined) {\n                 var search = searchState.outputElement();\n-                search.innerHTML = \"<h3 style=\\\"text-align: center;\\\">\" +\n-                   searchState.loadingText + \"</h3>\";\n+                search.innerHTML = \"<h3 class=\\\"search-loading\\\">\" +\n+                    searchState.loadingText + \"</h3>\";\n                 searchState.showResults(search);\n                 loadSearch();\n             }"}]}