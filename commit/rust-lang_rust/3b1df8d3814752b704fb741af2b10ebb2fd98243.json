{"sha": "3b1df8d3814752b704fb741af2b10ebb2fd98243", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMWRmOGQzODE0NzUyYjcwNGZiNzQxYWYyYjEwZWJiMmZkOTgyNDM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-02-01T11:51:33Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-02-01T12:01:16Z"}, "message": "fallout", "tree": {"sha": "18e81079d35ab3e9d31bf5f4f7c91d506432802b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18e81079d35ab3e9d31bf5f4f7c91d506432802b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b1df8d3814752b704fb741af2b10ebb2fd98243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b1df8d3814752b704fb741af2b10ebb2fd98243", "html_url": "https://github.com/rust-lang/rust/commit/3b1df8d3814752b704fb741af2b10ebb2fd98243", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b1df8d3814752b704fb741af2b10ebb2fd98243/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "328d2c76260631aa8da7d0c64eeb95f2592630d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/328d2c76260631aa8da7d0c64eeb95f2592630d1", "html_url": "https://github.com/rust-lang/rust/commit/328d2c76260631aa8da7d0c64eeb95f2592630d1"}], "stats": {"total": 426, "additions": 210, "deletions": 216}, "files": [{"sha": "f590095d9f2c89f0734f6ecc94fd303a2c762c25", "filename": "src/consts.rs", "status": "modified", "additions": 83, "deletions": 84, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/3b1df8d3814752b704fb741af2b10ebb2fd98243/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1df8d3814752b704fb741af2b10ebb2fd98243/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=3b1df8d3814752b704fb741af2b10ebb2fd98243", "patch": "@@ -12,7 +12,6 @@ use std::cmp::Ordering::{self, Greater, Less, Equal};\n use std::rc::Rc;\n use std::ops::Deref;\n use std::fmt;\n-use self::Constant::*;\n use self::FloatWidth::*;\n \n use syntax::ast::Lit_::*;\n@@ -44,25 +43,25 @@ impl From<FloatTy> for FloatWidth {\n #[derive(Eq, Debug, Clone)]\n pub enum Constant {\n     /// a String \"abc\"\n-    ConstantStr(String, StrStyle),\n+    Str(String, StrStyle),\n     /// a Binary String b\"abc\"\n-    ConstantBinary(Rc<Vec<u8>>),\n+    Binary(Rc<Vec<u8>>),\n     /// a single byte b'a'\n-    ConstantByte(u8),\n+    Byte(u8),\n     /// a single char 'a'\n-    ConstantChar(char),\n+    Char(char),\n     /// an integer\n-    ConstantInt(u64, LitIntType),\n+    Int(u64, LitIntType),\n     /// a float with given type\n-    ConstantFloat(String, FloatWidth),\n+    Float(String, FloatWidth),\n     /// true or false\n-    ConstantBool(bool),\n+    Bool(bool),\n     /// an array of constants\n-    ConstantVec(Vec<Constant>),\n+    Vec(Vec<Constant>),\n     /// also an array, but with only one constant, repeated N times\n-    ConstantRepeat(Box<Constant>, usize),\n+    Repeat(Box<Constant>, usize),\n     /// a tuple of constants\n-    ConstantTuple(Vec<Constant>),\n+    Tuple(Vec<Constant>),\n }\n \n impl Constant {\n@@ -72,7 +71,7 @@ impl Constant {\n     ///\n     /// if the constant could not be converted to u64 losslessly\n     fn as_u64(&self) -> u64 {\n-        if let ConstantInt(val, _) = *self {\n+        if let Constant::Int(val, _) = *self {\n             val // TODO we may want to check the sign if any\n         } else {\n             panic!(\"Could not convert a {:?} to u64\", self);\n@@ -83,9 +82,9 @@ impl Constant {\n     #[allow(cast_precision_loss)]\n     pub fn as_float(&self) -> Option<f64> {\n         match *self {\n-            ConstantByte(b) => Some(b as f64),\n-            ConstantFloat(ref s, _) => s.parse().ok(),\n-            ConstantInt(i, ty) => {\n+            Constant::Byte(b) => Some(b as f64),\n+            Constant::Float(ref s, _) => s.parse().ok(),\n+            Constant::Int(i, ty) => {\n                 Some(if is_negative(ty) {\n                     -(i as f64)\n                 } else {\n@@ -100,14 +99,14 @@ impl Constant {\n impl PartialEq for Constant {\n     fn eq(&self, other: &Constant) -> bool {\n         match (self, other) {\n-            (&ConstantStr(ref ls, ref lsty), &ConstantStr(ref rs, ref rsty)) => ls == rs && lsty == rsty,\n-            (&ConstantBinary(ref l), &ConstantBinary(ref r)) => l == r,\n-            (&ConstantByte(l), &ConstantByte(r)) => l == r,\n-            (&ConstantChar(l), &ConstantChar(r)) => l == r,\n-            (&ConstantInt(lv, lty), &ConstantInt(rv, rty)) => {\n+            (&Constant::Str(ref ls, ref lsty), &Constant::Str(ref rs, ref rsty)) => ls == rs && lsty == rsty,\n+            (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n+            (&Constant::Byte(l), &Constant::Byte(r)) => l == r,\n+            (&Constant::Char(l), &Constant::Char(r)) => l == r,\n+            (&Constant::Int(lv, lty), &Constant::Int(rv, rty)) => {\n                 lv == rv && (is_negative(lty) & (lv != 0)) == (is_negative(rty) & (rv != 0))\n             }\n-            (&ConstantFloat(ref ls, lw), &ConstantFloat(ref rs, rw)) => {\n+            (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n                 if match (lw, rw) {\n                     (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n                     _ => false,\n@@ -120,10 +119,10 @@ impl PartialEq for Constant {\n                     false\n                 }\n             }\n-            (&ConstantBool(l), &ConstantBool(r)) => l == r,\n-            (&ConstantVec(ref l), &ConstantVec(ref r)) => l == r,\n-            (&ConstantRepeat(ref lv, ref ls), &ConstantRepeat(ref rv, ref rs)) => ls == rs && lv == rv,\n-            (&ConstantTuple(ref l), &ConstantTuple(ref r)) => l == r,\n+            (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n+            (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l == r,\n+            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n+            (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => l == r,\n             _ => false, //TODO: Are there inter-type equalities?\n         }\n     }\n@@ -132,24 +131,24 @@ impl PartialEq for Constant {\n impl PartialOrd for Constant {\n     fn partial_cmp(&self, other: &Constant) -> Option<Ordering> {\n         match (self, other) {\n-            (&ConstantStr(ref ls, ref lsty), &ConstantStr(ref rs, ref rsty)) => {\n+            (&Constant::Str(ref ls, ref lsty), &Constant::Str(ref rs, ref rsty)) => {\n                 if lsty != rsty {\n                     None\n                 } else {\n                     Some(ls.cmp(rs))\n                 }\n             }\n-            (&ConstantByte(ref l), &ConstantByte(ref r)) => Some(l.cmp(r)),\n-            (&ConstantChar(ref l), &ConstantChar(ref r)) => Some(l.cmp(r)),\n-            (&ConstantInt(ref lv, lty), &ConstantInt(ref rv, rty)) => {\n+            (&Constant::Byte(ref l), &Constant::Byte(ref r)) => Some(l.cmp(r)),\n+            (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n+            (&Constant::Int(ref lv, lty), &Constant::Int(ref rv, rty)) => {\n                 Some(match (is_negative(lty) && *lv != 0, is_negative(rty) && *rv != 0) {\n                     (true, true) => rv.cmp(lv),\n                     (false, false) => lv.cmp(rv),\n                     (true, false) => Less,\n                     (false, true) => Greater,\n                 })\n             }\n-            (&ConstantFloat(ref ls, lw), &ConstantFloat(ref rs, rw)) => {\n+            (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n                 if match (lw, rw) {\n                     (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n                     _ => false,\n@@ -162,15 +161,15 @@ impl PartialOrd for Constant {\n                     None\n                 }\n             }\n-            (&ConstantBool(ref l), &ConstantBool(ref r)) => Some(l.cmp(r)),\n-            (&ConstantVec(ref l), &ConstantVec(ref r)) => l.partial_cmp(&r),\n-            (&ConstantRepeat(ref lv, ref ls), &ConstantRepeat(ref rv, ref rs)) => {\n+            (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),\n+            (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l.partial_cmp(&r),\n+            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => {\n                 match lv.partial_cmp(rv) {\n                     Some(Equal) => Some(ls.cmp(rs)),\n                     x => x,\n                 }\n             }\n-            (&ConstantTuple(ref l), &ConstantTuple(ref r)) => l.partial_cmp(r),\n+            (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => l.partial_cmp(r),\n             _ => None, //TODO: Are there any useful inter-type orderings?\n         }\n     }\n@@ -193,21 +192,21 @@ fn format_byte(fmt: &mut fmt::Formatter, b: u8) -> fmt::Result {\n impl fmt::Display for Constant {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ConstantStr(ref s, _) => write!(fmt, \"{:?}\", s),\n-            ConstantByte(ref b) => {\n+            Constant::Str(ref s, _) => write!(fmt, \"{:?}\", s),\n+            Constant::Byte(ref b) => {\n                 write!(fmt, \"b'\")\n                     .and_then(|_| format_byte(fmt, *b))\n                     .and_then(|_| write!(fmt, \"'\"))\n             }\n-            ConstantBinary(ref bs) => {\n+            Constant::Binary(ref bs) => {\n                 try!(write!(fmt, \"b\\\"\"));\n                 for b in bs.iter() {\n                     try!(format_byte(fmt, *b));\n                 }\n                 write!(fmt, \"\\\"\")\n             }\n-            ConstantChar(ref c) => write!(fmt, \"'{}'\", c),\n-            ConstantInt(ref i, ref ity) => {\n+            Constant::Char(ref c) => write!(fmt, \"'{}'\", c),\n+            Constant::Int(ref i, ref ity) => {\n                 let (sign, suffix) = match *ity {\n                     LitIntType::SignedIntLit(ref sity, ref sign) => {\n                         (if let Sign::Minus = *sign {\n@@ -229,25 +228,25 @@ impl fmt::Display for Constant {\n                 };\n                 write!(fmt, \"{}{}{}\", sign, i, suffix)\n             }\n-            ConstantFloat(ref s, ref fw) => {\n+            Constant::Float(ref s, ref fw) => {\n                 let suffix = match *fw {\n                     FloatWidth::Fw32 => \"f32\",\n                     FloatWidth::Fw64 => \"f64\",\n                     FloatWidth::FwAny => \"\",\n                 };\n                 write!(fmt, \"{}{}\", s, suffix)\n             }\n-            ConstantBool(ref b) => write!(fmt, \"{}\", b),\n-            ConstantRepeat(ref c, ref n) => write!(fmt, \"[{}; {}]\", c, n),\n-            ConstantVec(ref v) => {\n+            Constant::Bool(ref b) => write!(fmt, \"{}\", b),\n+            Constant::Repeat(ref c, ref n) => write!(fmt, \"[{}; {}]\", c, n),\n+            Constant::Vec(ref v) => {\n                 write!(fmt,\n                        \"[{}]\",\n                        v.iter()\n                         .map(|i| format!(\"{}\", i))\n                         .collect::<Vec<_>>()\n                         .join(\", \"))\n             }\n-            ConstantTuple(ref t) => {\n+            Constant::Tuple(ref t) => {\n                 write!(fmt,\n                        \"({})\",\n                        t.iter()\n@@ -262,21 +261,21 @@ impl fmt::Display for Constant {\n \n fn lit_to_constant(lit: &Lit_) -> Constant {\n     match *lit {\n-        LitStr(ref is, style) => ConstantStr(is.to_string(), style),\n-        LitByte(b) => ConstantByte(b),\n-        LitByteStr(ref s) => ConstantBinary(s.clone()),\n-        LitChar(c) => ConstantChar(c),\n-        LitInt(value, ty) => ConstantInt(value, ty),\n-        LitFloat(ref is, ty) => ConstantFloat(is.to_string(), ty.into()),\n-        LitFloatUnsuffixed(ref is) => ConstantFloat(is.to_string(), FwAny),\n-        LitBool(b) => ConstantBool(b),\n+        LitStr(ref is, style) => Constant::Str(is.to_string(), style),\n+        LitByte(b) => Constant::Byte(b),\n+        LitByteStr(ref s) => Constant::Binary(s.clone()),\n+        LitChar(c) => Constant::Char(c),\n+        LitInt(value, ty) => Constant::Int(value, ty),\n+        LitFloat(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n+        LitFloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FwAny),\n+        LitBool(b) => Constant::Bool(b),\n     }\n }\n \n fn constant_not(o: Constant) -> Option<Constant> {\n     Some(match o {\n-        ConstantBool(b) => ConstantBool(!b),\n-        ConstantInt(value, ty) => {\n+        Constant::Bool(b) => Constant::Bool(!b),\n+        Constant::Int(value, ty) => {\n             let (nvalue, nty) = match ty {\n                 SignedIntLit(ity, Plus) => {\n                     if value == ::std::u64::MAX {\n@@ -307,7 +306,7 @@ fn constant_not(o: Constant) -> Option<Constant> {\n                     return None;\n                 }  // refuse to guess\n             };\n-            ConstantInt(nvalue, nty)\n+            Constant::Int(nvalue, nty)\n         }\n         _ => {\n             return None;\n@@ -317,8 +316,8 @@ fn constant_not(o: Constant) -> Option<Constant> {\n \n fn constant_negate(o: Constant) -> Option<Constant> {\n     Some(match o {\n-        ConstantInt(value, ty) => {\n-            ConstantInt(value,\n+        Constant::Int(value, ty) => {\n+            Constant::Int(value,\n                         match ty {\n                             SignedIntLit(ity, sign) => SignedIntLit(ity, neg_sign(sign)),\n                             UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n@@ -327,7 +326,7 @@ fn constant_negate(o: Constant) -> Option<Constant> {\n                             }\n                         })\n         }\n-        ConstantFloat(is, ty) => ConstantFloat(neg_float_str(is), ty),\n+        Constant::Float(is, ty) => Constant::Float(neg_float_str(is), ty),\n         _ => {\n             return None;\n         }\n@@ -402,9 +401,9 @@ fn unify_int_type(l: LitIntType, r: LitIntType, s: Sign) -> Option<LitIntType> {\n \n fn add_neg_int(pos: u64, pty: LitIntType, neg: u64, nty: LitIntType) -> Option<Constant> {\n     if neg > pos {\n-        unify_int_type(nty, pty, Minus).map(|ty| ConstantInt(neg - pos, ty))\n+        unify_int_type(nty, pty, Minus).map(|ty| Constant::Int(neg - pos, ty))\n     } else {\n-        unify_int_type(nty, pty, Plus).map(|ty| ConstantInt(pos - neg, ty))\n+        unify_int_type(nty, pty, Plus).map(|ty| Constant::Int(pos - neg, ty))\n     }\n }\n \n@@ -416,7 +415,7 @@ fn sub_int(l: u64, lty: LitIntType, r: u64, rty: LitIntType, neg: bool) -> Optio\n                    } else {\n                        Plus\n                    })\n-        .and_then(|ty| l.checked_sub(r).map(|v| ConstantInt(v, ty)))\n+        .and_then(|ty| l.checked_sub(r).map(|v| Constant::Int(v, ty)))\n }\n \n \n@@ -449,10 +448,10 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprBlock(ref block) => self.block(block),\n             ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n             ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n-            ExprVec(ref vec) => self.multi(vec).map(ConstantVec),\n-            ExprTup(ref tup) => self.multi(tup).map(ConstantTuple),\n+            ExprVec(ref vec) => self.multi(vec).map(Constant::Vec),\n+            ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprRepeat(ref value, ref number) => {\n-                self.binop_apply(value, number, |v, n| Some(ConstantRepeat(Box::new(v), n.as_u64() as usize)))\n+                self.binop_apply(value, number, |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n             }\n             ExprUnary(op, ref operand) => {\n                 self.expr(operand).and_then(|o| {\n@@ -508,7 +507,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     fn ifthenelse(&mut self, cond: &Expr, then: &Block, otherwise: &Option<P<Expr>>) -> Option<Constant> {\n-        if let Some(ConstantBool(b)) = self.expr(cond) {\n+        if let Some(Constant::Bool(b)) = self.expr(cond) {\n             if b {\n                 self.block(then)\n             } else {\n@@ -524,8 +523,8 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             BiAdd => {\n                 self.binop_apply(left, right, |l, r| {\n                     match (l, r) {\n-                        (ConstantByte(l8), ConstantByte(r8)) => l8.checked_add(r8).map(ConstantByte),\n-                        (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n+                        (Constant::Byte(l8), Constant::Byte(r8)) => l8.checked_add(r8).map(Constant::Byte),\n+                        (Constant::Int(l64, lty), Constant::Int(r64, rty)) => {\n                             let (ln, rn) = (is_negative(lty), is_negative(rty));\n                             if ln == rn {\n                                 unify_int_type(lty,\n@@ -535,7 +534,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                                                } else {\n                                                    Plus\n                                                })\n-                                    .and_then(|ty| l64.checked_add(r64).map(|v| ConstantInt(v, ty)))\n+                                    .and_then(|ty| l64.checked_add(r64).map(|v| Constant::Int(v, ty)))\n                             } else if ln {\n                                 add_neg_int(r64, rty, l64, lty)\n                             } else {\n@@ -550,24 +549,24 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             BiSub => {\n                 self.binop_apply(left, right, |l, r| {\n                     match (l, r) {\n-                        (ConstantByte(l8), ConstantByte(r8)) => {\n+                        (Constant::Byte(l8), Constant::Byte(r8)) => {\n                             if r8 > l8 {\n                                 None\n                             } else {\n-                                Some(ConstantByte(l8 - r8))\n+                                Some(Constant::Byte(l8 - r8))\n                             }\n                         }\n-                        (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n+                        (Constant::Int(l64, lty), Constant::Int(r64, rty)) => {\n                             match (is_negative(lty), is_negative(rty)) {\n                                 (false, false) => sub_int(l64, lty, r64, rty, r64 > l64),\n                                 (true, true) => sub_int(l64, lty, r64, rty, l64 > r64),\n                                 (true, false) => {\n                                     unify_int_type(lty, rty, Minus)\n-                                        .and_then(|ty| l64.checked_add(r64).map(|v| ConstantInt(v, ty)))\n+                                        .and_then(|ty| l64.checked_add(r64).map(|v| Constant::Int(v, ty)))\n                                 }\n                                 (false, true) => {\n                                     unify_int_type(lty, rty, Plus)\n-                                        .and_then(|ty| l64.checked_add(r64).map(|v| ConstantInt(v, ty)))\n+                                        .and_then(|ty| l64.checked_add(r64).map(|v| Constant::Int(v, ty)))\n                                 }\n                             }\n                         }\n@@ -585,8 +584,8 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             BiBitOr => self.bitop(left, right, |x, y| (x | y)),\n             BiShl => self.bitop(left, right, |x, y| x << y),\n             BiShr => self.bitop(left, right, |x, y| x >> y),\n-            BiEq => self.binop_apply(left, right, |l, r| Some(ConstantBool(l == r))),\n-            BiNe => self.binop_apply(left, right, |l, r| Some(ConstantBool(l != r))),\n+            BiEq => self.binop_apply(left, right, |l, r| Some(Constant::Bool(l == r))),\n+            BiNe => self.binop_apply(left, right, |l, r| Some(Constant::Bool(l != r))),\n             BiLt => self.cmp(left, right, Less, true),\n             BiLe => self.cmp(left, right, Greater, false),\n             BiGe => self.cmp(left, right, Less, false),\n@@ -600,7 +599,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     {\n         self.binop_apply(left, right, |l, r| {\n             match (l, r) {\n-                (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n+                (Constant::Int(l64, lty), Constant::Int(r64, rty)) => {\n                     f(l64, r64).and_then(|value| {\n                         unify_int_type(lty,\n                                        rty,\n@@ -609,7 +608,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                                        } else {\n                                            Minus\n                                        })\n-                            .map(|ty| ConstantInt(value, ty))\n+                            .map(|ty| Constant::Int(value, ty))\n                     })\n                 }\n                 _ => None,\n@@ -622,10 +621,10 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     {\n         self.binop_apply(left, right, |l, r| {\n             match (l, r) {\n-                (ConstantBool(l), ConstantBool(r)) => Some(ConstantBool(f(l as u64, r as u64) != 0)),\n-                (ConstantByte(l8), ConstantByte(r8)) => Some(ConstantByte(f(l8 as u64, r8 as u64) as u8)),\n-                (ConstantInt(l, lty), ConstantInt(r, rty)) => {\n-                    unify_int_type(lty, rty, Plus).map(|ty| ConstantInt(f(l, r), ty))\n+                (Constant::Bool(l), Constant::Bool(r)) => Some(Constant::Bool(f(l as u64, r as u64) != 0)),\n+                (Constant::Byte(l8), Constant::Byte(r8)) => Some(Constant::Byte(f(l8 as u64, r8 as u64) as u8)),\n+                (Constant::Int(l, lty), Constant::Int(r, rty)) => {\n+                    unify_int_type(lty, rty, Plus).map(|ty| Constant::Int(f(l, r), ty))\n                 }\n                 _ => None,\n             }\n@@ -635,7 +634,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     fn cmp(&mut self, left: &Expr, right: &Expr, ordering: Ordering, b: bool) -> Option<Constant> {\n         self.binop_apply(left,\n                          right,\n-                         |l, r| l.partial_cmp(&r).map(|o| ConstantBool(b == (o == ordering))))\n+                         |l, r| l.partial_cmp(&r).map(|o| Constant::Bool(b == (o == ordering))))\n     }\n \n     fn binop_apply<F>(&mut self, left: &Expr, right: &Expr, op: F) -> Option<Constant>\n@@ -650,12 +649,12 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n \n     fn short_circuit(&mut self, left: &Expr, right: &Expr, b: bool) -> Option<Constant> {\n         self.expr(left).and_then(|left| {\n-            if let ConstantBool(lbool) = left {\n+            if let Constant::Bool(lbool) = left {\n                 if lbool == b {\n                     Some(left)\n                 } else {\n                     self.expr(right).and_then(|right| {\n-                        if let ConstantBool(_) = right {\n+                        if let Constant::Bool(_) = right {\n                             Some(right)\n                         } else {\n                             None"}, {"sha": "5fa9c7588cd3b835322d9442b0b9f4c553779e36", "filename": "src/identity_op.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b1df8d3814752b704fb741af2b10ebb2fd98243/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1df8d3814752b704fb741af2b10ebb2fd98243/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=3b1df8d3814752b704fb741af2b10ebb2fd98243", "patch": "@@ -2,8 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n \n-use consts::{constant_simple, is_negative};\n-use consts::Constant::ConstantInt;\n+use consts::{constant_simple, is_negative, Constant};\n use utils::{span_lint, snippet, in_macro};\n \n /// **What it does:** This lint checks for identity operations, e.g. `x + 0`. It is `Warn` by default.\n@@ -54,7 +53,7 @@ impl LateLintPass for IdentityOp {\n \n \n fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n-    if let Some(ConstantInt(v, ty)) = constant_simple(e) {\n+    if let Some(Constant::Int(v, ty)) = constant_simple(e) {\n         if match m {\n             0 => v == 0,\n             -1 => is_negative(ty) && v == 1,"}, {"sha": "1baaab6abc0742fce237f90be564d1c30d8bd31a", "filename": "src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1df8d3814752b704fb741af2b10ebb2fd98243/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1df8d3814752b704fb741af2b10ebb2fd98243/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=3b1df8d3814752b704fb741af2b10ebb2fd98243", "patch": "@@ -365,8 +365,8 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n     if let ExprRange(Some(ref start_expr), Some(ref stop_expr)) = arg.node {\n         // ...and both sides are compile-time constant integers...\n-        if let Some(start_idx @ Constant::ConstantInt(..)) = constant_simple(start_expr) {\n-            if let Some(stop_idx @ Constant::ConstantInt(..)) = constant_simple(stop_expr) {\n+        if let Some(start_idx @ Constant::Int(..)) = constant_simple(start_expr) {\n+            if let Some(stop_idx @ Constant::Int(..)) = constant_simple(stop_expr) {\n                 // ...and the start index is greater than the stop index,\n                 // this loop will never run. This is often confusing for developers\n                 // who think that this will iterate from the larger value to the"}, {"sha": "111f4d5642465b49fe5ad5c3d25d01265e69c675", "filename": "src/methods.rs", "status": "modified", "additions": 97, "deletions": 100, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/3b1df8d3814752b704fb741af2b10ebb2fd98243/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1df8d3814752b704fb741af2b10ebb2fd98243/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=3b1df8d3814752b704fb741af2b10ebb2fd98243", "patch": "@@ -19,9 +19,6 @@ use utils::{\n use utils::MethodArgs;\n use rustc::middle::cstore::CrateStore;\n \n-use self::SelfKind::*;\n-use self::OutType::*;\n-\n #[derive(Clone)]\n pub struct MethodsPass;\n \n@@ -456,11 +453,11 @@ fn lint_extend(cx: &LateContext, expr: &Expr, args: &MethodArgs) {\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty) \n+fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty)\n    -> Option<(Span, &'static str)> {\n     fn may_slice(cx: &LateContext, ty: &ty::Ty) -> bool {\n         match ty.sty {\n-            ty::TySlice(_) => true,            \n+            ty::TySlice(_) => true,\n             ty::TyStruct(..) => match_type(cx, ty, &VEC_PATH),\n             ty::TyArray(_, size) => size < 32,\n             ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n@@ -469,7 +466,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty)\n         }\n     }\n     if let ExprMethodCall(name, _, ref args) = expr.node {\n-        if &name.node.as_str() == &\"iter\" && \n+        if &name.node.as_str() == &\"iter\" &&\n                may_slice(cx, &cx.tcx.expr_ty(&args[0])) {\n             Some((args[0].span, \"&\"))\n         } else {\n@@ -479,7 +476,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty)\n         match ty.sty {\n             ty::TySlice(_) => Some((expr.span, \"\")),\n             ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n-            ty::TyBox(ref inner) => if may_slice(cx, inner) { \n+            ty::TyBox(ref inner) => if may_slice(cx, inner) {\n                 Some((expr.span, \"\"))\n             } else { None },\n             _ => None\n@@ -731,222 +728,222 @@ fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     debug_impl_exists\n }\n \n-const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [(\"into_\", &[ValueSelf]),\n-                                                               (\"to_\", &[RefSelf]),\n-                                                               (\"as_\", &[RefSelf, RefMutSelf]),\n-                                                               (\"is_\", &[RefSelf, NoSelf]),\n-                                                               (\"from_\", &[NoSelf])];\n+const CONVENTIONS: [(&'static str, &'static [SelfKind]); 5] = [(\"into_\", &[SelfKind::Value]),\n+                                                               (\"to_\", &[SelfKind::Ref]),\n+                                                               (\"as_\", &[SelfKind::Ref, SelfKind::RefMut]),\n+                                                               (\"is_\", &[SelfKind::Ref, SelfKind::No]),\n+                                                               (\"from_\", &[SelfKind::No])];\n \n const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30] = [(\"add\",\n                                                                                       2,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::Add\"),\n                                                                                      (\"sub\",\n                                                                                       2,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::Sub\"),\n                                                                                      (\"mul\",\n                                                                                       2,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::Mul\"),\n                                                                                      (\"div\",\n                                                                                       2,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::Div\"),\n                                                                                      (\"rem\",\n                                                                                       2,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::Rem\"),\n                                                                                      (\"shl\",\n                                                                                       2,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::Shl\"),\n                                                                                      (\"shr\",\n                                                                                       2,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::Shr\"),\n                                                                                      (\"bitand\",\n                                                                                       2,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::BitAnd\"),\n                                                                                      (\"bitor\",\n                                                                                       2,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::BitOr\"),\n                                                                                      (\"bitxor\",\n                                                                                       2,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::BitXor\"),\n                                                                                      (\"neg\",\n                                                                                       1,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::Neg\"),\n                                                                                      (\"not\",\n                                                                                       1,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::ops::Not\"),\n                                                                                      (\"drop\",\n                                                                                       1,\n-                                                                                      RefMutSelf,\n-                                                                                      UnitType,\n+                                                                                      SelfKind::RefMut,\n+                                                                                      OutType::Unit,\n                                                                                       \"std::ops::Drop\"),\n                                                                                      (\"index\",\n                                                                                       2,\n-                                                                                      RefSelf,\n-                                                                                      RefType,\n+                                                                                      SelfKind::Ref,\n+                                                                                      OutType::Ref,\n                                                                                       \"std::ops::Index\"),\n                                                                                      (\"index_mut\",\n                                                                                       2,\n-                                                                                      RefMutSelf,\n-                                                                                      RefType,\n+                                                                                      SelfKind::RefMut,\n+                                                                                      OutType::Ref,\n                                                                                       \"std::ops::IndexMut\"),\n                                                                                      (\"deref\",\n                                                                                       1,\n-                                                                                      RefSelf,\n-                                                                                      RefType,\n+                                                                                      SelfKind::Ref,\n+                                                                                      OutType::Ref,\n                                                                                       \"std::ops::Deref\"),\n                                                                                      (\"deref_mut\",\n                                                                                       1,\n-                                                                                      RefMutSelf,\n-                                                                                      RefType,\n+                                                                                      SelfKind::RefMut,\n+                                                                                      OutType::Ref,\n                                                                                       \"std::ops::DerefMut\"),\n                                                                                      (\"clone\",\n                                                                                       1,\n-                                                                                      RefSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Ref,\n+                                                                                      OutType::Any,\n                                                                                       \"std::clone::Clone\"),\n                                                                                      (\"borrow\",\n                                                                                       1,\n-                                                                                      RefSelf,\n-                                                                                      RefType,\n+                                                                                      SelfKind::Ref,\n+                                                                                      OutType::Ref,\n                                                                                       \"std::borrow::Borrow\"),\n                                                                                      (\"borrow_mut\",\n                                                                                       1,\n-                                                                                      RefMutSelf,\n-                                                                                      RefType,\n+                                                                                      SelfKind::RefMut,\n+                                                                                      OutType::Ref,\n                                                                                       \"std::borrow::BorrowMut\"),\n                                                                                      (\"as_ref\",\n                                                                                       1,\n-                                                                                      RefSelf,\n-                                                                                      RefType,\n+                                                                                      SelfKind::Ref,\n+                                                                                      OutType::Ref,\n                                                                                       \"std::convert::AsRef\"),\n                                                                                      (\"as_mut\",\n                                                                                       1,\n-                                                                                      RefMutSelf,\n-                                                                                      RefType,\n+                                                                                      SelfKind::RefMut,\n+                                                                                      OutType::Ref,\n                                                                                       \"std::convert::AsMut\"),\n                                                                                      (\"eq\",\n                                                                                       2,\n-                                                                                      RefSelf,\n-                                                                                      BoolType,\n+                                                                                      SelfKind::Ref,\n+                                                                                      OutType::Bool,\n                                                                                       \"std::cmp::PartialEq\"),\n                                                                                      (\"cmp\",\n                                                                                       2,\n-                                                                                      RefSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Ref,\n+                                                                                      OutType::Any,\n                                                                                       \"std::cmp::Ord\"),\n                                                                                      (\"default\",\n                                                                                       0,\n-                                                                                      NoSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::No,\n+                                                                                      OutType::Any,\n                                                                                       \"std::default::Default\"),\n                                                                                      (\"hash\",\n                                                                                       2,\n-                                                                                      RefSelf,\n-                                                                                      UnitType,\n+                                                                                      SelfKind::Ref,\n+                                                                                      OutType::Unit,\n                                                                                       \"std::hash::Hash\"),\n                                                                                      (\"next\",\n                                                                                       1,\n-                                                                                      RefMutSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::RefMut,\n+                                                                                      OutType::Any,\n                                                                                       \"std::iter::Iterator\"),\n                                                                                      (\"into_iter\",\n                                                                                       1,\n-                                                                                      ValueSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::Value,\n+                                                                                      OutType::Any,\n                                                                                       \"std::iter::IntoIterator\"),\n                                                                                      (\"from_iter\",\n                                                                                       1,\n-                                                                                      NoSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::No,\n+                                                                                      OutType::Any,\n                                                                                       \"std::iter::FromIterator\"),\n                                                                                      (\"from_str\",\n                                                                                       1,\n-                                                                                      NoSelf,\n-                                                                                      AnyType,\n+                                                                                      SelfKind::No,\n+                                                                                      OutType::Any,\n                                                                                       \"std::str::FromStr\")];\n \n #[derive(Clone, Copy)]\n enum SelfKind {\n-    ValueSelf,\n-    RefSelf,\n-    RefMutSelf,\n-    NoSelf,\n+    Value,\n+    Ref,\n+    RefMut,\n+    No,\n }\n \n impl SelfKind {\n     fn matches(&self, slf: &ExplicitSelf_, allow_value_for_ref: bool) -> bool {\n         match (self, slf) {\n-            (&ValueSelf, &SelfValue(_)) => true,\n-            (&RefSelf, &SelfRegion(_, Mutability::MutImmutable, _)) => true,\n-            (&RefMutSelf, &SelfRegion(_, Mutability::MutMutable, _)) => true,\n-            (&RefSelf, &SelfValue(_)) => allow_value_for_ref,\n-            (&RefMutSelf, &SelfValue(_)) => allow_value_for_ref,\n-            (&NoSelf, &SelfStatic) => true,\n+            (&SelfKind::Value, &SelfValue(_)) => true,\n+            (&SelfKind::Ref, &SelfRegion(_, Mutability::MutImmutable, _)) => true,\n+            (&SelfKind::RefMut, &SelfRegion(_, Mutability::MutMutable, _)) => true,\n+            (&SelfKind::Ref, &SelfValue(_)) => allow_value_for_ref,\n+            (&SelfKind::RefMut, &SelfValue(_)) => allow_value_for_ref,\n+            (&SelfKind::No, &SelfStatic) => true,\n             (_, &SelfExplicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n             _ => false,\n         }\n     }\n \n     fn matches_explicit_type(&self, ty: &Ty, allow_value_for_ref: bool) -> bool {\n         match (self, &ty.node) {\n-            (&ValueSelf, &TyPath(..)) => true,\n-            (&RefSelf, &TyRptr(_, MutTy { mutbl: Mutability::MutImmutable, .. })) => true,\n-            (&RefMutSelf, &TyRptr(_, MutTy { mutbl: Mutability::MutMutable, .. })) => true,\n-            (&RefSelf, &TyPath(..)) => allow_value_for_ref,\n-            (&RefMutSelf, &TyPath(..)) => allow_value_for_ref,\n+            (&SelfKind::Value, &TyPath(..)) => true,\n+            (&SelfKind::Ref, &TyRptr(_, MutTy { mutbl: Mutability::MutImmutable, .. })) => true,\n+            (&SelfKind::RefMut, &TyRptr(_, MutTy { mutbl: Mutability::MutMutable, .. })) => true,\n+            (&SelfKind::Ref, &TyPath(..)) => allow_value_for_ref,\n+            (&SelfKind::RefMut, &TyPath(..)) => allow_value_for_ref,\n             _ => false,\n         }\n     }\n \n     fn description(&self) -> &'static str {\n         match *self {\n-            ValueSelf => \"self by value\",\n-            RefSelf => \"self by reference\",\n-            RefMutSelf => \"self by mutable reference\",\n-            NoSelf => \"no self\",\n+            SelfKind::Value => \"self by value\",\n+            SelfKind::Ref => \"self by reference\",\n+            SelfKind::RefMut => \"self by mutable reference\",\n+            SelfKind::No => \"no self\",\n         }\n     }\n }\n \n #[derive(Clone, Copy)]\n enum OutType {\n-    UnitType,\n-    BoolType,\n-    AnyType,\n-    RefType,\n+    Unit,\n+    Bool,\n+    Any,\n+    Ref,\n }\n \n impl OutType {\n     fn matches(&self, ty: &FunctionRetTy) -> bool {\n         match (self, ty) {\n-            (&UnitType, &DefaultReturn(_)) => true,\n-            (&UnitType, &Return(ref ty)) if ty.node == TyTup(vec![].into()) => true,\n-            (&BoolType, &Return(ref ty)) if is_bool(ty) => true,\n-            (&AnyType, &Return(ref ty)) if ty.node != TyTup(vec![].into()) => true,\n-            (&RefType, &Return(ref ty)) => {\n+            (&OutType::Unit, &DefaultReturn(_)) => true,\n+            (&OutType::Unit, &Return(ref ty)) if ty.node == TyTup(vec![].into()) => true,\n+            (&OutType::Bool, &Return(ref ty)) if is_bool(ty) => true,\n+            (&OutType::Any, &Return(ref ty)) if ty.node != TyTup(vec![].into()) => true,\n+            (&OutType::Ref, &Return(ref ty)) => {\n                 if let TyRptr(_, _) = ty.node {\n                     true\n                 } else {"}, {"sha": "2c3ec86936c567cb92c111803c4cdc6e5c367534", "filename": "src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1df8d3814752b704fb741af2b10ebb2fd98243/src%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1df8d3814752b704fb741af2b10ebb2fd98243/src%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fzero_div_zero.rs?ref=3b1df8d3814752b704fb741af2b10ebb2fd98243", "patch": "@@ -35,8 +35,8 @@ impl LateLintPass for ZeroDivZeroPass {\n                 // TODO - constant_simple does not fold many operations involving floats.\n                 // That's probably fine for this lint - it's pretty unlikely that someone would\n                 // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-                let Some(Constant::ConstantFloat(ref lhs_value, lhs_width)) = constant_simple(left),\n-                let Some(Constant::ConstantFloat(ref rhs_value, rhs_width)) = constant_simple(right),\n+                let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(left),\n+                let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(right),\n                 let Some(0.0) = lhs_value.parse().ok(),\n                 let Some(0.0) = rhs_value.parse().ok()\n             ],"}, {"sha": "cc02853c70a100624a1b7e0d87a3707dbb19a222", "filename": "tests/cc_seme.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b1df8d3814752b704fb741af2b10ebb2fd98243/tests%2Fcc_seme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1df8d3814752b704fb741af2b10ebb2fd98243/tests%2Fcc_seme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcc_seme.rs?ref=3b1df8d3814752b704fb741af2b10ebb2fd98243", "patch": "@@ -3,8 +3,8 @@\n \n #[allow(dead_code)]\n enum Baz {\n-    Baz1,\n-    Baz2,\n+    One,\n+    Two,\n }\n \n struct Test {\n@@ -14,11 +14,11 @@ struct Test {\n \n fn main() {\n     use Baz::*;\n-    let x = Test { t: Some(0), b: Baz1 };\n+    let x = Test { t: Some(0), b: One };\n \n     match x {\n-        Test { t: Some(_), b: Baz1 } => unreachable!(),\n-        Test { t: Some(42), b: Baz2 } => unreachable!(),\n+        Test { t: Some(_), b: One } => unreachable!(),\n+        Test { t: Some(42), b: Two } => unreachable!(),\n         Test { t: None, .. } => unreachable!(),\n         Test { .. } => unreachable!(),\n     }"}, {"sha": "ad01e4fadd5f80d581eedaf61585f6fe871ed87a", "filename": "tests/compile-fail/complex_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1df8d3814752b704fb741af2b10ebb2fd98243/tests%2Fcompile-fail%2Fcomplex_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1df8d3814752b704fb741af2b10ebb2fd98243/tests%2Fcompile-fail%2Fcomplex_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcomplex_types.rs?ref=3b1df8d3814752b704fb741af2b10ebb2fd98243", "patch": "@@ -16,8 +16,8 @@ struct S {\n struct TS(Vec<Vec<Box<(u32, u32, u32, u32)>>>); //~ERROR very complex type\n \n enum E {\n-    V1(Vec<Vec<Box<(u32, u32, u32, u32)>>>), //~ERROR very complex type\n-    V2 { f: Vec<Vec<Box<(u32, u32, u32, u32)>>> }, //~ERROR very complex type\n+    Tuple(Vec<Vec<Box<(u32, u32, u32, u32)>>>), //~ERROR very complex type\n+    Struct { f: Vec<Vec<Box<(u32, u32, u32, u32)>>> }, //~ERROR very complex type\n }\n \n impl S {"}, {"sha": "21118b82718dad26af6102357fdb8e3f430284ea", "filename": "tests/compile-fail/no_effect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b1df8d3814752b704fb741af2b10ebb2fd98243/tests%2Fcompile-fail%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1df8d3814752b704fb741af2b10ebb2fd98243/tests%2Fcompile-fail%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fno_effect.rs?ref=3b1df8d3814752b704fb741af2b10ebb2fd98243", "patch": "@@ -11,8 +11,8 @@ struct Struct {\n     field: i32\n }\n enum Enum {\n-    TupleVariant(i32),\n-    StructVariant { field: i32 },\n+    Tuple(i32),\n+    Struct { field: i32 },\n }\n \n fn get_number() -> i32 { 0 }\n@@ -26,14 +26,14 @@ fn main() {\n     Tuple(0); //~ERROR statement with no effect\n     Struct { field: 0 }; //~ERROR statement with no effect\n     Struct { ..s }; //~ERROR statement with no effect\n-    Enum::TupleVariant(0); //~ERROR statement with no effect\n-    Enum::StructVariant { field: 0 }; //~ERROR statement with no effect\n+    Enum::Tuple(0); //~ERROR statement with no effect\n+    Enum::Struct { field: 0 }; //~ERROR statement with no effect\n \n     // Do not warn\n     get_number();\n     Tuple(get_number());\n     Struct { field: get_number() };\n     Struct { ..get_struct() };\n-    Enum::TupleVariant(get_number());\n-    Enum::StructVariant { field: get_number() };\n+    Enum::Tuple(get_number());\n+    Enum::Struct { field: get_number() };\n }"}, {"sha": "281d92c46df8114048e22c7efb173ae33ff2f887", "filename": "tests/compile-fail/used_underscore_binding.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b1df8d3814752b704fb741af2b10ebb2fd98243/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1df8d3814752b704fb741af2b10ebb2fd98243/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fused_underscore_binding.rs?ref=3b1df8d3814752b704fb741af2b10ebb2fd98243", "patch": "@@ -50,17 +50,17 @@ fn multiple_underscores(__foo: u32) -> u32 {\n fn _fn_test() {}\n struct _StructTest;\n enum _EnumTest {\n-    _FieldA,\n-    _FieldB(_StructTest)\n+    _Empty,\n+    _Value(_StructTest)\n }\n \n /// Test that we do not lint for non-variable bindings\n fn non_variables() {\n     _fn_test();\n     let _s = _StructTest;\n-    let _e = match _EnumTest::_FieldB(_StructTest) {\n-        _EnumTest::_FieldA => 0,\n-        _EnumTest::_FieldB(_st) => 1,\n+    let _e = match _EnumTest::_Value(_StructTest) {\n+        _EnumTest::_Empty => 0,\n+        _EnumTest::_Value(_st) => 1,\n     };\n     let f = _fn_test;\n     f();"}, {"sha": "75082e646a009f8184a2caee53d8e113d977a964", "filename": "tests/consts.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b1df8d3814752b704fb741af2b10ebb2fd98243/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1df8d3814752b704fb741af2b10ebb2fd98243/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=3b1df8d3814752b704fb741af2b10ebb2fd98243", "patch": "@@ -18,7 +18,6 @@ use syntax::ast::StrStyle::*;\n use syntax::ast::Sign::*;\n \n use clippy::consts::{constant_simple, Constant};\n-use clippy::consts::Constant::*;\n \n fn spanned<T>(t: T) -> Spanned<T> {\n     Spanned{ node: t, span: COMMAND_LINE_SP }\n@@ -45,18 +44,18 @@ fn check(expect: Constant, expr: &Expr) {\n     assert_eq!(Some(expect), constant_simple(expr))\n }\n \n-const TRUE : Constant = ConstantBool(true);\n-const FALSE : Constant = ConstantBool(false);\n-const ZERO : Constant = ConstantInt(0, UnsuffixedIntLit(Plus));\n-const ONE : Constant = ConstantInt(1, UnsuffixedIntLit(Plus));\n-const TWO : Constant = ConstantInt(2, UnsuffixedIntLit(Plus));\n+const TRUE : Constant = Constant::Bool(true);\n+const FALSE : Constant = Constant::Bool(false);\n+const ZERO : Constant = Constant::Int(0, UnsuffixedIntLit(Plus));\n+const ONE : Constant = Constant::Int(1, UnsuffixedIntLit(Plus));\n+const TWO : Constant = Constant::Int(2, UnsuffixedIntLit(Plus));\n \n #[test]\n fn test_lit() {\n     check(TRUE, &lit(LitBool(true)));\n     check(FALSE, &lit(LitBool(false)));\n     check(ZERO, &lit(LitInt(0, UnsuffixedIntLit(Plus))));\n-    check(ConstantStr(\"cool!\".into(), CookedStr), &lit(LitStr(\n+    check(Constant::Str(\"cool!\".into(), CookedStr), &lit(LitStr(\n         InternedString::new(\"cool!\"), CookedStr)));\n }\n "}]}