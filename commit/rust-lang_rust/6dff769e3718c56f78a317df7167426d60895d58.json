{"sha": "6dff769e3718c56f78a317df7167426d60895d58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZmY3NjllMzcxOGM1NmY3OGEzMTdkZjcxNjc0MjZkNjA4OTVkNTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-09T10:20:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-09T10:20:46Z"}, "message": "Auto merge of #68975 - Dylan-DPC:rollup-jzab8oh, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #68718 (Move `rustc_hir::def_id` to `rustc_span::def_id`)\n - #68834 (Fix and test implementation of BTreeMap's first/last_entry, pop_first/last)\n - #68857 (perf: Reduce Vec allocations in normalization by passing &mut Vec)\n - #68918 (Don't use the word \"unwrap\" to describe \"unwrap\" methods)\n - #68946 (Mark several functions and methods in core::cmp as #[must_use])\n - #68958 (Clean up E0277 and E0282 explanations)\n - #68960 (codegen: misc cleanups around debuginfo scopes and locations.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "26484dfcfb4f3f1709317f00c90ef60c6da46707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26484dfcfb4f3f1709317f00c90ef60c6da46707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dff769e3718c56f78a317df7167426d60895d58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dff769e3718c56f78a317df7167426d60895d58", "html_url": "https://github.com/rust-lang/rust/commit/6dff769e3718c56f78a317df7167426d60895d58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dff769e3718c56f78a317df7167426d60895d58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64ea639c12df0594dd891b1ba0b439c8c5eacd83", "url": "https://api.github.com/repos/rust-lang/rust/commits/64ea639c12df0594dd891b1ba0b439c8c5eacd83", "html_url": "https://github.com/rust-lang/rust/commit/64ea639c12df0594dd891b1ba0b439c8c5eacd83"}, {"sha": "9dabf80d5517ab87d5985edfd9dc1f66af6eaa16", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dabf80d5517ab87d5985edfd9dc1f66af6eaa16", "html_url": "https://github.com/rust-lang/rust/commit/9dabf80d5517ab87d5985edfd9dc1f66af6eaa16"}], "stats": {"total": 617, "additions": 310, "deletions": 307}, "files": [{"sha": "5b4b1c933472d8abeb16e36df78f8e89db18db56", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -675,13 +675,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        match self.length {\n-            0 => None,\n-            _ => Some(OccupiedEntry {\n-                handle: self.root.as_mut().first_kv(),\n+        let front = self.root.as_mut().first_leaf_edge();\n+        if let Ok(kv) = front.right_kv() {\n+            Some(OccupiedEntry {\n+                handle: kv.forget_node_type(),\n                 length: &mut self.length,\n                 _marker: PhantomData,\n-            }),\n+            })\n+        } else {\n+            None\n         }\n     }\n \n@@ -736,13 +738,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         T: Ord,\n         K: Borrow<T>,\n     {\n-        match self.length {\n-            0 => None,\n-            _ => Some(OccupiedEntry {\n-                handle: self.root.as_mut().last_kv(),\n+        let back = self.root.as_mut().last_leaf_edge();\n+        if let Ok(kv) = back.left_kv() {\n+            Some(OccupiedEntry {\n+                handle: kv.forget_node_type(),\n                 length: &mut self.length,\n                 _marker: PhantomData,\n-            }),\n+            })\n+        } else {\n+            None\n         }\n     }\n "}, {"sha": "0a26d7bf427ab019eb11850d76722493d225ed47", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -23,6 +23,11 @@ fn test_basic_large() {\n         assert_eq!(map.len(), i + 1);\n     }\n \n+    assert_eq!(map.first_key_value(), Some((&0, &0)));\n+    assert_eq!(map.last_key_value(), Some((&(size - 1), &(10 * (size - 1)))));\n+    assert_eq!(map.first_entry().unwrap().key(), &0);\n+    assert_eq!(map.last_entry().unwrap().key(), &(size - 1));\n+\n     for i in 0..size {\n         assert_eq!(map.get(&i).unwrap(), &(i * 10));\n     }"}, {"sha": "1a2b62d026b2ec969a38ef9186e9eff027a26eeb", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -487,21 +487,26 @@ fn test_first_last() {\n     a.insert(2);\n     assert_eq!(a.first(), Some(&1));\n     assert_eq!(a.last(), Some(&2));\n-    a.insert(3);\n+    for i in 3..=12 {\n+        a.insert(i);\n+    }\n     assert_eq!(a.first(), Some(&1));\n-    assert_eq!(a.last(), Some(&3));\n-\n-    assert_eq!(a.len(), 3);\n+    assert_eq!(a.last(), Some(&12));\n     assert_eq!(a.pop_first(), Some(1));\n-    assert_eq!(a.len(), 2);\n-    assert_eq!(a.pop_last(), Some(3));\n-    assert_eq!(a.len(), 1);\n+    assert_eq!(a.pop_last(), Some(12));\n     assert_eq!(a.pop_first(), Some(2));\n-    assert_eq!(a.len(), 0);\n-    assert_eq!(a.pop_last(), None);\n-    assert_eq!(a.len(), 0);\n+    assert_eq!(a.pop_last(), Some(11));\n+    assert_eq!(a.pop_first(), Some(3));\n+    assert_eq!(a.pop_last(), Some(10));\n+    assert_eq!(a.pop_first(), Some(4));\n+    assert_eq!(a.pop_first(), Some(5));\n+    assert_eq!(a.pop_first(), Some(6));\n+    assert_eq!(a.pop_first(), Some(7));\n+    assert_eq!(a.pop_first(), Some(8));\n+    assert_eq!(a.clone().pop_last(), Some(9));\n+    assert_eq!(a.pop_first(), Some(9));\n     assert_eq!(a.pop_first(), None);\n-    assert_eq!(a.len(), 0);\n+    assert_eq!(a.pop_last(), None);\n }\n \n fn rand_data(len: usize) -> Vec<u32> {"}, {"sha": "604be7d5f68d0f78f8617ee809c1149b468d517d", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -361,6 +361,7 @@ impl Ordering {\n     /// assert!(data == b);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reverse(self) -> Ordering {\n         match self {\n@@ -398,6 +399,7 @@ impl Ordering {\n     /// assert_eq!(result, Ordering::Less);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n     pub fn then(self, other: Ordering) -> Ordering {\n         match self {\n@@ -435,6 +437,7 @@ impl Ordering {\n     /// assert_eq!(result, Ordering::Less);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"ordering_chaining\", since = \"1.17.0\")]\n     pub fn then_with<F: FnOnce() -> Ordering>(self, f: F) -> Ordering {\n         match self {\n@@ -576,6 +579,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(10.cmp(&5), Ordering::Greater);\n     /// assert_eq!(5.cmp(&5), Ordering::Equal);\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cmp(&self, other: &Self) -> Ordering;\n \n@@ -591,6 +595,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// ```\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     #[inline]\n+    #[must_use]\n     fn max(self, other: Self) -> Self\n     where\n         Self: Sized,\n@@ -610,6 +615,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// ```\n     #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     #[inline]\n+    #[must_use]\n     fn min(self, other: Self) -> Self\n     where\n         Self: Sized,\n@@ -635,6 +641,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert!(0.clamp(-2, 1) == 0);\n     /// assert!(2.clamp(-2, 1) == 1);\n     /// ```\n+    #[must_use]\n     #[unstable(feature = \"clamp\", issue = \"44095\")]\n     fn clamp(self, min: Self, max: Self) -> Self\n     where\n@@ -915,6 +922,7 @@ pub macro PartialOrd($item:item) {\n /// assert_eq!(2, cmp::min(2, 2));\n /// ```\n #[inline]\n+#[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     v1.min(v2)\n@@ -935,6 +943,7 @@ pub fn min<T: Ord>(v1: T, v2: T) -> T {\n /// assert_eq!(cmp::min_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n     match compare(&v1, &v2) {\n@@ -958,6 +967,7 @@ pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n /// assert_eq!(cmp::min_by_key(-2, 2, |x: &i32| x.abs()), -2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n     min_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n@@ -978,6 +988,7 @@ pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n /// assert_eq!(2, cmp::max(2, 2));\n /// ```\n #[inline]\n+#[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     v1.max(v2)\n@@ -998,6 +1009,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// assert_eq!(cmp::max_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n     match compare(&v1, &v2) {\n@@ -1021,6 +1033,7 @@ pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n /// assert_eq!(cmp::max_by_key(-2, 2, |x: &i32| x.abs()), 2);\n /// ```\n #[inline]\n+#[must_use]\n #[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n pub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n     max_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))"}, {"sha": "9b32442371c37a32c77577b8e66e2f6551972911", "filename": "src/libcore/option.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -317,7 +317,7 @@ impl<T> Option<T> {\n     // Getting to contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Unwraps an option, yielding the content of a [`Some`].\n+    /// Returns the contained [`Some`] value, consuming the `self` value.\n     ///\n     /// # Panics\n     ///\n@@ -348,17 +348,22 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Moves the value `v` out of the `Option<T>` if it is [`Some(v)`].\n+    /// Returns the contained [`Some`] value, consuming the `self` value.\n     ///\n-    /// In general, because this function may panic, its use is discouraged.\n+    /// Because this function may panic, its use is generally discouraged.\n     /// Instead, prefer to use pattern matching and handle the [`None`]\n-    /// case explicitly.\n+    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n+    /// [`unwrap_or_default`].\n+    ///\n+    /// [`unwrap_or`]: #method.unwrap_or\n+    /// [`unwrap_or_else`]: #method.unwrap_or_else\n+    /// [`unwrap_or_default`]: #method.unwrap_or_default\n     ///\n     /// # Panics\n     ///\n     /// Panics if the self value equals [`None`].\n     ///\n-    /// [`Some(v)`]: #variant.Some\n+    /// [`Some`]: #variant.Some\n     /// [`None`]: #variant.None\n     ///\n     /// # Examples\n@@ -382,12 +387,13 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns the contained value or a default.\n+    /// Returns the contained [`Some`] value or a provided default.\n     ///\n     /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n     /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n     /// which is lazily evaluated.\n     ///\n+    /// [`Some`]: #variant.Some\n     /// [`unwrap_or_else`]: #method.unwrap_or_else\n     ///\n     /// # Examples\n@@ -405,7 +411,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns the contained value or computes it from a closure.\n+    /// Returns the contained [`Some`] value or computes it from a closure.\n     ///\n     /// # Examples\n     ///\n@@ -986,7 +992,7 @@ impl<T: Clone> Option<&mut T> {\n }\n \n impl<T: fmt::Debug> Option<T> {\n-    /// Unwraps an option, expecting [`None`] and returning nothing.\n+    /// Consumes `self` while expecting [`None`] and returning nothing.\n     ///\n     /// # Panics\n     ///\n@@ -1029,7 +1035,7 @@ impl<T: fmt::Debug> Option<T> {\n         }\n     }\n \n-    /// Unwraps an option, expecting [`None`] and returning nothing.\n+    /// Consumes `self` while expecting [`None`] and returning nothing.\n     ///\n     /// # Panics\n     ///\n@@ -1074,7 +1080,7 @@ impl<T: fmt::Debug> Option<T> {\n }\n \n impl<T: Default> Option<T> {\n-    /// Returns the contained value or a default\n+    /// Returns the contained [`Some`] value or a default\n     ///\n     /// Consumes the `self` argument then, if [`Some`], returns the contained\n     /// value, otherwise if [`None`], returns the [default value] for that"}, {"sha": "0bc29e1bc662cfb94dc28f43b808d2d933401be6", "filename": "src/libcore/result.rs", "status": "modified", "additions": 59, "deletions": 53, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -798,8 +798,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an [`Ok`].\n-    /// Else, it returns `optb`.\n+    /// Returns the contained [`Ok`] value or a provided default.\n     ///\n     /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n     /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n@@ -814,27 +813,25 @@ impl<T, E> Result<T, E> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// let optb = 2;\n+    /// let default = 2;\n     /// let x: Result<u32, &str> = Ok(9);\n-    /// assert_eq!(x.unwrap_or(optb), 9);\n+    /// assert_eq!(x.unwrap_or(default), 9);\n     ///\n     /// let x: Result<u32, &str> = Err(\"error\");\n-    /// assert_eq!(x.unwrap_or(optb), optb);\n+    /// assert_eq!(x.unwrap_or(default), default);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or(self, optb: T) -> T {\n+    pub fn unwrap_or(self, default: T) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(_) => optb,\n+            Err(_) => default,\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an [`Ok`].\n-    /// If the value is an [`Err`] then it calls `op` with its value.\n+    /// Returns the contained [`Ok`] value or computes it from a closure.\n     ///\n     /// [`Ok`]: enum.Result.html#variant.Ok\n-    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -937,7 +934,44 @@ impl<T: Clone, E> Result<&mut T, E> {\n }\n \n impl<T, E: fmt::Debug> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an [`Ok`].\n+    /// Returns the contained [`Ok`] value, consuming the `self` value.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is an [`Err`], with a panic message including the\n+    /// passed message, and the content of the [`Err`].\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```{.should_panic}\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n+    /// ```\n+    #[inline]\n+    #[track_caller]\n+    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n+    pub fn expect(self, msg: &str) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(e) => unwrap_failed(msg, &e),\n+        }\n+    }\n+\n+    /// Returns the contained [`Ok`] value, consuming the `self` value.\n+    ///\n+    /// Because this function may panic, its use is generally discouraged.\n+    /// Instead, prefer to use pattern matching and handle the [`Err`]\n+    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n+    /// [`unwrap_or_default`].\n+    ///\n+    /// [`unwrap_or`]: #method.unwrap_or\n+    /// [`unwrap_or_else`]: #method.unwrap_or_else\n+    /// [`unwrap_or_default`]: #method.unwrap_or_default\n     ///\n     /// # Panics\n     ///\n@@ -969,13 +1003,15 @@ impl<T, E: fmt::Debug> Result<T, E> {\n             Err(e) => unwrap_failed(\"called `Result::unwrap()` on an `Err` value\", &e),\n         }\n     }\n+}\n \n-    /// Unwraps a result, yielding the content of an [`Ok`].\n+impl<T: fmt::Debug, E> Result<T, E> {\n+    /// Returns the contained [`Err`] value, consuming the `self` value.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an [`Err`], with a panic message including the\n-    /// passed message, and the content of the [`Err`].\n+    /// Panics if the value is an [`Ok`], with a panic message including the\n+    /// passed message, and the content of the [`Ok`].\n     ///\n     /// [`Ok`]: enum.Result.html#variant.Ok\n     /// [`Err`]: enum.Result.html#variant.Err\n@@ -985,22 +1021,20 @@ impl<T, E: fmt::Debug> Result<T, E> {\n     /// Basic usage:\n     ///\n     /// ```{.should_panic}\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n+    /// let x: Result<u32, &str> = Ok(10);\n+    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n     /// ```\n     #[inline]\n     #[track_caller]\n-    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n-    pub fn expect(self, msg: &str) -> T {\n+    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n+    pub fn expect_err(self, msg: &str) -> E {\n         match self {\n-            Ok(t) => t,\n-            Err(e) => unwrap_failed(msg, &e),\n+            Ok(t) => unwrap_failed(msg, &t),\n+            Err(e) => e,\n         }\n     }\n-}\n \n-impl<T: fmt::Debug, E> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an [`Err`].\n+    /// Returns the contained [`Err`] value, consuming the `self` value.\n     ///\n     /// # Panics\n     ///\n@@ -1031,38 +1065,10 @@ impl<T: fmt::Debug, E> Result<T, E> {\n             Err(e) => e,\n         }\n     }\n-\n-    /// Unwraps a result, yielding the content of an [`Err`].\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the value is an [`Ok`], with a panic message including the\n-    /// passed message, and the content of the [`Ok`].\n-    ///\n-    /// [`Ok`]: enum.Result.html#variant.Ok\n-    /// [`Err`]: enum.Result.html#variant.Err\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```{.should_panic}\n-    /// let x: Result<u32, &str> = Ok(10);\n-    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n-    /// ```\n-    #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n-    pub fn expect_err(self, msg: &str) -> E {\n-        match self {\n-            Ok(t) => unwrap_failed(msg, &t),\n-            Err(e) => e,\n-        }\n-    }\n }\n \n impl<T: Default, E> Result<T, E> {\n-    /// Returns the contained value or a default\n+    /// Returns the contained [`Ok`] value or a default\n     ///\n     /// Consumes the `self` argument then, if [`Ok`], returns the contained\n     /// value, otherwise if [`Err`], returns the default value for that\n@@ -1101,7 +1107,7 @@ impl<T: Default, E> Result<T, E> {\n \n #[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n impl<T, E: Into<!>> Result<T, E> {\n-    /// Unwraps a result that can never be an [`Err`], yielding the content of the [`Ok`].\n+    /// Returns the contained [`Ok`] value, but never panics.\n     ///\n     /// Unlike [`unwrap`], this method is known to never panic on the\n     /// result types it is implemented for. Therefore, it can be used"}, {"sha": "76e4b5f01b775cd4c099ccac8f6c7e6c938e9bd2", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -249,6 +249,12 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n         self.hash_spans\n     }\n \n+    #[inline]\n+    fn hash_def_id(&mut self, def_id: DefId, hasher: &mut StableHasher) {\n+        let hcx = self;\n+        hcx.def_path_hash(def_id).hash_stable(hcx, hasher);\n+    }\n+\n     fn byte_pos_to_line_and_col(\n         &mut self,\n         byte: BytePos,"}, {"sha": "625d8a4670f22fce83f194d156f3913288fa5b62", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -11,12 +11,6 @@ use smallvec::SmallVec;\n use std::mem;\n \n impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n-    #[inline]\n-    fn hash_def_id(&mut self, def_id: DefId, hasher: &mut StableHasher) {\n-        let hcx = self;\n-        hcx.def_path_hash(def_id).hash_stable(hcx, hasher);\n-    }\n-\n     #[inline]\n     fn hash_hir_id(&mut self, hir_id: hir::HirId, hasher: &mut StableHasher) {\n         let hcx = self;"}, {"sha": "25bb54033f16575ca0654aeba0a48f5cc4597bb5", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -50,7 +50,9 @@ pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::project::MismatchedProjectionTypes;\n-pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n+pub use self::project::{\n+    normalize, normalize_projection_type, normalize_to, poly_project_and_unify_type,\n+};\n pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot};\n pub use self::select::{IntercrateAmbiguityCause, SelectionContext};\n pub use self::specialize::find_associated_item;"}, {"sha": "a1d785cf4447a5cda172f001bf871530957298b8", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 59, "deletions": 22, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -216,7 +216,22 @@ pub fn normalize<'a, 'b, 'tcx, T>(\n where\n     T: TypeFoldable<'tcx>,\n {\n-    normalize_with_depth(selcx, param_env, cause, 0, value)\n+    let mut obligations = Vec::new();\n+    let value = normalize_to(selcx, param_env, cause, value, &mut obligations);\n+    Normalized { value, obligations }\n+}\n+\n+pub fn normalize_to<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    value: &T,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    normalize_with_depth_to(selcx, param_env, cause, 0, value, obligations)\n }\n \n /// As `normalize`, but with a custom depth.\n@@ -227,11 +242,27 @@ pub fn normalize_with_depth<'a, 'b, 'tcx, T>(\n     depth: usize,\n     value: &T,\n ) -> Normalized<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    let mut obligations = Vec::new();\n+    let value = normalize_with_depth_to(selcx, param_env, cause, depth, value, &mut obligations);\n+    Normalized { value, obligations }\n+}\n+\n+pub fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    value: &T,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n     debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n-    let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth);\n+    let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth, obligations);\n     let result = normalizer.fold(value);\n     debug!(\n         \"normalize_with_depth: depth={} result={:?} with {} obligations\",\n@@ -240,14 +271,14 @@ where\n         normalizer.obligations.len()\n     );\n     debug!(\"normalize_with_depth: depth={} obligations={:?}\", depth, normalizer.obligations);\n-    Normalized { value: result, obligations: normalizer.obligations }\n+    result\n }\n \n struct AssocTypeNormalizer<'a, 'b, 'tcx> {\n     selcx: &'a mut SelectionContext<'b, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    obligations: Vec<PredicateObligation<'tcx>>,\n+    obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n     depth: usize,\n }\n \n@@ -257,8 +288,9 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         cause: ObligationCause<'tcx>,\n         depth: usize,\n+        obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n     ) -> AssocTypeNormalizer<'a, 'b, 'tcx> {\n-        AssocTypeNormalizer { selcx, param_env, cause, obligations: vec![], depth }\n+        AssocTypeNormalizer { selcx, param_env, cause, obligations, depth }\n     }\n \n     fn fold<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n@@ -343,7 +375,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                 );\n                 debug!(\n                     \"AssocTypeNormalizer: depth={} normalized {:?} to {:?}, \\\n-                        now with {} obligations\",\n+                     now with {} obligations\",\n                     self.depth,\n                     ty,\n                     normalized_ty,\n@@ -441,8 +473,8 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n \n     debug!(\n         \"opt_normalize_projection_type(\\\n-           projection_ty={:?}, \\\n-           depth={})\",\n+         projection_ty={:?}, \\\n+         depth={})\",\n         projection_ty, depth\n     );\n \n@@ -469,7 +501,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // changes\n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    found cache entry: ambiguous\"\n+                 found cache entry: ambiguous\"\n             );\n             if !projection_ty.has_closure_types() {\n                 return None;\n@@ -498,7 +530,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n \n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    found cache entry: in-progress\"\n+                 found cache entry: in-progress\"\n             );\n \n             // But for now, let's classify this as an overflow:\n@@ -521,7 +553,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // evaluations can causes ICEs (e.g., #43132).\n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    found normalized ty `{:?}`\",\n+                 found normalized ty `{:?}`\",\n                 ty\n             );\n \n@@ -546,7 +578,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n         Err(ProjectionCacheEntry::Error) => {\n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    found error\"\n+                 found error\"\n             );\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n@@ -567,23 +599,28 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n \n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    projected_ty={:?} \\\n-                    depth={} \\\n-                    projected_obligations={:?}\",\n+                 projected_ty={:?} \\\n+                 depth={} \\\n+                 projected_obligations={:?}\",\n                 projected_ty, depth, projected_obligations\n             );\n \n             let result = if projected_ty.has_projections() {\n-                let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth + 1);\n+                let mut normalizer = AssocTypeNormalizer::new(\n+                    selcx,\n+                    param_env,\n+                    cause,\n+                    depth + 1,\n+                    &mut projected_obligations,\n+                );\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n                 debug!(\n                     \"opt_normalize_projection_type: \\\n-                        normalized_ty={:?} depth={}\",\n+                     normalized_ty={:?} depth={}\",\n                     normalized_ty, depth\n                 );\n \n-                projected_obligations.extend(normalizer.obligations);\n                 Normalized { value: normalized_ty, obligations: projected_obligations }\n             } else {\n                 Normalized { value: projected_ty, obligations: projected_obligations }\n@@ -597,7 +634,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    projected_ty={:?} no progress\",\n+                 projected_ty={:?} no progress\",\n                 projected_ty\n             );\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n@@ -608,7 +645,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n         Err(ProjectionTyError::TooManyCandidates) => {\n             debug!(\n                 \"opt_normalize_projection_type: \\\n-                    too many candidates\"\n+                 too many candidates\"\n             );\n             infcx.projection_cache.borrow_mut().ambiguous(cache_key);\n             None\n@@ -930,7 +967,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx, I>(\n \n             debug!(\n                 \"assemble_candidates_from_predicates: candidate={:?} \\\n-                    is_match={} same_def_id={}\",\n+                 is_match={} same_def_id={}\",\n                 data, is_match, same_def_id\n             );\n \n@@ -1192,7 +1229,7 @@ fn confirm_object_candidate<'cx, 'tcx>(\n             None => {\n                 debug!(\n                     \"confirm_object_candidate: no env-predicate \\\n-                        found in object type `{:?}`; ill-formed\",\n+                     found in object type `{:?}`; ill-formed\",\n                     object_ty\n                 );\n                 return Progress::error(selcx.tcx());"}, {"sha": "26f2a4ddb385a4b9c1fca59a9834a9d1949cd39f", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -9,7 +9,9 @@ use self::SelectionCandidate::*;\n \n use super::coherence::{self, Conflict};\n use super::project;\n-use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n+use super::project::{\n+    normalize_with_depth, normalize_with_depth_to, Normalized, ProjectionCacheKey,\n+};\n use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n@@ -1019,7 +1021,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let Some(value) = value {\n                             debug!(\n                                 \"filter_negative_and_reservation_impls: \\\n-                                    reservation impl ambiguity on {:?}\",\n+                                 reservation impl ambiguity on {:?}\",\n                                 def_id\n                             );\n                             intercrate_ambiguity_clauses.push(\n@@ -1317,7 +1319,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if !self.can_cache_candidate(&candidate) {\n             debug!(\n                 \"insert_candidate_cache(trait_ref={:?}, candidate={:?} -\\\n-                    candidate is not cacheable\",\n+                 candidate is not cacheable\",\n                 trait_ref, candidate\n             );\n             return;\n@@ -3484,25 +3486,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // that order.\n         let predicates = tcx.predicates_of(def_id);\n         assert_eq!(predicates.parent, None);\n-        let mut predicates: Vec<_> = predicates\n-            .predicates\n-            .iter()\n-            .flat_map(|(predicate, _)| {\n-                let predicate = normalize_with_depth(\n-                    self,\n-                    param_env,\n-                    cause.clone(),\n-                    recursion_depth,\n-                    &predicate.subst(tcx, substs),\n-                );\n-                predicate.obligations.into_iter().chain(Some(Obligation {\n-                    cause: cause.clone(),\n-                    recursion_depth,\n-                    param_env,\n-                    predicate: predicate.value,\n-                }))\n-            })\n-            .collect();\n+        let mut obligations = Vec::new();\n+        for (predicate, _) in predicates.predicates {\n+            let predicate = normalize_with_depth_to(\n+                self,\n+                param_env,\n+                cause.clone(),\n+                recursion_depth,\n+                &predicate.subst(tcx, substs),\n+                &mut obligations,\n+            );\n+            obligations.push(Obligation {\n+                cause: cause.clone(),\n+                recursion_depth,\n+                param_env,\n+                predicate,\n+            });\n+        }\n \n         // We are performing deduplication here to avoid exponential blowups\n         // (#38528) from happening, but the real cause of the duplication is\n@@ -3513,20 +3513,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // This code is hot enough that it's worth avoiding the allocation\n         // required for the FxHashSet when possible. Special-casing lengths 0,\n         // 1 and 2 covers roughly 75-80% of the cases.\n-        if predicates.len() <= 1 {\n+        if obligations.len() <= 1 {\n             // No possibility of duplicates.\n-        } else if predicates.len() == 2 {\n+        } else if obligations.len() == 2 {\n             // Only two elements. Drop the second if they are equal.\n-            if predicates[0] == predicates[1] {\n-                predicates.truncate(1);\n+            if obligations[0] == obligations[1] {\n+                obligations.truncate(1);\n             }\n         } else {\n             // Three or more elements. Use a general deduplication process.\n             let mut seen = FxHashSet::default();\n-            predicates.retain(|i| seen.insert(i.clone()));\n+            obligations.retain(|i| seen.insert(i.clone()));\n         }\n \n-        predicates\n+        obligations\n     }\n }\n "}, {"sha": "fbcb77a403183ef41351525ba78376b980ae9eb8", "filename": "src/librustc/traits/wf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fwf.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -8,7 +8,6 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n-use std::iter::once;\n \n /// Returns the set of obligations needed to make `ty` well-formed.\n /// If `ty` contains unresolved inference variables, this may include\n@@ -26,6 +25,7 @@ pub fn obligations<'a, 'tcx>(\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n     if wf.compute(ty) {\n         debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", ty, body_id, wf.out);\n+\n         let result = wf.normalize();\n         debug!(\"wf::obligations({:?}, body_id={:?}) ~~> {:?}\", ty, body_id, result);\n         Some(result)\n@@ -143,15 +143,15 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let cause = self.cause(traits::MiscObligation);\n         let infcx = &mut self.infcx;\n         let param_env = self.param_env;\n-        self.out\n-            .iter()\n-            .inspect(|pred| assert!(!pred.has_escaping_bound_vars()))\n-            .flat_map(|pred| {\n-                let mut selcx = traits::SelectionContext::new(infcx);\n-                let pred = traits::normalize(&mut selcx, param_env, cause.clone(), pred);\n-                once(pred.value).chain(pred.obligations)\n-            })\n-            .collect()\n+        let mut obligations = Vec::new();\n+        self.out.iter().inspect(|pred| assert!(!pred.has_escaping_bound_vars())).for_each(|pred| {\n+            let mut selcx = traits::SelectionContext::new(infcx);\n+            let i = obligations.len();\n+            let value =\n+                traits::normalize_to(&mut selcx, param_env, cause.clone(), pred, &mut obligations);\n+            obligations.insert(i, value);\n+        });\n+        obligations\n     }\n \n     /// Pushes the obligations required for `trait_ref` to be WF into `self.out`."}, {"sha": "cdb9657e1ff3c3b294b1a57068e3ebc59f8ab86b", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -66,14 +66,8 @@ fn make_mir_scope(\n     if !has_variables.contains(scope) {\n         // Do not create a DIScope if there are no variables\n         // defined in this MIR Scope, to avoid debuginfo bloat.\n-\n-        // However, we don't skip creating a nested scope if\n-        // our parent is the root, because we might want to\n-        // put arguments in the root and not have shadowing.\n-        if parent_scope.scope_metadata.unwrap() != fn_metadata {\n-            debug_context.scopes[scope] = parent_scope;\n-            return;\n-        }\n+        debug_context.scopes[scope] = parent_scope;\n+        return;\n     }\n \n     let loc = span_start(cx, scope_data.span);"}, {"sha": "c1a7bb50878243fb6d2862263ea94c5cf2deb1ab", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -5,7 +5,6 @@ use rustc_codegen_ssa::mir::debuginfo::VariableKind::*;\n \n use self::metadata::{file_metadata, type_metadata, TypeMap};\n use self::namespace::mangled_name_of_instance;\n-use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n use self::type_names::compute_debuginfo_type_name;\n use self::utils::{create_DIArray, is_node_local_to_unit, span_start, DIB};\n \n@@ -38,7 +37,7 @@ use std::ffi::CString;\n use rustc::ty::layout::{self, HasTyCtxt, LayoutOf, Size};\n use rustc_codegen_ssa::traits::*;\n use rustc_span::symbol::Symbol;\n-use rustc_span::{self, BytePos, Pos, Span};\n+use rustc_span::{self, BytePos, Span};\n use smallvec::SmallVec;\n use syntax::ast;\n \n@@ -52,7 +51,6 @@ mod utils;\n pub use self::create_scope_map::compute_mir_scopes;\n pub use self::metadata::create_global_var_metadata;\n pub use self::metadata::extend_scope_to_file;\n-pub use self::source_loc::set_source_location;\n \n #[allow(non_upper_case_globals)]\n const DW_TAG_auto_variable: c_uint = 0x100;\n@@ -148,20 +146,18 @@ impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n     // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n     fn dbg_var_addr(\n         &mut self,\n-        dbg_context: &FunctionDebugContext<&'ll DIScope>,\n         dbg_var: &'ll DIVariable,\n         scope_metadata: &'ll DIScope,\n         variable_alloca: Self::Value,\n         direct_offset: Size,\n         indirect_offsets: &[Size],\n         span: Span,\n     ) {\n-        assert!(!dbg_context.source_locations_enabled);\n         let cx = self.cx();\n \n-        let loc = span_start(cx, span);\n-\n         // Convert the direct and indirect offsets to address ops.\n+        // FIXME(eddyb) use `const`s instead of getting the values via FFI,\n+        // the values should match the ones in the DWARF standard anyway.\n         let op_deref = || unsafe { llvm::LLVMRustDIBuilderCreateOpDeref() };\n         let op_plus_uconst = || unsafe { llvm::LLVMRustDIBuilderCreateOpPlusUconst() };\n         let mut addr_ops = SmallVec::<[_; 8]>::new();\n@@ -178,37 +174,32 @@ impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n             }\n         }\n \n-        // FIXME(eddyb) maybe this information could be extracted from `var`,\n+        // FIXME(eddyb) maybe this information could be extracted from `dbg_var`,\n         // to avoid having to pass it down in both places?\n-        source_loc::set_debug_location(\n-            self,\n-            InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()),\n-        );\n+        // NB: `var` doesn't seem to know about the column, so that's a limitation.\n+        let dbg_loc = cx.create_debug_loc(scope_metadata, span);\n         unsafe {\n-            let debug_loc = llvm::LLVMGetCurrentDebugLocation(self.llbuilder);\n             // FIXME(eddyb) replace `llvm.dbg.declare` with `llvm.dbg.addr`.\n-            let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n+            llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n                 DIB(cx),\n                 variable_alloca,\n                 dbg_var,\n                 addr_ops.as_ptr(),\n                 addr_ops.len() as c_uint,\n-                debug_loc,\n+                dbg_loc,\n                 self.llbb(),\n             );\n-\n-            llvm::LLVMSetInstDebugLocation(self.llbuilder, instr);\n         }\n-        source_loc::set_debug_location(self, UnknownLocation);\n     }\n \n-    fn set_source_location(\n-        &mut self,\n-        debug_context: &mut FunctionDebugContext<&'ll DIScope>,\n-        scope: &'ll DIScope,\n-        span: Span,\n-    ) {\n-        set_source_location(debug_context, &self, scope, span)\n+    fn set_source_location(&mut self, scope: &'ll DIScope, span: Span) {\n+        debug!(\"set_source_location: {}\", self.sess().source_map().span_to_string(span));\n+\n+        let dbg_loc = self.cx().create_debug_loc(scope, span);\n+\n+        unsafe {\n+            llvm::LLVMSetCurrentDebugLocation(self.llbuilder, dbg_loc);\n+        }\n     }\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self) {\n         gdb::insert_reference_to_gdb_debug_scripts_section_global(self)\n@@ -342,7 +333,6 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         };\n         let mut fn_debug_context = FunctionDebugContext {\n             scopes: IndexVec::from_elem(null_scope, &mir.source_scopes),\n-            source_locations_enabled: false,\n             defining_crate: def_id.krate,\n         };\n "}, {"sha": "1f871c7d207a41acc5dd160c9f9086f45b7bddcd", "filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs", "status": "modified", "additions": 23, "deletions": 67, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fsource_loc.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -1,79 +1,35 @@\n-use self::InternalDebugLocation::*;\n-\n use super::metadata::UNKNOWN_COLUMN_NUMBER;\n use super::utils::{debug_context, span_start};\n-use rustc_codegen_ssa::mir::debuginfo::FunctionDebugContext;\n \n-use crate::builder::Builder;\n-use crate::llvm;\n+use crate::common::CodegenCx;\n use crate::llvm::debuginfo::DIScope;\n-use log::debug;\n+use crate::llvm::{self, Value};\n use rustc_codegen_ssa::traits::*;\n \n use libc::c_uint;\n use rustc_span::{Pos, Span};\n \n-/// Sets the current debug location at the beginning of the span.\n-///\n-/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...).\n-pub fn set_source_location<D>(\n-    debug_context: &FunctionDebugContext<D>,\n-    bx: &Builder<'_, 'll, '_>,\n-    scope: &'ll DIScope,\n-    span: Span,\n-) {\n-    let dbg_loc = if debug_context.source_locations_enabled {\n-        debug!(\"set_source_location: {}\", bx.sess().source_map().span_to_string(span));\n-        let loc = span_start(bx.cx(), span);\n-        InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n-    } else {\n-        UnknownLocation\n-    };\n-    set_debug_location(bx, dbg_loc);\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum InternalDebugLocation<'ll> {\n-    KnownLocation { scope: &'ll DIScope, line: usize, col: usize },\n-    UnknownLocation,\n-}\n-\n-impl InternalDebugLocation<'ll> {\n-    pub fn new(scope: &'ll DIScope, line: usize, col: usize) -> Self {\n-        KnownLocation { scope, line, col }\n-    }\n-}\n-\n-pub fn set_debug_location(bx: &Builder<'_, 'll, '_>, debug_location: InternalDebugLocation<'ll>) {\n-    let metadata_node = match debug_location {\n-        KnownLocation { scope, line, col } => {\n-            // For MSVC, set the column number to zero.\n-            // Otherwise, emit it. This mimics clang behaviour.\n-            // See discussion in https://github.com/rust-lang/rust/issues/42921\n-            let col_used = if bx.sess().target.target.options.is_like_msvc {\n-                UNKNOWN_COLUMN_NUMBER\n-            } else {\n-                col as c_uint\n-            };\n-            debug!(\"setting debug location to {} {}\", line, col);\n-\n-            unsafe {\n-                Some(llvm::LLVMRustDIBuilderCreateDebugLocation(\n-                    debug_context(bx.cx()).llcontext,\n-                    line as c_uint,\n-                    col_used,\n-                    scope,\n-                    None,\n-                ))\n-            }\n+impl CodegenCx<'ll, '_> {\n+    pub fn create_debug_loc(&self, scope: &'ll DIScope, span: Span) -> &'ll Value {\n+        let loc = span_start(self, span);\n+\n+        // For MSVC, set the column number to zero.\n+        // Otherwise, emit it. This mimics clang behaviour.\n+        // See discussion in https://github.com/rust-lang/rust/issues/42921\n+        let col_used = if self.sess().target.target.options.is_like_msvc {\n+            UNKNOWN_COLUMN_NUMBER\n+        } else {\n+            loc.col.to_usize() as c_uint\n+        };\n+\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateDebugLocation(\n+                debug_context(self).llcontext,\n+                loc.line as c_uint,\n+                col_used,\n+                scope,\n+                None,\n+            )\n         }\n-        UnknownLocation => {\n-            debug!(\"clearing debug location \");\n-            None\n-        }\n-    };\n-\n-    unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(bx.llbuilder, metadata_node);\n     }\n }"}, {"sha": "146b7d3d76c5e1c394bda5ed32d5931229b57b0b", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -909,9 +909,7 @@ extern \"C\" {\n     pub fn LLVMDisposeBuilder(Builder: &'a mut Builder<'a>);\n \n     // Metadata\n-    pub fn LLVMSetCurrentDebugLocation(Builder: &Builder<'a>, L: Option<&'a Value>);\n-    pub fn LLVMGetCurrentDebugLocation(Builder: &Builder<'a>) -> &'a Value;\n-    pub fn LLVMSetInstDebugLocation(Builder: &Builder<'a>, Inst: &'a Value);\n+    pub fn LLVMSetCurrentDebugLocation(Builder: &Builder<'a>, L: &'a Value);\n \n     // Terminators\n     pub fn LLVMBuildRetVoid(B: &Builder<'a>) -> &'a Value;"}, {"sha": "e3e7f91071713dd6543cd2ee4b4adc441e4b662f", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -14,7 +14,6 @@ use super::{FunctionCx, LocalRef};\n \n pub struct FunctionDebugContext<D> {\n     pub scopes: IndexVec<mir::SourceScope, DebugScope<D>>,\n-    pub source_locations_enabled: bool,\n     pub defining_crate: CrateNum,\n }\n \n@@ -53,11 +52,10 @@ impl<D> DebugScope<D> {\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n-    pub fn set_debug_loc(&mut self, bx: &mut Bx, source_info: mir::SourceInfo) {\n+    pub fn set_debug_loc(&self, bx: &mut Bx, source_info: mir::SourceInfo) {\n         let (scope, span) = self.debug_loc(source_info);\n-        if let Some(debug_context) = &mut self.debug_context {\n-            // FIXME(eddyb) get rid of this unwrap somehow.\n-            bx.set_source_location(debug_context, scope.unwrap(), span);\n+        if let Some(scope) = scope {\n+            bx.set_source_location(scope, span);\n         }\n     }\n \n@@ -210,11 +208,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n \n-        let debug_context = match &self.debug_context {\n-            Some(debug_context) => debug_context,\n-            None => return,\n-        };\n-\n         // FIXME(eddyb) add debuginfo for unsized places too.\n         let base = match local_ref {\n             LocalRef::Place(place) => place,\n@@ -264,7 +257,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             if let Some(scope) = scope {\n                 if let Some(dbg_var) = var.dbg_var {\n                     bx.dbg_var_addr(\n-                        debug_context,\n                         dbg_var,\n                         scope,\n                         base.llval,"}, {"sha": "64ead19b358697501b8a57fd22b59dcba72eec58", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -230,13 +230,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         bx.br(fx.blocks[mir::START_BLOCK]);\n     }\n \n-    // Up until here, IR instructions for this function have explicitly not been annotated with\n-    // source code location, so we don't step into call setup code. From here on, source location\n-    // emitting should be enabled.\n-    if let Some(debug_context) = &mut fx.debug_context {\n-        debug_context.source_locations_enabled = true;\n-    }\n-\n     let rpo = traversal::reverse_postorder(&mir_body);\n     let mut visited = BitSet::new_empty(mir_body.basic_blocks().len());\n "}, {"sha": "3688ae51b391819979ff3350cd66c8855a212e06", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -49,7 +49,6 @@ pub trait DebugInfoBuilderMethods: BackendTypes {\n     // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n     fn dbg_var_addr(\n         &mut self,\n-        dbg_context: &FunctionDebugContext<Self::DIScope>,\n         dbg_var: Self::DIVariable,\n         scope_metadata: Self::DIScope,\n         variable_alloca: Self::Value,\n@@ -58,12 +57,7 @@ pub trait DebugInfoBuilderMethods: BackendTypes {\n         indirect_offsets: &[Size],\n         span: Span,\n     );\n-    fn set_source_location(\n-        &mut self,\n-        debug_context: &mut FunctionDebugContext<Self::DIScope>,\n-        scope: Self::DIScope,\n-        span: Span,\n-    );\n+    fn set_source_location(&mut self, scope: Self::DIScope, span: Span);\n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self);\n     fn set_var_name(&mut self, value: Self::Value, name: &str);\n }"}, {"sha": "2e2cd5e01fb6a6cface9126163080c8748676708", "filename": "src/librustc_error_codes/error_codes/E0277.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -1,5 +1,7 @@\n You tried to use a type which doesn't implement some trait in a place which\n-expected that trait. Erroneous code example:\n+expected that trait.\n+\n+Erroneous code example:\n \n ```compile_fail,E0277\n // here we declare the Foo trait with a bar method"}, {"sha": "49d2205f92c2a52dbb255a165c3a9bc8f8894495", "filename": "src/librustc_error_codes/error_codes/E0282.md", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -1,3 +1,11 @@\n+The compiler could not infer a type and asked for a type annotation.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0282\n+let x = \"hello\".chars().rev().collect();\n+```\n+\n This error indicates that type inference did not result in one unique possible\n type, and extra information is required. In most cases this can be provided\n by adding a type annotation. Sometimes you need to specify a generic type\n@@ -8,13 +16,9 @@ parameter with a `FromIterator` bound, which for a `char` iterator is\n implemented by `Vec` and `String` among others. Consider the following snippet\n that reverses the characters of a string:\n \n-```compile_fail,E0282\n-let x = \"hello\".chars().rev().collect();\n-```\n-\n-In this case, the compiler cannot infer what the type of `x` should be:\n-`Vec<char>` and `String` are both suitable candidates. To specify which type to\n-use, you can use a type annotation on `x`:\n+In the first code example, the compiler cannot infer what the type of `x` should\n+be: `Vec<char>` and `String` are both suitable candidates. To specify which type\n+to use, you can use a type annotation on `x`:\n \n ```\n let x: Vec<char> = \"hello\".chars().rev().collect();"}, {"sha": "e4edd34bd6e23724d54a777054ce1edd731e7174", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -12,7 +12,7 @@\n extern crate rustc_data_structures;\n \n pub mod def;\n-pub mod def_id;\n+pub use rustc_span::def_id;\n mod hir;\n pub mod hir_id;\n pub mod intravisit;"}, {"sha": "e8407b537011bf64655ce230cca5c6161150749c", "filename": "src/librustc_hir/stable_hash_impls.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_hir%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_hir%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fstable_hash_impls.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -1,14 +1,12 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n-use crate::def_id::DefId;\n use crate::hir::{BodyId, Expr, ImplItemId, ItemId, Mod, TraitItemId, Ty, VisibilityKind};\n use crate::hir_id::HirId;\n \n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n /// instead of implementing everything in librustc.\n pub trait HashStableContext: syntax::HashStableContext + rustc_target::HashStableContext {\n-    fn hash_def_id(&mut self, _: DefId, hasher: &mut StableHasher);\n     fn hash_hir_id(&mut self, _: HirId, hasher: &mut StableHasher);\n     fn hash_body_id(&mut self, _: BodyId, hasher: &mut StableHasher);\n     fn hash_reference_to_item(&mut self, _: HirId, hasher: &mut StableHasher);\n@@ -24,12 +22,6 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for HirId {\n     }\n }\n \n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for DefId {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        hcx.hash_def_id(*self, hasher)\n-    }\n-}\n-\n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for BodyId {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n         hcx.hash_body_id(*self, hasher)"}, {"sha": "6cdfd0500ca844a0e19bc4f10919e03d92a85ec3", "filename": "src/librustc_span/def_id.rs", "status": "renamed", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_span%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_span%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fdef_id.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -1,3 +1,5 @@\n+use crate::HashStableContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::AtomicRef;\n use rustc_index::vec::Idx;\n use rustc_serialize::{Decoder, Encoder};\n@@ -18,15 +20,6 @@ pub enum CrateNum {\n     Index(CrateId),\n }\n \n-impl ::std::fmt::Debug for CrateNum {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n-        match self {\n-            CrateNum::Index(id) => write!(fmt, \"crate{}\", id.private),\n-            CrateNum::ReservedForIncrCompCache => write!(fmt, \"crate for decoding incr comp cache\"),\n-        }\n-    }\n-}\n-\n /// Item definitions in the currently-compiled crate would have the `CrateNum`\n /// `LOCAL_CRATE` in their `DefId`.\n pub const LOCAL_CRATE: CrateNum = CrateNum::Index(CrateId::from_u32_const(0));\n@@ -100,6 +93,15 @@ impl rustc_serialize::UseSpecializedDecodable for CrateNum {\n     }\n }\n \n+impl ::std::fmt::Debug for CrateNum {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n+        match self {\n+            CrateNum::Index(id) => write!(fmt, \"crate{}\", id.private),\n+            CrateNum::ReservedForIncrCompCache => write!(fmt, \"crate for decoding incr comp cache\"),\n+        }\n+    }\n+}\n+\n rustc_index::newtype_index! {\n     /// A DefIndex is an index into the hir-map for a crate, identifying a\n     /// particular definition. It should really be considered an interned\n@@ -207,3 +209,9 @@ impl fmt::Debug for LocalDefId {\n \n impl rustc_serialize::UseSpecializedEncodable for LocalDefId {}\n impl rustc_serialize::UseSpecializedDecodable for LocalDefId {}\n+\n+impl<CTX: HashStableContext> HashStable<CTX> for DefId {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        hcx.hash_def_id(*self, hasher)\n+    }\n+}", "previous_filename": "src/librustc_hir/def_id.rs"}, {"sha": "87342d6a301201998712e6863519445d426757e2", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dff769e3718c56f78a317df7167426d60895d58/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=6dff769e3718c56f78a317df7167426d60895d58", "patch": "@@ -25,7 +25,8 @@ use edition::Edition;\n pub mod hygiene;\n use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, MacroKind, SyntaxContext};\n-\n+pub mod def_id;\n+use def_id::DefId;\n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n \n@@ -1561,6 +1562,7 @@ fn lookup_line(lines: &[BytePos], pos: BytePos) -> isize {\n /// instead of implementing everything in librustc.\n pub trait HashStableContext {\n     fn hash_spans(&self) -> bool;\n+    fn hash_def_id(&mut self, _: DefId, hasher: &mut StableHasher);\n     fn byte_pos_to_line_and_col(\n         &mut self,\n         byte: BytePos,"}]}