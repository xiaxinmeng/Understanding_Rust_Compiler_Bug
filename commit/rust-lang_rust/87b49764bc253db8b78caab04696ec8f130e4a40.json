{"sha": "87b49764bc253db8b78caab04696ec8f130e4a40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YjQ5NzY0YmMyNTNkYjhiNzhjYWFiMDQ2OTZlYzhmMTMwZTRhNDA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-17T13:01:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-07-17T14:39:59Z"}, "message": "warn about uninit multi-variant enums", "tree": {"sha": "aba8ac928a40f815f2910eff0b1c40e3ad5195e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aba8ac928a40f815f2910eff0b1c40e3ad5195e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87b49764bc253db8b78caab04696ec8f130e4a40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87b49764bc253db8b78caab04696ec8f130e4a40", "html_url": "https://github.com/rust-lang/rust/commit/87b49764bc253db8b78caab04696ec8f130e4a40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87b49764bc253db8b78caab04696ec8f130e4a40/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50", "html_url": "https://github.com/rust-lang/rust/commit/c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50"}], "stats": {"total": 137, "additions": 96, "deletions": 41}, "files": [{"sha": "395428191b1be23eba78bc5e0c217aca7dcf6f80", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/87b49764bc253db8b78caab04696ec8f130e4a40/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b49764bc253db8b78caab04696ec8f130e4a40/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=87b49764bc253db8b78caab04696ec8f130e4a40", "patch": "@@ -1922,6 +1922,14 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             None\n         }\n \n+        /// Test if this enum has several actually \"existing\" variants.\n+        /// Zero-sized uninhabited variants do not always have a tag assigned and thus do not \"exist\".\n+        fn is_multi_variant(adt: &ty::AdtDef) -> bool {\n+            // As an approximation, we only count dataless variants. Those are definitely inhabited.\n+            let existing_variants = adt.variants.iter().filter(|v| v.fields.is_empty()).count();\n+            existing_variants > 1\n+        }\n+\n         /// Return `Some` only if we are sure this type does *not*\n         /// allow zero initialization.\n         fn ty_find_init_error<'tcx>(\n@@ -1950,7 +1958,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 }\n                 // Recurse and checks for some compound types.\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n-                    // First check f this ADT has a layout attribute (like `NonNull` and friends).\n+                    // First check if this ADT has a layout attribute (like `NonNull` and friends).\n                     use std::ops::Bound;\n                     match tcx.layout_scalar_valid_range(adt_def.did) {\n                         // We exploit here that `layout_scalar_valid_range` will never\n@@ -2001,10 +2009,20 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                                 )\n                             })\n                         }\n-                        // Multi-variant enums are tricky: if all but one variant are\n-                        // uninhabited, we might actually do layout like for a single-variant\n-                        // enum, and then even leaving them uninitialized could be okay.\n-                        _ => None, // Conservative fallback for multi-variant enum.\n+                        // Multi-variant enum.\n+                        _ => {\n+                            if init == InitKind::Uninit && is_multi_variant(adt_def) {\n+                                let span = tcx.def_span(adt_def.did);\n+                                Some((\n+                                    \"enums have to be initialized to a variant\".to_string(),\n+                                    Some(span),\n+                                ))\n+                            } else {\n+                                // In principle, for zero-initialization we could figure out which variant corresponds\n+                                // to tag 0, and check that... but for now we just accept all zero-initializations.\n+                                None\n+                            }\n+                        }\n                     }\n                 }\n                 Tuple(..) => {"}, {"sha": "78d3060886dd0e73cf33b5ab38af8b239570aed9", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/87b49764bc253db8b78caab04696ec8f130e4a40/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b49764bc253db8b78caab04696ec8f130e4a40/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=87b49764bc253db8b78caab04696ec8f130e4a40", "patch": "@@ -23,6 +23,18 @@ enum WrapEnum<T> { Wrapped(T) }\n #[repr(transparent)]\n pub(crate) struct NonBig(u64);\n \n+/// A two-variant enum, thus needs a tag and may not remain uninitialized.\n+enum Fruit {\n+    Apple,\n+    Banana,\n+}\n+\n+/// Looks like two variants but really only has one.\n+enum OneFruit {\n+    Apple(!),\n+    Banana,\n+}\n+\n #[allow(unused)]\n fn generic<T: 'static>() {\n     unsafe {\n@@ -80,6 +92,9 @@ fn main() {\n         let _val: NonBig = mem::zeroed();\n         let _val: NonBig = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: Fruit = mem::zeroed();\n+        let _val: Fruit = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Transmute-from-0\n         let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n         let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n@@ -96,5 +111,9 @@ fn main() {\n         let _val: MaybeUninit<&'static i32> = mem::zeroed();\n         let _val: i32 = mem::zeroed();\n         let _val: bool = MaybeUninit::zeroed().assume_init();\n+        // Some things that happen to work due to rustc implementation details,\n+        // but are not guaranteed to keep working.\n+        let _val: i32 = mem::uninitialized();\n+        let _val: OneFruit = mem::uninitialized();\n     }\n }"}, {"sha": "3bf8a66ab0ae5268c2f4035de4eed89d32ee050e", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 54, "deletions": 36, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/87b49764bc253db8b78caab04696ec8f130e4a40/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87b49764bc253db8b78caab04696ec8f130e4a40/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=87b49764bc253db8b78caab04696ec8f130e4a40", "patch": "@@ -1,5 +1,5 @@\n error: the type `&T` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:29:32\n+  --> $DIR/uninitialized-zeroed.rs:41:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -15,7 +15,7 @@ LL | #![deny(invalid_value)]\n    = note: references must be non-null\n \n error: the type `&T` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:30:32\n+  --> $DIR/uninitialized-zeroed.rs:42:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Wrap<&T>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:32:38\n+  --> $DIR/uninitialized-zeroed.rs:44:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n@@ -41,7 +41,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<&T>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:33:38\n+  --> $DIR/uninitialized-zeroed.rs:45:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -56,7 +56,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:40:23\n+  --> $DIR/uninitialized-zeroed.rs:52:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n@@ -67,7 +67,7 @@ LL |         let _val: ! = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:41:23\n+  --> $DIR/uninitialized-zeroed.rs:53:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         let _val: ! = mem::uninitialized();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:43:30\n+  --> $DIR/uninitialized-zeroed.rs:55:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -89,7 +89,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:44:30\n+  --> $DIR/uninitialized-zeroed.rs:56:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +100,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    = note: the `!` type has no valid value\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:46:26\n+  --> $DIR/uninitialized-zeroed.rs:58:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -111,7 +111,7 @@ LL |         let _val: Void = mem::zeroed();\n    = note: enums with no variants have no valid value\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:47:26\n+  --> $DIR/uninitialized-zeroed.rs:59:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -122,7 +122,7 @@ LL |         let _val: Void = mem::uninitialized();\n    = note: enums with no variants have no valid value\n \n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:49:34\n+  --> $DIR/uninitialized-zeroed.rs:61:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -133,7 +133,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    = note: references must be non-null\n \n error: the type `&i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:50:34\n+  --> $DIR/uninitialized-zeroed.rs:62:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -144,7 +144,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:52:25\n+  --> $DIR/uninitialized-zeroed.rs:64:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n@@ -159,7 +159,7 @@ LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:53:25\n+  --> $DIR/uninitialized-zeroed.rs:65:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -174,7 +174,7 @@ LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:55:26\n+  --> $DIR/uninitialized-zeroed.rs:67:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -185,7 +185,7 @@ LL |         let _val: fn() = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:56:26\n+  --> $DIR/uninitialized-zeroed.rs:68:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -196,7 +196,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    = note: function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:58:32\n+  --> $DIR/uninitialized-zeroed.rs:70:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -211,7 +211,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:59:32\n+  --> $DIR/uninitialized-zeroed.rs:71:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -226,7 +226,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:61:36\n+  --> $DIR/uninitialized-zeroed.rs:73:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n@@ -241,7 +241,7 @@ LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:62:36\n+  --> $DIR/uninitialized-zeroed.rs:74:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n@@ -256,7 +256,7 @@ LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:64:42\n+  --> $DIR/uninitialized-zeroed.rs:76:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n@@ -271,7 +271,7 @@ LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:65:42\n+  --> $DIR/uninitialized-zeroed.rs:77:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n@@ -286,7 +286,7 @@ LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `std::ptr::NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:67:34\n+  --> $DIR/uninitialized-zeroed.rs:79:34\n    |\n LL |         let _val: NonNull<i32> = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -297,7 +297,7 @@ LL |         let _val: NonNull<i32> = mem::zeroed();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `std::ptr::NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:68:34\n+  --> $DIR/uninitialized-zeroed.rs:80:34\n    |\n LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -308,7 +308,7 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `*const dyn std::marker::Send` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:70:37\n+  --> $DIR/uninitialized-zeroed.rs:82:37\n    |\n LL |         let _val: *const dyn Send = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -319,7 +319,7 @@ LL |         let _val: *const dyn Send = mem::zeroed();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `*const dyn std::marker::Send` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:71:37\n+  --> $DIR/uninitialized-zeroed.rs:83:37\n    |\n LL |         let _val: *const dyn Send = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -330,7 +330,7 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:75:26\n+  --> $DIR/uninitialized-zeroed.rs:87:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -341,7 +341,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:78:32\n+  --> $DIR/uninitialized-zeroed.rs:90:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -356,7 +356,7 @@ LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:81:28\n+  --> $DIR/uninitialized-zeroed.rs:93:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -366,8 +366,26 @@ LL |         let _val: NonBig = mem::uninitialized();\n    |\n    = note: `NonBig` must be initialized inside its custom valid range\n \n+error: the type `Fruit` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:96:27\n+   |\n+LL |         let _val: Fruit = mem::uninitialized();\n+   |                           ^^^^^^^^^^^^^^^^^^^^\n+   |                           |\n+   |                           this code causes undefined behavior when executed\n+   |                           help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums have to be initialized to a variant\n+  --> $DIR/uninitialized-zeroed.rs:27:1\n+   |\n+LL | / enum Fruit {\n+LL | |     Apple,\n+LL | |     Banana,\n+LL | | }\n+   | |_^\n+\n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:84:34\n+  --> $DIR/uninitialized-zeroed.rs:99:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -378,7 +396,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: references must be non-null\n \n error: the type `&[i32]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:85:36\n+  --> $DIR/uninitialized-zeroed.rs:100:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -389,7 +407,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: references must be non-null\n \n error: the type `std::num::NonZeroU32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:86:32\n+  --> $DIR/uninitialized-zeroed.rs:101:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -400,7 +418,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `std::ptr::NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:89:34\n+  --> $DIR/uninitialized-zeroed.rs:104:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -411,7 +429,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `std::ptr::NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:90:34\n+  --> $DIR/uninitialized-zeroed.rs:105:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -422,7 +440,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:91:26\n+  --> $DIR/uninitialized-zeroed.rs:106:26\n    |\n LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -432,5 +450,5 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |\n    = note: booleans must be either `true` or `false`\n \n-error: aborting due to 35 previous errors\n+error: aborting due to 36 previous errors\n "}]}