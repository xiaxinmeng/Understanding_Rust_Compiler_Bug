{"sha": "bcefd688c99895275317eb95a1ec62743526208a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZWZkNjg4Yzk5ODk1Mjc1MzE3ZWI5NWExZWM2Mjc0MzUyNjIwOGE=", "commit": {"author": {"name": "Daniel Wagner-Hall", "email": "dawagner@gmail.com", "date": "2019-02-18T22:55:16Z"}, "committer": {"name": "Daniel Wagner-Hall", "email": "dawagner@gmail.com", "date": "2019-02-18T22:56:43Z"}, "message": "Restore tests\n\nAlso, fix existing test", "tree": {"sha": "7c07c370f8325c8b0cc22d943eb62e445012dc37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c07c370f8325c8b0cc22d943eb62e445012dc37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcefd688c99895275317eb95a1ec62743526208a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcefd688c99895275317eb95a1ec62743526208a", "html_url": "https://github.com/rust-lang/rust/commit/bcefd688c99895275317eb95a1ec62743526208a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcefd688c99895275317eb95a1ec62743526208a/comments", "author": {"login": "illicitonion", "id": 1131704, "node_id": "MDQ6VXNlcjExMzE3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1131704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/illicitonion", "html_url": "https://github.com/illicitonion", "followers_url": "https://api.github.com/users/illicitonion/followers", "following_url": "https://api.github.com/users/illicitonion/following{/other_user}", "gists_url": "https://api.github.com/users/illicitonion/gists{/gist_id}", "starred_url": "https://api.github.com/users/illicitonion/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/illicitonion/subscriptions", "organizations_url": "https://api.github.com/users/illicitonion/orgs", "repos_url": "https://api.github.com/users/illicitonion/repos", "events_url": "https://api.github.com/users/illicitonion/events{/privacy}", "received_events_url": "https://api.github.com/users/illicitonion/received_events", "type": "User", "site_admin": false}, "committer": {"login": "illicitonion", "id": 1131704, "node_id": "MDQ6VXNlcjExMzE3MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1131704?v=4", "gravatar_id": "", "url": "https://api.github.com/users/illicitonion", "html_url": "https://github.com/illicitonion", "followers_url": "https://api.github.com/users/illicitonion/followers", "following_url": "https://api.github.com/users/illicitonion/following{/other_user}", "gists_url": "https://api.github.com/users/illicitonion/gists{/gist_id}", "starred_url": "https://api.github.com/users/illicitonion/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/illicitonion/subscriptions", "organizations_url": "https://api.github.com/users/illicitonion/orgs", "repos_url": "https://api.github.com/users/illicitonion/repos", "events_url": "https://api.github.com/users/illicitonion/events{/privacy}", "received_events_url": "https://api.github.com/users/illicitonion/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3", "html_url": "https://github.com/rust-lang/rust/commit/422c9a0fa24bfbc9615d6cfe0bf314de91abb6e3"}], "stats": {"total": 159, "additions": 78, "deletions": 81}, "files": [{"sha": "3de1d01285ce3861e2d4c298d2145fb2997d9c02", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcefd688c99895275317eb95a1ec62743526208a/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcefd688c99895275317eb95a1ec62743526208a/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=bcefd688c99895275317eb95a1ec62743526208a", "patch": "@@ -537,6 +537,10 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n             })\n             .collect();\n \n+        if suggestion.is_empty() {\n+            return;\n+        }\n+\n         span_lint_and_sugg(\n             cx,\n             WILDCARD_ENUM_MATCH_ARM,"}, {"sha": "94d69d3c8a43e5a7f6d096463650ff16061c7187", "filename": "tests/ui/wildcard_enum_match_arm.rs", "status": "modified", "additions": 57, "deletions": 68, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/bcefd688c99895275317eb95a1ec62743526208a/tests%2Fui%2Fwildcard_enum_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcefd688c99895275317eb95a1ec62743526208a/tests%2Fui%2Fwildcard_enum_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.rs?ref=bcefd688c99895275317eb95a1ec62743526208a", "patch": "@@ -1,73 +1,62 @@\n-#![warn(clippy::wildcard_enum_match_arm)]\n-\n-#[derive(Debug)]\n-enum Maybe<T> {\n-    Some(T),\n-    Probably(T),\n-    None,\n-}\n-\n-fn is_it_wildcard<T>(m: Maybe<T>) -> &'static str {\n-    match m {\n-        Maybe::Some(_) => \"Some\",\n-        _ => \"Could be\",\n-    }\n-}\n-\n-fn is_it_bound<T>(m: Maybe<T>) -> &'static str {\n-    match m {\n-        Maybe::None => \"None\",\n-        _other => \"Could be\",\n-    }\n-}\n-\n-fn is_it_binding(m: Maybe<u32>) -> String {\n-    match m {\n-        Maybe::Some(v) => \"Large\".to_string(),\n-        n => format!(\"{:?}\", n),\n-    }\n-}\n-\n-fn is_it_binding_exhaustive(m: Maybe<u32>) -> String {\n-    match m {\n-        Maybe::Some(v) => \"Large\".to_string(),\n-        n @ Maybe::Probably(_) | n @ Maybe::None => format!(\"{:?}\", n),\n-    }\n-}\n-\n-fn is_it_with_guard(m: Maybe<u32>) -> &'static str {\n-    match m {\n-        Maybe::Some(v) if v > 100 => \"Large\",\n-        _ => \"Who knows\",\n-    }\n-}\n-\n-fn is_it_exhaustive<T>(m: Maybe<T>) -> &'static str {\n-    match m {\n-        Maybe::None => \"None\",\n-        Maybe::Some(_) | Maybe::Probably(..) => \"Could be\",\n-    }\n-}\n-\n-fn is_one_or_three(i: i32) -> bool {\n-    match i {\n-        1 | 3 => true,\n-        _ => false,\n+#![deny(clippy::wildcard_enum_match_arm)]\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+enum Color {\n+    Red,\n+    Green,\n+    Blue,\n+    Rgb(u8, u8, u8),\n+    Cyan,\n+}\n+\n+impl Color {\n+    fn is_monochrome(self) -> bool {\n+        match self {\n+            Color::Red | Color::Green | Color::Blue => true,\n+            Color::Rgb(r, g, b) => r | g == 0 || r | b == 0 || g | b == 0,\n+            Color::Cyan => false,\n+        }\n     }\n }\n \n fn main() {\n-    println!(\"{}\", is_it_wildcard(Maybe::Some(\"foo\")));\n-\n-    println!(\"{}\", is_it_bound(Maybe::Some(\"foo\")));\n-\n-    println!(\"{}\", is_it_binding(Maybe::Some(1)));\n-\n-    println!(\"{}\", is_it_binding_exhaustive(Maybe::Some(1)));\n-\n-    println!(\"{}\", is_it_with_guard(Maybe::Some(1)));\n-\n-    println!(\"{}\", is_it_exhaustive(Maybe::Some(\"foo\")));\n-\n-    println!(\"{}\", is_one_or_three(2));\n+    let color = Color::Rgb(0, 0, 127);\n+    match color {\n+        Color::Red => println!(\"Red\"),\n+        _ => eprintln!(\"Not red\"),\n+    };\n+    match color {\n+        Color::Red => println!(\"Red\"),\n+        _not_red => eprintln!(\"Not red\"),\n+    };\n+    let _str = match color {\n+        Color::Red => \"Red\".to_owned(),\n+        not_red => format!(\"{:?}\", not_red),\n+    };\n+    match color {\n+        Color::Red => {},\n+        Color::Green => {},\n+        Color::Blue => {},\n+        Color::Cyan => {},\n+        c if c.is_monochrome() => {},\n+        Color::Rgb(_, _, _) => {},\n+    };\n+    let _str = match color {\n+        Color::Red => \"Red\",\n+        c @ Color::Green | c @ Color::Blue | c @ Color::Rgb(_, _, _) | c @ Color::Cyan => \"Not red\",\n+    };\n+    match color {\n+        Color::Rgb(r, _, _) if r > 0 => \"Some red\",\n+        _ => \"No red\",\n+    };\n+    match color {\n+        Color::Red | Color::Green | Color::Blue | Color::Cyan => {},\n+        Color::Rgb(..) => {},\n+    };\n+    let x: u8 = unimplemented!();\n+    match x {\n+        0 => {},\n+        140 => {},\n+        _ => {},\n+    };\n }"}, {"sha": "999c1693301464121982df4e7bb24b2c19280e4f", "filename": "tests/ui/wildcard_enum_match_arm.stderr", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bcefd688c99895275317eb95a1ec62743526208a/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcefd688c99895275317eb95a1ec62743526208a/tests%2Fui%2Fwildcard_enum_match_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.stderr?ref=bcefd688c99895275317eb95a1ec62743526208a", "patch": "@@ -1,28 +1,32 @@\n error: wildcard match will miss any future added variants.\n-  --> $DIR/wildcard_enum_match_arm.rs:13:9\n+  --> $DIR/wildcard_enum_match_arm.rs:26:9\n    |\n-LL |         _ => \"Could be\",\n-   |         ^ help: try this: `Maybe::Probably(..) | Maybe::None`\n+LL |         _ => eprintln!(\"Not red\"),\n+   |         ^ help: try this: `Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n    |\n-   = note: `-D clippy::wildcard-enum-match-arm` implied by `-D warnings`\n+note: lint level defined here\n+  --> $DIR/wildcard_enum_match_arm.rs:1:9\n+   |\n+LL | #![deny(clippy::wildcard_enum_match_arm)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: wildcard match will miss any future added variants.\n-  --> $DIR/wildcard_enum_match_arm.rs:20:9\n+  --> $DIR/wildcard_enum_match_arm.rs:30:9\n    |\n-LL |         _other => \"Could be\",\n-   |         ^^^^^^ help: try this: `_other @ Maybe::Some(..) | _other @ Maybe::Probably(..)`\n+LL |         _not_red => eprintln!(\"Not red\"),\n+   |         ^^^^^^^^ help: try this: `_not_red @ Color::Green | _not_red @ Color::Blue | _not_red @ Color::Rgb(..) | _not_red @ Color::Cyan`\n \n error: wildcard match will miss any future added variants.\n-  --> $DIR/wildcard_enum_match_arm.rs:27:9\n+  --> $DIR/wildcard_enum_match_arm.rs:34:9\n    |\n-LL |         n => format!(\"{:?}\", n),\n-   |         ^ help: try this: `n @ Maybe::Probably(..) | n @ Maybe::None`\n+LL |         not_red => format!(\"{:?}\", not_red),\n+   |         ^^^^^^^ help: try this: `not_red @ Color::Green | not_red @ Color::Blue | not_red @ Color::Rgb(..) | not_red @ Color::Cyan`\n \n error: wildcard match will miss any future added variants.\n-  --> $DIR/wildcard_enum_match_arm.rs:41:9\n+  --> $DIR/wildcard_enum_match_arm.rs:50:9\n    |\n-LL |         _ => \"Who knows\",\n-   |         ^ help: try this: `Maybe::Some(..) | Maybe::Probably(..) | Maybe::None`\n+LL |         _ => \"No red\",\n+   |         ^ help: try this: `Color::Red | Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n \n error: aborting due to 4 previous errors\n "}]}