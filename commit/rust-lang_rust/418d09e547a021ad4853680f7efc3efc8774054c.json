{"sha": "418d09e547a021ad4853680f7efc3efc8774054c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOGQwOWU1NDdhMDIxYWQ0ODUzNjgwZjdlZmMzZWZjODc3NDA1NGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-02T01:49:10Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-09-02T01:54:03Z"}, "message": "Convert all uses of #ifmt to #fmt. Issue #855", "tree": {"sha": "b6cd0c22529d90105a7cc1d87fde5504f31031f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6cd0c22529d90105a7cc1d87fde5504f31031f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/418d09e547a021ad4853680f7efc3efc8774054c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/418d09e547a021ad4853680f7efc3efc8774054c", "html_url": "https://github.com/rust-lang/rust/commit/418d09e547a021ad4853680f7efc3efc8774054c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/418d09e547a021ad4853680f7efc3efc8774054c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4b81117ce3713599b48d2168bf10e0225f94819", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b81117ce3713599b48d2168bf10e0225f94819", "html_url": "https://github.com/rust-lang/rust/commit/b4b81117ce3713599b48d2168bf10e0225f94819"}], "stats": {"total": 360, "additions": 180, "deletions": 180}, "files": [{"sha": "553478d7ed1a4a1e23ae7328edf75f7e946cde5a", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -340,7 +340,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n     fn crate_meta_extras_hash(sha: sha1, _crate: &ast::crate,\n                               metas: &provided_metas) -> istr {\n         fn len_and_str(s: &istr) -> istr {\n-            ret #ifmt[\"%u_%s\", str::byte_len(s), s];\n+            ret #fmt[\"%u_%s\", str::byte_len(s), s];\n         }\n \n         fn len_and_str_lit(l: &ast::lit) -> istr {\n@@ -372,7 +372,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n     fn warn_missing(sess: &session::session, name: &istr, default: &istr) {\n         if !sess.get_opts().library { ret; }\n         sess.warn(\n-            #ifmt[\"missing crate link meta '%s', using '%s' as default\",\n+            #fmt[\"missing crate link meta '%s', using '%s' as default\",\n                        name, default]);\n     }\n \n@@ -458,7 +458,7 @@ fn mangle(ss: &[istr]) -> istr {\n     let n = ~\"_ZN\"; // Begin name-sequence.\n \n     for s: istr in ss {\n-        n += #ifmt[\"%u%s\", str::byte_len(s), s];\n+        n += #fmt[\"%u%s\", str::byte_len(s), s];\n     }\n     n += ~\"E\"; // End name-sequence.\n "}, {"sha": "829c40ed8035de07378295d5c6215e8335bcccd4", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -121,7 +121,7 @@ fn time<@T>(do_it: bool, what: &istr, thunk: fn() -> T) -> T {\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n     let end = std::time::precise_time_s();\n-    log_err #ifmt[\"time: %s took %s s\", what,\n+    log_err #fmt[\"time: %s took %s s\", what,\n                  common::float_to_str(end - start, 3u)];\n     ret rv;\n }\n@@ -260,14 +260,14 @@ fn version(argv0: &istr) {\n     let env_vers = #env[\"CFG_VERSION\"];\n     if str::byte_len(env_vers) != 0u { vers = env_vers; }\n     io::stdout().write_str(\n-        #ifmt[\"%s %s\\n\",\n+        #fmt[\"%s %s\\n\",\n                              argv0,\n                              vers]);\n }\n \n fn usage(argv0: &istr) {\n     io::stdout().write_str(\n-        #ifmt[\"usage: %s [options] <input>\\n\", argv0] +\n+        #fmt[\"usage: %s [options] <input>\\n\", argv0] +\n                                ~\"\n options:\n \n@@ -471,7 +471,7 @@ fn main(args: [istr]) {\n         alt getopts::getopts(args, opts()) {\n           getopts::success(m) { m }\n           getopts::failure(f) {\n-            log_err #ifmt[\"error: %s\", getopts::fail_str(f)];\n+            log_err #fmt[\"error: %s\", getopts::fail_str(f)];\n             fail\n           }\n         };\n@@ -636,9 +636,9 @@ fn main(args: [istr]) {\n     let err_code = run::run_program(prog, gcc_args);\n     if 0 != err_code {\n         sess.err(\n-            #ifmt[\"linking with gcc failed with code %d\", err_code]);\n+            #fmt[\"linking with gcc failed with code %d\", err_code]);\n         sess.note(\n-            #ifmt[\"gcc arguments: %s\",\n+            #fmt[\"gcc arguments: %s\",\n                        str::connect(gcc_args, ~\" \")]);\n         sess.abort_if_errors();\n     }"}, {"sha": "312cdc58f691ed5ff60da92efa160539b530872a", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -94,12 +94,12 @@ obj session(targ_cfg: @config,\n     }\n     fn span_bug(sp: span, msg: &istr) -> ! {\n         self.span_fatal(sp,\n-                        #ifmt[\"internal compiler error %s\",\n+                        #fmt[\"internal compiler error %s\",\n                                              msg]);\n     }\n     fn bug(msg: &istr) -> ! {\n         self.fatal(\n-            #ifmt[\"internal compiler error %s\",\n+            #fmt[\"internal compiler error %s\",\n                  msg]);\n     }\n     fn span_unimpl(sp: span, msg: &istr) -> ! {"}, {"sha": "ae104e62fa30b22f58125fcd4ad25de4638d1cce", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -123,10 +123,10 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n }\n \n fn contains(haystack: &[@ast::meta_item], needle: @ast::meta_item) -> bool {\n-    log #ifmt[\"looking for %s\",\n+    log #fmt[\"looking for %s\",\n                  syntax::print::pprust::meta_item_to_str(*needle)];\n     for item: @ast::meta_item in haystack {\n-        log #ifmt[\"looking in %s\",\n+        log #fmt[\"looking in %s\",\n                      syntax::print::pprust::meta_item_to_str(*item)];\n         if eq(item, needle) { log \"found it!\"; ret true; }\n     }\n@@ -183,7 +183,7 @@ fn require_unique_names(sess: &session::session, metas: &[@ast::meta_item]) {\n         let name = get_meta_item_name(meta);\n         if map.contains_key(name) {\n             sess.span_fatal(meta.span,\n-                            #ifmt[\"duplicate meta item `%s`\",\n+                            #fmt[\"duplicate meta item `%s`\",\n                                  name]);\n         }\n         map.insert(name, ());"}, {"sha": "5103ffab827739389a020fe3d22e24479b4922da", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -92,14 +92,14 @@ fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n    @ast::item {\n \n     cx.path += [i.ident];\n-    log #ifmt[\"current path: %s\",\n+    log #fmt[\"current path: %s\",\n              ast_util::path_name_i(cx.path)];\n \n     if is_test_fn(i) {\n         log \"this is a test function\";\n         let test = {path: cx.path, ignore: is_ignored(i)};\n         cx.testfns += [test];\n-        log #ifmt[\"have %u test functions\", vec::len(cx.testfns)];\n+        log #fmt[\"have %u test functions\", vec::len(cx.testfns)];\n     }\n \n     let res = fold::noop_fold_item(i, fld);\n@@ -168,7 +168,7 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n          node: item_,\n          span: dummy_sp()};\n \n-    log #ifmt[\"Synthetic test module:\\n%s\\n\",\n+    log #fmt[\"Synthetic test module:\\n%s\\n\",\n              pprust::item_to_str(@item)];\n \n     ret @item;\n@@ -234,7 +234,7 @@ fn mk_test_desc_vec_ty(cx: &test_ctxt) -> @ast::ty {\n }\n \n fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n-    log #ifmt[\"building test vector from %u tests\", vec::len(cx.testfns)];\n+    log #fmt[\"building test vector from %u tests\", vec::len(cx.testfns)];\n     let descs = [];\n     for test: test in cx.testfns {\n         let test_ = test; // Satisfy alias analysis\n@@ -249,7 +249,7 @@ fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     let path = test.path;\n \n-    log #ifmt[\"encoding %s\",\n+    log #fmt[\"encoding %s\",\n              ast_util::path_name_i(path)];\n \n     let name_lit: ast::lit ="}, {"sha": "105490ac22377579b340821795a4be7f815f92f0", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1040,7 +1040,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n       }\n       13 { ret ~\"Vector\"; }\n       14 { ret ~\"Metadata\"; }\n-      _ { log_err #ifmt[\"unknown TypeKind %d\", kind as int]; fail; }\n+      _ { log_err #fmt[\"unknown TypeKind %d\", kind as int]; fail; }\n     }\n }\n "}, {"sha": "4fd911a1bad0d0d3a7dafbef8fabf8a2691596d7", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -99,12 +99,12 @@ fn metadata_matches(crate_data: &@[u8], metas: &[@ast::meta_item]) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n \n-    log #ifmt[\"matching %u metadata requirements against %u items\",\n+    log #fmt[\"matching %u metadata requirements against %u items\",\n              vec::len(metas), vec::len(linkage_metas)];\n \n     for needed: @ast::meta_item in metas {\n         if !attr::contains(linkage_metas, needed) {\n-            log #ifmt[\"missing %s\",\n+            log #fmt[\"missing %s\",\n                      pprust::meta_item_to_str(*needed)];\n             ret false;\n         }\n@@ -169,13 +169,13 @@ fn find_library_crate_aux(nn: &{prefix: istr, suffix: istr},\n     // manually filtering fs::list_dir here.\n \n     for library_search_path: istr in library_search_paths {\n-        log #ifmt[\"searching %s\", library_search_path];\n+        log #fmt[\"searching %s\", library_search_path];\n         for path: istr in fs::list_dir(library_search_path) {\n-            log #ifmt[\"searching %s\", path];\n+            log #fmt[\"searching %s\", path];\n             let f: istr = fs::basename(path);\n             if !(str::starts_with(f, prefix) && str::ends_with(f, suffix))\n                {\n-                log #ifmt[\"skipping %s, doesn't look like %s*%s\",\n+                log #fmt[\"skipping %s, doesn't look like %s*%s\",\n                          path,\n                          prefix,\n                          suffix];\n@@ -184,11 +184,11 @@ fn find_library_crate_aux(nn: &{prefix: istr, suffix: istr},\n             alt get_metadata_section(path) {\n               option::some(cvec) {\n                 if !metadata_matches(cvec, metas) {\n-                    log #ifmt[\"skipping %s, metadata doesn't match\",\n+                    log #fmt[\"skipping %s, metadata doesn't match\",\n                              path];\n                     cont;\n                 }\n-                log #ifmt[\"found %s with matching metadata\",\n+                log #fmt[\"found %s with matching metadata\",\n                          path];\n                 ret some({ident: path, data: cvec});\n               }\n@@ -230,7 +230,7 @@ fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n       some(t) { ret t; }\n       none. {\n         sess.span_fatal(span,\n-                        #ifmt[\"can't find crate for '%s'\",\n+                        #fmt[\"can't find crate for '%s'\",\n                                    ident]);\n       }\n     }\n@@ -274,7 +274,7 @@ fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n     for dep: decoder::crate_dep in decoder::get_crate_deps(cdata) {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.ident;\n-        log #ifmt[\"resolving dep %s\", cname];\n+        log #fmt[\"resolving dep %s\", cname];\n         if e.crate_cache.contains_key(cname) {\n             log \"already have it\";\n             // We've already seen this crate"}, {"sha": "e99e9d274da95cf6b14c1e22273d0a7952c18078", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -348,7 +348,7 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n fn list_meta_items(meta_items: &ebml::doc, out: io::writer) {\n     for mi: @ast::meta_item in get_meta_items(meta_items) {\n         out.write_str(\n-                #ifmt[\"%s\\n\",\n+                #fmt[\"%s\\n\",\n                      pprust::meta_item_to_str(*mi)]);\n     }\n }\n@@ -358,7 +358,7 @@ fn list_crate_attributes(md: &ebml::doc, out: io::writer) {\n \n     for attr: ast::attribute in get_attributes(md) {\n         out.write_str(\n-                #ifmt[\"%s\\n\",\n+                #fmt[\"%s\\n\",\n                      pprust::attribute_to_str(attr)]);\n     }\n \n@@ -389,7 +389,7 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n \n     for dep: crate_dep in get_crate_deps(data) {\n         out.write_str(\n-            #ifmt[\"%d %s\\n\", dep.cnum,\n+            #fmt[\"%d %s\\n\", dep.cnum,\n                                  dep.ident]);\n     }\n \n@@ -411,7 +411,7 @@ fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n             let did_doc = ebml::get_doc(def, tag_def_id);\n             let did = parse_def_id(ebml::doc_data(did_doc));\n             out.write_str(\n-                    #ifmt[\"%s (%s)\\n\",\n+                    #fmt[\"%s (%s)\\n\",\n                          data.path,\n                          describe_def(items, did)]);\n         }"}, {"sha": "7ed760c32dcf219a618e32f8e167af3538e9a7f8", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -177,7 +177,7 @@ fn encode_inlineness(ebml_w: &ebml::writer, c: u8) {\n }\n \n fn def_to_str(did: &def_id) -> istr {\n-    ret #ifmt[\"%d:%d\", did.crate, did.node];\n+    ret #fmt[\"%d:%d\", did.crate, did.node];\n }\n \n fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {"}, {"sha": "7b255ab1fc6675b9b862973ad62b7a233891007a", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -183,7 +183,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n         for r in restricts {\n             if !option::is_none(r.unsafe_ty) {\n                 cx.tcx.sess.span_err(f.span,\n-                                     #ifmt[\"function may alias with argument \\\n+                                     #fmt[\"function may alias with argument \\\n                                            %u, which is not immutably rooted\",\n                                            i]);\n             }\n@@ -200,7 +200,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n                 if i != j &&\n                    ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) {\n                     cx.tcx.sess.span_err(args[i].span,\n-                        #ifmt[\"argument %u may alias with argument %u, \\\n+                        #fmt[\"argument %u may alias with argument %u, \\\n                                which is not immutably rooted\", i, j]);\n                 }\n                 i += 1u;"}, {"sha": "744d328f0f7a3c0bdf9d13856e9fa9a1a0dc84ce", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -114,13 +114,13 @@ fn type_and_kind(tcx: &ty::ctxt, e: &@ast::expr) ->\n fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr, k_need: ast::kind,\n                   descr: &istr) {\n     let tk = type_and_kind(tcx, e);\n-    log #ifmt[\"for %s: want %s type, got %s type %s\", descr,\n+    log #fmt[\"for %s: want %s type, got %s type %s\", descr,\n              kind_to_str(k_need), kind_to_str(tk.kind),\n              util::ppaux::ty_to_str(tcx, tk.ty)];\n \n     if !kind_lteq(k_need, tk.kind) {\n         let s =\n-            #ifmt[\"mismatched kinds for %s: needed %s type, got %s type %s\",\n+            #fmt[\"mismatched kinds for %s: needed %s type, got %s type %s\",\n                  descr, kind_to_str(k_need),\n                  kind_to_str(tk.kind),\n                  util::ppaux::ty_to_str(tcx, tk.ty)];\n@@ -169,7 +169,7 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n                 let k = ty::type_kind(tcx, t);\n                 if !kind_lteq(k_need, k) {\n                     let s =\n-                        #ifmt[\"mismatched kinds for typaram %d: \\\n+                        #fmt[\"mismatched kinds for typaram %d: \\\n                                   needed %s type, got %s type %s\",\n                              i, kind_to_str(k_need), kind_to_str(k),\n                              util::ppaux::ty_to_str(tcx, t)];"}, {"sha": "3fcf6bde0323b418a6cb540278d65a0a5740f20d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -572,7 +572,7 @@ fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &istr) -> ! {\n }\n \n fn mk_unresolved_msg(id: &ident, kind: &istr) -> istr {\n-    ret #ifmt[\"unresolved %s: %s\", kind, id];\n+    ret #fmt[\"unresolved %s: %s\", kind, id];\n }\n \n // Lookup helpers\n@@ -1027,7 +1027,7 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n             for match: glob_imp_def in matches {\n                 let sp = match.item.span;\n                 e.sess.span_note(\n-                    sp, #ifmt[\"'%s' is imported here\", id]);\n+                    sp, #fmt[\"'%s' is imported here\", id]);\n             }\n             e.sess.span_fatal(sp,\n                               ~\"'\" + id"}, {"sha": "f756cbd320167d203731088d7aff8712eca89e0e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1886,7 +1886,7 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n             alt { ti.take_glue } {\n               some(_) { }\n               none. {\n-                log #ifmt[\"+++ lazily_emit_tydesc_glue TAKE %s\",\n+                log #fmt[\"+++ lazily_emit_tydesc_glue TAKE %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n@@ -1896,15 +1896,15 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   default_helper(make_take_glue),\n                                   ti.ty_params, ~\"take\");\n-                log #ifmt[\"--- lazily_emit_tydesc_glue TAKE %s\",\n+                log #fmt[\"--- lazily_emit_tydesc_glue TAKE %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n             }\n         } else if field == abi::tydesc_field_drop_glue {\n             alt { ti.drop_glue } {\n               some(_) { }\n               none. {\n-                log #ifmt[\"+++ lazily_emit_tydesc_glue DROP %s\",\n+                log #fmt[\"+++ lazily_emit_tydesc_glue DROP %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n@@ -1914,15 +1914,15 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   default_helper(make_drop_glue),\n                                   ti.ty_params, ~\"drop\");\n-                log #ifmt[\"--- lazily_emit_tydesc_glue DROP %s\",\n+                log #fmt[\"--- lazily_emit_tydesc_glue DROP %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n             }\n          } else if field == abi::tydesc_field_free_glue {\n             alt { ti.free_glue } {\n               some(_) { }\n               none. {\n-                log #ifmt[\"+++ lazily_emit_tydesc_glue FREE %s\",\n+                log #fmt[\"+++ lazily_emit_tydesc_glue FREE %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n                 let lcx = cx.fcx.lcx;\n                 let glue_fn =\n@@ -1932,18 +1932,18 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n                 make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                   default_helper(make_free_glue),\n                                   ti.ty_params, ~\"free\");\n-                log #ifmt[\"--- lazily_emit_tydesc_glue FREE %s\",\n+                log #fmt[\"--- lazily_emit_tydesc_glue FREE %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n             }\n         } else if field == abi::tydesc_field_cmp_glue {\n             alt { ti.cmp_glue } {\n               some(_) { }\n               none. {\n-                log #ifmt[\"+++ lazily_emit_tydesc_glue CMP %s\",\n+                log #fmt[\"+++ lazily_emit_tydesc_glue CMP %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n                 ti.cmp_glue = some(bcx_ccx(cx).upcalls.cmp_type);\n-                log #ifmt[\"--- lazily_emit_tydesc_glue CMP %s\",\n+                log #fmt[\"--- lazily_emit_tydesc_glue CMP %s\",\n                          ty_to_str(bcx_tcx(cx), ti.ty)];\n               }\n             }\n@@ -6273,15 +6273,15 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n     write_metadata(cx.ccx, crate);\n     if ccx.sess.get_opts().stats {\n         log_err \"--- trans stats ---\";\n-        log_err #ifmt[\"n_static_tydescs: %u\", ccx.stats.n_static_tydescs];\n-        log_err #ifmt[\"n_derived_tydescs: %u\", ccx.stats.n_derived_tydescs];\n-        log_err #ifmt[\"n_glues_created: %u\", ccx.stats.n_glues_created];\n-        log_err #ifmt[\"n_null_glues: %u\", ccx.stats.n_null_glues];\n-        log_err #ifmt[\"n_real_glues: %u\", ccx.stats.n_real_glues];\n+        log_err #fmt[\"n_static_tydescs: %u\", ccx.stats.n_static_tydescs];\n+        log_err #fmt[\"n_derived_tydescs: %u\", ccx.stats.n_derived_tydescs];\n+        log_err #fmt[\"n_glues_created: %u\", ccx.stats.n_glues_created];\n+        log_err #fmt[\"n_null_glues: %u\", ccx.stats.n_null_glues];\n+        log_err #fmt[\"n_real_glues: %u\", ccx.stats.n_real_glues];\n \n \n         for timing: {ident: istr, time: int} in *ccx.stats.fn_times {\n-            log_err #ifmt[\"time: %s took %d ms\",\n+            log_err #fmt[\"time: %s took %d ms\",\n                          timing.ident, timing.time];\n         }\n     }"}, {"sha": "1b4c14cb95a69269b13bd28022ce59c27a164f11", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -171,7 +171,7 @@ fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n     // FIXME: This could be a typestate constraint\n     if vec::len(bs) != vec::len(ops) {\n         fcx.ccx.tcx.sess.span_bug(a.span,\n-                                  #ifmt[\"mismatched arg lengths: \\\n+                                  #fmt[\"mismatched arg lengths: \\\n                                         %u exprs vs. %u ops\",\n                                        vec::len(bs), vec::len(ops)]);\n     }"}, {"sha": "0815a862b8caa48ed0fdcea18e795e612c63e343", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -2438,7 +2438,7 @@ mod unify {\n             let sets = ~\"\";\n             let j = 0u;\n             while j < vec::len::<option::t<uint>>(vb.sets.nodes) {\n-                if ufind::find(vb.sets, j) == i { sets += #ifmt[\" %u\", j]; }\n+                if ufind::find(vb.sets, j) == i { sets += #fmt[\" %u\", j]; }\n                 j += 1u;\n             }\n             let typespec;\n@@ -2448,7 +2448,7 @@ mod unify {\n                 typespec = ~\" =\" + ty_to_str(tcx, typ);\n               }\n             }\n-            log_err #ifmt[\"set %u:%s%s\", i, typespec, sets];\n+            log_err #fmt[\"set %u:%s%s\", i, typespec, sets];\n             i += 1u;\n         }\n     }"}, {"sha": "2357ab1e420fe935f2e0bb26451e6392272d388b", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1377,10 +1377,10 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                 let arg_len = vec::len::<ty::t>(arg_types);\n                 if arg_len != subpats_len {\n                     // TODO: note definition of tag variant\n-                    // TODO (issue #448): Wrap a #ifmt string over multiple\n+                    // TODO (issue #448): Wrap a #fmt string over multiple\n                     // lines...\n                     let s =\n-                        #ifmt[\"this pattern has %u field%s, but the \\\n+                        #fmt[\"this pattern has %u field%s, but the \\\n                                        corresponding variant has %u field%s\",\n                              subpats_len,\n                              if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n@@ -1400,7 +1400,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                 // TODO: note definition of tag variant\n                 fcx.ccx.tcx.sess.span_fatal(\n                     pat.span,\n-                    #ifmt[\"this pattern has %u field%s, \\\n+                    #fmt[\"this pattern has %u field%s, \\\n                           but the corresponding \\\n                           variant has no fields\",\n                          subpats_len,\n@@ -1415,7 +1415,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n             // can never tell.\n             fcx.ccx.tcx.sess.span_fatal(\n                 pat.span,\n-                #ifmt[\"mismatched types: expected %s, found tag\",\n+                #fmt[\"mismatched types: expected %s, found tag\",\n                      ty_to_str(fcx.ccx.tcx, expected)]);\n           }\n         }\n@@ -1428,7 +1428,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(\n                 pat.span,\n-                #ifmt[\"mismatched types: expected %s, found record\",\n+                #fmt[\"mismatched types: expected %s, found record\",\n                      ty_to_str(fcx.ccx.tcx, expected)]);\n           }\n         }\n@@ -1437,7 +1437,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n             fcx.ccx.tcx.sess.span_fatal(\n                 pat.span,\n-                #ifmt[\"mismatched types: expected a record \\\n+                #fmt[\"mismatched types: expected a record \\\n                       with %u fields, found one with %u \\\n                       fields\",\n                      ex_f_count, f_count]);\n@@ -1450,7 +1450,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n               some(field) { check_pat(fcx, map, f.pat, field.mt.ty); }\n               none. {\n                 fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                            #ifmt[\"mismatched types: did not \\\n+                                            #fmt[\"mismatched types: did not \\\n                                              expect a record with a field %s\",\n                                                  f.ident]);\n               }\n@@ -1465,15 +1465,15 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(\n                 pat.span,\n-                #ifmt[\"mismatched types: expected %s, found tuple\",\n+                #fmt[\"mismatched types: expected %s, found tuple\",\n                      ty_to_str(fcx.ccx.tcx, expected)]);\n           }\n         }\n         let e_count = vec::len(elts);\n         if e_count != vec::len(ex_elts) {\n             fcx.ccx.tcx.sess.span_fatal(\n                 pat.span,\n-                #ifmt[\"mismatched types: expected a tuple \\\n+                #fmt[\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n                       fields\",\n                      vec::len(ex_elts), e_count]);\n@@ -1606,7 +1606,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         if expected_arg_count != supplied_arg_count {\n             fcx.ccx.tcx.sess.span_err(\n                 sp,\n-                #ifmt[\"this function takes %u \\\n+                #fmt[\"this function takes %u \\\n                       parameter%s but %u parameter%s supplied\",\n                       expected_arg_count,\n                       if expected_arg_count == 1u {\n@@ -1828,7 +1828,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                    structure_of(fcx, oper.span, oper_t) != ty::ty_bool {\n                 tcx.sess.span_err(\n                     expr.span,\n-                    #ifmt[\"mismatched types: expected bool \\\n+                    #fmt[\"mismatched types: expected bool \\\n                           or integer but found %s\",\n                          ty_to_str(tcx, oper_t)]);\n             }\n@@ -2274,7 +2274,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           _ {\n             let t_err = resolve_type_vars_if_possible(fcx, base_t);\n             let msg =\n-                #ifmt[\"attempted field access on type %s\",\n+                #fmt[\"attempted field access on type %s\",\n                      ty_to_str(tcx, t_err)];\n             tcx.sess.span_fatal(expr.span, msg);\n           }"}, {"sha": "42120906b786b8ed7a1b70c021f1cdde3204f9eb", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -80,7 +80,7 @@ fn span_to_str(sp: &span, cm: &codemap) -> istr {\n         let lo = lookup_char_pos(cm, cur.lo);\n         let hi = lookup_char_pos(cm, cur.hi);\n         res +=\n-            #ifmt[\"%s:%u:%u: %u:%u\",\n+            #fmt[\"%s:%u:%u: %u:%u\",\n                  if some(lo.filename) == prev_file {\n                      ~\"-\"\n                  } else {\n@@ -114,9 +114,9 @@ fn emit_diagnostic(sp: &option::t<span>, msg: &istr, kind: &istr, color: u8,\n     if term::color_supported() {\n         term::fg(io::stdout().get_buf_writer(), color);\n     }\n-    io::stdout().write_str(#ifmt[~\"%s:\", kind]);\n+    io::stdout().write_str(#fmt[~\"%s:\", kind]);\n     if term::color_supported() { term::reset(io::stdout().get_buf_writer()); }\n-    io::stdout().write_str(#ifmt[~\" %s\\n\", msg]);\n+    io::stdout().write_str(#fmt[~\" %s\\n\", msg]);\n \n     maybe_highlight_lines(sp, cm, maybe_lines);\n }\n@@ -146,14 +146,14 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n         // Print the offending lines\n         for line: uint in display_lines {\n             io::stdout().write_str(\n-                #ifmt[~\"%s:%u \", fm.name, line + 1u]);\n+                #fmt[~\"%s:%u \", fm.name, line + 1u]);\n             let s = get_line(fm, line as int, file);\n             if !str::ends_with(s, ~\"\\n\") { s += ~\"\\n\"; }\n             io::stdout().write_str(s);\n         }\n         if elided {\n             let last_line = display_lines[vec::len(display_lines) - 1u];\n-            let s = #ifmt[~\"%s:%u \", fm.name, last_line + 1u];\n+            let s = #fmt[~\"%s:%u \", fm.name, last_line + 1u];\n             let indent = str::char_len(s);\n             let out = ~\"\";\n             while indent > 0u { out += ~\" \"; indent -= 1u; }"}, {"sha": "c2a3a2011260721b15ea9d932a1586bf0efb979f", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -27,7 +27,7 @@ fn expand_expr(exts: &hashmap<istr, syntax_extension>, cx: &ext_ctxt,\n                 alt exts.find(extname) {\n                   none. {\n                     cx.span_fatal(pth.span,\n-                                  #ifmt[\"macro undefined: '%s'\",\n+                                  #fmt[\"macro undefined: '%s'\",\n                                        extname])\n                   }\n                   some(normal(ext)) {"}, {"sha": "abc73dc7c417ad5a65c3f245611e0bdf49240754", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -345,7 +345,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     if expected_nargs < nargs {\n         cx.span_fatal(\n             sp,\n-            #ifmt[\"too many arguments to #fmt. found %u, expected %u\",\n+            #fmt[\"too many arguments to #fmt. found %u, expected %u\",\n                  nargs, expected_nargs]);\n     }\n     ret tmp_expr;"}, {"sha": "3496791ce6e83af7d3da8a8746e429a2784d9e00", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -309,9 +309,9 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                         let len = vec::len(*ms);\n                         if old_len != len {\n                             let msg =\n-                                #ifmt[\"'%s' occurs %u times, but \",\n+                                #fmt[\"'%s' occurs %u times, but \",\n                                      fv, len] +\n-                                    #ifmt[\"'%s' occurs %u times\",\n+                                    #fmt[\"'%s' occurs %u times\",\n                                          old_name,\n                                          old_len];\n                             cx.span_fatal("}, {"sha": "e479377f3d79ab5f1975c444addc1bd99b09035f", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -325,7 +325,7 @@ fn scan_numeric_escape(rdr: &reader, n_hex_digits: uint) -> char {\n         rdr.bump();\n         if !is_hex_digit(n) {\n             rdr.err(\n-                    #ifmt[\"illegal numeric character escape: %d\", n as int]);\n+                    #fmt[\"illegal numeric character escape: %d\", n as int]);\n             fail;\n         }\n         accum_int *= 16;\n@@ -469,7 +469,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n               'U' { c2 = scan_numeric_escape(rdr, 8u); }\n               c2 {\n                 rdr.err(\n-                    #ifmt[\"unknown character escape: %d\",\n+                    #fmt[\"unknown character escape: %d\",\n                                          c2 as int]);\n                 fail;\n               }\n@@ -510,7 +510,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n                   }\n                   c2 {\n                     rdr.err(\n-                        #ifmt[\"unknown string escape: %d\",\n+                        #fmt[\"unknown string escape: %d\",\n                                              c2 as int]);\n                     fail;\n                   }\n@@ -551,7 +551,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n       '%' { ret binop(rdr, token::PERCENT); }\n       c {\n         rdr.err(\n-            #ifmt[\"unkown start of token: %d\", c as int]);\n+            #fmt[\"unkown start of token: %d\", c as int]);\n         fail;\n       }\n     }\n@@ -652,7 +652,7 @@ fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     let curr_line = ~\"/*\";\n     let level: int = 1;\n     while level > 0 {\n-        log #ifmt[\"=== block comment level %d\", level];\n+        log #fmt[\"=== block comment level %d\", level];\n         if rdr.is_eof() { rdr.err(~\"unterminated block comment\"); fail; }\n         if rdr.curr() == '\\n' {\n             trim_whitespace_prefix_and_push_line(lines, curr_line, col);"}, {"sha": "ef92672435a9693a0566c7bf4ef21c1114fa020c", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -66,7 +66,7 @@ tag token { STRING(istr, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n fn tok_str(t: token) -> istr {\n     alt t {\n       STRING(s, len) {\n-        ret #ifmt[~\"STR(%s,%d)\", s, len];\n+        ret #fmt[~\"STR(%s,%d)\", s, len];\n       }\n       BREAK(_) { ret ~\"BREAK\"; }\n       BEGIN(_) { ret ~\"BEGIN\"; }\n@@ -85,7 +85,7 @@ fn buf_str(toks: &[mutable token], szs: &[mutable int], left: uint,\n     while i != right && L != 0u {\n         L -= 1u;\n         if i != left { s += ~\", \"; }\n-        s += #ifmt[~\"%d=%s\", szs[i], tok_str(toks[i])];\n+        s += #fmt[~\"%d=%s\", szs[i], tok_str(toks[i])];\n         i += 1u;\n         i %= n;\n     }\n@@ -104,7 +104,7 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n     // fall behind.\n \n     let n: uint = 3u * linewidth;\n-    log #ifmt[~\"mk_printer %u\", linewidth];\n+    log #fmt[~\"mk_printer %u\", linewidth];\n     let token: [mutable token] = vec::init_elt_mut(EOF, n);\n     let size: [mutable int] = vec::init_elt_mut(0, n);\n     let scan_stack: [mutable uint] = vec::init_elt_mut(0u, n);\n@@ -244,7 +244,7 @@ obj printer(out: io::writer,\n     fn replace_last_token(t: token) { token[right] = t; }\n \n     fn pretty_print(t: token) {\n-        log #ifmt[~\"pp [%u,%u]\", left, right];\n+        log #fmt[~\"pp [%u,%u]\", left, right];\n         alt t {\n           EOF. {\n             if !scan_stack_empty {\n@@ -260,17 +260,17 @@ obj printer(out: io::writer,\n                 left = 0u;\n                 right = 0u;\n             } else { self.advance_right(); }\n-            log #ifmt[~\"pp BEGIN/buffer [%u,%u]\", left, right];\n+            log #fmt[~\"pp BEGIN/buffer [%u,%u]\", left, right];\n             token[right] = t;\n             size[right] = -right_total;\n             self.scan_push(right);\n           }\n           END. {\n             if scan_stack_empty {\n-                log #ifmt[~\"pp END/print [%u,%u]\", left, right];\n+                log #fmt[~\"pp END/print [%u,%u]\", left, right];\n                 self.print(t, 0);\n             } else {\n-                log #ifmt[~\"pp END/buffer [%u,%u]\", left, right];\n+                log #fmt[~\"pp END/buffer [%u,%u]\", left, right];\n                 self.advance_right();\n                 token[right] = t;\n                 size[right] = -1;\n@@ -284,7 +284,7 @@ obj printer(out: io::writer,\n                 left = 0u;\n                 right = 0u;\n             } else { self.advance_right(); }\n-            log #ifmt[~\"pp BREAK/buffer [%u,%u]\", left, right];\n+            log #fmt[~\"pp BREAK/buffer [%u,%u]\", left, right];\n             self.check_stack(0);\n             self.scan_push(right);\n             token[right] = t;\n@@ -293,10 +293,10 @@ obj printer(out: io::writer,\n           }\n           STRING(s, len) {\n             if scan_stack_empty {\n-                log #ifmt[~\"pp STRING/print [%u,%u]\", left, right];\n+                log #fmt[~\"pp STRING/print [%u,%u]\", left, right];\n                 self.print(t, len);\n             } else {\n-                log #ifmt[~\"pp STRING/buffer [%u,%u]\", left, right];\n+                log #fmt[~\"pp STRING/buffer [%u,%u]\", left, right];\n                 self.advance_right();\n                 token[right] = t;\n                 size[right] = len;\n@@ -307,14 +307,14 @@ obj printer(out: io::writer,\n         }\n     }\n     fn check_stream() {\n-        log #ifmt[~\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n+        log #fmt[~\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n                  left, right, left_total, right_total];\n         if right_total - left_total > space {\n-            log #ifmt[~\"scan window is %d, longer than space on line (%d)\",\n+            log #fmt[~\"scan window is %d, longer than space on line (%d)\",\n                      right_total - left_total, space];\n             if !scan_stack_empty {\n                 if left == scan_stack[bottom] {\n-                    log #ifmt[\"setting %u to infinity and popping\", left];\n+                    log #fmt[\"setting %u to infinity and popping\", left];\n                     size[self.scan_pop_bottom()] = size_infinity;\n                 }\n             }\n@@ -323,7 +323,7 @@ obj printer(out: io::writer,\n         }\n     }\n     fn scan_push(x: uint) {\n-        log #ifmt[\"scan_push %u\", x];\n+        log #fmt[\"scan_push %u\", x];\n         if scan_stack_empty {\n             scan_stack_empty = false;\n         } else { top += 1u; top %= buf_len; assert (top != bottom); }\n@@ -352,7 +352,7 @@ obj printer(out: io::writer,\n         assert (right != left);\n     }\n     fn advance_left(x: token, L: int) {\n-        log #ifmt[\"advnce_left [%u,%u], sizeof(%u)=%d\", left, right, left, L];\n+        log #fmt[\"advnce_left [%u,%u], sizeof(%u)=%d\", left, right, left, L];\n         if L >= 0 {\n             self.print(x, L);\n             alt x {\n@@ -391,13 +391,13 @@ obj printer(out: io::writer,\n         }\n     }\n     fn print_newline(amount: int) {\n-        log #ifmt[\"NEWLINE %d\", amount];\n+        log #fmt[\"NEWLINE %d\", amount];\n         out.write_str(~\"\\n\");\n         pending_indentation = 0;\n         self.indent(amount);\n     }\n     fn indent(amount: int) {\n-        log #ifmt[\"INDENT %d\", amount];\n+        log #fmt[\"INDENT %d\", amount];\n         pending_indentation += amount;\n     }\n     fn top() -> print_stack_elt {\n@@ -414,15 +414,15 @@ obj printer(out: io::writer,\n         out.write_str(s);\n     }\n     fn print(x: token, L: int) {\n-        log #ifmt[\"print %s %d (remaining line space=%d)\",\n+        log #fmt[\"print %s %d (remaining line space=%d)\",\n                  tok_str(x), L,\n                  space];\n         log buf_str(token, size, left, right, 6u);\n         alt x {\n           BEGIN(b) {\n             if L > space {\n                 let col = margin - space + b.offset;\n-                log #ifmt[\"print BEGIN -> push broken block at col %d\", col];\n+                log #fmt[\"print BEGIN -> push broken block at col %d\", col];\n                 print_stack += [{offset: col, pbreak: broken(b.breaks)}];\n             } else {\n                 log \"print BEGIN -> push fitting block\";"}, {"sha": "124a1e947f11a4564284dadbe08704cc31be03cb", "filename": "src/comp/syntax/untyped_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -362,7 +362,7 @@ fn dummy() {\n          alt *elts.(idx) {\n            leaf_destructure(x) { x }\n            _ {\n-             ctx.ff(sp, #ifmt[\"expected %s in position %u\",\n+             ctx.ff(sp, #fmt[\"expected %s in position %u\",\n                              #ident_to_str[leaf_destructure], idx])\n            }\n          }],"}, {"sha": "3b2491ad5aa398af28b1dfb7ee533063be725494", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -194,7 +194,7 @@ fn check_whole_compiler(code: &istr) {\n             ~\"/Users/jruderman/code/rust/build/stage1/rustc\",\n             [~\"-c\", filename]);\n \n-    //log_err #ifmt(\"Status: %d\", p.status);\n+    //log_err #fmt(\"Status: %d\", p.status);\n     //log_err \"Output: \" + p.out;\n     if p.err != ~\"\" {\n         if contains(p.err, ~\"argument of incompatible type\") {\n@@ -264,7 +264,7 @@ fn content_is_dangerous_to_modify(code: &istr) -> bool {\n     let dangerous_patterns =\n         [~\"obj\", // not safe to steal; https://github.com/graydon/rust/issues/761\n          ~\"#macro\", // not safe to steal things inside of it, because they have a special syntax\n-         ~\"#\", // strange representation of the arguments to #ifmt, for example\n+         ~\"#\", // strange representation of the arguments to #fmt, for example\n          ~\" be \", // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n          ~\"@\"]; // hangs when compiling: https://github.com/graydon/rust/issues/768\n \n@@ -326,9 +326,9 @@ fn check_roundtrip_convergence(code: &istr, maxIters: uint) {\n     }\n \n     if old == new {\n-        log_err #ifmt[\"Converged after %u iterations\", i];\n+        log_err #fmt[\"Converged after %u iterations\", i];\n     } else {\n-        log_err #ifmt[\"Did not converge after %u iterations!\", i];\n+        log_err #fmt[\"Did not converge after %u iterations!\", i];\n         write_file(~\"round-trip-a.rs\", old);\n         write_file(~\"round-trip-b.rs\", new);\n         std::run::run_program(~\"diff\",\n@@ -339,12 +339,12 @@ fn check_roundtrip_convergence(code: &istr, maxIters: uint) {\n }\n \n fn check_convergence(files: &[istr]) {\n-    log_err #ifmt[\"pp convergence tests: %u files\", vec::len(files)];\n+    log_err #fmt[\"pp convergence tests: %u files\", vec::len(files)];\n     for file in files {\n         if !file_is_confusing(file) {\n             let s = io::read_whole_file_str(file);\n             if !content_is_confusing(s) {\n-                log_err #ifmt[\"pp converge: %s\", file];\n+                log_err #fmt[\"pp converge: %s\", file];\n                 // Change from 7u to 2u when https://github.com/graydon/rust/issues/759 is fixed\n                 check_roundtrip_convergence(s, 7u);\n             }\n@@ -376,7 +376,7 @@ fn check_variants(files: &[istr]) {\n \n fn main(args: [istr]) {\n     if vec::len(args) != 2u {\n-        log_err #ifmt[\"usage: %s <testdir>\", args[0]];\n+        log_err #fmt[\"usage: %s <testdir>\", args[0]];\n         ret;\n     }\n     let files = [];"}, {"sha": "246574dd07bbadd5d1d1ebf8b5d0d399514d333d", "filename": "src/lib/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Flib%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Flib%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fnet.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -6,7 +6,7 @@ tag ip_addr { ipv4(u8, u8, u8, u8); }\n fn format_addr(ip: ip_addr) -> istr {\n     alt ip {\n       ipv4(a, b, c, d) {\n-        #ifmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint]\n+        #fmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint]\n       }\n       _ { fail \"Unsupported address type\"; }\n     }"}, {"sha": "71032bbcd645fdc1bd36d1953b4cc347a3468c7c", "filename": "src/lib/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -81,7 +81,7 @@ fn join(task_port: (task_id, comm::port<task_notification>)) -> task_result {\n       exit(_id, res) {\n         if _id == id {\n             ret res\n-        } else { fail #ifmt[\"join received id %d, expected %d\", _id, id] }\n+        } else { fail #fmt[\"join received id %d, expected %d\", _id, id] }\n       }\n     }\n }"}, {"sha": "e8ab05a46bae4706c8bc7d6cb92595a398889ed7", "filename": "src/lib/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -120,11 +120,11 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n             st.out.write_line(\n-                #ifmt[\"\\nrunning %u tests\", st.total]);\n+                #fmt[\"\\nrunning %u tests\", st.total]);\n           }\n           te_wait(test) {\n             st.out.write_str(\n-                #ifmt[\"test %s ... \", test.name]);\n+                #fmt[\"test %s ... \", test.name]);\n           }\n           te_result(test, result) {\n             alt result {\n@@ -167,17 +167,17 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n         st.out.write_line(~\"\\nfailures:\");\n         for test: test_desc in st.failures {\n             let testname = test.name; // Satisfy alias analysis\n-            st.out.write_line(#ifmt[\"    %s\", testname]);\n+            st.out.write_line(#fmt[\"    %s\", testname]);\n         }\n     }\n \n-    st.out.write_str(#ifmt[\"\\nresult: \"]);\n+    st.out.write_str(#fmt[\"\\nresult: \"]);\n     if success {\n         // There's no parallelism at this point so it's safe to use color\n         write_ok(st.out, true);\n     } else { write_failed(st.out, true); }\n     st.out.write_str(\n-            #ifmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n+            #fmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n                           st.failed, st.ignored]);\n \n     ret success;\n@@ -225,7 +225,7 @@ fn run_tests(opts: &test_opts, tests: &[test_desc], to_task: &test_to_task,\n     // provide a great user experience because you might sit waiting for the\n     // result of a particular test for an unusually long amount of time.\n     let concurrency = get_concurrency();\n-    log #ifmt[\"using %u test tasks\", concurrency];\n+    log #fmt[\"using %u test tasks\", concurrency];\n     let total = vec::len(filtered_tests);\n     let run_idx = 0u;\n     let wait_idx = 0u;"}, {"sha": "d6a44e6eb823c502bdbe596f8d00ec05b35bccf9", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -28,7 +28,7 @@ fn main() {\n     } else { max_depth = n; }\n     let stretch_depth = max_depth + 1;\n     let stretch_tree = bottom_up_tree(0, stretch_depth);\n-    log #ifmt[\"stretch tree of depth %d\\t check: %d\", stretch_depth,\n+    log #fmt[\"stretch tree of depth %d\\t check: %d\", stretch_depth,\n              item_check(stretch_tree)];\n     let long_lived_tree = bottom_up_tree(0, max_depth);\n     let depth = min_depth;\n@@ -43,10 +43,10 @@ fn main() {\n             chk += item_check(temp_tree);\n             i += 1;\n         }\n-        log #ifmt[\"%d\\t trees of depth %d\\t check: %d\", iterations * 2, depth,\n+        log #fmt[\"%d\\t trees of depth %d\\t check: %d\", iterations * 2, depth,\n                  chk];\n         depth += 2;\n     }\n-    log #ifmt[\"long lived trees of depth %d\\t check: %d\", max_depth,\n+    log #fmt[\"long lived trees of depth %d\\t check: %d\", max_depth,\n              item_check(long_lived_tree)];\n }"}, {"sha": "fa4a17180ae54dc7ee32200f86c3a4921d9cacbc", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -58,5 +58,5 @@ fn fannkuch(n: int) -> int {\n \n fn main(args: [istr]) {\n     let n = 7;\n-    log #ifmt[\"Pfannkuchen(%d) = %d\", n, fannkuch(n)];\n+    log #fmt[\"Pfannkuchen(%d) = %d\", n, fannkuch(n)];\n }"}, {"sha": "6a9a5348c2e6b8c654e966a6fd85785c733a4209", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -67,7 +67,7 @@ fn stress_task(id: int) {\n         let n = 15;\n         assert (fib(n) == fib(n));\n         i += 1;\n-        log_err #ifmt[\"%d: Completed %d iterations\", id, i];\n+        log_err #fmt[\"%d: Completed %d iterations\", id, i];\n     }\n }\n \n@@ -106,7 +106,7 @@ fn main(argv: [istr]) {\n                     let elapsed = stop - start;\n \n                     out.write_line(\n-                            #ifmt[\"%d\\t%d\\t%s\", n, fibn,\n+                            #fmt[\"%d\\t%d\\t%s\", n, fibn,\n                                  u64::str(elapsed)]);\n                 }\n             }"}, {"sha": "3a8f643bc37ef4478da09e65a0624cd223c55a6c", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -127,7 +127,7 @@ mod map_reduce {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n                   emit_val(v) {\n-                    // log_err #ifmt(\"received %d\", v);\n+                    // log_err #fmt(\"received %d\", v);\n                     ret some(v);\n                   }\n                   done. {\n@@ -202,7 +202,7 @@ fn main(argv: [istr]) {\n         let out = io::stdout();\n \n         out.write_line(\n-            #ifmt[\"Usage: %s <filename> ...\", argv[0]]);\n+            #fmt[\"Usage: %s <filename> ...\", argv[0]]);\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program."}, {"sha": "c62ebc73b5d90d290d9026d074ceef0bef3fae94", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -122,7 +122,7 @@ mod map_reduce {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n                   emit_val(v) {\n-                    // log_err #ifmt(\"received %d\", v);\n+                    // log_err #fmt(\"received %d\", v);\n                     ret some(v);\n                   }\n                   done. {\n@@ -196,7 +196,7 @@ fn main(argv: [istr]) {\n         let out = io::stdout();\n \n         out.write_line(\n-            #ifmt[\"Usage: %s <filename> ...\", argv[0]]);\n+            #fmt[\"Usage: %s <filename> ...\", argv[0]]);\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program."}, {"sha": "ef15958c3fc84784235d31a3517150f0befca07f", "filename": "src/test/compile-fail/ext-after-attrib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1,7 +1,7 @@\n-// error-pattern:expecting [, found ifmt\n+// error-pattern:expecting [, found fmt\n \n // Don't know how to deal with a syntax extension appearing after an\n // item attribute. Probably could use a better error message.\n #[foo = \"bar\"]\n-#ifmt(\"baz\")\n+#fmt(\"baz\")\n fn main() { }\n\\ No newline at end of file"}, {"sha": "9e1cbc557d4c1acc9ca7d25af311d56a4f1c7a56", "filename": "src/test/compile-fail/extfmt-missing-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:missing type\n \n-fn main() { #ifmt[\"%+\"]; }\n+fn main() { #fmt[\"%+\"]; }"}, {"sha": "7c13ef99dc5c9614dad382c9f8f25251a71e8ba3", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:format string\n \n-fn main() { #ifmt[]; }\n+fn main() { #fmt[]; }"}, {"sha": "445455f33d8bae901a3f7ea584fff3d34c5cc997", "filename": "src/test/compile-fail/extfmt-non-literal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1,8 +1,8 @@\n // error-pattern: literal\n \n fn main() {\n-    // #ifmt's first argument must be a literal.  Hopefully this\n+    // #fmt's first argument must be a literal.  Hopefully this\n     // restriction can be eased eventually to just require a\n     // compile-time constant.\n-    let x = #ifmt[\"a\" + \"b\"];\n+    let x = #fmt[\"a\" + \"b\"];\n }"}, {"sha": "8a2d7c4bbed304241a7012f624f509758ec07a4a", "filename": "src/test/compile-fail/extfmt-non-literal2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1,8 +1,8 @@\n // error-pattern: literal\n \n fn main() {\n-    // #ifmt's first argument must be a literal.  Hopefully this\n+    // #fmt's first argument must be a literal.  Hopefully this\n     // restriction can be eased eventually to just require a\n     // compile-time constant.\n-    let x = #ifmt[20];\n+    let x = #fmt[20];\n }"}, {"sha": "849a836060d2dbc2c1adb3685cb7add28891e3f2", "filename": "src/test/compile-fail/extfmt-not-enough-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -2,4 +2,4 @@\n \n use std;\n \n-fn main() { let s = #ifmt[\"%s%s%s\", \"test\", \"test\"]; }\n+fn main() { let s = #fmt[\"%s%s%s\", \"test\", \"test\"]; }"}, {"sha": "4c91da227e1bb2b417d6815ca6a940f45476bb34", "filename": "src/test/compile-fail/extfmt-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -2,4 +2,4 @@\n \n use std;\n \n-fn main() { let s = #ifmt[\"%s\", \"test\", \"test\"]; }\n+fn main() { let s = #fmt[\"%s\", \"test\", \"test\"]; }"}, {"sha": "3a35a1d727b95222633d3583112e4f27555caec9", "filename": "src/test/compile-fail/extfmt-unknown-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:unknown type\n \n-fn main() { #ifmt[\"%w\"]; }\n+fn main() { #fmt[\"%w\"]; }"}, {"sha": "4ac41efb31227b6fb3b4415f280b5a966af3d290", "filename": "src/test/compile-fail/extfmt-unsigned-plus.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     // Can't use a sign on unsigned conversions\n-    #ifmt[\"%+u\", 10u];\n+    #fmt[\"%+u\", 10u];\n }"}, {"sha": "6393548eb3d2ded19ea9458779d7f65e754c6053", "filename": "src/test/compile-fail/extfmt-unsigned-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     // Can't use a space on unsigned conversions\n-    #ifmt[\"% u\", 10u];\n+    #fmt[\"% u\", 10u];\n }"}, {"sha": "3b7d0ce1767939d2e673aae3c183a2df651add81", "filename": "src/test/compile-fail/extfmt-unterminated-conv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:unterminated conversion\n \n-fn main() { #ifmt[\"%\"]; }\n+fn main() { #fmt[\"%\"]; }"}, {"sha": "5f3fd1944dd9bb1531e052fb699ef543cab0f406", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -70,21 +70,21 @@ fn parse_config(args: &[istr]) -> config {\n \n fn log_config(config: &config) {\n     let c = config;\n-    logv(c, #ifmt[\"configuration:\"]);\n-    logv(c, #ifmt[\"compile_lib_path: %s\",\n+    logv(c, #fmt[\"configuration:\"]);\n+    logv(c, #fmt[\"compile_lib_path: %s\",\n                  config.compile_lib_path]);\n-    logv(c, #ifmt[\"run_lib_path: %s\", config.run_lib_path]);\n-    logv(c, #ifmt[\"rustc_path: %s\", config.rustc_path]);\n-    logv(c, #ifmt[\"src_base: %s\", config.src_base]);\n-    logv(c, #ifmt[\"build_base: %s\", config.build_base]);\n-    logv(c, #ifmt[\"stage_id: %s\", config.stage_id]);\n-    logv(c, #ifmt[\"mode: %s\", mode_str(config.mode)]);\n-    logv(c, #ifmt[\"run_ignored: %b\", config.run_ignored]);\n-    logv(c, #ifmt[\"filter: %s\", opt_str(config.filter)]);\n-    logv(c, #ifmt[\"runtool: %s\", opt_str(config.runtool)]);\n-    logv(c, #ifmt[\"rustcflags: %s\", opt_str(config.rustcflags)]);\n-    logv(c, #ifmt[\"verbose: %b\", config.verbose]);\n-    logv(c, #ifmt[\"\\n\"]);\n+    logv(c, #fmt[\"run_lib_path: %s\", config.run_lib_path]);\n+    logv(c, #fmt[\"rustc_path: %s\", config.rustc_path]);\n+    logv(c, #fmt[\"src_base: %s\", config.src_base]);\n+    logv(c, #fmt[\"build_base: %s\", config.build_base]);\n+    logv(c, #fmt[\"stage_id: %s\", config.stage_id]);\n+    logv(c, #fmt[\"mode: %s\", mode_str(config.mode)]);\n+    logv(c, #fmt[\"run_ignored: %b\", config.run_ignored]);\n+    logv(c, #fmt[\"filter: %s\", opt_str(config.filter)]);\n+    logv(c, #fmt[\"runtool: %s\", opt_str(config.runtool)]);\n+    logv(c, #fmt[\"rustcflags: %s\", opt_str(config.rustcflags)]);\n+    logv(c, #fmt[\"verbose: %b\", config.verbose]);\n+    logv(c, #fmt[\"\\n\"]);\n }\n \n fn opt_str(maybestr: option::t<istr>) -> istr {\n@@ -139,12 +139,12 @@ type tests_and_conv_fn =\n     {tests: [test::test_desc], to_task: fn(&fn()) -> test::joinable};\n \n fn make_tests(cx: &cx) -> tests_and_conv_fn {\n-    log #ifmt[\"making tests from %s\", cx.config.src_base];\n+    log #fmt[\"making tests from %s\", cx.config.src_base];\n     let configport = port::<[u8]>();\n     let tests = [];\n     for file: istr in fs::list_dir(cx.config.src_base) {\n         let file = file;\n-        log #ifmt[\"inspecting file %s\", file];\n+        log #fmt[\"inspecting file %s\", file];\n         if is_test(cx.config, file) {\n             tests += [make_test(cx, file, configport)];\n         }\n@@ -182,7 +182,7 @@ fn make_test(cx: &cx, testfile: &istr, configport: &port<[u8]>) ->\n }\n \n fn make_test_name(config: &config, testfile: &istr) -> istr {\n-    #ifmt[\"[%s] %s\", mode_str(config.mode), testfile]\n+    #fmt[\"[%s] %s\", mode_str(config.mode), testfile]\n }\n \n /*"}, {"sha": "d891e87f5ddafb0af23c13aa92ee6361ca365884", "filename": "src/test/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fheader.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -114,7 +114,7 @@ fn parse_name_value_directive(line: &istr,\n         let value =\n             str::slice(line, colon + str::byte_len(keycolon),\n                        str::byte_len(line));\n-        log #ifmt(\"%s: %s\", directive,\n+        log #fmt(\"%s: %s\", directive,\n                   value);\n         option::some(value)\n     } else { option::none }"}, {"sha": "9128160855b7088bbc8fac9124178134dac7e02a", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -24,7 +24,7 @@ fn run(cx: &cx, _testfile: -[u8]) {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(~\"\\n\\n\");\n     }\n-    log #ifmt[\"running %s\", testfile];\n+    log #fmt[\"running %s\", testfile];\n     let props = load_props(testfile);\n     alt cx.config.mode {\n       mode_compile_fail. { run_cfail_test(cx, props, testfile); }\n@@ -90,12 +90,12 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &istr) {\n \n     let round = 0;\n     while round < rounds {\n-        logv(cx.config, #ifmt[\"pretty-printing round %d\", round]);\n+        logv(cx.config, #fmt[\"pretty-printing round %d\", round]);\n         let procres = print_source(cx, testfile, srcs[round]);\n \n         if procres.status != 0 {\n             fatal_procres(\n-                    #ifmt[\"pretty-printing failed in round %d\", round],\n+                    #fmt[\"pretty-printing failed in round %d\", round],\n                     procres);\n         }\n \n@@ -147,7 +147,7 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &istr) {\n         if expected != actual {\n             error(~\"pretty-printed source does match expected source\");\n             let msg =\n-                #ifmt[\"\\n\\\n+                #fmt[\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n %s\\n\\\n@@ -190,7 +190,7 @@ fn check_error_patterns(props: &test_props, testfile: &istr,\n     let next_err_pat = props.error_patterns[next_err_idx];\n     for line: istr in str::split(procres.stdout, '\\n' as u8) {\n         if str::find(line, next_err_pat) > 0 {\n-            log #ifmt[\"found error pattern %s\",\n+            log #fmt[\"found error pattern %s\",\n                       next_err_pat];\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {\n@@ -206,11 +206,11 @@ fn check_error_patterns(props: &test_props, testfile: &istr,\n                    vec::len(props.error_patterns));\n     if vec::len(missing_patterns) == 1u {\n         fatal_procres(\n-            #ifmt[\"error pattern '%s' not found!\",\n+            #fmt[\"error pattern '%s' not found!\",\n                   missing_patterns[0]], procres);\n     } else {\n         for pattern: istr in missing_patterns {\n-            error(#ifmt[\"error pattern '%s' not found!\",\n+            error(#fmt[\"error pattern '%s' not found!\",\n                         pattern]);\n         }\n         fatal_procres(~\"multiple error patterns not found\", procres);\n@@ -299,7 +299,7 @@ fn program_output(cx: &cx, testfile: &istr, lib_path: &istr, prog: &istr,\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n-            logv(cx.config, #ifmt[\"executing %s\",\n+            logv(cx.config, #fmt[\"executing %s\",\n                                   cmdline]);\n             cmdline\n         };\n@@ -312,7 +312,7 @@ fn program_output(cx: &cx, testfile: &istr, lib_path: &istr, prog: &istr,\n }\n \n fn make_cmdline(libpath: &istr, prog: &istr, args: &[istr]) -> istr {\n-    #ifmt[\"%s %s %s\",\n+    #fmt[\"%s %s %s\",\n           lib_path_cmd_prefix(libpath),\n           prog,\n           str::connect(args, ~\" \")]\n@@ -321,7 +321,7 @@ fn make_cmdline(libpath: &istr, prog: &istr, args: &[istr]) -> istr {\n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n fn lib_path_cmd_prefix(path: &istr) -> istr {\n-        #ifmt[\"%s=\\\"%s\\\"\",\n+        #fmt[\"%s=\\\"%s\\\"\",\n               util::lib_path_env_var(),\n               util::make_new_path(path)]\n }\n@@ -362,14 +362,14 @@ fn output_base_name(config: &config, testfile: &istr) -> istr {\n             parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n             str::connect(parts, ~\".\")\n         };\n-    #ifmt[\"%s%s.%s\", base, filename,\n+    #fmt[\"%s%s.%s\", base, filename,\n                         config.stage_id]\n }\n \n fn maybe_dump_to_stdout(config: &config, out: &istr, err: &istr) {\n     if config.verbose {\n-        let sep1 = #ifmt[\"------%s------------------------------\", ~\"stdout\"];\n-        let sep2 = #ifmt[\"------%s------------------------------\", ~\"stderr\"];\n+        let sep1 = #fmt[\"------%s------------------------------\", ~\"stdout\"];\n+        let sep2 = #fmt[\"------%s------------------------------\", ~\"stderr\"];\n         let sep3 = ~\"------------------------------------------\";\n         io::stdout().write_line(sep1);\n         io::stdout().write_line(out);\n@@ -380,14 +380,14 @@ fn maybe_dump_to_stdout(config: &config, out: &istr, err: &istr) {\n }\n \n fn error(err: &istr) {\n-    io::stdout().write_line(#ifmt[\"\\nerror: %s\", err]);\n+    io::stdout().write_line(#fmt[\"\\nerror: %s\", err]);\n }\n \n fn fatal(err: &istr) -> ! { error(err); fail; }\n \n fn fatal_procres(err: &istr, procres: procres) -> ! {\n     let msg =\n-        #ifmt[\"\\n\\\n+        #fmt[\"\\n\\\n error: %s\\n\\\n command: %s\\n\\\n stdout:\\n\\"}, {"sha": "b15e16b5d4d1caa964535f1854aa6c6590de5352", "filename": "src/test/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Futil.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -11,7 +11,7 @@ fn make_new_path(path: &istr) -> istr {\n     // maintain the current value while adding our own\n     alt getenv(lib_path_env_var()) {\n       option::some(curr) {\n-        #ifmt[\"%s:%s\", path, curr] }\n+        #fmt[\"%s:%s\", path, curr] }\n       option::none. { path }\n     }\n }"}, {"sha": "2791db074466f99dffad79deb6905c0a52903dfb", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -2,4 +2,4 @@\n // no-valgrind\n use std;\n \n-fn main() { let str_var: istr = ~\"meh\"; fail #ifmt[\"%s\", str_var]; }\n+fn main() { let str_var: istr = ~\"meh\"; fail #fmt[\"%s\", str_var]; }"}, {"sha": "dd5fb0b18b3765eb412b4c1d8d892a6d64869ef0", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -167,7 +167,7 @@ mod test_distinguish_syntax_ext {\n     use std;\n \n     fn f() {\n-        #ifmt[\"test%s\", ~\"s\"];\n+        #fmt[\"test%s\", ~\"s\"];\n         #[attr = \"val\"]\n         fn g() { }\n     }"}, {"sha": "32109dc1caa8fca4983df450abc12de88f0bd634", "filename": "src/test/stdtest/qsort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fstdtest%2Fqsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/418d09e547a021ad4853680f7efc3efc8774054c/src%2Ftest%2Fstdtest%2Fqsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort.rs?ref=418d09e547a021ad4853680f7efc3efc8774054c", "patch": "@@ -54,7 +54,7 @@ fn test_simple() {\n  // Silly, but what else can we do?\n     check vec::same_length(expected, immut_names);\n     let pairs = vec::zip(expected, immut_names);\n-    for (a, b) in pairs { log #ifmt[\"%d %d\", a, b]; assert (a == b); }\n+    for (a, b) in pairs { log #fmt[\"%d %d\", a, b]; assert (a == b); }\n }\n \n // Local Variables:"}]}