{"sha": "6a347f3701665a2e01f1f762d6be3b201b73bf42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMzQ3ZjM3MDE2NjVhMmUwMWYxZjc2MmQ2YmUzYjIwMWI3M2JmNDI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-08T11:06:42Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-10T10:16:06Z"}, "message": "resolve: Remove `Deref<Target=Resolver>` implementations\n\nIt's now immediately clear what fields belong to the global resolver state and what are specific to passes/visitors.", "tree": {"sha": "5b612bfaf9eaee0b3f722c4218656f405fbb646b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b612bfaf9eaee0b3f722c4218656f405fbb646b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a347f3701665a2e01f1f762d6be3b201b73bf42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a347f3701665a2e01f1f762d6be3b201b73bf42", "html_url": "https://github.com/rust-lang/rust/commit/6a347f3701665a2e01f1f762d6be3b201b73bf42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a347f3701665a2e01f1f762d6be3b201b73bf42/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df03e420e020c2ccc71bad4f7978b49a1c049435", "url": "https://api.github.com/repos/rust-lang/rust/commits/df03e420e020c2ccc71bad4f7978b49a1c049435", "html_url": "https://github.com/rust-lang/rust/commit/df03e420e020c2ccc71bad4f7978b49a1c049435"}], "stats": {"total": 588, "additions": 269, "deletions": 319}, "files": [{"sha": "25d800212695aef5167f5424a898a46747cf619c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 106, "deletions": 120, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=6a347f3701665a2e01f1f762d6be3b201b73bf42", "patch": "@@ -19,7 +19,6 @@ use rustc::middle::cstore::CrateStore;\n use rustc_metadata::cstore::LoadedMacro;\n \n use std::cell::Cell;\n-use std::ops::{Deref, DerefMut};\n use std::ptr;\n use rustc_data_structures::sync::Lrc;\n \n@@ -94,6 +93,14 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Name>) {\n+        if !field_names.is_empty() {\n+            self.field_names.insert(def_id, field_names);\n+        }\n+    }\n+}\n+\n+impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // If any statements are items, we need to create an anonymous module\n         block.stmts.iter().any(|statement| match statement.node {\n@@ -102,12 +109,6 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn insert_field_names(&mut self, def_id: DefId, field_names: Vec<Name>) {\n-        if !field_names.is_empty() {\n-            self.field_names.insert(def_id, field_names);\n-        }\n-    }\n-\n     fn build_reduced_graph_for_use_tree(\n         &mut self,\n         // This particular use tree\n@@ -165,7 +166,7 @@ impl<'a> Resolver<'a> {\n \n                         if empty_for_self(&module_path) {\n                             resolve_error(\n-                                self,\n+                                &self.r,\n                                 use_tree.span,\n                                 ResolutionError::\n                                 SelfImportOnlyInImportListWithNonEmptyPrefix\n@@ -182,14 +183,14 @@ impl<'a> Resolver<'a> {\n                 } else {\n                     // Disallow `self`\n                     if source.ident.name == kw::SelfLower {\n-                        resolve_error(self,\n+                        resolve_error(&self.r,\n                                       use_tree.span,\n                                       ResolutionError::SelfImportsOnlyAllowedWithin);\n                     }\n \n                     // Disallow `use $crate;`\n                     if source.ident.name == kw::DollarCrate && module_path.is_empty() {\n-                        let crate_root = self.resolve_crate_root(source.ident);\n+                        let crate_root = self.r.resolve_crate_root(source.ident);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(.., name) => name,\n                             ModuleKind::Block(..) => unreachable!(),\n@@ -204,23 +205,23 @@ impl<'a> Resolver<'a> {\n                                     name: kw::PathRoot,\n                                     span: source.ident.span,\n                                 },\n-                                id: Some(self.session.next_node_id()),\n+                                id: Some(self.r.session.next_node_id()),\n                             });\n                             source.ident.name = crate_name;\n                         }\n                         if rename.is_none() {\n                             ident.name = crate_name;\n                         }\n \n-                        self.session.struct_span_warn(item.span, \"`$crate` may not be imported\")\n+                        self.r.session.struct_span_warn(item.span, \"`$crate` may not be imported\")\n                             .note(\"`use $crate;` was erroneously allowed and \\\n                                    will become a hard error in a future release\")\n                             .emit();\n                     }\n                 }\n \n                 if ident.name == kw::Crate {\n-                    self.session.span_err(ident.span,\n+                    self.r.session.span_err(ident.span,\n                         \"crate root imports need to be explicitly named: \\\n                          `use crate as name;`\");\n                 }\n@@ -282,7 +283,7 @@ impl<'a> Resolver<'a> {\n                     None\n                 }).collect::<Vec<_>>();\n                 if self_spans.len() > 1 {\n-                    let mut e = resolve_struct_error(self,\n+                    let mut e = resolve_struct_error(&self.r,\n                         self_spans[0],\n                         ResolutionError::SelfImportCanOnlyAppearOnceInTheList);\n \n@@ -328,17 +329,15 @@ impl<'a> Resolver<'a> {\n             }\n         }\n     }\n-}\n \n-impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item) {\n         let parent_scope = &self.parent_scope.clone();\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n         let ident = item.ident.gensym_if_underscore();\n         let sp = item.span;\n-        let vis = self.resolve_visibility(&item.vis, parent_scope);\n+        let vis = self.r.resolve_visibility(&item.vis, parent_scope);\n \n         match item.node {\n             ItemKind::Use(ref use_tree) => {\n@@ -352,7 +351,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n \n             ItemKind::ExternCrate(orig_name) => {\n                 let module = if orig_name.is_none() && ident.name == kw::SelfLower {\n-                    self.session\n+                    self.r.session\n                         .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n                         .span_suggestion(\n                             item.span,\n@@ -363,25 +362,25 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                         .emit();\n                     return;\n                 } else if orig_name == Some(kw::SelfLower) {\n-                    self.graph_root\n+                    self.r.graph_root\n                 } else {\n-                    let crate_id = self.resolver.crate_loader.process_extern_crate(\n-                        item, &self.resolver.definitions\n+                    let crate_id = self.r.crate_loader.process_extern_crate(\n+                        item, &self.r.definitions\n                     );\n-                    self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n+                    self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n-                self.populate_module_if_necessary(module);\n-                if let Some(name) = self.session.parse_sess.injected_crate_name.try_get() {\n+                self.r.populate_module_if_necessary(module);\n+                if let Some(name) = self.r.session.parse_sess.injected_crate_name.try_get() {\n                     if name.as_str() == ident.name.as_str() {\n-                        self.injected_crate = Some(module);\n+                        self.r.injected_crate = Some(module);\n                     }\n                 }\n \n                 let used = self.process_legacy_macro_imports(item, module, parent_scope);\n                 let binding =\n-                    (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.arenas);\n-                let directive = self.arenas.alloc_import_directive(ImportDirective {\n+                    (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n+                let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n                     root_id: item.id,\n                     id: item.id,\n                     parent_scope: parent_scope.clone(),\n@@ -399,18 +398,18 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                     vis: Cell::new(vis),\n                     used: Cell::new(used),\n                 });\n-                self.potentially_unused_imports.push(directive);\n-                let imported_binding = self.import(binding, directive);\n-                if ptr::eq(parent, self.graph_root) {\n-                    if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n+                self.r.potentially_unused_imports.push(directive);\n+                let imported_binding = self.r.import(binding, directive);\n+                if ptr::eq(parent, self.r.graph_root) {\n+                    if let Some(entry) = self.r.extern_prelude.get(&ident.modern()) {\n                         if expansion != ExpnId::root() && orig_name.is_some() &&\n                            entry.extern_crate_item.is_none() {\n-                            self.session.span_err(item.span, \"macro-expanded `extern crate` items \\\n-                                                              cannot shadow names passed with \\\n-                                                              `--extern`\");\n+                            let msg = \"macro-expanded `extern crate` items cannot \\\n+                                       shadow names passed with `--extern`\";\n+                            self.r.session.span_err(item.span, msg);\n                         }\n                     }\n-                    let entry = self.extern_prelude.entry(ident.modern())\n+                    let entry = self.r.extern_prelude.entry(ident.modern())\n                                                    .or_insert(ExternPreludeEntry {\n                         extern_crate_item: None,\n                         introduced_by_item: true,\n@@ -420,24 +419,24 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                         entry.introduced_by_item = true;\n                     }\n                 }\n-                self.define(parent, ident, TypeNS, imported_binding);\n+                self.r.define(parent, ident, TypeNS, imported_binding);\n             }\n \n             ItemKind::GlobalAsm(..) => {}\n \n             ItemKind::Mod(..) if ident.name == kw::Invalid => {} // Crate root\n \n             ItemKind::Mod(..) => {\n-                let def_id = self.definitions.local_def_id(item.id);\n+                let def_id = self.r.definitions.local_def_id(item.id);\n                 let module_kind = ModuleKind::Def(DefKind::Mod, def_id, ident.name);\n-                let module = self.arenas.alloc_module(ModuleData {\n+                let module = self.r.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, sym::no_implicit_prelude)\n                     },\n                     ..ModuleData::new(Some(parent), module_kind, def_id, expansion, item.span)\n                 });\n-                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n-                self.module_map.insert(def_id, module);\n+                self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n+                self.r.module_map.insert(def_id, module);\n \n                 // Descend into the module.\n                 self.parent_scope.module = module;\n@@ -448,62 +447,62 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n \n             // These items live in the value namespace.\n             ItemKind::Static(..) => {\n-                let res = Res::Def(DefKind::Static, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n-                let res = Res::Def(DefKind::Const, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Const, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n-                let res = Res::Def(DefKind::Fn, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n-                self.define_macro(item, parent_scope);\n+                self.r.define_macro(item, parent_scope);\n             }\n \n             // These items live in the type namespace.\n             ItemKind::TyAlias(..) => {\n-                let res = Res::Def(DefKind::TyAlias, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::TyAlias, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             ItemKind::OpaqueTy(_, _) => {\n-                let res = Res::Def(DefKind::OpaqueTy, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::OpaqueTy, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n                 let module_kind = ModuleKind::Def(\n                     DefKind::Enum,\n-                    self.definitions.local_def_id(item.id),\n+                    self.r.definitions.local_def_id(item.id),\n                     ident.name,\n                 );\n-                let module = self.new_module(parent,\n+                let module = self.r.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n                                              expansion,\n                                              item.span);\n-                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n+                self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n                     self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n                 }\n             }\n \n             ItemKind::TraitAlias(..) => {\n-                let res = Res::Def(DefKind::TraitAlias, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::TraitAlias, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n-                let def_id = self.definitions.local_def_id(item.id);\n+                let def_id = self.r.definitions.local_def_id(item.id);\n                 let res = Res::Def(DefKind::Struct, def_id);\n-                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n+                self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 let mut ctor_vis = vis;\n \n@@ -517,53 +516,53 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n \n                 // Record field names for error reporting.\n                 let field_names = struct_def.fields().iter().filter_map(|field| {\n-                    let field_vis = self.resolve_visibility(&field.vis, parent_scope);\n-                    if ctor_vis.is_at_least(field_vis, &*self.resolver) {\n+                    let field_vis = self.r.resolve_visibility(&field.vis, parent_scope);\n+                    if ctor_vis.is_at_least(field_vis, &*self.r) {\n                         ctor_vis = field_vis;\n                     }\n                     field.ident.map(|ident| ident.name)\n                 }).collect();\n-                let item_def_id = self.definitions.local_def_id(item.id);\n-                self.insert_field_names(item_def_id, field_names);\n+                let item_def_id = self.r.definitions.local_def_id(item.id);\n+                self.r.insert_field_names(item_def_id, field_names);\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if let Some(ctor_node_id) = struct_def.ctor_id() {\n                     let ctor_res = Res::Def(\n                         DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(struct_def)),\n-                        self.definitions.local_def_id(ctor_node_id),\n+                        self.r.definitions.local_def_id(ctor_node_id),\n                     );\n-                    self.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n-                    self.struct_constructors.insert(res.def_id(), (ctor_res, ctor_vis));\n+                    self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n+                    self.r.struct_constructors.insert(res.def_id(), (ctor_res, ctor_vis));\n                 }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n-                let res = Res::Def(DefKind::Union, self.definitions.local_def_id(item.id));\n-                self.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n+                let res = Res::Def(DefKind::Union, self.r.definitions.local_def_id(item.id));\n+                self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n-                    self.resolve_visibility(&field.vis, parent_scope);\n+                    self.r.resolve_visibility(&field.vis, parent_scope);\n                     field.ident.map(|ident| ident.name)\n                 }).collect();\n-                let item_def_id = self.definitions.local_def_id(item.id);\n-                self.insert_field_names(item_def_id, field_names);\n+                let item_def_id = self.r.definitions.local_def_id(item.id);\n+                self.r.insert_field_names(item_def_id, field_names);\n             }\n \n             ItemKind::Impl(..) => {}\n \n             ItemKind::Trait(..) => {\n-                let def_id = self.definitions.local_def_id(item.id);\n+                let def_id = self.r.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n                 let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n-                let module = self.new_module(parent,\n+                let module = self.r.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n                                              expansion,\n                                              item.span);\n-                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n+                self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.parent_scope.module = module;\n             }\n \n@@ -581,9 +580,9 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n         let ident = variant.node.ident;\n \n         // Define a name in the type namespace.\n-        let def_id = self.definitions.local_def_id(variant.node.id);\n+        let def_id = self.r.definitions.local_def_id(variant.node.id);\n         let res = Res::Def(DefKind::Variant, def_id);\n-        self.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n+        self.r.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n@@ -599,42 +598,42 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n         // It's ok to use the variant's id as a ctor id since an\n         // error will be reported on any use of such resolution anyway.\n         let ctor_node_id = variant.node.data.ctor_id().unwrap_or(variant.node.id);\n-        let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n+        let ctor_def_id = self.r.definitions.local_def_id(ctor_node_id);\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n-        self.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n+        self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem) {\n         let (res, ns) = match item.node {\n             ForeignItemKind::Fn(..) => {\n-                (Res::Def(DefKind::Fn, self.definitions.local_def_id(item.id)), ValueNS)\n+                (Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id)), ValueNS)\n             }\n             ForeignItemKind::Static(..) => {\n-                (Res::Def(DefKind::Static, self.definitions.local_def_id(item.id)), ValueNS)\n+                (Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id)), ValueNS)\n             }\n             ForeignItemKind::Ty => {\n-                (Res::Def(DefKind::ForeignTy, self.definitions.local_def_id(item.id)), TypeNS)\n+                (Res::Def(DefKind::ForeignTy, self.r.definitions.local_def_id(item.id)), TypeNS)\n             }\n             ForeignItemKind::Macro(_) => unreachable!(),\n         };\n         let parent = self.parent_scope.module;\n         let expansion = self.parent_scope.expansion;\n-        let vis = self.resolver.resolve_visibility(&item.vis, &self.parent_scope);\n-        self.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n+        let vis = self.r.resolve_visibility(&item.vis, &self.parent_scope);\n+        self.r.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n         let parent = self.parent_scope.module;\n         let expansion = self.parent_scope.expansion;\n         if self.block_needs_anonymous_module(block) {\n-            let module = self.new_module(parent,\n+            let module = self.r.new_module(parent,\n                                          ModuleKind::Block(block.id),\n                                          parent.normal_ancestor_id,\n                                          expansion,\n                                          block.span);\n-            self.block_map.insert(block.id, module);\n+            self.r.block_map.insert(block.id, module);\n             self.parent_scope.module = module; // Descend into the block.\n         }\n     }\n@@ -801,22 +800,22 @@ impl<'a> Resolver<'a> {\n         }\n         module.populated.set(true)\n     }\n+}\n \n+impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     fn legacy_import_macro(&mut self,\n                            name: Name,\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        if self.macro_use_prelude.insert(name, binding).is_some() && !allow_shadowing {\n+        if self.r.macro_use_prelude.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n-            self.session.struct_span_err(span, &msg).note(note).emit();\n+            self.r.session.struct_span_err(span, &msg).note(note).emit();\n         }\n     }\n-}\n \n-impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     /// Returns `true` if we should consider the underlying `extern crate` to be used.\n     fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>,\n                                     parent_scope: &ParentScope<'a>) -> bool {\n@@ -825,16 +824,16 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n         for attr in &item.attrs {\n             if attr.check_name(sym::macro_use) {\n                 if self.parent_scope.module.parent.is_some() {\n-                    span_err!(self.session, item.span, E0468,\n+                    span_err!(self.r.session, item.span, E0468,\n                         \"an `extern crate` loading macros must be at the crate root\");\n                 }\n                 if let ItemKind::ExternCrate(Some(orig_name)) = item.node {\n                     if orig_name == kw::SelfLower {\n-                        self.session.span_err(attr.span,\n+                        self.r.session.span_err(attr.span,\n                             \"`macro_use` is not supported on `extern crate self`\");\n                     }\n                 }\n-                let ill_formed = |span| span_err!(self.session, span, E0466, \"bad macro import\");\n+                let ill_formed = |span| span_err!(self.r.session, span, E0466, \"bad macro import\");\n                 match attr.meta() {\n                     Some(meta) => match meta.node {\n                         MetaItemKind::Word => {\n@@ -854,7 +853,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n             }\n         }\n \n-        let arenas = self.arenas;\n+        let arenas = self.r.arenas;\n         let macro_use_directive = |span| arenas.alloc_import_directive(ImportDirective {\n             root_id: item.id,\n             id: item.id,\n@@ -874,14 +873,14 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n         let allow_shadowing = parent_scope.expansion == ExpnId::root();\n         if let Some(span) = import_all {\n             let directive = macro_use_directive(span);\n-            self.potentially_unused_imports.push(directive);\n+            self.r.potentially_unused_imports.push(directive);\n             module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n-                let imported_binding = self.import(binding, directive);\n+                let imported_binding = self.r.import(binding, directive);\n                 self.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n             });\n         } else {\n             for ident in single_imports.iter().cloned() {\n-                let result = self.resolve_ident_in_module(\n+                let result = self.r.resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n@@ -891,12 +890,12 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                 );\n                 if let Ok(binding) = result {\n                     let directive = macro_use_directive(ident.span);\n-                    self.potentially_unused_imports.push(directive);\n-                    let imported_binding = self.import(binding, directive);\n+                    self.r.potentially_unused_imports.push(directive);\n+                    let imported_binding = self.r.import(binding, directive);\n                     self.legacy_import_macro(ident.name, imported_binding,\n                                              ident.span, allow_shadowing);\n                 } else {\n-                    span_err!(self.session, ident.span, E0469, \"imported macro not found\");\n+                    span_err!(self.r.session, ident.span, E0469, \"imported macro not found\");\n                 }\n             }\n         }\n@@ -908,7 +907,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n         for attr in attrs {\n             if attr.check_name(sym::macro_escape) {\n                 let msg = \"macro_escape is a deprecated synonym for macro_use\";\n-                let mut err = self.session.struct_span_warn(attr.span, msg);\n+                let mut err = self.r.session.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"consider an outer attribute, `#[macro_use]` mod ...\").emit();\n                 } else {\n@@ -919,7 +918,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n             }\n \n             if !attr.is_word() {\n-                self.session.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n+                self.r.session.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n             }\n             return true;\n         }\n@@ -929,35 +928,22 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n }\n \n pub struct BuildReducedGraphVisitor<'a, 'b> {\n-    pub resolver: &'a mut Resolver<'b>,\n+    pub r: &'a mut Resolver<'b>,\n     pub parent_scope: ParentScope<'b>,\n }\n \n-impl<'b> Deref for BuildReducedGraphVisitor<'_, 'b> {\n-    type Target = Resolver<'b>;\n-    fn deref(&self) -> &Self::Target {\n-        self.resolver\n-    }\n-}\n-\n-impl<'b> DerefMut for BuildReducedGraphVisitor<'_, 'b> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.resolver\n-    }\n-}\n-\n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n         self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n \n-        let invocation_data = self.arenas.alloc_invocation_data(InvocationData {\n+        let invocation_data = self.r.arenas.alloc_invocation_data(InvocationData {\n             module: self.parent_scope.module,\n             parent_legacy_scope: self.parent_scope.legacy,\n             output_legacy_scope: Cell::new(None),\n         });\n-        let old_invocation_data = self.invocations.insert(invoc_id, invocation_data);\n+        let old_invocation_data = self.r.invocations.insert(invoc_id, invocation_data);\n         assert!(old_invocation_data.is_none(), \"invocation data is reset for an invocation\");\n \n         invocation_data\n@@ -985,7 +971,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n             ItemKind::MacroDef(..) => {\n-                self.parent_scope.legacy = self.resolver.define_macro(item, &self.parent_scope);\n+                self.parent_scope.legacy = self.r.define_macro(item, &self.parent_scope);\n                 return\n             }\n             ItemKind::Mac(..) => {\n@@ -1042,12 +1028,12 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n \n         // Add the item to the trait info.\n-        let item_def_id = self.definitions.local_def_id(item.id);\n+        let item_def_id = self.r.definitions.local_def_id(item.id);\n         let (res, ns) = match item.node {\n             TraitItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n             TraitItemKind::Method(ref sig, _) => {\n                 if sig.decl.has_self() {\n-                    self.has_self.insert(item_def_id);\n+                    self.r.has_self.insert(item_def_id);\n                 }\n                 (Res::Def(DefKind::Method, item_def_id), ValueNS)\n             }\n@@ -1057,7 +1043,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n         let vis = ty::Visibility::Public;\n         let expansion = self.parent_scope.expansion;\n-        self.resolver.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n+        self.r.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n \n         self.parent_scope.module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);"}, {"sha": "922da7eef7a2ac8fa207382eab73e1ba084d67bc", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=6a347f3701665a2e01f1f762d6be3b201b73bf42", "patch": "@@ -23,8 +23,6 @@\n //  - `check_crate` finally emits the diagnostics based on the data generated\n //    in the last step\n \n-use std::ops::{Deref, DerefMut};\n-\n use crate::Resolver;\n use crate::resolve_imports::ImportDirectiveSubclass;\n \n@@ -49,45 +47,30 @@ impl<'a> UnusedImport<'a> {\n }\n \n struct UnusedImportCheckVisitor<'a, 'b> {\n-    resolver: &'a mut Resolver<'b>,\n+    r: &'a mut Resolver<'b>,\n     /// All the (so far) unused imports, grouped path list\n     unused_imports: NodeMap<UnusedImport<'a>>,\n     base_use_tree: Option<&'a ast::UseTree>,\n     base_id: ast::NodeId,\n     item_span: Span,\n }\n \n-// Deref and DerefMut impls allow treating UnusedImportCheckVisitor as Resolver.\n-impl<'a, 'b> Deref for UnusedImportCheckVisitor<'a, 'b> {\n-    type Target = Resolver<'b>;\n-\n-    fn deref<'c>(&'c self) -> &'c Resolver<'b> {\n-        &*self.resolver\n-    }\n-}\n-\n-impl<'a, 'b> DerefMut for UnusedImportCheckVisitor<'a, 'b> {\n-    fn deref_mut<'c>(&'c mut self) -> &'c mut Resolver<'b> {\n-        &mut *self.resolver\n-    }\n-}\n-\n impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     // We have information about whether `use` (import) directives are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, id: ast::NodeId) {\n         let mut used = false;\n-        self.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n+        self.r.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n         if !used {\n-            if self.maybe_unused_trait_imports.contains(&id) {\n+            if self.r.maybe_unused_trait_imports.contains(&id) {\n                 // Check later.\n                 return;\n             }\n             self.unused_import(self.base_id).add(id);\n         } else {\n             // This trait import is definitely used, in a way other than\n             // method resolution.\n-            self.maybe_unused_trait_imports.remove(&id);\n+            self.r.maybe_unused_trait_imports.remove(&id);\n             if let Some(i) = self.unused_imports.get_mut(&self.base_id) {\n                 i.unused.remove(&id);\n             }\n@@ -271,7 +254,7 @@ pub fn check_crate(resolver: &mut Resolver<'_>, krate: &ast::Crate) {\n     }\n \n     let mut visitor = UnusedImportCheckVisitor {\n-        resolver,\n+        r: resolver,\n         unused_imports: Default::default(),\n         base_use_tree: None,\n         base_id: ast::DUMMY_NODE_ID,\n@@ -304,7 +287,7 @@ pub fn check_crate(resolver: &mut Resolver<'_>, krate: &ast::Crate) {\n         let ms = MultiSpan::from_spans(spans.clone());\n         let mut span_snippets = spans.iter()\n             .filter_map(|s| {\n-                match visitor.session.source_map().span_to_snippet(*s) {\n+                match visitor.r.session.source_map().span_to_snippet(*s) {\n                     Ok(s) => Some(format!(\"`{}`\", s)),\n                     _ => None,\n                 }\n@@ -326,7 +309,7 @@ pub fn check_crate(resolver: &mut Resolver<'_>, krate: &ast::Crate) {\n             \"remove the unused import\"\n         };\n \n-        visitor.session.buffer_lint_with_diagnostic(\n+        visitor.r.session.buffer_lint_with_diagnostic(\n             lint::builtin::UNUSED_IMPORTS,\n             unused.use_tree_id,\n             ms,"}, {"sha": "3a39307849e133b83743dbc2b35d8162e9f33b10", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=6a347f3701665a2e01f1f762d6be3b201b73bf42", "patch": "@@ -396,7 +396,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n-        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((path, Vec::new()))\n@@ -420,7 +420,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n-        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -451,7 +451,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n-        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((path, Vec::new()))\n@@ -484,13 +484,13 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // 1) some consistent ordering for emitted dignostics, and\n         // 2) `std` suggestions before `core` suggestions.\n         let mut extern_crate_names =\n-            self.resolver.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n+            self.r.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n         extern_crate_names.sort_by_key(|name| Reverse(name.as_str()));\n \n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid.\n             path[0].ident.name = name;\n-            let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+            let result = self.r.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n             if let PathResult::Module(..) = result {\n@@ -556,7 +556,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 //   ie. `use a::b::{c, d, e};`\n                 //                      ^^^\n                 let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n-                    self.resolver.session, directive.span, directive.use_span,\n+                    self.r.session, directive.span, directive.use_span,\n                 );\n                 debug!(\"check_for_module_export_macro: found_closing_brace={:?} binding_span={:?}\",\n                        found_closing_brace, binding_span);\n@@ -571,7 +571,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     //   ie. `use a::b::{c, d};`\n                     //                    ^^^\n                     if let Some(previous_span) = extend_span_to_previous_binding(\n-                        self.resolver.session, binding_span,\n+                        self.r.session, binding_span,\n                     ) {\n                         debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n                         removal_span = removal_span.with_lo(previous_span.lo());\n@@ -589,12 +589,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 //   or  `use a::{b, c, d}};`\n                 //               ^^^^^^^^^^^\n                 let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n-                    self.resolver.session, module_name, directive.use_span,\n+                    self.r.session, module_name, directive.use_span,\n                 );\n                 debug!(\"check_for_module_export_macro: has_nested={:?} after_crate_name={:?}\",\n                        has_nested, after_crate_name);\n \n-                let source_map = self.resolver.session.source_map();\n+                let source_map = self.r.session.source_map();\n \n                 // Add the import to the start, with a `{` if required.\n                 let start_point = source_map.start_point(after_crate_name);"}, {"sha": "fe0760364f3a758b202678c239d7319106512e97", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 64, "deletions": 77, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=6a347f3701665a2e01f1f762d6be3b201b73bf42", "patch": "@@ -24,7 +24,6 @@ use syntax_pos::Span;\n \n use std::collections::BTreeSet;\n use std::mem::replace;\n-use std::ops::{Deref, DerefMut};\n \n mod diagnostics;\n \n@@ -69,7 +68,7 @@ impl PatternSource {\n }\n \n struct LateResolutionVisitor<'a, 'b> {\n-    resolver: &'b mut Resolver<'a>,\n+    r: &'b mut Resolver<'a>,\n \n     /// The module that represents the current item scope.\n     parent_scope: ParentScope<'a>,\n@@ -101,19 +100,6 @@ struct LateResolutionVisitor<'a, 'b> {\n     current_type_ascription: Vec<Span>,\n }\n \n-impl<'a> Deref for LateResolutionVisitor<'a, '_> {\n-    type Target = Resolver<'a>;\n-    fn deref(&self) -> &Self::Target {\n-        self.resolver\n-    }\n-}\n-\n-impl<'a> DerefMut for LateResolutionVisitor<'a, '_> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.resolver\n-    }\n-}\n-\n /// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n     fn visit_item(&mut self, item: &'tcx Item) {\n@@ -146,7 +132,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n                 let self_ty = Ident::with_empty_ctxt(kw::SelfUpper);\n                 let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Res::Err, |d| d.res());\n-                self.record_partial_res(ty.id, PartialRes::new(res));\n+                self.r.record_partial_res(ty.id, PartialRes::new(res));\n             }\n             _ => (),\n         }\n@@ -295,7 +281,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let parent_scope = resolver.dummy_parent_scope();\n         let graph_root = resolver.graph_root;\n         LateResolutionVisitor {\n-            resolver,\n+            r: resolver,\n             parent_scope,\n             ribs: PerNS {\n                 value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n@@ -318,7 +304,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                       record_used_id: Option<NodeId>,\n                                       path_span: Span)\n                                       -> Option<LexicalScopeBinding<'a>> {\n-        self.resolver.resolve_ident_in_lexical_scope(\n+        self.r.resolve_ident_in_lexical_scope(\n             ident, ns, &self.parent_scope, record_used_id, path_span, &self.ribs[ns]\n         )\n     }\n@@ -331,7 +317,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        self.resolver.resolve_path_with_ribs(\n+        self.r.resolve_path_with_ribs(\n             path, opt_ns, &self.parent_scope, record_used, path_span, crate_lint, &self.ribs\n         )\n     }\n@@ -357,15 +343,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n     {\n-        let id = self.definitions.local_def_id(id);\n-        let module = self.module_map.get(&id).cloned(); // clones a reference\n+        let id = self.r.definitions.local_def_id(id);\n+        let module = self.r.module_map.get(&id).cloned(); // clones a reference\n         if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = replace(&mut self.parent_scope.module, module);\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n-            self.finalize_current_module_macro_resolutions(module);\n+            self.r.finalize_current_module_macro_resolutions(module);\n             let ret = f(self);\n \n             self.parent_scope.module = orig_module;\n@@ -390,7 +376,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n                 MacroDefinition(def) => {\n-                    if def == self.macro_def(ident.span.ctxt()) {\n+                    if def == self.r.macro_def(ident.span.ctxt()) {\n                         ident.span.remove_mark();\n                     }\n                 }\n@@ -411,7 +397,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         debug!(\"resolve_adt\");\n         self.with_current_self_item(item, |this| {\n             this.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n-                let item_def_id = this.definitions.local_def_id(item.id);\n+                let item_def_id = this.r.definitions.local_def_id(item.id);\n                 this.with_self_rib(Res::SelfTy(None, Some(item_def_id)), |this| {\n                     visit::walk_item(this, item);\n                 });\n@@ -433,7 +419,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             };\n             let report_error = |this: &Self, ns| {\n                 let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n-                this.session.span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n+                this.r.session.span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n             };\n \n             for &ns in nss {\n@@ -443,13 +429,13 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     }\n                     Some(LexicalScopeBinding::Item(binding)) => {\n                         let orig_blacklisted_binding =\n-                            replace(&mut self.blacklisted_binding, Some(binding));\n+                            replace(&mut self.r.blacklisted_binding, Some(binding));\n                         if let Some(LexicalScopeBinding::Res(..)) =\n                                 self.resolve_ident_in_lexical_scope(ident, ns, None,\n                                                                     use_tree.prefix.span) {\n                             report_error(self, ns);\n                         }\n-                        self.blacklisted_binding = orig_blacklisted_binding;\n+                        self.r.blacklisted_binding = orig_blacklisted_binding;\n                     }\n                     None => {}\n                 }\n@@ -491,7 +477,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n-                    let local_def_id = this.definitions.local_def_id(item.id);\n+                    let local_def_id = this.r.definitions.local_def_id(item.id);\n                     this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n@@ -536,7 +522,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n-                    let local_def_id = this.definitions.local_def_id(item.id);\n+                    let local_def_id = this.r.definitions.local_def_id(item.id);\n                     this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n@@ -596,17 +582,17 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                     ident.name,\n                                     *span,\n                                 );\n-                                resolve_error(self, param.ident.span, err);\n+                                resolve_error(&self.r, param.ident.span, err);\n                             }\n                             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n                             // Plain insert (no renaming).\n                             let res = Res::Def(\n                                 DefKind::TyParam,\n-                                self.definitions.local_def_id(param.id),\n+                                self.r.definitions.local_def_id(param.id),\n                             );\n                             function_type_rib.bindings.insert(ident, res);\n-                            self.record_partial_res(param.id, PartialRes::new(res));\n+                            self.r.record_partial_res(param.id, PartialRes::new(res));\n                         }\n                         GenericParamKind::Const { .. } => {\n                             let ident = param.ident.modern();\n@@ -618,16 +604,16 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                     ident.name,\n                                     *span,\n                                 );\n-                                resolve_error(self, param.ident.span, err);\n+                                resolve_error(&self.r, param.ident.span, err);\n                             }\n                             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n                             let res = Res::Def(\n                                 DefKind::ConstParam,\n-                                self.definitions.local_def_id(param.id),\n+                                self.r.definitions.local_def_id(param.id),\n                             );\n                             function_value_rib.bindings.insert(ident, res);\n-                            self.record_partial_res(param.id, PartialRes::new(res));\n+                            self.r.record_partial_res(param.id, PartialRes::new(res));\n                         }\n                     }\n                 }\n@@ -786,7 +772,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             this.with_self_rib(Res::SelfTy(None, None), |this| {\n                 // Resolve the trait reference, if necessary.\n                 this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n-                    let item_def_id = this.definitions.local_def_id(item_id);\n+                    let item_def_id = this.r.definitions.local_def_id(item_id);\n                     this.with_self_rib(Res::SelfTy(trait_id, Some(item_def_id)), |this| {\n                         if let Some(trait_ref) = opt_trait_reference.as_ref() {\n                             // Resolve type arguments in the trait path.\n@@ -801,7 +787,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                             this.with_self_struct_ctor_rib(item_def_id, |this| {\n                                 debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n                                 for impl_item in impl_items {\n-                                    this.resolver.resolve_visibility(\n+                                    this.r.resolve_visibility(\n                                         &impl_item.vis, &this.parent_scope\n                                     );\n                                     // We also need a new scope for the impl item type parameters.\n@@ -878,7 +864,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if self.resolver.resolve_ident_in_module(\n+            if self.r.resolve_ident_in_module(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n@@ -887,7 +873,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 span,\n             ).is_err() {\n                 let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n-                resolve_error(self, span, err(ident.name, &path_names_to_string(path)));\n+                resolve_error(&self.r, span, err(ident.name, &path_names_to_string(path)));\n             }\n         }\n     }\n@@ -912,7 +898,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.partial_res_map.get(&pat.id)\n+                if sub_pat.is_some() || match self.r.partial_res_map.get(&pat.id)\n                                                                   .map(|res| res.base_res()) {\n                     Some(Res::Local(..)) => true,\n                     _ => false,\n@@ -985,14 +971,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut missing_vars = missing_vars.iter().collect::<Vec<_>>();\n         missing_vars.sort();\n         for (_, v) in missing_vars {\n-            resolve_error(self,\n+            resolve_error(&self.r,\n                           *v.origin.iter().next().unwrap(),\n                           ResolutionError::VariableNotBoundInPattern(v));\n         }\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();\n         for (name, v) in inconsistent_vars {\n-            resolve_error(self, v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n+            let err = ResolutionError::VariableBoundWithDifferentMode(*name, v.1);\n+            resolve_error(&self.r, v.0, err);\n         }\n     }\n \n@@ -1023,15 +1010,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         debug!(\"(resolving block) entering block\");\n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.parent_scope.module;\n-        let anonymous_module = self.block_map.get(&block.id).cloned(); // clones a reference\n+        let anonymous_module = self.r.block_map.get(&block.id).cloned(); // clones a reference\n \n         let mut num_macro_definition_ribs = 0;\n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");\n             self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.parent_scope.module = anonymous_module;\n-            self.finalize_current_module_macro_resolutions(anonymous_module);\n+            self.r.finalize_current_module_macro_resolutions(anonymous_module);\n         } else {\n             self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n         }\n@@ -1041,7 +1028,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             if let StmtKind::Item(ref item) = stmt.node {\n                 if let ItemKind::MacroDef(..) = item.node {\n                     num_macro_definition_ribs += 1;\n-                    let res = self.definitions.local_def_id(item.id);\n+                    let res = self.r.definitions.local_def_id(item.id);\n                     self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n                     self.label_ribs.push(Rib::new(MacroDefinition(res)));\n                 }\n@@ -1081,7 +1068,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n                 resolve_error(\n-                    self,\n+                    &self.r,\n                     ident.span,\n                     ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n                         &ident.as_str())\n@@ -1090,7 +1077,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             Some(..) if pat_src == PatternSource::FnParam => {\n                 // `fn f(a: u8, a: u8)`, error\n                 resolve_error(\n-                    self,\n+                    &self.r,\n                     ident.span,\n                     ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n                         &ident.as_str())\n@@ -1143,7 +1130,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                             Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n-                                self.record_use(ident, ValueNS, binding.unwrap(), false);\n+                                self.r.record_use(ident, ValueNS, binding.unwrap(), false);\n                                 Some(res)\n                             }\n                             Res::Def(DefKind::Ctor(..), _)\n@@ -1155,7 +1142,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                 // but we still conservatively report an error, see\n                                 // issues/33118#issuecomment-233962221 for one reason why.\n                                 resolve_error(\n-                                    self,\n+                                    &self.r,\n                                     ident.span,\n                                     ResolutionError::BindingShadowsSomethingUnacceptable(\n                                         pat_src.descr(), ident.name, binding.unwrap())\n@@ -1176,7 +1163,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                         self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n                     });\n \n-                    self.record_partial_res(pat.id, PartialRes::new(res));\n+                    self.r.record_partial_res(pat.id, PartialRes::new(res));\n                 }\n \n                 PatKind::TupleStruct(ref path, ..) => {\n@@ -1233,9 +1220,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n             let def_id = this.parent_scope.module.normal_ancestor_id;\n-            let node_id = this.definitions.as_local_node_id(def_id).unwrap();\n+            let node_id = this.r.definitions.as_local_node_id(def_id).unwrap();\n             let better = res.is_some();\n-            this.use_injections.push(UseError { err, candidates, node_id, better });\n+            this.r.use_injections.push(UseError { err, candidates, node_id, better });\n             PartialRes::new(Res::Err)\n         };\n \n@@ -1257,11 +1244,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                     let mut res = None;\n                     if let Res::Def(DefKind::Struct, def_id) = partial_res.base_res() {\n                         if let Some((ctor_res, ctor_vis))\n-                                = self.struct_constructors.get(&def_id).cloned() {\n+                                = self.r.struct_constructors.get(&def_id).cloned() {\n                             if is_expected(ctor_res) &&\n-                               self.is_accessible_from(ctor_vis, self.parent_scope.module) {\n+                               self.r.is_accessible_from(ctor_vis, self.parent_scope.module) {\n                                 let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n-                                self.session.buffer_lint(lint, id, span,\n+                                self.r.session.buffer_lint(lint, id, span,\n                                     \"private struct constructors are not usable through \\\n                                      re-exports in outer modules\",\n                                 );\n@@ -1280,12 +1267,12 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 if ns == ValueNS {\n                     let item_name = path.last().unwrap().ident;\n                     let traits = self.get_traits_containing_item(item_name, ns);\n-                    self.trait_map.insert(id, traits);\n+                    self.r.trait_map.insert(id, traits);\n                 }\n \n                 let mut std_path = vec![Segment::from_ident(Ident::with_empty_ctxt(sym::std))];\n                 std_path.extend(path);\n-                if self.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n+                if self.r.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n                     let cl = CrateLint::No;\n                     let ns = Some(ns);\n                     if let PathResult::Module(_) | PathResult::NonModule(_) =\n@@ -1294,7 +1281,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                         let item_span = path.iter().last().map(|segment| segment.ident.span)\n                             .unwrap_or(span);\n                         debug!(\"accessed item from `std` submodule as a bare type {:?}\", std_path);\n-                        let mut hm = self.session.confused_type_with_std_module.borrow_mut();\n+                        let mut hm = self.r.session.confused_type_with_std_module.borrow_mut();\n                         hm.insert(item_span, span);\n                         // In some places (E0223) we only have access to the full path\n                         hm.insert(span, span);\n@@ -1307,7 +1294,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n         if let PathSource::TraitItem(..) = source {} else {\n             // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n-            self.record_partial_res(id, partial_res);\n+            self.r.record_partial_res(id, partial_res);\n         }\n         partial_res\n     }\n@@ -1358,7 +1345,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         if qself.is_none() {\n             let path_seg = |seg: &Segment| PathSegment::from_ident(seg.ident);\n             let path = Path { segments: path.iter().map(path_seg).collect(), span };\n-            if let Ok((_, res)) = self.resolver.resolve_macro_path(\n+            if let Ok((_, res)) = self.r.resolve_macro_path(\n                 &path, None, &self.parent_scope, false, false\n             ) {\n                 return Some(PartialRes::new(res));\n@@ -1453,15 +1440,16 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             PathResult::Module(ModuleOrUniformRoot::Module(_)) |\n             PathResult::Failed { .. }\n                     if (ns == TypeNS || path.len() > 1) &&\n-                       self.primitive_type_table.primitive_types\n+                       self.r.primitive_type_table.primitive_types\n                            .contains_key(&path[0].ident.name) => {\n-                let prim = self.primitive_type_table.primitive_types[&path[0].ident.name];\n+                let prim = self.r.primitive_type_table.primitive_types[&path[0].ident.name];\n                 PartialRes::with_unresolved_segments(Res::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 PartialRes::new(module.res().unwrap()),\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n-                resolve_error(self, span, ResolutionError::FailedToResolve { label, suggestion });\n+                let err = ResolutionError::FailedToResolve { label, suggestion };\n+                resolve_error(&self.r, span, err);\n                 PartialRes::new(Res::Err)\n             }\n             PathResult::Module(..) | PathResult::Failed { .. } => return None,\n@@ -1487,7 +1475,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             };\n             if result.base_res() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n-                self.session.buffer_lint(lint, id, span, \"unnecessary qualification\")\n+                self.r.session.buffer_lint(lint, id, span, \"unnecessary qualification\")\n             }\n         }\n \n@@ -1550,15 +1538,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                             });\n                             find_best_match_for_name(names, &*ident.as_str(), None)\n                         });\n-                        self.record_partial_res(expr.id, PartialRes::new(Res::Err));\n-                        resolve_error(self,\n+                        self.r.record_partial_res(expr.id, PartialRes::new(Res::Err));\n+                        resolve_error(&self.r,\n                                       label.ident.span,\n                                       ResolutionError::UndeclaredLabel(&label.ident.as_str(),\n                                                                        close_match));\n                     }\n                     Some(node_id) => {\n                         // Since this res is a label, it is never read.\n-                        self.label_res_map.insert(expr.id, node_id);\n+                        self.r.label_res_map.insert(expr.id, node_id);\n                         self.unused_labels.remove(&node_id);\n                     }\n                 }\n@@ -1670,13 +1658,13 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n                 let traits = self.get_traits_containing_item(ident, ValueNS);\n-                self.trait_map.insert(expr.id, traits);\n+                self.r.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(ref segment, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\",\n                        expr.id);\n                 let traits = self.get_traits_containing_item(segment.ident, ValueNS);\n-                self.trait_map.insert(expr.id, traits);\n+                self.r.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n                 // Nothing to do.\n@@ -1691,7 +1679,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if self.resolver.resolve_ident_in_module(\n+            if self.r.resolve_ident_in_module(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n@@ -1709,11 +1697,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n             search_module = unwrap_or!(\n-                self.hygienic_lexical_parent(search_module, &mut ident.span), break\n+                self.r.hygienic_lexical_parent(search_module, &mut ident.span), break\n             );\n         }\n \n-        if let Some(prelude) = self.prelude {\n+        if let Some(prelude) = self.r.prelude {\n             if !search_module.no_implicit_prelude {\n                 self.get_traits_in_module_containing_item(ident, ns, prelude, &mut found_traits);\n             }\n@@ -1752,7 +1740,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 ).is_none() {\n                     continue\n                 }\n-                if self.resolver.resolve_ident_in_module_unadjusted(\n+                if self.r.resolve_ident_in_module_unadjusted(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     ns,\n@@ -1780,8 +1768,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                trait_name: Ident) -> SmallVec<[NodeId; 1]> {\n         let mut import_ids = smallvec![];\n         while let NameBindingKind::Import { directive, binding, .. } = kind {\n-            self.maybe_unused_trait_imports.insert(directive.id);\n-            self.add_to_glob_map(&directive, trait_name);\n+            self.r.maybe_unused_trait_imports.insert(directive.id);\n+            self.r.add_to_glob_map(&directive, trait_name);\n             import_ids.push(directive.id);\n             kind = &binding.kind;\n         };\n@@ -1791,9 +1779,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n impl<'a> Resolver<'a> {\n     pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n+        self.finalize_current_module_macro_resolutions(self.graph_root);\n         let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n-        let module = late_resolution_visitor.parent_scope.module;\n-        late_resolution_visitor.finalize_current_module_macro_resolutions(module);\n         visit::walk_crate(&mut late_resolution_visitor, krate);\n         for (id, span) in late_resolution_visitor.unused_labels.iter() {\n             self.session.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");"}, {"sha": "9c9eb017aef7df6646700c4c67def21dd5b7bf80", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=6a347f3701665a2e01f1f762d6be3b201b73bf42", "patch": "@@ -100,7 +100,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         };\n \n         let code = DiagnosticId::Error(code.into());\n-        let mut err = self.session.struct_span_err_with_code(base_span, &base_msg, code);\n+        let mut err = self.r.session.struct_span_err_with_code(base_span, &base_msg, code);\n \n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n         if [\"this\", \"my\"].contains(&&*item_str.as_str())\n@@ -143,7 +143,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n         // Try to lookup name in more relaxed fashion for better error reporting.\n         let ident = path.last().unwrap().ident;\n-        let candidates = self.lookup_import_candidates(ident, ns, is_expected)\n+        let candidates = self.r.lookup_import_candidates(ident, ns, is_expected)\n             .drain(..)\n             .filter(|ImportSuggestion { did, .. }| {\n                 match (did, res.and_then(|res| res.opt_def_id())) {\n@@ -155,7 +155,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         let crate_def_id = DefId::local(CRATE_DEF_INDEX);\n         if candidates.is_empty() && is_expected(Res::Def(DefKind::Enum, crate_def_id)) {\n             let enum_candidates =\n-                self.lookup_import_candidates(ident, ns, is_enum_variant);\n+                self.r.lookup_import_candidates(ident, ns, is_enum_variant);\n             let mut enum_candidates = enum_candidates.iter()\n                 .map(|suggestion| {\n                     import_candidate_to_enum_paths(&suggestion)\n@@ -267,7 +267,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         // parser issue where a struct literal is being used on an expression\n         // where a brace being opened means a block is being started. Look\n         // ahead for the next text to see if `span` is followed by a `{`.\n-        let sm = self.session.source_map();\n+        let sm = self.r.session.source_map();\n         let mut sp = span;\n         loop {\n             sp = sm.next_point(sp);\n@@ -429,9 +429,9 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             },\n             (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n                 if let Some((ctor_def, ctor_vis))\n-                        = self.struct_constructors.get(&def_id).cloned() {\n+                        = self.r.struct_constructors.get(&def_id).cloned() {\n                     let accessible_ctor =\n-                        self.is_accessible_from(ctor_vis, self.parent_scope.module);\n+                        self.r.is_accessible_from(ctor_vis, self.parent_scope.module);\n                     if is_expected(ctor_def) && !accessible_ctor {\n                         err.span_label(\n                             span,\n@@ -482,11 +482,11 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n             if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n                 // Look for a field with the same name in the current self_type.\n-                if let Some(resolution) = self.partial_res_map.get(&node_id) {\n+                if let Some(resolution) = self.r.partial_res_map.get(&node_id) {\n                     match resolution.base_res() {\n                         Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n                                 if resolution.unresolved_segments() == 0 => {\n-                            if let Some(field_names) = self.field_names.get(&did) {\n+                            if let Some(field_names) = self.r.field_names.get(&did) {\n                                 if field_names.iter().any(|&field_name| ident.name == field_name) {\n                                     return Some(AssocSuggestion::Field);\n                                 }\n@@ -506,7 +506,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n         // Look for associated items in the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if let Ok(binding) = self.resolver.resolve_ident_in_module(\n+            if let Ok(binding) = self.r.resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     ns,\n@@ -516,7 +516,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 ) {\n                 let res = binding.res();\n                 if filter_fn(res) {\n-                    return Some(if self.has_self.contains(&res.def_id()) {\n+                    return Some(if self.r.has_self.contains(&res.def_id()) {\n                         AssocSuggestion::MethodWithSelf\n                     } else {\n                         AssocSuggestion::AssocItem\n@@ -556,8 +556,9 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                     } else {\n                         // Items from the prelude\n                         if !module.no_implicit_prelude {\n-                            names.extend(self.extern_prelude.clone().iter().flat_map(|(ident, _)| {\n-                                self.crate_loader\n+                            let extern_prelude = self.r.extern_prelude.clone();\n+                            names.extend(extern_prelude.iter().flat_map(|(ident, _)| {\n+                                self.r.crate_loader\n                                     .maybe_process_path_extern(ident.name, ident.span)\n                                     .and_then(|crate_id| {\n                                         let crate_mod = Res::Def(\n@@ -576,7 +577,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                                     })\n                             }));\n \n-                            if let Some(prelude) = self.prelude {\n+                            if let Some(prelude) = self.r.prelude {\n                                 add_module_candidates(prelude, &mut names, &filter_fn);\n                             }\n                         }\n@@ -587,7 +588,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n             // Add primitive types to the mix\n             if filter_fn(Res::PrimTy(PrimTy::Bool)) {\n                 names.extend(\n-                    self.primitive_type_table.primitive_types.iter().map(|(name, prim_ty)| {\n+                    self.r.primitive_type_table.primitive_types.iter().map(|(name, prim_ty)| {\n                         TypoSuggestion::from_res(*name, Res::PrimTy(*prim_ty))\n                     })\n                 )\n@@ -622,7 +623,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n     /// Only used in a specific case of type ascription suggestions\n     fn get_colon_suggestion_span(&self, start: Span) -> Span {\n-        let cm = self.session.source_map();\n+        let cm = self.r.session.source_map();\n         start.to(cm.next_point(start))\n     }\n \n@@ -632,7 +633,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         base_span: Span,\n     ) {\n         debug!(\"type_ascription_suggetion {:?}\", base_span);\n-        let cm = self.session.source_map();\n+        let cm = self.r.session.source_map();\n         let base_snippet = cm.span_to_snippet(base_span);\n         debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n         if let Some(sp) = self.current_type_ascription.last() {\n@@ -711,13 +712,13 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n     fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n         let mut result = None;\n         let mut seen_modules = FxHashSet::default();\n-        let mut worklist = vec![(self.graph_root, Vec::new())];\n+        let mut worklist = vec![(self.r.graph_root, Vec::new())];\n \n         while let Some((in_module, path_segments)) = worklist.pop() {\n             // abort if the module is already found\n             if result.is_some() { break; }\n \n-            self.populate_module_if_necessary(in_module);\n+            self.r.populate_module_if_necessary(in_module);\n \n             in_module.for_each_child_stable(|ident, _, name_binding| {\n                 // abort if the module is already found or if name_binding is private external\n@@ -750,7 +751,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n \n     fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n         self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n-            self.populate_module_if_necessary(enum_module);\n+            self.r.populate_module_if_necessary(enum_module);\n \n             let mut variants = Vec::new();\n             enum_module.for_each_child_stable(|ident, _, name_binding| {"}, {"sha": "4aa3e2f9167737d6c1d82449cef23fb40b582192", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6a347f3701665a2e01f1f762d6be3b201b73bf42", "patch": "@@ -1732,7 +1732,7 @@ impl<'a> Resolver<'a> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n-        ImportResolver { resolver: self }.finalize_imports();\n+        ImportResolver { r: self }.finalize_imports();\n \n         self.late_resolve_crate(krate);\n "}, {"sha": "fed8e555d2bb3d71fffb0ae638d2500f7173af09", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=6a347f3701665a2e01f1f762d6be3b201b73bf42", "patch": "@@ -174,7 +174,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n         self.invocations.extend(derives.iter().map(|&derive| (derive, invocation)));\n         let mut visitor = BuildReducedGraphVisitor {\n-            resolver: self,\n+            r: self,\n             parent_scope: ParentScope {\n                 module: invocation.module,\n                 expansion: expn_id,\n@@ -194,7 +194,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn resolve_imports(&mut self) {\n-        ImportResolver { resolver: self }.resolve_imports()\n+        ImportResolver { r: self }.resolve_imports()\n     }\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: ExpnId, force: bool)"}, {"sha": "2ae2b1f3fc3e87c137108d11c7f765080a5a0e54", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a347f3701665a2e01f1f762d6be3b201b73bf42/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=6a347f3701665a2e01f1f762d6be3b201b73bf42", "patch": "@@ -9,6 +9,7 @@ use crate::{Resolver, Segment};\n use crate::{names_to_string, module_to_string};\n use crate::{resolve_error, ResolutionError};\n use crate::ModuleKind;\n+use crate::build_reduced_graph::BuildReducedGraphVisitor;\n use crate::diagnostics::Suggestion;\n \n use errors::Applicability;\n@@ -417,7 +418,9 @@ impl<'a> Resolver<'a> {\n         // No resolution and no one else can define the name - determinate error.\n         Err((Determined, Weak::No))\n     }\n+}\n \n+impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n                                 module_path: Vec<Segment>,\n@@ -430,7 +433,7 @@ impl<'a> Resolver<'a> {\n                                 vis: ty::Visibility,\n                                 parent_scope: ParentScope<'a>) {\n         let current_module = parent_scope.module;\n-        let directive = self.arenas.alloc_import_directive(ImportDirective {\n+        let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n             parent_scope,\n             module_path,\n             imported_module: Cell::new(None),\n@@ -448,10 +451,10 @@ impl<'a> Resolver<'a> {\n \n         debug!(\"add_import_directive({:?})\", directive);\n \n-        self.indeterminate_imports.push(directive);\n+        self.r.indeterminate_imports.push(directive);\n         match directive.subclass {\n             SingleImport { target, type_ns_only, .. } => {\n-                self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n+                self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n                     let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n                     resolution.single_imports.insert(PtrKey(directive));\n                 });\n@@ -463,7 +466,9 @@ impl<'a> Resolver<'a> {\n             _ => unreachable!(),\n         }\n     }\n+}\n \n+impl<'a> Resolver<'a> {\n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n     crate fn import(&self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n@@ -638,25 +643,12 @@ struct UnresolvedImportError {\n }\n \n pub struct ImportResolver<'a, 'b> {\n-    pub resolver: &'a mut Resolver<'b>,\n-}\n-\n-impl<'a, 'b> std::ops::Deref for ImportResolver<'a, 'b> {\n-    type Target = Resolver<'b>;\n-    fn deref(&self) -> &Resolver<'b> {\n-        self.resolver\n-    }\n-}\n-\n-impl<'a, 'b> std::ops::DerefMut for ImportResolver<'a, 'b> {\n-    fn deref_mut(&mut self) -> &mut Resolver<'b> {\n-        self.resolver\n-    }\n+    pub r: &'a mut Resolver<'b>,\n }\n \n impl<'a, 'b> ty::DefIdTree for &'a ImportResolver<'a, 'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n-        self.resolver.parent(id)\n+        self.r.parent(id)\n     }\n }\n \n@@ -672,29 +664,29 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     pub fn resolve_imports(&mut self) {\n-        let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n-        while self.indeterminate_imports.len() < prev_num_indeterminates {\n-            prev_num_indeterminates = self.indeterminate_imports.len();\n-            for import in mem::take(&mut self.indeterminate_imports) {\n+        let mut prev_num_indeterminates = self.r.indeterminate_imports.len() + 1;\n+        while self.r.indeterminate_imports.len() < prev_num_indeterminates {\n+            prev_num_indeterminates = self.r.indeterminate_imports.len();\n+            for import in mem::take(&mut self.r.indeterminate_imports) {\n                 match self.resolve_import(&import) {\n-                    true => self.determined_imports.push(import),\n-                    false => self.indeterminate_imports.push(import),\n+                    true => self.r.determined_imports.push(import),\n+                    false => self.r.indeterminate_imports.push(import),\n                 }\n             }\n         }\n     }\n \n     pub fn finalize_imports(&mut self) {\n-        for module in self.arenas.local_modules().iter() {\n+        for module in self.r.arenas.local_modules().iter() {\n             self.finalize_resolutions_in(module);\n         }\n \n         let mut has_errors = false;\n         let mut seen_spans = FxHashSet::default();\n         let mut errors = vec![];\n         let mut prev_root_id: NodeId = NodeId::from_u32(0);\n-        for i in 0 .. self.determined_imports.len() {\n-            let import = self.determined_imports[i];\n+        for i in 0 .. self.r.determined_imports.len() {\n+            let import = self.r.determined_imports[i];\n             if let Some(err) = self.finalize_import(import) {\n                 has_errors = true;\n \n@@ -709,7 +701,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n                 // If the error is a single failed import then create a \"fake\" import\n                 // resolution for it so that later resolve stages won't complain.\n-                self.import_dummy_binding(import);\n+                self.r.import_dummy_binding(import);\n                 if prev_root_id.as_u32() != 0\n                         && prev_root_id.as_u32() != import.root_id.as_u32()\n                         && !errors.is_empty() {\n@@ -738,7 +730,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n         if !has_errors {\n-            for import in &self.indeterminate_imports {\n+            for import in &self.r.indeterminate_imports {\n                 self.throw_unresolved_import_error(errors, Some(MultiSpan::from(import.span)));\n                 break;\n             }\n@@ -777,7 +769,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             (span, msg)\n         };\n \n-        let mut diag = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n+        let mut diag = struct_span_err!(self.r.session, span, E0432, \"{}\", &msg);\n \n         if let Some((_, UnresolvedImportError { note, .. })) = errors.iter().last() {\n             for message in note {\n@@ -813,7 +805,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n             let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n-            let path_res = self.resolve_path(\n+            let path_res = self.r.resolve_path(\n                 &directive.module_path,\n                 None,\n                 &directive.parent_scope,\n@@ -844,7 +836,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         };\n \n         let mut indeterminate = false;\n-        self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n+        self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             if let Err(Undetermined) = source_bindings[ns].get() {\n                 // For better failure detection, pretend that the import will\n                 // not define any names while resolving its module path.\n@@ -896,10 +888,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         directive: &'b ImportDirective<'b>\n     ) -> Option<UnresolvedImportError> {\n         let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n-        let prev_ambiguity_errors_len = self.ambiguity_errors.len();\n-        let path_res = self.resolve_path(&directive.module_path, None, &directive.parent_scope,\n+        let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n+        let path_res = self.r.resolve_path(&directive.module_path, None, &directive.parent_scope,\n                                          true, directive.span, directive.crate_lint());\n-        let no_ambiguity = self.ambiguity_errors.len() == prev_ambiguity_errors_len;\n+        let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n         directive.vis.set(orig_vis);\n         let module = match path_res {\n             PathResult::Module(module) => {\n@@ -909,10 +901,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         span_bug!(directive.span, \"inconsistent resolution for an import\");\n                     }\n                 } else {\n-                    if self.privacy_errors.is_empty() {\n+                    if self.r.privacy_errors.is_empty() {\n                         let msg = \"cannot determine resolution for the import\";\n                         let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                        self.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n+                        self.r.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n                     }\n                 }\n \n@@ -921,7 +913,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 if no_ambiguity {\n                     assert!(directive.imported_module.get().is_none());\n-                    resolve_error(self, span, ResolutionError::FailedToResolve {\n+                    resolve_error(&self.r, span, ResolutionError::FailedToResolve {\n                         label,\n                         suggestion,\n                     });\n@@ -983,7 +975,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n                     let mut full_path = directive.module_path.clone();\n                     full_path.push(Segment::from_ident(Ident::invalid()));\n-                    self.lint_if_path_starts_with_module(\n+                    self.r.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n                         &full_path,\n                         directive.span,\n@@ -1006,15 +998,15 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                    max_vis.get() != ty::Visibility::Invisible && // Allow empty globs.\n                    !max_vis.get().is_at_least(directive.vis.get(), &*self) {\n                     let msg = \"A non-empty glob must import something with the glob's visibility\";\n-                    self.session.span_err(directive.span, msg);\n+                    self.r.session.span_err(directive.span, msg);\n                 }\n                 return None;\n             }\n             _ => unreachable!(),\n         };\n \n         let mut all_ns_err = true;\n-        self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n+        self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n             let orig_blacklisted_binding =\n                 mem::replace(&mut this.blacklisted_binding, target_bindings[ns].get());\n@@ -1069,7 +1061,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         if all_ns_err {\n             let mut all_ns_failed = true;\n-            self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n+            self.r.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n                 let binding = this.resolve_ident_in_module(\n                     module, ident, ns, &directive.parent_scope, true, directive.span\n                 );\n@@ -1148,14 +1140,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 })\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n-                self.import_dummy_binding(directive);\n+                self.r.import_dummy_binding(directive);\n                 None\n             }\n         }\n \n         let mut reexport_error = None;\n         let mut any_successful_reexport = false;\n-        self.per_ns(|this, ns| {\n+        self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n                 let vis = directive.vis.get();\n                 if !binding.pseudo_vis().is_at_least(vis, &*this) {\n@@ -1174,12 +1166,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                    re-exported (error E0365), consider declaring with \\\n                                    `pub`\",\n                                    ident);\n-                self.session.buffer_lint(PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n+                self.r.session.buffer_lint(PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n                                          directive.id,\n                                          directive.span,\n                                          &msg);\n             } else if ns == TypeNS {\n-                struct_span_err!(self.session, directive.span, E0365,\n+                struct_span_err!(self.r.session, directive.span, E0365,\n                                  \"`{}` is private, and cannot be re-exported\", ident)\n                     .span_label(directive.span, format!(\"re-export of private `{}`\", ident))\n                     .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n@@ -1188,7 +1180,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let msg = format!(\"`{}` is private, and cannot be re-exported\", ident);\n                 let note_msg =\n                     format!(\"consider marking `{}` as `pub` in the imported module\", ident);\n-                struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n+                struct_span_err!(self.r.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n             }\n@@ -1199,7 +1191,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             // 2 segments, so the `resolve_path` above won't trigger it.\n             let mut full_path = directive.module_path.clone();\n             full_path.push(Segment::from_ident(ident));\n-            self.per_ns(|this, ns| {\n+            self.r.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n                     this.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n@@ -1214,7 +1206,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        self.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n+        self.r.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n             this.import_res_map.entry(directive.id).or_default()[ns] = Some(binding.res());\n         });\n \n@@ -1261,7 +1253,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             macro_ns: None,\n         };\n \n-        self.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n+        self.r.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n             if binding.res() == Res::Err {\n                 return;\n             }\n@@ -1299,7 +1291,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             let mut redundant_spans: Vec<_> = redundant_span.present_items().collect();\n             redundant_spans.sort();\n             redundant_spans.dedup();\n-            self.session.buffer_lint_with_diagnostic(\n+            self.r.session.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n                 directive.id,\n                 directive.span,\n@@ -1313,20 +1305,20 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let module = match directive.imported_module.get().unwrap() {\n             ModuleOrUniformRoot::Module(module) => module,\n             _ => {\n-                self.session.span_err(directive.span, \"cannot glob-import all possible crates\");\n+                self.r.session.span_err(directive.span, \"cannot glob-import all possible crates\");\n                 return;\n             }\n         };\n \n-        self.populate_module_if_necessary(module);\n+        self.r.populate_module_if_necessary(module);\n \n         if module.is_trait() {\n-            self.session.span_err(directive.span, \"items in traits are not importable.\");\n+            self.r.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n         } else if module.def_id() == directive.parent_scope.module.def_id()  {\n             return;\n         } else if let GlobImport { is_prelude: true, .. } = directive.subclass {\n-            self.prelude = Some(module);\n+            self.r.prelude = Some(module);\n             return;\n         }\n \n@@ -1340,18 +1332,19 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n-                Some(Some(def)) => self.macro_def_scope(def),\n+                Some(Some(def)) => self.r.macro_def_scope(def),\n                 Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n-            if self.is_accessible_from(binding.pseudo_vis(), scope) {\n-                let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n+            if self.r.is_accessible_from(binding.pseudo_vis(), scope) {\n+                let imported_binding = self.r.import(binding, directive);\n+                let _ =\n+                    self.r.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        self.record_partial_res(directive.id, PartialRes::new(module.res().unwrap()));\n+        self.r.record_partial_res(directive.id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n@@ -1380,7 +1373,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 if res != Res::Err {\n                     if let Some(def_id) = res.opt_def_id() {\n                         if !def_id.is_local() {\n-                            self.cstore.export_macros_untracked(def_id.krate);\n+                            self.r.cstore.export_macros_untracked(def_id.krate);\n                         }\n                     }\n                     reexports.push(Export {\n@@ -1406,7 +1399,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n                                                 Some(binding.span),\n                                                 msg.clone());\n-                                let fresh = self.session.one_time_diagnostics\n+                                let fresh = self.r.session.one_time_diagnostics\n                                     .borrow_mut().insert(error_id);\n                                 if !fresh {\n                                     continue;\n@@ -1415,7 +1408,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             },\n                             ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n                         };\n-                        let mut err = self.session.struct_span_err(binding.span, &msg);\n+                        let mut err = self.r.session.struct_span_err(binding.span, &msg);\n \n                         let imported_module = match directive.imported_module.get() {\n                             Some(ModuleOrUniformRoot::Module(module)) => module,\n@@ -1431,16 +1424,16 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         let enum_span = enum_resolution.borrow()\n                             .binding.expect(\"binding should exist\")\n                             .span;\n-                        let enum_def_span = self.session.source_map().def_span(enum_span);\n-                        let enum_def_snippet = self.session.source_map()\n+                        let enum_def_span = self.r.session.source_map().def_span(enum_span);\n+                        let enum_def_snippet = self.r.session.source_map()\n                             .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n                         // potentially need to strip extant `crate`/`pub(path)` for suggestion\n                         let after_vis_index = enum_def_snippet.find(\"enum\")\n                             .expect(\"`enum` keyword should exist in snippet\");\n                         let suggestion = format!(\"pub {}\",\n                                                  &enum_def_snippet[after_vis_index..]);\n \n-                        self.session\n+                        self.r.session\n                             .diag_span_suggestion_once(&mut err,\n                                                        DiagnosticMessageId::ErrorId(0),\n                                                        enum_def_span,\n@@ -1453,7 +1446,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         if reexports.len() > 0 {\n             if let Some(def_id) = module.def_id() {\n-                self.export_map.insert(def_id, reexports);\n+                self.r.export_map.insert(def_id, reexports);\n             }\n         }\n     }"}]}