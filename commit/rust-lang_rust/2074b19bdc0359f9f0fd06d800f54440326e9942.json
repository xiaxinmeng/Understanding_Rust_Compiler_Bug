{"sha": "2074b19bdc0359f9f0fd06d800f54440326e9942", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNzRiMTliZGMwMzU5ZjlmMGZkMDZkODAwZjU0NDQwMzI2ZTk5NDI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-09T18:04:30Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-16T17:38:07Z"}, "message": "More docs for std::io::BufRead", "tree": {"sha": "c9116468eedb406705118fe73d2df4498c6f7017", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9116468eedb406705118fe73d2df4498c6f7017"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2074b19bdc0359f9f0fd06d800f54440326e9942", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2074b19bdc0359f9f0fd06d800f54440326e9942", "html_url": "https://github.com/rust-lang/rust/commit/2074b19bdc0359f9f0fd06d800f54440326e9942", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2074b19bdc0359f9f0fd06d800f54440326e9942/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4e93196e16030ebf7a20c473849534235d676f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e93196e16030ebf7a20c473849534235d676f8", "html_url": "https://github.com/rust-lang/rust/commit/e4e93196e16030ebf7a20c473849534235d676f8"}], "stats": {"total": 218, "additions": 186, "deletions": 32}, "files": [{"sha": "60ac89790aaaaea71c18aee3950ba3da6274f553", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 186, "deletions": 32, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/2074b19bdc0359f9f0fd06d800f54440326e9942/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2074b19bdc0359f9f0fd06d800f54440326e9942/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=2074b19bdc0359f9f0fd06d800f54440326e9942", "patch": "@@ -505,59 +505,136 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n     }\n }\n \n-/// A `BufRead` is a type of reader which has some form of internal buffering to\n-/// allow certain kinds of reading operations to be more optimized than others.\n+/// A `BufRead` is a type of `Read`er which has an internal buffer, allowing it\n+/// to perform extra ways of reading.\n ///\n-/// This type extends the `Read` trait with a few methods that are not\n-/// possible to reasonably implement with purely a read interface.\n+/// For example, reading line-by-line requires using a buffer, so if you want\n+/// to read by line, you'll need `BufRead`, which includes a\n+/// [`read_line()`][readline] method as well as a [`lines()`][lines] iterator.\n+///\n+/// [readline]: #method.read_line\n+/// [lines]: #method.lines\n+///\n+/// # Examples\n+///\n+/// A locked standard input implements `BufRead`:\n+///\n+/// ```\n+/// use std::io;\n+/// use std::io::BufRead;\n+///\n+/// let stdin = io::stdin();\n+/// for line in stdin.lock().lines() {\n+///     println!(\"{}\", line.unwrap());\n+/// }\n+/// ```\n+///\n+/// If you have something that implements `Read`, you can use the [`BufReader`\n+/// type][bufreader] to turn it into a `BufRead`.\n+///\n+/// For example, [`File`][file] implements `Read`, but not `BufRead`.\n+/// `BufReader` to the rescue!\n+///\n+/// [bufreader]: struct.BufReader.html\n+/// [file]: ../fs/struct.File.html\n+///\n+/// ```\n+/// use std::io;\n+/// use std::fs::File;\n+/// use std::io::BufRead;\n+/// use std::io::BufReader;\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// let f = try!(File::open(\"foo.txt\"));\n+/// let f = BufReader::new(f);\n+///\n+/// for line in f.lines() {\n+///     println!(\"{}\", line.unwrap());\n+/// }\n+///\n+/// # Ok(())\n+/// # }\n+/// ```\n ///\n-/// You can use the [`BufReader` wrapper type](struct.BufReader.html) to turn any\n-/// reader into a buffered reader.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BufRead: Read {\n     /// Fills the internal buffer of this object, returning the buffer contents.\n     ///\n-    /// None of the contents will be \"read\" in the sense that later calling\n-    /// `read` may return the same contents.\n+    /// This function is a lower-level call. It needs to be paired with the\n+    /// [`consume`][consume] method to function properly. When calling this\n+    /// method, none of the contents will be \"read\" in the sense that later\n+    /// calling `read` may return the same contents. As such, `consume` must be\n+    /// called with the number of bytes that are consumed from this buffer to\n+    /// ensure that the bytes are never returned twice.\n     ///\n-    /// The `consume` function must be called with the number of bytes that are\n-    /// consumed from this buffer returned to ensure that the bytes are never\n-    /// returned twice.\n+    /// [consume]: #tymethod.consume\n     ///\n     /// An empty buffer returned indicates that the stream has reached EOF.\n     ///\n     /// # Errors\n     ///\n     /// This function will return an I/O error if the underlying reader was\n     /// read, but returned an error.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`:\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    /// let mut stdin = stdin.lock();\n+    ///\n+    /// // we can't have two `&mut` references to `stdin`, so use a block\n+    /// // to end the borrow early.\n+    /// let length = {\n+    ///     let buffer = stdin.fill_buf().unwrap();\n+    ///\n+    ///     // work with buffer\n+    ///     println!(\"{:?}\", buffer);\n+    ///\n+    ///     buffer.len()\n+    /// };\n+    ///\n+    /// // ensure the bytes we worked with aren't returned again later\n+    /// stdin.consume(length);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fill_buf(&mut self) -> Result<&[u8]>;\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n     /// so they should no longer be returned in calls to `read`.\n     ///\n-    /// This function does not perform any I/O, it simply informs this object\n-    /// that some amount of its buffer, returned from `fill_buf`, has been\n-    /// consumed and should no longer be returned.\n+    /// This function is a lower-level call. It needs to be paired with the\n+    /// [`fill_buf`][fillbuf] method to function properly. This function does\n+    /// not perform any I/O, it simply informs this object that some amount of\n+    /// its buffer, returned from `fill_buf`, has been consumed and should no\n+    /// longer be returned. As such, this function may do odd things if\n+    /// `fill_buf` isn't called before calling it.\n+    ///\n+    /// [fillbuf]: #tymethod.fill_buff\n+    ///\n+    /// The `amt` must be `<=` the number of bytes in the buffer returned by\n+    /// `fill_buf`.\n     ///\n-    /// This function is used to tell the buffer how many bytes you've consumed\n-    /// from the return value of `fill_buf`, and so may do odd things if\n-    /// `fill_buf` isn't called before calling this.\n+    /// # Examples\n     ///\n-    /// The `amt` must be `<=` the number of bytes in the buffer returned by `fill_buf`.\n+    /// Since `consume()` is meant to be used with [`fill_buf()`][fillbuf],\n+    /// that method's example includes an example of `consume()`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn consume(&mut self, amt: usize);\n \n-    /// Read all bytes until the delimiter `byte` is reached.\n+    /// Read all bytes into `buf` until the delimiter `byte` is reached.\n     ///\n-    /// This function will continue to read (and buffer) bytes from the\n-    /// underlying stream until the delimiter or EOF is found. Once found, all\n-    /// bytes up to, and including, the delimiter (if found) will be appended to\n-    /// `buf`.\n+    /// This function will read bytes from the underlying stream until the\n+    /// delimiter or EOF is found. Once found, all bytes up to, and including,\n+    /// the delimiter (if found) will be appended to `buf`.\n     ///\n-    /// If this buffered reader is currently at EOF, then this function will not\n-    /// place any more bytes into `buf` and will return `Ok(n)` where `n` is the\n-    /// number of bytes which were read.\n+    /// If this reader is currently at EOF then this function will not modify\n+    /// `buf` and will return `Ok(n)` where `n` is the number of bytes which\n+    /// were read.\n     ///\n     /// # Errors\n     ///\n@@ -566,18 +643,39 @@ pub trait BufRead: Read {\n     ///\n     /// If an I/O error is encountered then all bytes read so far will be\n     /// present in `buf` and its length will have been adjusted appropriately.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`. In this example, we'll\n+    /// read from standard input until we see an `a` byte.\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// fn foo() -> io::Result<()> {\n+    /// let stdin = io::stdin();\n+    /// let mut stdin = stdin.lock();\n+    /// let mut buffer = Vec::new();\n+    ///\n+    /// try!(stdin.read_until(b'a', &mut buffer));\n+    ///\n+    /// println!(\"{:?}\", buffer);\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> {\n         read_until(self, byte, buf)\n     }\n \n-    /// Read all bytes until a newline (the 0xA byte) is reached, and\n-    /// append them to the provided buffer.\n+    /// Read all bytes until a newline (the 0xA byte) is reached, and append\n+    /// them to the provided buffer.\n     ///\n-    /// This function will continue to read (and buffer) bytes from the\n-    /// underlying stream until the newline delimiter (the 0xA byte) or EOF is\n-    /// found. Once found, all bytes up to, and including, the delimiter (if\n-    /// found) will be appended to `buf`.\n+    /// This function will read bytes from the underlying stream until the\n+    /// newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes\n+    /// up to, and including, the delimiter (if found) will be appended to\n+    /// `buf`.\n     ///\n     /// If this reader is currently at EOF then this function will not modify\n     /// `buf` and will return `Ok(n)` where `n` is the number of bytes which\n@@ -589,6 +687,31 @@ pub trait BufRead: Read {\n     /// return an error if the read bytes are not valid UTF-8. If an I/O error\n     /// is encountered then `buf` may contain some bytes already read in the\n     /// event that all data read so far was valid UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`. In this example, we'll\n+    /// read all of the lines from standard input. If we were to do this in\n+    /// an actual project, the [`lines()`][lines] method would be easier, of\n+    /// course.\n+    ///\n+    /// [lines]: #method.lines\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    /// let mut stdin = stdin.lock();\n+    /// let mut buffer = String::new();\n+    ///\n+    /// while stdin.read_line(&mut buffer).unwrap() > 0 {\n+    ///     // work with buffer\n+    ///     println!(\"{:?}\", buffer);\n+    ///\n+    ///     buffer.clear();\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_line(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we are not calling the `.read_until` method here, but\n@@ -606,6 +729,22 @@ pub trait BufRead: Read {\n     ///\n     /// This function will yield errors whenever `read_until` would have also\n     /// yielded an error.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`. In this example, we'll\n+    /// read some input from standard input, splitting on commas.\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    ///\n+    /// for content in stdin.lock().split(b',') {\n+    ///     println!(\"{:?}\", content.unwrap());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split(self, byte: u8) -> Split<Self> where Self: Sized {\n         Split { buf: self, delim: byte }\n@@ -616,6 +755,21 @@ pub trait BufRead: Read {\n     /// The iterator returned from this function will yield instances of\n     /// `io::Result<String>`. Each string returned will *not* have a newline\n     /// byte (the 0xA byte) at the end.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`:\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    ///\n+    /// for line in stdin.lock().lines() {\n+    ///     println!(\"{}\", line.unwrap());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(self) -> Lines<Self> where Self: Sized {\n         Lines { buf: self }"}]}