{"sha": "189440c7b55ce892fe931c42b02c4c8178a6cc0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4OTQ0MGM3YjU1Y2U4OTJmZTkzMWM0MmIwMmM0YzgxNzhhNmNjMGE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-23T15:02:39Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-23T15:02:39Z"}, "message": "Add a Union to the base item completion test fixture", "tree": {"sha": "f0e226cbfe25db66e116ef4a092eab1ad248f7fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0e226cbfe25db66e116ef4a092eab1ad248f7fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/189440c7b55ce892fe931c42b02c4c8178a6cc0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/189440c7b55ce892fe931c42b02c4c8178a6cc0a", "html_url": "https://github.com/rust-lang/rust/commit/189440c7b55ce892fe931c42b02c4c8178a6cc0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/189440c7b55ce892fe931c42b02c4c8178a6cc0a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8de3f7ee538b0fee7783c18b03042dc3f12ca84b", "html_url": "https://github.com/rust-lang/rust/commit/8de3f7ee538b0fee7783c18b03042dc3f12ca84b"}], "stats": {"total": 276, "additions": 134, "deletions": 142}, "files": [{"sha": "4b2aaa1d7a45130c9e4049933185db78d719223e", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=189440c7b55ce892fe931c42b02c4c8178a6cc0a", "patch": "@@ -255,60 +255,6 @@ mod tests {\n         expect.assert_eq(&actual);\n     }\n \n-    fn check_builtin(ra_fixture: &str, expect: Expect) {\n-        let actual = filtered_completion_list(ra_fixture, CompletionKind::BuiltinType);\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn dont_complete_primitive_in_use() {\n-        check_builtin(r#\"use self::$0;\"#, expect![[\"\"]]);\n-    }\n-\n-    #[test]\n-    fn dont_complete_primitive_in_module_scope() {\n-        check_builtin(r#\"fn foo() { self::$0 }\"#, expect![[\"\"]]);\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant() {\n-        check(\n-            r#\"\n-enum E { Foo, Bar(i32) }\n-fn foo() { let _ = E::$0 }\n-\"#,\n-            expect![[r#\"\n-                ev Foo    ()\n-                ev Bar(\u2026) (i32)\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_struct_associated_items() {\n-        check(\n-            r#\"\n-//- /lib.rs\n-struct S;\n-\n-impl S {\n-    fn a() {}\n-    fn b(&self) {}\n-    const C: i32 = 42;\n-    type T = i32;\n-}\n-\n-fn foo() { let _ = S::$0 }\n-\"#,\n-            expect![[r#\"\n-                fn a()  fn()\n-                me b(\u2026) fn(&self)\n-                ct C    const C: i32 = 42;\n-                ta T    type T = i32;\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn associated_item_visibility() {\n         check(\n@@ -336,21 +282,6 @@ fn foo() { let _ = S::$0 }\n         );\n     }\n \n-    #[test]\n-    fn completes_enum_associated_method() {\n-        check(\n-            r#\"\n-enum E {};\n-impl E { fn m() { } }\n-\n-fn foo() { let _ = E::$0 }\n-        \"#,\n-            expect![[r#\"\n-                fn m() fn()\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_union_associated_method() {\n         check("}, {"sha": "b8d60dfd2c3dbc398b6c5636c4b5007be77eb244", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=189440c7b55ce892fe931c42b02c4c8178a6cc0a", "patch": "@@ -1,11 +1,12 @@\n //! Tests and test utilities for completions.\n //!\n-//! Most tests live in this module or its submodules unless for very specific completions like\n-//! `attributes` or `lifetimes` where the completed concept is a distinct thing.\n-//! Notable examples for completions that are being tested in this module's submodule are paths.\n-//! Another exception are `check_edit` tests which usually live in the completion modules themselves,\n-//! as the main purpose of this test module here is to give the developer an overview of whats being\n-//! completed where, not how.\n+//! Most tests live in this module or its submodules. The tests in these submodules are \"location\"\n+//! oriented, that is they try to check completions for something like type position, param position\n+//! etc.\n+//! Tests that are more orientated towards specific completion types like visibility checks of path\n+//! completions or `check_edit` tests usually live in their respective completion modules instead.\n+//! This gives this test module and its submodules here the main purpose of giving the developer an\n+//! overview of whats being completed where, not how.\n \n mod attribute;\n mod expression;\n@@ -55,6 +56,7 @@ macro_rules! makro {}\n #[rustc_builtin_macro]\n pub macro Clone {}\n fn function() {}\n+union Union { field: i32 }\n \"#;\n \n pub(crate) const TEST_CONFIG: CompletionConfig = CompletionConfig {"}, {"sha": "cf22fb20ab1e1306576d06c132da655a9b8efa43", "filename": "crates/ide_completion/src/tests/expression.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fexpression.rs?ref=189440c7b55ce892fe931c42b02c4c8178a6cc0a", "patch": "@@ -70,6 +70,7 @@ impl Unit {\n     }\n }\n \"#,\n+        // `self` is in here twice, once as the module, once as the local\n         expect![[r##\"\n             kw unsafe\n             kw fn\n@@ -114,12 +115,42 @@ impl Unit {\n             ?? Unresolved\n             fn function()   fn()\n             sc STATIC\n+            un Union\n             ev TupleV(\u2026)    (u32)\n             ct CONST\n             ma makro!(\u2026)    #[macro_export] macro_rules! makro\n             me self.foo()   fn(self)\n         \"##]],\n     );\n+    check(\n+        r#\"\n+use non_existant::Unresolved;\n+mod qualified { pub enum Enum { Variant } }\n+\n+impl Unit {\n+    fn foo<'lifetime, TypeParam, const CONST_PARAM: usize>(self) {\n+        fn local_func() {}\n+        self::$0\n+    }\n+}\n+\"#,\n+        expect![[r##\"\n+            tt Trait\n+            en Enum\n+            st Record\n+            st Tuple\n+            md module\n+            st Unit\n+            md qualified\n+            ma makro!(\u2026)  #[macro_export] macro_rules! makro\n+            ?? Unresolved\n+            fn function() fn()\n+            sc STATIC\n+            un Union\n+            ev TupleV(\u2026)  (u32)\n+            ct CONST\n+        \"##]],\n+    );\n }\n \n #[test]\n@@ -247,3 +278,27 @@ fn quux(x: i32) {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn enum_qualified() {\n+    check(\n+        r#\"\n+impl Enum {\n+    type AssocType = ();\n+    const ASSOC_CONST: () = ();\n+    fn assoc_fn() {}\n+}\n+fn func() {\n+    Enum::$0\n+}\n+\"#,\n+        expect![[r#\"\n+            ev TupleV(\u2026)   (u32)\n+            ev RecordV     { field: u32 }\n+            ev UnitV       ()\n+            ct ASSOC_CONST const ASSOC_CONST: () = ();\n+            fn assoc_fn()  fn()\n+            ta AssocType   type AssocType = ();\n+        \"#]],\n+    );\n+}"}, {"sha": "ad87bdc7513d26f18147921732a6049c26d5818a", "filename": "crates/ide_completion/src/tests/item.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem.rs?ref=189440c7b55ce892fe931c42b02c4c8178a6cc0a", "patch": "@@ -28,6 +28,7 @@ impl Tra$0\n             md module\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n@@ -51,6 +52,7 @@ impl Trait for Str$0\n             md module\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],"}, {"sha": "5791921e448282f0c3282bb05e2f13b28cbb7fd6", "filename": "crates/ide_completion/src/tests/pattern.rs", "status": "modified", "additions": 34, "deletions": 59, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs?ref=189440c7b55ce892fe931c42b02c4c8178a6cc0a", "patch": "@@ -3,19 +3,19 @@ use expect_test::{expect, Expect};\n \n use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n \n-fn check(ra_fixture: &str, expect: Expect) {\n+fn check_empty(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(ra_fixture);\n     expect.assert_eq(&actual)\n }\n \n-fn check_with(ra_fixture: &str, expect: Expect) {\n+fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{}\\n{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n     expect.assert_eq(&actual)\n }\n \n #[test]\n fn ident_rebind_pat() {\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let en$0 @ x\n@@ -29,7 +29,7 @@ fn quux() {\n \n #[test]\n fn ident_ref_pat() {\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let ref en$0\n@@ -39,7 +39,7 @@ fn quux() {\n             kw mut\n         \"#]],\n     );\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let ref en$0 @ x\n@@ -54,7 +54,7 @@ fn quux() {\n #[test]\n fn ident_ref_mut_pat() {\n     // FIXME mut is already here, don't complete it again\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let ref mut en$0\n@@ -64,7 +64,7 @@ fn quux() {\n             kw mut\n         \"#]],\n     );\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let ref mut en$0 @ x\n@@ -78,7 +78,7 @@ fn quux() {\n \n #[test]\n fn ref_pat() {\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let &en$0\n@@ -89,7 +89,7 @@ fn quux() {\n         \"#]],\n     );\n     // FIXME mut is already here, don't complete it again\n-    check(\n+    check_empty(\n         r#\"\n fn quux() {\n     let &mut en$0\n@@ -103,7 +103,7 @@ fn quux() {\n \n #[test]\n fn refutable() {\n-    check_with(\n+    check(\n         r#\"\n fn foo() {\n     if let a$0\n@@ -129,7 +129,7 @@ fn foo() {\n \n #[test]\n fn irrefutable() {\n-    check_with(\n+    check(\n         r#\"\n fn foo() {\n    let a$0\n@@ -150,7 +150,7 @@ fn foo() {\n \n #[test]\n fn in_param() {\n-    check_with(\n+    check(\n         r#\"\n fn foo(a$0) {\n }\n@@ -170,7 +170,7 @@ fn foo(a$0) {\n \n #[test]\n fn only_fn_like_macros() {\n-    check(\n+    check_empty(\n         r#\"\n macro_rules! m { ($e:expr) => { $e } }\n \n@@ -190,7 +190,7 @@ fn foo() {\n \n #[test]\n fn in_simple_macro_call() {\n-    check(\n+    check_empty(\n         r#\"\n macro_rules! m { ($e:expr) => { $e } }\n enum E { X }\n@@ -210,7 +210,7 @@ fn foo() {\n \n #[test]\n fn omits_private_fields_pat() {\n-    check(\n+    check_empty(\n         r#\"\n mod foo {\n     pub struct Record { pub field: i32, _field: i32 }\n@@ -235,32 +235,9 @@ fn outer() {\n     )\n }\n \n-// #[test]\n-// fn only_shows_ident_completion() {\n-//     check_edit(\n-//         \"Foo\",\n-//         r#\"\n-// struct Foo(i32);\n-// fn main() {\n-//     match Foo(92) {\n-//         a$0(92) => (),\n-//     }\n-// }\n-// \"#,\n-//         r#\"\n-// struct Foo(i32);\n-// fn main() {\n-//     match Foo(92) {\n-//         Foo(92) => (),\n-//     }\n-// }\n-// \"#,\n-//     );\n-// }\n-\n #[test]\n fn completes_self_pats() {\n-    check(\n+    check_empty(\n         r#\"\n struct Foo(i32);\n impl Foo {\n@@ -282,35 +259,33 @@ impl Foo {\n }\n \n #[test]\n-fn completes_qualified_variant() {\n+fn enum_qualified() {\n+    // FIXME: Don't show functions, they aren't patterns\n     check(\n         r#\"\n-enum Foo {\n-    Bar { baz: i32 }\n+impl Enum {\n+    type AssocType = ();\n+    const ASSOC_CONST: () = ();\n+    fn assoc_fn() {}\n }\n-impl Foo {\n-    fn foo() {\n-        match {Foo::Bar { baz: 0 }} {\n-            B$0\n-        }\n-    }\n+fn func() {\n+    if let Enum::$0 = unknown {}\n }\n-    \"#,\n+\"#,\n         expect![[r#\"\n-            kw mut\n-            bn Self::Bar Self::Bar { baz$1 }$0\n-            ev Self::Bar { baz: i32 }\n-            bn Foo::Bar  Foo::Bar { baz$1 }$0\n-            ev Foo::Bar  { baz: i32 }\n-            sp Self\n-            en Foo\n+            ev TupleV(\u2026)   (u32)\n+            ev RecordV     { field: u32 }\n+            ev UnitV       ()\n+            ct ASSOC_CONST const ASSOC_CONST: () = ();\n+            fn assoc_fn()  fn()\n+            ta AssocType   type AssocType = ();\n         \"#]],\n-    )\n+    );\n }\n \n #[test]\n fn completes_in_record_field_pat() {\n-    check(\n+    check_empty(\n         r#\"\n struct Foo { bar: Bar }\n struct Bar(u32);\n@@ -328,7 +303,7 @@ fn outer(Foo { bar: $0 }: Foo) {}\n \n #[test]\n fn skips_in_record_field_pat_name() {\n-    check(\n+    check_empty(\n         r#\"\n struct Foo { bar: Bar }\n struct Bar(u32);"}, {"sha": "d43e4b50b13c75778aaeb6570dfb2be667d002f5", "filename": "crates/ide_completion/src/tests/predicate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests%2Fpredicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests%2Fpredicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpredicate.rs?ref=189440c7b55ce892fe931c42b02c4c8178a6cc0a", "patch": "@@ -27,6 +27,7 @@ struct Foo<'lt, T, const C: usize> where $0 {}\n             st Foo<\u2026>\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n@@ -107,6 +108,7 @@ struct Foo<'lt, T, const C: usize> where for<'a> $0 {}\n             st Foo<\u2026>\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n@@ -133,6 +135,7 @@ impl Record {\n             md module\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],"}, {"sha": "88146357ca7ef5e6b54c79ae628fcac193671fb6", "filename": "crates/ide_completion/src/tests/type_pos.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189440c7b55ce892fe931c42b02c4c8178a6cc0a/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=189440c7b55ce892fe931c42b02c4c8178a6cc0a", "patch": "@@ -3,14 +3,14 @@ use expect_test::{expect, Expect};\n \n use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n \n-fn check_with(ra_fixture: &str, expect: Expect) {\n+fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{}\\n{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n     expect.assert_eq(&actual)\n }\n \n #[test]\n fn record_field_ty() {\n-    check_with(\n+    check(\n         r#\"\n struct Foo<'lt, T, const C: usize> {\n     f: $0\n@@ -30,6 +30,7 @@ struct Foo<'lt, T, const C: usize> {\n             st Foo<\u2026>\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n@@ -38,7 +39,7 @@ struct Foo<'lt, T, const C: usize> {\n \n #[test]\n fn tuple_struct_field() {\n-    check_with(\n+    check(\n         r#\"\n struct Foo<'lt, T, const C: usize>(f$0);\n \"#,\n@@ -58,6 +59,7 @@ struct Foo<'lt, T, const C: usize>(f$0);\n             st Foo<\u2026>\n             st Unit\n             ma makro!(\u2026)  #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026)  #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n@@ -66,7 +68,7 @@ struct Foo<'lt, T, const C: usize>(f$0);\n \n #[test]\n fn fn_return_type() {\n-    check_with(\n+    check(\n         r#\"\n fn x<'lt, T, const C: usize>() -> $0\n \"#,\n@@ -82,6 +84,7 @@ fn x<'lt, T, const C: usize>() -> $0\n             md module\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n@@ -90,7 +93,7 @@ fn x<'lt, T, const C: usize>() -> $0\n \n #[test]\n fn body_type_pos() {\n-    check_with(\n+    check(\n         r#\"\n fn foo<'lt, T, const C: usize>() {\n     let local = ();\n@@ -109,11 +112,12 @@ fn foo<'lt, T, const C: usize>() {\n             md module\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n     );\n-    check_with(\n+    check(\n         r#\"\n fn foo<'lt, T, const C: usize>() {\n     let local = ();\n@@ -128,13 +132,14 @@ fn foo<'lt, T, const C: usize>() {\n             md module\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n+            un Union\n         \"##]],\n     );\n }\n \n #[test]\n fn completes_types_and_const_in_arg_list() {\n-    check_with(\n+    check(\n         r#\"\n trait Trait2 {\n     type Foo;\n@@ -157,12 +162,13 @@ fn foo<'lt, T: Trait2<$0>, const CONST_PARAM: usize>(_: T) {}\n             st Unit\n             ma makro!(\u2026)          #[macro_export] macro_rules! makro\n             tt Trait2\n+            un Union\n             ct CONST\n             ma makro!(\u2026)          #[macro_export] macro_rules! makro\n             bt u32\n         \"##]],\n     );\n-    check_with(\n+    check(\n         r#\"\n trait Trait2 {\n     type Foo;\n@@ -179,7 +185,25 @@ fn foo<'lt, T: Trait2<self::$0>, const CONST_PARAM: usize>(_: T) {}\n             st Unit\n             ma makro!(\u2026) #[macro_export] macro_rules! makro\n             tt Trait2\n+            un Union\n             ct CONST\n         \"##]],\n     );\n }\n+\n+#[test]\n+fn enum_qualified() {\n+    check(\n+        r#\"\n+impl Enum {\n+    type AssocType = ();\n+    const ASSOC_CONST: () = ();\n+    fn assoc_fn() {}\n+}\n+fn func(_: Enum::$0) {}\n+\"#,\n+        expect![[r#\"\n+            ta AssocType type AssocType = ();\n+        \"#]],\n+    );\n+}"}]}