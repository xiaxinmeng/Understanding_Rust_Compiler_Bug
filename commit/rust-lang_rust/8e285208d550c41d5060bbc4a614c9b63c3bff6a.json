{"sha": "8e285208d550c41d5060bbc4a614c9b63c3bff6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMjg1MjA4ZDU1MGM0MWQ1MDYwYmJjNGE2MTRjOWI2M2MzYmZmNmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-20T12:51:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-20T12:51:48Z"}, "message": "auto merge of #12686 : FlaPer87/rust/shared, r=nikomatsakis\n\n`Share` implies that all *reachable* content is *threadsafe*.\r\n\r\nThreadsafe is defined as \"exposing no operation that permits a data race if multiple threads have access to a &T pointer simultaneously\". (NB: the type system should guarantee that if you have access to memory via a &T pointer, the only other way to gain access to that memory is through another &T pointer)...\r\n\r\nFixes #11781\r\ncc #12577 \r\n\r\nWhat this PR will do\r\n================\r\n\r\n- [x] Add Share kind and\r\n- [x]  Replace usages of Freeze with Share in bounds.\r\n- [x] Add Unsafe<T> #12577\r\n- [x] Forbid taking the address of a immutable static item with `Unsafe<T>` interior\r\n\r\nWhat's left to do in a separate PR (after the snapshot)?\r\n===========================================\r\n\r\n- Remove `Freeze` completely", "tree": {"sha": "8c4ca58b43010ac4bb619df96c7425247e9ba55a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c4ca58b43010ac4bb619df96c7425247e9ba55a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e285208d550c41d5060bbc4a614c9b63c3bff6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e285208d550c41d5060bbc4a614c9b63c3bff6a", "html_url": "https://github.com/rust-lang/rust/commit/8e285208d550c41d5060bbc4a614c9b63c3bff6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e285208d550c41d5060bbc4a614c9b63c3bff6a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95ee0a04fd78deb773da2d1b2544696c4f0278c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/95ee0a04fd78deb773da2d1b2544696c4f0278c7", "html_url": "https://github.com/rust-lang/rust/commit/95ee0a04fd78deb773da2d1b2544696c4f0278c7"}, {"sha": "7b19574a2c2faac766c5192b243e5c361e449f3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b19574a2c2faac766c5192b243e5c361e449f3b", "html_url": "https://github.com/rust-lang/rust/commit/7b19574a2c2faac766c5192b243e5c361e449f3b"}], "stats": {"total": 767, "additions": 500, "deletions": 267}, "files": [{"sha": "9835e50d5476574de19db7b7e9c8874c1c2f4b71", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -595,10 +595,10 @@ Other features provided by lang items include:\n - stack unwinding and general failure; the `eh_personality`, `fail_`\n   and `fail_bounds_checks` lang items.\n - the traits in `std::kinds` used to indicate types that satisfy\n-  various kinds; lang items `send`, `freeze` and `pod`.\n+  various kinds; lang items `send`, `share` and `pod`.\n - the marker types and variance indicators found in\n   `std::kinds::markers`; lang items `covariant_type`,\n-  `contravariant_lifetime`, `no_freeze_bound`, etc.\n+  `contravariant_lifetime`, `no_share_bound`, etc.\n \n Lang items are loaded lazily by the compiler; e.g. if one never uses\n `~` then there is no need to define functions for `exchange_malloc`"}, {"sha": "0a417a5a8bf11a40e867bb09ae06903946a17c6a", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -2095,6 +2095,10 @@ and may not be overridden:\n Types are sendable\n unless they contain managed boxes, managed closures, or references.\n \n+* `Share` - Types that are *threadsafe*\n+These are types that are safe to be used across several threads with access to\n+a `&T` pointer. `MutexArc` is an example of a *sharable* type with internal mutable data.\n+\n * `Freeze` - Constant (immutable) types.\n These are types that do not contain anything intrinsically mutable.\n Intrinsically mutable values include `Cell` in the standard library."}, {"sha": "a990310a648134e4b20267a61759e6cc0c9ffabc", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -603,6 +603,9 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n             'P' => {\n                 param_bounds.builtin_bounds.add(ty::BoundPod);\n             }\n+            'T' => {\n+                param_bounds.builtin_bounds.add(ty::BoundShare);\n+            }\n             'I' => {\n                 param_bounds.trait_bounds.push(@parse_trait_ref(st, |x,y| conv(x,y)));\n             }"}, {"sha": "911729cd68a7b0b4bf1f8711955e0468f1610476", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -410,6 +410,7 @@ fn enc_bounds(w: &mut MemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n             ty::BoundStatic => mywrite!(w, \"O\"),\n             ty::BoundSized => mywrite!(w, \"Z\"),\n             ty::BoundPod => mywrite!(w, \"P\"),\n+            ty::BoundShare => mywrite!(w, \"T\"),\n         }\n     }\n "}, {"sha": "5db1324b3fef83d9a00d153089f476f17b9dc29c", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -518,11 +518,11 @@ impl<'a> CheckLoanCtxt<'a> {\n                                             expr: &ast::Expr,\n                                             cmt: mc::cmt)\n                                             -> bool {\n-            match cmt.freely_aliasable() {\n+            match cmt.freely_aliasable(this.tcx()) {\n                 None => {\n                     return true;\n                 }\n-                Some(mc::AliasableStaticMut) => {\n+                Some(mc::AliasableStaticMut(..)) => {\n                     return true;\n                 }\n                 Some(cause) => {"}, {"sha": "6e98d282f8f6f76f4a6879a952f4ccf07f1dcf34", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 71, "deletions": 47, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -82,10 +82,12 @@ impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n     fn visit_block(&mut self, b: &Block, _: ()) {\n         gather_loans_in_block(self, b);\n     }\n-    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block,\n-                s: Span, n: NodeId, _: ()) {\n-        gather_loans_in_fn(self, fk, fd, b, s, n);\n-    }\n+\n+    /// Do not visit closures or fn items here, the outer loop in\n+    /// borrowck/mod will visit them for us in turn.\n+    fn visit_fn(&mut self, _: &FnKind, _: &FnDecl, _: &Block,\n+                _: Span, _: NodeId, _: ()) {}\n+\n     fn visit_stmt(&mut self, s: &Stmt, _: ()) {\n         visit::walk_stmt(self, s, ());\n     }\n@@ -99,10 +101,20 @@ impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n     // #7740: Do not visit items here, not even fn items nor methods\n     // of impl items; the outer loop in borrowck/mod will visit them\n     // for us in turn.  Thus override visit_item's walk with a no-op.\n-    fn visit_item(&mut self, _: &ast::Item, _: ()) { }\n+    fn visit_item(&mut self, _: &ast::Item, _: ()) {}\n+}\n+\n+fn add_pat_to_id_range(this: &mut GatherLoanCtxt,\n+                       p: &ast::Pat) {\n+    // NB: This visitor function just adds the pat ids into the id\n+    // range. We gather loans that occur in patterns using the\n+    // `gather_pat()` method below. Eventually these two should be\n+    // brought together.\n+    this.id_range.add(p.id);\n+    visit::walk_pat(this, p, ());\n }\n \n-pub fn gather_loans(bccx: &BorrowckCtxt, decl: &ast::FnDecl, body: &ast::Block)\n+pub fn gather_loans_in_fn(bccx: &BorrowckCtxt, decl: &ast::FnDecl, body: &ast::Block)\n                     -> (IdRange, Vec<Loan>, move_data::MoveData) {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n@@ -119,27 +131,6 @@ pub fn gather_loans(bccx: &BorrowckCtxt, decl: &ast::FnDecl, body: &ast::Block)\n     (id_range, all_loans, move_data)\n }\n \n-fn add_pat_to_id_range(this: &mut GatherLoanCtxt,\n-                       p: &ast::Pat) {\n-    // NB: This visitor function just adds the pat ids into the id\n-    // range. We gather loans that occur in patterns using the\n-    // `gather_pat()` method below. Eventually these two should be\n-    // brought together.\n-    this.id_range.add(p.id);\n-    visit::walk_pat(this, p, ());\n-}\n-\n-fn gather_loans_in_fn(_v: &mut GatherLoanCtxt,\n-                      _fk: &FnKind,\n-                      _decl: &ast::FnDecl,\n-                      _body: &ast::Block,\n-                      _sp: Span,\n-                      _id: ast::NodeId) {\n-    // Do not visit closures or fn items here, the outer loop in\n-    // borrowck/mod will visit them for us in turn.\n-    return;\n-}\n-\n fn gather_loans_in_block(this: &mut GatherLoanCtxt,\n                          blk: &ast::Block) {\n     this.id_range.add(blk.id);\n@@ -171,6 +162,28 @@ fn gather_loans_in_local(this: &mut GatherLoanCtxt,\n     visit::walk_local(this, local, ());\n }\n \n+pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &ast::Expr) {\n+\n+    debug!(\"gather_loans_in_item(expr={})\", expr.repr(bccx.tcx));\n+\n+    let mut glcx = GatherLoanCtxt {\n+        bccx: bccx,\n+        id_range: IdRange::max(),\n+        all_loans: Vec::new(),\n+        item_ub: expr.id,\n+        repeating_ids: vec!(expr.id),\n+        move_data: MoveData::new()\n+    };\n+\n+    // FIXME #13005 This should also walk the\n+    // expression.\n+    match expr.node {\n+        ast::ExprAddrOf(..) => {\n+            glcx.visit_expr(expr, ());\n+        }\n+        _ => {}\n+    }\n+}\n \n fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n                         ex: &ast::Expr) {\n@@ -673,34 +686,45 @@ impl<'a> GatherLoanCtxt<'a> {\n                               -> Result<(),()> {\n             //! Implements the A-* rules in doc.rs.\n \n-            match req_kind {\n-                ty::ImmBorrow => {\n+            match (cmt.freely_aliasable(bccx.tcx), req_kind) {\n+                (None, _) => {\n+                    /* Uniquely accessible path -- OK for `&` and `&mut` */\n                     Ok(())\n                 }\n-\n-                ty::UniqueImmBorrow | ty::MutBorrow => {\n-                    // Check for those cases where we cannot control\n-                    // the aliasing and make sure that we are not\n-                    // being asked to.\n-                    match cmt.freely_aliasable() {\n-                        None => {\n-                            Ok(())\n+                (Some(mc::AliasableStatic(safety)), ty::ImmBorrow) => {\n+                    // Borrow of an immutable static item:\n+                    match safety {\n+                        mc::InteriorUnsafe => {\n+                            // If the static item contains an Unsafe<T>, it has interior mutability.\n+                            // In such cases, we cannot permit it to be borrowed, because the\n+                            // static item resides in immutable memory and mutating it would\n+                            // cause segfaults.\n+                            bccx.tcx.sess.span_err(borrow_span,\n+                                                   format!(\"borrow of immutable static items with \\\n+                                                            unsafe interior is not allowed\"));\n+                            Err(())\n                         }\n-                        Some(mc::AliasableStaticMut) => {\n-                            // This is nasty, but we ignore the\n-                            // aliasing rules if the data is based in\n-                            // a `static mut`, since those are always\n-                            // unsafe. At your own peril and all that.\n+                        mc::InteriorSafe => {\n+                            // Immutable static can be borrowed, no problem.\n                             Ok(())\n                         }\n-                        Some(alias_cause) => {\n-                            bccx.report_aliasability_violation(\n+                    }\n+                }\n+                (Some(mc::AliasableStaticMut(..)), _) => {\n+                    // Even touching a static mut is considered unsafe. We assume the\n+                    // user knows what they're doing in these cases.\n+                    Ok(())\n+                }\n+                (Some(alias_cause), ty::UniqueImmBorrow) |\n+                (Some(alias_cause), ty::MutBorrow) => {\n+                    bccx.report_aliasability_violation(\n                                 borrow_span,\n                                 BorrowViolation(loan_cause),\n                                 alias_cause);\n-                            Err(())\n-                        }\n-                    }\n+                    Err(())\n+                }\n+                (_, _) => {\n+                    Ok(())\n                 }\n             }\n         }"}, {"sha": "1242fdbae6a4a36e092942f3fa689b8555c77ba9", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -69,6 +69,10 @@ impl<'a> Visitor<()> for BorrowckCtxt<'a> {\n                 b: &Block, s: Span, n: NodeId, _: ()) {\n         borrowck_fn(self, fk, fd, b, s, n);\n     }\n+\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+        borrowck_item(self, item);\n+    }\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n@@ -117,6 +121,21 @@ pub fn check_crate(tcx: &ty::ctxt,\n     }\n }\n \n+fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n+    // Gather loans for items. Note that we don't need\n+    // to check loans for single expressions. The check\n+    // loan step is intended for things that have a data\n+    // flow dependent conditions.\n+    match item.node {\n+        ast::ItemStatic(_, _, ex) => {\n+            gather_loans::gather_loans_in_static_initializer(this, ex);\n+        }\n+        _ => {\n+            visit::walk_item(this, item, ());\n+        }\n+    }\n+}\n+\n fn borrowck_fn(this: &mut BorrowckCtxt,\n                fk: &FnKind,\n                decl: &ast::FnDecl,\n@@ -127,7 +146,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n \n     // Check the body of fn items.\n     let (id_range, all_loans, move_data) =\n-        gather_loans::gather_loans(this, decl, body);\n+        gather_loans::gather_loans_in_fn(this, decl, body);\n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n                              this.method_map,\n@@ -715,8 +734,8 @@ impl<'a> BorrowckCtxt<'a> {\n                     span,\n                     format!(\"{} in an aliasable location\", prefix));\n             }\n-            mc::AliasableStatic |\n-            mc::AliasableStaticMut => {\n+            mc::AliasableStatic(..) |\n+            mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err(\n                     span,\n                     format!(\"{} in a static location\", prefix));"}, {"sha": "ecc3ba59dd5ab68be55c15395c4a44a6561aaf86", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -18,8 +18,11 @@\n // - For each *immutable* static item, it checks that its **value**:\n //       - doesn't own owned, managed pointers\n //       - doesn't contain a struct literal or a call to an enum variant / struct constructor where\n-//           - the type of the struct/enum is not freeze\n //           - the type of the struct/enum has a dtor\n+//\n+// Rules Enforced Elsewhere:\n+// - It's not possible to take the address of a static item with unsafe interior. This is enforced\n+// by borrowck::gather_loans\n \n use middle::ty;\n \n@@ -121,21 +124,6 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n                 self.tcx.sess.span_err(e.span,\n                                    \"static items are not allowed to have owned pointers\");\n             }\n-            ast::ExprProc(..) => {\n-                self.report_error(e.span,\n-                                  Some(~\"immutable static items must be `Freeze`\"));\n-                return;\n-            }\n-            ast::ExprAddrOf(mutability, _) => {\n-                match mutability {\n-                    ast::MutMutable => {\n-                        self.report_error(e.span,\n-                                  Some(~\"immutable static items must be `Freeze`\"));\n-                        return;\n-                    }\n-                    _ => {}\n-                }\n-            }\n             _ => {\n                 let node_ty = ty::node_id_to_type(self.tcx, e.id);\n \n@@ -147,11 +135,6 @@ impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n                                      Some(~\"static items are not allowed to have destructors\"));\n                             return;\n                         }\n-                        if Some(did) == self.tcx.lang_items.no_freeze_bound() {\n-                            self.report_error(e.span,\n-                                              Some(~\"immutable static items must be `Freeze`\"));\n-                            return;\n-                        }\n                     }\n                     _ => {}\n                 }"}, {"sha": "193c924f4e4a58b11328d3d9ca7340263f80a85b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -22,7 +22,7 @@\n \n use driver::session::Session;\n use metadata::csearch::each_lang_item;\n-use middle::ty::{BuiltinBound, BoundFreeze, BoundPod, BoundSend, BoundSized};\n+use middle::ty;\n use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n@@ -82,15 +82,17 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn to_builtin_kind(&self, id: ast::DefId) -> Option<BuiltinBound> {\n+    pub fn to_builtin_kind(&self, id: ast::DefId) -> Option<ty::BuiltinBound> {\n         if Some(id) == self.freeze_trait() {\n-            Some(BoundFreeze)\n+            Some(ty::BoundFreeze)\n         } else if Some(id) == self.send_trait() {\n-            Some(BoundSend)\n+            Some(ty::BoundSend)\n         } else if Some(id) == self.sized_trait() {\n-            Some(BoundSized)\n+            Some(ty::BoundSized)\n         } else if Some(id) == self.pod_trait() {\n-            Some(BoundPod)\n+            Some(ty::BoundPod)\n+        } else if Some(id) == self.share_trait() {\n+            Some(ty::BoundShare)\n         } else {\n             None\n         }\n@@ -213,6 +215,7 @@ lets_do_this! {\n     SendTraitLangItem,               \"send\",                    send_trait;\n     SizedTraitLangItem,              \"sized\",                   sized_trait;\n     PodTraitLangItem,                \"pod\",                     pod_trait;\n+    ShareTraitLangItem,              \"share\",                   share_trait;\n \n     DropTraitLangItem,               \"drop\",                    drop_trait;\n \n@@ -230,6 +233,8 @@ lets_do_this! {\n     ShrTraitLangItem,                \"shr\",                     shr_trait;\n     IndexTraitLangItem,              \"index\",                   index_trait;\n \n+    UnsafeTypeLangItem,              \"unsafe\",                  unsafe_type;\n+\n     DerefTraitLangItem,              \"deref\",                   deref_trait;\n     DerefMutTraitLangItem,           \"deref_mut\",               deref_mut_trait;\n \n@@ -274,5 +279,6 @@ lets_do_this! {\n     NoFreezeItem,                    \"no_freeze_bound\",         no_freeze_bound;\n     NoSendItem,                      \"no_send_bound\",           no_send_bound;\n     NoPodItem,                       \"no_pod_bound\",            no_pod_bound;\n+    NoShareItem,                     \"no_share_bound\",          no_share_bound;\n     ManagedItem,                     \"managed_bound\",           managed_bound;\n }"}, {"sha": "04d4b4c67de2cae7af291eee33eea1b25214128b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -1222,12 +1222,17 @@ pub fn field_mutbl(tcx: &ty::ctxt,\n     return None;\n }\n \n+pub enum InteriorSafety {\n+    InteriorUnsafe,\n+    InteriorSafe\n+}\n+\n pub enum AliasableReason {\n     AliasableManaged,\n     AliasableBorrowed,\n     AliasableOther,\n-    AliasableStatic,\n-    AliasableStaticMut,\n+    AliasableStatic(InteriorSafety),\n+    AliasableStaticMut(InteriorSafety),\n }\n \n impl cmt_ {\n@@ -1257,7 +1262,7 @@ impl cmt_ {\n         }\n     }\n \n-    pub fn freely_aliasable(&self) -> Option<AliasableReason> {\n+    pub fn freely_aliasable(&self, ctxt: &ty::ctxt) -> Option<AliasableReason> {\n         /*!\n          * Returns `Some(_)` if this lvalue represents a freely aliasable\n          * pointer type.\n@@ -1275,7 +1280,7 @@ impl cmt_ {\n             cat_interior(b, _) |\n             cat_discr(b, _) => {\n                 // Aliasability depends on base cmt\n-                b.freely_aliasable()\n+                b.freely_aliasable(ctxt)\n             }\n \n             cat_copied_upvar(CopiedUpvar {onceness: ast::Once, ..}) |\n@@ -1292,10 +1297,16 @@ impl cmt_ {\n             }\n \n             cat_static_item(..) => {\n+                let int_safe = if ty::type_interior_is_unsafe(ctxt, self.ty) {\n+                    InteriorUnsafe\n+                } else {\n+                    InteriorSafe\n+                };\n+\n                 if self.mutbl.is_mutable() {\n-                    Some(AliasableStaticMut)\n+                    Some(AliasableStaticMut(int_safe))\n                 } else {\n-                    Some(AliasableStatic)\n+                    Some(AliasableStatic(int_safe))\n                 }\n             }\n "}, {"sha": "6dc31f7fdaaeb40f594738a7ac27eb062c29b4aa", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -850,6 +850,7 @@ pub enum BuiltinBound {\n     BoundFreeze,\n     BoundSized,\n     BoundPod,\n+    BoundShare,\n }\n \n pub fn EmptyBuiltinBounds() -> BuiltinBounds {\n@@ -862,6 +863,7 @@ pub fn AllBuiltinBounds() -> BuiltinBounds {\n     set.add(BoundSend);\n     set.add(BoundFreeze);\n     set.add(BoundSized);\n+    set.add(BoundShare);\n     set\n }\n \n@@ -1872,31 +1874,33 @@ macro_rules! def_type_content_sets(\n \n def_type_content_sets!(\n     mod TC {\n-        None                                = 0b0000__00000000__0000,\n+        None                                = 0b0000_0000__0000_0000__0000,\n \n         // Things that are interior to the value (first nibble):\n-        InteriorUnsized                     = 0b0000__00000000__0001,\n-        // InteriorAll                         = 0b0000__00000000__1111,\n+        InteriorUnsized                     = 0b0000_0000__0000_0000__0001,\n+        InteriorUnsafe                      = 0b0000_0000__0000_0000__0010,\n+        // InteriorAll                         = 0b00000000__00000000__1111,\n \n         // Things that are owned by the value (second and third nibbles):\n-        OwnsOwned                           = 0b0000__00000001__0000,\n-        OwnsDtor                            = 0b0000__00000010__0000,\n-        OwnsManaged /* see [1] below */     = 0b0000__00000100__0000,\n-        OwnsAffine                          = 0b0000__00001000__0000,\n-        OwnsAll                             = 0b0000__11111111__0000,\n+        OwnsOwned                           = 0b0000_0000__0000_0001__0000,\n+        OwnsDtor                            = 0b0000_0000__0000_0010__0000,\n+        OwnsManaged /* see [1] below */     = 0b0000_0000__0000_0100__0000,\n+        OwnsAffine                          = 0b0000_0000__0000_1000__0000,\n+        OwnsAll                             = 0b0000_0000__1111_1111__0000,\n \n         // Things that are reachable by the value in any way (fourth nibble):\n-        ReachesNonsendAnnot                 = 0b0001__00000000__0000,\n-        ReachesBorrowed                     = 0b0010__00000000__0000,\n-        // ReachesManaged /* see [1] below */  = 0b0100__00000000__0000,\n-        ReachesMutable                      = 0b1000__00000000__0000,\n-        ReachesAll                          = 0b1111__00000000__0000,\n+        ReachesNonsendAnnot                 = 0b0000_0001__0000_0000__0000,\n+        ReachesBorrowed                     = 0b0000_0010__0000_0000__0000,\n+        // ReachesManaged /* see [1] below */  = 0b0000_0100__0000_0000__0000,\n+        ReachesMutable                      = 0b0000_1000__0000_0000__0000,\n+        ReachesNoShare                      = 0b0001_0000__0000_0000__0000,\n+        ReachesAll                          = 0b0001_1111__0000_0000__0000,\n \n         // Things that cause values to *move* rather than *copy*\n-        Moves                               = 0b0000__00001011__0000,\n+        Moves                               = 0b0000_0000__0000_1011__0000,\n \n         // Things that mean drop glue is necessary\n-        NeedsDrop                           = 0b0000__00000111__0000,\n+        NeedsDrop                           = 0b0000_0000__0000_0111__0000,\n \n         // Things that prevent values from being sent\n         //\n@@ -1905,31 +1909,34 @@ def_type_content_sets!(\n         //       both ReachesManaged and OwnsManaged so that when\n         //       a parameter has a bound T:Send, we are able to deduce\n         //       that it neither reaches nor owns a managed pointer.\n-        Nonsendable                         = 0b0111__00000100__0000,\n+        Nonsendable                         = 0b0000_0111__0000_0100__0000,\n \n         // Things that prevent values from being considered freezable\n-        Nonfreezable                        = 0b1000__00000000__0000,\n+        Nonfreezable                        = 0b0000_1000__0000_0000__0000,\n \n         // Things that prevent values from being considered 'static\n-        Nonstatic                           = 0b0010__00000000__0000,\n+        Nonstatic                           = 0b0000_0010__0000_0000__0000,\n \n         // Things that prevent values from being considered sized\n-        Nonsized                            = 0b0000__00000000__0001,\n+        Nonsized                            = 0b0000_0000__0000_0000__0001,\n+\n+        // Things that prevent values from being shared\n+        Nonsharable                         = 0b0001_0000__0000_0000__0000,\n \n         // Things that make values considered not POD (would be same\n         // as `Moves`, but for the fact that managed data `@` is\n         // not considered POD)\n-        Nonpod                              = 0b0000__00001111__0000,\n+        Nonpod                              = 0b0000_0000__0000_1111__0000,\n \n         // Bits to set when a managed value is encountered\n         //\n         // [1] Do not set the bits TC::OwnsManaged or\n         //     TC::ReachesManaged directly, instead reference\n         //     TC::Managed to set them both at once.\n-        Managed                             = 0b0100__00000100__0000,\n+        Managed                             = 0b0000_0100__0000_0100__0000,\n \n         // All bits\n-        All                                 = 0b1111__11111111__1111\n+        All                                 = 0b1111_1111__1111_1111__1111\n     }\n )\n \n@@ -1945,6 +1952,7 @@ impl TypeContents {\n             BoundSend => self.is_sendable(cx),\n             BoundSized => self.is_sized(cx),\n             BoundPod => self.is_pod(cx),\n+            BoundShare => self.is_sharable(cx),\n         }\n     }\n \n@@ -1964,6 +1972,10 @@ impl TypeContents {\n         !self.intersects(TC::Nonsendable)\n     }\n \n+    pub fn is_sharable(&self, _: &ctxt) -> bool {\n+        !self.intersects(TC::Nonsharable)\n+    }\n+\n     pub fn owns_managed(&self) -> bool {\n         self.intersects(TC::OwnsManaged)\n     }\n@@ -1984,6 +1996,10 @@ impl TypeContents {\n         !self.intersects(TC::Nonpod)\n     }\n \n+    pub fn interior_unsafe(&self) -> bool {\n+        self.intersects(TC::InteriorUnsafe)\n+    }\n+\n     pub fn moves_by_default(&self, _: &ctxt) -> bool {\n         self.intersects(TC::Moves)\n     }\n@@ -2080,6 +2096,10 @@ pub fn type_is_freezable(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_freezable(cx)\n }\n \n+pub fn type_interior_is_unsafe(cx: &ctxt, t: ty::t) -> bool {\n+    type_contents(cx, t).interior_unsafe()\n+}\n+\n pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     let ty_id = type_id(ty);\n \n@@ -2284,6 +2304,10 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n             tc | TC::Managed\n         } else if Some(did) == cx.lang_items.no_pod_bound() {\n             tc | TC::OwnsAffine\n+        } else if Some(did) == cx.lang_items.no_share_bound() {\n+            tc | TC::ReachesNoShare\n+        } else if Some(did) == cx.lang_items.unsafe_type() {\n+            tc | TC::InteriorUnsafe\n         } else {\n             tc\n         }\n@@ -2362,6 +2386,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 BoundFreeze => TC::Nonfreezable,\n                 BoundSized => TC::Nonsized,\n                 BoundPod => TC::Nonpod,\n+                BoundShare => TC::Nonsharable,\n             };\n         });\n         return tc;"}, {"sha": "e43eed9f219ac6a4f7a974c50ed272fbf38027b4", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -674,6 +674,7 @@ impl Repr for ty::ParamBounds {\n                 ty::BoundFreeze => ~\"Freeze\",\n                 ty::BoundSized => ~\"Sized\",\n                 ty::BoundPod => ~\"Pod\",\n+                ty::BoundShare => ~\"Share\",\n             });\n         }\n         for t in self.trait_bounds.iter() {\n@@ -961,6 +962,7 @@ impl UserString for ty::BuiltinBound {\n             ty::BoundFreeze => ~\"Freeze\",\n             ty::BoundSized => ~\"Sized\",\n             ty::BoundPod => ~\"Pod\",\n+            ty::BoundShare => ~\"Share\",\n         }\n     }\n }"}, {"sha": "5733504c0d189b2727cbf4fea9afba14eacec1b3", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -17,35 +17,38 @@ use fmt;\n use kinds::{marker, Pod};\n use ops::{Deref, DerefMut, Drop};\n use option::{None, Option, Some};\n+use ty::Unsafe;\n \n /// A mutable memory location that admits only `Pod` data.\n pub struct Cell<T> {\n-    priv value: T,\n+    priv value: Unsafe<T>,\n     priv marker1: marker::InvariantType<T>,\n     priv marker2: marker::NoFreeze,\n+    priv marker3: marker::NoShare,\n }\n \n impl<T:Pod> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n-            value: value,\n+            value: Unsafe{value: value, marker1: marker::InvariantType::<T>},\n             marker1: marker::InvariantType::<T>,\n             marker2: marker::NoFreeze,\n+            marker3: marker::NoShare,\n         }\n     }\n \n     /// Returns a copy of the contained value.\n     #[inline]\n     pub fn get(&self) -> T {\n-        self.value\n+        unsafe{ *self.value.get() }\n     }\n \n     /// Sets the contained value.\n     #[inline]\n     pub fn set(&self, value: T) {\n         unsafe {\n-            *cast::transmute_mut(&self.value) = value\n+            *self.value.get() = value;\n         }\n     }\n }\n@@ -64,17 +67,18 @@ impl<T:Eq + Pod> Eq for Cell<T> {\n \n impl<T: fmt::Show> fmt::Show for Cell<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, r\"Cell \\{ value: {} \\}\", self.value)\n+        write!(f.buf, r\"Cell \\{ value: {} \\}\", unsafe{*&self.value.get()})\n     }\n }\n \n /// A mutable memory location with dynamically checked borrow rules\n pub struct RefCell<T> {\n-    priv value: T,\n+    priv value: Unsafe<T>,\n     priv borrow: BorrowFlag,\n     priv marker1: marker::InvariantType<T>,\n     priv marker2: marker::NoFreeze,\n     priv marker3: marker::NoPod,\n+    priv marker4: marker::NoShare,\n }\n \n // Values [1, MAX-1] represent the number of `Ref` active\n@@ -90,15 +94,16 @@ impl<T> RefCell<T> {\n             marker1: marker::InvariantType::<T>,\n             marker2: marker::NoFreeze,\n             marker3: marker::NoPod,\n-            value: value,\n+            marker4: marker::NoShare,\n+            value: Unsafe{value: value, marker1: marker::InvariantType::<T>},\n             borrow: UNUSED,\n         }\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n     pub fn unwrap(self) -> T {\n         assert!(self.borrow == UNUSED);\n-        self.value\n+        unsafe{self.value.unwrap()}\n     }\n \n     unsafe fn as_mut<'a>(&'a self) -> &'a mut RefCell<T> {\n@@ -198,7 +203,7 @@ impl<T> RefCell<T> {\n     #[inline]\n     pub fn set(&self, value: T) {\n         let mut reference = self.borrow_mut();\n-        *reference.get() = value\n+        *reference.get() = value;\n     }\n }\n \n@@ -247,14 +252,14 @@ impl<'b, T> Ref<'b, T> {\n     /// Retrieve an immutable reference to the stored value.\n     #[inline]\n     pub fn get<'a>(&'a self) -> &'a T {\n-        &self.parent.value\n+        unsafe{ &*self.parent.value.get() }\n     }\n }\n \n impl<'b, T> Deref<T> for Ref<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        &self.parent.value\n+        unsafe{ &*self.parent.value.get() }\n     }\n }\n \n@@ -275,21 +280,21 @@ impl<'b, T> RefMut<'b, T> {\n     /// Retrieve a mutable reference to the stored value.\n     #[inline]\n     pub fn get<'a>(&'a mut self) -> &'a mut T {\n-        &mut self.parent.value\n+        unsafe{ &mut *self.parent.value.get() }\n     }\n }\n \n impl<'b, T> Deref<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref<'a>(&'a self) -> &'a T {\n-        &self.parent.value\n+        unsafe{ &*self.parent.value.get() }\n     }\n }\n \n impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n-        &mut self.parent.value\n+        unsafe{ &mut *self.parent.value.get() }\n     }\n }\n "}, {"sha": "b44616421d1826617c5528118c259b58c5953679", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -46,6 +46,22 @@ pub trait Pod {\n     // Empty.\n }\n \n+/// Types that can be safely shared between threads, hence thread-safe.\n+#[cfg(stage0)]\n+pub trait Share {\n+    // Empty\n+}\n+\n+#[cfg(stage0)]\n+impl<T> Share for T {}\n+\n+/// Types that can be safely shared between threads, hence thread-safe.\n+#[cfg(not(stage0))]\n+#[lang=\"share\"]\n+pub trait Share {\n+    // Empty\n+}\n+\n /// Marker types are special types that are used with unsafe code to\n /// inform the compiler of special constraints. Marker types should\n /// only be needed when you are creating an abstraction that is\n@@ -232,6 +248,13 @@ pub mod marker {\n     #[deriving(Eq,Clone)]\n     pub struct NoPod;\n \n+    /// A type which is considered \"not sharable\", meaning that\n+    /// its contents are not threadsafe, hence they cannot be\n+    /// shared between tasks.\n+    #[lang=\"no_share_bound\"]\n+    #[deriving(Eq,Clone)]\n+    pub struct NoShare;\n+\n     /// A type which is considered managed by the GC. This is typically\n     /// embedded in other types.\n     #[lang=\"managed_bound\"]"}, {"sha": "0431a80d0c4080b915b2b92d11fae7e2002e0d78", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -83,6 +83,7 @@\n #[cfg(test)] pub use kinds = realstd::kinds;\n #[cfg(test)] pub use ops = realstd::ops;\n #[cfg(test)] pub use cmp = realstd::cmp;\n+#[cfg(test)] pub use ty = realstd::ty;\n \n #[cfg(stage0)]\n pub use vec_ng = vec;\n@@ -141,6 +142,7 @@ pub mod gc;\n #[cfg(not(test))] pub mod kinds;\n #[cfg(not(test))] pub mod ops;\n #[cfg(not(test))] pub mod cmp;\n+#[cfg(not(test))] pub mod ty;\n \n \n /* Common traits */\n@@ -229,5 +231,6 @@ mod std {\n     pub use rt;\n     pub use str;\n     pub use to_str;\n+    pub use ty;\n     pub use unstable;\n }"}, {"sha": "f3a5bd3d3b5829d0012c74be21be33a896cc7a6f", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -20,7 +20,7 @@ generally useful to many Rust programs.\n */\n \n // Reexported core operators\n-pub use kinds::{Freeze, Pod, Send, Sized};\n+pub use kinds::{Freeze, Pod, Send, Sized, Share};\n pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Drop, Deref, DerefMut};"}, {"sha": "605cbd3f28a12fba59272d1f8d8ec3914841055d", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -42,7 +42,8 @@ struct RcBox<T> {\n #[unsafe_no_drop_flag]\n pub struct Rc<T> {\n     priv ptr: *mut RcBox<T>,\n-    priv marker: marker::NoSend\n+    priv nosend: marker::NoSend,\n+    priv noshare: marker::NoShare\n }\n \n impl<T> Rc<T> {\n@@ -56,7 +57,8 @@ impl<T> Rc<T> {\n                 // strong destructor is running, even if the weak\n                 // pointer is stored inside the strong one.\n                 ptr: transmute(~RcBox { value: value, strong: 1, weak: 1 }),\n-                marker: marker::NoSend,\n+                nosend: marker::NoSend,\n+                noshare: marker::NoShare\n             }\n         }\n     }\n@@ -67,7 +69,11 @@ impl<T> Rc<T> {\n     pub fn downgrade(&self) -> Weak<T> {\n         unsafe {\n             (*self.ptr).weak += 1;\n-            Weak { ptr: self.ptr, marker: marker::NoSend }\n+            Weak {\n+                ptr: self.ptr,\n+                nosend: marker::NoSend,\n+                noshare: marker::NoShare\n+            }\n         }\n     }\n }\n@@ -107,7 +113,7 @@ impl<T> Clone for Rc<T> {\n     fn clone(&self) -> Rc<T> {\n         unsafe {\n             (*self.ptr).strong += 1;\n-            Rc { ptr: self.ptr, marker: marker::NoSend }\n+            Rc { ptr: self.ptr, nosend: marker::NoSend, noshare: marker::NoShare }\n         }\n     }\n }\n@@ -138,7 +144,8 @@ impl<T: Ord> Ord for Rc<T> {\n #[unsafe_no_drop_flag]\n pub struct Weak<T> {\n     priv ptr: *mut RcBox<T>,\n-    priv marker: marker::NoSend\n+    priv nosend: marker::NoSend,\n+    priv noshare: marker::NoShare\n }\n \n impl<T> Weak<T> {\n@@ -149,7 +156,7 @@ impl<T> Weak<T> {\n                 None\n             } else {\n                 (*self.ptr).strong += 1;\n-                Some(Rc { ptr: self.ptr, marker: marker::NoSend })\n+                Some(Rc { ptr: self.ptr, nosend: marker::NoSend, noshare: marker::NoShare })\n             }\n         }\n     }\n@@ -176,7 +183,7 @@ impl<T> Clone for Weak<T> {\n     fn clone(&self) -> Weak<T> {\n         unsafe {\n             (*self.ptr).weak += 1;\n-            Weak { ptr: self.ptr, marker: marker::NoSend }\n+            Weak { ptr: self.ptr, nosend: marker::NoSend, noshare: marker::NoShare }\n         }\n     }\n }"}, {"sha": "92974005305531dd20df517486fba51f6f92ee5d", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -28,6 +28,7 @@ use ops::Drop;\n use ptr::RawPtr;\n use sync::atomics::{fence, AtomicUint, Relaxed, Acquire, Release};\n use slice;\n+use ty::Unsafe;\n \n /// An atomically reference counted pointer.\n ///\n@@ -39,11 +40,14 @@ pub struct UnsafeArc<T> {\n \n struct ArcData<T> {\n     count: AtomicUint,\n-    data: T,\n+    data: Unsafe<T>,\n }\n \n unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {\n-    let data = ~ArcData { count: AtomicUint::new(refcount), data: data };\n+    let data = ~ArcData {\n+                    count: AtomicUint::new(refcount),\n+                    data: Unsafe::new(data)\n+                 };\n     cast::transmute(data)\n }\n \n@@ -82,7 +86,7 @@ impl<T: Send> UnsafeArc<T> {\n         unsafe {\n             // FIXME(#12049): this needs some sort of debug assertion\n             if cfg!(test) { assert!((*self.data).count.load(Relaxed) > 0); }\n-            return &mut (*self.data).data as *mut T;\n+            return (*self.data).data.get();\n         }\n     }\n \n@@ -93,7 +97,7 @@ impl<T: Send> UnsafeArc<T> {\n         unsafe {\n             // FIXME(#12049): this needs some sort of debug assertion\n             if cfg!(test) { assert!((*self.data).count.load(Relaxed) > 0); }\n-            return &(*self.data).data as *T;\n+            return (*self.data).data.get() as *T;\n         }\n     }\n "}, {"sha": "cbdb38c1c58b6d95104d9c44571f3eb8fb0ecc72", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -114,35 +114,36 @@ use cast;\n use std::kinds::marker;\n use option::{Option,Some,None};\n use ops::Drop;\n+use ty::Unsafe;\n \n /// An atomic boolean type.\n pub struct AtomicBool {\n-    priv v: uint,\n+    priv v: Unsafe<uint>,\n     priv nopod: marker::NoPod\n }\n \n /// A signed atomic integer type, supporting basic atomic arithmetic operations\n pub struct AtomicInt {\n-    priv v: int,\n+    priv v: Unsafe<int>,\n     priv nopod: marker::NoPod\n }\n \n /// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n pub struct AtomicUint {\n-    priv v: uint,\n+    priv v: Unsafe<uint>,\n     priv nopod: marker::NoPod\n }\n \n /// An unsigned atomic integer type that is forced to be 64-bits. This does not\n /// support all operations.\n pub struct AtomicU64 {\n-    priv v: u64,\n+    priv v: Unsafe<u64>,\n     priv nopod: marker::NoPod\n }\n \n /// An unsafe atomic pointer. Only supports basic atomic operations\n pub struct AtomicPtr<T> {\n-    priv p: uint,\n+    priv p: Unsafe<uint>,\n     priv nopod: marker::NoPod\n }\n \n@@ -152,7 +153,7 @@ pub struct AtomicPtr<T> {\n /// owned heap objects across tasks.\n #[unsafe_no_drop_flag]\n pub struct AtomicOption<T> {\n-    priv p: uint,\n+    priv p: Unsafe<uint>,\n }\n \n /// Atomic memory orderings\n@@ -186,13 +187,21 @@ pub enum Ordering {\n }\n \n /// An `AtomicBool` initialized to `false`\n-pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: 0, nopod: marker::NoPod };\n+pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nopod: marker::NoPod };\n /// An `AtomicInt` initialized to `0`\n-pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: 0, nopod: marker::NoPod };\n+pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nopod: marker::NoPod };\n /// An `AtomicUint` initialized to `0`\n-pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: 0, nopod: marker::NoPod };\n+pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nopod: marker::NoPod };\n /// An `AtomicU64` initialized to `0`\n-pub static INIT_ATOMIC_U64 : AtomicU64 = AtomicU64 { v: 0, nopod: marker::NoPod };\n+pub static INIT_ATOMIC_U64 : AtomicU64 = AtomicU64 { v: Unsafe{value: 0,\n+                                                               marker1: marker::InvariantType},\n+                                                     nopod: marker::NoPod };\n \n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n@@ -201,29 +210,30 @@ static UINT_TRUE: uint = -1;\n impl AtomicBool {\n     /// Create a new `AtomicBool`\n     pub fn new(v: bool) -> AtomicBool {\n-        AtomicBool { v: if v { UINT_TRUE } else { 0 }, nopod: marker::NoPod }\n+        let val = if v { UINT_TRUE } else { 0 };\n+        AtomicBool { v: Unsafe::new(val), nopod: marker::NoPod }\n     }\n \n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(&self.v, order) > 0 }\n+        unsafe { atomic_load(&*self.v.get(), order) > 0 }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&mut self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_store(&mut self.v, val, order); }\n+        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_swap(&mut self.v, val, order) > 0 }\n+        unsafe { atomic_swap(&mut *self.v.get(), val, order) > 0 }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -276,7 +286,7 @@ impl AtomicBool {\n         let old = if old { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) > 0 }\n+        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) > 0 }\n     }\n \n     /// A logical \"and\" operation\n@@ -306,7 +316,7 @@ impl AtomicBool {\n     pub fn fetch_and(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_and(&mut self.v, val, order) > 0 }\n+        unsafe { atomic_and(&mut *self.v.get(), val, order) > 0 }\n     }\n \n     /// A logical \"nand\" operation\n@@ -337,7 +347,7 @@ impl AtomicBool {\n     pub fn fetch_nand(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_nand(&mut self.v, val, order) > 0 }\n+        unsafe { atomic_nand(&mut *self.v.get(), val, order) > 0 }\n     }\n \n     /// A logical \"or\" operation\n@@ -367,7 +377,7 @@ impl AtomicBool {\n     pub fn fetch_or(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_or(&mut self.v, val, order) > 0 }\n+        unsafe { atomic_or(&mut *self.v.get(), val, order) > 0 }\n     }\n \n     /// A logical \"xor\" operation\n@@ -397,32 +407,32 @@ impl AtomicBool {\n     pub fn fetch_xor(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_xor(&mut self.v, val, order) > 0 }\n+        unsafe { atomic_xor(&mut *self.v.get(), val, order) > 0 }\n     }\n }\n \n impl AtomicInt {\n     /// Create a new `AtomicInt`\n     pub fn new(v: int) -> AtomicInt {\n-        AtomicInt { v:v, nopod: marker::NoPod}\n+        AtomicInt {v: Unsafe::new(v), nopod: marker::NoPod}\n     }\n \n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> int {\n-        unsafe { atomic_load(&self.v, order) }\n+        unsafe { atomic_load(&*self.v.get(), order) }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&mut self, val: int, order: Ordering) {\n-        unsafe { atomic_store(&mut self.v, val, order); }\n+        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_swap(&mut self.v, val, order) }\n+        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -432,7 +442,7 @@ impl AtomicInt {\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n     pub fn compare_and_swap(&mut self, old: int, new: int, order: Ordering) -> int {\n-        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n+        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n     }\n \n     /// Add to the current value, returning the previous\n@@ -448,7 +458,7 @@ impl AtomicInt {\n     /// ```\n     #[inline]\n     pub fn fetch_add(&mut self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_add(&mut self.v, val, order) }\n+        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n     }\n \n     /// Subtract from the current value, returning the previous\n@@ -464,7 +474,7 @@ impl AtomicInt {\n     /// ```\n     #[inline]\n     pub fn fetch_sub(&mut self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_sub(&mut self.v, val, order) }\n+        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n     }\n }\n \n@@ -474,62 +484,62 @@ impl AtomicInt {\n #[cfg(not(target_arch = \"mips\"))]\n impl AtomicU64 {\n     pub fn new(v: u64) -> AtomicU64 {\n-        AtomicU64 { v:v, nopod: marker::NoPod }\n+        AtomicU64 { v: Unsafe::new(v), nopod: marker::NoPod }\n     }\n \n     #[inline]\n     pub fn load(&self, order: Ordering) -> u64 {\n-        unsafe { atomic_load(&self.v, order) }\n+        unsafe { atomic_load(&*self.v.get(), order) }\n     }\n \n     #[inline]\n     pub fn store(&mut self, val: u64, order: Ordering) {\n-        unsafe { atomic_store(&mut self.v, val, order); }\n+        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n     }\n \n     #[inline]\n     pub fn swap(&mut self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_swap(&mut self.v, val, order) }\n+        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n     }\n \n     #[inline]\n     pub fn compare_and_swap(&mut self, old: u64, new: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n+        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n     }\n \n     #[inline]\n     pub fn fetch_add(&mut self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_add(&mut self.v, val, order) }\n+        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n     }\n \n     #[inline]\n     pub fn fetch_sub(&mut self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_sub(&mut self.v, val, order) }\n+        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n     }\n }\n \n impl AtomicUint {\n     /// Create a new `AtomicUint`\n     pub fn new(v: uint) -> AtomicUint {\n-        AtomicUint { v:v, nopod: marker::NoPod }\n+        AtomicUint { v: Unsafe::new(v), nopod: marker::NoPod }\n     }\n \n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> uint {\n-        unsafe { atomic_load(&self.v, order) }\n+        unsafe { atomic_load(&*self.v.get(), order) }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&mut self, val: uint, order: Ordering) {\n-        unsafe { atomic_store(&mut self.v, val, order); }\n+        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_swap(&mut self.v, val, order) }\n+        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -539,7 +549,7 @@ impl AtomicUint {\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n     pub fn compare_and_swap(&mut self, old: uint, new: uint, order: Ordering) -> uint {\n-        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n+        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n     }\n \n     /// Add to the current value, returning the previous\n@@ -555,7 +565,7 @@ impl AtomicUint {\n     /// ```\n     #[inline]\n     pub fn fetch_add(&mut self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_add(&mut self.v, val, order) }\n+        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n     }\n \n     /// Subtract from the current value, returning the previous\n@@ -571,34 +581,34 @@ impl AtomicUint {\n     /// ```\n     #[inline]\n     pub fn fetch_sub(&mut self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_sub(&mut self.v, val, order) }\n+        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n     }\n }\n \n impl<T> AtomicPtr<T> {\n     /// Create a new `AtomicPtr`\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: p as uint, nopod: marker::NoPod }\n+        AtomicPtr { p: Unsafe::new(p as uint), nopod: marker::NoPod }\n     }\n \n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_load(&self.p, order) as *mut T\n+            atomic_load(&*self.p.get(), order) as *mut T\n         }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&mut self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(&mut self.p, ptr as uint, order); }\n+        unsafe { atomic_store(&mut *self.p.get(), ptr as uint, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, ptr: *mut T, order: Ordering) -> *mut T {\n-        unsafe { atomic_swap(&mut self.p, ptr as uint, order) as *mut T }\n+        unsafe { atomic_swap(&mut *self.p.get(), ptr as uint, order) as *mut T }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -609,7 +619,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     pub fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(&mut self.p, old as uint,\n+            atomic_compare_and_swap(&mut *self.p.get(), old as uint,\n                                     new as uint, order) as *mut T\n         }\n     }\n@@ -618,19 +628,19 @@ impl<T> AtomicPtr<T> {\n impl<T> AtomicOption<T> {\n     /// Create a new `AtomicOption`\n     pub fn new(p: ~T) -> AtomicOption<T> {\n-        unsafe { AtomicOption { p: cast::transmute(p) } }\n+        unsafe { AtomicOption { p: Unsafe::new(cast::transmute(p)) } }\n     }\n \n     /// Create a new `AtomicOption` that doesn't contain a value\n-    pub fn empty() -> AtomicOption<T> { AtomicOption { p: 0 } }\n+    pub fn empty() -> AtomicOption<T> { AtomicOption { p: Unsafe::new(0) } }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: ~T, order: Ordering) -> Option<~T> {\n         unsafe {\n             let val = cast::transmute(val);\n \n-            let p = atomic_swap(&mut self.p, val, order);\n+            let p = atomic_swap(&mut *self.p.get(), val, order);\n             if p as uint == 0 {\n                 None\n             } else {\n@@ -655,7 +665,7 @@ impl<T> AtomicOption<T> {\n         unsafe {\n             let val = cast::transmute(val);\n             let expected = cast::transmute(0);\n-            let oldval = atomic_compare_and_swap(&mut self.p, expected, val, order);\n+            let oldval = atomic_compare_and_swap(&mut *self.p.get(), expected, val, order);\n             if oldval == expected {\n                 None\n             } else {\n@@ -670,7 +680,7 @@ impl<T> AtomicOption<T> {\n     /// result does not get invalidated by another task after this returns.\n     #[inline]\n     pub fn is_empty(&mut self, order: Ordering) -> bool {\n-        unsafe { atomic_load(&self.p, order) as uint == 0 }\n+        unsafe { atomic_load(&*self.p.get(), order) as uint == 0 }\n     }\n }\n "}, {"sha": "344235053f350bc9a859d28e986996ca568dbaf6", "filename": "src/libstd/ty.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibstd%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fty.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Types dealing with unsafe actions.\n+\n+use cast;\n+use kinds::marker;\n+\n+/// Unsafe type that wraps a type T and indicates unsafe interior operations on the\n+/// wrapped type. Types with an `Unsafe<T>` field are considered to have an *unsafe\n+/// interior*. The Unsafe type is the only legal way to obtain aliasable data that is\n+/// considered mutable. In general, transmuting an &T type into an &mut T is considered\n+/// undefined behavior.\n+///\n+/// Although it is possible to put an Unsafe<T> into static item, it is not permitted to\n+/// take the address of the static item if the item is not declared as mutable. This rule\n+/// exists because immutable static items are stored in read-only memory, and thus any\n+/// attempt to mutate their interior can cause segfaults. Immutable static items containing\n+/// Unsafe<T> instances are still useful as read-only initializers, however, so we do not\n+/// forbid them altogether.\n+///\n+/// Types like `Cell` and `RefCell` use this type to wrap their internal data.\n+///\n+/// Unsafe doesn't opt-out from any kind, instead, types with an `Unsafe` interior\n+/// are expected to opt-out from kinds themselves.\n+///\n+/// # Example:\n+///\n+/// ```rust\n+/// use std::ty::Unsafe;\n+/// use std::kinds::marker;\n+///\n+/// struct NotThreadSafe<T> {\n+///     value: Unsafe<T>,\n+///     marker1: marker::NoShare\n+/// }\n+/// ```\n+///\n+/// **NOTE:** Unsafe<T> fields are public to allow static initializers. It is not recommended\n+/// to access its fields directly, `get` should be used instead.\n+#[cfg(not(stage0))]\n+#[lang=\"unsafe\"]\n+pub struct Unsafe<T> {\n+    /// Wrapped value\n+    value: T,\n+\n+    /// Invariance marker\n+    marker1: marker::InvariantType<T>\n+}\n+\n+/// Unsafe type for stage0\n+#[cfg(stage0)]\n+pub struct Unsafe<T> {\n+    /// Wrapped value\n+    value: T,\n+\n+    /// Invariance marker\n+    marker1: marker::InvariantType<T>\n+}\n+\n+impl<T> Unsafe<T> {\n+\n+    /// Static constructor\n+    pub fn new(value: T) -> Unsafe<T> {\n+        Unsafe{value: value, marker1: marker::InvariantType}\n+    }\n+\n+    /// Gets a mutable pointer to the wrapped value\n+    #[inline]\n+    pub unsafe fn get(&self) -> *mut T { cast::transmute(&self.value) }\n+\n+    /// Unwraps the value\n+    #[inline]\n+    pub unsafe fn unwrap(self) -> T { self.value }\n+}"}, {"sha": "71adab71734b99d889ea4b9f7c4b576a610c0ddf", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -54,6 +54,9 @@ use std::kinds::marker;\n use std::sync::arc::UnsafeArc;\n use std::task;\n \n+#[cfg(stage0)]\n+use std::kinds::Share;\n+\n /// As sync::condvar, a mechanism for unlock-and-descheduling and\n /// signaling, for use with the Arc types.\n pub struct ArcCondvar<'a> {\n@@ -122,7 +125,7 @@ pub struct Arc<T> { priv x: UnsafeArc<T> }\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-impl<T:Freeze+Send> Arc<T> {\n+impl<T: Share + Send> Arc<T> {\n     /// Create an atomically reference counted wrapper.\n     #[inline]\n     pub fn new(data: T) -> Arc<T> {\n@@ -135,7 +138,7 @@ impl<T:Freeze+Send> Arc<T> {\n     }\n }\n \n-impl<T:Freeze + Send> Clone for Arc<T> {\n+impl<T: Share + Send> Clone for Arc<T> {\n     /**\n     * Duplicate an atomically reference counted wrapper.\n     *\n@@ -295,19 +298,21 @@ struct RWArcInner<T> { lock: RWLock, failed: bool, data: T }\n pub struct RWArc<T> {\n     priv x: UnsafeArc<RWArcInner<T>>,\n     priv marker: marker::NoFreeze,\n+    priv marker1: marker::NoShare,\n }\n \n-impl<T:Freeze + Send> Clone for RWArc<T> {\n+impl<T: Share + Send> Clone for RWArc<T> {\n     /// Duplicate a rwlock-protected Arc. See arc::clone for more details.\n     #[inline]\n     fn clone(&self) -> RWArc<T> {\n         RWArc { x: self.x.clone(),\n-                marker: marker::NoFreeze, }\n+                marker: marker::NoFreeze,\n+                marker1: marker::NoShare, }\n     }\n \n }\n \n-impl<T:Freeze + Send> RWArc<T> {\n+impl<T: Share + Send> RWArc<T> {\n     /// Create a reader/writer Arc with the supplied data.\n     pub fn new(user_data: T) -> RWArc<T> {\n         RWArc::new_with_condvars(user_data, 1)\n@@ -323,7 +328,8 @@ impl<T:Freeze + Send> RWArc<T> {\n             failed: false, data: user_data\n         };\n         RWArc { x: UnsafeArc::new(data),\n-                marker: marker::NoFreeze, }\n+                marker: marker::NoFreeze,\n+                marker1: marker::NoShare, }\n     }\n \n     /**\n@@ -454,7 +460,7 @@ impl<T:Freeze + Send> RWArc<T> {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T:Freeze + Send>(state: *mut RWArcInner<T>) -> *RWLock {\n+fn borrow_rwlock<T: Share + Send>(state: *mut RWArcInner<T>) -> *RWLock {\n     unsafe { cast::transmute(&(*state).lock) }\n }\n \n@@ -471,7 +477,7 @@ pub struct RWReadMode<'a, T> {\n     priv token: sync::RWLockReadMode<'a>,\n }\n \n-impl<'a, T:Freeze + Send> RWWriteMode<'a, T> {\n+impl<'a, T: Share + Send> RWWriteMode<'a, T> {\n     /// Access the pre-downgrade RWArc in write mode.\n     pub fn write<U>(&mut self, blk: |x: &mut T| -> U) -> U {\n         match *self {\n@@ -510,7 +516,7 @@ impl<'a, T:Freeze + Send> RWWriteMode<'a, T> {\n     }\n }\n \n-impl<'a, T:Freeze + Send> RWReadMode<'a, T> {\n+impl<'a, T: Share + Send> RWReadMode<'a, T> {\n     /// Access the post-downgrade rwlock in read mode.\n     pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n         match *self {\n@@ -534,7 +540,7 @@ pub struct CowArc<T> { priv x: UnsafeArc<T> }\n /// mutation of the contents if there is only a single reference to\n /// the data. If there are multiple references the data is automatically\n /// cloned and the task modifies the cloned data in place of the shared data.\n-impl<T:Clone+Send+Freeze> CowArc<T> {\n+impl<T: Clone + Send + Share> CowArc<T> {\n     /// Create a copy-on-write atomically reference counted wrapper\n     #[inline]\n     pub fn new(data: T) -> CowArc<T> {\n@@ -558,7 +564,7 @@ impl<T:Clone+Send+Freeze> CowArc<T> {\n     }\n }\n \n-impl<T:Clone+Send+Freeze> Clone for CowArc<T> {\n+impl<T: Clone + Send + Share> Clone for CowArc<T> {\n     /// Duplicate a Copy-on-write Arc. See arc::clone for more details.\n     fn clone(&self) -> CowArc<T> {\n         CowArc { x: self.x.clone() }"}, {"sha": "fce9ddcc2ee71715972c28a48cf61b64a8691b70", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -1159,14 +1159,6 @@ mod test {\n \n     use std::vec::Vec;\n \n-    fn is_freeze<T: Freeze>() {}\n-\n-    // Assert that the AST remains Freeze (#10693).\n-    #[test]\n-    fn ast_is_freeze() {\n-        is_freeze::<Item>();\n-    }\n-\n     // are ASTs encodable?\n     #[test]\n     fn check_asts_encodable() {"}, {"sha": "0406f5f5ba959b498a8078e78596ff1b0cd4c52a", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -29,7 +29,7 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n-impl<T:Eq + Hash + Freeze + Clone + 'static> Interner<T> {\n+impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n             map: RefCell::new(HashMap::new()),"}, {"sha": "51bbb59b77eca84f73502c27c84539a2b67efa6d", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -16,17 +16,17 @@ struct arc_destruct<T> {\n }\n \n #[unsafe_destructor]\n-impl<T:Freeze> Drop for arc_destruct<T> {\n+impl<T: Share> Drop for arc_destruct<T> {\n     fn drop(&mut self) {}\n }\n \n-fn arc_destruct<T:Freeze>(data: int) -> arc_destruct<T> {\n+fn arc_destruct<T: Share>(data: int) -> arc_destruct<T> {\n     arc_destruct {\n         _data: data\n     }\n }\n \n-fn arc<T:Freeze>(_data: T) -> arc_destruct<T> {\n+fn arc<T: Share>(_data: T) -> arc_destruct<T> {\n     arc_destruct(0)\n }\n "}, {"sha": "c790a040a91a4be332c9240b52994022f0509af3", "filename": "src/test/compile-fail/borrowck-forbid-static-unsafe-interior.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fborrowck-forbid-static-unsafe-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fborrowck-forbid-static-unsafe-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-forbid-static-unsafe-interior.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Verify that it is not possible to take the address of\n+// static items with usnafe interior.\n+\n+use std::kinds::marker;\n+use std::ty::Unsafe;\n+\n+struct MyUnsafe<T> {\n+    value: Unsafe<T>\n+}\n+\n+impl<T> MyUnsafe<T> {\n+    fn forbidden(&self) {}\n+}\n+\n+enum UnsafeEnum<T> {\n+    VariantSafe,\n+    VariantUnsafe(Unsafe<T>)\n+}\n+\n+static STATIC1: UnsafeEnum<int> = VariantSafe;\n+\n+static STATIC2: Unsafe<int> = Unsafe{value: 1, marker1: marker::InvariantType};\n+static STATIC3: MyUnsafe<int> = MyUnsafe{value: STATIC2};\n+\n+static STATIC4: &'static Unsafe<int> = &'static STATIC2;\n+//~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n+\n+\n+fn main() {\n+    let a = &STATIC1;\n+    //~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n+\n+    STATIC3.forbidden()\n+    //~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n+}\n+\n+"}, {"sha": "7de38e6173be1ee3628fb07ccd76a092870ef29b", "filename": "src/test/compile-fail/builtin-superkinds-double-superkind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-double-superkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-double-superkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-double-superkind.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -11,12 +11,12 @@\n // Test for traits that inherit from multiple builtin kinds at once,\n // testing that all such kinds must be present on implementing types.\n \n-trait Foo : Send+Freeze { }\n+trait Foo : Send+Share { }\n \n-impl <T: Freeze> Foo for (T,) { } //~ ERROR cannot implement this trait\n+impl <T: Share> Foo for (T,) { } //~ ERROR cannot implement this trait\n \n impl <T: Send> Foo for (T,T) { } //~ ERROR cannot implement this trait\n \n-impl <T: Send+Freeze> Foo for (T,T,T) { } // (ok)\n+impl <T: Send+Share> Foo for (T,T,T) { } // (ok)\n \n fn main() { }"}, {"sha": "0d5a71559e8678317d1464fa7f13b3b6ba72e093", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -11,13 +11,13 @@\n // Tests (negatively) the ability for the Self type in default methods\n // to use capabilities granted by builtin kinds as supertraits.\n \n-trait Foo : Freeze {\n+trait Foo : Share {\n     fn foo(self, mut chan: Sender<Self>) {\n         chan.send(self); //~ ERROR does not fulfill `Send`\n     }\n }\n \n-impl <T: Freeze> Foo for T { }\n+impl <T: Share> Foo for T { }\n \n fn main() {\n     let (tx, rx) = channel();"}, {"sha": "bc0ad6dbb2938a2329b03dc953cc0ff6367de290", "filename": "src/test/compile-fail/builtin-superkinds-typaram-not-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-typaram-not-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-typaram-not-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-typaram-not-send.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -12,6 +12,6 @@\n \n trait Foo : Send { }\n \n-impl <T: Freeze> Foo for T { } //~ ERROR cannot implement this trait\n+impl <T: Share> Foo for T { } //~ ERROR cannot implement this trait\n \n fn main() { }"}, {"sha": "6bedac6d12d6c026b73b7d4189e77df8f215ed19", "filename": "src/test/compile-fail/cant-implement-builtin-kinds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fcant-implement-builtin-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fcant-implement-builtin-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcant-implement-builtin-kinds.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -14,6 +14,6 @@ struct X<T>(T);\n \n impl <T> Send for X<T> { } //~ ERROR cannot provide an explicit implementation for a builtin kind\n impl <T> Sized for X<T> { } //~ ERROR cannot provide an explicit implementation for a builtin kind\n-impl <T> Freeze for X<T> { } //~ ERROR cannot provide an explicit implementation for a builtin kind\n+impl <T> Share for X<T> { } //~ ERROR cannot provide an explicit implementation for a builtin kind\n \n fn main() { }"}, {"sha": "8ae40a74af188342f673f3d77c88c51d405acc06", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -124,30 +124,6 @@ static STATIC18: @SafeStruct = @SafeStruct{field1: Variant1, field2: Variant2(0)\n static STATIC19: ~int = box 3;\n //~^ ERROR static items are not allowed to have owned pointers\n \n-\n-struct StructNoFreeze<'a> {\n-    nf: &'a int\n-}\n-\n-enum EnumNoFreeze<'a> {\n-    FreezableVariant,\n-    NonFreezableVariant(StructNoFreeze<'a>)\n-}\n-\n-static STATIC20: StructNoFreeze<'static> = StructNoFreeze{nf: &'static mut 4};\n-//~^ ERROR immutable static items must be `Freeze`\n-\n-static STATIC21: EnumNoFreeze<'static> = FreezableVariant;\n-static STATIC22: EnumNoFreeze<'static> = NonFreezableVariant(StructNoFreeze{nf: &'static mut 4});\n-//~^ ERROR immutable static items must be `Freeze`\n-\n-struct NFMarker {\n-    nf: marker::NoFreeze\n-}\n-\n-static STATIC23: NFMarker = NFMarker{nf: marker::NoFreeze};\n-//~^ ERROR immutable static items must be `Freeze`\n-\n pub fn main() {\n     let y = { static x: ~int = ~3; x };\n     //~^ ERROR static items are not allowed to have owned pointers"}, {"sha": "3550922dc1462e97d5aadd1f37335e003b8bbbf2", "filename": "src/test/compile-fail/comm-not-freeze.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn test<T: Freeze>() {}\n+fn test<T: Share>() {}\n \n fn main() {\n-    test::<Sender<int>>();        //~ ERROR: does not fulfill `Freeze`\n-    test::<Receiver<int>>();        //~ ERROR: does not fulfill `Freeze`\n-    test::<Sender<int>>();  //~ ERROR: does not fulfill `Freeze`\n+    test::<Sender<int>>();        //~ ERROR: does not fulfill `Share`\n+    test::<Receiver<int>>();        //~ ERROR: does not fulfill `Share`\n+    test::<Sender<int>>();  //~ ERROR: does not fulfill `Share`\n }"}, {"sha": "b159337765e5f5844447a045e6902f86a1822e58", "filename": "src/test/compile-fail/issue-2611-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -20,7 +20,7 @@ struct E {\n }\n \n impl A for E {\n-  fn b<F:Freeze,G>(_x: F) -> F { fail!() } //~ ERROR type parameter 0 requires `Freeze`\n+  fn b<F: Share, G>(_x: F) -> F { fail!() } //~ ERROR type parameter 0 requires `Share`\n }\n \n fn main() {}"}, {"sha": "84e856f5ac915dc618d881f971ced398edf4ab10", "filename": "src/test/compile-fail/marker-no-share.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fmarker-no-share.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fmarker-no-share.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmarker-no-share.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -10,9 +10,9 @@\n \n use std::kinds::marker;\n \n-fn foo<P:Freeze>(p: P) { }\n+fn foo<P: Share>(p: P) { }\n \n fn main()\n {\n-    foo(marker::NoFreeze); //~ ERROR does not fulfill `Freeze`\n+    foo(marker::NoShare); //~ ERROR does not fulfill `Share`\n }", "previous_filename": "src/test/compile-fail/marker-no-freeze.rs"}, {"sha": "f1e7ef216c32c6982b31445c677f2bb2ae4f1ad8", "filename": "src/test/compile-fail/mut-not-freeze.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -10,9 +10,9 @@\n \n use std::cell::RefCell;\n \n-fn f<T: Freeze>(_: T) {}\n+fn f<T: Share>(_: T) {}\n \n fn main() {\n     let x = RefCell::new(0);\n-    f(x); //~ ERROR: which does not fulfill `Freeze`\n+    f(x); //~ ERROR: which does not fulfill `Share`\n }"}, {"sha": "e68274fcb7940579ad82b9caa60985e292628e1d", "filename": "src/test/compile-fail/no_share-enum.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fno_share-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fno_share-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_share-enum.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -10,13 +10,13 @@\n \n use std::kinds::marker;\n \n-enum Foo { A(marker::NoFreeze) }\n+enum Foo { A(marker::NoShare) }\n \n-fn bar<T: Freeze>(_: T) {}\n+fn bar<T: Share>(_: T) {}\n \n fn main() {\n-    let x = A(marker::NoFreeze);\n+    let x = A(marker::NoShare);\n     bar(x);\n     //~^ ERROR instantiating a type parameter with an incompatible type `Foo`,\n-    //         which does not fulfill `Freeze`\n+    //         which does not fulfill `Share`\n }", "previous_filename": "src/test/compile-fail/no_freeze-enum.rs"}, {"sha": "ad79d03821206ffd76746b932b7dbb0bb00a69e5", "filename": "src/test/compile-fail/no_share-rc.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_share-rc.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -11,11 +11,11 @@\n use std::rc::Rc;\n use std::cell::RefCell;\n \n-fn bar<T: Freeze>(_: T) {}\n+fn bar<T: Share>(_: T) {}\n \n fn main() {\n     let x = Rc::new(RefCell::new(5));\n     bar(x);\n     //~^ ERROR instantiating a type parameter with an incompatible type\n-    //         `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Freeze`\n+    //         `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Share`\n }", "previous_filename": "src/test/compile-fail/no_freeze-rc.rs"}, {"sha": "7bb7d86e8d870d309a50a6bafdf6fce54b00fe35", "filename": "src/test/compile-fail/no_share-struct.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fno_share-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Fcompile-fail%2Fno_share-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_share-struct.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -10,13 +10,13 @@\n \n use std::kinds::marker;\n \n-struct Foo { a: int, m: marker::NoFreeze }\n+struct Foo { a: int, m: marker::NoShare }\n \n-fn bar<T: Freeze>(_: T) {}\n+fn bar<T: Share>(_: T) {}\n \n fn main() {\n-    let x = Foo { a: 5, m: marker::NoFreeze };\n+    let x = Foo { a: 5, m: marker::NoShare };\n     bar(x);\n     //~^ ERROR instantiating a type parameter with an incompatible type `Foo`,\n-    //         which does not fulfill `Freeze`\n+    //         which does not fulfill `Share`\n }", "previous_filename": "src/test/compile-fail/no_freeze-struct.rs"}, {"sha": "c8c2a11d8d649916bfb153f97df736407f3362c9", "filename": "src/test/run-pass/const-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-bound.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -12,7 +12,7 @@\n // are const.\n \n \n-fn foo<T:Freeze>(x: T) -> T { x }\n+fn foo<T: Share>(x: T) -> T { x }\n \n struct F { field: int }\n "}, {"sha": "f48a49a15eb3d805ffa0dbd6c11d6f526d425426", "filename": "src/test/run-pass/issue-2611-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Frun-pass%2Fissue-2611-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Frun-pass%2Fissue-2611-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611-3.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -12,7 +12,7 @@\n // than the traits require.\n \n trait A {\n-  fn b<C:Freeze,D>(x: C) -> C;\n+  fn b<C:Share,D>(x: C) -> C;\n }\n \n struct E {"}, {"sha": "0ed4fdb2c054d528fb9bfde5d371710ffbbd35fd", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e285208d550c41d5060bbc4a614c9b63c3bff6a/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=8e285208d550c41d5060bbc4a614c9b63c3bff6a", "patch": "@@ -65,10 +65,10 @@ pub fn main() {\n     let dogge1 = Dogge { bark_decibels: 100, tricks_known: 42, name: ~\"alan_turing\" };\n     let dogge2 = Dogge { bark_decibels: 55,  tricks_known: 11, name: ~\"albert_einstein\" };\n     let fishe = Goldfyshe { swim_speed: 998, name: ~\"alec_guinness\" };\n-    let arc = Arc::new(~[~catte  as ~Pet:Freeze+Send,\n-                         ~dogge1 as ~Pet:Freeze+Send,\n-                         ~fishe  as ~Pet:Freeze+Send,\n-                         ~dogge2 as ~Pet:Freeze+Send]);\n+    let arc = Arc::new(~[~catte  as ~Pet:Share+Send,\n+                         ~dogge1 as ~Pet:Share+Send,\n+                         ~fishe  as ~Pet:Share+Send,\n+                         ~dogge2 as ~Pet:Share+Send]);\n     let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n     task::spawn(proc() { check_legs(arc1); tx1.send(()); });\n@@ -83,21 +83,21 @@ pub fn main() {\n     rx3.recv();\n }\n \n-fn check_legs(arc: Arc<~[~Pet:Freeze+Send]>) {\n+fn check_legs(arc: Arc<~[~Pet:Share+Send]>) {\n     let mut legs = 0;\n     for pet in arc.get().iter() {\n         legs += pet.num_legs();\n     }\n     assert!(legs == 12);\n }\n-fn check_names(arc: Arc<~[~Pet:Freeze+Send]>) {\n+fn check_names(arc: Arc<~[~Pet:Share+Send]>) {\n     for pet in arc.get().iter() {\n         pet.name(|name| {\n             assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n         })\n     }\n }\n-fn check_pedigree(arc: Arc<~[~Pet:Freeze+Send]>) {\n+fn check_pedigree(arc: Arc<~[~Pet:Share+Send]>) {\n     for pet in arc.get().iter() {\n         assert!(pet.of_good_pedigree());\n     }"}]}