{"sha": "1fa6ada9dd3a17fc8c99b6b559a2835946803d21", "node_id": "C_kwDOAAsO6NoAKDFmYTZhZGE5ZGQzYTE3ZmM4Yzk5YjZiNTU5YTI4MzU5NDY4MDNkMjE", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2023-01-06T02:43:16Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2023-01-06T02:43:16Z"}, "message": "Detect bindings assigned blocks without tail expressions in trait errors\n\nAddress  #44173 for trait errors.", "tree": {"sha": "5ab6b85dd8bc2a5e3978c24522b84820c36d5b4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ab6b85dd8bc2a5e3978c24522b84820c36d5b4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fa6ada9dd3a17fc8c99b6b559a2835946803d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fa6ada9dd3a17fc8c99b6b559a2835946803d21", "html_url": "https://github.com/rust-lang/rust/commit/1fa6ada9dd3a17fc8c99b6b559a2835946803d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fa6ada9dd3a17fc8c99b6b559a2835946803d21/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1983a627b37c98e6660dd74ea3a56ac157fc2777", "url": "https://api.github.com/repos/rust-lang/rust/commits/1983a627b37c98e6660dd74ea3a56ac157fc2777", "html_url": "https://github.com/rust-lang/rust/commit/1983a627b37c98e6660dd74ea3a56ac157fc2777"}], "stats": {"total": 200, "additions": 172, "deletions": 28}, "files": [{"sha": "714fbcf4eaa68702b02734791a3b44b01bb51b7e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1fa6ada9dd3a17fc8c99b6b559a2835946803d21/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa6ada9dd3a17fc8c99b6b559a2835946803d21/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=1fa6ada9dd3a17fc8c99b6b559a2835946803d21", "patch": "@@ -771,7 +771,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 ),\n                             }\n                         };\n-\n+                        self.check_for_binding_assigned_block_without_tail_expression(\n+                            &obligation,\n+                            &mut err,\n+                            trait_predicate,\n+                        );\n                         if self.suggest_add_reference_to_arg(\n                             &obligation,\n                             &mut err,\n@@ -2267,23 +2271,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 if let (Some(body_id), Some(ty::subst::GenericArgKind::Type(_))) =\n                     (body_id, subst.map(|subst| subst.unpack()))\n                 {\n-                    struct FindExprBySpan<'hir> {\n-                        span: Span,\n-                        result: Option<&'hir hir::Expr<'hir>>,\n-                    }\n-\n-                    impl<'v> hir::intravisit::Visitor<'v> for FindExprBySpan<'v> {\n-                        fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n-                            if self.span == ex.span {\n-                                self.result = Some(ex);\n-                            } else {\n-                                hir::intravisit::walk_expr(self, ex);\n-                            }\n-                        }\n-                    }\n-\n-                    let mut expr_finder = FindExprBySpan { span, result: None };\n-\n+                    let mut expr_finder = FindExprBySpan::new(span);\n                     expr_finder.visit_expr(&self.tcx.hir().body(body_id).value);\n \n                     if let Some(hir::Expr {\n@@ -2770,6 +2758,36 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     }\n }\n \n+/// Crude way of getting back an `Expr` from a `Span`.\n+pub struct FindExprBySpan<'hir> {\n+    pub span: Span,\n+    pub result: Option<&'hir hir::Expr<'hir>>,\n+    pub ty_result: Option<&'hir hir::Ty<'hir>>,\n+}\n+\n+impl<'hir> FindExprBySpan<'hir> {\n+    fn new(span: Span) -> Self {\n+        Self { span, result: None, ty_result: None }\n+    }\n+}\n+\n+impl<'v> Visitor<'v> for FindExprBySpan<'v> {\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        if self.span == ex.span {\n+            self.result = Some(ex);\n+        } else {\n+            hir::intravisit::walk_expr(self, ex);\n+        }\n+    }\n+    fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n+        if self.span == ty.span {\n+            self.ty_result = Some(ty);\n+        } else {\n+            hir::intravisit::walk_ty(self, ty);\n+        }\n+    }\n+}\n+\n /// Look for type `param` in an ADT being used only through a reference to confirm that suggesting\n /// `param: ?Sized` would be a valid constraint.\n struct FindTypeParam {"}, {"sha": "ad2711209e259426f9347c2415de937170b7d01d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1fa6ada9dd3a17fc8c99b6b559a2835946803d21/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa6ada9dd3a17fc8c99b6b559a2835946803d21/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=1fa6ada9dd3a17fc8c99b6b559a2835946803d21", "patch": "@@ -1,6 +1,9 @@\n // ignore-tidy-filelength\n \n-use super::{DefIdOrName, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation};\n+use super::{\n+    DefIdOrName, FindExprBySpan, Obligation, ObligationCause, ObligationCauseCode,\n+    PredicateObligation,\n+};\n \n use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n@@ -196,6 +199,13 @@ pub trait TypeErrCtxtExt<'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n \n+    fn check_for_binding_assigned_block_without_tail_expression(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut Diagnostic,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n+    );\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1032,6 +1042,66 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         true\n     }\n \n+    fn check_for_binding_assigned_block_without_tail_expression(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut Diagnostic,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n+    ) {\n+        let mut span = obligation.cause.span;\n+        while span.from_expansion() {\n+            // Remove all the desugaring and macro contexts.\n+            span.remove_mark();\n+        }\n+        let mut expr_finder = FindExprBySpan::new(span);\n+        let Some(hir::Node::Expr(body)) = self.tcx.hir().find(obligation.cause.body_id) else { return; };\n+        expr_finder.visit_expr(&body);\n+        let Some(expr) = expr_finder.result else { return; };\n+        let Some(typeck) = &self.typeck_results else { return; };\n+        let Some(ty) = typeck.expr_ty_adjusted_opt(expr) else { return; };\n+        if !ty.is_unit() {\n+            return;\n+        };\n+        let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind else { return; };\n+        let hir::def::Res::Local(hir_id) = path.res else { return; };\n+        let Some(hir::Node::Pat(pat)) = self.tcx.hir().find(hir_id) else {\n+            return;\n+        };\n+        let Some(hir::Node::Local(hir::Local {\n+            ty: None,\n+            init: Some(init),\n+            ..\n+        })) = self.tcx.hir().find_parent(pat.hir_id) else { return; };\n+        let hir::ExprKind::Block(block, None) = init.kind else { return; };\n+        if block.expr.is_some() {\n+            return;\n+        }\n+        let [.., stmt] = block.stmts else {\n+            err.span_help(block.span, \"this empty block is missing a tail expression\");\n+            return;\n+        };\n+        let hir::StmtKind::Semi(tail_expr) = stmt.kind else { return; };\n+        let Some(ty) = typeck.expr_ty_opt(tail_expr) else {\n+            err.span_help(block.span, \"this block is missing a tail expression\");\n+            return;\n+        };\n+        let ty = self.resolve_numeric_literals_with_default(self.resolve_vars_if_possible(ty));\n+        let trait_pred_and_self = trait_pred.map_bound(|trait_pred| (trait_pred, ty));\n+\n+        let new_obligation =\n+            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred_and_self);\n+        if self.predicate_must_hold_modulo_regions(&new_obligation) {\n+            err.span_suggestion_verbose(\n+                stmt.span.with_lo(tail_expr.span.hi()),\n+                \"remove this semicolon\",\n+                \"\",\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            err.span_help(block.span, \"this block is missing a tail expression\");\n+        }\n+    }\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,"}, {"sha": "09afd27a079ba6111003e9181a9c949950e41018", "filename": "src/test/ui/type/binding-assigned-block-without-tail-expression.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fa6ada9dd3a17fc8c99b6b559a2835946803d21/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fa6ada9dd3a17fc8c99b6b559a2835946803d21/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.rs?ref=1fa6ada9dd3a17fc8c99b6b559a2835946803d21", "patch": "@@ -1,3 +1,4 @@\n+struct S;\n fn main() {\n     let x = {\n         println!(\"foo\");\n@@ -7,10 +8,15 @@ fn main() {\n     let z = {\n         \"hi\";\n     };\n+    let s = {\n+        S;\n+    };\n     println!(\"{}\", x); //~ ERROR E0277\n     println!(\"{}\", y); //~ ERROR E0277\n     println!(\"{}\", z); //~ ERROR E0277\n+    println!(\"{}\", s); //~ ERROR E0277\n     let _: i32 = x; //~ ERROR E0308\n     let _: i32 = y; //~ ERROR E0308\n     let _: i32 = z; //~ ERROR E0308\n+    let _: i32 = s; //~ ERROR E0308\n }"}, {"sha": "646c632517aea401b8017b8bf801794497d74dd7", "filename": "src/test/ui/type/binding-assigned-block-without-tail-expression.stderr", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1fa6ada9dd3a17fc8c99b6b559a2835946803d21/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fa6ada9dd3a17fc8c99b6b559a2835946803d21/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fbinding-assigned-block-without-tail-expression.stderr?ref=1fa6ada9dd3a17fc8c99b6b559a2835946803d21", "patch": "@@ -1,35 +1,68 @@\n error[E0277]: `()` doesn't implement `std::fmt::Display`\n-  --> $DIR/binding-assigned-block-without-tail-expression.rs:10:20\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:14:20\n    |\n LL |     println!(\"{}\", x);\n    |                    ^ `()` cannot be formatted with the default formatter\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `()`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: remove this semicolon\n+   |\n+LL -         42;\n+LL +         42\n+   |\n \n error[E0277]: `()` doesn't implement `std::fmt::Display`\n-  --> $DIR/binding-assigned-block-without-tail-expression.rs:11:20\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:15:20\n    |\n LL |     println!(\"{}\", y);\n    |                    ^ `()` cannot be formatted with the default formatter\n    |\n+help: this empty block is missing a tail expression\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:7:13\n+   |\n+LL |     let y = {};\n+   |             ^^\n    = help: the trait `std::fmt::Display` is not implemented for `()`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: `()` doesn't implement `std::fmt::Display`\n-  --> $DIR/binding-assigned-block-without-tail-expression.rs:12:20\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:16:20\n    |\n LL |     println!(\"{}\", z);\n    |                    ^ `()` cannot be formatted with the default formatter\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `()`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: remove this semicolon\n+   |\n+LL -         \"hi\";\n+LL +         \"hi\"\n+   |\n+\n+error[E0277]: `()` doesn't implement `std::fmt::Display`\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:17:20\n+   |\n+LL |     println!(\"{}\", s);\n+   |                    ^ `()` cannot be formatted with the default formatter\n+   |\n+help: this block is missing a tail expression\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:11:13\n+   |\n+LL |       let s = {\n+   |  _____________^\n+LL | |         S;\n+LL | |     };\n+   | |_____^\n+   = help: the trait `std::fmt::Display` is not implemented for `()`\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n-  --> $DIR/binding-assigned-block-without-tail-expression.rs:13:18\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:18:18\n    |\n LL |     let _: i32 = x;\n    |            ---   ^ expected `i32`, found `()`\n@@ -43,37 +76,54 @@ LL +         42\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/binding-assigned-block-without-tail-expression.rs:14:18\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:19:18\n    |\n LL |     let _: i32 = y;\n    |            ---   ^ expected `i32`, found `()`\n    |            |\n    |            expected due to this\n    |\n help: this empty block is missing a tail expression\n-  --> $DIR/binding-assigned-block-without-tail-expression.rs:6:13\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:7:13\n    |\n LL |     let y = {};\n    |             ^^\n \n error[E0308]: mismatched types\n-  --> $DIR/binding-assigned-block-without-tail-expression.rs:15:18\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:20:18\n    |\n LL |     let _: i32 = z;\n    |            ---   ^ expected `i32`, found `()`\n    |            |\n    |            expected due to this\n    |\n help: this block is missing a tail expression\n-  --> $DIR/binding-assigned-block-without-tail-expression.rs:7:13\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:8:13\n    |\n LL |       let z = {\n    |  _____________^\n LL | |         \"hi\";\n LL | |     };\n    | |_____^\n \n-error: aborting due to 6 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:21:18\n+   |\n+LL |     let _: i32 = s;\n+   |            ---   ^ expected `i32`, found `()`\n+   |            |\n+   |            expected due to this\n+   |\n+help: this block is missing a tail expression\n+  --> $DIR/binding-assigned-block-without-tail-expression.rs:11:13\n+   |\n+LL |       let s = {\n+   |  _____________^\n+LL | |         S;\n+LL | |     };\n+   | |_____^\n+\n+error: aborting due to 8 previous errors\n \n Some errors have detailed explanations: E0277, E0308.\n For more information about an error, try `rustc --explain E0277`."}]}