{"sha": "6b0a16ab1ad689679d5b2376f842ef0606bd81c7", "node_id": "C_kwDOAAsO6NoAKDZiMGExNmFiMWFkNjg5Njc5ZDViMjM3NmY4NDJlZjA2MDZiZDgxYzc", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-29T23:54:57Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-29T23:54:57Z"}, "message": "Pre-allocate an empty `Lrc<NamedMatchVec>`.\n\nThis avoids some allocations.", "tree": {"sha": "19bbed1288063c64ddb3bf3251cc9f562f322a86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19bbed1288063c64ddb3bf3251cc9f562f322a86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b0a16ab1ad689679d5b2376f842ef0606bd81c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b0a16ab1ad689679d5b2376f842ef0606bd81c7", "html_url": "https://github.com/rust-lang/rust/commit/6b0a16ab1ad689679d5b2376f842ef0606bd81c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b0a16ab1ad689679d5b2376f842ef0606bd81c7/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "524d21bd5495ad9941597701e7e924ade3f60b53", "url": "https://api.github.com/repos/rust-lang/rust/commits/524d21bd5495ad9941597701e7e924ade3f60b53", "html_url": "https://github.com/rust-lang/rust/commit/524d21bd5495ad9941597701e7e924ade3f60b53"}], "stats": {"total": 34, "additions": 26, "deletions": 8}, "files": [{"sha": "18302ffdb8e1054cb0b109c9dd4b01bd5db41940", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6b0a16ab1ad689679d5b2376f842ef0606bd81c7/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b0a16ab1ad689679d5b2376f842ef0606bd81c7/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=6b0a16ab1ad689679d5b2376f842ef0606bd81c7", "patch": "@@ -155,11 +155,11 @@ struct MatcherPos<'tt> {\n rustc_data_structures::static_assert_size!(MatcherPos<'_>, 104);\n \n impl<'tt> MatcherPos<'tt> {\n-    fn top_level(matcher: &'tt [TokenTree]) -> Self {\n+    fn top_level(matcher: &'tt [TokenTree], empty_matches: Lrc<NamedMatchVec>) -> Self {\n         MatcherPos {\n             tts: matcher,\n             idx: 0,\n-            matches: Lrc::new(smallvec![]),\n+            matches: empty_matches,\n             seq_depth: 0,\n             match_lo: 0,\n             match_cur: 0,\n@@ -168,7 +168,11 @@ impl<'tt> MatcherPos<'tt> {\n         }\n     }\n \n-    fn sequence(parent: Box<MatcherPos<'tt>>, seq: &'tt SequenceRepetition) -> Self {\n+    fn sequence(\n+        parent: Box<MatcherPos<'tt>>,\n+        seq: &'tt SequenceRepetition,\n+        empty_matches: Lrc<NamedMatchVec>,\n+    ) -> Self {\n         let mut mp = MatcherPos {\n             tts: &seq.tts,\n             idx: 0,\n@@ -182,7 +186,7 @@ impl<'tt> MatcherPos<'tt> {\n         // Start with an empty vec for each metavar within the sequence. Note that `mp.seq_depth`\n         // must have the parent's depth at this point for these `push_match` calls to work.\n         for idx in mp.match_lo..mp.match_lo + seq.num_captures {\n-            mp.push_match(idx, MatchedSeq(Lrc::new(smallvec![])));\n+            mp.push_match(idx, MatchedSeq(empty_matches.clone()));\n         }\n         mp.seq_depth += 1;\n         mp\n@@ -415,11 +419,21 @@ pub struct TtParser<'tt> {\n \n     /// The set of mps that are waiting for the black-box parser.\n     bb_mps: Vec<Box<MatcherPos<'tt>>>,\n+\n+    /// Pre-allocate an empty match array, so it can be cloned cheaply for macros with many rules\n+    /// that have no metavars.\n+    empty_matches: Lrc<NamedMatchVec>,\n }\n \n impl<'tt> TtParser<'tt> {\n     pub(super) fn new(macro_name: Ident) -> TtParser<'tt> {\n-        TtParser { macro_name, cur_mps: vec![], next_mps: vec![], bb_mps: vec![] }\n+        TtParser {\n+            macro_name,\n+            cur_mps: vec![],\n+            next_mps: vec![],\n+            bb_mps: vec![],\n+            empty_matches: Lrc::new(smallvec![]),\n+        }\n     }\n \n     /// Process the matcher positions of `cur_mps` until it is empty. In the process, this will\n@@ -469,13 +483,17 @@ impl<'tt> TtParser<'tt> {\n                             new_mp.match_cur += seq.num_captures;\n                             new_mp.idx += 1;\n                             for idx in mp.match_cur..mp.match_cur + seq.num_captures {\n-                                new_mp.push_match(idx, MatchedSeq(Lrc::new(smallvec![])));\n+                                new_mp.push_match(idx, MatchedSeq(self.empty_matches.clone()));\n                             }\n                             self.cur_mps.push(new_mp);\n                         }\n \n                         // Allow for the possibility of one or more matches of this sequence.\n-                        self.cur_mps.push(box MatcherPos::sequence(mp, &seq));\n+                        self.cur_mps.push(box MatcherPos::sequence(\n+                            mp,\n+                            &seq,\n+                            self.empty_matches.clone(),\n+                        ));\n                     }\n \n                     &TokenTree::MetaVarDecl(span, _, None) => {\n@@ -621,7 +639,7 @@ impl<'tt> TtParser<'tt> {\n         // possible next positions into `next_mps`. After some post-processing, the contents of\n         // `next_mps` replenish `cur_mps` and we start over again.\n         self.cur_mps.clear();\n-        self.cur_mps.push(box MatcherPos::top_level(matcher));\n+        self.cur_mps.push(box MatcherPos::top_level(matcher, self.empty_matches.clone()));\n \n         loop {\n             self.next_mps.clear();"}]}