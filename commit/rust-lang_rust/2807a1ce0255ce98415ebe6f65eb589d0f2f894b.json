{"sha": "2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MDdhMWNlMDI1NWNlOTg0MTVlYmU2ZjY1ZWI1ODlkMGYyZjg5NGI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-02-24T18:15:45Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-02-24T18:15:45Z"}, "message": "Use arrays instead of vectors in tests", "tree": {"sha": "879116c1d285754e3e3779817211b816849902b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/879116c1d285754e3e3779817211b816849902b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "html_url": "https://github.com/rust-lang/rust/commit/2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e", "html_url": "https://github.com/rust-lang/rust/commit/dccdde4007c191aa8b8d9cfffb0c7d3509fa675e"}], "stats": {"total": 521, "additions": 254, "deletions": 267}, "files": [{"sha": "49da298bb3fcb1b524b012123c28823dcc356c04", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -73,7 +73,7 @@ macro_rules! vec {\n     };\n }\n # fn main() {\n-#     assert_eq!(&[1,2,3], &vec![1,2,3]);\n+#     assert_eq!([1,2,3], vec![1,2,3]);\n # }\n ```\n "}, {"sha": "36c76dbad14aefcb20076f4d9c63613aa80fe221", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -480,7 +480,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(3);\n     ///\n     /// let vec = heap.into_sorted_vec();\n-    /// assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7]);\n+    /// assert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);\n     /// ```\n     pub fn into_sorted_vec(mut self) -> Vec<T> {\n         let mut end = self.len();"}, {"sha": "61bb204a443edb2ccc37df91cd3238e6b51bd2c1", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -640,13 +640,13 @@ impl BitVec {\n     /// let mut bv = BitVec::from_elem(3, true);\n     /// bv.set(1, false);\n     ///\n-    /// assert_eq!(bv.to_bytes(), vec!(0b10100000));\n+    /// assert_eq!(bv.to_bytes(), [0b10100000]);\n     ///\n     /// let mut bv = BitVec::from_elem(9, false);\n     /// bv.set(2, true);\n     /// bv.set(8, true);\n     ///\n-    /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n+    /// assert_eq!(bv.to_bytes(), [0b00100000, 0b10000000]);\n     /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n         fn bit(bit_vec: &BitVec, byte: usize, bit: usize) -> u8 {\n@@ -806,7 +806,7 @@ impl BitVec {\n     /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n     /// bv.grow(2, true);\n     /// assert_eq!(bv.len(), 10);\n-    /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n+    /// assert_eq!(bv.to_bytes(), [0b01001011, 0b11000000]);\n     /// ```\n     pub fn grow(&mut self, n: usize, value: bool) {\n         // Note: we just bulk set all the bits in the last word in this fn in multiple places\n@@ -2285,12 +2285,12 @@ mod tests {\n     fn test_to_bytes() {\n         let mut bv = BitVec::from_elem(3, true);\n         bv.set(1, false);\n-        assert_eq!(bv.to_bytes(), vec!(0b10100000));\n+        assert_eq!(bv.to_bytes(), [0b10100000]);\n \n         let mut bv = BitVec::from_elem(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n-        assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n+        assert_eq!(bv.to_bytes(), [0b00100000, 0b10000000]);\n     }\n \n     #[test]\n@@ -2675,7 +2675,7 @@ mod bit_set_test {\n         let bit_vec: BitSet = usizes.into_iter().collect();\n \n         let idxs: Vec<_> = bit_vec.iter().collect();\n-        assert_eq!(idxs, vec![0, 2, 3]);\n+        assert_eq!(idxs, [0, 2, 3]);\n \n         let long: BitSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n         let real: Vec<_> = range_step(0, 10000, 2).collect();"}, {"sha": "6b83253faed820e4e9e2a0756cb0dbeb37479d02", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -1281,7 +1281,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(2, \"b\");\n     ///\n     /// let keys: Vec<usize> = a.keys().cloned().collect();\n-    /// assert_eq!(keys, vec![1,2,]);\n+    /// assert_eq!(keys, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n@@ -1303,7 +1303,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(2, \"b\");\n     ///\n     /// let values: Vec<&str> = a.values().cloned().collect();\n-    /// assert_eq!(values, vec![\"a\",\"b\"]);\n+    /// assert_eq!(values, [\"a\", \"b\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {"}, {"sha": "8a668a23dbbe7c1e9245862d83e9db3c10d3bcdf", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -121,7 +121,7 @@ impl<T> BTreeSet<T> {\n     /// }\n     ///\n     /// let v: Vec<usize> = set.iter().cloned().collect();\n-    /// assert_eq!(v, vec![1,2,3,4]);\n+    /// assert_eq!(v, [1, 2, 3, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n@@ -138,7 +138,7 @@ impl<T> BTreeSet<T> {\n     /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n     ///\n     /// let v: Vec<usize> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1,2,3,4]);\n+    /// assert_eq!(v, [1, 2, 3, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n@@ -197,7 +197,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(3);\n     ///\n     /// let diff: Vec<usize> = a.difference(&b).cloned().collect();\n-    /// assert_eq!(diff, vec![1]);\n+    /// assert_eq!(diff, [1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n@@ -220,7 +220,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(3);\n     ///\n     /// let sym_diff: Vec<usize> = a.symmetric_difference(&b).cloned().collect();\n-    /// assert_eq!(sym_diff, vec![1,3]);\n+    /// assert_eq!(sym_diff, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n@@ -244,7 +244,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(3);\n     ///\n     /// let intersection: Vec<usize> = a.intersection(&b).cloned().collect();\n-    /// assert_eq!(intersection, vec![2]);\n+    /// assert_eq!(intersection, [2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n@@ -266,7 +266,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(2);\n     ///\n     /// let union: Vec<usize> = a.union(&b).cloned().collect();\n-    /// assert_eq!(union, vec![1,2]);\n+    /// assert_eq!(union, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n@@ -534,7 +534,7 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     ///\n     /// let result = &a - &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1, 2]);\n+    /// assert_eq!(result_vec, [1, 2]);\n     /// ```\n     fn sub(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n         self.difference(rhs).cloned().collect()\n@@ -557,7 +557,7 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     ///\n     /// let result = &a ^ &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1, 4]);\n+    /// assert_eq!(result_vec, [1, 4]);\n     /// ```\n     fn bitxor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n         self.symmetric_difference(rhs).cloned().collect()\n@@ -580,7 +580,7 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     ///\n     /// let result = &a & &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![2, 3]);\n+    /// assert_eq!(result_vec, [2, 3]);\n     /// ```\n     fn bitand(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n         self.intersection(rhs).cloned().collect()\n@@ -603,7 +603,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     ///\n     /// let result = &a | &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1, 2, 3, 4, 5]);\n+    /// assert_eq!(result_vec, [1, 2, 3, 4, 5]);\n     /// ```\n     fn bitor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n         self.union(rhs).cloned().collect()"}, {"sha": "12c5d7a9cc61de7349a12d5c3dc501e1aa9a54b3", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -428,19 +428,19 @@ mod test {\n \n         e1.insert(A);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A], elems);\n+        assert_eq!([A], elems);\n \n         e1.insert(C);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A,C], elems);\n+        assert_eq!([A,C], elems);\n \n         e1.insert(C);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A,C], elems);\n+        assert_eq!([A,C], elems);\n \n         e1.insert(B);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A,B,C], elems);\n+        assert_eq!([A,B,C], elems);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -458,35 +458,35 @@ mod test {\n \n         let e_union = e1 | e2;\n         let elems: ::vec::Vec<_> = e_union.iter().collect();\n-        assert_eq!(vec![A,B,C], elems);\n+        assert_eq!([A,B,C], elems);\n \n         let e_intersection = e1 & e2;\n         let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n-        assert_eq!(vec![C], elems);\n+        assert_eq!([C], elems);\n \n         // Another way to express intersection\n         let e_intersection = e1 - (e1 - e2);\n         let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n-        assert_eq!(vec![C], elems);\n+        assert_eq!([C], elems);\n \n         let e_subtract = e1 - e2;\n         let elems: ::vec::Vec<_> = e_subtract.iter().collect();\n-        assert_eq!(vec![A], elems);\n+        assert_eq!([A], elems);\n \n         // Bitwise XOR of two sets, aka symmetric difference\n         let e_symmetric_diff = e1 ^ e2;\n         let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems);\n+        assert_eq!([A,B], elems);\n \n         // Another way to express symmetric difference\n         let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n         let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems);\n+        assert_eq!([A,B], elems);\n \n         // Yet another way to express symmetric difference\n         let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n         let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems);\n+        assert_eq!([A,B], elems);\n     }\n \n     #[test]"}, {"sha": "aa9bd5b0fedabd41a553a27b165c41cba640fd72", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -777,7 +777,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// {\n     ///     let vec: Vec<_> = list.into_iter().collect();\n-    ///     assert_eq!(vec, vec![1, 2, 3, 4]);\n+    ///     assert_eq!(vec, [1, 2, 3, 4]);\n     /// }\n     /// ```\n     #[inline]\n@@ -1273,7 +1273,7 @@ mod tests {\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), vec![-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n     }\n \n     #[test]"}, {"sha": "e9764547628c052cd22db69dbf5424e619881db4", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -26,7 +26,7 @@\n ///\n /// ```\n /// let v = vec![1; 3];\n-/// assert_eq!(v, vec![1, 1, 1]);\n+/// assert_eq!(v, [1, 1, 1]);\n /// ```\n ///\n /// Note that unlike array expressions this syntax supports all elements"}, {"sha": "6850e8c0f8ee743446465e33dc03f54a851a60c3", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -1779,10 +1779,10 @@ mod tests {\n         let mut v = vec![1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n         assert_eq!(e, 1);\n-        assert_eq!(v, vec![5, 2, 3, 4]);\n+        assert_eq!(v, [5, 2, 3, 4]);\n         e = v.swap_remove(3);\n         assert_eq!(e, 4);\n-        assert_eq!(v, vec![5, 2, 3]);\n+        assert_eq!(v, [5, 2, 3]);\n     }\n \n     #[test]\n@@ -1890,7 +1890,7 @@ mod tests {\n     fn test_retain() {\n         let mut v = vec![1, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        assert_eq!(v, vec![1, 3, 5]);\n+        assert_eq!(v, [1, 3, 5]);\n     }\n \n     #[test]\n@@ -2159,45 +2159,45 @@ mod tests {\n         let v: [Vec<i32>; 0] = [];\n         let c = v.concat();\n         assert_eq!(c, []);\n-        let d = [vec![1], vec![2,3]].concat();\n-        assert_eq!(d, vec![1, 2, 3]);\n+        let d = [vec![1], vec![2, 3]].concat();\n+        assert_eq!(d, [1, 2, 3]);\n \n         let v: &[&[_]] = &[&[1], &[2, 3]];\n-        assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n+        assert_eq!(v.connect(&0), [1, 0, 2, 3]);\n         let v: &[&[_]] = &[&[1], &[2], &[3]];\n-        assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), [1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n         let v: [Vec<i32>; 0] = [];\n-        assert_eq!(v.connect(&0), vec![]);\n-        assert_eq!([vec![1], vec![2, 3]].connect(&0), vec![1, 0, 2, 3]);\n-        assert_eq!([vec![1], vec![2], vec![3]].connect(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), []);\n+        assert_eq!([vec![1i], vec![2, 3]].connect(&0), [1, 0, 2, 3]);\n+        assert_eq!([vec![1i], vec![2], vec![3]].connect(&0), [1, 0, 2, 0, 3]);\n \n         let v: [&[_]; 2] = [&[1], &[2, 3]];\n-        assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n+        assert_eq!(v.connect(&0), [1, 0, 2, 3]);\n         let v: [&[_]; 3] = [&[1], &[2], &[3]];\n-        assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), [1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_insert() {\n         let mut a = vec![1, 2, 4];\n         a.insert(2, 3);\n-        assert_eq!(a, vec![1, 2, 3, 4]);\n+        assert_eq!(a, [1, 2, 3, 4]);\n \n         let mut a = vec![1, 2, 3];\n         a.insert(0, 0);\n-        assert_eq!(a, vec![0, 1, 2, 3]);\n+        assert_eq!(a, [0, 1, 2, 3]);\n \n         let mut a = vec![1, 2, 3];\n         a.insert(3, 4);\n-        assert_eq!(a, vec![1, 2, 3, 4]);\n+        assert_eq!(a, [1, 2, 3, 4]);\n \n         let mut a = vec![];\n         a.insert(0, 1);\n-        assert_eq!(a, vec![1]);\n+        assert_eq!(a, [1]);\n     }\n \n     #[test]\n@@ -2212,16 +2212,16 @@ mod tests {\n         let mut a = vec![1, 2, 3, 4];\n \n         assert_eq!(a.remove(2), 3);\n-        assert_eq!(a, vec![1, 2, 4]);\n+        assert_eq!(a, [1, 2, 4]);\n \n         assert_eq!(a.remove(2), 4);\n-        assert_eq!(a, vec![1, 2]);\n+        assert_eq!(a, [1, 2]);\n \n         assert_eq!(a.remove(0), 1);\n-        assert_eq!(a, vec![2]);\n+        assert_eq!(a, [2]);\n \n         assert_eq!(a.remove(0), 2);\n-        assert_eq!(a, vec![]);\n+        assert_eq!(a, []);\n     }\n \n     #[test]"}, {"sha": "c58cca828d8c39a04c9fc542aa7b0ff3ec54a8ad", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -552,7 +552,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n     ///\n-    /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// assert_eq!(v, ['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chars(&self) -> Chars {\n@@ -600,20 +600,20 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n     /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, vec![\"\"]);\n+    /// assert_eq!(v, [\"\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n@@ -632,23 +632,23 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n-    /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n+    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n     ///\n     /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n-    /// assert_eq!(v, vec![\"abcXdef\"]);\n+    /// assert_eq!(v, [\"abcXdef\"]);\n     ///\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, vec![\"\"]);\n+    /// assert_eq!(v, [\"\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n+    /// assert_eq!(v, [\"abc\", \"def2ghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n@@ -669,17 +669,17 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, vec![\"A\", \"B\"]);\n+    /// assert_eq!(v, [\"A\", \"B\"]);\n     ///\n     /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n-    /// assert_eq!(v, vec![\"A\", \"\", \"B\", \"\"]);\n+    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi3\".split_terminator(|c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n@@ -699,17 +699,17 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n-    /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n-    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n+    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n@@ -727,13 +727,13 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n+    /// assert_eq!(v, [(0,3), (6,9), (12,15)]);\n     ///\n     /// let v: Vec<(usize, usize)> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, vec![(1,4), (4,7)]);\n+    /// assert_eq!(v, [(1,4), (4,7)]);\n     ///\n     /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n+    /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might have its iterator type changed\")]\n@@ -749,10 +749,10 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, vec![\"\", \"XXX\", \"YYY\", \"\"]);\n+    /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n     ///\n     /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n+    /// assert_eq!(v, [\"1\", \"\", \"2\"]);\n     /// ```\n     #[unstable(feature = \"collections\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use `split()` with a `&str`\")]\n@@ -770,7 +770,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let four_lines = \"foo\\nbar\\n\\nbaz\";\n     /// let v: Vec<&str> = four_lines.lines().collect();\n     ///\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     ///\n     /// Leaving off the trailing character:\n@@ -779,7 +779,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n     /// let v: Vec<&str> = four_lines.lines().collect();\n     ///\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(&self) -> Lines {\n@@ -796,7 +796,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\";\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n     ///\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     ///\n     /// Leaving off the trailing character:\n@@ -805,7 +805,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n     ///\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines_any(&self) -> LinesAny {\n@@ -1441,7 +1441,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n     /// let v: Vec<&str> = some_words.words().collect();\n     ///\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n     #[unstable(feature = \"str_words\",\n                reason = \"the precise algorithm to use is unclear\")]\n@@ -2400,35 +2400,35 @@ mod tests {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n         let split: Vec<&str> = data.splitn(3, ' ').collect();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         let split: Vec<&str> = data.splitn(3, |c: char| c == ' ').collect();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         // Unicode\n         let split: Vec<&str> = data.splitn(3, '\u00e4').collect();\n-        assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         let split: Vec<&str> = data.splitn(3, |c: char| c == '\u00e4').collect();\n-        assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n     #[test]\n     fn test_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n         let split: Vec<&str> = data.split('\\n').collect();\n-        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+        assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n         let split: Vec<&str> = data.split_terminator('\\n').collect();\n-        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+        assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n     fn test_words() {\n         let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n         let words: Vec<&str> = data.words().collect();\n-        assert_eq!(words, vec![\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n+        assert_eq!(words, [\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n     }\n \n     #[test]\n@@ -2513,11 +2513,11 @@ mod tests {\n     fn test_lines() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n         let lines: Vec<&str> = data.lines().collect();\n-        assert_eq!(lines, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+        assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n \n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n         let lines: Vec<&str> = data.lines().collect();\n-        assert_eq!(lines, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+        assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]"}, {"sha": "e9070cff207586cf7377b7023456c4f6f2c58ef4", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -120,7 +120,7 @@ impl String {\n     /// let invalid_vec = vec![240, 144, 128];\n     /// let s = String::from_utf8(invalid_vec).err().unwrap();\n     /// assert_eq!(s.utf8_error(), Utf8Error::TooShort);\n-    /// assert_eq!(s.into_bytes(), vec![240, 144, 128]);\n+    /// assert_eq!(s.into_bytes(), [240, 144, 128]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -340,7 +340,7 @@ impl String {\n     /// ```\n     /// let s = String::from_str(\"hello\");\n     /// let bytes = s.into_bytes();\n-    /// assert_eq!(bytes, vec![104, 101, 108, 108, 111]);\n+    /// assert_eq!(bytes, [104, 101, 108, 108, 111]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -619,7 +619,7 @@ impl String {\n     /// let mut s = String::from_str(\"hello\");\n     /// unsafe {\n     ///     let vec = s.as_mut_vec();\n-    ///     assert!(vec == &mut vec![104, 101, 108, 108, 111]);\n+    ///     assert!(vec == &[104, 101, 108, 108, 111]);\n     ///     vec.reverse();\n     /// }\n     /// assert_eq!(s.as_slice(), \"olleh\");"}, {"sha": "c446618649d7d8465f50469dd30f5237e41f7ddd", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -93,15 +93,15 @@ use borrow::{Cow, IntoCow};\n /// for x in vec.iter() {\n ///     println!(\"{}\", x);\n /// }\n-/// assert_eq!(vec, vec![7, 1, 2, 3]);\n+/// assert_eq!(vec, [7, 1, 2, 3]);\n /// ```\n ///\n /// The `vec!` macro is provided to make initialization more convenient:\n ///\n /// ```\n /// let mut vec = vec![1, 2, 3];\n /// vec.push(4);\n-/// assert_eq!(vec, vec![1, 2, 3, 4]);\n+/// assert_eq!(vec, [1, 2, 3, 4]);\n /// ```\n ///\n /// Use a `Vec<T>` as an efficient stack:\n@@ -242,7 +242,7 @@ impl<T> Vec<T> {\n     ///\n     ///         // Put everything back together into a Vec\n     ///         let rebuilt = Vec::from_raw_parts(p, len, cap);\n-    ///         assert_eq!(rebuilt, vec![4, 5, 6]);\n+    ///         assert_eq!(rebuilt, [4, 5, 6]);\n     ///     }\n     /// }\n     /// ```\n@@ -404,7 +404,7 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.truncate(2);\n-    /// assert_eq!(vec, vec![1, 2]);\n+    /// assert_eq!(vec, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: usize) {\n@@ -505,10 +505,10 @@ impl<T> Vec<T> {\n     /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n     ///\n     /// assert_eq!(v.swap_remove(1), \"bar\");\n-    /// assert_eq!(v, vec![\"foo\", \"qux\", \"baz\"]);\n+    /// assert_eq!(v, [\"foo\", \"qux\", \"baz\"]);\n     ///\n     /// assert_eq!(v.swap_remove(0), \"foo\");\n-    /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n+    /// assert_eq!(v, [\"baz\", \"qux\"]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -531,9 +531,9 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut vec = vec![1, 2, 3];\n     /// vec.insert(1, 4);\n-    /// assert_eq!(vec, vec![1, 4, 2, 3]);\n+    /// assert_eq!(vec, [1, 4, 2, 3]);\n     /// vec.insert(4, 5);\n-    /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n+    /// assert_eq!(vec, [1, 4, 2, 3, 5]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, index: usize, element: T) {\n@@ -569,7 +569,7 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut v = vec![1, 2, 3];\n     /// assert_eq!(v.remove(1), 2);\n-    /// assert_eq!(v, vec![1, 3]);\n+    /// assert_eq!(v, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: usize) -> T {\n@@ -603,7 +603,7 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.retain(|&x| x%2 == 0);\n-    /// assert_eq!(vec, vec![2, 4]);\n+    /// assert_eq!(vec, [2, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n@@ -636,7 +636,7 @@ impl<T> Vec<T> {\n     /// ```rust\n     /// let mut vec = vec!(1, 2);\n     /// vec.push(3);\n-    /// assert_eq!(vec, vec!(1, 2, 3));\n+    /// assert_eq!(vec, [1, 2, 3]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -674,7 +674,7 @@ impl<T> Vec<T> {\n     /// ```rust\n     /// let mut vec = vec![1, 2, 3];\n     /// assert_eq!(vec.pop(), Some(3));\n-    /// assert_eq!(vec, vec![1, 2]);\n+    /// assert_eq!(vec, [1, 2]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -701,8 +701,8 @@ impl<T> Vec<T> {\n     /// let mut vec = vec![1, 2, 3];\n     /// let mut vec2 = vec![4, 5, 6];\n     /// vec.append(&mut vec2);\n-    /// assert_eq!(vec, vec![1, 2, 3, 4, 5, 6]);\n-    /// assert_eq!(vec2, vec![]);\n+    /// assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n+    /// assert_eq!(vec2, []);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"collections\",\n@@ -1019,8 +1019,8 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut vec = vec![1,2,3];\n     /// let vec2 = vec.split_off(1);\n-    /// assert_eq!(vec, vec![1]);\n-    /// assert_eq!(vec2, vec![2, 3]);\n+    /// assert_eq!(vec, [1]);\n+    /// assert_eq!(vec2, [2, 3]);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"collections\",\n@@ -1057,11 +1057,11 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     /// let mut vec = vec![\"hello\"];\n     /// vec.resize(3, \"world\");\n-    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n+    /// assert_eq!(vec, [\"hello\", \"world\", \"world\"]);\n     ///\n     /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.resize(2, 0);\n-    /// assert_eq!(vec, vec![1, 2]);\n+    /// assert_eq!(vec, [1, 2]);\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting for dust to settle\")]\n@@ -1085,7 +1085,7 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     /// let mut vec = vec![1];\n     /// vec.push_all(&[2, 3, 4]);\n-    /// assert_eq!(vec, vec![1, 2, 3, 4]);\n+    /// assert_eq!(vec, [1, 2, 3, 4]);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"collections\",\n@@ -1121,7 +1121,7 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// vec.dedup();\n     ///\n-    /// assert_eq!(vec, vec![1, 2, 3, 2]);\n+    /// assert_eq!(vec, [1, 2, 3, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn dedup(&mut self) {\n@@ -2105,7 +2105,7 @@ mod tests {\n             }\n         }\n \n-        assert!(values == vec![2, 3, 5, 6, 7]);\n+        assert_eq!(values, [2, 3, 5, 6, 7]);\n     }\n \n     #[test]\n@@ -2147,7 +2147,7 @@ mod tests {\n     fn test_retain() {\n         let mut vec = vec![1, 2, 3, 4];\n         vec.retain(|&x| x % 2 == 0);\n-        assert!(vec == vec![2, 4]);\n+        assert_eq!(vec, [2, 4]);\n     }\n \n     #[test]\n@@ -2207,13 +2207,13 @@ mod tests {\n             let a = [1, 2, 3];\n             let ptr = a.as_ptr();\n             let b = Vec::from_raw_buf(ptr, 3);\n-            assert_eq!(b, vec![1, 2, 3]);\n+            assert_eq!(b, [1, 2, 3]);\n \n             // Test on-heap copy-from-buf.\n             let c = vec![1, 2, 3, 4, 5];\n             let ptr = c.as_ptr();\n             let d = Vec::from_raw_buf(ptr, 5);\n-            assert_eq!(d, vec![1, 2, 3, 4, 5]);\n+            assert_eq!(d, [1, 2, 3, 4, 5]);\n         }\n     }\n \n@@ -2375,7 +2375,7 @@ mod tests {\n         for i in vec {\n             vec2.push(i);\n         }\n-        assert!(vec2 == vec![1, 2, 3]);\n+        assert_eq!(vec2, [1, 2, 3]);\n     }\n \n     #[test]\n@@ -2385,7 +2385,7 @@ mod tests {\n         for i in vec.into_iter().rev() {\n             vec2.push(i);\n         }\n-        assert!(vec2 == vec![3, 2, 1]);\n+        assert_eq!(vec2, [3, 2, 1]);\n     }\n \n     #[test]\n@@ -2395,7 +2395,7 @@ mod tests {\n         for i in vec {\n             vec2.push(i);\n         }\n-        assert!(vec2 == vec![(), (), ()]);\n+        assert_eq!(vec2, [(), (), ()]);\n     }\n \n     #[test]\n@@ -2443,16 +2443,16 @@ mod tests {\n         let mut vec = vec![1, 2, 3];\n         let mut vec2 = vec![4, 5, 6];\n         vec.append(&mut vec2);\n-        assert_eq!(vec, vec![1, 2, 3, 4, 5, 6]);\n-        assert_eq!(vec2, vec![]);\n+        assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n+        assert_eq!(vec2, []);\n     }\n \n     #[test]\n     fn test_split_off() {\n         let mut vec = vec![1, 2, 3, 4, 5, 6];\n         let vec2 = vec.split_off(4);\n-        assert_eq!(vec, vec![1, 2, 3, 4]);\n-        assert_eq!(vec2, vec![5, 6]);\n+        assert_eq!(vec, [1, 2, 3, 4]);\n+        assert_eq!(vec2, [5, 6]);\n     }\n \n     #[bench]"}, {"sha": "9476b98eb82c627655de6b9449d3e7d6df9c4e95", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -2105,7 +2105,7 @@ mod tests {\n         let mut d: VecDeque<_> = (0..5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n-        assert_eq!(d.iter().cloned().collect::<Vec<_>>(), vec!(4, 2, 3, 1));\n+        assert_eq!(d.iter().cloned().collect::<Vec<_>>(), [4, 2, 3, 1]);\n     }\n \n     #[test]\n@@ -2868,17 +2868,17 @@ mod tests {\n \n         // normal append\n         a.append(&mut b);\n-        assert_eq!(a.iter().cloned().collect(), vec![1, 2, 3, 4, 5, 6]);\n-        assert_eq!(b.iter().cloned().collect(), vec![]);\n+        assert_eq!(a.iter().cloned().collect(), [1, 2, 3, 4, 5, 6]);\n+        assert_eq!(b.iter().cloned().collect(), []);\n \n         // append nothing to something\n         a.append(&mut b);\n-        assert_eq!(a.iter().cloned().collect(), vec![1, 2, 3, 4, 5, 6]);\n-        assert_eq!(b.iter().cloned().collect(), vec![]);\n+        assert_eq!(a.iter().cloned().collect(), [1, 2, 3, 4, 5, 6]);\n+        assert_eq!(b.iter().cloned().collect(), []);\n \n         // append something to nothing\n         b.append(&mut a);\n-        assert_eq!(b.iter().cloned().collect(), vec![1, 2, 3, 4, 5, 6]);\n-        assert_eq!(a.iter().cloned().collect(), vec![]);\n+        assert_eq!(b.iter().cloned().collect(), [1, 2, 3, 4, 5, 6]);\n+        assert_eq!(a.iter().cloned().collect(), []);\n     }\n }"}, {"sha": "1c497c86dfdde93f858c4b49dcc7c35e4578b0bf", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -308,7 +308,7 @@ impl<V> VecMap<V> {\n     ///\n     /// let vec: Vec<(usize, &str)> = map.into_iter().collect();\n     ///\n-    /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+    /// assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<V> {\n@@ -425,7 +425,7 @@ impl<V> VecMap<V> {\n     ///\n     /// let vec: Vec<(usize, &str)> = map.drain().collect();\n     ///\n-    /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+    /// assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -1226,7 +1226,7 @@ mod test_map {\n \n         let vec: Vec<_> = map.drain().collect();\n \n-        assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+        assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n         assert_eq!(map.len(), 0);\n     }\n "}, {"sha": "6d8e04d97dd0325b729a7fdec9166b9c605d25f5", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -582,8 +582,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     /// let vec = vec![1, 2, 3, 4];\n     /// let (even, odd): (Vec<_>, Vec<_>) = vec.into_iter().partition(|&n| n % 2 == 0);\n-    /// assert_eq!(even, vec![2, 4]);\n-    /// assert_eq!(odd, vec![1, 3]);\n+    /// assert_eq!(even, [2, 4]);\n+    /// assert_eq!(odd, [1, 3]);\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"recently added as part of collections reform\")]"}, {"sha": "1ecbd8fae8cdb664b5f9549a358ea6c7cb7b7b01", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -556,7 +556,7 @@ impl<T> Option<T> {\n     /// ```\n     /// let x = Some(\"string\");\n     /// let v: Vec<&str> = x.into_iter().collect();\n-    /// assert_eq!(v, vec![\"string\"]);\n+    /// assert_eq!(v, [\"string\"]);\n     ///\n     /// let x = None;\n     /// let v: Vec<&str> = x.into_iter().collect();"}, {"sha": "bca73782491bf5fe30571f61665babdbf2163767", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -548,11 +548,11 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// let x: Result<u32, &str> = Ok(5);\n     /// let v: Vec<u32> = x.into_iter().collect();\n-    /// assert_eq!(v, vec![5]);\n+    /// assert_eq!(v, [5]);\n     ///\n     /// let x: Result<u32, &str> = Err(\"nothing!\");\n     /// let v: Vec<u32> = x.into_iter().collect();\n-    /// assert_eq!(v, vec![]);\n+    /// assert_eq!(v, []);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "8a27400389f4ada601d595879b3b0ed651c46ff4", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 21, "deletions": 32, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -74,7 +74,7 @@ fn test_multi_iter() {\n fn test_counter_from_iter() {\n     let it = count(0, 5).take(10);\n     let xs: Vec<int> = FromIterator::from_iter(it);\n-    assert!(xs == vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n+    assert_eq!(xs, [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n }\n \n #[test]\n@@ -104,7 +104,7 @@ fn test_iterator_chain() {\n fn test_filter_map() {\n     let it = count(0, 1).take(10)\n         .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-    assert!(it.collect::<Vec<uint>>() == vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n+    assert_eq!(it.collect::<Vec<uint>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n }\n \n #[test]\n@@ -730,23 +730,22 @@ fn test_random_access_cycle() {\n \n #[test]\n fn test_double_ended_range() {\n-    assert!((11..14).rev().collect::<Vec<_>>() == vec![13, 12, 11]);\n+    assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n     for _ in (10..0).rev() {\n         panic!(\"unreachable\");\n     }\n \n-    assert!((11..14).rev().collect::<Vec<_>>() == vec![13, 12, 11]);\n+    assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n     for _ in (10..0).rev() {\n         panic!(\"unreachable\");\n     }\n }\n \n #[test]\n fn test_range() {\n-    assert!((0..5).collect::<Vec<_>>() == vec![0, 1, 2, 3, 4]);\n-    assert!((-10..-1).collect::<Vec<_>>() ==\n-               vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-    assert!((0..5).rev().collect::<Vec<_>>() == vec![4, 3, 2, 1, 0]);\n+    assert_eq!((0..5).collect::<Vec<_>>(), [0, 1, 2, 3, 4]);\n+    assert_eq!((-10..-1).collect::<Vec<_>>(), [-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n+    assert_eq!((0..5).rev().collect::<Vec<_>>(), [4, 3, 2, 1, 0]);\n     assert_eq!((200..-5).count(), 0);\n     assert_eq!((200..-5).rev().count(), 0);\n     assert_eq!((200..200).count(), 0);\n@@ -767,38 +766,28 @@ fn test_range_inclusive() {\n             vec![5, 4, 3, 2, 1, 0]);\n     assert_eq!(range_inclusive(200, -5).count(), 0);\n     assert_eq!(range_inclusive(200, -5).rev().count(), 0);\n-    assert!(range_inclusive(200, 200).collect::<Vec<int>>() == vec![200]);\n-    assert!(range_inclusive(200, 200).rev().collect::<Vec<int>>() == vec![200]);\n+    assert_eq!(range_inclusive(200, 200).collect::<Vec<int>>(), [200]);\n+    assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<int>>(), [200]);\n }\n \n #[test]\n fn test_range_step() {\n-    assert!(range_step(0, 20, 5).collect::<Vec<int>>() ==\n-            vec![0, 5, 10, 15]);\n-    assert!(range_step(20, 0, -5).collect::<Vec<int>>() ==\n-            vec![20, 15, 10, 5]);\n-    assert!(range_step(20, 0, -6).collect::<Vec<int>>() ==\n-            vec![20, 14, 8, 2]);\n-    assert!(range_step(200u8, 255, 50).collect::<Vec<u8>>() ==\n-            vec![200u8, 250]);\n-    assert!(range_step(200, -5, 1).collect::<Vec<int>>() == vec![]);\n-    assert!(range_step(200, 200, 1).collect::<Vec<int>>() == vec![]);\n+    assert_eq!(range_step(0, 20, 5).collect::<Vec<int>>(), [0, 5, 10, 15]);\n+    assert_eq!(range_step(20, 0, -5).collect::<Vec<int>>(), [20, 15, 10, 5]);\n+    assert_eq!(range_step(20, 0, -6).collect::<Vec<int>>(), [20, 14, 8, 2]);\n+    assert_eq!(range_step(200u8, 255, 50).collect::<Vec<u8>>(), [200u8, 250]);\n+    assert_eq!(range_step(200i, -5, 1).collect::<Vec<int>>(), []);\n+    assert_eq!(range_step(200i, 200, 1).collect::<Vec<int>>(), []);\n }\n \n #[test]\n fn test_range_step_inclusive() {\n-    assert!(range_step_inclusive(0, 20, 5).collect::<Vec<int>>() ==\n-            vec![0, 5, 10, 15, 20]);\n-    assert!(range_step_inclusive(20, 0, -5).collect::<Vec<int>>() ==\n-            vec![20, 15, 10, 5, 0]);\n-    assert!(range_step_inclusive(20, 0, -6).collect::<Vec<int>>() ==\n-            vec![20, 14, 8, 2]);\n-    assert!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>() ==\n-            vec![200u8, 250]);\n-    assert!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>() ==\n-            vec![]);\n-    assert!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>() ==\n-            vec![200]);\n+    assert_eq!(range_step_inclusive(0, 20, 5).collect::<Vec<int>>(), [0, 5, 10, 15, 20]);\n+    assert_eq!(range_step_inclusive(20, 0, -5).collect::<Vec<int>>(), [20, 15, 10, 5, 0]);\n+    assert_eq!(range_step_inclusive(20, 0, -6).collect::<Vec<int>>(), [20, 14, 8, 2]);\n+    assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>(), [200u8, 250]);\n+    assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>(), []);\n+    assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>(), [200]);\n }\n \n #[test]"}, {"sha": "73000670c61aa839e975fb39829b45eb39be2789", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -103,7 +103,7 @@ fn test_transmute() {\n     }\n \n     unsafe {\n-        assert!(vec![76u8] == transmute::<_, Vec<u8>>(\"L\".to_string()));\n+        assert_eq!([76u8], transmute::<_, Vec<u8>>(\"L\".to_string()));\n     }\n }\n "}, {"sha": "f60570eaaf417941f4e54b4cf6beb5b60f5b8dc2", "filename": "src/libcoretest/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcoretest%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcoretest%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnonzero.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -54,7 +54,7 @@ fn test_match_option_empty_vec() {\n fn test_match_option_vec() {\n     let a = Some(vec![1, 2, 3, 4]);\n     match a {\n-        Some(v) => assert_eq!(v, vec![1, 2, 3, 4]),\n+        Some(v) => assert_eq!(v, [1, 2, 3, 4]),\n         None => panic!(\"unexpected None while matching on Some(vec![1, 2, 3, 4])\")\n     }\n }"}, {"sha": "c8a54ef59abda2c0676e72bd196db6090ae220c8", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -156,7 +156,7 @@ fn test_ptr_subtraction() {\n             m_ptr = m_ptr.offset(-1);\n         }\n \n-        assert!(xs_mut == vec![0,2,4,6,8,10,12,14,16,18]);\n+        assert_eq!(xs_mut, [0,2,4,6,8,10,12,14,16,18]);\n     }\n }\n "}, {"sha": "019f935911f7a78315f834be60b88c8928835c13", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -22,7 +22,7 @@ fn test_pattern_deref_forward() {\n fn test_empty_match_indices() {\n     let data = \"a\u00e4\u4e2d!\";\n     let vec: Vec<_> = data.match_indices(\"\").collect();\n-    assert_eq!(vec, vec![(0, 0), (1, 1), (3, 3), (6, 6), (7, 7)]);\n+    assert_eq!(vec, [(0, 0), (1, 1), (3, 3), (6, 6), (7, 7)]);\n }\n \n #[test]\n@@ -69,54 +69,54 @@ fn test_rsplitn_char_iterator() {\n \n     let mut split: Vec<&str> = data.rsplitn(3, ' ').collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == ' ').collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     // Unicode\n     let mut split: Vec<&str> = data.rsplitn(3, '\u00e4').collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == '\u00e4').collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n }\n \n #[test]\n fn test_split_char_iterator() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n     let split: Vec<&str> = data.split(' ').collect();\n-    assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n     rsplit.reverse();\n-    assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n-    assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n     rsplit.reverse();\n-    assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     // Unicode\n     let split: Vec<&str> = data.split('\u00e4').collect();\n-    assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n     rsplit.reverse();\n-    assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n-    assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n     rsplit.reverse();\n-    assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n }\n \n #[test]\n@@ -125,18 +125,18 @@ fn test_rev_split_char_iterator_no_trailing() {\n \n     let mut split: Vec<&str> = data.split('\\n').rev().collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n     let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n }\n \n #[test]\n fn test_utf16_code_units() {\n     use unicode::str::Utf16Encoder;\n     assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n-               vec![0xE9, 0xD83D, 0xDCA9])\n+               [0xE9, 0xD83D, 0xDCA9])\n }\n \n #[test]"}, {"sha": "c52465a889907b57c4357f19d4a801677ab8b6c5", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -45,7 +45,7 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n /// let mut w = SeekableMemWriter::new();\n /// w.write(&[0, 1, 2]);\n ///\n-/// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n+/// assert_eq!(w.unwrap(), [0, 1, 2]);\n /// ```\n pub struct SeekableMemWriter {\n     buf: Vec<u8>,"}, {"sha": "d9cedc482985155e84445cc947292d222e412359", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -806,11 +806,11 @@ fn walk_ty() {\n         let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n         let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n         let walked: Vec<_> = uniq_ty.walk().collect();\n-        assert_eq!(vec!(uniq_ty,\n-                        tup2_ty,\n-                        tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n-                        tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n-                        uint_ty),\n+        assert_eq!([uniq_ty,\n+                    tup2_ty,\n+                    tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n+                    tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n+                    uint_ty],\n                    walked);\n     })\n }"}, {"sha": "05d4e0f59fefc4d1732c83ec6ff588deda10df5d", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -3074,19 +3074,19 @@ mod tests {\n     #[test]\n     fn test_decode_array() {\n         let v: Vec<()> = super::decode(\"[]\").unwrap();\n-        assert_eq!(v, vec![]);\n+        assert_eq!(v, []);\n \n         let v: Vec<()> = super::decode(\"[null]\").unwrap();\n-        assert_eq!(v, vec![()]);\n+        assert_eq!(v, [()]);\n \n         let v: Vec<bool> = super::decode(\"[true]\").unwrap();\n-        assert_eq!(v, vec![true]);\n+        assert_eq!(v, [true]);\n \n         let v: Vec<int> = super::decode(\"[3, 1]\").unwrap();\n-        assert_eq!(v, vec![3, 1]);\n+        assert_eq!(v, [3, 1]);\n \n         let v: Vec<Vec<uint>> = super::decode(\"[[3], [1, 2]]\").unwrap();\n-        assert_eq!(v, vec![vec![3], vec![1, 2]]);\n+        assert_eq!(v, [vec![3], vec![1, 2]]);\n     }\n \n     #[test]"}, {"sha": "8bd19f063f0300c51cc9256b70f6c7f0d1aa5fba", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -328,7 +328,7 @@ mod test {\n     fn read_bytes() {\n         let mut reader = MemReader::new(vec!(10, 11, 12, 13));\n         let bytes = reader.read_exact(4).unwrap();\n-        assert!(bytes == vec!(10, 11, 12, 13));\n+        assert_eq!(bytes, [10, 11, 12, 13]);\n     }\n \n     #[test]\n@@ -337,7 +337,7 @@ mod test {\n             count: 0,\n         };\n         let bytes = reader.read_exact(4).unwrap();\n-        assert!(bytes == vec!(10, 11, 12, 13));\n+        assert_eq!(bytes, [10, 11, 12, 13]);\n     }\n \n     #[test]\n@@ -351,7 +351,7 @@ mod test {\n         let mut reader = MemReader::new(vec![10, 11, 12, 13]);\n         let mut buf = vec![8, 9];\n         assert!(reader.push_at_least(4, 4, &mut buf).is_ok());\n-        assert!(buf == vec![8, 9, 10, 11, 12, 13]);\n+        assert_eq!(buf, [8, 9, 10, 11, 12, 13]);\n     }\n \n     #[test]\n@@ -361,15 +361,15 @@ mod test {\n         };\n         let mut buf = vec![8, 9];\n         assert!(reader.push_at_least(4, 4, &mut buf).is_ok());\n-        assert!(buf == vec![8, 9, 10, 11, 12, 13]);\n+        assert_eq!(buf, [8, 9, 10, 11, 12, 13]);\n     }\n \n     #[test]\n     fn push_at_least_eof() {\n         let mut reader = MemReader::new(vec![10, 11]);\n         let mut buf = vec![8, 9];\n         assert!(reader.push_at_least(4, 4, &mut buf).is_err());\n-        assert!(buf == vec![8, 9, 10, 11]);\n+        assert_eq!(buf, [8, 9, 10, 11]);\n     }\n \n     #[test]\n@@ -379,7 +379,7 @@ mod test {\n         };\n         let mut buf = vec![8, 9];\n         assert!(reader.push_at_least(4, 4, &mut buf).is_err());\n-        assert!(buf == vec![8, 9, 10]);\n+        assert_eq!(buf, [8, 9, 10]);\n     }\n \n     #[test]\n@@ -388,7 +388,7 @@ mod test {\n             count: 0,\n         };\n         let buf = reader.read_to_end().unwrap();\n-        assert!(buf == vec!(10, 11, 12, 13));\n+        assert_eq!(buf, [10, 11, 12, 13]);\n     }\n \n     #[test]\n@@ -398,7 +398,7 @@ mod test {\n             count: 0,\n         };\n         let buf = reader.read_to_end().unwrap();\n-        assert!(buf == vec!(10, 11));\n+        assert_eq!(buf, [10, 11]);\n     }\n \n     #[test]"}, {"sha": "c08a2c1f477b3ea6017fffbaff6e739d301af081", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -60,7 +60,7 @@ impl Writer for Vec<u8> {\n /// let mut w = MemWriter::new();\n /// w.write(&[0, 1, 2]);\n ///\n-/// assert_eq!(w.into_inner(), vec!(0, 1, 2));\n+/// assert_eq!(w.into_inner(), [0, 1, 2]);\n /// ```\n #[unstable(feature = \"io\")]\n #[deprecated(since = \"1.0.0\",\n@@ -118,7 +118,7 @@ impl Writer for MemWriter {\n ///\n /// let mut r = MemReader::new(vec!(0, 1, 2));\n ///\n-/// assert_eq!(r.read_to_end().unwrap(), vec!(0, 1, 2));\n+/// assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n /// ```\n pub struct MemReader {\n     buf: Vec<u8>,\n@@ -321,7 +321,7 @@ impl<'a> Seek for BufWriter<'a> {\n /// let buf = [0, 1, 2, 3];\n /// let mut r = BufReader::new(&buf);\n ///\n-/// assert_eq!(r.read_to_end().unwrap(), vec![0, 1, 2, 3]);\n+/// assert_eq!(r.read_to_end().unwrap(), [0, 1, 2, 3]);\n /// ```\n pub struct BufReader<'a> {\n     buf: &'a [u8],\n@@ -504,8 +504,8 @@ mod test {\n         assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n+        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n+        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n         assert!(reader.read(&mut buf).is_err());\n     }\n \n@@ -530,8 +530,8 @@ mod test {\n         assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = &mut &*in_buf;\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n+        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n+        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n         assert!(reader.read(&mut buf).is_err());\n     }\n \n@@ -557,8 +557,8 @@ mod test {\n         assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = BufReader::new(&in_buf);\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n+        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n+        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n         assert!(reader.read(&mut buf).is_err());\n     }\n "}, {"sha": "cdf2bae1cbad3c260e28e36b682b1db6b1a4a201", "filename": "src/libstd/old_io/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibstd%2Fold_io%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibstd%2Fold_io%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fresult.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -87,7 +87,7 @@ mod test {\n         let mut writer: old_io::IoResult<Vec<u8>> = Ok(Vec::new());\n         writer.write_all(&[0, 1, 2]).unwrap();\n         writer.flush().unwrap();\n-        assert_eq!(writer.unwrap(), vec!(0, 1, 2));\n+        assert_eq!(writer.unwrap(), [0, 1, 2]);\n     }\n \n     #[test]"}, {"sha": "8e49335ed5469e110114ab9823866d113903e071", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -284,7 +284,7 @@ mod test {\n         let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 4);\n-            assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n+            assert_eq!([0, 1, 2], r.read_to_end().unwrap());\n         }\n     }\n \n@@ -293,9 +293,9 @@ mod test {\n         let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 2);\n-            assert_eq!(vec!(0, 1), r.read_to_end().unwrap());\n+            assert_eq!([0, 1], r.read_to_end().unwrap());\n         }\n-        assert_eq!(vec!(2), r.read_to_end().unwrap());\n+        assert_eq!([2], r.read_to_end().unwrap());\n     }\n \n     #[test]\n@@ -305,7 +305,7 @@ mod test {\n         assert_eq!(3, r.limit());\n         assert_eq!(0, r.read_byte().unwrap());\n         assert_eq!(2, r.limit());\n-        assert_eq!(vec!(1, 2), r.read_to_end().unwrap());\n+        assert_eq!([1, 2], r.read_to_end().unwrap());\n         assert_eq!(0, r.limit());\n     }\n \n@@ -314,7 +314,7 @@ mod test {\n         let mut r = MemReader::new(vec![0, 1, 2, 3, 4, 5]);\n         let mut r = LimitReader::new(r.by_ref(), 1);\n         r.consume(2);\n-        assert_eq!(vec![], r.read_to_end().unwrap());\n+        assert_eq!([], r.read_to_end().unwrap());\n     }\n \n     #[test]\n@@ -330,7 +330,7 @@ mod test {\n         let mut s = ZeroReader;\n         let mut buf = vec![1, 2, 3];\n         assert_eq!(s.read(&mut buf), Ok(3));\n-        assert_eq!(vec![0, 0, 0], buf);\n+        assert_eq!([0, 0, 0], buf);\n     }\n \n     #[test]\n@@ -373,24 +373,24 @@ mod test {\n         let rs = vec!(MemReader::new(vec!(0, 1)), MemReader::new(vec!()),\n                       MemReader::new(vec!(2, 3)));\n         let mut r = ChainedReader::new(rs.into_iter());\n-        assert_eq!(vec!(0, 1, 2, 3), r.read_to_end().unwrap());\n+        assert_eq!([0, 1, 2, 3], r.read_to_end().unwrap());\n     }\n \n     #[test]\n     fn test_tee_reader() {\n         let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n                                    Vec::new());\n-        assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n+        assert_eq!([0, 1, 2], r.read_to_end().unwrap());\n         let (_, w) = r.into_inner();\n-        assert_eq!(vec!(0, 1, 2), w);\n+        assert_eq!([0, 1, 2], w);\n     }\n \n     #[test]\n     fn test_copy() {\n         let mut r = MemReader::new(vec!(0, 1, 2, 3, 4));\n         let mut w = Vec::new();\n         copy(&mut r, &mut w).unwrap();\n-        assert_eq!(vec!(0, 1, 2, 3, 4), w);\n+        assert_eq!([0, 1, 2, 3, 4], w);\n     }\n \n     #[test]"}, {"sha": "fb9d6fef1faa7e0071343937f6aad0eea519eba4", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -1202,11 +1202,11 @@ mod tests {\n             string.code_points().map(|c| c.to_char()).collect::<Vec<_>>()\n         }\n         let mut string = Wtf8Buf::from_str(\"\u00e9 \");\n-        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' ')]);\n+        assert_eq!(cp(&string), [Some('\u00e9'), Some(' ')]);\n         string.push(c(0xD83D));\n-        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' '), None]);\n+        assert_eq!(cp(&string), [Some('\u00e9'), Some(' '), None]);\n         string.push(c(0xDCA9));\n-        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' '), Some('\ud83d\udca9')]);\n+        assert_eq!(cp(&string), [Some('\u00e9'), Some(' '), Some('\ud83d\udca9')]);\n     }\n \n     #[test]"}, {"sha": "91bfe6f32dc6c46ecd0574f8f3438983434cc9ae", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -2028,7 +2028,7 @@ foo_module!();\n         let renamed_crate = renamer.fold_crate(the_crate);\n         let idents = crate_idents(&renamed_crate);\n         let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n-        assert_eq!(resolved,vec!(f_ident.name,Name(16),int_ident.name,Name(16),Name(16),Name(16)));\n+        assert_eq!(resolved, [f_ident.name,Name(16),int_ident.name,Name(16),Name(16),Name(16)]);\n     }\n \n     // test the PatIdentRenamer; only PatIdents get renamed\n@@ -2044,8 +2044,6 @@ foo_module!();\n         let idents = crate_idents(&renamed_crate);\n         let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n         let x_name = x_ident.name;\n-        assert_eq!(resolved,vec!(f_ident.name,Name(16),int_ident.name,Name(16),x_name,x_name));\n+        assert_eq!(resolved, [f_ident.name,Name(16),int_ident.name,Name(16),x_name,x_name]);\n     }\n-\n-\n }"}, {"sha": "72431d8e6aa2c317ccd23aa9449193f01445c344", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -288,19 +288,19 @@ mod tests {\n     fn xorpush_test () {\n         let mut s = Vec::new();\n         xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), vec!(14));\n+        assert_eq!(s.clone(), [14]);\n         xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), Vec::new());\n+        assert_eq!(s.clone(), []);\n         xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), vec!(14));\n+        assert_eq!(s.clone(), [14]);\n         xor_push(&mut s, 15);\n-        assert_eq!(s.clone(), vec!(14, 15));\n+        assert_eq!(s.clone(), [14, 15]);\n         xor_push(&mut s, 16);\n-        assert_eq!(s.clone(), vec!(14, 15, 16));\n+        assert_eq!(s.clone(), [14, 15, 16]);\n         xor_push(&mut s, 16);\n-        assert_eq!(s.clone(), vec!(14, 15));\n+        assert_eq!(s.clone(), [14, 15]);\n         xor_push(&mut s, 15);\n-        assert_eq!(s.clone(), vec!(14));\n+        assert_eq!(s.clone(), [14]);\n     }\n \n     fn id(n: u32, s: SyntaxContext) -> Ident {\n@@ -389,29 +389,29 @@ mod tests {\n         assert_eq!(marksof_internal (EMPTY_CTXT,stopname,&t),Vec::new());\n         // FIXME #5074: ANF'd to dodge nested calls\n         { let ans = unfold_marks(vec!(4,98),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans,stopname,&t),vec!(4,98));}\n+         assert_eq! (marksof_internal (ans,stopname,&t), [4, 98]);}\n         // does xoring work?\n         { let ans = unfold_marks(vec!(5,5,16),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans,stopname,&t), vec!(16));}\n+         assert_eq! (marksof_internal (ans,stopname,&t), [16]);}\n         // does nested xoring work?\n         { let ans = unfold_marks(vec!(5,10,10,5,16),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname,&t), vec!(16));}\n+         assert_eq! (marksof_internal (ans, stopname,&t), [16]);}\n         // rename where stop doesn't match:\n         { let chain = vec!(M(9),\n                         R(id(name1.usize() as u32,\n                              apply_mark_internal (4, EMPTY_CTXT,&mut t)),\n                           Name(100101102)),\n                         M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname, &t), vec!(9,14));}\n+         assert_eq! (marksof_internal (ans, stopname, &t), [9, 14]);}\n         // rename where stop does match\n         { let name1sc = apply_mark_internal(4, EMPTY_CTXT, &mut t);\n          let chain = vec!(M(9),\n                        R(id(name1.usize() as u32, name1sc),\n                          stopname),\n                        M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname, &t), vec!(9)); }\n+         assert_eq! (marksof_internal (ans, stopname, &t), [9]); }\n     }\n \n "}, {"sha": "90df23882a1d4bf53c790a36ed40dae5ac899696", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -229,10 +229,10 @@ mod test {\n         assert_eq!(Vec::new(), v);\n \n         let v = SmallVector::one(1);\n-        assert_eq!(vec![1], v.into_iter().collect::<Vec<_>>());\n+        assert_eq!([1], v.into_iter().collect::<Vec<_>>());\n \n         let v = SmallVector::many(vec![1, 2, 3]);\n-        assert_eq!(vec!(1, 2, 3), v.into_iter().collect::<Vec<_>>());\n+        assert_eq!([1, 2, 3], v.into_iter().collect::<Vec<_>>());\n     }\n \n     #[test]"}, {"sha": "112525fcce96efe2a1762a6555f4ddee0a80daa5", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -652,15 +652,15 @@ mod test {\n             let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.err().unwrap());\n-            assert_eq!(res.unwrap(), vec!(b'0' + bs[0]));\n+            assert_eq!(res.unwrap(), [b'0' + bs[0]]);\n             let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.err().unwrap());\n-            assert_eq!(res.unwrap(), vec!(b'0' + bs[1]));\n+            assert_eq!(res.unwrap(), [b'0' + bs[1]]);\n             let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.err().unwrap());\n-            assert_eq!(res.unwrap(), vec!(b'0' + bs[2]));\n+            assert_eq!(res.unwrap(), [b'0' + bs[2]]);\n         }\n     }\n "}, {"sha": "d2e9bc2efe7279c10a0a00d7c25b6b1522aea5d1", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -23,5 +23,5 @@ pub fn main() {\n     let mut v = vec!(1);\n     v.push_val(2);\n     v.push_val(3);\n-    assert_eq!(v, vec!(1, 2, 3));\n+    assert_eq!(v, [1, 2, 3]);\n }"}, {"sha": "2473b4b674e5784a1fcf94cd65253014952ac748", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -22,5 +22,5 @@ fn bar(v: &mut [uint]) {\n pub fn main() {\n     let mut the_vec = vec!(1, 2, 3, 100);\n     bar(&mut the_vec);\n-    assert_eq!(the_vec, vec!(100, 3, 2, 1));\n+    assert_eq!(the_vec, [100, 3, 2, 1]);\n }"}, {"sha": "ea09bb3904de6b950f027f95b9094bd885ed66ef", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -18,5 +18,5 @@ fn bar(v: &mut [uint]) {\n pub fn main() {\n     let mut the_vec = vec!(1, 2, 3, 100);\n     bar(&mut the_vec);\n-    assert_eq!(the_vec, vec!(100, 3, 2, 1));\n+    assert_eq!(the_vec, [100, 3, 2, 1]);\n }"}, {"sha": "010f54dd55934ea53c425066dd4bb67dde200c85", "filename": "src/test/run-pass/generic-static-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -24,5 +24,5 @@ impl<T> vec_utils<T> for Vec<T> {\n }\n \n pub fn main() {\n-    assert_eq!(vec_utils::map_(&vec!(1,2,3), |&x| x+1), vec!(2,3,4));\n+    assert_eq!(vec_utils::map_(&vec!(1,2,3), |&x| x+1), [2,3,4]);\n }"}, {"sha": "0d563f1a714c350cecbf0f18523c9a2c7fa993ad", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -44,11 +44,11 @@ fn transform(x: Option<int>) -> Option<String> {\n pub fn main() {\n     assert_eq!(transform(Some(10)), Some(\"11\".to_string()));\n     assert_eq!(transform(None), None);\n-    assert!((vec!(\"hi\".to_string()))\n+    assert_eq!((vec!(\"hi\".to_string()))\n         .bind(|x| vec!(x.clone(), format!(\"{}!\", x)) )\n-        .bind(|x| vec!(x.clone(), format!(\"{}?\", x)) ) ==\n-        vec!(\"hi\".to_string(),\n-             \"hi?\".to_string(),\n-             \"hi!\".to_string(),\n-             \"hi!?\".to_string()));\n+        .bind(|x| vec!(x.clone(), format!(\"{}?\", x)) ),\n+        [\"hi\".to_string(),\n+         \"hi?\".to_string(),\n+         \"hi!\".to_string(),\n+         \"hi!?\".to_string()]);\n }"}, {"sha": "0dedf621a4f2887f0f6205142239e505e9e638bf", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -44,9 +44,9 @@ fn bar<U:to_str,T:map<U>>(x: T) -> Vec<String> {\n }\n \n pub fn main() {\n-    assert_eq!(foo(vec!(1)), vec!(\"hi\".to_string()));\n-    assert_eq!(bar::<int, Vec<int> >(vec!(4, 5)), vec!(\"4\".to_string(), \"5\".to_string()));\n+    assert_eq!(foo(vec!(1)), [\"hi\".to_string()]);\n+    assert_eq!(bar::<int, Vec<int> >(vec!(4, 5)), [\"4\".to_string(), \"5\".to_string()]);\n     assert_eq!(bar::<String, Vec<String> >(vec!(\"x\".to_string(), \"y\".to_string())),\n-               vec!(\"x\".to_string(), \"y\".to_string()));\n-    assert_eq!(bar::<(), Vec<()>>(vec!(())), vec!(\"()\".to_string()));\n+               [\"x\".to_string(), \"y\".to_string()]);\n+    assert_eq!(bar::<(), Vec<()>>(vec!(())), [\"()\".to_string()]);\n }"}, {"sha": "1401fe7470b0a1d71f0772e2d9217414625cdbde", "filename": "src/test/run-pass/unboxed-closures-infer-upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2807a1ce0255ce98415ebe6f65eb589d0f2f894b/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-upvar.rs?ref=2807a1ce0255ce98415ebe6f65eb589d0f2f894b", "patch": "@@ -18,5 +18,5 @@ fn f<F: FnMut()>(mut f: F) {\n fn main() {\n     let mut v: Vec<_> = vec![];\n     f(|| v.push(0));\n-    assert_eq!(v, vec![0]);\n+    assert_eq!(v, [0]);\n }"}]}