{"sha": "9ad6e263c9eec118a37cdbd5e182afaaad42840a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZDZlMjYzYzllZWMxMThhMzdjZGJkNWUxODJhZmFhYWQ0Mjg0MGE=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-02-17T16:02:22Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-02-17T16:47:26Z"}, "message": "Fix match_same_arms with SpanlessEq changes", "tree": {"sha": "70cbe0e2aeafac757f63552ecd0f16284ae7c614", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70cbe0e2aeafac757f63552ecd0f16284ae7c614"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ad6e263c9eec118a37cdbd5e182afaaad42840a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad6e263c9eec118a37cdbd5e182afaaad42840a", "html_url": "https://github.com/rust-lang/rust/commit/9ad6e263c9eec118a37cdbd5e182afaaad42840a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ad6e263c9eec118a37cdbd5e182afaaad42840a/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "742922a41a07653ec85b81a3be2c5788707e10d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/742922a41a07653ec85b81a3be2c5788707e10d9", "html_url": "https://github.com/rust-lang/rust/commit/742922a41a07653ec85b81a3be2c5788707e10d9"}], "stats": {"total": 113, "additions": 50, "deletions": 63}, "files": [{"sha": "efc8b13942507dc408df040a4d281aae391d7268", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 50, "deletions": 63, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9ad6e263c9eec118a37cdbd5e182afaaad42840a/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad6e263c9eec118a37cdbd5e182afaaad42840a/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=9ad6e263c9eec118a37cdbd5e182afaaad42840a", "patch": "@@ -3,19 +3,19 @@ use crate::utils::sugg::Sugg;\n use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n     expr_block, get_parent_expr, implements_trait, in_macro, indent_of, is_allowed, is_expn_of, is_refutable,\n-    is_type_diagnostic_item, is_wild, match_qpath, match_type, meets_msrv, multispan_sugg, path_to_local_id,\n-    peel_hir_pat_refs, peel_mid_ty_refs, peel_n_hir_expr_refs, remove_blocks, snippet, snippet_block, snippet_opt,\n-    snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n-    strip_pat_refs,\n+    is_type_diagnostic_item, is_wild, match_qpath, match_type, meets_msrv, multispan_sugg, path_to_local,\n+    path_to_local_id, peel_hir_pat_refs, peel_mid_ty_refs, peel_n_hir_expr_refs, remove_blocks, snippet, snippet_block,\n+    snippet_opt, snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n+    span_lint_and_then, strip_pat_refs,\n };\n use crate::utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::{\n-    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, Local, MatchSource, Mutability, Node, Pat,\n+    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource, Mutability, Node, Pat,\n     PatKind, QPath, RangeEnd,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -24,7 +24,7 @@ use rustc_middle::ty::{self, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::{sym, Symbol};\n+use rustc_span::sym;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n use std::collections::Bound;\n@@ -1873,13 +1873,6 @@ fn test_overlapping() {\n \n /// Implementation of `MATCH_SAME_ARMS`.\n fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    fn same_bindings<'tcx>(lhs: &FxHashMap<Symbol, Ty<'tcx>>, rhs: &FxHashMap<Symbol, Ty<'tcx>>) -> bool {\n-        lhs.len() == rhs.len()\n-            && lhs\n-                .iter()\n-                .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| TyS::same_type(l_ty, r_ty)))\n-    }\n-\n     if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n         let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n             let mut h = SpanlessHash::new(cx);\n@@ -1891,12 +1884,38 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n             let min_index = usize::min(lindex, rindex);\n             let max_index = usize::max(lindex, rindex);\n \n+            let mut local_map: FxHashMap<HirId, HirId> = FxHashMap::default();\n+            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+                if_chain! {\n+                    if let Some(a_id) = path_to_local(a);\n+                    if let Some(b_id) = path_to_local(b);\n+                    let entry = match local_map.entry(a_id) {\n+                        Entry::Vacant(entry) => entry,\n+                        // check if using the same bindings as before\n+                        Entry::Occupied(entry) => return *entry.get() == b_id,\n+                    };\n+                    // the names technically don't have to match; this makes the lint more conservative\n+                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n+                    if TyS::same_type(cx.typeck_results().expr_ty(a), cx.typeck_results().expr_ty(b));\n+                    if pat_contains_local(lhs.pat, a_id);\n+                    if pat_contains_local(rhs.pat, b_id);\n+                    then {\n+                        entry.insert(b_id);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+            };\n             // Arms with a guard are ignored, those can\u2019t always be merged together\n             // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none()) &&\n-                SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n-                // all patterns should have the same bindings\n-                same_bindings(&bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n+            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n+                && SpanlessEq::new(cx)\n+                    .expr_fallback(eq_fallback)\n+                    .eq_expr(&lhs.body, &rhs.body)\n+                // these checks could be removed to allow unused bindings\n+                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n         };\n \n         let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n@@ -1939,50 +1958,18 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n     }\n }\n \n-/// Returns the list of bindings in a pattern.\n-fn bindings<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n-    fn bindings_impl<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n-        match pat.kind {\n-            PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n-            PatKind::TupleStruct(_, pats, _) => {\n-                for pat in pats {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Binding(.., ident, ref as_pat) => {\n-                if let Entry::Vacant(v) = map.entry(ident.name) {\n-                    v.insert(cx.typeck_results().pat_ty(pat));\n-                }\n-                if let Some(ref as_pat) = *as_pat {\n-                    bindings_impl(cx, as_pat, map);\n-                }\n-            },\n-            PatKind::Or(fields) | PatKind::Tuple(fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Struct(_, fields, _) => {\n-                for pat in fields {\n-                    bindings_impl(cx, &pat.pat, map);\n-                }\n-            },\n-            PatKind::Slice(lhs, ref mid, rhs) => {\n-                for pat in lhs {\n-                    bindings_impl(cx, pat, map);\n-                }\n-                if let Some(ref mid) = *mid {\n-                    bindings_impl(cx, mid, map);\n-                }\n-                for pat in rhs {\n-                    bindings_impl(cx, pat, map);\n-                }\n-            },\n-            PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild | PatKind::Path(..) => (),\n-        }\n-    }\n-\n-    let mut result = FxHashMap::default();\n-    bindings_impl(cx, pat, &mut result);\n+fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n+    let mut result = false;\n+    pat.walk_short(|p| {\n+        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n+        !result\n+    });\n     result\n }\n+\n+/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n+fn bindings_eq(pat: &Pat<'_>, mut ids: FxHashSet<HirId>) -> bool {\n+    let mut result = true;\n+    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n+    result && ids.is_empty()\n+}"}]}