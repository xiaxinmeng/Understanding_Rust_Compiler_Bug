{"sha": "85b155f6f1941be159b5a2790b5396fece101f64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YjE1NWY2ZjE5NDFiZTE1OWI1YTI3OTBiNTM5NmZlY2UxMDFmNjQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-09T18:26:15Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-11T17:58:23Z"}, "message": "trans: Don't try to place declarations during codegen unit partitioning.", "tree": {"sha": "72055a15acd858cbd121d69c918c4287045b2b79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72055a15acd858cbd121d69c918c4287045b2b79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85b155f6f1941be159b5a2790b5396fece101f64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85b155f6f1941be159b5a2790b5396fece101f64", "html_url": "https://github.com/rust-lang/rust/commit/85b155f6f1941be159b5a2790b5396fece101f64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85b155f6f1941be159b5a2790b5396fece101f64/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3f19cb0b36b24b2252b9334b9511a4087cabf85", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3f19cb0b36b24b2252b9334b9511a4087cabf85", "html_url": "https://github.com/rust-lang/rust/commit/e3f19cb0b36b24b2252b9334b9511a4087cabf85"}], "stats": {"total": 214, "additions": 75, "deletions": 139}, "files": [{"sha": "65c3aa12ba6c895b61b09213ed4a9bb6d124f215", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/85b155f6f1941be159b5a2790b5396fece101f64/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b155f6f1941be159b5a2790b5396fece101f64/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=85b155f6f1941be159b5a2790b5396fece101f64", "patch": "@@ -80,7 +80,7 @@ use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n-use partitioning::{self, PartitioningStrategy, InstantiationMode, CodegenUnit};\n+use partitioning::{self, PartitioningStrategy, CodegenUnit};\n use symbol_names_test;\n use trans_item::TransItem;\n use tvec;\n@@ -2942,8 +2942,8 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         None => TransItemCollectionMode::Lazy\n     };\n \n-    let (items, reference_map) = time(time_passes, \"translation item collection\", || {\n-        collector::collect_crate_translation_items(scx, collection_mode)\n+    let (items, inlining_map) = time(time_passes, \"translation item collection\", || {\n+        collector::collect_crate_translation_items(&scx, collection_mode)\n     });\n \n     let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n@@ -2956,7 +2956,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         partitioning::partition(scx.tcx(),\n                                 items.iter().cloned(),\n                                 strategy,\n-                                &reference_map)\n+                                &inlining_map)\n     });\n \n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n@@ -2984,18 +2984,17 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                     output.push_str(&cgu_name[..]);\n \n                     let linkage_abbrev = match linkage {\n-                        InstantiationMode::Def(llvm::ExternalLinkage) => \"External\",\n-                        InstantiationMode::Def(llvm::AvailableExternallyLinkage) => \"Available\",\n-                        InstantiationMode::Def(llvm::LinkOnceAnyLinkage) => \"OnceAny\",\n-                        InstantiationMode::Def(llvm::LinkOnceODRLinkage) => \"OnceODR\",\n-                        InstantiationMode::Def(llvm::WeakAnyLinkage) => \"WeakAny\",\n-                        InstantiationMode::Def(llvm::WeakODRLinkage) => \"WeakODR\",\n-                        InstantiationMode::Def(llvm::AppendingLinkage) => \"Appending\",\n-                        InstantiationMode::Def(llvm::InternalLinkage) => \"Internal\",\n-                        InstantiationMode::Def(llvm::PrivateLinkage) => \"Private\",\n-                        InstantiationMode::Def(llvm::ExternalWeakLinkage) => \"ExternalWeak\",\n-                        InstantiationMode::Def(llvm::CommonLinkage) => \"Common\",\n-                        InstantiationMode::Decl => \"Declaration\",\n+                        llvm::ExternalLinkage => \"External\",\n+                        llvm::AvailableExternallyLinkage => \"Available\",\n+                        llvm::LinkOnceAnyLinkage => \"OnceAny\",\n+                        llvm::LinkOnceODRLinkage => \"OnceODR\",\n+                        llvm::WeakAnyLinkage => \"WeakAny\",\n+                        llvm::WeakODRLinkage => \"WeakODR\",\n+                        llvm::AppendingLinkage => \"Appending\",\n+                        llvm::InternalLinkage => \"Internal\",\n+                        llvm::PrivateLinkage => \"Private\",\n+                        llvm::ExternalWeakLinkage => \"ExternalWeak\",\n+                        llvm::CommonLinkage => \"Common\",\n                     };\n \n                     output.push_str(\"[\");"}, {"sha": "0614c29aaed0cffa78a985d03787425b6841dce7", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 34, "deletions": 54, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/85b155f6f1941be159b5a2790b5396fece101f64/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b155f6f1941be159b5a2790b5396fece101f64/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=85b155f6f1941be159b5a2790b5396fece101f64", "patch": "@@ -188,8 +188,6 @@\n //! this is not implemented however: a translation item will be produced\n //! regardless of whether it is actually needed or not.\n \n-use rustc_data_structures::bitvec::BitVector;\n-\n use rustc::hir;\n use rustc::hir::intravisit as hir_visit;\n \n@@ -226,42 +224,33 @@ pub enum TransItemCollectionMode {\n \n /// Maps every translation item to all translation items it references in its\n /// body.\n-pub struct ReferenceMap<'tcx> {\n-    // Maps a source translation item to a range of target translation items.\n+pub struct InliningMap<'tcx> {\n+    // Maps a source translation item to a range of target translation items\n+    // that are potentially inlined by LLVM into the source.\n     // The two numbers in the tuple are the start (inclusive) and\n-    // end index (exclusive) within the `targets` and the `inlined` vecs.\n+    // end index (exclusive) within the `targets` vecs.\n     index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n     targets: Vec<TransItem<'tcx>>,\n-    inlined: BitVector\n }\n \n-impl<'tcx> ReferenceMap<'tcx> {\n+impl<'tcx> InliningMap<'tcx> {\n \n-    fn new() -> ReferenceMap<'tcx> {\n-        ReferenceMap {\n+    fn new() -> InliningMap<'tcx> {\n+        InliningMap {\n             index: FnvHashMap(),\n             targets: Vec::new(),\n-            inlined: BitVector::new(64 * 256),\n         }\n     }\n \n-    fn record_references<I>(&mut self, source: TransItem<'tcx>, targets: I)\n-        where I: Iterator<Item=(TransItem<'tcx>, bool)>\n+    fn record_inlining_canditates<I>(&mut self,\n+                                     source: TransItem<'tcx>,\n+                                     targets: I)\n+        where I: Iterator<Item=TransItem<'tcx>>\n     {\n         assert!(!self.index.contains_key(&source));\n \n         let start_index = self.targets.len();\n-\n-        for (target, inlined) in targets {\n-            let index = self.targets.len();\n-            self.targets.push(target);\n-            self.inlined.grow(index + 1);\n-\n-            if inlined {\n-                self.inlined.insert(index);\n-            }\n-        }\n-\n+        self.targets.extend(targets);\n         let end_index = self.targets.len();\n         self.index.insert(source, (start_index, end_index));\n     }\n@@ -272,28 +261,17 @@ impl<'tcx> ReferenceMap<'tcx> {\n         where F: FnMut(TransItem<'tcx>) {\n         if let Some(&(start_index, end_index)) = self.index.get(&source)\n         {\n-            for index in start_index .. end_index {\n-                if self.inlined.contains(index) {\n-                    f(self.targets[index])\n-                }\n+            for candidate in &self.targets[start_index .. end_index] {\n+                f(*candidate)\n             }\n         }\n     }\n-\n-    pub fn get_direct_references_from(&self, source: TransItem<'tcx>) -> &[TransItem<'tcx>]\n-    {\n-        if let Some(&(start_index, end_index)) = self.index.get(&source) {\n-            &self.targets[start_index .. end_index]\n-        } else {\n-            &self.targets[0 .. 0]\n-        }\n-    }\n }\n \n pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FnvHashSet<TransItem<'tcx>>,\n-                                                     ReferenceMap<'tcx>) {\n+                                                     InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     scx.tcx().dep_graph.with_ignore(|| {\n@@ -302,17 +280,17 @@ pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FnvHashSet();\n         let mut recursion_depths = DefIdMap();\n-        let mut reference_map = ReferenceMap::new();\n+        let mut inlining_map = InliningMap::new();\n \n         for root in roots {\n             collect_items_rec(scx,\n                               root,\n                               &mut visited,\n                               &mut recursion_depths,\n-                              &mut reference_map);\n+                              &mut inlining_map);\n         }\n \n-        (visited, reference_map)\n+        (visited, inlining_map)\n     })\n }\n \n@@ -343,7 +321,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FnvHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n-                                   reference_map: &mut ReferenceMap<'tcx>) {\n+                                   inlining_map: &mut InliningMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n         // We've been here already, no need to search again.\n         return;\n@@ -390,10 +368,10 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n     }\n \n-    record_references(scx.tcx(), starting_point, &neighbors[..], reference_map);\n+    record_inlining_canditates(scx.tcx(), starting_point, &neighbors[..], inlining_map);\n \n     for neighbour in neighbors {\n-        collect_items_rec(scx, neighbour, visited, recursion_depths, reference_map);\n+        collect_items_rec(scx, neighbour, visited, recursion_depths, inlining_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n@@ -403,17 +381,19 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n }\n \n-fn record_references<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               caller: TransItem<'tcx>,\n-                               callees: &[TransItem<'tcx>],\n-                               reference_map: &mut ReferenceMap<'tcx>) {\n-    let iter = callees.into_iter()\n-                      .map(|callee| {\n-                        let is_inlining_candidate = callee.is_from_extern_crate() ||\n-                                                    callee.requests_inline(tcx);\n-                        (*callee, is_inlining_candidate)\n-                      });\n-    reference_map.record_references(caller, iter);\n+fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        caller: TransItem<'tcx>,\n+                                        callees: &[TransItem<'tcx>],\n+                                        inlining_map: &mut InliningMap<'tcx>) {\n+    let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n+        trans_item.is_from_extern_crate() || trans_item.requests_inline(tcx)\n+    };\n+\n+    let inlining_candidates = callees.into_iter()\n+                                     .map(|x| *x)\n+                                     .filter(is_inlining_candidate);\n+\n+    inlining_map.record_inlining_canditates(caller, inlining_candidates);\n }\n \n fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "098ba759247be44d8a4b128cc290921f7e067994", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 15, "deletions": 58, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/85b155f6f1941be159b5a2790b5396fece101f64/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b155f6f1941be159b5a2790b5396fece101f64/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=85b155f6f1941be159b5a2790b5396fece101f64", "patch": "@@ -116,7 +116,7 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use collector::ReferenceMap;\n+use collector::InliningMap;\n use llvm;\n use monomorphize;\n use rustc::hir::def_id::DefId;\n@@ -127,20 +127,9 @@ use syntax::parse::token::{self, InternedString};\n use trans_item::TransItem;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n-#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n-pub enum InstantiationMode {\n-    /// This variant indicates that a translation item should be placed in some\n-    /// codegen unit as a definition and with the given linkage.\n-    Def(llvm::Linkage),\n-\n-    /// This variant indicates that only a declaration of some translation item\n-    /// should be placed in a given codegen unit.\n-    Decl\n-}\n-\n pub struct CodegenUnit<'tcx> {\n     pub name: InternedString,\n-    pub items: FnvHashMap<TransItem<'tcx>, InstantiationMode>,\n+    pub items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n }\n \n pub enum PartitioningStrategy {\n@@ -157,7 +146,7 @@ const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n-                              reference_map: &ReferenceMap<'tcx>)\n+                              inlining_map: &InliningMap<'tcx>)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n@@ -177,13 +166,8 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // translation items can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with #[inline].\n     let post_inlining = place_inlined_translation_items(initial_partitioning,\n-                                                        reference_map);\n-\n-    // Now we know all *definitions* within all codegen units, thus we can\n-    // easily determine which declarations need to be placed within each one.\n-    let post_declarations = place_declarations(post_inlining, reference_map);\n-\n-    post_declarations.0\n+                                                        inlining_map);\n+    post_inlining.0\n }\n \n struct PreInliningPartitioning<'tcx> {\n@@ -192,7 +176,6 @@ struct PreInliningPartitioning<'tcx> {\n }\n \n struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n-struct PostDeclarationsPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n \n fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              trans_items: I)\n@@ -240,8 +223,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n             };\n \n-            codegen_unit.items.insert(trans_item,\n-                                      InstantiationMode::Def(linkage));\n+            codegen_unit.items.insert(trans_item, linkage);\n             roots.insert(trans_item);\n         }\n     }\n@@ -295,15 +277,15 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n }\n \n fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartitioning<'tcx>,\n-                                         reference_map: &ReferenceMap<'tcx>)\n+                                         inlining_map: &InliningMap<'tcx>)\n                                          -> PostInliningPartitioning<'tcx> {\n     let mut new_partitioning = Vec::new();\n \n     for codegen_unit in &initial_partitioning.codegen_units[..] {\n         // Collect all items that need to be available in this codegen unit\n         let mut reachable = FnvHashSet();\n         for root in codegen_unit.items.keys() {\n-            follow_inlining(*root, reference_map, &mut reachable);\n+            follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n         let mut new_codegen_unit = CodegenUnit {\n@@ -313,22 +295,22 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n \n         // Add all translation items that are not already there\n         for trans_item in reachable {\n-            if let Some(instantiation_mode) = codegen_unit.items.get(&trans_item) {\n+            if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n-                new_codegen_unit.items.insert(trans_item, *instantiation_mode);\n+                new_codegen_unit.items.insert(trans_item, *linkage);\n             } else {\n                 if initial_partitioning.roots.contains(&trans_item) {\n                     // This item will be instantiated in some other codegen unit,\n                     // so we just add it here with AvailableExternallyLinkage\n                     new_codegen_unit.items.insert(trans_item,\n-                        InstantiationMode::Def(llvm::AvailableExternallyLinkage));\n+                                                  llvm::AvailableExternallyLinkage);\n                 } else {\n                     // We can't be sure if this will also be instantiated\n                     // somewhere else, so we add an instance here with\n                     // LinkOnceODRLinkage. That way the item can be discarded if\n                     // it's not needed (inlined) after all.\n                     new_codegen_unit.items.insert(trans_item,\n-                        InstantiationMode::Def(llvm::LinkOnceODRLinkage));\n+                                                  llvm::LinkOnceODRLinkage);\n                 }\n             }\n         }\n@@ -339,43 +321,18 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n     return PostInliningPartitioning(new_partitioning);\n \n     fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n-                             reference_map: &ReferenceMap<'tcx>,\n+                             inlining_map: &InliningMap<'tcx>,\n                              visited: &mut FnvHashSet<TransItem<'tcx>>) {\n         if !visited.insert(trans_item) {\n             return;\n         }\n \n-        reference_map.with_inlining_candidates(trans_item, |target| {\n-            follow_inlining(target, reference_map, visited);\n+        inlining_map.with_inlining_candidates(trans_item, |target| {\n+            follow_inlining(target, inlining_map, visited);\n         });\n     }\n }\n \n-fn place_declarations<'tcx>(codegen_units: PostInliningPartitioning<'tcx>,\n-                            reference_map: &ReferenceMap<'tcx>)\n-                            -> PostDeclarationsPartitioning<'tcx> {\n-    let PostInliningPartitioning(mut codegen_units) = codegen_units;\n-\n-    for codegen_unit in codegen_units.iter_mut() {\n-        let mut declarations = FnvHashSet();\n-\n-        for (trans_item, _) in &codegen_unit.items {\n-            for referenced_item in reference_map.get_direct_references_from(*trans_item) {\n-                if !codegen_unit.items.contains_key(referenced_item) {\n-                    declarations.insert(*referenced_item);\n-                }\n-            }\n-        }\n-\n-        codegen_unit.items\n-                    .extend(declarations.iter()\n-                                        .map(|trans_item| (*trans_item,\n-                                                           InstantiationMode::Decl)));\n-    }\n-\n-    PostDeclarationsPartitioning(codegen_units)\n-}\n-\n fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  trans_item: TransItem<'tcx>)\n                                                  -> Option<DefId> {"}, {"sha": "04ebef645ec9836ec648b279ec1548f30128b070", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85b155f6f1941be159b5a2790b5396fece101f64/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b155f6f1941be159b5a2790b5396fece101f64/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=85b155f6f1941be159b5a2790b5396fece101f64", "patch": "@@ -23,7 +23,7 @@ struct Struct {\n }\n \n impl Drop for Struct {\n-    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR] local_drop_glue-mod1[Declaration]\n+    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR]\n     fn drop(&mut self) {}\n }\n "}, {"sha": "e38e676b95c617b9d4d18dd11346a9d70d91e324", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85b155f6f1941be159b5a2790b5396fece101f64/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b155f6f1941be159b5a2790b5396fece101f64/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=85b155f6f1941be159b5a2790b5396fece101f64", "patch": "@@ -19,10 +19,10 @@\n // Used in different modules/codegen units but always instantiated in the same\n // codegen unit.\n \n-//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR] local_generic[Declaration]\n-//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR] local_generic-mod1[Declaration]\n-//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR] local_generic-mod1-mod1[Declaration]\n-//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR] local_generic-mod2[Declaration]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR]\n pub fn generic<T>(x: T) -> T { x }\n \n //~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[WeakODR]"}, {"sha": "99dda0e38bad7aeb63ac64262a91136f9f4b1fcf", "filename": "src/test/codegen-units/partitioning/methods-are-with-self-type.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/85b155f6f1941be159b5a2790b5396fece101f64/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85b155f6f1941be159b5a2790b5396fece101f64/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs?ref=85b155f6f1941be159b5a2790b5396fece101f64", "patch": "@@ -61,19 +61,19 @@ mod type2 {\n //~ TRANS_ITEM fn methods_are_with_self_type::main[0]\n fn main()\n {\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR]\n     SomeGenericType(0u32, 0u64).method();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR]\n     SomeGenericType::associated_fn('c', \"&str\");\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n     type1::Struct.foo();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n     type2::Struct.foo();\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n     type1::Struct.default();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n     type2::Struct.default();\n }\n "}]}