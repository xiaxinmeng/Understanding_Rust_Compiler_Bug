{"sha": "f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0OTlkMzY1YWRhMDFhMjNiZDA0NmJhYzliMWJlZjdjY2RiOWZhOGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-30T22:04:00Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-02T22:16:07Z"}, "message": "libsyntax: Make the parser mutable", "tree": {"sha": "f8f22773382ac7774384f8ec58417f16e04f9041", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8f22773382ac7774384f8ec58417f16e04f9041"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "html_url": "https://github.com/rust-lang/rust/commit/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0df9b850ac1ed3abd0ff5abfbb716af83501dd5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0df9b850ac1ed3abd0ff5abfbb716af83501dd5a", "html_url": "https://github.com/rust-lang/rust/commit/0df9b850ac1ed3abd0ff5abfbb716af83501dd5a"}], "stats": {"total": 1005, "additions": 518, "deletions": 487}, "files": [{"sha": "d7d8360f1e8b674aa0b8f05a3954adf9938f00a5", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -39,9 +39,9 @@ fn next_state(s: State) -> Option<State> {\n \n pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                -> base::MacResult {\n-    let p = parse::new_parser_from_tts(cx.parse_sess(),\n-                                       cx.cfg(),\n-                                       tts.to_owned());\n+    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                           cx.cfg(),\n+                                           tts.to_owned());\n \n     let mut asm = @\"\";\n     let mut asm_str_style = None;"}, {"sha": "a4f447874ffbec7465bd3ac19ab651b31d083935", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -442,9 +442,9 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n pub fn get_exprs_from_tts(cx: &ExtCtxt,\n                           sp: Span,\n                           tts: &[ast::token_tree]) -> ~[@ast::Expr] {\n-    let p = parse::new_parser_from_tts(cx.parse_sess(),\n-                                       cx.cfg(),\n-                                       tts.to_owned());\n+    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                           cx.cfg(),\n+                                           tts.to_owned());\n     let mut es = ~[];\n     while *p.token != token::EOF {\n         if es.len() != 0 && !p.eat(&token::COMMA) {"}, {"sha": "f58b5eb3a92fdf98771c27057fa6eddd331f2f2f", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -26,7 +26,9 @@ use parse::token;\n use parse::attr::parser_attr;\n \n pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n-    let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts.to_owned());\n+    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                           cx.cfg(),\n+                                           tts.to_owned());\n \n     let mut cfgs = ~[];\n     // parse `cfg!(meta_item, meta_item(x,y), meta_item=\"foo\", ...)`"}, {"sha": "2d4bdd3da23c13e8aef5284e58989cd8c790a87c", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -53,11 +53,11 @@ struct Context<'a> {\n impl<'a> Context<'a> {\n     /// Parses the arguments from the given list of tokens, returning None if\n     /// there's a parse error so we can continue parsing other format! expressions.\n-    fn parse_args(&mut self, sp: Span,\n-                  tts: &[ast::token_tree]) -> (@ast::Expr, Option<@ast::Expr>) {\n-        let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n-                                             self.ecx.cfg(),\n-                                             tts.to_owned());\n+    fn parse_args(&mut self, sp: Span, tts: &[ast::token_tree])\n+                  -> (@ast::Expr, Option<@ast::Expr>) {\n+        let mut p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n+                                                 self.ecx.cfg(),\n+                                                 tts.to_owned());\n         // Parse the leading function expression (maybe a block, maybe a path)\n         let extra = p.parse_expr();\n         if !p.eat(&token::COMMA) {"}, {"sha": "5021cf968f7aa6548c2d85c4db7bb9e15e8c3dc8", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -579,21 +579,17 @@ fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     ss\n }\n \n-fn expand_tts(cx: &ExtCtxt,\n-              sp: Span,\n-              tts: &[ast::token_tree]) -> (@ast::Expr, @ast::Expr) {\n-\n+fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+              -> (@ast::Expr, @ast::Expr) {\n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n     // it has to do with transition away from supporting old-style macros, so\n     // try removing it when enough of them are gone.\n \n-    let p = parse::new_parser_from_tts(\n-        cx.parse_sess(),\n-        cx.cfg(),\n-        tts.to_owned()\n-    );\n+    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                           cx.cfg(),\n+                                           tts.to_owned());\n     *p.quote_depth += 1u;\n \n     let cx_expr = p.parse_expr();"}, {"sha": "11e7c1c8499a08b3afe4d56002d302768358c0c2", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -81,9 +81,13 @@ pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     // The file will be added to the code map by the parser\n-    let p = parse::new_sub_parser_from_file(\n-        cx.parse_sess(), cx.cfg(),\n-        &res_rel_file(cx, sp, &Path::new(file)), sp);\n+    let mut p =\n+        parse::new_sub_parser_from_file(cx.parse_sess(),\n+                                        cx.cfg(),\n+                                        &res_rel_file(cx,\n+                                                      sp,\n+                                                      &Path::new(file)),\n+                                        sp);\n     base::MRExpr(p.parse_expr())\n }\n "}, {"sha": "34151377d7bdfb092b91f5d18d4325a13bda31fd", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -26,7 +26,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                                None,\n                                tt.to_owned());\n     let rdr = tt_rdr as @mut reader;\n-    let rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n+    let mut rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n     if rust_parser.is_keyword(keywords::True) {\n         cx.set_trace_macros(true);\n@@ -38,7 +38,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n \n     rust_parser.bump();\n \n-    let rust_parser = Parser(sess, cfg, rdr.dup());\n+    let mut rust_parser = Parser(sess, cfg, rdr.dup());\n     let result = rust_parser.parse_expr();\n     base::MRExpr(result)\n }"}, {"sha": "f2c695c6cd6513d023b5f8b87c84242abc3bf10c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -403,13 +403,13 @@ pub fn parse(\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n-                let rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n+                let mut rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n                 let mut ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {\n                   match_nonterminal(_, ref name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n-                        parse_nt(&rust_parser, ident_to_str(name))));\n+                        parse_nt(&mut rust_parser, ident_to_str(name))));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()\n@@ -426,7 +426,7 @@ pub fn parse(\n     }\n }\n \n-pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n+pub fn parse_nt(p: &mut Parser, name: &str) -> nonterminal {\n     match name {\n       \"item\" => match p.parse_item(~[]) {\n         Some(i) => token::nt_item(i),"}, {"sha": "365c48c7c8654de92d0657e430c67b17642567c8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -24,10 +24,11 @@ use parse::attr::parser_attr;\n use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_str};\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt, EOF};\n use print;\n+use std::cell::RefCell;\n use util::small_vector::SmallVector;\n \n struct ParserAnyMacro {\n-    parser: @Parser,\n+    parser: RefCell<Parser>,\n }\n \n impl ParserAnyMacro {\n@@ -38,28 +39,36 @@ impl ParserAnyMacro {\n     /// fail!(); } )` doesn't get picked up by .parse_expr(), but it's\n     /// allowed to be there.\n     fn ensure_complete_parse(&self, allow_semi: bool) {\n-        if allow_semi && *self.parser.token == SEMI {\n-            self.parser.bump()\n+        let mut parser = self.parser.borrow_mut();\n+        if allow_semi && *parser.get().token == SEMI {\n+            parser.get().bump()\n         }\n-        if *self.parser.token != EOF {\n-            let msg = format!(\"macro expansion ignores token `{}` and any following\",\n-                              self.parser.this_token_to_str());\n-            self.parser.span_err(*self.parser.span, msg);\n+        if *parser.get().token != EOF {\n+            let token_str = parser.get().this_token_to_str();\n+            let msg = format!(\"macro expansion ignores token `{}` and any \\\n+                               following\",\n+                              token_str);\n+            let span = *parser.get().span;\n+            parser.get().span_err(span, msg);\n         }\n     }\n }\n \n impl AnyMacro for ParserAnyMacro {\n     fn make_expr(&self) -> @ast::Expr {\n-        let ret = self.parser.parse_expr();\n+        let ret = {\n+            let mut parser = self.parser.borrow_mut();\n+            parser.get().parse_expr()\n+        };\n         self.ensure_complete_parse(true);\n         ret\n     }\n     fn make_items(&self) -> SmallVector<@ast::item> {\n         let mut ret = SmallVector::zero();\n         loop {\n-            let attrs = self.parser.parse_outer_attributes();\n-            match self.parser.parse_item(attrs) {\n+            let mut parser = self.parser.borrow_mut();\n+            let attrs = parser.get().parse_outer_attributes();\n+            match parser.get().parse_item(attrs) {\n                 Some(item) => ret.push(item),\n                 None => break\n             }\n@@ -68,8 +77,11 @@ impl AnyMacro for ParserAnyMacro {\n         ret\n     }\n     fn make_stmt(&self) -> @ast::Stmt {\n-        let attrs = self.parser.parse_outer_attributes();\n-        let ret = self.parser.parse_stmt(attrs);\n+        let ret = {\n+            let mut parser = self.parser.borrow_mut();\n+            let attrs = parser.get().parse_outer_attributes();\n+            parser.get().parse_stmt(attrs)\n+        };\n         self.ensure_complete_parse(true);\n         ret\n     }\n@@ -142,14 +154,14 @@ fn generic_extension(cx: &ExtCtxt,\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(s_d, Some(named_matches),\n                                            rhs);\n-                let p = @Parser(cx.parse_sess(),\n-                                cx.cfg(),\n-                                trncbr as @mut reader);\n+                let p = Parser(cx.parse_sess(),\n+                               cx.cfg(),\n+                               trncbr as @mut reader);\n \n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return MRAny(@ParserAnyMacro {\n-                    parser: p,\n+                    parser: RefCell::new(p),\n                 } as @AnyMacro)\n               }\n               failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {"}, {"sha": "ef2322939aad696cc27c018aadc538c1234b03d5", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -17,19 +17,18 @@ use parse::token::INTERPOLATED;\n \n // a parser that can parse attributes.\n pub trait parser_attr {\n-    fn parse_outer_attributes(&self) -> ~[ast::Attribute];\n-    fn parse_attribute(&self, permit_inner: bool) -> ast::Attribute;\n-    fn parse_inner_attrs_and_next(&self) ->\n-        (~[ast::Attribute], ~[ast::Attribute]);\n-    fn parse_meta_item(&self) -> @ast::MetaItem;\n-    fn parse_meta_seq(&self) -> ~[@ast::MetaItem];\n-    fn parse_optional_meta(&self) -> ~[@ast::MetaItem];\n+    fn parse_outer_attributes(&mut self) -> ~[ast::Attribute];\n+    fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n+    fn parse_inner_attrs_and_next(&mut self)\n+                                  -> (~[ast::Attribute], ~[ast::Attribute]);\n+    fn parse_meta_item(&mut self) -> @ast::MetaItem;\n+    fn parse_meta_seq(&mut self) -> ~[@ast::MetaItem];\n+    fn parse_optional_meta(&mut self) -> ~[@ast::MetaItem];\n }\n \n impl parser_attr for Parser {\n-\n     // Parse attributes that appear before an item\n-    fn parse_outer_attributes(&self) -> ~[ast::Attribute] {\n+    fn parse_outer_attributes(&mut self) -> ~[ast::Attribute] {\n         let mut attrs: ~[ast::Attribute] = ~[];\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\",\n@@ -66,7 +65,7 @@ impl parser_attr for Parser {\n     //\n     // if permit_inner is true, then a trailing `;` indicates an inner\n     // attribute\n-    fn parse_attribute(&self, permit_inner: bool) -> ast::Attribute {\n+    fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute {\n         debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n                permit_inner, self.token);\n         let (span, value) = match *self.token {\n@@ -85,8 +84,9 @@ impl parser_attr for Parser {\n                 (mk_sp(lo, hi), meta_item)\n             }\n             _ => {\n+                let token_str = self.this_token_to_str();\n                 self.fatal(format!(\"expected `\\\\#` but found `{}`\",\n-                                   self.this_token_to_str()));\n+                                   token_str));\n             }\n         };\n         let style = if permit_inner && *self.token == token::SEMI {\n@@ -115,7 +115,7 @@ impl parser_attr for Parser {\n     // matches inner_attrs* outer_attr?\n     // you can make the 'next' field an Option, but the result is going to be\n     // more useful as a vector.\n-    fn parse_inner_attrs_and_next(&self)\n+    fn parse_inner_attrs_and_next(&mut self)\n                                   -> (~[ast::Attribute], ~[ast::Attribute]) {\n         let mut inner_attrs: ~[ast::Attribute] = ~[];\n         let mut next_outer_attrs: ~[ast::Attribute] = ~[];\n@@ -154,9 +154,10 @@ impl parser_attr for Parser {\n     // matches meta_item = IDENT\n     // | IDENT = lit\n     // | IDENT meta_seq\n-    fn parse_meta_item(&self) -> @ast::MetaItem {\n+    fn parse_meta_item(&mut self) -> @ast::MetaItem {\n         let lo = self.span.lo;\n-        let name = self.id_to_str(self.parse_ident());\n+        let ident = self.parse_ident();\n+        let name = self.id_to_str(ident);\n         match *self.token {\n             token::EQ => {\n                 self.bump();\n@@ -187,14 +188,14 @@ impl parser_attr for Parser {\n     }\n \n     // matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&self) -> ~[@ast::MetaItem] {\n+    fn parse_meta_seq(&mut self) -> ~[@ast::MetaItem] {\n         self.parse_seq(&token::LPAREN,\n                        &token::RPAREN,\n                        seq_sep_trailing_disallowed(token::COMMA),\n                        |p| p.parse_meta_item()).node\n     }\n \n-    fn parse_optional_meta(&self) -> ~[@ast::MetaItem] {\n+    fn parse_optional_meta(&mut self) -> ~[@ast::MetaItem] {\n         match *self.token {\n             token::LPAREN => self.parse_meta_seq(),\n             _ => ~[]"}, {"sha": "1200c5db611adaabd5e2192643dd991ef5c67ed0", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -84,7 +84,7 @@ pub fn parse_crate_attrs_from_file(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> ~[ast::Attribute] {\n-    let parser = new_parser_from_file(sess, cfg, input);\n+    let mut parser = new_parser_from_file(sess, cfg, input);\n     let (inner, _) = parser.parse_inner_attrs_and_next();\n     return inner;\n }\n@@ -95,10 +95,10 @@ pub fn parse_crate_from_source_str(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> ast::Crate {\n-    let p = new_parser_from_source_str(sess,\n-                                       /*bad*/ cfg.clone(),\n-                                       name,\n-                                       source);\n+    let mut p = new_parser_from_source_str(sess,\n+                                           /*bad*/ cfg.clone(),\n+                                           name,\n+                                           source);\n     maybe_aborted(p.parse_crate_mod(),p)\n }\n \n@@ -108,10 +108,10 @@ pub fn parse_crate_attrs_from_source_str(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> ~[ast::Attribute] {\n-    let p = new_parser_from_source_str(sess,\n-                                       /*bad*/ cfg.clone(),\n-                                       name,\n-                                       source);\n+    let mut p = new_parser_from_source_str(sess,\n+                                           /*bad*/ cfg.clone(),\n+                                           name,\n+                                           source);\n     let (inner, _) = maybe_aborted(p.parse_inner_attrs_and_next(),p);\n     return inner;\n }\n@@ -122,12 +122,7 @@ pub fn parse_expr_from_source_str(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> @ast::Expr {\n-    let p = new_parser_from_source_str(\n-        sess,\n-        cfg,\n-        name,\n-        source\n-    );\n+    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_expr(), p)\n }\n \n@@ -138,12 +133,7 @@ pub fn parse_item_from_source_str(\n     attrs: ~[ast::Attribute],\n     sess: @mut ParseSess\n ) -> Option<@ast::item> {\n-    let p = new_parser_from_source_str(\n-        sess,\n-        cfg,\n-        name,\n-        source\n-    );\n+    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_item(attrs),p)\n }\n \n@@ -153,12 +143,7 @@ pub fn parse_meta_from_source_str(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> @ast::MetaItem {\n-    let p = new_parser_from_source_str(\n-        sess,\n-        cfg,\n-        name,\n-        source\n-    );\n+    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_meta_item(),p)\n }\n \n@@ -169,7 +154,7 @@ pub fn parse_stmt_from_source_str(\n     attrs: ~[ast::Attribute],\n     sess: @mut ParseSess\n ) -> @ast::Stmt {\n-    let p = new_parser_from_source_str(\n+    let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n         name,\n@@ -184,7 +169,7 @@ pub fn parse_tts_from_source_str(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> ~[ast::token_tree] {\n-    let p = new_parser_from_source_str(\n+    let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n         name,\n@@ -201,15 +186,15 @@ pub fn parse_tts_from_source_str(\n // consumed all of the input before returning the function's\n // result.\n pub fn parse_from_source_str<T>(\n-                             f: |&Parser| -> T,\n+                             f: |&mut Parser| -> T,\n                              name: @str,\n                              ss: codemap::FileSubstr,\n                              source: @str,\n                              cfg: ast::CrateConfig,\n                              sess: @mut ParseSess)\n                              -> T {\n-    let p = new_parser_from_source_substr(sess, cfg, name, ss, source);\n-    let r = f(&p);\n+    let mut p = new_parser_from_source_substr(sess, cfg, name, ss, source);\n+    let r = f(&mut p);\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n@@ -326,7 +311,7 @@ pub fn filemap_to_tts(sess: @mut ParseSess, filemap: @FileMap)\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = ~[];\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap);\n-    let p1 = Parser(sess, cfg, srdr as @mut reader);\n+    let mut p1 = Parser(sess, cfg, srdr as @mut reader);\n     p1.parse_all_token_trees()\n }\n \n@@ -339,7 +324,7 @@ pub fn tts_to_parser(sess: @mut ParseSess,\n }\n \n // abort if necessary\n-pub fn maybe_aborted<T>(result : T, p: Parser) -> T {\n+pub fn maybe_aborted<T>(result: T, mut p: Parser) -> T {\n     p.abort_if_errors();\n     result\n }"}, {"sha": "199f02028a260255277852cf78bb703956c032ff", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -57,23 +57,23 @@ impl to_bytes::IterBytes for ObsoleteSyntax {\n \n pub trait ParserObsoleteMethods {\n     /// Reports an obsolete syntax non-fatal error.\n-    fn obsolete(&self, sp: Span, kind: ObsoleteSyntax);\n+    fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax);\n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&self, sp: Span, kind: ObsoleteSyntax) -> @Expr;\n-    fn report(&self,\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> @Expr;\n+    fn report(&mut self,\n               sp: Span,\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n               desc: &str);\n-    fn token_is_obsolete_ident(&self, ident: &str, token: &Token) -> bool;\n-    fn is_obsolete_ident(&self, ident: &str) -> bool;\n-    fn eat_obsolete_ident(&self, ident: &str) -> bool;\n+    fn token_is_obsolete_ident(&mut self, ident: &str, token: &Token) -> bool;\n+    fn is_obsolete_ident(&mut self, ident: &str) -> bool;\n+    fn eat_obsolete_ident(&mut self, ident: &str) -> bool;\n }\n \n impl ParserObsoleteMethods for Parser {\n     /// Reports an obsolete syntax non-fatal error.\n-    fn obsolete(&self, sp: Span, kind: ObsoleteSyntax) {\n+    fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n             ObsoleteSwap => (\n                 \"swap\",\n@@ -158,12 +158,12 @@ impl ParserObsoleteMethods for Parser {\n \n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&self, sp: Span, kind: ObsoleteSyntax) -> @Expr {\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> @Expr {\n         self.obsolete(sp, kind);\n         self.mk_expr(sp.lo, sp.hi, ExprLit(@respan(sp, lit_nil)))\n     }\n \n-    fn report(&self,\n+    fn report(&mut self,\n               sp: Span,\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n@@ -176,8 +176,8 @@ impl ParserObsoleteMethods for Parser {\n         }\n     }\n \n-    fn token_is_obsolete_ident(&self, ident: &str, token: &Token)\n-                                   -> bool {\n+    fn token_is_obsolete_ident(&mut self, ident: &str, token: &Token)\n+                               -> bool {\n         match *token {\n             token::IDENT(sid, _) => {\n                 str::eq_slice(self.id_to_str(sid), ident)\n@@ -186,11 +186,11 @@ impl ParserObsoleteMethods for Parser {\n         }\n     }\n \n-    fn is_obsolete_ident(&self, ident: &str) -> bool {\n+    fn is_obsolete_ident(&mut self, ident: &str) -> bool {\n         self.token_is_obsolete_ident(ident, self.token)\n     }\n \n-    fn eat_obsolete_ident(&self, ident: &str) -> bool {\n+    fn eat_obsolete_ident(&mut self, ident: &str) -> bool {\n         if self.is_obsolete_ident(ident) {\n             self.bump();\n             true"}, {"sha": "2a4658854c3f884cf9ba47c90d0a756a7271a889", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 410, "deletions": 379, "changes": 789, "blob_url": "https://github.com/rust-lang/rust/blob/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f499d365ada01a23bd046bac9b1bef7ccdb9fa8c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f499d365ada01a23bd046bac9b1bef7ccdb9fa8c", "patch": "@@ -360,55 +360,47 @@ fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n \n impl Parser {\n     // convert a token to a string using self's reader\n-    pub fn token_to_str(&self, token: &token::Token) -> ~str {\n+    pub fn token_to_str(&mut self, token: &token::Token) -> ~str {\n         token::to_str(get_ident_interner(), token)\n     }\n \n     // convert the current token to a string using self's reader\n-    pub fn this_token_to_str(&self) -> ~str {\n+    pub fn this_token_to_str(&mut self) -> ~str {\n         self.token_to_str(self.token)\n     }\n \n-    pub fn unexpected_last(&self, t: &token::Token) -> ! {\n-        self.span_fatal(\n-            *self.last_span,\n-            format!(\n-                \"unexpected token: `{}`\",\n-                self.token_to_str(t)\n-            )\n-        );\n+    pub fn unexpected_last(&mut self, t: &token::Token) -> ! {\n+        let token_str = self.token_to_str(t);\n+        self.span_fatal(*self.last_span, format!(\"unexpected token: `{}`\",\n+                                                 token_str));\n     }\n \n-    pub fn unexpected(&self) -> ! {\n-        self.fatal(\n-            format!(\n-                \"unexpected token: `{}`\",\n-                self.this_token_to_str()\n-            )\n-        );\n+    pub fn unexpected(&mut self) -> ! {\n+        let this_token = self.this_token_to_str();\n+        self.fatal(format!(\"unexpected token: `{}`\", this_token));\n     }\n \n     // expect and consume the token t. Signal an error if\n     // the next token is not t.\n-    pub fn expect(&self, t: &token::Token) {\n+    pub fn expect(&mut self, t: &token::Token) {\n         if *self.token == *t {\n             self.bump();\n         } else {\n-            self.fatal(\n-                format!(\n-                    \"expected `{}` but found `{}`\",\n-                    self.token_to_str(t),\n-                    self.this_token_to_str()\n-                )\n-            )\n+            let token_str = self.token_to_str(t);\n+            let this_token_str = self.this_token_to_str();\n+            self.fatal(format!(\"expected `{}` but found `{}`\",\n+                               token_str,\n+                               this_token_str))\n         }\n     }\n \n     // Expect next token to be edible or inedible token.  If edible,\n     // then consume it; if inedible, then return without consuming\n     // anything.  Signal a fatal error if next token is unexpected.\n-    pub fn expect_one_of(&self, edible: &[token::Token], inedible: &[token::Token]) {\n-        fn tokens_to_str(p:&Parser, tokens: &[token::Token]) -> ~str {\n+    pub fn expect_one_of(&mut self,\n+                         edible: &[token::Token],\n+                         inedible: &[token::Token]) {\n+        fn tokens_to_str(p: &mut Parser, tokens: &[token::Token]) -> ~str {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n             let b = i.next().map_default(~\"\", |t| p.token_to_str(t));\n@@ -435,7 +427,7 @@ impl Parser {\n     // Check for erroneous `ident { }`; if matches, signal error and\n     // recover (without consuming any expected input token).  Returns\n     // true if and only if input was consumed for recovery.\n-    pub fn check_for_erroneous_unit_struct_expecting(&self, expected: &[token::Token]) -> bool {\n+    pub fn check_for_erroneous_unit_struct_expecting(&mut self, expected: &[token::Token]) -> bool {\n         if *self.token == token::LBRACE\n             && expected.iter().all(|t| *t != token::LBRACE)\n             && self.look_ahead(1, |t| *t == token::RBRACE) {\n@@ -453,7 +445,7 @@ impl Parser {\n     // Commit to parsing a complete expression `e` expected to be\n     // followed by some token from the set edible + inedible.  Recover\n     // from anticipated input errors, discarding erroneous characters.\n-    pub fn commit_expr(&self, e: @Expr, edible: &[token::Token], inedible: &[token::Token]) {\n+    pub fn commit_expr(&mut self, e: @Expr, edible: &[token::Token], inedible: &[token::Token]) {\n         debug!(\"commit_expr {:?}\", e);\n         match e.node {\n             ExprPath(..) => {\n@@ -466,14 +458,14 @@ impl Parser {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_expr_expecting(&self, e: @Expr, edible: token::Token) {\n+    pub fn commit_expr_expecting(&mut self, e: @Expr, edible: token::Token) {\n         self.commit_expr(e, &[edible], &[])\n     }\n \n     // Commit to parsing a complete statement `s`, which expects to be\n     // followed by some token from the set edible + inedible.  Check\n     // for recoverable input errors, discarding erroneous characters.\n-    pub fn commit_stmt(&self, s: @Stmt, edible: &[token::Token], inedible: &[token::Token]) {\n+    pub fn commit_stmt(&mut self, s: @Stmt, edible: &[token::Token], inedible: &[token::Token]) {\n         debug!(\"commit_stmt {:?}\", s);\n         let _s = s; // unused, but future checks might want to inspect `s`.\n         if self.last_token.as_ref().map_default(false, |t| is_ident_or_path(*t)) {\n@@ -483,11 +475,11 @@ impl Parser {\n         self.expect_one_of(edible, inedible)\n     }\n \n-    pub fn commit_stmt_expecting(&self, s: @Stmt, edible: token::Token) {\n+    pub fn commit_stmt_expecting(&mut self, s: @Stmt, edible: token::Token) {\n         self.commit_stmt(s, &[edible], &[])\n     }\n \n-    pub fn parse_ident(&self) -> ast::Ident {\n+    pub fn parse_ident(&mut self) -> ast::Ident {\n         self.check_strict_keywords();\n         self.check_reserved_keywords();\n         match *self.token {\n@@ -499,17 +491,13 @@ impl Parser {\n                 self.bug(\"ident interpolation not converted to real token\");\n             }\n             _ => {\n-                self.fatal(\n-                    format!(\n-                        \"expected ident, found `{}`\",\n-                        self.this_token_to_str()\n-                    )\n-                );\n+                let token_str = self.this_token_to_str();\n+                self.fatal(format!( \"expected ident, found `{}`\", token_str))\n             }\n         }\n     }\n \n-    pub fn parse_path_list_ident(&self) -> ast::path_list_ident {\n+    pub fn parse_path_list_ident(&mut self) -> ast::path_list_ident {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         let hi = self.last_span.hi;\n@@ -519,19 +507,19 @@ impl Parser {\n \n     // consume token 'tok' if it exists. Returns true if the given\n     // token was present, false otherwise.\n-    pub fn eat(&self, tok: &token::Token) -> bool {\n+    pub fn eat(&mut self, tok: &token::Token) -> bool {\n         let is_present = *self.token == *tok;\n         if is_present { self.bump() }\n         is_present\n     }\n \n-    pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n+    pub fn is_keyword(&mut self, kw: keywords::Keyword) -> bool {\n         token::is_keyword(kw, self.token)\n     }\n \n     // if the next token is the given keyword, eat it and return\n     // true. Otherwise, return false.\n-    pub fn eat_keyword(&self, kw: keywords::Keyword) -> bool {\n+    pub fn eat_keyword(&mut self, kw: keywords::Keyword) -> bool {\n         let is_kw = match *self.token {\n             token::IDENT(sid, false) => kw.to_ident().name == sid.name,\n             _ => false\n@@ -543,36 +531,36 @@ impl Parser {\n     // if the given word is not a keyword, signal an error.\n     // if the next token is not the given word, signal an error.\n     // otherwise, eat it.\n-    pub fn expect_keyword(&self, kw: keywords::Keyword) {\n+    pub fn expect_keyword(&mut self, kw: keywords::Keyword) {\n         if !self.eat_keyword(kw) {\n-            self.fatal(\n-                format!(\n-                    \"expected `{}`, found `{}`\",\n-                    self.id_to_str(kw.to_ident()).to_str(),\n-                    self.this_token_to_str()\n-                )\n-            );\n+            let id_str = self.id_to_str(kw.to_ident()).to_str();\n+            let token_str = self.this_token_to_str();\n+            self.fatal(format!(\"expected `{}`, found `{}`\",\n+                               id_str,\n+                               token_str))\n         }\n     }\n \n     // signal an error if the given string is a strict keyword\n-    pub fn check_strict_keywords(&self) {\n+    pub fn check_strict_keywords(&mut self) {\n         if token::is_strict_keyword(self.token) {\n+            let token_str = self.this_token_to_str();\n             self.span_err(*self.span,\n-                          format!(\"found `{}` in ident position\", self.this_token_to_str()));\n+                          format!(\"found `{}` in ident position\", token_str));\n         }\n     }\n \n     // signal an error if the current token is a reserved keyword\n-    pub fn check_reserved_keywords(&self) {\n+    pub fn check_reserved_keywords(&mut self) {\n         if token::is_reserved_keyword(self.token) {\n-            self.fatal(format!(\"`{}` is a reserved keyword\", self.this_token_to_str()));\n+            let token_str = self.this_token_to_str();\n+            self.fatal(format!(\"`{}` is a reserved keyword\", token_str))\n         }\n     }\n \n     // Expect and consume a `|`. If `||` is seen, replace it with a single\n     // `|` and continue. If a `|` is not seen, signal an error.\n-    fn expect_or(&self) {\n+    fn expect_or(&mut self) {\n         match *self.token {\n             token::BINOP(token::OR) => self.bump(),\n             token::OROR => {\n@@ -581,16 +569,20 @@ impl Parser {\n                                    self.span.hi)\n             }\n             _ => {\n+                let token_str = self.this_token_to_str();\n                 let found_token = self.token_to_str(&token::BINOP(token::OR));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    found_token,\n-                                   self.this_token_to_str()))\n+                                   token_str))\n             }\n         }\n     }\n \n     // Parse a sequence bracketed by `|` and `|`, stopping before the `|`.\n-    fn parse_seq_to_before_or<T>(&self, sep: &token::Token, f: |&Parser| -> T)\n+    fn parse_seq_to_before_or<T>(\n+                              &mut self,\n+                              sep: &token::Token,\n+                              f: |&mut Parser| -> T)\n                               -> ~[T] {\n         let mut first = true;\n         let mut vector = ~[];\n@@ -610,26 +602,30 @@ impl Parser {\n     // expect and consume a GT. if a >> is seen, replace it\n     // with a single > and continue. If a GT is not seen,\n     // signal an error.\n-    pub fn expect_gt(&self) {\n+    pub fn expect_gt(&mut self) {\n         match *self.token {\n             token::GT => self.bump(),\n             token::BINOP(token::SHR) => self.replace_token(\n                 token::GT,\n                 self.span.lo + BytePos(1),\n                 self.span.hi\n             ),\n-            _ => self.fatal(format!(\"expected `{}`, found `{}`\",\n-                                 self.token_to_str(&token::GT),\n-                                 self.this_token_to_str()))\n+            _ => {\n+                let gt_str = self.token_to_str(&token::GT);\n+                let this_token_str = self.this_token_to_str();\n+                self.fatal(format!(\"expected `{}`, found `{}`\",\n+                                   gt_str,\n+                                   this_token_str))\n+            }\n         }\n     }\n \n     // parse a sequence bracketed by '<' and '>', stopping\n     // before the '>'.\n     pub fn parse_seq_to_before_gt<T>(\n-                                  &self,\n+                                  &mut self,\n                                   sep: Option<token::Token>,\n-                                  f: |&Parser| -> T)\n+                                  f: |&mut Parser| -> T)\n                                   -> OptVec<T> {\n         let mut first = true;\n         let mut v = opt_vec::Empty;\n@@ -648,9 +644,9 @@ impl Parser {\n     }\n \n     pub fn parse_seq_to_gt<T>(\n-                           &self,\n+                           &mut self,\n                            sep: Option<token::Token>,\n-                           f: |&Parser| -> T)\n+                           f: |&mut Parser| -> T)\n                            -> OptVec<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n@@ -661,10 +657,10 @@ impl Parser {\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n     pub fn parse_seq_to_end<T>(\n-                            &self,\n+                            &mut self,\n                             ket: &token::Token,\n                             sep: SeqSep,\n-                            f: |&Parser| -> T)\n+                            f: |&mut Parser| -> T)\n                             -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -675,10 +671,10 @@ impl Parser {\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n     pub fn parse_seq_to_before_end<T>(\n-                                   &self,\n+                                   &mut self,\n                                    ket: &token::Token,\n                                    sep: SeqSep,\n-                                   f: |&Parser| -> T)\n+                                   f: |&mut Parser| -> T)\n                                    -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n@@ -700,11 +696,11 @@ impl Parser {\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n     pub fn parse_unspanned_seq<T>(\n-                               &self,\n+                               &mut self,\n                                bra: &token::Token,\n                                ket: &token::Token,\n                                sep: SeqSep,\n-                               f: |&Parser| -> T)\n+                               f: |&mut Parser| -> T)\n                                -> ~[T] {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -715,11 +711,11 @@ impl Parser {\n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n     pub fn parse_seq<T>(\n-                     &self,\n+                     &mut self,\n                      bra: &token::Token,\n                      ket: &token::Token,\n                      sep: SeqSep,\n-                     f: |&Parser| -> T)\n+                     f: |&mut Parser| -> T)\n                      -> Spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);\n@@ -730,7 +726,7 @@ impl Parser {\n     }\n \n     // advance the parser by one token\n-    pub fn bump(&self) {\n+    pub fn bump(&mut self) {\n         *self.last_span = *self.span;\n         // Stash token for error recovery (sometimes; clone is not necessarily cheap).\n         *self.last_token = if is_ident_or_path(self.token) {\n@@ -758,27 +754,27 @@ impl Parser {\n     }\n \n     // Advance the parser by one token and return the bumped token.\n-    pub fn bump_and_get(&self) -> token::Token {\n+    pub fn bump_and_get(&mut self) -> token::Token {\n         let old_token = util::replace(self.token, token::UNDERSCORE);\n         self.bump();\n         old_token\n     }\n \n     // EFFECT: replace the current token and span with the given one\n-    pub fn replace_token(&self,\n+    pub fn replace_token(&mut self,\n                          next: token::Token,\n                          lo: BytePos,\n                          hi: BytePos) {\n         *self.token = next;\n         *self.span = mk_sp(lo, hi);\n     }\n-    pub fn buffer_length(&self) -> int {\n+    pub fn buffer_length(&mut self) -> int {\n         if *self.buffer_start <= *self.buffer_end {\n             return *self.buffer_end - *self.buffer_start;\n         }\n         return (4 - *self.buffer_start) + *self.buffer_end;\n     }\n-    pub fn look_ahead<R>(&self, distance: uint, f: |&token::Token| -> R)\n+    pub fn look_ahead<R>(&mut self, distance: uint, f: |&token::Token| -> R)\n                       -> R {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n@@ -787,35 +783,35 @@ impl Parser {\n         }\n         f(&self.buffer[(*self.buffer_start + dist - 1) & 3].tok)\n     }\n-    pub fn fatal(&self, m: &str) -> ! {\n+    pub fn fatal(&mut self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(*self.span, m)\n     }\n-    pub fn span_fatal(&self, sp: Span, m: &str) -> ! {\n+    pub fn span_fatal(&mut self, sp: Span, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n-    pub fn span_note(&self, sp: Span, m: &str) {\n+    pub fn span_note(&mut self, sp: Span, m: &str) {\n         self.sess.span_diagnostic.span_note(sp, m)\n     }\n-    pub fn bug(&self, m: &str) -> ! {\n+    pub fn bug(&mut self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_bug(*self.span, m)\n     }\n-    pub fn warn(&self, m: &str) {\n+    pub fn warn(&mut self, m: &str) {\n         self.sess.span_diagnostic.span_warn(*self.span, m)\n     }\n-    pub fn span_err(&self, sp: Span, m: &str) {\n+    pub fn span_err(&mut self, sp: Span, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n     }\n-    pub fn abort_if_errors(&self) {\n+    pub fn abort_if_errors(&mut self) {\n         self.sess.span_diagnostic.handler().abort_if_errors();\n     }\n \n-    pub fn id_to_str(&self, id: Ident) -> @str {\n+    pub fn id_to_str(&mut self, id: Ident) -> @str {\n         get_ident_interner().get(id.name)\n     }\n \n     // Is the current token one of the keywords that signals a bare function\n     // type?\n-    pub fn token_is_bare_fn_keyword(&self) -> bool {\n+    pub fn token_is_bare_fn_keyword(&mut self) -> bool {\n         if token::is_keyword(keywords::Fn, self.token) {\n             return true\n         }\n@@ -829,35 +825,35 @@ impl Parser {\n     }\n \n     // Is the current token one of the keywords that signals a closure type?\n-    pub fn token_is_closure_keyword(&self) -> bool {\n+    pub fn token_is_closure_keyword(&mut self) -> bool {\n         token::is_keyword(keywords::Unsafe, self.token) ||\n             token::is_keyword(keywords::Once, self.token)\n     }\n \n     // Is the current token one of the keywords that signals an old-style\n     // closure type (with explicit sigil)?\n-    pub fn token_is_old_style_closure_keyword(&self) -> bool {\n+    pub fn token_is_old_style_closure_keyword(&mut self) -> bool {\n         token::is_keyword(keywords::Unsafe, self.token) ||\n             token::is_keyword(keywords::Once, self.token) ||\n             token::is_keyword(keywords::Fn, self.token)\n     }\n \n-    pub fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n+    pub fn token_is_lifetime(tok: &token::Token) -> bool {\n         match *tok {\n             token::LIFETIME(..) => true,\n             _ => false,\n         }\n     }\n \n-    pub fn get_lifetime(&self, tok: &token::Token) -> ast::Ident {\n+    pub fn get_lifetime(&mut self, tok: &token::Token) -> ast::Ident {\n         match *tok {\n             token::LIFETIME(ref ident) => *ident,\n             _ => self.bug(\"not a lifetime\"),\n         }\n     }\n \n     // parse a ty_bare_fun type:\n-    pub fn parse_ty_bare_fn(&self) -> ty_ {\n+    pub fn parse_ty_bare_fn(&mut self) -> ty_ {\n         /*\n \n         [extern \"ABI\"] [unsafe] fn <'lt> (S) -> T\n@@ -887,7 +883,7 @@ impl Parser {\n \n     // Parses a procedure type (`proc`). The initial `proc` keyword must\n     // already have been parsed.\n-    pub fn parse_proc_type(&self) -> ty_ {\n+    pub fn parse_proc_type(&mut self) -> ty_ {\n         let (decl, lifetimes) = self.parse_ty_fn_decl(false);\n         ty_closure(@TyClosure {\n             sigil: OwnedSigil,\n@@ -901,7 +897,7 @@ impl Parser {\n     }\n \n     // parse a ty_closure type\n-    pub fn parse_ty_closure(&self,\n+    pub fn parse_ty_closure(&mut self,\n                             opt_sigil: Option<ast::Sigil>,\n                             mut region: Option<ast::Lifetime>)\n                             -> ty_ {\n@@ -990,7 +986,7 @@ impl Parser {\n             lifetimes: lifetimes,\n         });\n \n-        fn parse_onceness(this: &Parser) -> Onceness {\n+        fn parse_onceness(this: &mut Parser) -> Onceness {\n             if this.eat_keyword(keywords::Once) {\n                 Once\n             } else {\n@@ -999,7 +995,7 @@ impl Parser {\n         }\n     }\n \n-    pub fn parse_unsafety(&self) -> purity {\n+    pub fn parse_unsafety(&mut self) -> purity {\n         if self.eat_keyword(keywords::Unsafe) {\n             return unsafe_fn;\n         } else {\n@@ -1008,7 +1004,7 @@ impl Parser {\n     }\n \n     // parse a function type (following the 'fn')\n-    pub fn parse_ty_fn_decl(&self, allow_variadic: bool) -> (P<fn_decl>, OptVec<ast::Lifetime>) {\n+    pub fn parse_ty_fn_decl(&mut self, allow_variadic: bool) -> (P<fn_decl>, OptVec<ast::Lifetime>) {\n         /*\n \n         (fn) <'lt> (S) -> T\n@@ -1039,7 +1035,7 @@ impl Parser {\n     }\n \n     // parse the methods in a trait declaration\n-    pub fn parse_trait_methods(&self) -> ~[trait_method] {\n+    pub fn parse_trait_methods(&mut self) -> ~[trait_method] {\n         self.parse_unspanned_seq(\n             &token::LBRACE,\n             &token::RBRACE,\n@@ -1048,7 +1044,7 @@ impl Parser {\n             let attrs = p.parse_outer_attributes();\n             let lo = p.span.lo;\n \n-            let vis_span = *self.span;\n+            let vis_span = *p.span;\n             let vis = p.parse_visibility();\n             let pur = p.parse_fn_purity();\n             // NB: at the moment, trait methods are public by default; this\n@@ -1057,25 +1053,21 @@ impl Parser {\n \n             let generics = p.parse_generics();\n \n-            let (explicit_self, d) = self.parse_fn_decl_with_self(|p| {\n+            let (explicit_self, d) = p.parse_fn_decl_with_self(|p| {\n                 // This is somewhat dubious; We don't want to allow argument\n                 // names to be left off if there is a definition...\n                 p.parse_arg_general(false)\n             });\n \n             let hi = p.last_span.hi;\n-            debug!(\"parse_trait_methods(): trait method signature ends in \\\n-                    `{}`\",\n-                   self.this_token_to_str());\n             match *p.token {\n               token::SEMI => {\n                 p.bump();\n                 debug!(\"parse_trait_methods(): parsing required method\");\n                 // NB: at the moment, visibility annotations on required\n                 // methods are ignored; this could change.\n                 if vis != ast::inherited {\n-                    self.obsolete(vis_span,\n-                                  ObsoleteTraitFuncVisibility);\n+                    p.obsolete(vis_span, ObsoleteTraitFuncVisibility);\n                 }\n                 required(TypeMethod {\n                     ident: ident,\n@@ -1109,27 +1101,24 @@ impl Parser {\n               }\n \n               _ => {\n-                    p.fatal(\n-                        format!(\n-                            \"expected `;` or `\\\\{` but found `{}`\",\n-                            self.this_token_to_str()\n-                        )\n-                    );\n-                }\n+                  let token_str = p.this_token_to_str();\n+                  p.fatal(format!(\"expected `;` or `\\\\{` but found `{}`\",\n+                                  token_str))\n+              }\n             }\n         })\n     }\n \n     // parse a possibly mutable type\n-    pub fn parse_mt(&self) -> mt {\n+    pub fn parse_mt(&mut self) -> mt {\n         let mutbl = self.parse_mutability();\n         let t = self.parse_ty(false);\n         mt { ty: t, mutbl: mutbl }\n     }\n \n     // parse [mut/const/imm] ID : TY\n     // now used only by obsolete record syntax parser...\n-    pub fn parse_ty_field(&self) -> TypeField {\n+    pub fn parse_ty_field(&mut self) -> TypeField {\n         let lo = self.span.lo;\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n@@ -1144,7 +1133,7 @@ impl Parser {\n     }\n \n     // parse optional return type [ -> TY ] in function decl\n-    pub fn parse_ret_ty(&self) -> (ret_style, P<Ty>) {\n+    pub fn parse_ret_ty(&mut self) -> (ret_style, P<Ty>) {\n         return if self.eat(&token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(&token::NOT) {\n@@ -1175,7 +1164,7 @@ impl Parser {\n     // parse a type.\n     // Useless second parameter for compatibility with quasiquote macros.\n     // Bleh!\n-    pub fn parse_ty(&self, _: bool) -> P<Ty> {\n+    pub fn parse_ty(&mut self, _: bool) -> P<Ty> {\n         maybe_whole!(no_clone self, nt_ty);\n \n         let lo = self.span.lo;\n@@ -1247,7 +1236,7 @@ impl Parser {\n                 *self.token == token::BINOP(token::OR) ||\n                 *self.token == token::OROR ||\n                 *self.token == token::LT ||\n-                self.token_is_lifetime(self.token) {\n+                Parser::token_is_lifetime(self.token) {\n             // CLOSURE\n             //\n             // XXX(pcwalton): Eventually `token::LT` will not unambiguously\n@@ -1283,7 +1272,7 @@ impl Parser {\n     }\n \n     // parse the type following a @ or a ~\n-    pub fn parse_box_or_uniq_pointee(&self,\n+    pub fn parse_box_or_uniq_pointee(&mut self,\n                                      sigil: ast::Sigil)\n                                      -> ty_ {\n         // ~'foo fn() or ~fn() are parsed directly as obsolete fn types:\n@@ -1314,7 +1303,7 @@ impl Parser {\n         }\n     }\n \n-    pub fn parse_borrowed_pointee(&self) -> ty_ {\n+    pub fn parse_borrowed_pointee(&mut self) -> ty_ {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = self.parse_opt_lifetime();\n \n@@ -1327,7 +1316,7 @@ impl Parser {\n         return ty_rptr(opt_lifetime, mt);\n     }\n \n-    pub fn is_named_argument(&self) -> bool {\n+    pub fn is_named_argument(&mut self) -> bool {\n         let offset = match *self.token {\n             token::BINOP(token::AND) => 1,\n             token::ANDAND => 1,\n@@ -1348,7 +1337,7 @@ impl Parser {\n \n     // This version of parse arg doesn't necessarily require\n     // identifier names.\n-    pub fn parse_arg_general(&self, require_name: bool) -> arg {\n+    pub fn parse_arg_general(&mut self, require_name: bool) -> arg {\n         let pat = if require_name || self.is_named_argument() {\n             debug!(\"parse_arg_general parse_pat (require_name:{:?})\",\n                    require_name);\n@@ -1373,12 +1362,12 @@ impl Parser {\n     }\n \n     // parse a single function argument\n-    pub fn parse_arg(&self) -> arg {\n+    pub fn parse_arg(&mut self) -> arg {\n         self.parse_arg_general(true)\n     }\n \n     // parse an argument in a lambda header e.g. |arg, arg|\n-    pub fn parse_fn_block_arg(&self) -> arg {\n+    pub fn parse_fn_block_arg(&mut self) -> arg {\n         let pat = self.parse_pat();\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n@@ -1396,7 +1385,7 @@ impl Parser {\n         }\n     }\n \n-    pub fn maybe_parse_fixed_vstore(&self) -> Option<@ast::Expr> {\n+    pub fn maybe_parse_fixed_vstore(&mut self) -> Option<@ast::Expr> {\n         if *self.token == token::COMMA &&\n                 self.look_ahead(1, |t| *t == token::DOTDOT) {\n             self.bump();\n@@ -1408,7 +1397,7 @@ impl Parser {\n     }\n \n     // matches token_lit = LIT_INT | ...\n-    pub fn lit_from_token(&self, tok: &token::Token) -> lit_ {\n+    pub fn lit_from_token(&mut self, tok: &token::Token) -> lit_ {\n         match *tok {\n             token::LIT_CHAR(i) => lit_char(i),\n             token::LIT_INT(i, it) => lit_int(i, it),\n@@ -1425,7 +1414,7 @@ impl Parser {\n     }\n \n     // matches lit = true | false | token_lit\n-    pub fn parse_lit(&self) -> lit {\n+    pub fn parse_lit(&mut self) -> lit {\n         let lo = self.span.lo;\n         let lit = if self.eat_keyword(keywords::True) {\n             lit_bool(true)\n@@ -1440,7 +1429,7 @@ impl Parser {\n     }\n \n     // matches '-' lit | lit\n-    pub fn parse_literal_maybe_minus(&self) -> @Expr {\n+    pub fn parse_literal_maybe_minus(&mut self) -> @Expr {\n         let minus_lo = self.span.lo;\n         let minus_present = self.eat(&token::BINOP(token::MINUS));\n \n@@ -1451,7 +1440,8 @@ impl Parser {\n \n         if minus_present {\n             let minus_hi = self.span.hi;\n-            self.mk_expr(minus_lo, minus_hi, self.mk_unary(UnNeg, expr))\n+            let unary = self.mk_unary(UnNeg, expr);\n+            self.mk_expr(minus_lo, minus_hi, unary)\n         } else {\n             expr\n         }\n@@ -1461,7 +1451,7 @@ impl Parser {\n     /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n     /// bounds are permitted and whether `::` must precede type parameter\n     /// groups.\n-    pub fn parse_path(&self, mode: PathParsingMode) -> PathAndBounds {\n+    pub fn parse_path(&mut self, mode: PathParsingMode) -> PathAndBounds {\n         // Check for a whole path...\n         let found = match *self.token {\n             INTERPOLATED(token::nt_path(_)) => Some(self.bump_and_get()),\n@@ -1580,7 +1570,7 @@ impl Parser {\n     }\n \n     /// parses 0 or 1 lifetime\n-    pub fn parse_opt_lifetime(&self) -> Option<ast::Lifetime> {\n+    pub fn parse_opt_lifetime(&mut self) -> Option<ast::Lifetime> {\n         match *self.token {\n             token::LIFETIME(..) => {\n                 Some(self.parse_lifetime())\n@@ -1593,7 +1583,7 @@ impl Parser {\n \n     /// Parses a single lifetime\n     // matches lifetime = LIFETIME\n-    pub fn parse_lifetime(&self) -> ast::Lifetime {\n+    pub fn parse_lifetime(&mut self) -> ast::Lifetime {\n         match *self.token {\n             token::LIFETIME(i) => {\n                 let span = *self.span;\n@@ -1613,7 +1603,7 @@ impl Parser {\n     // matches lifetimes = ( lifetime ) | ( lifetime , lifetimes )\n     // actually, it matches the empty one too, but putting that in there\n     // messes up the grammar....\n-    pub fn parse_lifetimes(&self) -> OptVec<ast::Lifetime> {\n+    pub fn parse_lifetimes(&mut self) -> OptVec<ast::Lifetime> {\n         /*!\n          *\n          * Parses zero or more comma separated lifetimes.\n@@ -1645,13 +1635,13 @@ impl Parser {\n         }\n     }\n \n-    pub fn token_is_mutability(&self, tok: &token::Token) -> bool {\n+    pub fn token_is_mutability(tok: &token::Token) -> bool {\n         token::is_keyword(keywords::Mut, tok) ||\n         token::is_keyword(keywords::Const, tok)\n     }\n \n     // parse mutability declaration (mut/const/imm)\n-    pub fn parse_mutability(&self) -> Mutability {\n+    pub fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(keywords::Mut) {\n             MutMutable\n         } else if self.eat_keyword(keywords::Const) {\n@@ -1663,7 +1653,7 @@ impl Parser {\n     }\n \n     // parse ident COLON expr\n-    pub fn parse_field(&self) -> Field {\n+    pub fn parse_field(&mut self) -> Field {\n         let lo = self.span.lo;\n         let i = self.parse_ident();\n         let hi = self.last_span.hi;\n@@ -1676,27 +1666,27 @@ impl Parser {\n         }\n     }\n \n-    pub fn mk_expr(&self, lo: BytePos, hi: BytePos, node: Expr_) -> @Expr {\n+    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: Expr_) -> @Expr {\n         @Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: mk_sp(lo, hi),\n         }\n     }\n \n-    pub fn mk_unary(&self, unop: ast::UnOp, expr: @Expr) -> ast::Expr_ {\n+    pub fn mk_unary(&mut self, unop: ast::UnOp, expr: @Expr) -> ast::Expr_ {\n         ExprUnary(ast::DUMMY_NODE_ID, unop, expr)\n     }\n \n-    pub fn mk_binary(&self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n+    pub fn mk_binary(&mut self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n         ExprBinary(ast::DUMMY_NODE_ID, binop, lhs, rhs)\n     }\n \n-    pub fn mk_call(&self, f: @Expr, args: ~[@Expr], sugar: CallSugar) -> ast::Expr_ {\n+    pub fn mk_call(&mut self, f: @Expr, args: ~[@Expr], sugar: CallSugar) -> ast::Expr_ {\n         ExprCall(f, args, sugar)\n     }\n \n-    pub fn mk_method_call(&self,\n+    pub fn mk_method_call(&mut self,\n                       rcvr: @Expr,\n                       ident: Ident,\n                       tps: ~[P<Ty>],\n@@ -1705,27 +1695,27 @@ impl Parser {\n         ExprMethodCall(ast::DUMMY_NODE_ID, rcvr, ident, tps, args, sugar)\n     }\n \n-    pub fn mk_index(&self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n+    pub fn mk_index(&mut self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n         ExprIndex(ast::DUMMY_NODE_ID, expr, idx)\n     }\n \n-    pub fn mk_field(&self, expr: @Expr, ident: Ident, tys: ~[P<Ty>]) -> ast::Expr_ {\n+    pub fn mk_field(&mut self, expr: @Expr, ident: Ident, tys: ~[P<Ty>]) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n     }\n \n-    pub fn mk_assign_op(&self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n+    pub fn mk_assign_op(&mut self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n         ExprAssignOp(ast::DUMMY_NODE_ID, binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&self, lo: BytePos, hi: BytePos, m: mac_) -> @Expr {\n+    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: mac_) -> @Expr {\n         @Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n         }\n     }\n \n-    pub fn mk_lit_u32(&self, i: u32) -> @Expr {\n+    pub fn mk_lit_u32(&mut self, i: u32) -> @Expr {\n         let span = self.span;\n         let lv_lit = @codemap::Spanned {\n             node: lit_uint(i as u64, ty_u32),\n@@ -1742,7 +1732,7 @@ impl Parser {\n     // at the bottom (top?) of the precedence hierarchy,\n     // parse things like parenthesized exprs,\n     // macros, return, etc.\n-    pub fn parse_bottom_expr(&self) -> @Expr {\n+    pub fn parse_bottom_expr(&mut self) -> @Expr {\n         maybe_whole_expr!(self);\n \n         let lo = self.span.lo;\n@@ -1814,7 +1804,7 @@ impl Parser {\n                                                ExprDoBody);\n         } else if self.eat_keyword(keywords::While) {\n             return self.parse_while_expr();\n-        } else if self.token_is_lifetime(&*self.token) {\n+        } else if Parser::token_is_lifetime(&*self.token) {\n             let lifetime = self.get_lifetime(&*self.token);\n             self.bump();\n             self.expect(&token::COLON);\n@@ -1829,7 +1819,7 @@ impl Parser {\n             return self.parse_loop_expr(None);\n         } else if self.eat_keyword(keywords::Continue) {\n             let lo = self.span.lo;\n-            let ex = if self.token_is_lifetime(&*self.token) {\n+            let ex = if Parser::token_is_lifetime(&*self.token) {\n                 let lifetime = self.get_lifetime(&*self.token);\n                 self.bump();\n                 ExprAgain(Some(lifetime.name))\n@@ -1892,7 +1882,7 @@ impl Parser {\n             } else { ex = ExprRet(None); }\n         } else if self.eat_keyword(keywords::Break) {\n             // BREAK expression\n-            if self.token_is_lifetime(&*self.token) {\n+            if Parser::token_is_lifetime(&*self.token) {\n                 let lifetime = self.get_lifetime(&*self.token);\n                 self.bump();\n                 ex = ExprBreak(Some(lifetime.name));\n@@ -1967,20 +1957,20 @@ impl Parser {\n     }\n \n     // parse a block or unsafe block\n-    pub fn parse_block_expr(&self, lo: BytePos, blk_mode: BlockCheckMode)\n+    pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode)\n                             -> @Expr {\n         self.expect(&token::LBRACE);\n         let blk = self.parse_block_tail(lo, blk_mode);\n         return self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk));\n     }\n \n     // parse a.b or a(13) or a[4] or just a\n-    pub fn parse_dot_or_call_expr(&self) -> @Expr {\n+    pub fn parse_dot_or_call_expr(&mut self) -> @Expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n     }\n \n-    pub fn parse_dot_or_call_expr_with(&self, e0: @Expr) -> @Expr {\n+    pub fn parse_dot_or_call_expr_with(&mut self, e0: @Expr) -> @Expr {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -2013,7 +2003,8 @@ impl Parser {\n                             e = self.mk_expr(lo, hi, nd);\n                         }\n                         _ => {\n-                            e = self.mk_expr(lo, hi, self.mk_field(e, i, tys));\n+                            let field = self.mk_field(e, i, tys);\n+                            e = self.mk_expr(lo, hi, field)\n                         }\n                     }\n                   }\n@@ -2043,7 +2034,8 @@ impl Parser {\n                 let ix = self.parse_expr();\n                 hi = ix.span.hi;\n                 self.commit_expr_expecting(ix, token::RBRACKET);\n-                e = self.mk_expr(lo, hi, self.mk_index(e, ix));\n+                let index = self.mk_index(e, ix);\n+                e = self.mk_expr(lo, hi, index)\n               }\n \n               _ => return e\n@@ -2054,8 +2046,8 @@ impl Parser {\n \n     // parse an optional separator followed by a kleene-style\n     // repetition token (+ or *).\n-    pub fn parse_sep_and_zerok(&self) -> (Option<token::Token>, bool) {\n-        fn parse_zerok(parser: &Parser) -> Option<bool> {\n+    pub fn parse_sep_and_zerok(&mut self) -> (Option<token::Token>, bool) {\n+        fn parse_zerok(parser: &mut Parser) -> Option<bool> {\n             match *parser.token {\n                 token::BINOP(token::STAR) | token::BINOP(token::PLUS) => {\n                     let zerok = *parser.token == token::BINOP(token::STAR);\n@@ -2079,7 +2071,7 @@ impl Parser {\n     }\n \n     // parse a single token tree from the input.\n-    pub fn parse_token_tree(&self) -> token_tree {\n+    pub fn parse_token_tree(&mut self) -> token_tree {\n         // FIXME #6994: currently, this is too eager. It\n         // parses token trees but also identifies tt_seq's\n         // and tt_nonterminals; it's too early to know yet\n@@ -2092,15 +2084,17 @@ impl Parser {\n         // not an EOF, and not the desired right-delimiter (if\n         // it were, parse_seq_to_before_end would have prevented\n         // reaching this point.\n-        fn parse_non_delim_tt_tok(p: &Parser) -> token_tree {\n+        fn parse_non_delim_tt_tok(p: &mut Parser) -> token_tree {\n             maybe_whole!(deref p, nt_tt);\n             match *p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET => {\n                   // This is a conservative error: only report the last unclosed delimiter. The\n                   // previous unclosed delimiters could actually be closed! The parser just hasn't\n                   // gotten to them yet.\n                   p.open_braces.last_opt().map(|sp| p.span_note(*sp, \"unclosed delimiter\"));\n-                  p.fatal(format!(\"incorrect close delimiter: `{}`\", p.this_token_to_str()));\n+                  let token_str = p.this_token_to_str();\n+                  p.fatal(format!(\"incorrect close delimiter: `{}`\",\n+                                  token_str))\n               },\n               /* we ought to allow different depths of unquotation */\n               token::DOLLAR if *p.quote_depth > 0u => {\n@@ -2135,7 +2129,7 @@ impl Parser {\n         }\n \n         // turn the next token into a tt_tok:\n-        fn parse_any_tt_tok(p: &Parser) -> token_tree{\n+        fn parse_any_tt_tok(p: &mut Parser) -> token_tree{\n             tt_tok(*p.span, p.bump_and_get())\n         }\n \n@@ -2173,15 +2167,15 @@ impl Parser {\n \n     // parse a stream of tokens into a list of token_trees,\n     // up to EOF.\n-    pub fn parse_all_token_trees(&self) -> ~[token_tree] {\n+    pub fn parse_all_token_trees(&mut self) -> ~[token_tree] {\n         let mut tts = ~[];\n         while *self.token != token::EOF {\n             tts.push(self.parse_token_tree());\n         }\n         tts\n     }\n \n-    pub fn parse_matchers(&self) -> ~[matcher] {\n+    pub fn parse_matchers(&mut self) -> ~[matcher] {\n         // unification of matchers and token_trees would vastly improve\n         // the interpolation of matchers\n         maybe_whole!(self, nt_matchers);\n@@ -2199,7 +2193,7 @@ impl Parser {\n     // This goofy function is necessary to correctly match parens in matchers.\n     // Otherwise, `$( ( )` would be a valid matcher, and `$( () )` would be\n     // invalid. It's similar to common::parse_seq.\n-    pub fn parse_matcher_subseq_upto(&self,\n+    pub fn parse_matcher_subseq_upto(&mut self,\n                                      name_idx: @mut uint,\n                                      ket: &token::Token)\n                                      -> ~[matcher] {\n@@ -2217,7 +2211,7 @@ impl Parser {\n         return ret_val;\n     }\n \n-    pub fn parse_matcher(&self, name_idx: @mut uint) -> matcher {\n+    pub fn parse_matcher(&mut self, name_idx: @mut uint) -> matcher {\n         let lo = self.span.lo;\n \n         let m = if *self.token == token::DOLLAR {\n@@ -2248,7 +2242,7 @@ impl Parser {\n     }\n \n     // parse a prefix-operator expr\n-    pub fn parse_prefix_expr(&self) -> @Expr {\n+    pub fn parse_prefix_expr(&mut self) -> @Expr {\n         let lo = self.span.lo;\n         let hi;\n \n@@ -2347,12 +2341,13 @@ impl Parser {\n     }\n \n     // parse an expression of binops\n-    pub fn parse_binops(&self) -> @Expr {\n-        self.parse_more_binops(self.parse_prefix_expr(), 0)\n+    pub fn parse_binops(&mut self) -> @Expr {\n+        let prefix_expr = self.parse_prefix_expr();\n+        self.parse_more_binops(prefix_expr, 0)\n     }\n \n     // parse an expression of binops of at least min_prec precedence\n-    pub fn parse_more_binops(&self, lhs: @Expr, min_prec: uint) -> @Expr {\n+    pub fn parse_more_binops(&mut self, lhs: @Expr, min_prec: uint) -> @Expr {\n         if self.expr_is_complete(lhs) { return lhs; }\n \n         // Prevent dynamic borrow errors later on by limiting the\n@@ -2377,8 +2372,8 @@ impl Parser {\n                     self.bump();\n                     let expr = self.parse_prefix_expr();\n                     let rhs = self.parse_more_binops(expr, cur_prec);\n-                    let bin = self.mk_expr(lhs.span.lo, rhs.span.hi,\n-                                           self.mk_binary(cur_op, lhs, rhs));\n+                    let binary = self.mk_binary(cur_op, lhs, rhs);\n+                    let bin = self.mk_expr(lhs.span.lo, rhs.span.hi, binary);\n                     self.parse_more_binops(bin, min_prec)\n                 } else {\n                     lhs\n@@ -2401,7 +2396,7 @@ impl Parser {\n     // parse an assignment expression....\n     // actually, this seems to be the main entry point for\n     // parsing an arbitrary expression.\n-    pub fn parse_assign_expr(&self) -> @Expr {\n+    pub fn parse_assign_expr(&mut self) -> @Expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n         match *self.token {\n@@ -2425,8 +2420,8 @@ impl Parser {\n                   token::SHL =>     BiShl,\n                   token::SHR =>     BiShr\n               };\n-              self.mk_expr(lo, rhs.span.hi,\n-                           self.mk_assign_op(aop, lhs, rhs))\n+              let assign_op = self.mk_assign_op(aop, lhs, rhs);\n+              self.mk_expr(lo, rhs.span.hi, assign_op)\n           }\n           token::DARROW => {\n             self.obsolete(*self.span, ObsoleteSwap);\n@@ -2442,7 +2437,7 @@ impl Parser {\n     }\n \n     // parse an 'if' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&self) -> @Expr {\n+    pub fn parse_if_expr(&mut self) -> @Expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let thn = self.parse_block();\n@@ -2457,12 +2452,12 @@ impl Parser {\n     }\n \n     // `|args| { ... }` or `{ ...}` like in `do` expressions\n-    pub fn parse_lambda_block_expr(&self) -> @Expr {\n+    pub fn parse_lambda_block_expr(&mut self) -> @Expr {\n         self.parse_lambda_expr_(\n-            || {\n-                match *self.token {\n+            |p| {\n+                match *p.token {\n                   token::BINOP(token::OR) | token::OROR => {\n-                    self.parse_fn_block_decl()\n+                    p.parse_fn_block_decl()\n                   }\n                   _ => {\n                     // No argument list - `do foo {`\n@@ -2471,36 +2466,36 @@ impl Parser {\n                           output: P(Ty {\n                               id: ast::DUMMY_NODE_ID,\n                               node: ty_infer,\n-                              span: *self.span\n+                              span: *p.span\n                           }),\n                           cf: return_val,\n                           variadic: false\n                       })\n                   }\n                 }\n             },\n-            || {\n-                let blk = self.parse_block();\n-                self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk))\n+            |p| {\n+                let blk = p.parse_block();\n+                p.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk))\n             })\n     }\n \n     // `|args| expr`\n-    pub fn parse_lambda_expr(&self) -> @Expr {\n-        self.parse_lambda_expr_(|| self.parse_fn_block_decl(),\n-                                || self.parse_expr())\n+    pub fn parse_lambda_expr(&mut self) -> @Expr {\n+        self.parse_lambda_expr_(|p| p.parse_fn_block_decl(),\n+                                |p| p.parse_expr())\n     }\n \n     // parse something of the form |args| expr\n     // this is used both in parsing a lambda expr\n     // and in parsing a block expr as e.g. in for...\n-    pub fn parse_lambda_expr_(&self,\n-                              parse_decl: || -> P<fn_decl>,\n-                              parse_body: || -> @Expr)\n+    pub fn parse_lambda_expr_(&mut self,\n+                              parse_decl: |&mut Parser| -> P<fn_decl>,\n+                              parse_body: |&mut Parser| -> @Expr)\n                               -> @Expr {\n         let lo = self.last_span.lo;\n-        let decl = parse_decl();\n-        let body = parse_body();\n+        let decl = parse_decl(self);\n+        let body = parse_body(self);\n         let fakeblock = P(ast::Block {\n             view_items: ~[],\n             stmts: ~[],\n@@ -2510,11 +2505,10 @@ impl Parser {\n             span: body.span,\n         });\n \n-        return self.mk_expr(lo, body.span.hi,\n-                            ExprFnBlock(decl, fakeblock));\n+        return self.mk_expr(lo, body.span.hi, ExprFnBlock(decl, fakeblock));\n     }\n \n-    pub fn parse_else_expr(&self) -> @Expr {\n+    pub fn parse_else_expr(&mut self) -> @Expr {\n         if self.eat_keyword(keywords::If) {\n             return self.parse_if_expr();\n         } else {\n@@ -2524,7 +2518,7 @@ impl Parser {\n     }\n \n     // parse a 'for' .. 'in' expression ('for' token already eaten)\n-    pub fn parse_for_expr(&self, opt_ident: Option<ast::Ident>) -> @Expr {\n+    pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>) -> @Expr {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let lo = self.last_span.lo;\n@@ -2541,7 +2535,7 @@ impl Parser {\n     // parse a 'do'.\n     // the 'do' expression parses as a call, but looks like\n     // a function call followed by a closure expression.\n-    pub fn parse_sugary_call_expr(&self,\n+    pub fn parse_sugary_call_expr(&mut self,\n                                   lo: BytePos,\n                                   keyword: ~str,\n                                   sugar: CallSugar,\n@@ -2570,33 +2564,31 @@ impl Parser {\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append((*args).clone(), [last_arg]);\n-                self.mk_expr(lo, block.span.hi,\n-                             self.mk_method_call(f,\n-                                                 i,\n-                                                 (*tps).clone(),\n-                                                 args,\n-                                                 sugar))\n+                let method_call = self.mk_method_call(f,\n+                                                      i,\n+                                                      (*tps).clone(),\n+                                                      args,\n+                                                      sugar);\n+                self.mk_expr(lo, block.span.hi, method_call)\n             }\n             ExprField(f, i, ref tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                self.mk_expr(lo, block.span.hi,\n-                             self.mk_method_call(f,\n-                                                 i,\n-                                                 (*tps).clone(),\n-                                                 ~[last_arg],\n-                                                 sugar))\n+                let method_call = self.mk_method_call(f,\n+                                                      i,\n+                                                      (*tps).clone(),\n+                                                      ~[last_arg],\n+                                                      sugar);\n+                self.mk_expr(lo, block.span.hi, method_call)\n             }\n             ExprPath(..) | ExprCall(..) | ExprMethodCall(..) |\n                 ExprParen(..) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                self.mk_expr(\n-                    lo,\n-                    last_arg.span.hi,\n-                    self.mk_call(e, ~[last_arg], sugar))\n+                let call = self.mk_call(e, ~[last_arg], sugar);\n+                self.mk_expr(lo, last_arg.span.hi, call)\n             }\n             _ => {\n                 // There may be other types of expressions that can\n@@ -2610,15 +2602,15 @@ impl Parser {\n         }\n     }\n \n-    pub fn parse_while_expr(&self) -> @Expr {\n+    pub fn parse_while_expr(&mut self) -> @Expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let body = self.parse_block();\n         let hi = body.span.hi;\n         return self.mk_expr(lo, hi, ExprWhile(cond, body));\n     }\n \n-    pub fn parse_loop_expr(&self, opt_ident: Option<ast::Ident>) -> @Expr {\n+    pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>) -> @Expr {\n         // loop headers look like 'loop {' or 'loop unsafe {'\n         let is_loop_header =\n             *self.token == token::LBRACE\n@@ -2640,7 +2632,7 @@ impl Parser {\n \n             self.obsolete(*self.last_span, ObsoleteLoopAsContinue);\n             let lo = self.span.lo;\n-            let ex = if self.token_is_lifetime(&*self.token) {\n+            let ex = if Parser::token_is_lifetime(&*self.token) {\n                 let lifetime = self.get_lifetime(&*self.token);\n                 self.bump();\n                 ExprAgain(Some(lifetime.name))\n@@ -2653,13 +2645,13 @@ impl Parser {\n     }\n \n     // For distingishing between struct literals and blocks\n-    fn looking_at_struct_literal(&self) -> bool {\n+    fn looking_at_struct_literal(&mut self) -> bool {\n         *self.token == token::LBRACE &&\n         (self.look_ahead(1, |t| token::is_plain_ident(t)) &&\n          self.look_ahead(2, |t| *t == token::COLON))\n     }\n \n-    fn parse_match_expr(&self) -> @Expr {\n+    fn parse_match_expr(&mut self) -> @Expr {\n         let lo = self.last_span.lo;\n         let discriminant = self.parse_expr();\n         self.commit_expr_expecting(discriminant, token::LBRACE);\n@@ -2700,12 +2692,12 @@ impl Parser {\n     }\n \n     // parse an expression\n-    pub fn parse_expr(&self) -> @Expr {\n+    pub fn parse_expr(&mut self) -> @Expr {\n         return self.parse_expr_res(UNRESTRICTED);\n     }\n \n     // parse an expression, subject to the given restriction\n-    fn parse_expr_res(&self, r: restriction) -> @Expr {\n+    fn parse_expr_res(&mut self, r: restriction) -> @Expr {\n         let old = *self.restriction;\n         *self.restriction = r;\n         let e = self.parse_assign_expr();\n@@ -2714,7 +2706,7 @@ impl Parser {\n     }\n \n     // parse the RHS of a local variable declaration (e.g. '= 14;')\n-    fn parse_initializer(&self) -> Option<@Expr> {\n+    fn parse_initializer(&mut self) -> Option<@Expr> {\n         if *self.token == token::EQ {\n             self.bump();\n             Some(self.parse_expr())\n@@ -2724,7 +2716,7 @@ impl Parser {\n     }\n \n     // parse patterns, separated by '|' s\n-    fn parse_pats(&self) -> ~[@Pat] {\n+    fn parse_pats(&mut self) -> ~[@Pat] {\n         let mut pats = ~[];\n         loop {\n             pats.push(self.parse_pat());\n@@ -2734,7 +2726,7 @@ impl Parser {\n     }\n \n     fn parse_pat_vec_elements(\n-        &self,\n+        &mut self,\n     ) -> (~[@Pat], Option<@Pat>, ~[@Pat]) {\n         let mut before = ~[];\n         let mut slice = None;\n@@ -2795,7 +2787,7 @@ impl Parser {\n     }\n \n     // parse the fields of a struct-like pattern\n-    fn parse_pat_fields(&self) -> (~[ast::FieldPat], bool) {\n+    fn parse_pat_fields(&mut self) -> (~[ast::FieldPat], bool) {\n         let mut fields = ~[];\n         let mut etc = false;\n         let mut first = true;\n@@ -2815,12 +2807,9 @@ impl Parser {\n             if etc {\n                 self.bump();\n                 if *self.token != token::RBRACE {\n-                    self.fatal(\n-                        format!(\n-                            \"expected `\\\\}`, found `{}`\",\n-                            self.this_token_to_str()\n-                        )\n-                    );\n+                    let token_str = self.this_token_to_str();\n+                    self.fatal(format!(\"expected `\\\\}`, found `{}`\",\n+                                       token_str))\n                 }\n                 etc = true;\n                 break;\n@@ -2842,9 +2831,10 @@ impl Parser {\n             let subpat;\n             if *self.token == token::COLON {\n                 match bind_type {\n-                    BindByRef(..) | BindByValue(MutMutable) =>\n-                        self.fatal(format!(\"unexpected `{}`\",\n-                                   self.this_token_to_str())),\n+                    BindByRef(..) | BindByValue(MutMutable) => {\n+                        let token_str = self.this_token_to_str();\n+                        self.fatal(format!(\"unexpected `{}`\", token_str))\n+                    }\n                     _ => {}\n                 }\n \n@@ -2863,7 +2853,7 @@ impl Parser {\n     }\n \n     // parse a pattern.\n-    pub fn parse_pat(&self) -> @Pat {\n+    pub fn parse_pat(&mut self) -> @Pat {\n         maybe_whole!(self, nt_pat);\n \n         let lo = self.span.lo;\n@@ -3141,7 +3131,7 @@ impl Parser {\n     // parse ident or ident @ pat\n     // used by the copy foo and ref foo patterns to give a good\n     // error message when parsing mistakes like ref foo(a,b)\n-    fn parse_pat_ident(&self,\n+    fn parse_pat_ident(&mut self,\n                        binding_mode: ast::BindingMode)\n                        -> ast::Pat_ {\n         if !is_plain_ident(&*self.token) {\n@@ -3172,7 +3162,7 @@ impl Parser {\n     }\n \n     // parse a local variable declaration\n-    fn parse_local(&self) -> @Local {\n+    fn parse_local(&mut self) -> @Local {\n         let lo = self.span.lo;\n         let pat = self.parse_pat();\n \n@@ -3193,7 +3183,7 @@ impl Parser {\n     }\n \n     // parse a \"let\" stmt\n-    fn parse_let(&self) -> @Decl {\n+    fn parse_let(&mut self) -> @Decl {\n         let lo = self.span.lo;\n         let local = self.parse_local();\n         while self.eat(&token::COMMA) {\n@@ -3204,7 +3194,7 @@ impl Parser {\n     }\n \n     // parse a structure field\n-    fn parse_name_and_ty(&self,\n+    fn parse_name_and_ty(&mut self,\n                          pr: visibility,\n                          attrs: ~[Attribute]) -> struct_field {\n         let lo = self.span.lo;\n@@ -3224,10 +3214,10 @@ impl Parser {\n \n     // parse a statement. may include decl.\n     // precondition: any attributes are parsed already\n-    pub fn parse_stmt(&self, item_attrs: ~[Attribute]) -> @Stmt {\n+    pub fn parse_stmt(&mut self, item_attrs: ~[Attribute]) -> @Stmt {\n         maybe_whole!(self, nt_stmt);\n \n-        fn check_expected_item(p: &Parser, found_attrs: bool) {\n+        fn check_expected_item(p: &mut Parser, found_attrs: bool) {\n             // If we have attributes then we should have an item\n             if found_attrs {\n                 p.span_err(*p.last_span, \"expected item after attributes\");\n@@ -3318,13 +3308,13 @@ impl Parser {\n     }\n \n     // is this expression a successfully-parsed statement?\n-    fn expr_is_complete(&self, e: @Expr) -> bool {\n+    fn expr_is_complete(&mut self, e: @Expr) -> bool {\n         return *self.restriction == RESTRICT_STMT_EXPR &&\n             !classify::expr_requires_semi_to_be_stmt(e);\n     }\n \n     // parse a block. No inner attrs are allowed.\n-    pub fn parse_block(&self) -> P<Block> {\n+    pub fn parse_block(&mut self) -> P<Block> {\n         maybe_whole!(no_clone self, nt_block);\n \n         let lo = self.span.lo;\n@@ -3337,7 +3327,7 @@ impl Parser {\n     }\n \n     // parse a block. Inner attrs are allowed.\n-    fn parse_inner_attrs_and_block(&self)\n+    fn parse_inner_attrs_and_block(&mut self)\n         -> (~[Attribute], P<Block>) {\n \n         maybe_whole!(pair_empty self, nt_block);\n@@ -3356,12 +3346,12 @@ impl Parser {\n     // I guess that also means \"already parsed the 'impure'\" if\n     // necessary, and this should take a qualifier.\n     // some blocks start with \"#{\"...\n-    fn parse_block_tail(&self, lo: BytePos, s: BlockCheckMode) -> P<Block> {\n+    fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> P<Block> {\n         self.parse_block_tail_(lo, s, ~[])\n     }\n \n     // parse the rest of a block expression or function body\n-    fn parse_block_tail_(&self, lo: BytePos, s: BlockCheckMode,\n+    fn parse_block_tail_(&mut self, lo: BytePos, s: BlockCheckMode,\n                          first_item_attrs: ~[Attribute]) -> P<Block> {\n         let mut stmts = ~[];\n         let mut expr = None;\n@@ -3490,7 +3480,7 @@ impl Parser {\n     // Returns \"Some(Empty)\" if there's a colon but nothing after (e.g. \"T:\")\n     // Returns \"Some(stuff)\" otherwise (e.g. \"T:stuff\").\n     // NB: The None/Some distinction is important for issue #7264.\n-    fn parse_optional_ty_param_bounds(&self) -> Option<OptVec<TyParamBound>> {\n+    fn parse_optional_ty_param_bounds(&mut self) -> Option<OptVec<TyParamBound>> {\n         if !self.eat(&token::COLON) {\n             return None;\n         }\n@@ -3523,7 +3513,7 @@ impl Parser {\n     }\n \n     // matches typaram = IDENT optbounds\n-    fn parse_ty_param(&self) -> TyParam {\n+    fn parse_ty_param(&mut self) -> TyParam {\n         let ident = self.parse_ident();\n         let opt_bounds = self.parse_optional_ty_param_bounds();\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n@@ -3535,7 +3525,7 @@ impl Parser {\n     // matches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n     //                  | ( < lifetimes , typaramseq ( , )? > )\n     // where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n-    pub fn parse_generics(&self) -> ast::Generics {\n+    pub fn parse_generics(&mut self) -> ast::Generics {\n         if self.eat(&token::LT) {\n             let lifetimes = self.parse_lifetimes();\n             let ty_params = self.parse_seq_to_gt(\n@@ -3547,15 +3537,16 @@ impl Parser {\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&self) -> (OptVec<ast::Lifetime>, ~[P<Ty>]) {\n+    fn parse_generic_values_after_lt(&mut self) -> (OptVec<ast::Lifetime>, ~[P<Ty>]) {\n         let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n             Some(token::COMMA),\n             |p| p.parse_ty(false));\n         (lifetimes, opt_vec::take_vec(result))\n     }\n \n-    fn parse_fn_args(&self, named_args: bool, allow_variadic: bool) -> (~[arg], bool) {\n+    fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n+                     -> (~[arg], bool) {\n         let sp = *self.span;\n         let mut args: ~[Option<arg>] =\n             self.parse_unspanned_seq(\n@@ -3602,7 +3593,7 @@ impl Parser {\n     }\n \n     // parse the argument list and result type of a function declaration\n-    pub fn parse_fn_decl(&self, allow_variadic: bool) -> P<fn_decl> {\n+    pub fn parse_fn_decl(&mut self, allow_variadic: bool) -> P<fn_decl> {\n \n         let (args, variadic) = self.parse_fn_args(true, allow_variadic);\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n@@ -3615,32 +3606,28 @@ impl Parser {\n         })\n     }\n \n-    fn is_self_ident(&self) -> bool {\n+    fn is_self_ident(&mut self) -> bool {\n         match *self.token {\n           token::IDENT(id, false) => id.name == special_idents::self_.name,\n           _ => false\n         }\n     }\n \n-    fn expect_self_ident(&self) {\n+    fn expect_self_ident(&mut self) {\n         if !self.is_self_ident() {\n-            self.fatal(\n-                format!(\n-                    \"expected `self` but found `{}`\",\n-                    self.this_token_to_str()\n-                )\n-            );\n+            let token_str = self.this_token_to_str();\n+            self.fatal(format!(\"expected `self` but found `{}`\", token_str))\n         }\n         self.bump();\n     }\n \n     // parse the argument list and result type of a function\n     // that may have a self type.\n-    fn parse_fn_decl_with_self(&self, parse_arg_fn: |&Parser| -> arg)\n+    fn parse_fn_decl_with_self(&mut self, parse_arg_fn: |&mut Parser| -> arg)\n                                -> (explicit_self, P<fn_decl>) {\n         fn maybe_parse_explicit_self(cnstr: |v: Mutability| ->\n                                         ast::explicit_self_,\n-                                     p: &Parser)\n+                                     p: &mut Parser)\n                                      -> ast::explicit_self_ {\n             // We need to make sure it isn't a type\n             if p.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) ||\n@@ -3657,10 +3644,11 @@ impl Parser {\n             }\n         }\n \n-        fn maybe_parse_borrowed_explicit_self(this: &Parser) -> ast::explicit_self_ {\n+        fn maybe_parse_borrowed_explicit_self(this: &mut Parser)\n+                                              -> ast::explicit_self_ {\n             // The following things are possible to see here:\n             //\n-            //     fn(&self)\n+            //     fn(&mut self)\n             //     fn(&mut self)\n             //     fn(&'lt self)\n             //     fn(&'lt mut self)\n@@ -3671,24 +3659,26 @@ impl Parser {\n                 this.bump();\n                 this.expect_self_ident();\n                 sty_region(None, MutImmutable)\n-            } else if this.look_ahead(1, |t| this.token_is_mutability(t)) &&\n+            } else if this.look_ahead(1, |t| Parser::token_is_mutability(t)) &&\n                     this.look_ahead(2,\n                                     |t| token::is_keyword(keywords::Self,\n                                                           t)) {\n                 this.bump();\n                 let mutability = this.parse_mutability();\n                 this.expect_self_ident();\n                 sty_region(None, mutability)\n-            } else if this.look_ahead(1, |t| this.token_is_lifetime(t)) &&\n+            } else if this.look_ahead(1, |t| Parser::token_is_lifetime(t)) &&\n                        this.look_ahead(2,\n                                        |t| token::is_keyword(keywords::Self,\n                                                              t)) {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n                 this.expect_self_ident();\n                 sty_region(Some(lifetime), MutImmutable)\n-            } else if this.look_ahead(1, |t| this.token_is_lifetime(t)) &&\n-                      this.look_ahead(2, |t| this.token_is_mutability(t)) &&\n+            } else if this.look_ahead(1, |t| Parser::token_is_lifetime(t)) &&\n+                      this.look_ahead(2, |t| {\n+                          Parser::token_is_mutability(t)\n+                      }) &&\n                       this.look_ahead(3, |t| token::is_keyword(keywords::Self,\n                                                                t)) {\n                 this.bump();\n@@ -3730,7 +3720,7 @@ impl Parser {\n             // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n             // emitting cryptic \"unexpected token\" errors.\n             self.bump();\n-            let mutability = if self.token_is_mutability(self.token) {\n+            let mutability = if Parser::token_is_mutability(self.token) {\n                 self.parse_mutability()\n             } else { MutImmutable };\n             if self.is_self_ident() {\n@@ -3739,13 +3729,13 @@ impl Parser {\n             }\n             sty_value(mutability)\n           }\n-          _ if self.token_is_mutability(self.token) &&\n+          _ if Parser::token_is_mutability(self.token) &&\n                self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n             let mutability = self.parse_mutability();\n             self.expect_self_ident();\n             sty_value(mutability)\n           }\n-          _ if self.token_is_mutability(self.token) &&\n+          _ if Parser::token_is_mutability(self.token) &&\n                self.look_ahead(1, |t| *t == token::TILDE) &&\n                self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n             let mutability = self.parse_mutability();\n@@ -3775,21 +3765,16 @@ impl Parser {\n                     fn_inputs = ~[];\n                 }\n                 _ => {\n-                    self.fatal(\n-                        format!(\n-                            \"expected `,` or `)`, found `{}`\",\n-                            self.this_token_to_str()\n-                        )\n-                    );\n+                    let token_str = self.this_token_to_str();\n+                    self.fatal(format!(\"expected `,` or `)`, found `{}`\",\n+                                       token_str))\n                 }\n             }\n         } else {\n             let sep = seq_sep_trailing_disallowed(token::COMMA);\n-            fn_inputs = self.parse_seq_to_before_end(\n-                &token::RPAREN,\n-                sep,\n-                parse_arg_fn\n-            );\n+            fn_inputs = self.parse_seq_to_before_end(&token::RPAREN,\n+                                                     sep,\n+                                                     parse_arg_fn);\n         }\n \n         self.expect(&token::RPAREN);\n@@ -3809,7 +3794,7 @@ impl Parser {\n     }\n \n     // parse the |arg, arg| header on a lambda\n-    fn parse_fn_block_decl(&self) -> P<fn_decl> {\n+    fn parse_fn_block_decl(&mut self) -> P<fn_decl> {\n         let inputs_captures = {\n             if self.eat(&token::OROR) {\n                 ~[]\n@@ -3837,7 +3822,7 @@ impl Parser {\n     }\n \n     // Parses the `(arg, arg) -> return_type` header on a procedure.\n-    fn parse_proc_decl(&self) -> P<fn_decl> {\n+    fn parse_proc_decl(&mut self) -> P<fn_decl> {\n         let inputs =\n             self.parse_unspanned_seq(&token::LPAREN,\n                                      &token::RPAREN,\n@@ -3863,13 +3848,13 @@ impl Parser {\n     }\n \n     // parse the name and optional generic types of a function header.\n-    fn parse_fn_header(&self) -> (Ident, ast::Generics) {\n+    fn parse_fn_header(&mut self) -> (Ident, ast::Generics) {\n         let id = self.parse_ident();\n         let generics = self.parse_generics();\n         (id, generics)\n     }\n \n-    fn mk_item(&self, lo: BytePos, hi: BytePos, ident: Ident,\n+    fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n                node: item_, vis: visibility,\n                attrs: ~[Attribute]) -> @item {\n         @ast::item { ident: ident,\n@@ -3881,7 +3866,7 @@ impl Parser {\n     }\n \n     // parse an item-position function declaration.\n-    fn parse_item_fn(&self, purity: purity, abis: AbiSet) -> item_info {\n+    fn parse_item_fn(&mut self, purity: purity, abis: AbiSet) -> item_info {\n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(false);\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n@@ -3891,7 +3876,7 @@ impl Parser {\n     }\n \n     // parse a method in a trait impl, starting with `attrs` attributes.\n-    fn parse_method(&self, already_parsed_attrs: Option<~[Attribute]>) -> @method {\n+    fn parse_method(&mut self, already_parsed_attrs: Option<~[Attribute]>) -> @method {\n         let next_attrs = self.parse_outer_attributes();\n         let attrs = match already_parsed_attrs {\n             Some(mut a) => { a.push_all_move(next_attrs); a }\n@@ -3927,7 +3912,7 @@ impl Parser {\n     }\n \n     // parse trait Foo { ... }\n-    fn parse_item_trait(&self) -> item_info {\n+    fn parse_item_trait(&mut self) -> item_info {\n         let ident = self.parse_ident();\n         let tps = self.parse_generics();\n \n@@ -3947,7 +3932,7 @@ impl Parser {\n     // Parses two variants (with the region/type params always optional):\n     //    impl<T> Foo { ... }\n     //    impl<T> ToStr for ~[T] { ... }\n-    fn parse_item_impl(&self) -> item_info {\n+    fn parse_item_impl(&mut self) -> item_info {\n         // First, parse type parameters if necessary.\n         let generics = self.parse_generics();\n \n@@ -4008,15 +3993,15 @@ impl Parser {\n     }\n \n     // parse a::B<~str,int>\n-    fn parse_trait_ref(&self) -> trait_ref {\n+    fn parse_trait_ref(&mut self) -> trait_ref {\n         ast::trait_ref {\n             path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n             ref_id: ast::DUMMY_NODE_ID,\n         }\n     }\n \n     // parse B + C<~str,int> + D\n-    fn parse_trait_ref_list(&self, ket: &token::Token) -> ~[trait_ref] {\n+    fn parse_trait_ref_list(&mut self, ket: &token::Token) -> ~[trait_ref] {\n         self.parse_seq_to_before_end(\n             ket,\n             seq_sep_trailing_disallowed(token::BINOP(token::PLUS)),\n@@ -4025,7 +4010,7 @@ impl Parser {\n     }\n \n     // parse struct Foo { ... }\n-    fn parse_item_struct(&self) -> item_info {\n+    fn parse_item_struct(&mut self) -> item_info {\n         let class_name = self.parse_ident();\n         let generics = self.parse_generics();\n \n@@ -4052,7 +4037,7 @@ impl Parser {\n                 &token::RPAREN,\n                 seq_sep_trailing_allowed(token::COMMA),\n                 |p| {\n-                let attrs = self.parse_outer_attributes();\n+                let attrs = p.parse_outer_attributes();\n                 let lo = p.span.lo;\n                 let struct_field_ = ast::struct_field_ {\n                     kind: unnamed_field,\n@@ -4068,13 +4053,10 @@ impl Parser {\n             is_tuple_like = true;\n             fields = ~[];\n         } else {\n-            self.fatal(\n-                format!(\n-                    \"expected `\\\\{`, `(`, or `;` after struct name \\\n-                    but found `{}`\",\n-                    self.this_token_to_str()\n-                )\n-            );\n+            let token_str = self.this_token_to_str();\n+            self.fatal(format!(\"expected `\\\\{`, `(`, or `;` after struct \\\n+                                name but found `{}`\",\n+                               token_str))\n         }\n \n         let _ = ast::DUMMY_NODE_ID;  // XXX: Workaround for crazy bug.\n@@ -4088,7 +4070,7 @@ impl Parser {\n     }\n \n     // parse a structure field declaration\n-    pub fn parse_single_struct_field(&self,\n+    pub fn parse_single_struct_field(&mut self,\n                                      vis: visibility,\n                                      attrs: ~[Attribute])\n                                      -> struct_field {\n@@ -4099,16 +4081,17 @@ impl Parser {\n             }\n             token::RBRACE => {}\n             _ => {\n+                let token_str = self.this_token_to_str();\n                 self.span_fatal(*self.span,\n                                 format!(\"expected `,`, or `\\\\}` but found `{}`\",\n-                                     self.this_token_to_str()));\n+                                        token_str))\n             }\n         }\n         a_var\n     }\n \n     // parse an element of a struct definition\n-    fn parse_struct_decl_field(&self) -> struct_field {\n+    fn parse_struct_decl_field(&mut self) -> struct_field {\n \n         let attrs = self.parse_outer_attributes();\n \n@@ -4124,15 +4107,15 @@ impl Parser {\n     }\n \n     // parse visiility: PUB, PRIV, or nothing\n-    fn parse_visibility(&self) -> visibility {\n+    fn parse_visibility(&mut self) -> visibility {\n         if self.eat_keyword(keywords::Pub) { public }\n         else if self.eat_keyword(keywords::Priv) { private }\n         else { inherited }\n     }\n \n     // given a termination token and a vector of already-parsed\n     // attributes (of length 0 or 1), parse all of the items in a module\n-    fn parse_mod_items(&self,\n+    fn parse_mod_items(&mut self,\n                        term: token::Token,\n                        first_item_attrs: ~[Attribute])\n                        -> _mod {\n@@ -4167,8 +4150,9 @@ impl Parser {\n                                  the module\");\n               }\n               _ => {\n-                self.fatal(format!(\"expected item but found `{}`\",\n-                                self.this_token_to_str()));\n+                  let token_str = self.this_token_to_str();\n+                  self.fatal(format!(\"expected item but found `{}`\",\n+                                     token_str))\n               }\n             }\n         }\n@@ -4181,7 +4165,7 @@ impl Parser {\n         ast::_mod { view_items: view_items, items: items }\n     }\n \n-    fn parse_item_const(&self) -> item_info {\n+    fn parse_item_const(&mut self) -> item_info {\n         let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n@@ -4193,7 +4177,7 @@ impl Parser {\n     }\n \n     // parse a `mod <foo> { ... }` or `mod <foo>;` item\n-    fn parse_item_mod(&self, outer_attrs: &[Attribute]) -> item_info {\n+    fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> item_info {\n         let id_span = *self.span;\n         let id = self.parse_ident();\n         if *self.token == token::SEMI {\n@@ -4212,7 +4196,7 @@ impl Parser {\n         }\n     }\n \n-    fn push_mod_path(&self, id: Ident, attrs: &[Attribute]) {\n+    fn push_mod_path(&mut self, id: Ident, attrs: &[Attribute]) {\n         let default_path = token::interner_get(id.name);\n         let file_path = match ::attr::first_attr_value_str_by_name(attrs,\n                                                                    \"path\") {\n@@ -4222,12 +4206,12 @@ impl Parser {\n         self.mod_path_stack.push(file_path)\n     }\n \n-    fn pop_mod_path(&self) {\n+    fn pop_mod_path(&mut self) {\n         self.mod_path_stack.pop();\n     }\n \n     // read a module from a source file.\n-    fn eval_src_mod(&self,\n+    fn eval_src_mod(&mut self,\n                     id: ast::Ident,\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n@@ -4268,7 +4252,7 @@ impl Parser {\n                                     id_sp)\n     }\n \n-    fn eval_src_mod_from_path(&self,\n+    fn eval_src_mod_from_path(&mut self,\n                               path: Path,\n                               outer_attrs: ~[ast::Attribute],\n                               id_sp: Span) -> (ast::item_, ~[ast::Attribute]) {\n@@ -4288,7 +4272,7 @@ impl Parser {\n         }\n         self.sess.included_mod_stack.push(path.clone());\n \n-        let p0 =\n+        let mut p0 =\n             new_sub_parser_from_file(self.sess,\n                                      self.cfg.clone(),\n                                      &path,\n@@ -4302,7 +4286,7 @@ impl Parser {\n     }\n \n     // parse a function declaration from a foreign module\n-    fn parse_item_foreign_fn(&self, vis: ast::visibility,\n+    fn parse_item_foreign_fn(&mut self, vis: ast::visibility,\n                              attrs: ~[Attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n \n@@ -4325,7 +4309,7 @@ impl Parser {\n     }\n \n     // parse a static item from a foreign module\n-    fn parse_item_foreign_static(&self, vis: ast::visibility,\n+    fn parse_item_foreign_static(&mut self, vis: ast::visibility,\n                                  attrs: ~[Attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n \n@@ -4346,7 +4330,7 @@ impl Parser {\n     }\n \n     // parse safe/unsafe and fn\n-    fn parse_fn_purity(&self) -> purity {\n+    fn parse_fn_purity(&mut self) -> purity {\n         if self.eat_keyword(keywords::Fn) { impure_fn }\n         else if self.eat_keyword(keywords::Unsafe) {\n             self.expect_keyword(keywords::Fn);\n@@ -4358,7 +4342,7 @@ impl Parser {\n \n     // at this point, this is essentially a wrapper for\n     // parse_foreign_items.\n-    fn parse_foreign_mod_items(&self,\n+    fn parse_foreign_mod_items(&mut self,\n                                abis: AbiSet,\n                                first_item_attrs: ~[Attribute])\n                                -> foreign_mod {\n@@ -4381,7 +4365,7 @@ impl Parser {\n     }\n \n     // parse extern foo; or extern mod foo { ... } or extern { ... }\n-    fn parse_item_foreign_mod(&self,\n+    fn parse_item_foreign_mod(&mut self,\n                               lo: BytePos,\n                               opt_abis: Option<AbiSet>,\n                               visibility: visibility,\n@@ -4393,9 +4377,10 @@ impl Parser {\n             must_be_named_mod = true;\n             self.expect_keyword(keywords::Mod);\n         } else if *self.token != token::LBRACE {\n+            let token_str = self.this_token_to_str();\n             self.span_fatal(*self.span,\n                             format!(\"expected `\\\\{` or `mod` but found `{}`\",\n-                                 self.this_token_to_str()));\n+                                    token_str))\n         }\n \n         let (named, maybe_path, ident) = match *self.token {\n@@ -4410,10 +4395,11 @@ impl Parser {\n             }\n             _ => {\n                 if must_be_named_mod {\n+                    let token_str = self.this_token_to_str();\n                     self.span_fatal(*self.span,\n                                     format!(\"expected foreign module name but \\\n-                                          found `{}`\",\n-                                         self.this_token_to_str()));\n+                                             found `{}`\",\n+                                            token_str))\n                 }\n \n                 (false, None,\n@@ -4434,12 +4420,13 @@ impl Parser {\n             let m = self.parse_foreign_mod_items(abis, next);\n             self.expect(&token::RBRACE);\n \n-            return iovi_item(self.mk_item(lo,\n-                                          self.last_span.hi,\n-                                          ident,\n-                                          item_foreign_mod(m),\n-                                          visibility,\n-                                          maybe_append(attrs, Some(inner))));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    ident,\n+                                    item_foreign_mod(m),\n+                                    visibility,\n+                                    maybe_append(attrs, Some(inner)));\n+            return iovi_item(item);\n         }\n \n         if opt_abis.is_some() {\n@@ -4465,7 +4452,7 @@ impl Parser {\n     }\n \n     // parse type Foo = Bar;\n-    fn parse_item_type(&self) -> item_info {\n+    fn parse_item_type(&mut self) -> item_info {\n         let ident = self.parse_ident();\n         let tps = self.parse_generics();\n         self.expect(&token::EQ);\n@@ -4476,7 +4463,7 @@ impl Parser {\n \n     // parse a structure-like enum variant definition\n     // this should probably be renamed or refactored...\n-    fn parse_struct_def(&self) -> @struct_def {\n+    fn parse_struct_def(&mut self) -> @struct_def {\n         let mut fields: ~[struct_field] = ~[];\n         while *self.token != token::RBRACE {\n             fields.push(self.parse_struct_decl_field());\n@@ -4490,7 +4477,7 @@ impl Parser {\n     }\n \n     // parse the part of an \"enum\" decl following the '{'\n-    fn parse_enum_def(&self, _generics: &ast::Generics) -> enum_def {\n+    fn parse_enum_def(&mut self, _generics: &ast::Generics) -> enum_def {\n         let mut variants = ~[];\n         let mut all_nullary = true;\n         let mut have_disr = false;\n@@ -4554,7 +4541,7 @@ impl Parser {\n     }\n \n     // parse an \"enum\" declaration\n-    fn parse_item_enum(&self) -> item_info {\n+    fn parse_item_enum(&mut self) -> item_info {\n         let id = self.parse_ident();\n         let generics = self.parse_generics();\n         self.expect(&token::LBRACE);\n@@ -4563,7 +4550,7 @@ impl Parser {\n         (id, item_enum(enum_definition, generics), None)\n     }\n \n-    fn fn_expr_lookahead(&self, tok: &token::Token) -> bool {\n+    fn fn_expr_lookahead(tok: &token::Token) -> bool {\n         match *tok {\n           token::LPAREN | token::AT | token::TILDE | token::BINOP(_) => true,\n           _ => false\n@@ -4572,7 +4559,7 @@ impl Parser {\n \n     // Parses a string as an ABI spec on an extern type or module. Consumes\n     // the `extern` keyword, if one is found.\n-    fn parse_opt_abis(&self) -> Option<AbiSet> {\n+    fn parse_opt_abis(&mut self) -> Option<AbiSet> {\n         if !self.eat_keyword(keywords::Extern) {\n             return None\n         }\n@@ -4620,7 +4607,7 @@ impl Parser {\n     // flags; on failure, return iovi_none.\n     // NB: this function no longer parses the items inside an\n     // extern mod.\n-    fn parse_item_or_view_item(&self,\n+    fn parse_item_or_view_item(&mut self,\n                                attrs: ~[Attribute],\n                                macros_allowed: bool)\n                                -> item_or_view_item {\n@@ -4660,10 +4647,13 @@ impl Parser {\n                 let abis = opt_abis.unwrap_or(AbiSet::C());\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(extern_fn, abis);\n-                return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n-                                              item_, visibility,\n-                                              maybe_append(attrs,\n-                                                           extra_attrs)));\n+                let item = self.mk_item(lo,\n+                                        self.last_span.hi,\n+                                        ident,\n+                                        item_,\n+                                        visibility,\n+                                        maybe_append(attrs, extra_attrs));\n+                return iovi_item(item);\n             } else  {\n                 // EXTERN MODULE ITEM (iovi_view_item)\n                 return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs,\n@@ -4675,19 +4665,27 @@ impl Parser {\n             // STATIC ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return iovi_item(item);\n         }\n         if self.is_keyword(keywords::Fn) &&\n-                self.look_ahead(1, |f| !self.fn_expr_lookahead(f)) {\n+                self.look_ahead(1, |f| !Parser::fn_expr_lookahead(f)) {\n             // FUNCTION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(impure_fn, AbiSet::Rust());\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return iovi_item(item);\n         }\n         if self.is_keyword(keywords::Unsafe)\n             && self.look_ahead(1u, |t| *t != token::LBRACE) {\n@@ -4696,57 +4694,85 @@ impl Parser {\n             self.expect_keyword(keywords::Fn);\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(unsafe_fn, AbiSet::Rust());\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return iovi_item(item);\n         }\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return iovi_item(item);\n         }\n         if self.eat_keyword(keywords::Type) {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return iovi_item(item);\n         }\n         if self.eat_keyword(keywords::Enum) {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return iovi_item(item);\n         }\n         if self.eat_keyword(keywords::Trait) {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return iovi_item(item);\n         }\n         if self.eat_keyword(keywords::Impl) {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_impl();\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return iovi_item(item);\n         }\n         if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct();\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n-                                          visibility,\n-                                          maybe_append(attrs, extra_attrs)));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return iovi_item(item);\n         }\n         self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n     }\n \n     // parse a foreign item; on failure, return iovi_none.\n-    fn parse_foreign_item(&self,\n+    fn parse_foreign_item(&mut self,\n                           attrs: ~[Attribute],\n                           macros_allowed: bool)\n                           -> item_or_view_item {\n@@ -4770,7 +4796,7 @@ impl Parser {\n \n     // this is the fall-through for parsing items.\n     fn parse_macro_use_or_failure(\n-        &self,\n+        &mut self,\n         attrs: ~[Attribute],\n         macros_allowed: bool,\n         lo : BytePos,\n@@ -4812,8 +4838,13 @@ impl Parser {\n                                              span: mk_sp(self.span.lo,\n                                                          self.span.hi) };\n             let item_ = item_mac(m);\n-            return iovi_item(self.mk_item(lo, self.last_span.hi, id, item_,\n-                                          visibility, attrs));\n+            let item = self.mk_item(lo,\n+                                    self.last_span.hi,\n+                                    id,\n+                                    item_,\n+                                    visibility,\n+                                    attrs);\n+            return iovi_item(item);\n         }\n \n         // FAILURE TO PARSE ITEM\n@@ -4830,7 +4861,7 @@ impl Parser {\n         return iovi_none(attrs);\n     }\n \n-    pub fn parse_item(&self, attrs: ~[Attribute]) -> Option<@ast::item> {\n+    pub fn parse_item(&mut self, attrs: ~[Attribute]) -> Option<@ast::item> {\n         match self.parse_item_or_view_item(attrs, true) {\n             iovi_none(_) => None,\n             iovi_view_item(_) =>\n@@ -4842,7 +4873,7 @@ impl Parser {\n     }\n \n     // parse, e.g., \"use a::b::{z,y}\"\n-    fn parse_use(&self) -> view_item_ {\n+    fn parse_use(&mut self) -> view_item_ {\n         return view_item_use(self.parse_view_paths());\n     }\n \n@@ -4852,7 +4883,7 @@ impl Parser {\n     // | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n     // | MOD? non_global_path MOD_SEP STAR\n     // | MOD? non_global_path\n-    fn parse_view_path(&self) -> @view_path {\n+    fn parse_view_path(&mut self) -> @view_path {\n         let lo = self.span.lo;\n \n         if *self.token == token::LBRACE {\n@@ -4976,7 +5007,7 @@ impl Parser {\n     }\n \n     // matches view_paths = view_path | view_path , view_paths\n-    fn parse_view_paths(&self) -> ~[@view_path] {\n+    fn parse_view_paths(&mut self) -> ~[@view_path] {\n         let mut vp = ~[self.parse_view_path()];\n         while *self.token == token::COMMA {\n             self.bump();\n@@ -4990,7 +5021,7 @@ impl Parser {\n     // text that can't be parsed as an item\n     // - mod_items uses extern_mod_allowed = true\n     // - block_tail_ uses extern_mod_allowed = false\n-    fn parse_items_and_view_items(&self,\n+    fn parse_items_and_view_items(&mut self,\n                                   first_item_attrs: ~[Attribute],\n                                   mut extern_mod_allowed: bool,\n                                   macros_allowed: bool)\n@@ -5074,7 +5105,7 @@ impl Parser {\n \n     // Parses a sequence of foreign items. Stops when it finds program\n     // text that can't be parsed as an item\n-    fn parse_foreign_items(&self, first_item_attrs: ~[Attribute],\n+    fn parse_foreign_items(&mut self, first_item_attrs: ~[Attribute],\n                            macros_allowed: bool)\n         -> ParsedItemsAndViewItems {\n         let mut attrs = vec::append(first_item_attrs,\n@@ -5115,7 +5146,7 @@ impl Parser {\n \n     // Parses a source module as a crate. This is the main\n     // entry point for the parser.\n-    pub fn parse_crate_mod(&self) -> Crate {\n+    pub fn parse_crate_mod(&mut self) -> Crate {\n         let lo = self.span.lo;\n         // parse the crate's inner attrs, maybe (oops) one\n         // of the attrs of an item:\n@@ -5132,7 +5163,7 @@ impl Parser {\n         }\n     }\n \n-    pub fn parse_optional_str(&self) -> Option<(@str, ast::StrStyle)> {\n+    pub fn parse_optional_str(&mut self) -> Option<(@str, ast::StrStyle)> {\n         let (s, style) = match *self.token {\n             token::LIT_STR(s) => (s, ast::CookedStr),\n             token::LIT_STR_RAW(s, n) => (s, ast::RawStr(n)),\n@@ -5142,7 +5173,7 @@ impl Parser {\n         Some((ident_to_str(&s), style))\n     }\n \n-    pub fn parse_str(&self) -> (@str, StrStyle) {\n+    pub fn parse_str(&mut self) -> (@str, StrStyle) {\n         match self.parse_optional_str() {\n             Some(s) => { s }\n             _ =>  self.fatal(\"expected string literal\")"}]}