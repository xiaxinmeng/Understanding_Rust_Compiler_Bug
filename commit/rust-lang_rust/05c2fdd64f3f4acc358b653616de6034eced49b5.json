{"sha": "05c2fdd64f3f4acc358b653616de6034eced49b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YzJmZGQ2NGYzZjRhY2MzNThiNjUzNjE2ZGU2MDM0ZWNlZDQ5YjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-24T17:48:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-24T17:48:42Z"}, "message": "Auto merge of #36639 - pcwalton:const-prop, r=eddyb\n\nlibrustc_mir: Propagate constants during copy propagation.\n\nThis optimization kicks in a lot when bootstrapping the compiler.\n\nr? @eddyb", "tree": {"sha": "204d1d8f2387df1a37b7aa3e42860fba466ef6e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/204d1d8f2387df1a37b7aa3e42860fba466ef6e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05c2fdd64f3f4acc358b653616de6034eced49b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05c2fdd64f3f4acc358b653616de6034eced49b5", "html_url": "https://github.com/rust-lang/rust/commit/05c2fdd64f3f4acc358b653616de6034eced49b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05c2fdd64f3f4acc358b653616de6034eced49b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdad70213b32454837c0ed16dbbac3954325feea", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdad70213b32454837c0ed16dbbac3954325feea", "html_url": "https://github.com/rust-lang/rust/commit/bdad70213b32454837c0ed16dbbac3954325feea"}, {"sha": "79cb2dbfac51c79f08f823519c2cc69bf5382f6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/79cb2dbfac51c79f08f823519c2cc69bf5382f6f", "html_url": "https://github.com/rust-lang/rust/commit/79cb2dbfac51c79f08f823519c2cc69bf5382f6f"}], "stats": {"total": 298, "additions": 226, "deletions": 72}, "files": [{"sha": "11b4441c8460a62e486194febb783ba9b2d1ec0c", "filename": "src/librustc_mir/def_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05c2fdd64f3f4acc358b653616de6034eced49b5/src%2Flibrustc_mir%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c2fdd64f3f4acc358b653616de6034eced49b5/src%2Flibrustc_mir%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdef_use.rs?ref=05c2fdd64f3f4acc358b653616de6034eced49b5", "patch": "@@ -165,22 +165,22 @@ impl<'tcx, F> MutVisitor<'tcx> for MutateUseVisitor<'tcx, F>\n /// A small structure that enables various metadata of the MIR to be queried\n /// without a reference to the MIR itself.\n #[derive(Clone, Copy)]\n-struct MirSummary {\n+pub struct MirSummary {\n     arg_count: usize,\n     var_count: usize,\n     temp_count: usize,\n }\n \n impl MirSummary {\n-    fn new(mir: &Mir) -> MirSummary {\n+    pub fn new(mir: &Mir) -> MirSummary {\n         MirSummary {\n             arg_count: mir.arg_decls.len(),\n             var_count: mir.var_decls.len(),\n             temp_count: mir.temp_decls.len(),\n         }\n     }\n \n-    fn local_index<'tcx>(&self, lvalue: &Lvalue<'tcx>) -> Option<Local> {\n+    pub fn local_index<'tcx>(&self, lvalue: &Lvalue<'tcx>) -> Option<Local> {\n         match *lvalue {\n             Lvalue::Arg(arg) => Some(Local::new(arg.index())),\n             Lvalue::Var(var) => Some(Local::new(var.index() + self.arg_count)),"}, {"sha": "79fd16012d9ee24780e6449bd8baa4706a3ad109", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 212, "deletions": 58, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/05c2fdd64f3f4acc358b653616de6034eced49b5/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c2fdd64f3f4acc358b653616de6034eced49b5/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=05c2fdd64f3f4acc358b653616de6034eced49b5", "patch": "@@ -29,18 +29,50 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use def_use::DefUseAnalysis;\n-use rustc::mir::repr::{Local, Lvalue, Mir, Operand, Rvalue, StatementKind};\n+use def_use::{DefUseAnalysis, MirSummary};\n+use rustc::mir::repr::{Constant, Local, Location, Lvalue, Mir, Operand, Rvalue, StatementKind};\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::indexed_vec::Idx;\n+use transform::qualify_consts;\n \n pub struct CopyPropagation;\n \n impl Pass for CopyPropagation {}\n \n impl<'tcx> MirPass<'tcx> for CopyPropagation {\n-    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self,\n+                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    source: MirSource,\n+                    mir: &mut Mir<'tcx>) {\n+        match source {\n+            MirSource::Const(_) => {\n+                // Don't run on constants, because constant qualification might reject the\n+                // optimized IR.\n+                return\n+            }\n+            MirSource::Static(..) | MirSource::Promoted(..) => {\n+                // Don't run on statics and promoted statics, because trans might not be able to\n+                // evaluate the optimized IR.\n+                return\n+            }\n+            MirSource::Fn(function_node_id) => {\n+                if qualify_consts::is_const_fn(tcx, tcx.map.local_def_id(function_node_id)) {\n+                    // Don't run on const functions, as, again, trans might not be able to evaluate\n+                    // the optimized IR.\n+                    return\n+                }\n+            }\n+        }\n+\n+        // We only run when the MIR optimization level is at least 1. This avoids messing up debug\n+        // info.\n+        match tcx.sess.opts.debugging_opts.mir_opt_level {\n+            Some(0) | None => return,\n+            _ => {}\n+        }\n+\n         loop {\n             let mut def_use_analysis = DefUseAnalysis::new(mir);\n             def_use_analysis.analyze(mir);\n@@ -50,7 +82,7 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                 let dest_local = Local::new(dest_local_index);\n                 debug!(\"Considering destination local: {}\", mir.format_local(dest_local));\n \n-                let src_local;\n+                let action;\n                 let location;\n                 {\n                     // The destination must have exactly one def.\n@@ -88,66 +120,114 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     };\n \n                     // That use of the source must be an assignment.\n-                    let src_lvalue = match statement.kind {\n-                        StatementKind::Assign(\n-                                ref dest_lvalue,\n-                                Rvalue::Use(Operand::Consume(ref src_lvalue)))\n-                                if Some(dest_local) == mir.local_index(dest_lvalue) => {\n-                            src_lvalue\n+                    match statement.kind {\n+                        StatementKind::Assign(ref dest_lvalue, Rvalue::Use(ref operand)) if\n+                                Some(dest_local) == mir.local_index(dest_lvalue) => {\n+                            let maybe_action = match *operand {\n+                                Operand::Consume(ref src_lvalue) => {\n+                                    Action::local_copy(mir, &def_use_analysis, src_lvalue)\n+                                }\n+                                Operand::Constant(ref src_constant) => {\n+                                    Action::constant(src_constant)\n+                                }\n+                            };\n+                            match maybe_action {\n+                                Some(this_action) => action = this_action,\n+                                None => continue,\n+                            }\n                         }\n                         _ => {\n                             debug!(\"  Can't copy-propagate local: source use is not an \\\n                                     assignment\");\n                             continue\n                         }\n-                    };\n-                    src_local = match mir.local_index(src_lvalue) {\n-                        Some(src_local) => src_local,\n-                        None => {\n-                            debug!(\"  Can't copy-propagate local: source is not a local\");\n-                            continue\n-                        }\n-                    };\n-\n-                    // There must be exactly one use of the source used in a statement (not in a\n-                    // terminator).\n-                    let src_use_info = def_use_analysis.local_info(src_local);\n-                    let src_use_count = src_use_info.use_count();\n-                    if src_use_count == 0 {\n-                        debug!(\"  Can't copy-propagate local: no uses\");\n-                        continue\n-                    }\n-                    if src_use_count != 1 {\n-                        debug!(\"  Can't copy-propagate local: {} uses\", src_use_info.use_count());\n-                        continue\n-                    }\n-\n-                    // Verify that the source doesn't change in between. This is done\n-                    // conservatively for now, by ensuring that the source has exactly one\n-                    // mutation. The goal is to prevent things like:\n-                    //\n-                    //     DEST = SRC;\n-                    //     SRC = X;\n-                    //     USE(DEST);\n-                    //\n-                    // From being misoptimized into:\n-                    //\n-                    //     SRC = X;\n-                    //     USE(SRC);\n-                    let src_def_count = src_use_info.def_count_not_including_drop();\n-                    if src_def_count != 1 {\n-                        debug!(\"  Can't copy-propagate local: {} defs of src\",\n-                               src_use_info.def_count_not_including_drop());\n-                        continue\n                     }\n                 }\n \n-                // If all checks passed, then we can eliminate the destination and the assignment.\n+                changed = action.perform(mir, &def_use_analysis, dest_local, location) || changed;\n+                // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n+                // regenerating the chains.\n+                break\n+            }\n+            if !changed {\n+                break\n+            }\n+        }\n+    }\n+}\n+\n+enum Action<'tcx> {\n+    PropagateLocalCopy(Local),\n+    PropagateConstant(Constant<'tcx>),\n+}\n+\n+impl<'tcx> Action<'tcx> {\n+    fn local_copy(mir: &Mir<'tcx>, def_use_analysis: &DefUseAnalysis, src_lvalue: &Lvalue<'tcx>)\n+                  -> Option<Action<'tcx>> {\n+        // The source must be a local.\n+        let src_local = match mir.local_index(src_lvalue) {\n+            Some(src_local) => src_local,\n+            None => {\n+                debug!(\"  Can't copy-propagate local: source is not a local\");\n+                return None\n+            }\n+        };\n+\n+        // We're trying to copy propagate a local.\n+        // There must be exactly one use of the source used in a statement (not in a terminator).\n+        let src_use_info = def_use_analysis.local_info(src_local);\n+        let src_use_count = src_use_info.use_count();\n+        if src_use_count == 0 {\n+            debug!(\"  Can't copy-propagate local: no uses\");\n+            return None\n+        }\n+        if src_use_count != 1 {\n+            debug!(\"  Can't copy-propagate local: {} uses\", src_use_info.use_count());\n+            return None\n+        }\n+\n+        // Verify that the source doesn't change in between. This is done conservatively for now,\n+        // by ensuring that the source has exactly one mutation. The goal is to prevent things\n+        // like:\n+        //\n+        //     DEST = SRC;\n+        //     SRC = X;\n+        //     USE(DEST);\n+        //\n+        // From being misoptimized into:\n+        //\n+        //     SRC = X;\n+        //     USE(SRC);\n+        let src_def_count = src_use_info.def_count_not_including_drop();\n+        if src_def_count != 1 {\n+            debug!(\"  Can't copy-propagate local: {} defs of src\",\n+                   src_use_info.def_count_not_including_drop());\n+            return None\n+        }\n+\n+        Some(Action::PropagateLocalCopy(src_local))\n+    }\n+\n+    fn constant(src_constant: &Constant<'tcx>) -> Option<Action<'tcx>> {\n+        Some(Action::PropagateConstant((*src_constant).clone()))\n+    }\n+\n+    fn perform(self,\n+               mir: &mut Mir<'tcx>,\n+               def_use_analysis: &DefUseAnalysis<'tcx>,\n+               dest_local: Local,\n+               location: Location)\n+               -> bool {\n+        match self {\n+            Action::PropagateLocalCopy(src_local) => {\n+                // Eliminate the destination and the assignment.\n                 //\n                 // First, remove all markers.\n                 //\n                 // FIXME(pcwalton): Don't do this. Merge live ranges instead.\n-                debug!(\"  Replacing all uses of {}\", mir.format_local(dest_local));\n+                debug!(\"  Replacing all uses of {} with {} (local)\",\n+                       mir.format_local(dest_local),\n+                       mir.format_local(src_local));\n                 for lvalue_use in &def_use_analysis.local_info(dest_local).defs_and_uses {\n                     if lvalue_use.context.is_storage_marker() {\n                         mir.make_statement_nop(lvalue_use.location)\n@@ -159,22 +239,96 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     }\n                 }\n \n-                // Now replace all uses of the destination local with the source local.\n+                // Replace all uses of the destination local with the source local.\n                 let src_lvalue = Lvalue::from_local(mir, src_local);\n                 def_use_analysis.replace_all_defs_and_uses_with(dest_local, mir, src_lvalue);\n \n                 // Finally, zap the now-useless assignment instruction.\n+                debug!(\"  Deleting assignment\");\n                 mir.make_statement_nop(location);\n \n-                changed = true;\n-                // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n-                // regenerating the chains.\n-                break\n+                true\n             }\n-            if !changed {\n-                break\n+            Action::PropagateConstant(src_constant) => {\n+                // First, remove all markers.\n+                //\n+                // FIXME(pcwalton): Don't do this. Merge live ranges instead.\n+                debug!(\"  Replacing all uses of {} with {:?} (constant)\",\n+                       mir.format_local(dest_local),\n+                       src_constant);\n+                let dest_local_info = def_use_analysis.local_info(dest_local);\n+                for lvalue_use in &dest_local_info.defs_and_uses {\n+                    if lvalue_use.context.is_storage_marker() {\n+                        mir.make_statement_nop(lvalue_use.location)\n+                    }\n+                }\n+\n+                // Replace all uses of the destination local with the constant.\n+                let mut visitor = ConstantPropagationVisitor::new(MirSummary::new(mir),\n+                                                                  dest_local,\n+                                                                  src_constant);\n+                for dest_lvalue_use in &dest_local_info.defs_and_uses {\n+                    visitor.visit_location(mir, dest_lvalue_use.location)\n+                }\n+\n+                // Zap the assignment instruction if we eliminated all the uses. We won't have been\n+                // able to do that if the destination was used in a projection, because projections\n+                // must have lvalues on their LHS.\n+                let use_count = dest_local_info.use_count();\n+                if visitor.uses_replaced == use_count {\n+                    debug!(\"  {} of {} use(s) replaced; deleting assignment\",\n+                           visitor.uses_replaced,\n+                           use_count);\n+                    mir.make_statement_nop(location);\n+                    true\n+                } else if visitor.uses_replaced == 0 {\n+                    debug!(\"  No uses replaced; not deleting assignment\");\n+                    false\n+                } else {\n+                    debug!(\"  {} of {} use(s) replaced; not deleting assignment\",\n+                           visitor.uses_replaced,\n+                           use_count);\n+                    true\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct ConstantPropagationVisitor<'tcx> {\n+    dest_local: Local,\n+    constant: Constant<'tcx>,\n+    mir_summary: MirSummary,\n+    uses_replaced: usize,\n+}\n+\n+impl<'tcx> ConstantPropagationVisitor<'tcx> {\n+    fn new(mir_summary: MirSummary, dest_local: Local, constant: Constant<'tcx>)\n+           -> ConstantPropagationVisitor<'tcx> {\n+        ConstantPropagationVisitor {\n+            dest_local: dest_local,\n+            constant: constant,\n+            mir_summary: mir_summary,\n+            uses_replaced: 0,\n+        }\n+    }\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n+    fn visit_operand(&mut self, operand: &mut Operand<'tcx>, location: Location) {\n+        self.super_operand(operand, location);\n+\n+        match *operand {\n+            Operand::Consume(ref lvalue) => {\n+                if self.mir_summary.local_index(lvalue) != Some(self.dest_local) {\n+                    return\n+                }\n             }\n+            Operand::Constant(_) => return,\n         }\n+\n+        *operand = Operand::Constant(self.constant.clone());\n+        self.uses_replaced += 1\n     }\n }\n "}, {"sha": "2c03af2c8e97a93d67fa655683e662e0c38afa80", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05c2fdd64f3f4acc358b653616de6034eced49b5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c2fdd64f3f4acc358b653616de6034eced49b5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=05c2fdd64f3f4acc358b653616de6034eced49b5", "patch": "@@ -116,7 +116,7 @@ impl fmt::Display for Mode {\n     }\n }\n \n-fn is_const_fn(tcx: TyCtxt, def_id: DefId) -> bool {\n+pub fn is_const_fn(tcx: TyCtxt, def_id: DefId) -> bool {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         let fn_like = FnLikeNode::from_node(tcx.map.get(node_id));\n         match fn_like.map(|f| f.kind()) {"}, {"sha": "49ed2229fcd2b721bcb865a468a718095d10515b", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05c2fdd64f3f4acc358b653616de6034eced49b5/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c2fdd64f3f4acc358b653616de6034eced49b5/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=05c2fdd64f3f4acc358b653616de6034eced49b5", "patch": "@@ -23,9 +23,9 @@ fn helper(_: usize) {\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n-// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %s, i32 0, i32 0\n+// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 0\n // CHECK: store i8* %0, i8** [[X0]]\n-// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %s, i32 0, i32 1\n+// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 1\n // CHECK: store [[USIZE]] %1, [[USIZE]]* [[X1]]\n \n     let x = &*s;"}, {"sha": "4ed0c8bc9ffa4184fb9da7e22c0ecab48a24c1c5", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/05c2fdd64f3f4acc358b653616de6034eced49b5/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c2fdd64f3f4acc358b653616de6034eced49b5/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=05c2fdd64f3f4acc358b653616de6034eced49b5", "patch": "@@ -19,29 +19,29 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.node4.PreTrans.after.mir\n+// START rustc.node4.TypeckMir.before.mir\n //     bb0: {\n-//         nop;                             // scope 0 at storage_ranges.rs:14:9: 14:10\n+//         StorageLive(var0);               // scope 0 at storage_ranges.rs:14:9: 14:10\n //         var0 = const 0i32;               // scope 0 at storage_ranges.rs:14:13: 14:14\n //         StorageLive(var1);               // scope 1 at storage_ranges.rs:16:13: 16:14\n //         StorageLive(tmp1);               // scope 1 at storage_ranges.rs:16:18: 16:25\n-//         nop;                             // scope 1 at storage_ranges.rs:16:23: 16:24\n-//         nop;                             // scope 1 at storage_ranges.rs:16:23: 16:24\n-//         tmp1 = std::option::Option<i32>::Some(var0,); // scope 1 at storage_ranges.rs:16:18: 16:25\n+//         StorageLive(tmp2);               // scope 1 at storage_ranges.rs:16:23: 16:24\n+//         tmp2 = var0;                     // scope 1 at storage_ranges.rs:16:23: 16:24\n+//         tmp1 = std::option::Option<i32>::Some(tmp2,); // scope 1 at storage_ranges.rs:16:18: 16:25\n //         var1 = &tmp1;                    // scope 1 at storage_ranges.rs:16:17: 16:25\n-//         nop;                             // scope 1 at storage_ranges.rs:16:23: 16:24\n+//         StorageDead(tmp2);               // scope 1 at storage_ranges.rs:16:23: 16:24\n //         tmp0 = ();                       // scope 2 at storage_ranges.rs:15:5: 17:6\n //         StorageDead(tmp1);               // scope 1 at storage_ranges.rs:16:18: 16:25\n //         StorageDead(var1);               // scope 1 at storage_ranges.rs:16:13: 16:14\n //         StorageLive(var2);               // scope 1 at storage_ranges.rs:18:9: 18:10\n //         var2 = const 1i32;               // scope 1 at storage_ranges.rs:18:13: 18:14\n //         return = ();                     // scope 3 at storage_ranges.rs:13:11: 19:2\n //         StorageDead(var2);               // scope 1 at storage_ranges.rs:18:9: 18:10\n-//         nop;                             // scope 0 at storage_ranges.rs:14:9: 14:10\n+//         StorageDead(var0);               // scope 0 at storage_ranges.rs:14:9: 14:10\n //         goto -> bb1;                     // scope 0 at storage_ranges.rs:13:1: 19:2\n //     }\n //\n //     bb1: {\n //         return;                          // scope 0 at storage_ranges.rs:13:1: 19:2\n //     }\n-// END rustc.node4.PreTrans.after.mir\n+// END rustc.node4.TypeckMir.before.mir"}]}