{"sha": "261b606ddc12cfb027659562f3e22fbf77bfe448", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MWI2MDZkZGMxMmNmYjAyNzY1OTU2MmYzZTIyZmJmNzdiZmU0NDg=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-30T19:45:48Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-12-30T19:47:41Z"}, "message": "review comments and fix rebase", "tree": {"sha": "7c6cb72cafe17c29278325b14f496e81200079dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c6cb72cafe17c29278325b14f496e81200079dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/261b606ddc12cfb027659562f3e22fbf77bfe448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/261b606ddc12cfb027659562f3e22fbf77bfe448", "html_url": "https://github.com/rust-lang/rust/commit/261b606ddc12cfb027659562f3e22fbf77bfe448", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/261b606ddc12cfb027659562f3e22fbf77bfe448/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a3872ea9c2692edd84d8841a8d43175e3725319", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3872ea9c2692edd84d8841a8d43175e3725319", "html_url": "https://github.com/rust-lang/rust/commit/8a3872ea9c2692edd84d8841a8d43175e3725319"}], "stats": {"total": 33, "additions": 14, "deletions": 19}, "files": [{"sha": "91b062b45060a8ebed62fd657eed5560a0ff2ad8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/261b606ddc12cfb027659562f3e22fbf77bfe448/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/261b606ddc12cfb027659562f3e22fbf77bfe448/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=261b606ddc12cfb027659562f3e22fbf77bfe448", "patch": "@@ -68,6 +68,7 @@ pub trait AstConv<'tcx> {\n     /// Returns the type to use when a type is omitted.\n     fn ty_infer(&self, param: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx>;\n \n+    /// Returns `true` if `_` is allowed in type signatures in the current context.\n     fn allow_ty_infer(&self) -> bool;\n \n     /// Returns the const to use when a const is omitted.\n@@ -2770,8 +2771,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let tcx = self.tcx();\n \n         // We proactively collect all the infered type params to emit a single error per fn def.\n-        let mut visitor = PlaceholderHirTyCollector::new();\n-        for ty in &decl.inputs {\n+        let mut visitor = PlaceholderHirTyCollector::default();\n+        for ty in decl.inputs {\n             visitor.visit_ty(ty);\n         }\n         let input_tys = decl.inputs.iter().map(|a| self.ty_of_arg(a, None));\n@@ -2789,6 +2790,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty::Binder::bind(tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi));\n \n         if !self.allow_ty_infer() {\n+            // We always collect the spans for placeholder types when evaluating `fn`s, but we\n+            // only want to emit an error complaining about them if infer types (`_`) are not\n+            // allowed. `allow_ty_infer` gates this behavior.\n             crate::collect::placeholder_type_error(\n                 tcx,\n                 ident_span.unwrap_or(DUMMY_SP),"}, {"sha": "7e04c9487a7285a2fb2013a6fbca2d6001c16f71", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/261b606ddc12cfb027659562f3e22fbf77bfe448/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/261b606ddc12cfb027659562f3e22fbf77bfe448/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=261b606ddc12cfb027659562f3e22fbf77bfe448", "patch": "@@ -102,6 +102,7 @@ pub struct ItemCtxt<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n+#[derive(Default)]\n crate struct PlaceholderHirTyCollector(crate Vec<Span>);\n \n impl<'v> Visitor<'v> for PlaceholderHirTyCollector {\n@@ -116,16 +117,13 @@ impl<'v> Visitor<'v> for PlaceholderHirTyCollector {\n     }\n }\n \n-impl PlaceholderHirTyCollector {\n-    pub fn new() -> PlaceholderHirTyCollector {\n-        PlaceholderHirTyCollector(vec![])\n-    }\n-}\n-\n struct CollectItemTypesVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n }\n \n+/// If there are any placeholder types (`_`), emit an error explaining that this is not allowed\n+/// and suggest adding type parameters in the appropriate place, taking into consideration any and\n+/// all already existing generic type parameters to avoid suggesting a name that is already in use.\n crate fn placeholder_type_error(\n     tcx: TyCtxt<'tcx>,\n     ident_span: Span,\n@@ -136,6 +134,7 @@ crate fn placeholder_type_error(\n     if placeholder_types.is_empty() {\n         return;\n     }\n+    // This is the whitelist of possible parameter names that we might suggest.\n     let possible_names = [\"T\", \"K\", \"L\", \"A\", \"B\", \"C\"];\n     let used_names = generics\n         .iter()\n@@ -181,7 +180,7 @@ fn reject_placeholder_type_signatures_in_item(tcx: TyCtxt<'tcx>, item: &'tcx hir\n         _ => return,\n     };\n \n-    let mut visitor = PlaceholderHirTyCollector::new();\n+    let mut visitor = PlaceholderHirTyCollector::default();\n     visitor.visit_item(item);\n \n     placeholder_type_error(tcx, item.ident.span, generics, visitor.0, suggest);\n@@ -1796,15 +1795,7 @@ fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n     match &ty.kind {\n         hir::TyKind::Infer => true,\n         hir::TyKind::Slice(ty) | hir::TyKind::Array(ty, _) => is_suggestable_infer_ty(ty),\n-        hir::TyKind::Tup(tys)\n-            if !tys.is_empty()\n-                && tys.iter().any(|ty| match ty.kind {\n-                    hir::TyKind::Infer => true,\n-                    _ => false,\n-                }) =>\n-        {\n-            true\n-        }\n+        hir::TyKind::Tup(tys) => tys.iter().any(|ty| is_suggestable_infer_ty(ty)),\n         _ => false,\n     }\n }\n@@ -1838,7 +1829,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             match get_infer_ret_ty(&sig.decl.output) {\n                 Some(ty) => {\n                     let fn_sig = tcx.typeck_tables_of(def_id).liberated_fn_sigs()[hir_id];\n-                    let mut visitor = PlaceholderHirTyCollector::new();\n+                    let mut visitor = PlaceholderHirTyCollector::default();\n                     visitor.visit_ty(ty);\n                     let mut diag = bad_placeholder_type(tcx, visitor.0);\n                     let ret_ty = fn_sig.output();"}]}