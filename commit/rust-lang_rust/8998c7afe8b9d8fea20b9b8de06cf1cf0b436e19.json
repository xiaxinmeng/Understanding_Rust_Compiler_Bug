{"sha": "8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5OThjN2FmZThiOWQ4ZmVhMjBiOWI4ZGUwNmNmMWNmMGI0MzZlMTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-06T11:26:24Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-06T11:30:54Z"}, "message": "try_validation: handle multi-branching, and use macro for most remaining manual throw_validation_failure sites", "tree": {"sha": "6b3f6270ecc5822987ac0429545cb048246ad26a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b3f6270ecc5822987ac0429545cb048246ad26a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19", "html_url": "https://github.com/rust-lang/rust/commit/8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c4422654a3d207709a766813f2e4ca190776a2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4422654a3d207709a766813f2e4ca190776a2a", "html_url": "https://github.com/rust-lang/rust/commit/7c4422654a3d207709a766813f2e4ca190776a2a"}], "stats": {"total": 125, "additions": 47, "deletions": 78}, "files": [{"sha": "b9f9d37df7645d19400ac4c3a5ebb783a859e04c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19", "patch": "@@ -149,10 +149,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if args.len() != 1 {\n             throw_ub!(InvalidDropFn(fn_sig));\n         }\n-        let ty = args[0]\n-            .builtin_deref(true)\n-            .ok_or_else(|| err_ub!(InvalidDropFn(fn_sig)))?\n-            .ty;\n+        let ty = args[0].builtin_deref(true).ok_or_else(|| err_ub!(InvalidDropFn(fn_sig)))?.ty;\n         Ok((drop_instance, ty))\n     }\n "}, {"sha": "a5f012c8f4efbb7af03d5f89f2b330ee48d51de4", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 46, "deletions": 74, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8998c7afe8b9d8fea20b9b8de06cf1cf0b436e19", "patch": "@@ -73,17 +73,18 @@ macro_rules! throw_validation_failure {\n ///\n macro_rules! try_validation {\n     ($e:expr, $where:expr,\n-     $( $p:pat )|+ => { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? $( , )?\n+     $( $( $p:pat )|+ => { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? ),+ $(,)?\n     ) => {{\n         match $e {\n             Ok(x) => x,\n             // We catch the error and turn it into a validation failure. We are okay with\n             // allocation here as this can only slow down builds that fail anyway.\n-            $( Err(InterpErrorInfo { kind: $p, .. }) )|+ =>\n+            $( $( Err(InterpErrorInfo { kind: $p, .. }) )|+ =>\n                 throw_validation_failure!(\n                     $where,\n                     { $( $what_fmt ),+ } $( expected { $( $expected_fmt ),+ } )?\n                 ),\n+            )+\n             #[allow(unreachable_patterns)]\n             Err(e) => Err::<!, _>(e)?,\n         }\n@@ -367,66 +368,45 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n         }\n         // Make sure this is dereferenceable and all.\n-        let size_and_align = match self.ecx.size_and_align_of(place.meta, place.layout) {\n-            Ok(res) => res,\n-            Err(err) => match err.kind {\n-                err_ub!(InvalidMeta(msg)) => throw_validation_failure!(self.path,\n-                    { \"invalid {} metadata: {}\", kind, msg }\n-                ),\n-                _ => bug!(\"unexpected error during ptr size_and_align_of: {}\", err),\n-            },\n-        };\n+        let size_and_align = try_validation!(\n+            self.ecx.size_and_align_of(place.meta, place.layout),\n+            self.path,\n+            err_ub!(InvalidMeta(msg)) => { \"invalid {} metadata: {}\", kind, msg },\n+        );\n         let (size, align) = size_and_align\n             // for the purpose of validity, consider foreign types to have\n             // alignment and size determined by the layout (size will be 0,\n             // alignment should take attributes into account).\n             .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n         // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n-        let ptr: Option<_> = match self.ecx.memory.check_ptr_access_align(\n-            place.ptr,\n-            size,\n-            Some(align),\n-            CheckInAllocMsg::InboundsTest,\n-        ) {\n-            Ok(ptr) => ptr,\n-            Err(err) => {\n-                info!(\n-                    \"{:?} did not pass access check for size {:?}, align {:?}\",\n-                    place.ptr, size, align\n-                );\n-                match err.kind {\n-                    err_ub!(DanglingIntPointer(0, _)) => {\n-                        throw_validation_failure!(self.path,\n-                            { \"a NULL {}\", kind }\n-                        )\n-                    }\n-                    err_ub!(DanglingIntPointer(i, _)) => throw_validation_failure!(self.path,\n-                        { \"a {} to unallocated address {}\", kind, i }\n-                    ),\n-                    err_ub!(AlignmentCheckFailed { required, has }) => throw_validation_failure!(\n-                        self.path,\n-                        {\n-                            \"an unaligned {} (required {} byte alignment but found {})\",\n-                            kind,\n-                            required.bytes(),\n-                            has.bytes()\n-                        }\n-                    ),\n-                    err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(self.path,\n-                        { \"a dangling {} (created from integer)\", kind }\n-                    ),\n-                    err_ub!(PointerOutOfBounds { .. }) => throw_validation_failure!(self.path,\n-                        { \"a dangling {} (going beyond the bounds of its allocation)\", kind }\n-                    ),\n-                    // This cannot happen during const-eval (because interning already detects\n-                    // dangling pointers), but it can happen in Miri.\n-                    err_ub!(PointerUseAfterFree(_)) => throw_validation_failure!(self.path,\n-                        { \"a dangling {} (use-after-free)\", kind }\n-                    ),\n-                    _ => bug!(\"Unexpected error during ptr inbounds test: {}\", err),\n-                }\n-            }\n-        };\n+        let ptr: Option<_> = try_validation!(\n+            self.ecx.memory.check_ptr_access_align(\n+                place.ptr,\n+                size,\n+                Some(align),\n+                CheckInAllocMsg::InboundsTest,\n+            ),\n+            self.path,\n+            err_ub!(DanglingIntPointer(0, _)) =>\n+                { \"a NULL {}\", kind },\n+            err_ub!(DanglingIntPointer(i, _)) =>\n+                { \"a {} to unallocated address {}\", kind, i },\n+            err_ub!(AlignmentCheckFailed { required, has }) =>\n+                {\n+                    \"an unaligned {} (required {} byte alignment but found {})\",\n+                    kind,\n+                    required.bytes(),\n+                    has.bytes()\n+                },\n+            err_unsup!(ReadBytesAsPointer) =>\n+                { \"a dangling {} (created from integer)\", kind },\n+            err_ub!(PointerOutOfBounds { .. }) =>\n+                { \"a dangling {} (going beyond the bounds of its allocation)\", kind },\n+            // This cannot happen during const-eval (because interning already detects\n+            // dangling pointers), but it can happen in Miri.\n+            err_ub!(PointerUseAfterFree(_)) =>\n+                { \"a dangling {} (use-after-free)\", kind },\n+        );\n         // Recursive checking\n         if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n             if let Some(ptr) = ptr {\n@@ -710,23 +690,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         assert!(op.layout.ty.builtin_deref(true).is_none());\n \n         // Recursively walk the type. Translate some possible errors to something nicer.\n-        match self.walk_value(op) {\n-            Ok(()) => {}\n-            Err(err) => match err.kind {\n-                err_ub!(InvalidDiscriminant(val)) => {\n-                    throw_validation_failure!(self.path,\n-                        { \"{}\", val } expected { \"a valid enum discriminant\" }\n-                    )\n-                }\n-                err_unsup!(ReadPointerAsBytes) => {\n-                    throw_validation_failure!(self.path,\n-                        { \"a pointer\" } expected { \"plain (non-pointer) bytes\" }\n-                    )\n-                }\n-                // Propagate upwards (that will also check for unexpected errors).\n-                _ => return Err(err),\n-            },\n-        }\n+        try_validation!(\n+            self.walk_value(op),\n+            self.path,\n+            err_ub!(InvalidDiscriminant(val)) =>\n+                { \"{}\", val } expected { \"a valid enum discriminant\" },\n+            err_unsup!(ReadPointerAsBytes) =>\n+                { \"a pointer\" } expected { \"plain (non-pointer) bytes\" },\n+        );\n \n         // *After* all of this, check the ABI.  We need to check the ABI to handle\n         // types like `NonNull` where the `Scalar` info is more restrictive than what\n@@ -825,7 +796,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Ok(()) => {}\n                     // Some error happened, try to provide a more detailed description.\n                     Err(err) => {\n-                        // For some errors we might be able to provide extra information\n+                        // For some errors we might be able to provide extra information.\n+                        // (This custom logic does not fit the `try_validation!` macro.)\n                         match err.kind {\n                             err_ub!(InvalidUndefBytes(Some(ptr))) => {\n                                 // Some byte was uninitialized, determine which"}]}