{"sha": "f30cc74fb41916d11a27e6b29ebbe73298534573", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMGNjNzRmYjQxOTE2ZDExYTI3ZTZiMjllYmJlNzMyOTg1MzQ1NzM=", "commit": {"author": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2020-10-08T21:34:11Z"}, "committer": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2020-10-08T21:34:11Z"}, "message": "Avoid SeqCst or static mut in mach_timebase_info cache", "tree": {"sha": "09922255f8a56339ed9517245f35c7f4d8142f85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09922255f8a56339ed9517245f35c7f4d8142f85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f30cc74fb41916d11a27e6b29ebbe73298534573", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f30cc74fb41916d11a27e6b29ebbe73298534573", "html_url": "https://github.com/rust-lang/rust/commit/f30cc74fb41916d11a27e6b29ebbe73298534573", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f30cc74fb41916d11a27e6b29ebbe73298534573/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccea570488694e502c1a7ca8f3f0866c9b763ce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccea570488694e502c1a7ca8f3f0866c9b763ce4", "html_url": "https://github.com/rust-lang/rust/commit/ccea570488694e502c1a7ca8f3f0866c9b763ce4"}], "stats": {"total": 58, "additions": 36, "deletions": 22}, "files": [{"sha": "5dc1ade9c1fa1cc1075aa96fb482e8685b9326e9", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f30cc74fb41916d11a27e6b29ebbe73298534573/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f30cc74fb41916d11a27e6b29ebbe73298534573/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=f30cc74fb41916d11a27e6b29ebbe73298534573", "patch": "@@ -117,8 +117,7 @@ impl Hash for Timespec {\n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n mod inner {\n     use crate::fmt;\n-    use crate::mem;\n-    use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+    use crate::sync::atomic::{AtomicBool, AtomicU64, Ordering};\n     use crate::sys::cvt;\n     use crate::sys_common::mul_div_u64;\n     use crate::time::Duration;\n@@ -233,31 +232,46 @@ mod inner {\n     }\n \n     fn info() -> mach_timebase_info {\n-        static mut INFO: mach_timebase_info = mach_timebase_info { numer: 0, denom: 0 };\n-        static STATE: AtomicUsize = AtomicUsize::new(0);\n+        static INITIALIZED: AtomicBool = AtomicBool::new(false);\n+        static INFO_BITS: AtomicU64 = AtomicU64::new(0);\n+\n+        // If a previous thread has filled in this global INITIALIZED, use that.\n+        if INITIALIZED.load(Ordering::Acquire) {\n+            // The Acquire/Release pair used for INITIALIZED ensures that this\n+            // load can see the corresponding `INFO_BITS` store, despite them\n+            // both being Relaxed.\n+            return info_from_bits(INFO_BITS.load(Ordering::Relaxed));\n+        }\n+\n+        // ... otherwise learn for ourselves ...\n+        extern \"C\" {\n+            fn mach_timebase_info(info: mach_timebase_info_t) -> kern_return_t;\n+        }\n \n+        let mut info = info_from_bits(0);\n         unsafe {\n-            // If a previous thread has filled in this global state, use that.\n-            if STATE.load(SeqCst) == 2 {\n-                return INFO;\n-            }\n+            mach_timebase_info(&mut info);\n+        }\n \n-            // ... otherwise learn for ourselves ...\n-            let mut info = mem::zeroed();\n-            extern \"C\" {\n-                fn mach_timebase_info(info: mach_timebase_info_t) -> kern_return_t;\n-            }\n+        // Note: This is racy, but the race is against other threads trying to\n+        // write the same value.\n+        INFO_BITS.store(info_to_bits(info), Ordering::Relaxed);\n \n-            mach_timebase_info(&mut info);\n+        // The `Release` here \"publishes\" the store of `INFO_BITS` to other\n+        // threads (which do a `INITIALIZED.load(Acquire)`) despite it being\n+        // read/written w/ `Relaxed`.\n+        INITIALIZED.store(true, Ordering::Release);\n+        info\n+    }\n \n-            // ... and attempt to be the one thread that stores it globally for\n-            // all other threads\n-            if STATE.compare_exchange(0, 1, SeqCst, SeqCst).is_ok() {\n-                INFO = info;\n-                STATE.store(2, SeqCst);\n-            }\n-            return info;\n-        }\n+    #[inline]\n+    fn info_to_bits(info: mach_timebase_info) -> u64 {\n+        ((info.denom as u64) << 32) | (info.numer as u64)\n+    }\n+\n+    #[inline]\n+    fn info_from_bits(bits: u64) -> mach_timebase_info {\n+        mach_timebase_info { numer: bits as u32, denom: (bits >> 32) as u32 }\n     }\n }\n "}]}