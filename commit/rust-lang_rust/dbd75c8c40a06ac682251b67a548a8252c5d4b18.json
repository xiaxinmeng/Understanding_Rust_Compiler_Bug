{"sha": "dbd75c8c40a06ac682251b67a548a8252c5d4b18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiZDc1YzhjNDBhMDZhYzY4MjI1MWI2N2E1NDhhODI1MmM1ZDRiMTg=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-08T22:22:27Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-15T20:55:43Z"}, "message": "Handle more cases involving `impl` and `trait`", "tree": {"sha": "e82e4d9e51d100c373939b8d2febbe50ad7cae05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e82e4d9e51d100c373939b8d2febbe50ad7cae05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbd75c8c40a06ac682251b67a548a8252c5d4b18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbd75c8c40a06ac682251b67a548a8252c5d4b18", "html_url": "https://github.com/rust-lang/rust/commit/dbd75c8c40a06ac682251b67a548a8252c5d4b18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbd75c8c40a06ac682251b67a548a8252c5d4b18/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b7ffd93330142d433ed3035ef838638dc6afa3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b7ffd93330142d433ed3035ef838638dc6afa3a", "html_url": "https://github.com/rust-lang/rust/commit/5b7ffd93330142d433ed3035ef838638dc6afa3a"}], "stats": {"total": 179, "additions": 101, "deletions": 78}, "files": [{"sha": "c8baafef50a7cee20cb7cd564cfa523e9dd8d16a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 80, "deletions": 67, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=dbd75c8c40a06ac682251b67a548a8252c5d4b18", "patch": "@@ -969,90 +969,103 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         trait_ref: &ty::PolyTraitRef<'_>,\n         body_id: hir::HirId,\n     ) {\n-        let node = self.tcx.hir()\n-            .find(self.tcx.hir().get_parent_item(body_id))\n-            .or_else(|| self.tcx.hir().find(body_id));\n         debug!(\n-            \"suggest_restricting_param_bound node={:?} - trait_ref={:?} ty={:?} ({:?})\",\n-            node,\n+            \"suggest_restricting_param_bound trait_ref={:?} ty={:?} ({:?})\",\n             trait_ref,\n             trait_ref.self_ty(),\n             trait_ref.self_ty().kind,\n         );\n-        if let ty::Param(param_ty) = &trait_ref.self_ty().kind {\n-            let restrict_msg = \"consider further restricting this bound\";\n-            let param_name = param_ty.name.as_str();\n-\n-            if let Some(hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Struct(_, generics), span, ..\n-            })) |\n-            Some(hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Enum(_, generics), span, ..\n-            })) |\n-            Some(hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Union(_, generics), span, ..\n-            })) |\n-            Some(hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Trait(_, _, generics, ..), span, ..\n-            })) |\n-            Some(hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Impl(_, _, _, generics, ..), span, ..\n-            })) |\n-            Some(hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Fn(_, _, generics, _), span, ..\n-            })) = &node {\n-                for param in &generics.params {\n-                    if param_name == param.name.ident().as_str() {\n-                        if param_name.starts_with(\"impl \") {\n-                            err.span_suggestion(\n-                                param.span,\n-                                restrict_msg,\n-                                // `impl CurrentTrait + MissingTrait`\n-                                format!(\"{} + {}\", param.name.ident(), trait_ref),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            if generics.where_clause.predicates.is_empty() &&\n-                                param.bounds.is_empty()\n-                            {\n+        let param_ty = if let ty::Param(param_ty) = &trait_ref.self_ty().kind {\n+            param_ty\n+        } else {\n+            err.help(&format!(\"consider adding a `where {}` bound\", trait_ref.to_predicate()));\n+            return;\n+        };\n+\n+        let mut hir_id = body_id;\n+        while let Some(node) = self.tcx.hir().find(hir_id) {\n+            debug!(\"suggest_restricting_param_bound node={:?}\", node);\n+            match node {\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Struct(_, generics), span, .. }) |\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Enum(_, generics), span, .. }) |\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Union(_, generics), span, .. }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, ..), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(_, _, _, generics, ..), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_, _, generics, _), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TyAlias(_, generics), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. }), span, ..\n+                }) |\n+                hir::Node::TraitItem(hir::TraitItem { generics, span, .. }) |\n+                hir::Node::ImplItem(hir::ImplItem { generics, span, .. }) => {\n+                    let restrict_msg = \"consider further restricting this bound\";\n+                    let param_name = param_ty.name.as_str();\n+                    for param in &generics.params {\n+                        if param_name == param.name.ident().as_str() {\n+                            if param_name.starts_with(\"impl \") {\n                                 err.span_suggestion(\n                                     param.span,\n-                                    \"consider restricting this bound\",\n-                                    format!(\"{}\", trait_ref.to_predicate()),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            } else if !generics.where_clause.predicates.is_empty() {\n-                                err.span_suggestion(\n-                                    generics.where_clause.span().unwrap().shrink_to_hi(),\n-                                    &format!(\n-                                        \"consider further restricting type parameter `{}`\",\n-                                        param_ty,\n-                                    ),\n-                                    format!(\", {}\", trait_ref.to_predicate()),\n+                                    restrict_msg,\n+                                    // `impl CurrentTrait + MissingTrait`\n+                                    format!(\"{} + {}\", param.name.ident(), trait_ref),\n                                     Applicability::MachineApplicable,\n                                 );\n                             } else {\n-                                let sp = param.span.with_hi(span.hi());\n-                                let span = self.tcx.sess.source_map().span_through_char(sp, ':');\n-                                if sp != param.span && sp != span {\n-                                    // Only suggest if we have high certainty that the span covers\n-                                    // the colon in `foo<T: Trait>`.\n-                                    err.span_suggestion(span, restrict_msg, format!(\n-                                        \"{} + \",\n-                                        trait_ref.to_predicate(),\n-                                    ), Applicability::MachineApplicable);\n+                                if generics.where_clause.predicates.is_empty() &&\n+                                    param.bounds.is_empty()\n+                                {\n+                                    err.span_suggestion(\n+                                        param.span,\n+                                        \"consider restricting this bound\",\n+                                        format!(\"{}\", trait_ref.to_predicate()),\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                } else if !generics.where_clause.predicates.is_empty() {\n+                                    err.span_suggestion(\n+                                        generics.where_clause.span().unwrap().shrink_to_hi(),\n+                                        &format!(\n+                                            \"consider further restricting type parameter `{}`\",\n+                                            param_ty,\n+                                        ),\n+                                        format!(\", {}\", trait_ref.to_predicate()),\n+                                        Applicability::MachineApplicable,\n+                                    );\n                                 } else {\n-                                    err.span_label(param.span, &format!(\n-                                        \"consider adding a `where {}` bound\",\n-                                        trait_ref.to_predicate(),\n-                                    ));\n+                                    let sp = param.span.with_hi(span.hi());\n+                                    let span = self.tcx.sess.source_map()\n+                                        .span_through_char(sp, ':');\n+                                    if sp != param.span && sp != span {\n+                                        // Only suggest if we have high certainty that the span\n+                                        // covers the colon in `foo<T: Trait>`.\n+                                        err.span_suggestion(span, restrict_msg, format!(\n+                                            \"{} + \",\n+                                            trait_ref.to_predicate(),\n+                                        ), Applicability::MachineApplicable);\n+                                    } else {\n+                                        err.span_label(param.span, &format!(\n+                                            \"consider adding a `where {}` bound\",\n+                                            trait_ref.to_predicate(),\n+                                        ));\n+                                    }\n                                 }\n                             }\n+                            return;\n                         }\n-                        return;\n                     }\n                 }\n+                hir::Node::Crate => return,\n+                _ => {}\n             }\n+\n+            hir_id = self.tcx.hir().get_parent_item(hir_id);\n         }\n         // FIXME: Add special check for `?Sized` so we don't suggest `T: Sized + ?Sized`.\n "}, {"sha": "78198322913c7579fd92590525fb33c46843e0d6", "filename": "src/test/ui/associated-types/associated-types-no-suitable-bound.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr?ref=dbd75c8c40a06ac682251b67a548a8252c5d4b18", "patch": "@@ -2,9 +2,10 @@ error[E0277]: the trait bound `T: Get` is not satisfied\n   --> $DIR/associated-types-no-suitable-bound.rs:11:5\n    |\n LL |     fn uhoh<T>(foo: <T as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: Get` bound\n+   |     ^^^^^^^^-^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |       |\n+   |     |       help: consider restricting this bound: `T: Get`\n+   |     the trait `Get` is not implemented for `T`\n \n error: aborting due to previous error\n "}, {"sha": "2fb9977f4d700a87d0fed2afab0fbc2ec5fc5f06", "filename": "src/test/ui/consts/too_generic_eval_ice.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr?ref=dbd75c8c40a06ac682251b67a548a8252c5d4b18", "patch": "@@ -16,26 +16,30 @@ error[E0277]: the size for values of type `A` cannot be known at compilation tim\n    |\n LL | pub struct Foo<A, B>(A, B);\n    | --------------------------- required by `Foo`\n+LL | \n+LL | impl<A, B> Foo<A, B> {\n+   |      - help: consider restricting this bound: `A: std::marker::Sized`\n ...\n LL |         [5; Self::HOST_SIZE] == [6; 0]\n    |             ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `A`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where A: std::marker::Sized` bound\n \n error[E0277]: the size for values of type `B` cannot be known at compilation time\n   --> $DIR/too_generic_eval_ice.rs:7:13\n    |\n LL | pub struct Foo<A, B>(A, B);\n    | --------------------------- required by `Foo`\n+LL | \n+LL | impl<A, B> Foo<A, B> {\n+   |         - help: consider restricting this bound: `B: std::marker::Sized`\n ...\n LL |         [5; Self::HOST_SIZE] == [6; 0]\n    |             ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `B`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where B: std::marker::Sized` bound\n \n error: aborting due to 3 previous errors\n "}, {"sha": "0d8ee61b5ba13926040563ae61e362b76e227449", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=dbd75c8c40a06ac682251b67a548a8252c5d4b18", "patch": "@@ -1,10 +1,11 @@\n error[E0277]: the trait bound `S: std::marker::Copy` is not satisfied in `(S, T)`\n   --> $DIR/issue-55872-1.rs:12:5\n    |\n+LL | impl<S: Default> Bar for S {\n+   |      -- help: consider further restricting this bound: `S: std::marker::Copy +`\n LL |     type E = impl Copy;\n    |     ^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `S`\n    |\n-   = help: consider adding a `where S: std::marker::Copy` bound\n    = note: required because it appears within the type `(S, T)`\n    = note: the return type of a function must have a statically known size\n \n@@ -13,8 +14,10 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied in `(S, T)\n    |\n LL |     type E = impl Copy;\n    |     ^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `T`\n+...\n+LL |     fn foo<T: Default>() -> Self::E {\n+   |            -- help: consider further restricting this bound: `T: std::marker::Copy +`\n    |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n    = note: required because it appears within the type `(S, T)`\n    = note: the return type of a function must have a statically known size\n "}, {"sha": "995b544600389fb58411d3cd654eaf236142b601", "filename": "src/test/ui/where-clauses/where-clause-constraints-are-local-for-inherent-impl.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-inherent-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-inherent-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-inherent-impl.stderr?ref=dbd75c8c40a06ac682251b67a548a8252c5d4b18", "patch": "@@ -4,10 +4,11 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL | fn require_copy<T: Copy>(x: T) {}\n    |    ------------    ---- required by this bound in `require_copy`\n ...\n+LL | impl<T> Foo<T> {\n+   |      - help: consider restricting this bound: `T: std::marker::Copy`\n+...\n LL |         require_copy(self.x);\n    |                      ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "fe575f3a28a9ea13c32c7ec8a366480de2b546ff", "filename": "src/test/ui/where-clauses/where-clause-constraints-are-local-for-trait-impl.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-trait-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbd75c8c40a06ac682251b67a548a8252c5d4b18/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-trait-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-trait-impl.stderr?ref=dbd75c8c40a06ac682251b67a548a8252c5d4b18", "patch": "@@ -4,10 +4,11 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL | fn require_copy<T: Copy>(x: T) {}\n    |    ------------    ---- required by this bound in `require_copy`\n ...\n+LL | impl<T> Foo<T> for Bar<T> {\n+   |      - help: consider restricting this bound: `T: std::marker::Copy`\n+...\n LL |         require_copy(self.x);\n    |                      ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}]}