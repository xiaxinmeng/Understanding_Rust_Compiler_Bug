{"sha": "c781fc4a6a8af287f7abe141f035a638bc0165c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ODFmYzRhNmE4YWYyODdmN2FiZTE0MWYwMzVhNjM4YmMwMTY1YzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-04T01:32:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-04T01:32:21Z"}, "message": "Auto merge of #36320 - GuillaumeGomez:rustdoc_test_info, r=alexcrichton\n\nAdd information in case of markdown block code test failure\n\nr? @steveklabnik\n\ncc @jonathandturner", "tree": {"sha": "1b104948b624ede568053d31b42c41176192fed3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b104948b624ede568053d31b42c41176192fed3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c781fc4a6a8af287f7abe141f035a638bc0165c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c781fc4a6a8af287f7abe141f035a638bc0165c3", "html_url": "https://github.com/rust-lang/rust/commit/c781fc4a6a8af287f7abe141f035a638bc0165c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c781fc4a6a8af287f7abe141f035a638bc0165c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0648517faf1e2cf37c8b6770cbd0180a816ed9a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0648517faf1e2cf37c8b6770cbd0180a816ed9a0", "html_url": "https://github.com/rust-lang/rust/commit/0648517faf1e2cf37c8b6770cbd0180a816ed9a0"}, {"sha": "b7f1d7a4bdf1a06d4ac1fc1d01eb7568608351a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7f1d7a4bdf1a06d4ac1fc1d01eb7568608351a0", "html_url": "https://github.com/rust-lang/rust/commit/b7f1d7a4bdf1a06d4ac1fc1d01eb7568608351a0"}], "stats": {"total": 264, "additions": 207, "deletions": 57}, "files": [{"sha": "86c5c780c5eb2b7f9a8a9c57ee9b9cdaa302653e", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -8,6 +8,7 @@\n [submodule \"src/rt/hoedown\"]\n \tpath = src/rt/hoedown\n \turl = https://github.com/rust-lang/hoedown.git\n+\tbranch = rust-2015-09-21-do-not-delete\n [submodule \"src/jemalloc\"]\n \tpath = src/jemalloc\n \turl = https://github.com/rust-lang/jemalloc.git"}, {"sha": "fe2edcad25c20d84bdea3f08805e483231f8f4e5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -521,17 +521,22 @@ impl<'a, I: IntoIterator<Item=&'a ast::NestedMetaItem>> NestedAttributesExt for\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug, Default)]\n pub struct Attributes {\n     pub doc_strings: Vec<String>,\n-    pub other_attrs: Vec<ast::Attribute>\n+    pub other_attrs: Vec<ast::Attribute>,\n+    pub span: Option<syntax_pos::Span>,\n }\n \n impl Attributes {\n     pub fn from_ast(attrs: &[ast::Attribute]) -> Attributes {\n         let mut doc_strings = vec![];\n+        let mut sp = None;\n         let other_attrs = attrs.iter().filter_map(|attr| {\n             attr.with_desugared_doc(|attr| {\n                 if let Some(value) = attr.value_str() {\n                     if attr.check_name(\"doc\") {\n                         doc_strings.push(value.to_string());\n+                        if sp.is_none() {\n+                            sp = Some(attr.span);\n+                        }\n                         return None;\n                     }\n                 }\n@@ -541,7 +546,8 @@ impl Attributes {\n         }).collect();\n         Attributes {\n             doc_strings: doc_strings,\n-            other_attrs: other_attrs\n+            other_attrs: other_attrs,\n+            span: sp,\n         }\n     }\n "}, {"sha": "e8ff8930bdd7d32eb16557c3bbfce9822eccca34", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 37, "deletions": 19, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -71,29 +71,31 @@ const HOEDOWN_EXTENSIONS: libc::c_uint =\n enum hoedown_document {}\n \n type blockcodefn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                 *const hoedown_buffer, *const hoedown_renderer_data);\n+                                 *const hoedown_buffer, *const hoedown_renderer_data,\n+                                 libc::size_t);\n \n type blockquotefn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                  *const hoedown_renderer_data);\n+                                  *const hoedown_renderer_data, libc::size_t);\n \n type headerfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                              libc::c_int, *const hoedown_renderer_data);\n+                              libc::c_int, *const hoedown_renderer_data,\n+                              libc::size_t);\n \n type blockhtmlfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                 *const hoedown_renderer_data);\n+                                 *const hoedown_renderer_data, libc::size_t);\n \n type codespanfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                *const hoedown_renderer_data) -> libc::c_int;\n+                                *const hoedown_renderer_data, libc::size_t) -> libc::c_int;\n \n type linkfn = extern \"C\" fn (*mut hoedown_buffer, *const hoedown_buffer,\n                              *const hoedown_buffer, *const hoedown_buffer,\n-                             *const hoedown_renderer_data) -> libc::c_int;\n+                             *const hoedown_renderer_data, libc::size_t) -> libc::c_int;\n \n type entityfn = extern \"C\" fn (*mut hoedown_buffer, *const hoedown_buffer,\n-                               *const hoedown_renderer_data);\n+                               *const hoedown_renderer_data, libc::size_t);\n \n type normaltextfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                                  *const hoedown_renderer_data);\n+                                  *const hoedown_renderer_data, libc::size_t);\n \n #[repr(C)]\n struct hoedown_renderer_data {\n@@ -147,7 +149,8 @@ struct html_toc_data {\n \n struct MyOpaque {\n     dfltblk: extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n-                           *const hoedown_buffer, *const hoedown_renderer_data),\n+                           *const hoedown_buffer, *const hoedown_renderer_data,\n+                           libc::size_t),\n     toc_builder: Option<TocBuilder>,\n }\n \n@@ -229,7 +232,8 @@ pub fn render(w: &mut fmt::Formatter,\n               print_toc: bool,\n               html_flags: libc::c_uint) -> fmt::Result {\n     extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n-                    lang: *const hoedown_buffer, data: *const hoedown_renderer_data) {\n+                    lang: *const hoedown_buffer, data: *const hoedown_renderer_data,\n+                    line: libc::size_t) {\n         unsafe {\n             if orig_text.is_null() { return }\n \n@@ -246,7 +250,8 @@ pub fn render(w: &mut fmt::Formatter,\n                 let rlang = str::from_utf8(rlang).unwrap();\n                 if !LangString::parse(rlang).rust {\n                     (my_opaque.dfltblk)(ob, orig_text, lang,\n-                                        opaque as *const hoedown_renderer_data);\n+                                        opaque as *const hoedown_renderer_data,\n+                                        line);\n                     true\n                 } else {\n                     false\n@@ -312,7 +317,8 @@ pub fn render(w: &mut fmt::Formatter,\n     }\n \n     extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n-                     level: libc::c_int, data: *const hoedown_renderer_data) {\n+                     level: libc::c_int, data: *const hoedown_renderer_data,\n+                     _: libc::size_t) {\n         // hoedown does this, we may as well too\n         unsafe { hoedown_buffer_puts(ob, \"\\n\\0\".as_ptr() as *const _); }\n \n@@ -373,6 +379,7 @@ pub fn render(w: &mut fmt::Formatter,\n         ob: *mut hoedown_buffer,\n         text: *const hoedown_buffer,\n         _: *const hoedown_renderer_data,\n+        _: libc::size_t\n     ) -> libc::c_int {\n         let content = if text.is_null() {\n             \"\".to_owned()\n@@ -422,11 +429,12 @@ pub fn render(w: &mut fmt::Formatter,\n     }\n }\n \n-pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n+pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, start_line: usize) {\n     extern fn block(_ob: *mut hoedown_buffer,\n                     text: *const hoedown_buffer,\n                     lang: *const hoedown_buffer,\n-                    data: *const hoedown_renderer_data) {\n+                    data: *const hoedown_renderer_data,\n+                    line: libc::size_t) {\n         unsafe {\n             if text.is_null() { return }\n             let block_info = if lang.is_null() {\n@@ -445,16 +453,19 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                 stripped_filtered_line(l).unwrap_or(l)\n             });\n             let text = lines.collect::<Vec<&str>>().join(\"\\n\");\n+            let line = tests.get_line() + line;\n             tests.add_test(text.to_owned(),\n                            block_info.should_panic, block_info.no_run,\n                            block_info.ignore, block_info.test_harness,\n-                           block_info.compile_fail, block_info.error_codes);\n+                           block_info.compile_fail, block_info.error_codes,\n+                           line);\n         }\n     }\n \n     extern fn header(_ob: *mut hoedown_buffer,\n                      text: *const hoedown_buffer,\n-                     level: libc::c_int, data: *const hoedown_renderer_data) {\n+                     level: libc::c_int, data: *const hoedown_renderer_data,\n+                     _: libc::size_t) {\n         unsafe {\n             let opaque = (*data).opaque as *mut hoedown_html_renderer_state;\n             let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n@@ -468,6 +479,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n         }\n     }\n \n+    tests.set_line(start_line);\n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n         let renderer = hoedown_html_renderer_new(0, 0);\n@@ -488,6 +500,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n struct LangString {\n+    original: String,\n     should_panic: bool,\n     no_run: bool,\n     ignore: bool,\n@@ -500,6 +513,7 @@ struct LangString {\n impl LangString {\n     fn all_false() -> LangString {\n         LangString {\n+            original: String::new(),\n             should_panic: false,\n             no_run: false,\n             ignore: false,\n@@ -521,6 +535,7 @@ impl LangString {\n             allow_error_code_check = true;\n         }\n \n+        data.original = string.to_owned();\n         let tokens = string.split(|c: char|\n             !(c == '_' || c == '-' || c.is_alphanumeric())\n         );\n@@ -586,7 +601,8 @@ pub fn plain_summary_line(md: &str) -> String {\n                        _link: *const hoedown_buffer,\n                        _title: *const hoedown_buffer,\n                        content: *const hoedown_buffer,\n-                       data: *const hoedown_renderer_data) -> libc::c_int\n+                       data: *const hoedown_renderer_data,\n+                       _: libc::size_t) -> libc::c_int\n     {\n         unsafe {\n             if !content.is_null() && (*content).size > 0 {\n@@ -599,8 +615,9 @@ pub fn plain_summary_line(md: &str) -> String {\n     }\n \n     extern fn normal_text(_ob: *mut hoedown_buffer,\n-                              text: *const hoedown_buffer,\n-                              data: *const hoedown_renderer_data)\n+                          text: *const hoedown_buffer,\n+                          data: *const hoedown_renderer_data,\n+                          _: libc::size_t)\n     {\n         unsafe {\n             let ob = (*data).opaque as *mut hoedown_buffer;\n@@ -647,6 +664,7 @@ mod tests {\n                 test_harness: test_harness,\n                 compile_fail: compile_fail,\n                 error_codes: error_codes,\n+                original: s.to_owned(),\n             })\n         }\n "}, {"sha": "49497957be980734fe03a7e29713a4022b4dd319", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -154,8 +154,9 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n     let mut opts = TestOptions::default();\n     opts.no_crate_inject = true;\n     let mut collector = Collector::new(input.to_string(), cfgs, libs, externs,\n-                                       true, opts, maybe_sysroot);\n-    find_testable_code(&input_str, &mut collector);\n+                                       true, opts, maybe_sysroot, \"input\".to_string(),\n+                                       None);\n+    find_testable_code(&input_str, &mut collector, 0);\n     test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main(&test_args, collector.tests);\n     0"}, {"sha": "6b6330ef12a94dea6a53da36ebbaa08dfbae69df", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -37,6 +37,7 @@ use rustc_trans::back::link;\n use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax_pos::{BytePos, DUMMY_SP, Pos};\n use errors;\n use errors::emitter::ColorConfig;\n \n@@ -79,7 +80,7 @@ pub fn run(input: &str,\n     let _ignore = dep_graph.in_ignore();\n     let cstore = Rc::new(CStore::new(&dep_graph));\n     let mut sess = session::build_session_(\n-        sessopts, &dep_graph, Some(input_path.clone()), handler, codemap, cstore.clone(),\n+        sessopts, &dep_graph, Some(input_path.clone()), handler, codemap.clone(), cstore.clone(),\n     );\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     sess.parse_sess.config =\n@@ -96,13 +97,16 @@ pub fn run(input: &str,\n         link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n     });\n     let opts = scrape_test_config(hir_forest.krate());\n+    let filename = input_path.to_str().unwrap_or(\"\").to_owned();\n     let mut collector = Collector::new(crate_name,\n                                        cfgs,\n                                        libs,\n                                        externs,\n                                        false,\n                                        opts,\n-                                       maybe_sysroot);\n+                                       maybe_sysroot,\n+                                       filename,\n+                                       Some(codemap));\n \n     {\n         let dep_graph = DepGraph::new(false);\n@@ -256,7 +260,9 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n                         error_codes.retain(|err| !out.contains(err));\n                     }\n                 }\n-                Ok(()) if compile_fail => panic!(\"test compiled while it wasn't supposed to\"),\n+                Ok(()) if compile_fail => {\n+                    panic!(\"test compiled while it wasn't supposed to\")\n+                }\n                 _ => {}\n             }\n         }\n@@ -302,7 +308,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n             if should_panic && out.status.success() {\n                 panic!(\"test executable succeeded when it should have failed\");\n             } else if !should_panic && !out.status.success() {\n-                panic!(\"test executable failed:\\n{}\\n{}\",\n+                panic!(\"test executable failed:\\n{}\\n{}\\n\",\n                        str::from_utf8(&out.stdout).unwrap_or(\"\"),\n                        str::from_utf8(&out.stderr).unwrap_or(\"\"));\n             }\n@@ -384,11 +390,15 @@ pub struct Collector {\n     cratename: String,\n     opts: TestOptions,\n     maybe_sysroot: Option<PathBuf>,\n+    filename: String,\n+    start_line: usize,\n+    codemap: Option<Rc<CodeMap>>,\n }\n \n impl Collector {\n     pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n-               use_headers: bool, opts: TestOptions, maybe_sysroot: Option<PathBuf>) -> Collector {\n+               use_headers: bool, opts: TestOptions, maybe_sysroot: Option<PathBuf>,\n+               filename: String, codemap: Option<Rc<CodeMap>>) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n@@ -401,18 +411,17 @@ impl Collector {\n             cratename: cratename,\n             opts: opts,\n             maybe_sysroot: maybe_sysroot,\n+            filename: filename,\n+            start_line: 0,\n+            codemap: codemap,\n         }\n     }\n \n     pub fn add_test(&mut self, test: String,\n                     should_panic: bool, no_run: bool, should_ignore: bool,\n-                    as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>) {\n-        let name = if self.use_headers {\n-            let s = self.current_header.as_ref().map(|s| &**s).unwrap_or(\"\");\n-            format!(\"{}_{}\", s, self.cnt)\n-        } else {\n-            format!(\"{}_{}\", self.names.join(\"::\"), self.cnt)\n-        };\n+                    as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n+                    line: usize) {\n+        let name = format!(\"{} - line {}\", self.filename, line);\n         self.cnt += 1;\n         let cfgs = self.cfgs.clone();\n         let libs = self.libs.clone();\n@@ -456,6 +465,19 @@ impl Collector {\n         });\n     }\n \n+    pub fn get_line(&self) -> usize {\n+        if let Some(ref codemap) = self.codemap{\n+            let line = codemap.lookup_char_pos(BytePos(self.start_line as u32)).line;\n+            if line > 0 { line - 1 } else { line }\n+        } else {\n+            self.start_line\n+        }\n+    }\n+\n+    pub fn set_line(&mut self, start_line: usize) {\n+        self.start_line = start_line;\n+    }\n+\n     pub fn register_header(&mut self, name: &str, level: u32) {\n         if self.use_headers && level == 1 {\n             // we use these headings as test names, so it's good if\n@@ -496,7 +518,8 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n         attrs.unindent_doc_comments();\n         if let Some(doc) = attrs.doc_value() {\n             self.collector.cnt = 0;\n-            markdown::find_testable_code(doc, self.collector);\n+            markdown::find_testable_code(doc, self.collector,\n+                                         attrs.span.unwrap_or(DUMMY_SP).lo.to_usize());\n         }\n \n         nested(self);"}, {"sha": "455a6a0fb32e21ae736fd81a50579dabdb09f976", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -280,9 +280,9 @@ impl Attribute {\n                 Symbol::intern(\"doc\"),\n                 Symbol::intern(&strip_doc_comment_decoration(&comment.as_str())));\n             if self.style == ast::AttrStyle::Outer {\n-                f(&mk_attr_outer(self.id, meta))\n+                f(&mk_attr_outer(self.span, self.id, meta))\n             } else {\n-                f(&mk_attr_inner(self.id, meta))\n+                f(&mk_attr_inner(self.span, self.id, meta))\n             }\n         } else {\n             f(self)\n@@ -339,8 +339,8 @@ pub fn mk_attr_id() -> AttrId {\n }\n \n /// Returns an inner attribute with the given value.\n-pub fn mk_attr_inner(id: AttrId, item: MetaItem) -> Attribute {\n-    mk_spanned_attr_inner(DUMMY_SP, id, item)\n+pub fn mk_attr_inner(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n+    mk_spanned_attr_inner(span, id, item)\n }\n \n /// Returns an innter attribute with the given value and span.\n@@ -356,8 +356,8 @@ pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n \n \n /// Returns an outer attribute with the given value.\n-pub fn mk_attr_outer(id: AttrId, item: MetaItem) -> Attribute {\n-    mk_spanned_attr_outer(DUMMY_SP, id, item)\n+pub fn mk_attr_outer(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n+    mk_spanned_attr_outer(span, id, item)\n }\n \n /// Returns an outer attribute with the given value and span."}, {"sha": "f8f1820d0b97ea47f3f566e49d877c8c13c54ae8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -27,6 +27,7 @@ use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n use symbol::{Symbol, keywords};\n+use syntax_pos::DUMMY_SP;\n use tokenstream::{self, TokenTree};\n \n use std::ascii;\n@@ -116,12 +117,12 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n         // #![feature(prelude_import)]\n         let prelude_import_meta = attr::mk_list_word_item(Symbol::intern(\"prelude_import\"));\n         let list = attr::mk_list_item(Symbol::intern(\"feature\"), vec![prelude_import_meta]);\n-        let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), list);\n+        let fake_attr = attr::mk_attr_inner(DUMMY_SP, attr::mk_attr_id(), list);\n         s.print_attribute(&fake_attr)?;\n \n         // #![no_std]\n         let no_std_meta = attr::mk_word_item(Symbol::intern(\"no_std\"));\n-        let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), no_std_meta);\n+        let fake_attr = attr::mk_attr_inner(DUMMY_SP, attr::mk_attr_id(), no_std_meta);\n         s.print_attribute(&fake_attr)?;\n     }\n "}, {"sha": "4a2dfaf61247cb1648e5ea6ce0a3ffb049556421", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -56,7 +56,8 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n     let crate_name = Symbol::intern(&alt_std_name.unwrap_or(name.to_string()));\n \n     krate.module.items.insert(0, P(ast::Item {\n-        attrs: vec![attr::mk_attr_outer(attr::mk_attr_id(),\n+        attrs: vec![attr::mk_attr_outer(DUMMY_SP,\n+                                        attr::mk_attr_id(),\n                                         attr::mk_word_item(Symbol::intern(\"macro_use\")))],\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::ExternCrate(Some(crate_name)),"}, {"sha": "dd2756cd2b22c95aa42b715c59a095488ab4bf41", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -195,7 +195,8 @@ impl fold::Folder for EntryPointCleaner {\n                     let dead_code_str = Symbol::intern(\"dead_code\");\n                     let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n                     let allow_dead_code_item = attr::mk_list_item(allow_str, word_vec);\n-                    let allow_dead_code = attr::mk_attr_outer(attr::mk_attr_id(),\n+                    let allow_dead_code = attr::mk_attr_outer(DUMMY_SP,\n+                                                              attr::mk_attr_id(),\n                                                               allow_dead_code_item);\n \n                     ast::Item {"}, {"sha": "da282f1bb7277b4d30fa1599ee29ad8eb4dd2a92", "filename": "src/rt/hoedown", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fhoedown?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -1 +1 @@\n-Subproject commit a3736a0a1907cbc8bf619708738815a5fd789c80\n+Subproject commit da282f1bb7277b4d30fa1599ee29ad8eb4dd2a92"}, {"sha": "f65cc9e06a329486e467e2071605dd08cbfb1684", "filename": "src/test/run-make/issue-22131/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Ftest%2Frun-make%2Fissue-22131%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Ftest%2Frun-make%2Fissue-22131%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-22131%2FMakefile?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -4,4 +4,4 @@ all: foo.rs\n \t$(RUSTC) --cfg 'feature=\"bar\"' --crate-type lib foo.rs\n \t$(HOST_RPATH_ENV) '$(RUSTDOC)' --test --cfg 'feature=\"bar\"' \\\n \t\t-L $(TMPDIR) foo.rs |\\\n-\t\tgrep -q 'test foo_0 ... ok'\n+\t\tgrep -q 'foo.rs - line 11 ... ok'"}, {"sha": "b2afe43204d41d811c28f679d97226c495bb9a8f", "filename": "src/test/rustdoc/test_option_check/test.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Ftest%2Frustdoc%2Ftest_option_check%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Ftest%2Frustdoc%2Ftest_option_check%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftest_option_check%2Ftest.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+// check-test-line-numbers-match\n+\n+/// This is a Foo;\n+///\n+/// ```\n+/// println!(\"baaaaaar\");\n+/// ```\n+pub struct Foo;\n+\n+/// This is a Bar;\n+///\n+/// ```\n+/// println!(\"fooooo\");\n+/// ```\n+pub struct Bar;"}, {"sha": "786b3192e067568174a23a86b35c13f6e1e59a8a", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -25,7 +25,7 @@ const TEST_REPOS: &'static [Test] = &[\n     Test {\n         name: \"cargo\",\n         repo: \"https://github.com/rust-lang/cargo\",\n-        sha: \"2324c2bbaf7fc6ea9cbdd77c034ef1af769cb617\",\n+        sha: \"0e1e34be7540bdaed4918457654fbf028cf69e56\",\n         lock: None,\n     },\n     Test {"}, {"sha": "71d8d62c75b698adb47cf5c9f96989c3faf4fb2c", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -224,6 +224,8 @@ pub struct TestProps {\n     pub incremental_dir: Option<PathBuf>,\n     // Specifies that a cfail test must actually compile without errors.\n     pub must_compile_successfully: bool,\n+    // rustdoc will test the output of the `--test` option\n+    pub check_test_line_numbers_match: bool,\n }\n \n impl TestProps {\n@@ -248,6 +250,7 @@ impl TestProps {\n             forbid_output: vec![],\n             incremental_dir: None,\n             must_compile_successfully: false,\n+            check_test_line_numbers_match: false,\n         }\n     }\n \n@@ -347,6 +350,10 @@ impl TestProps {\n             if !self.must_compile_successfully {\n                 self.must_compile_successfully = parse_must_compile_successfully(ln);\n             }\n+\n+            if !self.check_test_line_numbers_match {\n+                self.check_test_line_numbers_match = parse_check_test_line_numbers_match(ln);\n+            }\n         });\n \n         for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n@@ -458,6 +465,10 @@ fn parse_must_compile_successfully(line: &str) -> bool {\n     parse_name_directive(line, \"must-compile-successfully\")\n }\n \n+fn parse_check_test_line_numbers_match(line: &str) -> bool {\n+    parse_name_directive(line, \"check-test-line-numbers-match\")\n+}\n+\n fn parse_env(line: &str, name: &str) -> Option<(String, String)> {\n     parse_name_value_directive(line, name).map(|nv| {\n         // nv is either FOO or FOO=BAR"}, {"sha": "a8c46722e163b97956fd27f3e173c3adfb315ba6", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 69, "deletions": 8, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c781fc4a6a8af287f7abe141f035a638bc0165c3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=c781fc4a6a8af287f7abe141f035a638bc0165c3", "patch": "@@ -43,7 +43,7 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n         }\n \n         _ => {\n-            // android has it's own gdb handling\n+            // android has its own gdb handling\n             if config.mode == DebugInfoGdb && config.gdb.is_none() {\n                 panic!(\"gdb not available but debuginfo gdb debuginfo test requested\");\n             }\n@@ -1887,14 +1887,75 @@ actual:\\n\\\n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"rustdoc failed!\", &proc_res);\n         }\n-        let root = self.find_rust_src_root().unwrap();\n \n-        let res = self.cmd2procres(Command::new(&self.config.docck_python)\n-                                   .arg(root.join(\"src/etc/htmldocck.py\"))\n-                                   .arg(out_dir)\n-                                   .arg(&self.testpaths.file));\n-        if !res.status.success() {\n-            self.fatal_proc_rec(\"htmldocck failed!\", &res);\n+        if self.props.check_test_line_numbers_match == true {\n+            self.check_rustdoc_test_option(proc_res);\n+        } else {\n+            let root = self.find_rust_src_root().unwrap();\n+            let res = self.cmd2procres(Command::new(&self.config.docck_python)\n+                                       .arg(root.join(\"src/etc/htmldocck.py\"))\n+                                       .arg(out_dir)\n+                                       .arg(&self.testpaths.file));\n+            if !res.status.success() {\n+                self.fatal_proc_rec(\"htmldocck failed!\", &res);\n+            }\n+        }\n+    }\n+\n+    fn check_rustdoc_test_option(&self, res: ProcRes) {\n+        let mut file = fs::File::open(&self.testpaths.file)\n+                                .expect(\"markdown_test_output_check_entry File::open failed\");\n+        let mut content = String::new();\n+        file.read_to_string(&mut content)\n+            .expect(\"markdown_test_output_check_entry read_to_string failed\");\n+        let mut ignore = false;\n+        let mut v: Vec<usize> =\n+            content.lines()\n+                   .enumerate()\n+                   .filter_map(|(line_nb, line)| {\n+                       let sline = line.split(\"///\").last().unwrap_or(\"\");\n+                       let line = sline.trim_left();\n+                       if line.starts_with(\"```\") {\n+                           if ignore {\n+                               ignore = false;\n+                               None\n+                           } else {\n+                               ignore = true;\n+                               Some(line_nb + 1)\n+                           }\n+                       } else {\n+                           None\n+                       }\n+                   })\n+                   .collect();\n+\n+        let mut tested = 0;\n+        for _ in res.stdout.split(\"\\n\")\n+                           .filter(|s| s.starts_with(\"test \"))\n+                           .inspect(|s| {\n+                               let tmp: Vec<&str> = s.split(\" - line \").collect();\n+                               if tmp.len() == 2 {\n+                                   tested += 1;\n+                                   let line = tmp[1].split(\" ...\")\n+                                                    .next()\n+                                                    .unwrap_or(\"0\")\n+                                                    .parse()\n+                                                    .unwrap_or(0);\n+                                   if let Ok(pos) = v.binary_search(&line) {\n+                                       v.remove(pos);\n+                                   } else {\n+                                       self.fatal_proc_rec(\n+                                           &format!(\"Not found doc test: \\\"{}\\\" in {:?}\", s, v),\n+                                           &res);\n+                                   }\n+                               }\n+                           }) {}\n+        if tested == 0 {\n+            self.fatal_proc_rec(\"No test has been found\", &res);\n+        } else if v.len() != 0 {\n+            self.fatal_proc_rec(&format!(\"Not found test at line{} {:?}\",\n+                                         if v.len() > 1 { \"s\" } else { \"\" }, v),\n+                                &res);\n         }\n     }\n "}]}