{"sha": "87ba8f2a19ef97790571a8b092b95fe87b6b6f76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YmE4ZjJhMTllZjk3NzkwNTcxYThiMDkyYjk1ZmU4N2I2YjZmNzY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-13T01:52:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-13T01:52:48Z"}, "message": "Rollup merge of #68848 - nnethercote:hasten-macro-parsing, r=petrochenkov\n\nHasten macro parsing\n\nr? @eddyb", "tree": {"sha": "2b0f8e0721781926446bdcf1bd4439eb98c98000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b0f8e0721781926446bdcf1bd4439eb98c98000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87ba8f2a19ef97790571a8b092b95fe87b6b6f76", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeRKvwCRBK7hj4Ov3rIwAAdHIIAJXqFKeM3wwzvuSnjQZWAc8a\n35krODwUjkxs9t7P0rut15trCpS00+onHgFM71wLM/UxRuEWTh9FXLXrNPf/EjVg\nJSXLqIlOlF1Dirx8Y+B8VFLHvjhSRS78gEjAUGSjPAXW7efnxvxSV9XW+CxYtWuo\nsfUATMbKqPjiEg30uua7cVpbSSoGaaCf+Btc+/rCJGugsGuXDOnt7SlG17lImUDk\nU3svNuJKdvQqAtyYkJ8MxFXGwFDTfzSPzEbpah+kej+nynHPr4+M0K70sEAnCp1Y\nKGDolFBl94O2m7CxduO4YKWa1Sao1EBeudZmv9iD3PIMQv/8g/i3I9oRCT+paY0=\n=4M/1\n-----END PGP SIGNATURE-----\n", "payload": "tree 2b0f8e0721781926446bdcf1bd4439eb98c98000\nparent 2a201336ed2f253cd22561477764989050acb889\nparent 2a13b24d369b8619f0197993cd5dc60f7217ed72\nauthor Dylan DPC <dylan.dpc@gmail.com> 1581558768 +0100\ncommitter GitHub <noreply@github.com> 1581558768 +0100\n\nRollup merge of #68848 - nnethercote:hasten-macro-parsing, r=petrochenkov\n\nHasten macro parsing\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87ba8f2a19ef97790571a8b092b95fe87b6b6f76", "html_url": "https://github.com/rust-lang/rust/commit/87ba8f2a19ef97790571a8b092b95fe87b6b6f76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a201336ed2f253cd22561477764989050acb889", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a201336ed2f253cd22561477764989050acb889", "html_url": "https://github.com/rust-lang/rust/commit/2a201336ed2f253cd22561477764989050acb889"}, {"sha": "2a13b24d369b8619f0197993cd5dc60f7217ed72", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a13b24d369b8619f0197993cd5dc60f7217ed72", "html_url": "https://github.com/rust-lang/rust/commit/2a13b24d369b8619f0197993cd5dc60f7217ed72"}], "stats": {"total": 137, "additions": 73, "deletions": 64}, "files": [{"sha": "f119c956ced04e078bef2d823b97041276eb4f71", "filename": "src/librustc_expand/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_expand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_expand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Flib.rs?ref=87ba8f2a19ef97790571a8b092b95fe87b6b6f76", "patch": "@@ -1,3 +1,4 @@\n+#![feature(cow_is_borrowed)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(proc_macro_diagnostic)]"}, {"sha": "5bf7602ea6e8f7a37e98fa372e85391b8de4167e", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=87ba8f2a19ef97790571a8b092b95fe87b6b6f76", "patch": "@@ -78,20 +78,19 @@ use crate::mbe::{self, TokenTree};\n \n use rustc_ast_pretty::pprust;\n use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n-use rustc_parse::Directory;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{kw, sym, Symbol};\n use syntax::ast::{Ident, Name};\n use syntax::ptr::P;\n use syntax::token::{self, DocComment, Nonterminal, Token};\n-use syntax::tokenstream::TokenStream;\n \n use rustc_errors::{FatalError, PResult};\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n use std::ops::{Deref, DerefMut};\n@@ -613,28 +612,9 @@ fn inner_parse_loop<'root, 'tt>(\n     Success(())\n }\n \n-/// Use the given sequence of token trees (`ms`) as a matcher. Match the given token stream `tts`\n-/// against it and return the match.\n-///\n-/// # Parameters\n-///\n-/// - `sess`: The session into which errors are emitted\n-/// - `tts`: The tokenstream we are matching against the pattern `ms`\n-/// - `ms`: A sequence of token trees representing a pattern against which we are matching\n-/// - `directory`: Information about the file locations (needed for the black-box parser)\n-/// - `recurse_into_modules`: Whether or not to recurse into modules (needed for the black-box\n-///   parser)\n-pub(super) fn parse(\n-    sess: &ParseSess,\n-    tts: TokenStream,\n-    ms: &[TokenTree],\n-    directory: Option<Directory<'_>>,\n-    recurse_into_modules: bool,\n-) -> NamedParseResult {\n-    // Create a parser that can be used for the \"black box\" parts.\n-    let mut parser =\n-        Parser::new(sess, tts, directory, recurse_into_modules, true, rustc_parse::MACRO_ARGUMENTS);\n-\n+/// Use the given sequence of token trees (`ms`) as a matcher. Match the token\n+/// stream from the given `parser` against it and return the match.\n+pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> NamedParseResult {\n     // A queue of possible matcher positions. We initialize it with the matcher position in which\n     // the \"dot\" is before the first token of the first token tree in `ms`. `inner_parse_loop` then\n     // processes all of these possible matcher positions and produces possible next positions into\n@@ -659,7 +639,7 @@ pub(super) fn parse(\n         // parsing from the black-box parser done. The result is that `next_items` will contain a\n         // bunch of possible next matcher positions in `next_items`.\n         match inner_parse_loop(\n-            sess,\n+            parser.sess,\n             &mut cur_items,\n             &mut next_items,\n             &mut eof_items,\n@@ -684,7 +664,7 @@ pub(super) fn parse(\n             if eof_items.len() == 1 {\n                 let matches =\n                     eof_items[0].matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n-                return nameize(sess, ms, matches);\n+                return nameize(parser.sess, ms, matches);\n             } else if eof_items.len() > 1 {\n                 return Error(\n                     parser.token.span,\n@@ -709,9 +689,14 @@ pub(super) fn parse(\n         // unnecessary implicit clone later in Rc::make_mut.\n         drop(eof_items);\n \n+        // If there are no possible next positions AND we aren't waiting for the black-box parser,\n+        // then there is a syntax error.\n+        if bb_items.is_empty() && next_items.is_empty() {\n+            return Failure(parser.token.clone(), \"no rules expected this token in macro call\");\n+        }\n         // Another possibility is that we need to call out to parse some rust nonterminal\n         // (black-box) parser. However, if there is not EXACTLY ONE of these, something is wrong.\n-        if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {\n+        else if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {\n             let nts = bb_items\n                 .iter()\n                 .map(|item| match item.top_elts.get_tt(item.idx) {\n@@ -733,16 +718,11 @@ pub(super) fn parse(\n                 ),\n             );\n         }\n-        // If there are no possible next positions AND we aren't waiting for the black-box parser,\n-        // then there is a syntax error.\n-        else if bb_items.is_empty() && next_items.is_empty() {\n-            return Failure(parser.token.take(), \"no rules expected this token in macro call\");\n-        }\n         // Dump all possible `next_items` into `cur_items` for the next iteration.\n         else if !next_items.is_empty() {\n             // Now process the next token\n             cur_items.extend(next_items.drain(..));\n-            parser.bump();\n+            parser.to_mut().bump();\n         }\n         // Finally, we have the case where we need to call the black-box parser to get some\n         // nonterminal.\n@@ -754,7 +734,7 @@ pub(super) fn parse(\n                 let match_cur = item.match_cur;\n                 item.push_match(\n                     match_cur,\n-                    MatchedNonterminal(Lrc::new(parse_nt(&mut parser, span, ident.name))),\n+                    MatchedNonterminal(Lrc::new(parse_nt(parser.to_mut(), span, ident.name))),\n                 );\n                 item.idx += 1;\n                 item.match_cur += 1;"}, {"sha": "9e6edee265c989261b17f0049ac7157171e5597c", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=87ba8f2a19ef97790571a8b092b95fe87b6b6f76", "patch": "@@ -1,11 +1,11 @@\n-use crate::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n+use crate::base::{DummyResult, ExpansionData, ExtCtxt, MacResult, TTMacroExpander};\n use crate::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstFragmentKind};\n use crate::mbe;\n use crate::mbe::macro_check;\n-use crate::mbe::macro_parser::parse;\n+use crate::mbe::macro_parser::parse_tt;\n use crate::mbe::macro_parser::{Error, Failure, Success};\n-use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedParseResult};\n+use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq};\n use crate::mbe::transcribe::transcribe;\n \n use rustc_ast_pretty::pprust;\n@@ -166,9 +166,9 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n     }\n }\n \n-fn trace_macros_note(cx: &mut ExtCtxt<'_>, sp: Span, message: String) {\n+fn trace_macros_note(cx_expansions: &mut FxHashMap<Span, Vec<String>>, sp: Span, message: String) {\n     let sp = sp.macro_backtrace().last().map(|trace| trace.call_site).unwrap_or(sp);\n-    cx.expansions.entry(sp).or_default().push(message);\n+    cx_expansions.entry(sp).or_default().push(message);\n }\n \n /// Given `lhses` and `rhses`, this is the new macro we create\n@@ -184,12 +184,36 @@ fn generic_extension<'cx>(\n ) -> Box<dyn MacResult + 'cx> {\n     if cx.trace_macros() {\n         let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(arg.clone()));\n-        trace_macros_note(cx, sp, msg);\n+        trace_macros_note(&mut cx.expansions, sp, msg);\n     }\n \n     // Which arm's failure should we report? (the one furthest along)\n     let mut best_failure: Option<(Token, &str)> = None;\n+\n+    // We create a base parser that can be used for the \"black box\" parts.\n+    // Every iteration needs a fresh copy of that base parser. However, the\n+    // parser is not mutated on many of the iterations, particularly when\n+    // dealing with macros like this:\n+    //\n+    // macro_rules! foo {\n+    //     (\"a\") => (A);\n+    //     (\"b\") => (B);\n+    //     (\"c\") => (C);\n+    //     // ... etc. (maybe hundreds more)\n+    // }\n+    //\n+    // as seen in the `html5ever` benchmark. We use a `Cow` so that the base\n+    // parser is only cloned when necessary (upon mutation). Furthermore, we\n+    // reinitialize the `Cow` with the base parser at the start of every\n+    // iteration, so that any mutated parsers are not reused. This is all quite\n+    // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n+    // 68836 suggests a more comprehensive but more complex change to deal with\n+    // this situation.)\n+    let base_parser = base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+\n     for (i, lhs) in lhses.iter().enumerate() {\n+        let mut parser = Cow::Borrowed(&base_parser);\n+\n         // try each arm's matchers\n         let lhs_tt = match *lhs {\n             mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n@@ -202,7 +226,7 @@ fn generic_extension<'cx>(\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snaphot = mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n \n-        match parse_tt(cx, lhs_tt, arg.clone()) {\n+        match parse_tt(&mut parser, lhs_tt) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n@@ -232,11 +256,11 @@ fn generic_extension<'cx>(\n \n                 if cx.trace_macros() {\n                     let msg = format!(\"to `{}`\", pprust::tts_to_string(tts.clone()));\n-                    trace_macros_note(cx, sp, msg);\n+                    trace_macros_note(&mut cx.expansions, sp, msg);\n                 }\n \n                 let directory = Directory {\n-                    path: Cow::from(cx.current_expansion.module.directory.as_path()),\n+                    path: cx.current_expansion.module.directory.clone(),\n                     ownership: cx.current_expansion.directory_ownership,\n                 };\n                 let mut p = Parser::new(cx.parse_sess(), tts, Some(directory), true, false, None);\n@@ -269,6 +293,7 @@ fn generic_extension<'cx>(\n         // Restore to the state before snapshotting and maybe try again.\n         mem::swap(&mut gated_spans_snaphot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n     }\n+    drop(base_parser);\n \n     let (token, label) = best_failure.expect(\"ran no matchers\");\n     let span = token.span.substitute_dummy(sp);\n@@ -286,7 +311,9 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n-            match parse_tt(cx, lhs_tt, arg.clone()) {\n+            let base_parser =\n+                base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+            match parse_tt(&mut Cow::Borrowed(&base_parser), lhs_tt) {\n                 Success(_) => {\n                     if comma_span.is_dummy() {\n                         err.note(\"you might be missing a comma\");\n@@ -368,7 +395,8 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let argument_map = match parse(sess, body, &argument_gram, None, true) {\n+    let base_parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n+    let argument_map = match parse_tt(&mut Cow::Borrowed(&base_parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n@@ -1184,14 +1212,16 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-/// Use this token tree as a matcher to parse given tts.\n-fn parse_tt(cx: &ExtCtxt<'_>, mtch: &[mbe::TokenTree], tts: TokenStream) -> NamedParseResult {\n-    // `None` is because we're not interpolating\n+fn base_parser_from_cx<'cx>(\n+    current_expansion: &'cx ExpansionData,\n+    sess: &'cx ParseSess,\n+    tts: TokenStream,\n+) -> Parser<'cx> {\n     let directory = Directory {\n-        path: Cow::from(cx.current_expansion.module.directory.as_path()),\n-        ownership: cx.current_expansion.directory_ownership,\n+        path: current_expansion.module.directory.clone(),\n+        ownership: current_expansion.directory_ownership,\n     };\n-    parse(cx.parse_sess(), tts, mtch, Some(directory), true)\n+    Parser::new(sess, tts, Some(directory), true, true, rustc_parse::MACRO_ARGUMENTS)\n }\n \n /// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For"}, {"sha": "4aad2c0f68a29f9e36336cd021108fa1803b6f4f", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=87ba8f2a19ef97790571a8b092b95fe87b6b6f76", "patch": "@@ -12,8 +12,7 @@ use syntax::ast;\n use syntax::token::{self, Nonterminal};\n use syntax::tokenstream::{self, TokenStream, TokenTree};\n \n-use std::borrow::Cow;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::str;\n \n use log::info;\n@@ -29,8 +28,8 @@ pub mod validate_attr;\n pub mod config;\n \n #[derive(Clone)]\n-pub struct Directory<'a> {\n-    pub path: Cow<'a, Path>,\n+pub struct Directory {\n+    pub path: PathBuf,\n     pub ownership: DirectoryOwnership,\n }\n \n@@ -274,7 +273,7 @@ pub fn stream_to_parser<'a>(\n pub fn stream_to_parser_with_base_dir<'a>(\n     sess: &'a ParseSess,\n     stream: TokenStream,\n-    base_dir: Directory<'a>,\n+    base_dir: Directory,\n ) -> Parser<'a> {\n     Parser::new(sess, stream, Some(base_dir), true, false, None)\n }"}, {"sha": "e1461dbb8e763c25f143e5c5b06bbbf4b07125f3", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=87ba8f2a19ef97790571a8b092b95fe87b6b6f76", "patch": "@@ -29,7 +29,6 @@ use syntax::token::{self, DelimToken, Token, TokenKind};\n use syntax::tokenstream::{self, DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use syntax::util::comments::{doc_comment_style, strip_doc_comment_decoration};\n \n-use std::borrow::Cow;\n use std::path::PathBuf;\n use std::{cmp, mem, slice};\n \n@@ -108,7 +107,7 @@ pub struct Parser<'a> {\n     pub prev_span: Span,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n-    pub(super) directory: Directory<'a>,\n+    pub(super) directory: Directory,\n     /// `true` to parse sub-modules in other files.\n     // Public for rustfmt usage.\n     pub recurse_into_file_modules: bool,\n@@ -370,7 +369,7 @@ impl<'a> Parser<'a> {\n     pub fn new(\n         sess: &'a ParseSess,\n         tokens: TokenStream,\n-        directory: Option<Directory<'a>>,\n+        directory: Option<Directory>,\n         recurse_into_file_modules: bool,\n         desugar_doc_comments: bool,\n         subparser_name: Option<&'static str>,\n@@ -385,7 +384,7 @@ impl<'a> Parser<'a> {\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n             directory: Directory {\n-                path: Cow::from(PathBuf::new()),\n+                path: PathBuf::new(),\n                 ownership: DirectoryOwnership::Owned { relative: None },\n             },\n             root_module_name: None,\n@@ -413,7 +412,7 @@ impl<'a> Parser<'a> {\n                 &sess.source_map().lookup_char_pos(parser.token.span.lo()).file.unmapped_path\n             {\n                 if let Some(directory_path) = path.parent() {\n-                    parser.directory.path = Cow::from(directory_path.to_path_buf());\n+                    parser.directory.path = directory_path.to_path_buf();\n                 }\n             }\n         }"}, {"sha": "0c8fad03d869053b0def50ac6c40153a48d52bbc", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87ba8f2a19ef97790571a8b092b95fe87b6b6f76/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=87ba8f2a19ef97790571a8b092b95fe87b6b6f76", "patch": "@@ -285,7 +285,7 @@ impl<'a> Parser<'a> {\n \n     fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n         if let Some(path) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n-            self.directory.path.to_mut().push(&*path.as_str());\n+            self.directory.path.push(&*path.as_str());\n             self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n         } else {\n             // We have to push on the current module name in the case of relative\n@@ -297,10 +297,10 @@ impl<'a> Parser<'a> {\n             if let DirectoryOwnership::Owned { relative } = &mut self.directory.ownership {\n                 if let Some(ident) = relative.take() {\n                     // remove the relative offset\n-                    self.directory.path.to_mut().push(&*ident.as_str());\n+                    self.directory.path.push(&*ident.as_str());\n                 }\n             }\n-            self.directory.path.to_mut().push(&*id.as_str());\n+            self.directory.path.push(&*id.as_str());\n         }\n     }\n }"}]}