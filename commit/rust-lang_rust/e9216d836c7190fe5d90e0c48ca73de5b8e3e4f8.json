{"sha": "e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8", "node_id": "C_kwDOAAsO6NoAKGU5MjE2ZDgzNmM3MTkwZmU1ZDkwZTBjNDhjYTczZGU1YjhlM2U0Zjg", "commit": {"author": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-28T17:17:36Z"}, "committer": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-28T17:17:36Z"}, "message": "Improve `needless_lifetimes`", "tree": {"sha": "cded1edbc4f9d68c378bd2cc677d6ff2b8ed841e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cded1edbc4f9d68c378bd2cc677d6ff2b8ed841e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8", "html_url": "https://github.com/rust-lang/rust/commit/e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43268141da663e42bf3cd1bb4964c5af20c7e979", "url": "https://api.github.com/repos/rust-lang/rust/commits/43268141da663e42bf3cd1bb4964c5af20c7e979", "html_url": "https://github.com/rust-lang/rust/commit/43268141da663e42bf3cd1bb4964c5af20c7e979"}], "stats": {"total": 228, "additions": 168, "deletions": 60}, "files": [{"sha": "996eb277426632f9985f5334f15f24779e950736", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 92, "deletions": 28, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use clippy_utils::trait_ref_of_method;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::intravisit::nested_filter::{self as hir_nested_filter, NestedFilter};\n@@ -151,6 +151,7 @@ fn check_fn_inner<'tcx>(\n         .params\n         .iter()\n         .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n+\n     for typ in types {\n         for pred in generics.bounds_for_param(cx.tcx.hir().local_def_id(typ.hir_id)) {\n             if pred.origin == PredicateOrigin::WhereClause {\n@@ -187,15 +188,30 @@ fn check_fn_inner<'tcx>(\n             }\n         }\n     }\n-    if could_use_elision(cx, decl, body, trait_sig, generics.params) {\n-        span_lint(\n+\n+    if let Some(elidable_lts) = could_use_elision(cx, decl, body, trait_sig, generics.params) {\n+        let lts = elidable_lts\n+            .iter()\n+            // In principle, the result of the call to `Node::ident` could be `unwrap`ped, as `DefId` should refer to a\n+            // `Node::GenericParam`.\n+            .filter_map(|&(def_id, _)| cx.tcx.hir().get_by_def_id(def_id).ident())\n+            .map(|ident| ident.to_string())\n+            .collect::<Vec<_>>()\n+            .join(\", \");\n+\n+        span_lint_and_then(\n             cx,\n             NEEDLESS_LIFETIMES,\n             span.with_hi(decl.output.span().hi()),\n-            \"explicit lifetimes given in parameter types where they could be elided \\\n-             (or replaced with `'_` if needed by type declaration)\",\n+            &format!(\"the following explicit lifetimes could be elided: {lts}\"),\n+            |diag| {\n+                if let Some(span) = elidable_lts.iter().find_map(|&(_, span)| span) {\n+                    diag.span_help(span, \"replace with `'_` in generic arguments such as here\");\n+                }\n+            },\n         );\n     }\n+\n     if report_extra_lifetimes {\n         self::report_extra_lifetimes(cx, decl, generics);\n     }\n@@ -220,13 +236,14 @@ fn explicit_self_type<'tcx>(cx: &LateContext<'tcx>, func: &FnDecl<'tcx>, ident:\n     }\n }\n \n+#[expect(clippy::too_many_lines)]\n fn could_use_elision<'tcx>(\n     cx: &LateContext<'tcx>,\n     func: &'tcx FnDecl<'_>,\n     body: Option<BodyId>,\n     trait_sig: Option<&[Ident]>,\n     named_generics: &'tcx [GenericParam<'_>],\n-) -> bool {\n+) -> Option<Vec<(LocalDefId, Option<Span>)>> {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n@@ -253,15 +270,15 @@ fn could_use_elision<'tcx>(\n     }\n \n     if input_visitor.abort() || output_visitor.abort() {\n-        return false;\n+        return None;\n     }\n \n     let input_lts = input_visitor.lts;\n     let output_lts = output_visitor.lts;\n \n     if let Some(trait_sig) = trait_sig {\n         if explicit_self_type(cx, func, trait_sig.first().copied()) {\n-            return false;\n+            return None;\n         }\n     }\n \n@@ -270,22 +287,22 @@ fn could_use_elision<'tcx>(\n \n         let first_ident = body.params.first().and_then(|param| param.pat.simple_ident());\n         if explicit_self_type(cx, func, first_ident) {\n-            return false;\n+            return None;\n         }\n \n         let mut checker = BodyLifetimeChecker {\n             lifetimes_used_in_body: false,\n         };\n         checker.visit_expr(body.value);\n         if checker.lifetimes_used_in_body {\n-            return false;\n+            return None;\n         }\n     }\n \n     // check for lifetimes from higher scopes\n     for lt in input_lts.iter().chain(output_lts.iter()) {\n         if !allowed_lts.contains(lt) {\n-            return false;\n+            return None;\n         }\n     }\n \n@@ -301,47 +318,62 @@ fn could_use_elision<'tcx>(\n         for lt in input_visitor.nested_elision_site_lts {\n             if let RefLt::Named(def_id) = lt {\n                 if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n-                    return false;\n+                    return None;\n                 }\n             }\n         }\n         for lt in output_visitor.nested_elision_site_lts {\n             if let RefLt::Named(def_id) = lt {\n                 if allowed_lts.contains(&cx.tcx.item_name(def_id.to_def_id())) {\n-                    return false;\n+                    return None;\n                 }\n             }\n         }\n     }\n \n     // no input lifetimes? easy case!\n     if input_lts.is_empty() {\n-        false\n+        None\n     } else if output_lts.is_empty() {\n         // no output lifetimes, check distinctness of input lifetimes\n \n         // only unnamed and static, ok\n         let unnamed_and_static = input_lts.iter().all(|lt| *lt == RefLt::Unnamed || *lt == RefLt::Static);\n         if unnamed_and_static {\n-            return false;\n+            return None;\n+        }\n+        // we have no output reference, so we can elide explicit lifetimes that occur at most once\n+        let elidable_lts = named_lifetime_occurrences(&input_lts)\n+            .into_iter()\n+            .filter_map(|(def_id, occurrences)| {\n+                if occurrences <= 1 {\n+                    Some((def_id, input_visitor.sample_generic_arg_span.get(&def_id).copied()))\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        if elidable_lts.is_empty() {\n+            None\n+        } else {\n+            Some(elidable_lts)\n         }\n-        // we have no output reference, so we only need all distinct lifetimes\n-        input_lts.len() == unique_lifetimes(&input_lts)\n     } else {\n         // we have output references, so we need one input reference,\n         // and all output lifetimes must be the same\n-        if unique_lifetimes(&output_lts) > 1 {\n-            return false;\n-        }\n         if input_lts.len() == 1 {\n             match (&input_lts[0], &output_lts[0]) {\n-                (&RefLt::Named(n1), &RefLt::Named(n2)) if n1 == n2 => true,\n-                (&RefLt::Named(_), &RefLt::Unnamed) => true,\n-                _ => false, /* already elided, different named lifetimes\n-                             * or something static going on */\n+                (&RefLt::Named(n1), &RefLt::Named(n2)) if n1 == n2 => {\n+                    Some(vec![(n1, input_visitor.sample_generic_arg_span.get(&n1).copied())])\n+                },\n+                (&RefLt::Named(n), &RefLt::Unnamed) => {\n+                    Some(vec![(n, input_visitor.sample_generic_arg_span.get(&n).copied())])\n+                },\n+                _ => None, /* already elided, different named lifetimes\n+                            * or something static going on */\n             }\n         } else {\n-            false\n+            None\n         }\n     }\n }\n@@ -358,10 +390,24 @@ fn allowed_lts_from(tcx: TyCtxt<'_>, named_generics: &[GenericParam<'_>]) -> FxH\n     allowed_lts\n }\n \n-/// Number of unique lifetimes in the given vector.\n+/// Number of times each named lifetime occurs in the given slice. Returns a vector to preserve\n+/// relative order.\n #[must_use]\n-fn unique_lifetimes(lts: &[RefLt]) -> usize {\n-    lts.iter().collect::<FxHashSet<_>>().len()\n+fn named_lifetime_occurrences(lts: &[RefLt]) -> Vec<(LocalDefId, usize)> {\n+    let mut occurrences = Vec::new();\n+    for lt in lts {\n+        if let &RefLt::Named(curr_def_id) = lt {\n+            if let Some(i) = occurrences\n+                .iter()\n+                .position(|&(prev_def_id, _)| prev_def_id == curr_def_id)\n+            {\n+                occurrences[i].1 += 1;\n+            } else {\n+                occurrences.push((curr_def_id, 1));\n+            }\n+        }\n+    }\n+    occurrences\n }\n \n const CLOSURE_TRAIT_BOUNDS: [LangItem; 3] = [LangItem::Fn, LangItem::FnMut, LangItem::FnOnce];\n@@ -370,6 +416,7 @@ const CLOSURE_TRAIT_BOUNDS: [LangItem; 3] = [LangItem::Fn, LangItem::FnMut, Lang\n struct RefVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     lts: Vec<RefLt>,\n+    sample_generic_arg_span: FxHashMap<LocalDefId, Span>,\n     nested_elision_site_lts: Vec<RefLt>,\n     unelided_trait_object_lifetime: bool,\n }\n@@ -379,6 +426,7 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n         Self {\n             cx,\n             lts: Vec::new(),\n+            sample_generic_arg_span: FxHashMap::default(),\n             nested_elision_site_lts: Vec::new(),\n             unelided_trait_object_lifetime: false,\n         }\n@@ -472,6 +520,22 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             _ => walk_ty(self, ty),\n         }\n     }\n+\n+    fn visit_generic_arg(&mut self, generic_arg: &'tcx GenericArg<'tcx>) {\n+        if let GenericArg::Lifetime(l) = generic_arg\n+            && let LifetimeName::Param(def_id, _) = l.name\n+        {\n+            self.sample_generic_arg_span.entry(def_id).or_insert(l.span);\n+        }\n+        // Replace with `walk_generic_arg` if/when https://github.com/rust-lang/rust/pull/103692 lands.\n+        // walk_generic_arg(self, generic_arg);\n+        match generic_arg {\n+            GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n+            GenericArg::Type(ty) => self.visit_ty(ty),\n+            GenericArg::Const(ct) => self.visit_anon_const(&ct.value),\n+            GenericArg::Infer(inf) => self.visit_infer(inf),\n+        }\n+    }\n }\n \n /// Are any lifetimes mentioned in the `where` clause? If so, we don't try to"}, {"sha": "3fe1221429495d3ef1924f738e794c46a71762bf", "filename": "tests/ui/needless_lifetimes.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8/tests%2Fui%2Fneedless_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8/tests%2Fui%2Fneedless_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.rs?ref=e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8", "patch": "@@ -419,4 +419,12 @@ mod issue7296 {\n     }\n }\n \n+mod false_negative {\n+    #![allow(unused)]\n+\n+    fn foo<'a>(x: &'a u8, y: &'_ u8) {}\n+\n+    fn bar<'a>(x: &'a u8, y: &'_ u8, z: &'_ u8) {}\n+}\n+\n fn main() {}"}, {"sha": "94787b95181be540c718749932cae7062a761756", "filename": "tests/ui/needless_lifetimes.stderr", "status": "modified", "additions": 68, "deletions": 32, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8/tests%2Fui%2Fneedless_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8/tests%2Fui%2Fneedless_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.stderr?ref=e9216d836c7190fe5d90e0c48ca73de5b8e3e4f8", "patch": "@@ -1,190 +1,226 @@\n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a, 'b\n   --> $DIR/needless_lifetimes.rs:11:1\n    |\n LL | fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::needless-lifetimes` implied by `-D warnings`\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a, 'b\n   --> $DIR/needless_lifetimes.rs:13:1\n    |\n LL | fn distinct_and_static<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: &'static u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:23:1\n    |\n LL | fn in_and_out<'a>(x: &'a u8, _y: u8) -> &'a u8 {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:57:1\n    |\n LL | fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:62:1\n    |\n LL | fn where_clause_without_lt<'a, T>(x: &'a u8, _y: u8) -> Result<&'a u8, ()>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a, 'b\n   --> $DIR/needless_lifetimes.rs:74:1\n    |\n LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace with `'_` in generic arguments such as here\n+  --> $DIR/needless_lifetimes.rs:74:37\n+   |\n+LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n+   |                                     ^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:98:1\n    |\n LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace with `'_` in generic arguments such as here\n+  --> $DIR/needless_lifetimes.rs:98:32\n+   |\n+LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n+   |                                ^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 's\n   --> $DIR/needless_lifetimes.rs:128:5\n    |\n LL |     fn self_and_out<'s>(&'s self) -> &'s u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 's, 't\n   --> $DIR/needless_lifetimes.rs:137:5\n    |\n LL |     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:156:1\n    |\n LL | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace with `'_` in generic arguments such as here\n+  --> $DIR/needless_lifetimes.rs:156:33\n+   |\n+LL | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n+   |                                 ^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:186:1\n    |\n LL | fn trait_obj_elided2<'a>(_arg: &'a dyn Drop) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:192:1\n    |\n LL | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace with `'_` in generic arguments such as here\n+  --> $DIR/needless_lifetimes.rs:192:37\n+   |\n+LL | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n+   |                                     ^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:211:1\n    |\n LL | fn named_input_elided_output<'a>(_arg: &'a str) -> &str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:219:1\n    |\n LL | fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:255:1\n    |\n LL | fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:262:9\n    |\n LL |         fn needless_lt<'a>(x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:266:9\n    |\n LL |         fn needless_lt<'a>(_x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:279:9\n    |\n LL |         fn baz<'a>(&'a self) -> impl Foo + 'a {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:311:5\n    |\n LL |     fn impl_trait_elidable_nested_anonymous_lifetimes<'a>(i: &'a i32, f: impl Fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:320:5\n    |\n LL |     fn generics_elidable<'a, T: Fn(&i32) -> &i32>(i: &'a i32, f: T) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:332:5\n    |\n LL |     fn where_clause_elidadable<'a, T>(i: &'a i32, f: T) -> &'a i32\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:347:5\n    |\n LL |     fn pointer_fn_elidable<'a>(i: &'a i32, f: fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:360:5\n    |\n LL |     fn nested_fn_pointer_3<'a>(_: &'a i32) -> fn(fn(&i32) -> &i32) -> i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:363:5\n    |\n LL |     fn nested_fn_pointer_4<'a>(_: &'a i32) -> impl Fn(fn(&i32)) {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:385:9\n    |\n LL |         fn implicit<'a>(&'a self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:388:9\n    |\n LL |         fn implicit_mut<'a>(&'a mut self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:399:9\n    |\n LL |         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:405:9\n    |\n LL |         fn implicit<'a>(&'a self) -> &'a ();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:406:9\n    |\n LL |         fn implicit_provided<'a>(&'a self) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:415:9\n    |\n LL |         fn lifetime_elsewhere<'a>(self: Box<Self>, here: &'a ()) -> &'a ();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+error: the following explicit lifetimes could be elided: 'a\n   --> $DIR/needless_lifetimes.rs:416:9\n    |\n LL |         fn lifetime_elsewhere_provided<'a>(self: Box<Self>, here: &'a ()) -> &'a () {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 31 previous errors\n+error: the following explicit lifetimes could be elided: 'a\n+  --> $DIR/needless_lifetimes.rs:425:5\n+   |\n+LL |     fn foo<'a>(x: &'a u8, y: &'_ u8) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the following explicit lifetimes could be elided: 'a\n+  --> $DIR/needless_lifetimes.rs:427:5\n+   |\n+LL |     fn bar<'a>(x: &'a u8, y: &'_ u8, z: &'_ u8) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 33 previous errors\n "}]}