{"sha": "4982a59986f7393ace98f63c10e6c435ffba1420", "node_id": "C_kwDOAAsO6NoAKDQ5ODJhNTk5ODZmNzM5M2FjZTk4ZjYzYzEwZTZjNDM1ZmZiYTE0MjA", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-06-22T11:02:23Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-06-28T06:58:27Z"}, "message": "Rename/restructure memory ordering intrinsics.", "tree": {"sha": "500b1a7af30f2fe231b93a827bdb39c927aeea29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/500b1a7af30f2fe231b93a827bdb39c927aeea29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4982a59986f7393ace98f63c10e6c435ffba1420", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4982a59986f7393ace98f63c10e6c435ffba1420", "html_url": "https://github.com/rust-lang/rust/commit/4982a59986f7393ace98f63c10e6c435ffba1420", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4982a59986f7393ace98f63c10e6c435ffba1420/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bf9c20765bd206dd5ec3c5840cee315c17521aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf9c20765bd206dd5ec3c5840cee315c17521aa", "html_url": "https://github.com/rust-lang/rust/commit/8bf9c20765bd206dd5ec3c5840cee315c17521aa"}], "stats": {"total": 1070, "additions": 695, "deletions": 375}, "files": [{"sha": "24f6e020fdb92c25d23a01d6ac5ef9b89ad4c9d5", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -7,6 +7,7 @@\n #![feature(associated_type_bounds)]\n #![feature(strict_provenance)]\n #![feature(int_roundings)]\n+#![feature(if_let_guard)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "7f14b95317b46e66ca0be4501eecfdf7281fe0b0", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -376,32 +376,23 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             // This requires that atomic intrinsics follow a specific naming pattern:\n-            // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n-            name if name_str.starts_with(\"atomic_\") => {\n+            // \"atomic_<operation>[_<ordering>]\"\n+            name if let Some(atomic) = name_str.strip_prefix(\"atomic_\") => {\n                 use crate::common::AtomicOrdering::*;\n                 use crate::common::{AtomicRmwBinOp, SynchronizationScope};\n \n-                let split: Vec<_> = name_str.split('_').collect();\n-\n-                let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n-                let (order, failorder) = match split.len() {\n-                    2 => (SequentiallyConsistent, SequentiallyConsistent),\n-                    3 => match split[2] {\n-                        \"unordered\" => (Unordered, Unordered),\n-                        \"relaxed\" => (Relaxed, Relaxed),\n-                        \"acq\" => (Acquire, Acquire),\n-                        \"rel\" => (Release, Relaxed),\n-                        \"acqrel\" => (AcquireRelease, Acquire),\n-                        \"failrelaxed\" if is_cxchg => (SequentiallyConsistent, Relaxed),\n-                        \"failacq\" if is_cxchg => (SequentiallyConsistent, Acquire),\n-                        _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n-                    },\n-                    4 => match (split[2], split[3]) {\n-                        (\"acq\", \"failrelaxed\") if is_cxchg => (Acquire, Relaxed),\n-                        (\"acqrel\", \"failrelaxed\") if is_cxchg => (AcquireRelease, Relaxed),\n-                        _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n-                    },\n-                    _ => bx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n+                let Some((instruction, ordering)) = atomic.split_once('_') else {\n+                    bx.sess().fatal(\"Atomic intrinsic missing memory ordering\");\n+                };\n+\n+                let parse_ordering = |bx: &Bx, s| match s {\n+                    \"unordered\" => Unordered,\n+                    \"relaxed\" => Relaxed,\n+                    \"acquire\" => Acquire,\n+                    \"release\" => Release,\n+                    \"acqrel\" => AcquireRelease,\n+                    \"seqcst\" => SequentiallyConsistent,\n+                    _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n                 };\n \n                 let invalid_monomorphization = |ty| {\n@@ -416,11 +407,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     );\n                 };\n \n-                match split[1] {\n+                match instruction {\n                     \"cxchg\" | \"cxchgweak\" => {\n+                        let Some((success, failure)) = ordering.split_once('_') else {\n+                            bx.sess().fatal(\"Atomic compare-exchange intrinsic missing failure memory ordering\");\n+                        };\n                         let ty = substs.type_at(0);\n                         if int_type_width_signed(ty, bx.tcx()).is_some() || ty.is_unsafe_ptr() {\n-                            let weak = split[1] == \"cxchgweak\";\n+                            let weak = instruction == \"cxchgweak\";\n                             let mut dst = args[0].immediate();\n                             let mut cmp = args[1].immediate();\n                             let mut src = args[2].immediate();\n@@ -432,7 +426,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 cmp = bx.ptrtoint(cmp, bx.type_isize());\n                                 src = bx.ptrtoint(src, bx.type_isize());\n                             }\n-                            let pair = bx.atomic_cmpxchg(dst, cmp, src, order, failorder, weak);\n+                            let pair = bx.atomic_cmpxchg(dst, cmp, src, parse_ordering(bx, success), parse_ordering(bx, failure), weak);\n                             let val = bx.extract_value(pair, 0);\n                             let success = bx.extract_value(pair, 1);\n                             let val = bx.from_immediate(val);\n@@ -460,11 +454,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 let llty = bx.type_isize();\n                                 let ptr_llty = bx.type_ptr_to(llty);\n                                 source = bx.pointercast(source, ptr_llty);\n-                                let result = bx.atomic_load(llty, source, order, size);\n+                                let result = bx.atomic_load(llty, source, parse_ordering(bx, ordering), size);\n                                 // ... and then cast the result back to a pointer\n                                 bx.inttoptr(result, bx.backend_type(layout))\n                             } else {\n-                                bx.atomic_load(bx.backend_type(layout), source, order, size)\n+                                bx.atomic_load(bx.backend_type(layout), source, parse_ordering(bx, ordering), size)\n                             }\n                         } else {\n                             return invalid_monomorphization(ty);\n@@ -484,20 +478,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 ptr = bx.pointercast(ptr, ptr_llty);\n                                 val = bx.ptrtoint(val, bx.type_isize());\n                             }\n-                            bx.atomic_store(val, ptr, order, size);\n+                            bx.atomic_store(val, ptr, parse_ordering(bx, ordering), size);\n                             return;\n                         } else {\n                             return invalid_monomorphization(ty);\n                         }\n                     }\n \n                     \"fence\" => {\n-                        bx.atomic_fence(order, SynchronizationScope::CrossThread);\n+                        bx.atomic_fence(parse_ordering(bx, ordering), SynchronizationScope::CrossThread);\n                         return;\n                     }\n \n                     \"singlethreadfence\" => {\n-                        bx.atomic_fence(order, SynchronizationScope::SingleThread);\n+                        bx.atomic_fence(parse_ordering(bx, ordering), SynchronizationScope::SingleThread);\n                         return;\n                     }\n \n@@ -531,7 +525,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 ptr = bx.pointercast(ptr, ptr_llty);\n                                 val = bx.ptrtoint(val, bx.type_isize());\n                             }\n-                            bx.atomic_rmw(atom_op, ptr, val, order)\n+                            bx.atomic_rmw(atom_op, ptr, val, parse_ordering(bx, ordering))\n                         } else {\n                             return invalid_monomorphization(ty);\n                         }"}, {"sha": "b1683cf4fc4aea0970c161604e22eed460daacc2", "filename": "compiler/rustc_error_codes/src/error_codes/E0093.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0093.md?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -24,12 +24,12 @@ functions are defined in `compiler/rustc_codegen_llvm/src/intrinsic.rs` and in\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n-    fn atomic_fence(); // ok!\n+    fn atomic_fence_seqcst(); // ok!\n }\n \n fn main() {\n     unsafe {\n-        atomic_fence();\n+        atomic_fence_seqcst();\n     }\n }\n ```"}, {"sha": "a8ce38c9ae1a7919dcc973fd2f603dd2a351f9e8", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 447, "deletions": 134, "changes": 581, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -70,6 +70,214 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n     unsafe { crate::ptr::drop_in_place(to_drop) }\n }\n \n+// These have been renamed.\n+#[cfg(bootstrap)]\n+extern \"rust-intrinsic\" {\n+    pub fn atomic_cxchg<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_load<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_acq<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_store<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_rel<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_xchg<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_fence();\n+    pub fn atomic_fence_acq();\n+    pub fn atomic_fence_rel();\n+    pub fn atomic_fence_acqrel();\n+    pub fn atomic_singlethreadfence();\n+    pub fn atomic_singlethreadfence_acq();\n+    pub fn atomic_singlethreadfence_rel();\n+    pub fn atomic_singlethreadfence_acqrel();\n+}\n+\n+// These have been renamed.\n+#[cfg(bootstrap)]\n+mod atomics {\n+    pub use super::atomic_cxchg as atomic_cxchg_seqcst_seqcst;\n+    pub use super::atomic_cxchg_acq as atomic_cxchg_acquire_acquire;\n+    pub use super::atomic_cxchg_acq_failrelaxed as atomic_cxchg_acquire_relaxed;\n+    pub use super::atomic_cxchg_acqrel as atomic_cxchg_acqrel_acquire;\n+    pub use super::atomic_cxchg_acqrel_failrelaxed as atomic_cxchg_acqrel_relaxed;\n+    pub use super::atomic_cxchg_failacq as atomic_cxchg_seqcst_acquire;\n+    pub use super::atomic_cxchg_failrelaxed as atomic_cxchg_seqcst_relaxed;\n+    pub use super::atomic_cxchg_rel as atomic_cxchg_release_relaxed;\n+    pub use super::atomic_cxchg_relaxed as atomic_cxchg_relaxed_relaxed;\n+\n+    pub use super::atomic_cxchgweak as atomic_cxchgweak_seqcst_seqcst;\n+    pub use super::atomic_cxchgweak_acq as atomic_cxchgweak_acquire_acquire;\n+    pub use super::atomic_cxchgweak_acq_failrelaxed as atomic_cxchgweak_acquire_relaxed;\n+    pub use super::atomic_cxchgweak_acqrel as atomic_cxchgweak_acqrel_acquire;\n+    pub use super::atomic_cxchgweak_acqrel_failrelaxed as atomic_cxchgweak_acqrel_relaxed;\n+    pub use super::atomic_cxchgweak_failacq as atomic_cxchgweak_seqcst_acquire;\n+    pub use super::atomic_cxchgweak_failrelaxed as atomic_cxchgweak_seqcst_relaxed;\n+    pub use super::atomic_cxchgweak_rel as atomic_cxchgweak_release_relaxed;\n+    pub use super::atomic_cxchgweak_relaxed as atomic_cxchgweak_relaxed_relaxed;\n+\n+    pub use super::atomic_load as atomic_load_seqcst;\n+    pub use super::atomic_load_acq as atomic_load_acquire;\n+    pub use super::atomic_load_relaxed;\n+    pub use super::atomic_load_unordered;\n+\n+    pub use super::atomic_store as atomic_store_seqcst;\n+    pub use super::atomic_store_rel as atomic_store_release;\n+    pub use super::atomic_store_relaxed;\n+    pub use super::atomic_store_unordered;\n+\n+    pub use super::atomic_xchg as atomic_xchg_seqcst;\n+    pub use super::atomic_xchg_acq as atomic_xchg_acquire;\n+    pub use super::atomic_xchg_acqrel;\n+    pub use super::atomic_xchg_rel as atomic_xchg_release;\n+    pub use super::atomic_xchg_relaxed;\n+\n+    pub use super::atomic_xadd as atomic_xadd_seqcst;\n+    pub use super::atomic_xadd_acq as atomic_xadd_acquire;\n+    pub use super::atomic_xadd_acqrel;\n+    pub use super::atomic_xadd_rel as atomic_xadd_release;\n+    pub use super::atomic_xadd_relaxed;\n+\n+    pub use super::atomic_xsub as atomic_xsub_seqcst;\n+    pub use super::atomic_xsub_acq as atomic_xsub_acquire;\n+    pub use super::atomic_xsub_acqrel;\n+    pub use super::atomic_xsub_rel as atomic_xsub_release;\n+    pub use super::atomic_xsub_relaxed;\n+\n+    pub use super::atomic_and as atomic_and_seqcst;\n+    pub use super::atomic_and_acq as atomic_and_acquire;\n+    pub use super::atomic_and_acqrel;\n+    pub use super::atomic_and_rel as atomic_and_release;\n+    pub use super::atomic_and_relaxed;\n+\n+    pub use super::atomic_nand as atomic_nand_seqcst;\n+    pub use super::atomic_nand_acq as atomic_nand_acquire;\n+    pub use super::atomic_nand_acqrel;\n+    pub use super::atomic_nand_rel as atomic_nand_release;\n+    pub use super::atomic_nand_relaxed;\n+\n+    pub use super::atomic_or as atomic_or_seqcst;\n+    pub use super::atomic_or_acq as atomic_or_acquire;\n+    pub use super::atomic_or_acqrel;\n+    pub use super::atomic_or_rel as atomic_or_release;\n+    pub use super::atomic_or_relaxed;\n+\n+    pub use super::atomic_xor as atomic_xor_seqcst;\n+    pub use super::atomic_xor_acq as atomic_xor_acquire;\n+    pub use super::atomic_xor_acqrel;\n+    pub use super::atomic_xor_rel as atomic_xor_release;\n+    pub use super::atomic_xor_relaxed;\n+\n+    pub use super::atomic_max as atomic_max_seqcst;\n+    pub use super::atomic_max_acq as atomic_max_acquire;\n+    pub use super::atomic_max_acqrel;\n+    pub use super::atomic_max_rel as atomic_max_release;\n+    pub use super::atomic_max_relaxed;\n+\n+    pub use super::atomic_min as atomic_min_seqcst;\n+    pub use super::atomic_min_acq as atomic_min_acquire;\n+    pub use super::atomic_min_acqrel;\n+    pub use super::atomic_min_rel as atomic_min_release;\n+    pub use super::atomic_min_relaxed;\n+\n+    pub use super::atomic_umin as atomic_umin_seqcst;\n+    pub use super::atomic_umin_acq as atomic_umin_acquire;\n+    pub use super::atomic_umin_acqrel;\n+    pub use super::atomic_umin_rel as atomic_umin_release;\n+    pub use super::atomic_umin_relaxed;\n+\n+    pub use super::atomic_umax as atomic_umax_seqcst;\n+    pub use super::atomic_umax_acq as atomic_umax_acquire;\n+    pub use super::atomic_umax_acqrel;\n+    pub use super::atomic_umax_rel as atomic_umax_release;\n+    pub use super::atomic_umax_relaxed;\n+\n+    pub use super::atomic_fence as atomic_fence_seqcst;\n+    pub use super::atomic_fence_acq as atomic_fence_acquire;\n+    pub use super::atomic_fence_acqrel;\n+    pub use super::atomic_fence_rel as atomic_fence_release;\n+\n+    pub use super::atomic_singlethreadfence as atomic_singlethreadfence_seqcst;\n+    pub use super::atomic_singlethreadfence_acq as atomic_singlethreadfence_acquire;\n+    pub use super::atomic_singlethreadfence_acqrel;\n+    pub use super::atomic_singlethreadfence_rel as atomic_singlethreadfence_release;\n+}\n+\n+#[cfg(bootstrap)]\n+pub use atomics::*;\n+\n+#[cfg(not(bootstrap))]\n extern \"rust-intrinsic\" {\n     // N.B., these intrinsics take raw pointers because they mutate aliased\n     // memory, which is not valid for either `&` or `&mut`.\n@@ -78,142 +286,226 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::Acquire`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::Relaxed`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchg_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n-    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange`].\n-    pub fn atomic_cxchg_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange` method by passing\n+    /// [`Ordering::SeqCst`] as both the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange`].\n+    pub fn atomic_cxchg_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Acquire`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_acq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Release`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_rel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Acquire`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_acqrel<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Relaxed`] as both the `success` and `failure` parameters.\n+    /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    pub fn atomic_cxchgweak_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::SeqCst`] as the `success` and [`Ordering::Acquire`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_failacq<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::Acquire`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_acq_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n-    /// [`Ordering::AcqRel`] as the `success` and [`Ordering::Relaxed`] as the\n-    /// `failure` parameters. For example, [`AtomicBool::compare_exchange_weak`].\n-    pub fn atomic_cxchgweak_acqrel_failrelaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    /// Stores a value if the current value is the same as the `old` value.\n+    ///\n+    /// The stabilized version of this intrinsic is available on the\n+    /// [`atomic`] types via the `compare_exchange_weak` method by passing\n+    /// [`Ordering::SeqCst`] as both the success and failure parameters.\n+    /// For example, [`AtomicBool::compare_exchange_weak`].\n+    pub fn atomic_cxchgweak_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::load`].\n-    pub fn atomic_load<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_seqcst<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::load`].\n-    pub fn atomic_load_acq<T: Copy>(src: *const T) -> T;\n+    pub fn atomic_load_acquire<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -227,13 +519,13 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::store`].\n-    pub fn atomic_store<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::store`].\n-    pub fn atomic_store_rel<T: Copy>(dst: *mut T, val: T);\n+    pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -247,19 +539,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::swap`].\n-    pub fn atomic_xchg<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::swap`].\n-    pub fn atomic_xchg_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::swap`].\n-    pub fn atomic_xchg_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xchg_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -278,19 +570,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n-    pub fn atomic_xadd<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n-    pub fn atomic_xadd_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n-    pub fn atomic_xadd_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xadd_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -309,19 +601,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n-    pub fn atomic_xsub<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n-    pub fn atomic_xsub_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n-    pub fn atomic_xsub_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xsub_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -340,19 +632,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_and`].\n-    pub fn atomic_and<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_and`].\n-    pub fn atomic_and_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_and`].\n-    pub fn atomic_and_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_and_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -371,19 +663,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n-    pub fn atomic_nand<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n-    pub fn atomic_nand_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n-    pub fn atomic_nand_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_nand_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -402,19 +694,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_or`].\n-    pub fn atomic_or<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_or`].\n-    pub fn atomic_or_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_or`].\n-    pub fn atomic_or_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_or_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -433,19 +725,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n-    pub fn atomic_xor<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n-    pub fn atomic_xor_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n-    pub fn atomic_xor_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_xor_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -464,19 +756,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_max`].\n-    pub fn atomic_max<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_max`].\n-    pub fn atomic_max_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_max`].\n-    pub fn atomic_max_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_max_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -495,19 +787,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_min`].\n-    pub fn atomic_min<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_min`].\n-    pub fn atomic_min_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_min`].\n-    pub fn atomic_min_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_min_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -526,19 +818,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_min`].\n-    pub fn atomic_umin<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_min`].\n-    pub fn atomic_umin_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_min`].\n-    pub fn atomic_umin_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umin_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -557,19 +849,19 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_max`].\n-    pub fn atomic_umax<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_max`].\n-    pub fn atomic_umax_acq<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_max`].\n-    pub fn atomic_umax_rel<T: Copy>(dst: *mut T, src: T) -> T;\n+    pub fn atomic_umax_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n@@ -583,67 +875,24 @@ extern \"rust-intrinsic\" {\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_max`].\n     pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n-    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a no-op.\n-    /// Prefetches have no effect on the behavior of the program but can change its performance\n-    /// characteristics.\n-    ///\n-    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n-    ///\n-    /// This intrinsic does not have a stable counterpart.\n-    pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n-    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a no-op.\n-    /// Prefetches have no effect on the behavior of the program but can change its performance\n-    /// characteristics.\n-    ///\n-    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n-    ///\n-    /// This intrinsic does not have a stable counterpart.\n-    pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n-    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a no-op.\n-    /// Prefetches have no effect on the behavior of the program but can change its performance\n-    /// characteristics.\n-    ///\n-    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n-    ///\n-    /// This intrinsic does not have a stable counterpart.\n-    pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n-    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a no-op.\n-    /// Prefetches have no effect on the behavior of the program but can change its performance\n-    /// characteristics.\n-    ///\n-    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n-    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n-    ///\n-    /// This intrinsic does not have a stable counterpart.\n-    pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n-}\n-\n-extern \"rust-intrinsic\" {\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n-    pub fn atomic_fence();\n+    pub fn atomic_fence_seqcst();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n-    pub fn atomic_fence_acq();\n+    pub fn atomic_fence_acquire();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n-    pub fn atomic_fence_rel();\n+    pub fn atomic_fence_release();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n@@ -661,7 +910,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n-    pub fn atomic_singlethreadfence();\n+    pub fn atomic_singlethreadfence_seqcst();\n     /// A compiler-only memory barrier.\n     ///\n     /// Memory accesses will never be reordered across this barrier by the\n@@ -672,7 +921,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n-    pub fn atomic_singlethreadfence_acq();\n+    pub fn atomic_singlethreadfence_acquire();\n     /// A compiler-only memory barrier.\n     ///\n     /// Memory accesses will never be reordered across this barrier by the\n@@ -683,7 +932,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n-    pub fn atomic_singlethreadfence_rel();\n+    pub fn atomic_singlethreadfence_release();\n     /// A compiler-only memory barrier.\n     ///\n     /// Memory accesses will never be reordered across this barrier by the\n@@ -695,6 +944,70 @@ extern \"rust-intrinsic\" {\n     /// [`atomic::compiler_fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n     pub fn atomic_singlethreadfence_acqrel();\n+}\n+\n+// These have been renamed.\n+//\n+// These are the aliases for the old names.\n+// To be removed when stdarch and panic_unwind have been updated.\n+#[cfg(not(bootstrap))]\n+mod atomics {\n+    pub use super::atomic_cxchg_acqrel_acquire as atomic_cxchg_acqrel;\n+    pub use super::atomic_cxchg_acqrel_relaxed as atomic_cxchg_acqrel_failrelaxed;\n+    pub use super::atomic_cxchg_acquire_acquire as atomic_cxchg_acq;\n+    pub use super::atomic_cxchg_acquire_relaxed as atomic_cxchg_acq_failrelaxed;\n+    pub use super::atomic_cxchg_relaxed_relaxed as atomic_cxchg_relaxed;\n+    pub use super::atomic_cxchg_release_relaxed as atomic_cxchg_rel;\n+    pub use super::atomic_cxchg_seqcst_acquire as atomic_cxchg_failacq;\n+    pub use super::atomic_cxchg_seqcst_relaxed as atomic_cxchg_failrelaxed;\n+    pub use super::atomic_cxchg_seqcst_seqcst as atomic_cxchg;\n+    pub use super::atomic_store_seqcst as atomic_store;\n+}\n+\n+#[cfg(not(bootstrap))]\n+pub use atomics::*;\n+\n+extern \"rust-intrinsic\" {\n+    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n+    /// if supported; otherwise, it is a no-op.\n+    /// Prefetches have no effect on the behavior of the program but can change its performance\n+    /// characteristics.\n+    ///\n+    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n+    pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n+    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n+    /// if supported; otherwise, it is a no-op.\n+    /// Prefetches have no effect on the behavior of the program but can change its performance\n+    /// characteristics.\n+    ///\n+    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n+    pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n+    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n+    /// if supported; otherwise, it is a no-op.\n+    /// Prefetches have no effect on the behavior of the program but can change its performance\n+    /// characteristics.\n+    ///\n+    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n+    pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n+    /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n+    /// if supported; otherwise, it is a no-op.\n+    /// Prefetches have no effect on the behavior of the program but can change its performance\n+    /// characteristics.\n+    ///\n+    /// The `locality` argument must be a constant integer and is a temporal locality specifier\n+    /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n+    ///\n+    /// This intrinsic does not have a stable counterpart.\n+    pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n \n     /// Magic intrinsic that derives its meaning from attributes\n     /// attached to the function."}, {"sha": "2fba85077d756831e7e1033ba58db3eccb0d43f3", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 86, "deletions": 74, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -2568,11 +2568,11 @@ unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {\n     // SAFETY: the caller must uphold the safety contract for `atomic_store`.\n     unsafe {\n         match order {\n-            Release => intrinsics::atomic_store_rel(dst, val),\n             Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_store(dst, val),\n+            Release => intrinsics::atomic_store_release(dst, val),\n+            SeqCst => intrinsics::atomic_store_seqcst(dst, val),\n             Acquire => panic!(\"there is no such thing as an acquire store\"),\n-            AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n+            AcqRel => panic!(\"there is no such thing as an acquire-release store\"),\n         }\n     }\n }\n@@ -2582,11 +2582,11 @@ unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_load`.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_load_acq(dst),\n             Relaxed => intrinsics::atomic_load_relaxed(dst),\n-            SeqCst => intrinsics::atomic_load(dst),\n+            Acquire => intrinsics::atomic_load_acquire(dst),\n+            SeqCst => intrinsics::atomic_load_seqcst(dst),\n             Release => panic!(\"there is no such thing as a release load\"),\n-            AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n+            AcqRel => panic!(\"there is no such thing as an acquire-release load\"),\n         }\n     }\n }\n@@ -2597,11 +2597,11 @@ unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_swap`.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_xchg_acq(dst, val),\n-            Release => intrinsics::atomic_xchg_rel(dst, val),\n-            AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_xchg(dst, val),\n+            Acquire => intrinsics::atomic_xchg_acquire(dst, val),\n+            Release => intrinsics::atomic_xchg_release(dst, val),\n+            AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_xchg_seqcst(dst, val),\n         }\n     }\n }\n@@ -2613,11 +2613,11 @@ unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_add`.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_xadd_acq(dst, val),\n-            Release => intrinsics::atomic_xadd_rel(dst, val),\n-            AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_xadd(dst, val),\n+            Acquire => intrinsics::atomic_xadd_acquire(dst, val),\n+            Release => intrinsics::atomic_xadd_release(dst, val),\n+            AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_xadd_seqcst(dst, val),\n         }\n     }\n }\n@@ -2629,11 +2629,11 @@ unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_sub`.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_xsub_acq(dst, val),\n-            Release => intrinsics::atomic_xsub_rel(dst, val),\n-            AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_xsub(dst, val),\n+            Acquire => intrinsics::atomic_xsub_acquire(dst, val),\n+            Release => intrinsics::atomic_xsub_release(dst, val),\n+            AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_xsub_seqcst(dst, val),\n         }\n     }\n }\n@@ -2650,16 +2650,22 @@ unsafe fn atomic_compare_exchange<T: Copy>(\n     // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange`.\n     let (val, ok) = unsafe {\n         match (success, failure) {\n-            (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n-            (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n-            (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n-            (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n-            (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n-            (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n-            (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n-            (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n-            (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n-            (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+            (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed_relaxed(dst, old, new),\n+            //(Relaxed, Acquire) => intrinsics::atomic_cxchg_relaxed_acquire(dst, old, new),\n+            //(Relaxed, SeqCst) => intrinsics::atomic_cxchg_relaxed_seqcst(dst, old, new),\n+            (Acquire, Relaxed) => intrinsics::atomic_cxchg_acquire_relaxed(dst, old, new),\n+            (Acquire, Acquire) => intrinsics::atomic_cxchg_acquire_acquire(dst, old, new),\n+            //(Acquire, SeqCst) => intrinsics::atomic_cxchg_acquire_seqcst(dst, old, new),\n+            (Release, Relaxed) => intrinsics::atomic_cxchg_release_relaxed(dst, old, new),\n+            //(Release, Acquire) => intrinsics::atomic_cxchg_release_acquire(dst, old, new),\n+            //(Release, SeqCst) => intrinsics::atomic_cxchg_release_seqcst(dst, old, new),\n+            (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_relaxed(dst, old, new),\n+            (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel_acquire(dst, old, new),\n+            //(AcqRel, SeqCst) => intrinsics::atomic_cxchg_acqrel_seqcst(dst, old, new),\n+            (SeqCst, Relaxed) => intrinsics::atomic_cxchg_seqcst_relaxed(dst, old, new),\n+            (SeqCst, Acquire) => intrinsics::atomic_cxchg_seqcst_acquire(dst, old, new),\n+            (SeqCst, SeqCst) => intrinsics::atomic_cxchg_seqcst_seqcst(dst, old, new),\n+            (_, AcqRel) => panic!(\"there is no such thing as an acquire-release failure ordering\"),\n             (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n             _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n         }\n@@ -2679,16 +2685,22 @@ unsafe fn atomic_compare_exchange_weak<T: Copy>(\n     // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange_weak`.\n     let (val, ok) = unsafe {\n         match (success, failure) {\n-            (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n-            (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n-            (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n-            (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n-            (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n-            (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n-            (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n-            (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n-            (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n-            (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+            (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed_relaxed(dst, old, new),\n+            //(Relaxed, Acquire) => intrinsics::atomic_cxchgweak_relaxed_acquire(dst, old, new),\n+            //(Relaxed, SeqCst) => intrinsics::atomic_cxchgweak_relaxed_seqcst(dst, old, new),\n+            (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acquire_relaxed(dst, old, new),\n+            (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acquire_acquire(dst, old, new),\n+            //(Acquire, SeqCst) => intrinsics::atomic_cxchgweak_acquire_seqcst(dst, old, new),\n+            (Release, Relaxed) => intrinsics::atomic_cxchgweak_release_relaxed(dst, old, new),\n+            //(Release, Acquire) => intrinsics::atomic_cxchgweak_release_acquire(dst, old, new),\n+            //(Release, SeqCst) => intrinsics::atomic_cxchgweak_release_seqcst(dst, old, new),\n+            (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_relaxed(dst, old, new),\n+            (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel_acquire(dst, old, new),\n+            //(AcqRel, SeqCst) => intrinsics::atomic_cxchgweak_acqrel_seqcst(dst, old, new),\n+            (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_seqcst_relaxed(dst, old, new),\n+            (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_seqcst_acquire(dst, old, new),\n+            (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak_seqcst_seqcst(dst, old, new),\n+            (_, AcqRel) => panic!(\"there is no such thing as an acquire-release failure ordering\"),\n             (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n             _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n         }\n@@ -2702,11 +2714,11 @@ unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_and`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_and_acq(dst, val),\n-            Release => intrinsics::atomic_and_rel(dst, val),\n-            AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_and(dst, val),\n+            Acquire => intrinsics::atomic_and_acquire(dst, val),\n+            Release => intrinsics::atomic_and_release(dst, val),\n+            AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_and_seqcst(dst, val),\n         }\n     }\n }\n@@ -2717,11 +2729,11 @@ unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_nand`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_nand_acq(dst, val),\n-            Release => intrinsics::atomic_nand_rel(dst, val),\n-            AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_nand(dst, val),\n+            Acquire => intrinsics::atomic_nand_acquire(dst, val),\n+            Release => intrinsics::atomic_nand_release(dst, val),\n+            AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_nand_seqcst(dst, val),\n         }\n     }\n }\n@@ -2732,11 +2744,11 @@ unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_or`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_or_acq(dst, val),\n-            Release => intrinsics::atomic_or_rel(dst, val),\n+            SeqCst => intrinsics::atomic_or_seqcst(dst, val),\n+            Acquire => intrinsics::atomic_or_acquire(dst, val),\n+            Release => intrinsics::atomic_or_release(dst, val),\n             AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_or(dst, val),\n         }\n     }\n }\n@@ -2747,11 +2759,11 @@ unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_xor`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_xor_acq(dst, val),\n-            Release => intrinsics::atomic_xor_rel(dst, val),\n+            SeqCst => intrinsics::atomic_xor_seqcst(dst, val),\n+            Acquire => intrinsics::atomic_xor_acquire(dst, val),\n+            Release => intrinsics::atomic_xor_release(dst, val),\n             AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_xor(dst, val),\n         }\n     }\n }\n@@ -2763,11 +2775,11 @@ unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_max`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_max_acq(dst, val),\n-            Release => intrinsics::atomic_max_rel(dst, val),\n-            AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_max(dst, val),\n+            Acquire => intrinsics::atomic_max_acquire(dst, val),\n+            Release => intrinsics::atomic_max_release(dst, val),\n+            AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_max_seqcst(dst, val),\n         }\n     }\n }\n@@ -2779,11 +2791,11 @@ unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_min`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_min_acq(dst, val),\n-            Release => intrinsics::atomic_min_rel(dst, val),\n-            AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_min(dst, val),\n+            Acquire => intrinsics::atomic_min_acquire(dst, val),\n+            Release => intrinsics::atomic_min_release(dst, val),\n+            AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_min_seqcst(dst, val),\n         }\n     }\n }\n@@ -2795,11 +2807,11 @@ unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umax`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_umax_acq(dst, val),\n-            Release => intrinsics::atomic_umax_rel(dst, val),\n-            AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_umax(dst, val),\n+            Acquire => intrinsics::atomic_umax_acquire(dst, val),\n+            Release => intrinsics::atomic_umax_release(dst, val),\n+            AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_umax_seqcst(dst, val),\n         }\n     }\n }\n@@ -2811,11 +2823,11 @@ unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umin`\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_umin_acq(dst, val),\n-            Release => intrinsics::atomic_umin_rel(dst, val),\n-            AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n             Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n-            SeqCst => intrinsics::atomic_umin(dst, val),\n+            Acquire => intrinsics::atomic_umin_acquire(dst, val),\n+            Release => intrinsics::atomic_umin_release(dst, val),\n+            AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n+            SeqCst => intrinsics::atomic_umin_seqcst(dst, val),\n         }\n     }\n }\n@@ -2901,10 +2913,10 @@ pub fn fence(order: Ordering) {\n     // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_fence_acq(),\n-            Release => intrinsics::atomic_fence_rel(),\n+            Acquire => intrinsics::atomic_fence_acquire(),\n+            Release => intrinsics::atomic_fence_release(),\n             AcqRel => intrinsics::atomic_fence_acqrel(),\n-            SeqCst => intrinsics::atomic_fence(),\n+            SeqCst => intrinsics::atomic_fence_seqcst(),\n             Relaxed => panic!(\"there is no such thing as a relaxed fence\"),\n         }\n     }\n@@ -2983,10 +2995,10 @@ pub fn compiler_fence(order: Ordering) {\n     // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {\n-            Acquire => intrinsics::atomic_singlethreadfence_acq(),\n-            Release => intrinsics::atomic_singlethreadfence_rel(),\n+            Acquire => intrinsics::atomic_singlethreadfence_acquire(),\n+            Release => intrinsics::atomic_singlethreadfence_release(),\n             AcqRel => intrinsics::atomic_singlethreadfence_acqrel(),\n-            SeqCst => intrinsics::atomic_singlethreadfence(),\n+            SeqCst => intrinsics::atomic_singlethreadfence_seqcst(),\n             Relaxed => panic!(\"there is no such thing as a relaxed compiler fence\"),\n         }\n     }"}, {"sha": "47d90b1856be51ad7701c19df3a798b451cd6083", "filename": "src/test/run-make-fulldeps/atomic-lock-free/atomic_lock_free.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Frun-make-fulldeps%2Fatomic-lock-free%2Fatomic_lock_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Frun-make-fulldeps%2Fatomic-lock-free%2Fatomic_lock_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fatomic-lock-free%2Fatomic_lock_free.rs?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -3,7 +3,7 @@\n #![no_core]\n \n extern \"rust-intrinsic\" {\n-    fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n+    fn atomic_xadd_seqcst<T>(dst: *mut T, src: T) -> T;\n }\n \n #[lang = \"sized\"]\n@@ -17,50 +17,50 @@ impl<T: ?Sized> Copy for *mut T {}\n \n #[cfg(target_has_atomic = \"8\")]\n pub unsafe fn atomic_u8(x: *mut u8) {\n-    atomic_xadd(x, 1);\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"8\")]\n pub unsafe fn atomic_i8(x: *mut i8) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"16\")]\n pub unsafe fn atomic_u16(x: *mut u16) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"16\")]\n pub unsafe fn atomic_i16(x: *mut i16) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"32\")]\n pub unsafe fn atomic_u32(x: *mut u32) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"32\")]\n pub unsafe fn atomic_i32(x: *mut i32) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"64\")]\n pub unsafe fn atomic_u64(x: *mut u64) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"64\")]\n pub unsafe fn atomic_i64(x: *mut i64) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"128\")]\n pub unsafe fn atomic_u128(x: *mut u128) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"128\")]\n pub unsafe fn atomic_i128(x: *mut i128) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"ptr\")]\n pub unsafe fn atomic_usize(x: *mut usize) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }\n #[cfg(target_has_atomic = \"ptr\")]\n pub unsafe fn atomic_isize(x: *mut isize) {\n-    atomic_xadd(x, 1);\n+    atomic_xadd_seqcst(x, 1);\n }"}, {"sha": "f3b9d569ce3b1977a4d87a0690b529de67cb571c", "filename": "src/test/ui/intrinsics/auxiliary/cci_intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Fui%2Fintrinsics%2Fauxiliary%2Fcci_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Fui%2Fintrinsics%2Fauxiliary%2Fcci_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fauxiliary%2Fcci_intrinsic.rs?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -2,13 +2,13 @@\n \n pub mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xchg_seqcst<T>(dst: *mut T, src: T) -> T;\n     }\n }\n \n #[inline(always)]\n-pub fn atomic_xchg(dst: *mut isize, src: isize) -> isize {\n+pub fn atomic_xchg_seqcst(dst: *mut isize, src: isize) -> isize {\n     unsafe {\n-        rusti::atomic_xchg(dst, src)\n+        rusti::atomic_xchg_seqcst(dst, src)\n     }\n }"}, {"sha": "ce3fa7b0c05e68a7652a046ff100a63045d53b3d", "filename": "src/test/ui/intrinsics/intrinsic-atomics-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics-cc.rs?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -3,10 +3,10 @@\n \n \n extern crate cci_intrinsic;\n-use cci_intrinsic::atomic_xchg;\n+use cci_intrinsic::atomic_xchg_seqcst;\n \n pub fn main() {\n     let mut x = 1;\n-    atomic_xchg(&mut x, 5);\n+    atomic_xchg_seqcst(&mut x, 5);\n     assert_eq!(x, 5);\n }"}, {"sha": "b17f4347be31cce7dd97c0f4614e021e64b4f0f5", "filename": "src/test/ui/intrinsics/intrinsic-atomics.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-atomics.rs?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -3,77 +3,77 @@\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n-        pub fn atomic_cxchg<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n-        pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n-        pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchg_seqcst_seqcst<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchg_acquire_acquire<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchg_release_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n-        pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n-        pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n-        pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchgweak_seqcst_seqcst<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchgweak_acquire_acquire<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchgweak_release_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n-        pub fn atomic_load<T>(src: *const T) -> T;\n-        pub fn atomic_load_acq<T>(src: *const T) -> T;\n+        pub fn atomic_load_seqcst<T>(src: *const T) -> T;\n+        pub fn atomic_load_acquire<T>(src: *const T) -> T;\n \n-        pub fn atomic_store<T>(dst: *mut T, val: T);\n-        pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n+        pub fn atomic_store_seqcst<T>(dst: *mut T, val: T);\n+        pub fn atomic_store_release<T>(dst: *mut T, val: T);\n \n-        pub fn atomic_xchg<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xchg_acq<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xchg_rel<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xchg_seqcst<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xchg_acquire<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xchg_release<T>(dst: *mut T, src: T) -> T;\n \n-        pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xadd_seqcst<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xadd_acquire<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xadd_release<T>(dst: *mut T, src: T) -> T;\n \n-        pub fn atomic_xsub<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xsub_acq<T>(dst: *mut T, src: T) -> T;\n-        pub fn atomic_xsub_rel<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xsub_seqcst<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xsub_acquire<T>(dst: *mut T, src: T) -> T;\n+        pub fn atomic_xsub_release<T>(dst: *mut T, src: T) -> T;\n     }\n }\n \n pub fn main() {\n     unsafe {\n         let mut x: Box<_> = Box::new(1);\n \n-        assert_eq!(rusti::atomic_load(&*x), 1);\n+        assert_eq!(rusti::atomic_load_seqcst(&*x), 1);\n         *x = 5;\n-        assert_eq!(rusti::atomic_load_acq(&*x), 5);\n+        assert_eq!(rusti::atomic_load_acquire(&*x), 5);\n \n-        rusti::atomic_store(&mut *x,3);\n+        rusti::atomic_store_seqcst(&mut *x,3);\n         assert_eq!(*x, 3);\n-        rusti::atomic_store_rel(&mut *x,1);\n+        rusti::atomic_store_release(&mut *x,1);\n         assert_eq!(*x, 1);\n \n-        assert_eq!(rusti::atomic_cxchg(&mut *x, 1, 2), (1, true));\n+        assert_eq!(rusti::atomic_cxchg_seqcst_seqcst(&mut *x, 1, 2), (1, true));\n         assert_eq!(*x, 2);\n \n-        assert_eq!(rusti::atomic_cxchg_acq(&mut *x, 1, 3), (2, false));\n+        assert_eq!(rusti::atomic_cxchg_acquire_acquire(&mut *x, 1, 3), (2, false));\n         assert_eq!(*x, 2);\n \n-        assert_eq!(rusti::atomic_cxchg_rel(&mut *x, 2, 1), (2, true));\n+        assert_eq!(rusti::atomic_cxchg_release_relaxed(&mut *x, 2, 1), (2, true));\n         assert_eq!(*x, 1);\n \n-        assert_eq!(rusti::atomic_xchg(&mut *x, 0), 1);\n+        assert_eq!(rusti::atomic_xchg_seqcst(&mut *x, 0), 1);\n         assert_eq!(*x, 0);\n \n-        assert_eq!(rusti::atomic_xchg_acq(&mut *x, 1), 0);\n+        assert_eq!(rusti::atomic_xchg_acquire(&mut *x, 1), 0);\n         assert_eq!(*x, 1);\n \n-        assert_eq!(rusti::atomic_xchg_rel(&mut *x, 0), 1);\n+        assert_eq!(rusti::atomic_xchg_release(&mut *x, 0), 1);\n         assert_eq!(*x, 0);\n \n-        assert_eq!(rusti::atomic_xadd(&mut *x, 1), 0);\n-        assert_eq!(rusti::atomic_xadd_acq(&mut *x, 1), 1);\n-        assert_eq!(rusti::atomic_xadd_rel(&mut *x, 1), 2);\n+        assert_eq!(rusti::atomic_xadd_seqcst(&mut *x, 1), 0);\n+        assert_eq!(rusti::atomic_xadd_acquire(&mut *x, 1), 1);\n+        assert_eq!(rusti::atomic_xadd_release(&mut *x, 1), 2);\n         assert_eq!(*x, 3);\n \n-        assert_eq!(rusti::atomic_xsub(&mut *x, 1), 3);\n-        assert_eq!(rusti::atomic_xsub_acq(&mut *x, 1), 2);\n-        assert_eq!(rusti::atomic_xsub_rel(&mut *x, 1), 1);\n+        assert_eq!(rusti::atomic_xsub_seqcst(&mut *x, 1), 3);\n+        assert_eq!(rusti::atomic_xsub_acquire(&mut *x, 1), 2);\n+        assert_eq!(rusti::atomic_xsub_release(&mut *x, 1), 1);\n         assert_eq!(*x, 0);\n \n         loop {\n-            let res = rusti::atomic_cxchgweak(&mut *x, 0, 1);\n+            let res = rusti::atomic_cxchgweak_seqcst_seqcst(&mut *x, 0, 1);\n             assert_eq!(res.0, 0);\n             if res.1 {\n                 break;\n@@ -82,7 +82,7 @@ pub fn main() {\n         assert_eq!(*x, 1);\n \n         loop {\n-            let res = rusti::atomic_cxchgweak_acq(&mut *x, 1, 2);\n+            let res = rusti::atomic_cxchgweak_acquire_acquire(&mut *x, 1, 2);\n             assert_eq!(res.0, 1);\n             if res.1 {\n                 break;\n@@ -91,7 +91,7 @@ pub fn main() {\n         assert_eq!(*x, 2);\n \n         loop {\n-            let res = rusti::atomic_cxchgweak_rel(&mut *x, 2, 3);\n+            let res = rusti::atomic_cxchgweak_release_relaxed(&mut *x, 2, 3);\n             assert_eq!(res.0, 2);\n             if res.1 {\n                 break;"}, {"sha": "85ea81ba67961e116765b353888adb88f657bb1f", "filename": "src/test/ui/intrinsics/non-integer-atomic.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.rs?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -12,81 +12,81 @@ pub type Bar = &'static Fn();\n pub type Quux = [u8; 100];\n \n pub unsafe fn test_bool_load(p: &mut bool, v: bool) {\n-    intrinsics::atomic_load(p);\n-    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `bool`\n+    intrinsics::atomic_load_seqcst(p);\n+    //~^ ERROR `atomic_load_seqcst` intrinsic: expected basic integer type, found `bool`\n }\n \n pub unsafe fn test_bool_store(p: &mut bool, v: bool) {\n-    intrinsics::atomic_store(p, v);\n-    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `bool`\n+    intrinsics::atomic_store_seqcst(p, v);\n+    //~^ ERROR `atomic_store_seqcst` intrinsic: expected basic integer type, found `bool`\n }\n \n pub unsafe fn test_bool_xchg(p: &mut bool, v: bool) {\n-    intrinsics::atomic_xchg(p, v);\n-    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `bool`\n+    intrinsics::atomic_xchg_seqcst(p, v);\n+    //~^ ERROR `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `bool`\n }\n \n pub unsafe fn test_bool_cxchg(p: &mut bool, v: bool) {\n-    intrinsics::atomic_cxchg(p, v, v);\n-    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `bool`\n+    intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+    //~^ ERROR `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `bool`\n }\n \n pub unsafe fn test_Foo_load(p: &mut Foo, v: Foo) {\n-    intrinsics::atomic_load(p);\n-    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `Foo`\n+    intrinsics::atomic_load_seqcst(p);\n+    //~^ ERROR `atomic_load_seqcst` intrinsic: expected basic integer type, found `Foo`\n }\n \n pub unsafe fn test_Foo_store(p: &mut Foo, v: Foo) {\n-    intrinsics::atomic_store(p, v);\n-    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `Foo`\n+    intrinsics::atomic_store_seqcst(p, v);\n+    //~^ ERROR `atomic_store_seqcst` intrinsic: expected basic integer type, found `Foo`\n }\n \n pub unsafe fn test_Foo_xchg(p: &mut Foo, v: Foo) {\n-    intrinsics::atomic_xchg(p, v);\n-    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `Foo`\n+    intrinsics::atomic_xchg_seqcst(p, v);\n+    //~^ ERROR `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `Foo`\n }\n \n pub unsafe fn test_Foo_cxchg(p: &mut Foo, v: Foo) {\n-    intrinsics::atomic_cxchg(p, v, v);\n-    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `Foo`\n+    intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+    //~^ ERROR `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `Foo`\n }\n \n pub unsafe fn test_Bar_load(p: &mut Bar, v: Bar) {\n-    intrinsics::atomic_load(p);\n+    intrinsics::atomic_load_seqcst(p);\n     //~^ ERROR expected basic integer type, found `&dyn Fn()`\n }\n \n pub unsafe fn test_Bar_store(p: &mut Bar, v: Bar) {\n-    intrinsics::atomic_store(p, v);\n+    intrinsics::atomic_store_seqcst(p, v);\n     //~^ ERROR expected basic integer type, found `&dyn Fn()`\n }\n \n pub unsafe fn test_Bar_xchg(p: &mut Bar, v: Bar) {\n-    intrinsics::atomic_xchg(p, v);\n+    intrinsics::atomic_xchg_seqcst(p, v);\n     //~^ ERROR expected basic integer type, found `&dyn Fn()`\n }\n \n pub unsafe fn test_Bar_cxchg(p: &mut Bar, v: Bar) {\n-    intrinsics::atomic_cxchg(p, v, v);\n+    intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n     //~^ ERROR expected basic integer type, found `&dyn Fn()`\n }\n \n pub unsafe fn test_Quux_load(p: &mut Quux, v: Quux) {\n-    intrinsics::atomic_load(p);\n-    //~^ ERROR `atomic_load` intrinsic: expected basic integer type, found `[u8; 100]`\n+    intrinsics::atomic_load_seqcst(p);\n+    //~^ ERROR `atomic_load_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n }\n \n pub unsafe fn test_Quux_store(p: &mut Quux, v: Quux) {\n-    intrinsics::atomic_store(p, v);\n-    //~^ ERROR `atomic_store` intrinsic: expected basic integer type, found `[u8; 100]`\n+    intrinsics::atomic_store_seqcst(p, v);\n+    //~^ ERROR `atomic_store_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n }\n \n pub unsafe fn test_Quux_xchg(p: &mut Quux, v: Quux) {\n-    intrinsics::atomic_xchg(p, v);\n-    //~^ ERROR `atomic_xchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+    intrinsics::atomic_xchg_seqcst(p, v);\n+    //~^ ERROR `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n }\n \n pub unsafe fn test_Quux_cxchg(p: &mut Quux, v: Quux) {\n-    intrinsics::atomic_cxchg(p, v, v);\n-    //~^ ERROR `atomic_cxchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+    intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+    //~^ ERROR `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n }"}, {"sha": "32791a8e8b7f1c870fe357c19817046327025fd7", "filename": "src/test/ui/intrinsics/non-integer-atomic.stderr", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4982a59986f7393ace98f63c10e6c435ffba1420/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fnon-integer-atomic.stderr?ref=4982a59986f7393ace98f63c10e6c435ffba1420", "patch": "@@ -1,98 +1,98 @@\n-error[E0511]: invalid monomorphization of `atomic_load` intrinsic: expected basic integer type, found `bool`\n+error[E0511]: invalid monomorphization of `atomic_load_seqcst` intrinsic: expected basic integer type, found `bool`\n   --> $DIR/non-integer-atomic.rs:15:5\n    |\n-LL |     intrinsics::atomic_load(p);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_load_seqcst(p);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_store` intrinsic: expected basic integer type, found `bool`\n+error[E0511]: invalid monomorphization of `atomic_store_seqcst` intrinsic: expected basic integer type, found `bool`\n   --> $DIR/non-integer-atomic.rs:20:5\n    |\n-LL |     intrinsics::atomic_store(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_store_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_xchg` intrinsic: expected basic integer type, found `bool`\n+error[E0511]: invalid monomorphization of `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `bool`\n   --> $DIR/non-integer-atomic.rs:25:5\n    |\n-LL |     intrinsics::atomic_xchg(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_xchg_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_cxchg` intrinsic: expected basic integer type, found `bool`\n+error[E0511]: invalid monomorphization of `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `bool`\n   --> $DIR/non-integer-atomic.rs:30:5\n    |\n-LL |     intrinsics::atomic_cxchg(p, v, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_load` intrinsic: expected basic integer type, found `Foo`\n+error[E0511]: invalid monomorphization of `atomic_load_seqcst` intrinsic: expected basic integer type, found `Foo`\n   --> $DIR/non-integer-atomic.rs:35:5\n    |\n-LL |     intrinsics::atomic_load(p);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_load_seqcst(p);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_store` intrinsic: expected basic integer type, found `Foo`\n+error[E0511]: invalid monomorphization of `atomic_store_seqcst` intrinsic: expected basic integer type, found `Foo`\n   --> $DIR/non-integer-atomic.rs:40:5\n    |\n-LL |     intrinsics::atomic_store(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_store_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_xchg` intrinsic: expected basic integer type, found `Foo`\n+error[E0511]: invalid monomorphization of `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `Foo`\n   --> $DIR/non-integer-atomic.rs:45:5\n    |\n-LL |     intrinsics::atomic_xchg(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_xchg_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_cxchg` intrinsic: expected basic integer type, found `Foo`\n+error[E0511]: invalid monomorphization of `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `Foo`\n   --> $DIR/non-integer-atomic.rs:50:5\n    |\n-LL |     intrinsics::atomic_cxchg(p, v, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_load` intrinsic: expected basic integer type, found `&dyn Fn()`\n+error[E0511]: invalid monomorphization of `atomic_load_seqcst` intrinsic: expected basic integer type, found `&dyn Fn()`\n   --> $DIR/non-integer-atomic.rs:55:5\n    |\n-LL |     intrinsics::atomic_load(p);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_load_seqcst(p);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_store` intrinsic: expected basic integer type, found `&dyn Fn()`\n+error[E0511]: invalid monomorphization of `atomic_store_seqcst` intrinsic: expected basic integer type, found `&dyn Fn()`\n   --> $DIR/non-integer-atomic.rs:60:5\n    |\n-LL |     intrinsics::atomic_store(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_store_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_xchg` intrinsic: expected basic integer type, found `&dyn Fn()`\n+error[E0511]: invalid monomorphization of `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `&dyn Fn()`\n   --> $DIR/non-integer-atomic.rs:65:5\n    |\n-LL |     intrinsics::atomic_xchg(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_xchg_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_cxchg` intrinsic: expected basic integer type, found `&dyn Fn()`\n+error[E0511]: invalid monomorphization of `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `&dyn Fn()`\n   --> $DIR/non-integer-atomic.rs:70:5\n    |\n-LL |     intrinsics::atomic_cxchg(p, v, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_load` intrinsic: expected basic integer type, found `[u8; 100]`\n+error[E0511]: invalid monomorphization of `atomic_load_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n   --> $DIR/non-integer-atomic.rs:75:5\n    |\n-LL |     intrinsics::atomic_load(p);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_load_seqcst(p);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_store` intrinsic: expected basic integer type, found `[u8; 100]`\n+error[E0511]: invalid monomorphization of `atomic_store_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n   --> $DIR/non-integer-atomic.rs:80:5\n    |\n-LL |     intrinsics::atomic_store(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_store_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_xchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+error[E0511]: invalid monomorphization of `atomic_xchg_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n   --> $DIR/non-integer-atomic.rs:85:5\n    |\n-LL |     intrinsics::atomic_xchg(p, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_xchg_seqcst(p, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `atomic_cxchg` intrinsic: expected basic integer type, found `[u8; 100]`\n+error[E0511]: invalid monomorphization of `atomic_cxchg_seqcst_seqcst` intrinsic: expected basic integer type, found `[u8; 100]`\n   --> $DIR/non-integer-atomic.rs:90:5\n    |\n-LL |     intrinsics::atomic_cxchg(p, v, v);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     intrinsics::atomic_cxchg_seqcst_seqcst(p, v, v);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 16 previous errors\n "}]}