{"sha": "c888af52be46ed87bb14043da02df486288701c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ODhhZjUyYmU0NmVkODdiYjE0MDQzZGEwMmRmNDg2Mjg4NzAxYzY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-13T15:19:35Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-01T22:10:58Z"}, "message": "Replace ConstVariableTable with UnificationTable", "tree": {"sha": "2f2a6ed6e7f3517cba98f4ebd1118d8befca0d35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f2a6ed6e7f3517cba98f4ebd1118d8befca0d35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c888af52be46ed87bb14043da02df486288701c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c888af52be46ed87bb14043da02df486288701c6", "html_url": "https://github.com/rust-lang/rust/commit/c888af52be46ed87bb14043da02df486288701c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c888af52be46ed87bb14043da02df486288701c6/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2308d2d68aa726eac33e8a5a43e70ab1b002ed1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2308d2d68aa726eac33e8a5a43e70ab1b002ed1b", "html_url": "https://github.com/rust-lang/rust/commit/2308d2d68aa726eac33e8a5a43e70ab1b002ed1b"}], "stats": {"total": 509, "additions": 181, "deletions": 328}, "files": [{"sha": "7ee762d94ae6c8b6b20caddf5ddba7819e6eba86", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=c888af52be46ed87bb14043da02df486288701c6", "patch": "@@ -28,7 +28,7 @@ use super::{InferCtxt, MiscVariable, TypeTrace};\n use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n-use super::const_variable::ConstVariableValue;\n+use super::unify_key::{ConstVarValue, ConstVariableValue, ConstVariableOrigin};\n \n use crate::hir::def_id::DefId;\n use crate::mir::interpret::ConstValue;\n@@ -40,7 +40,7 @@ use crate::ty::subst::SubstsRef;\n use crate::traits::{Obligation, PredicateObligations};\n \n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Clone)]\n pub struct CombineFields<'infcx, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -166,7 +166,10 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     ) -> RelateResult<'tcx, &'tcx LazyConst<'tcx>> {\n         self.const_unification_table\n             .borrow_mut()\n-            .unify_var_value(vid, ConstVariableValue::Known { value })\n+            .unify_var_value(vid, ConstVarValue {\n+                origin: ConstVariableOrigin::ConstInference(DUMMY_SP),\n+                val: ConstVariableValue::Known { value },\n+            })\n             .map_err(|e| const_unification_error(vid_is_expected, e))?;\n         Ok(value)\n     }\n@@ -590,7 +593,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 ..\n             }) => {\n                 let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n-                match variable_table.probe(*vid).known() {\n+                match variable_table.probe_value(*vid).val.known() {\n                     Some(u) => {\n                         self.relate(&u, &u)\n                     }"}, {"sha": "ac758add872fec534165980eac6a409079abfe89", "filename": "src/librustc/infer/const_variable.rs", "status": "removed", "additions": 0, "deletions": 271, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/2308d2d68aa726eac33e8a5a43e70ab1b002ed1b/src%2Flibrustc%2Finfer%2Fconst_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2308d2d68aa726eac33e8a5a43e70ab1b002ed1b/src%2Flibrustc%2Finfer%2Fconst_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fconst_variable.rs?ref=2308d2d68aa726eac33e8a5a43e70ab1b002ed1b", "patch": "@@ -1,271 +0,0 @@\n-use crate::mir::interpret::ConstValue;\n-use syntax::symbol::InternedString;\n-use syntax_pos::Span;\n-use crate::ty::{self, InferConst};\n-\n-use std::cmp;\n-use std::marker::PhantomData;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::snapshot_vec as sv;\n-use rustc_data_structures::unify as ut;\n-\n-pub struct ConstVariableTable<'tcx> {\n-    values: sv::SnapshotVec<Delegate<'tcx>>,\n-\n-    relations: ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>,\n-}\n-\n-/// Reasons to create a const inference variable\n-#[derive(Copy, Clone, Debug)]\n-pub enum ConstVariableOrigin {\n-    MiscVariable(Span),\n-    ConstInference(Span),\n-    ConstParameterDefinition(Span, InternedString),\n-    SubstitutionPlaceholder(Span),\n-}\n-\n-pub type ConstVariableMap<'tcx> = FxHashMap<ty::ConstVid<'tcx>, ConstVariableOrigin>;\n-\n-struct ConstVariableData {\n-    origin: ConstVariableOrigin,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum ConstVariableValue<'tcx> {\n-    Known { value: &'tcx ty::LazyConst<'tcx> },\n-    Unknown { universe: ty::UniverseIndex },\n-}\n-\n-impl<'tcx> ConstVariableValue<'tcx> {\n-    /// If this value is known, returns the const it is known to be.\n-    /// Otherwise, `None`.\n-    pub fn known(&self) -> Option<&'tcx ty::LazyConst<'tcx>> {\n-        match *self {\n-            ConstVariableValue::Unknown { .. } => None,\n-            ConstVariableValue::Known { value } => Some(value),\n-        }\n-    }\n-\n-    pub fn is_unknown(&self) -> bool {\n-        match *self {\n-            ConstVariableValue::Unknown { .. } => true,\n-            ConstVariableValue::Known { .. } => false,\n-        }\n-    }\n-}\n-\n-pub struct Snapshot<'tcx> {\n-    snapshot: sv::Snapshot,\n-    relation_snapshot: ut::Snapshot<ut::InPlace<ty::ConstVid<'tcx>>>,\n-}\n-\n-struct Instantiate<'tcx> {\n-    _vid: ty::ConstVid<'tcx>,\n-}\n-\n-struct Delegate<'tcx> {\n-    pub phantom: PhantomData<&'tcx ()>,\n-}\n-\n-impl<'tcx> ConstVariableTable<'tcx> {\n-    pub fn new() -> ConstVariableTable<'tcx> {\n-        ConstVariableTable {\n-            values: sv::SnapshotVec::new(),\n-            relations: ut::UnificationTable::new(),\n-        }\n-    }\n-\n-    /// Returns the origin that was given when `vid` was created.\n-    ///\n-    /// Note that this function does not return care whether\n-    /// `vid` has been unified with something else or not.\n-    pub fn var_origin(&self, vid: ty::ConstVid<'tcx>) -> &ConstVariableOrigin {\n-        &self.values[vid.index as usize].origin\n-    }\n-\n-    pub fn unify_var_var(\n-        &mut self,\n-        a_id: ty::ConstVid<'tcx>,\n-        b_id: ty::ConstVid<'tcx>,\n-    ) -> Result<(), (&'tcx ty::LazyConst<'tcx>, &'tcx ty::LazyConst<'tcx>)> {\n-        self.relations.unify_var_var(a_id, b_id)\n-    }\n-\n-    pub fn unify_var_value(\n-        &mut self,\n-        a_id: ty::ConstVid<'tcx>,\n-        b: ConstVariableValue<'tcx>,\n-    ) -> Result<(), (&'tcx ty::LazyConst<'tcx>, &'tcx ty::LazyConst<'tcx>)> {\n-        self.relations.unify_var_value(a_id, b)\n-    }\n-\n-    /// Creates a new const variable.\n-    ///\n-    /// - `origin`: indicates *why* the const variable was created.\n-    ///   The code in this module doesn't care, but it can be useful\n-    ///   for improving error messages.\n-    pub fn new_var(\n-        &mut self,\n-        universe: ty::UniverseIndex,\n-        origin: ConstVariableOrigin,\n-    ) -> ty::ConstVid<'tcx> {\n-        let vid = self.relations.new_key(ConstVariableValue::Unknown{ universe });\n-\n-        let index = self.values.push(ConstVariableData {\n-            origin,\n-        });\n-        assert_eq!(vid.index, index as u32);\n-\n-        debug!(\"new_var(index={:?}, origin={:?}\", vid, origin);\n-\n-        vid\n-    }\n-\n-    /// Retrieves the type to which `vid` has been instantiated, if\n-    /// any.\n-    pub fn probe(\n-        &mut self,\n-        vid: ty::ConstVid<'tcx>\n-    ) -> ConstVariableValue<'tcx> {\n-        self.relations.probe_value(vid)\n-    }\n-\n-    /// If `t` is a type-inference variable, and it has been\n-    /// instantiated, then return the with which it was\n-    /// instantiated. Otherwise, returns `t`.\n-    pub fn replace_if_possible(\n-        &mut self,\n-        c: &'tcx ty::LazyConst<'tcx>\n-    ) -> &'tcx ty::LazyConst<'tcx> {\n-        if let ty::LazyConst::Evaluated(ty::Const {\n-            val: ConstValue::Infer(InferConst::Var(vid)),\n-            ..\n-        }) = c {\n-            match self.probe(*vid).known() {\n-                Some(c) => c,\n-                None => c,\n-            }\n-        } else {\n-            c\n-        }\n-    }\n-\n-    /// Creates a snapshot of the type variable state.  This snapshot\n-    /// must later be committed (`commit()`) or rolled back\n-    /// (`rollback_to()`).  Nested snapshots are permitted, but must\n-    /// be processed in a stack-like fashion.\n-    pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n-        Snapshot {\n-            snapshot: self.values.start_snapshot(),\n-            relation_snapshot: self.relations.snapshot(),\n-        }\n-    }\n-\n-    /// Undoes all changes since the snapshot was created. Any\n-    /// snapshots created since that point must already have been\n-    /// committed or rolled back.\n-    pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n-        debug!(\"rollback_to{:?}\", {\n-            for action in self.values.actions_since_snapshot(&s.snapshot) {\n-                if let sv::UndoLog::NewElem(index) = *action {\n-                    debug!(\"inference variable _#{}t popped\", index)\n-                }\n-            }\n-        });\n-\n-        let Snapshot { snapshot, relation_snapshot } = s;\n-        self.values.rollback_to(snapshot);\n-        self.relations.rollback_to(relation_snapshot);\n-    }\n-\n-    /// Commits all changes since the snapshot was created, making\n-    /// them permanent (unless this snapshot was created within\n-    /// another snapshot). Any snapshots created since that point\n-    /// must already have been committed or rolled back.\n-    pub fn commit(&mut self, s: Snapshot<'tcx>) {\n-        let Snapshot { snapshot, relation_snapshot } = s;\n-        self.values.commit(snapshot);\n-        self.relations.commit(relation_snapshot);\n-    }\n-\n-    /// Returns a map `{V1 -> V2}`, where the keys `{V1}` are\n-    /// const-variables created during the snapshot, and the values\n-    /// `{V2}` are the root variables that they were unified with,\n-    /// along with their origin.\n-    pub fn consts_created_since_snapshot(\n-        &mut self,\n-        s: &Snapshot<'tcx>\n-    ) -> ConstVariableMap<'tcx> {\n-        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n-\n-        actions_since_snapshot\n-            .iter()\n-            .filter_map(|action| match action {\n-                &sv::UndoLog::NewElem(index) => Some(ty::ConstVid {\n-                    index: index as u32,\n-                    phantom: PhantomData,\n-                }),\n-                _ => None,\n-            })\n-            .map(|vid| {\n-                let origin = self.values.get(vid.index as usize).origin.clone();\n-                (vid, origin)\n-            })\n-            .collect()\n-    }\n-}\n-\n-impl<'tcx> ut::UnifyKey for ty::ConstVid<'tcx> {\n-    type Value = ConstVariableValue<'tcx>;\n-    fn index(&self) -> u32 { self.index }\n-    fn from_index(i: u32) -> Self { ty::ConstVid { index: i, phantom: PhantomData } }\n-    fn tag() -> &'static str { \"ConstVid\" }\n-}\n-\n-impl<'tcx> ut::UnifyValue for ConstVariableValue<'tcx> {\n-    type Error = (&'tcx ty::LazyConst<'tcx>, &'tcx ty::LazyConst<'tcx>);\n-\n-    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, Self::Error> {\n-        match (value1, value2) {\n-            (\n-                &ConstVariableValue::Known { value: value1 },\n-                &ConstVariableValue::Known { value: value2 }\n-            ) => {\n-                match <&'tcx ty::LazyConst<'tcx>>::unify_values(&value1, &value2) {\n-                    Ok(value) => Ok(ConstVariableValue::Known { value }),\n-                    Err(err) => Err(err),\n-                }\n-            }\n-\n-            // If one side is known, prefer that one.\n-            (&ConstVariableValue::Known { .. }, &ConstVariableValue::Unknown { .. }) => Ok(*value1),\n-            (&ConstVariableValue::Unknown { .. }, &ConstVariableValue::Known { .. }) => Ok(*value2),\n-\n-            // If both sides are *unknown*, it hardly matters, does it?\n-            (&ConstVariableValue::Unknown { universe: universe1 },\n-             &ConstVariableValue::Unknown { universe: universe2 }) =>  {\n-                // If we unify two unbound variables, ?T and ?U, then whatever\n-                // value they wind up taking (which must be the same value) must\n-                // be nameable by both universes. Therefore, the resulting\n-                // universe is the minimum of the two universes, because that is\n-                // the one which contains the fewest names in scope.\n-                let universe = cmp::min(universe1, universe2);\n-                Ok(ConstVariableValue::Unknown { universe })\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> ut::EqUnifyValue for &'tcx ty::LazyConst<'tcx> {}\n-\n-impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n-    type Value = ConstVariableData;\n-    type Undo = Instantiate<'tcx>;\n-\n-    fn reverse(_values: &mut Vec<ConstVariableData>, _action: Instantiate<'tcx>) {\n-        // We don't actually have to *do* anything to reverse an\n-        // instantiation; the value for a variable is stored in the\n-        // `relations` and hence its rollback code will handle\n-        // it.\n-    }\n-}"}, {"sha": "226ab8b438e3fff96f88c91be9b1791f477be154", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=c888af52be46ed87bb14043da02df486288701c6", "patch": "@@ -8,6 +8,7 @@ use crate::ty::TyVar;\n use crate::ty::subst::SubstsRef;\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::mir::interpret::ConstValue;\n+use crate::infer::unify_key::replace_if_possible;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n pub struct Equate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -110,8 +111,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.const_unification_table.borrow_mut().replace_if_possible(a);\n-        let b = infcx.const_unification_table.borrow_mut().replace_if_possible(b);\n+        let a = replace_if_possible(infcx.const_unification_table.borrow_mut(), a);\n+        let b = replace_if_possible(infcx.const_unification_table.borrow_mut(), b);\n         let a_is_expected = self.a_is_expected();\n         if let (&ty::LazyConst::Evaluated(a_eval), &ty::LazyConst::Evaluated(b_eval)) = (a, b) {\n             match (a_eval.val, b_eval.val) {"}, {"sha": "a1de08847887176a7813ad310a2bc19f85a9faa9", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=c888af52be46ed87bb14043da02df486288701c6", "patch": "@@ -232,7 +232,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 ConstValue::Infer(ty::InferConst::Var(v)) => {\n                     let opt_ct = self.infcx.const_unification_table\n                         .borrow_mut()\n-                        .probe(*v)\n+                        .probe_value(*v)\n+                        .val\n                         .known();\n                     return self.freshen_const(\n                         opt_ct,"}, {"sha": "43f4ecfb852bf321f230e1ffad9caeae7e1d8ce3", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=c888af52be46ed87bb14043da02df486288701c6", "patch": "@@ -181,26 +181,16 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx>\n             val: ConstValue::Infer(ty::InferConst::Var(vid)),\n             ty,\n         }) = *ct {\n-            match self.const_variables.get(&vid) {\n-                None => {\n-                    // This variable was created before the\n-                    // \"fudging\".  Since we refresh all\n-                    // variables to their binding anyhow, we know\n-                    // that it is unbound, so we can just return\n-                    // it.\n-                    debug_assert!(\n-                        self.infcx.const_unification_table.borrow_mut()\n-                        .probe(vid)\n-                        .is_unknown()\n-                    );\n-                    ct\n-                }\n-                Some(&origin) => {\n-                    // This variable was created during the\n-                    // fudging. Recreate it with a fresh variable\n-                    // here.\n-                    self.infcx.next_const_var(ty, origin)\n-                }\n+            if self.const_variables.contains(&vid) {\n+                // This variable was created during the\n+                // fudging. Recreate it with a fresh variable\n+                // here.\n+                let origin = self.infcx.const_unification_table.borrow_mut()\n+                    .probe_value(vid)\n+                    .origin;\n+                self.infcx.next_const_var(ty, origin)\n+            } else {\n+                ct\n             }\n         } else {\n             ct.super_fold_with(self)"}, {"sha": "84ebe2d8b52928a5fcfb57ac82aecaa0e348520b", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=c888af52be46ed87bb14043da02df486288701c6", "patch": "@@ -4,11 +4,10 @@\n use super::combine::CombineFields;\n use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n \n-use crate::infer::{CombinedSnapshot, ConstVariableOrigin};\n+use crate::infer::CombinedSnapshot;\n use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n use crate::ty::{self, Binder, TypeFoldable};\n-\n-use syntax_pos::DUMMY_SP;\n+use crate::mir::interpret::ConstValue;\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n@@ -101,13 +100,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }))\n         };\n \n-        let fld_c = |_: ty::BoundVar, ty| {\n-            self.next_const_var_in_universe(\n-                ty,\n-                // FIXME(const_generics): do we want a placeholder const?\n-                ConstVariableOrigin::MiscVariable(DUMMY_SP),\n-                next_universe,\n-            )\n+        let fld_c = |bound_var: ty::BoundVar, ty| {\n+            self.tcx.mk_lazy_const(ty::LazyConst::Evaluated(\n+                ty::Const {\n+                    val: ConstValue::Placeholder(ty::PlaceholderConst {\n+                        universe: next_universe,\n+                        name: bound_var,\n+                    }),\n+                    ty,\n+                }\n+            ))\n         };\n \n         let (result, map) = self.tcx.replace_bound_vars(binder, fld_r, fld_t, fld_c);"}, {"sha": "e013b2429e31815864de90248fc8bf3f4950cf6c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c888af52be46ed87bb14043da02df486288701c6", "patch": "@@ -10,6 +10,7 @@ pub use crate::ty::IntVarValue;\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::canonical::{Canonical, CanonicalVarValues};\n+use crate::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use crate::middle::free_region::RegionRelations;\n use crate::middle::lang_items;\n use crate::middle::region;\n@@ -35,13 +36,12 @@ use syntax_pos::symbol::InternedString;\n use syntax_pos::Span;\n \n use self::combine::CombineFields;\n-use self::const_variable::ConstVariableOrigin;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n use self::type_variable::TypeVariableOrigin;\n-use self::unify_key::ToType;\n+use self::unify_key::{ToType, ConstVariableOrigin};\n \n pub mod at;\n pub mod canonical;\n@@ -62,7 +62,6 @@ pub mod region_constraints;\n pub mod resolve;\n mod sub;\n pub mod type_variable;\n-pub mod const_variable;\n pub mod unify_key;\n \n #[must_use]\n@@ -126,7 +125,7 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     /// Map from const parameter variable to the kind of const it represents.\n-    const_unification_table: RefCell<const_variable::ConstVariableTable<'tcx>>,\n+    const_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>>,\n \n     /// Map from integral variable to the kind of integer it represents.\n     int_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::IntVid>>>,\n@@ -532,7 +531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n                 in_progress_tables,\n                 projection_cache: Default::default(),\n                 type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-                const_unification_table: RefCell::new(const_variable::ConstVariableTable::new()),\n+                const_unification_table: RefCell::new(ut::UnificationTable::new()),\n                 int_unification_table: RefCell::new(ut::UnificationTable::new()),\n                 float_unification_table: RefCell::new(ut::UnificationTable::new()),\n                 region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n@@ -598,7 +597,7 @@ impl<'tcx> InferOk<'tcx, ()> {\n pub struct CombinedSnapshot<'a, 'tcx: 'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot<'tcx>,\n-    const_snapshot: const_variable::Snapshot<'tcx>,\n+    const_snapshot: ut::Snapshot<ut::InPlace<ty::ConstVid<'tcx>>>,\n     int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n     float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n     region_constraints_snapshot: RegionSnapshot,\n@@ -1017,14 +1016,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ) -> &'tcx ty::LazyConst<'tcx> {\n         let vid = self.const_unification_table\n             .borrow_mut()\n-            .new_var(universe, origin);\n+            .new_key(ConstVarValue {\n+                origin,\n+                val: ConstVariableValue::Unknown { universe },\n+            });\n         self.tcx.mk_const_var(vid, ty)\n     }\n \n     pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n         self.const_unification_table\n             .borrow_mut()\n-            .new_var(self.universe(), origin)\n+            .new_key(ConstVarValue {\n+                origin,\n+                val: ConstVariableValue::Unknown { universe: self.universe() },\n+            })\n     }\n \n     fn next_int_var_id(&self) -> IntVid {\n@@ -1120,13 +1125,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.tcx.mk_ty_var(ty_var_id).into()\n             }\n             GenericParamDefKind::Const { .. } => {\n+                let origin = ConstVariableOrigin::ConstParameterDefinition(span, param.name);\n                 let const_var_id =\n                     self.const_unification_table\n                         .borrow_mut()\n-                        .new_var(\n-                            self.universe(),\n-                            ConstVariableOrigin::ConstParameterDefinition(span, param.name),\n-                        );\n+                        .new_key(ConstVarValue {\n+                            origin,\n+                            val: ConstVariableValue::Unknown { universe: self.universe() },\n+                        });\n                 self.tcx.mk_const_var(const_var_id, self.tcx.type_of(param.def_id)).into()\n             }\n         }\n@@ -1362,9 +1368,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         vid: ty::ConstVid<'tcx>\n     ) -> Result<&'tcx ty::LazyConst<'tcx>, ty::UniverseIndex> {\n-        use self::const_variable::ConstVariableValue;\n+        use self::unify_key::ConstVariableValue;\n \n-        match self.const_unification_table.borrow_mut().probe(vid) {\n+        match self.const_unification_table.borrow_mut().probe_value(vid).val {\n             ConstVariableValue::Known { value } => Ok(value),\n             ConstVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1380,7 +1386,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }) = ct {\n             self.const_unification_table\n                 .borrow_mut()\n-                .probe(*v)\n+                .probe_value(*v)\n+                .val\n                 .known()\n                 .map(|c| self.resolve_const_var(c))\n                 .unwrap_or(ct)\n@@ -1400,7 +1407,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }) => {\n                 self.const_unification_table\n                     .borrow_mut()\n-                    .probe(*vid)\n+                    .probe_value(*vid)\n+                    .val\n                     .known()\n                     .map(|c| self.shallow_resolve_const(c))\n                     .unwrap_or(ct)"}, {"sha": "1b34403f0533997d3466b886ac9df33d6cb74e01", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=c888af52be46ed87bb14043da02df486288701c6", "patch": "@@ -6,6 +6,7 @@ use crate::ty::{self, Ty, TyCtxt, InferConst};\n use crate::ty::TyVar;\n use crate::ty::fold::TypeFoldable;\n use crate::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use crate::infer::unify_key::replace_if_possible;\n use crate::mir::interpret::ConstValue;\n use std::mem;\n \n@@ -143,8 +144,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.const_unification_table.borrow_mut().replace_if_possible(a);\n-        let b = infcx.const_unification_table.borrow_mut().replace_if_possible(b);\n+        let a = replace_if_possible(infcx.const_unification_table.borrow_mut(), a);\n+        let b = replace_if_possible(infcx.const_unification_table.borrow_mut(), b);\n \n         // Consts can only be equal or unequal to each other: there's no subtyping\n         // relation, so we're just going to perform equating here instead."}, {"sha": "5cd0e8e25912e46e9bfa3b05e85e46990d19d4ca", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 120, "deletions": 2, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c888af52be46ed87bb14043da02df486288701c6/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=c888af52be46ed87bb14043da02df486288701c6", "patch": "@@ -1,5 +1,13 @@\n-use crate::ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt};\n-use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue};\n+use crate::ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt, InferConst};\n+use crate::mir::interpret::ConstValue;\n+use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue, UnificationTable};\n+use rustc_data_structures::unify::InPlace;\n+use syntax_pos::{Span, DUMMY_SP};\n+use syntax::symbol::InternedString;\n+\n+use std::cmp;\n+use std::marker::PhantomData;\n+use std::cell::RefMut;\n \n pub trait ToType {\n     fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n@@ -68,3 +76,113 @@ impl ToType for FloatVarValue {\n         tcx.mk_mach_float(self.0)\n     }\n }\n+\n+// Generic consts.\n+\n+/// Reasons to create a const inference variable\n+#[derive(Copy, Clone, Debug)]\n+pub enum ConstVariableOrigin {\n+    MiscVariable(Span),\n+    ConstInference(Span),\n+    ConstParameterDefinition(Span, InternedString),\n+    SubstitutionPlaceholder(Span),\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum ConstVariableValue<'tcx> {\n+    Known { value: &'tcx ty::LazyConst<'tcx> },\n+    Unknown { universe: ty::UniverseIndex },\n+}\n+\n+impl<'tcx> ConstVariableValue<'tcx> {\n+    /// If this value is known, returns the const it is known to be.\n+    /// Otherwise, `None`.\n+    pub fn known(&self) -> Option<&'tcx ty::LazyConst<'tcx>> {\n+        match *self {\n+            ConstVariableValue::Unknown { .. } => None,\n+            ConstVariableValue::Known { value } => Some(value),\n+        }\n+    }\n+\n+    pub fn is_unknown(&self) -> bool {\n+        match *self {\n+            ConstVariableValue::Unknown { .. } => true,\n+            ConstVariableValue::Known { .. } => false,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct ConstVarValue<'tcx> {\n+    pub origin: ConstVariableOrigin,\n+    pub val: ConstVariableValue<'tcx>,\n+}\n+\n+impl<'tcx> UnifyKey for ty::ConstVid<'tcx> {\n+    type Value = ConstVarValue<'tcx>;\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> Self { ty::ConstVid { index: i, phantom: PhantomData } }\n+    fn tag() -> &'static str { \"ConstVid\" }\n+}\n+\n+impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n+    type Error = (&'tcx ty::LazyConst<'tcx>, &'tcx ty::LazyConst<'tcx>);\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, Self::Error> {\n+        let val = match (value1.val, value2.val) {\n+            (\n+                ConstVariableValue::Known { value: value1 },\n+                ConstVariableValue::Known { value: value2 }\n+            ) => {\n+                match <&'tcx ty::LazyConst<'tcx>>::unify_values(&value1, &value2) {\n+                    Ok(value) => Ok(ConstVariableValue::Known { value }),\n+                    Err(err) => Err(err),\n+                }\n+            }\n+\n+            // If one side is known, prefer that one.\n+            (ConstVariableValue::Known { .. }, ConstVariableValue::Unknown { .. }) => {\n+                Ok(value1.val)\n+            }\n+            (ConstVariableValue::Unknown { .. }, ConstVariableValue::Known { .. }) => {\n+                Ok(value2.val)\n+            }\n+\n+            // If both sides are *unknown*, it hardly matters, does it?\n+            (ConstVariableValue::Unknown { universe: universe1 },\n+             ConstVariableValue::Unknown { universe: universe2 }) =>  {\n+                // If we unify two unbound variables, ?T and ?U, then whatever\n+                // value they wind up taking (which must be the same value) must\n+                // be nameable by both universes. Therefore, the resulting\n+                // universe is the minimum of the two universes, because that is\n+                // the one which contains the fewest names in scope.\n+                let universe = cmp::min(universe1, universe2);\n+                Ok(ConstVariableValue::Unknown { universe })\n+            }\n+        }?;\n+\n+        Ok(ConstVarValue {\n+            origin: ConstVariableOrigin::ConstInference(DUMMY_SP),\n+            val,\n+        })\n+    }\n+}\n+\n+impl<'tcx> EqUnifyValue for &'tcx ty::LazyConst<'tcx> {}\n+\n+pub fn replace_if_possible(\n+    mut table: RefMut<'_, UnificationTable<InPlace<ty::ConstVid<'tcx>>>>,\n+    c: &'tcx ty::LazyConst<'tcx>\n+) -> &'tcx ty::LazyConst<'tcx> {\n+    if let ty::LazyConst::Evaluated(ty::Const {\n+        val: ConstValue::Infer(InferConst::Var(vid)),\n+        ..\n+    }) = c {\n+        match table.probe_value(*vid).val.known() {\n+            Some(c) => c,\n+            None => c,\n+        }\n+    } else {\n+        c\n+    }\n+}"}]}