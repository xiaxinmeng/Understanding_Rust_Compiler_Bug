{"sha": "531515d7ae3c9cf9addd47b17db951f9fd8635ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMTUxNWQ3YWUzYzljZjlhZGRkNDdiMTdkYjk1MWY5ZmQ4NjM1ZWQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-12T00:05:39Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-12T00:05:39Z"}, "message": "rustc: Represent types as uints. Cuts typechecking down from 14s to 12s.", "tree": {"sha": "9164a5dd01fc35603f099521f3cc7bec789b1a74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9164a5dd01fc35603f099521f3cc7bec789b1a74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/531515d7ae3c9cf9addd47b17db951f9fd8635ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/531515d7ae3c9cf9addd47b17db951f9fd8635ed", "html_url": "https://github.com/rust-lang/rust/commit/531515d7ae3c9cf9addd47b17db951f9fd8635ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/531515d7ae3c9cf9addd47b17db951f9fd8635ed/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da09a0320ef5120b082c82148a0bb72ee97ae551", "url": "https://api.github.com/repos/rust-lang/rust/commits/da09a0320ef5120b082c82148a0bb72ee97ae551", "html_url": "https://github.com/rust-lang/rust/commit/da09a0320ef5120b082c82148a0bb72ee97ae551"}], "stats": {"total": 291, "additions": 143, "deletions": 148}, "files": [{"sha": "a8784d794af0573bc1f86954bf9dde8a679a173a", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 143, "deletions": 148, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/531515d7ae3c9cf9addd47b17db951f9fd8635ed/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/531515d7ae3c9cf9addd47b17db951f9fd8635ed/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=531515d7ae3c9cf9addd47b17db951f9fd8635ed", "patch": "@@ -65,9 +65,7 @@ fn method_ty_to_fn_ty(ctxt cx, method m) -> t {\n     ret mk_fn(cx, m.proto, m.inputs, m.output);\n }\n \n-// Never construct these manually. These are interned. Also don't assume that\n-// you can access the fields of this type directly; soon these will just be\n-// uints, and that won't work anymore.\n+// Never construct these manually. These are interned.\n //\n // TODO: It'd be really nice to be able to hide this definition from the\n // outside world, to enforce the above invariants.\n@@ -78,7 +76,8 @@ type raw_t = rec(sty struct,\n                  bool has_bound_params,\n                  bool has_vars,\n                  bool has_locals);\n-type t = @raw_t;\n+\n+type t = uint;\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast.rs as well.\n@@ -137,76 +136,62 @@ tag type_err {\n type ty_param_count_and_ty = tup(uint, t);\n type type_cache = hashmap[ast.def_id,ty_param_count_and_ty];\n \n-type type_store = rec(vec[ty.t] empty_vec_ty,\n-                      vec[mutable ty.t] empty_vec_mutable_ty,\n-                      ty.t t_nil,\n-                      ty.t t_bool,\n-                      ty.t t_int,\n-                      ty.t t_float,\n-                      ty.t t_uint,\n-\n-                      ty.t t_i8,\n-                      ty.t t_i16,\n-                      ty.t t_i32,\n-                      ty.t t_i64,\n-\n-                      ty.t t_u8,\n-                      ty.t t_u16,\n-                      ty.t t_u32,\n-                      ty.t t_u64,\n-\n-                      ty.t t_f32,\n-                      ty.t t_f64,\n-\n-                      ty.t t_char,\n-                      ty.t t_str,\n-\n-                      ty.t t_task,\n-                      ty.t t_native,\n-                      ty.t t_type,\n-\n-                      mutable vec[ty.t] t_params,\n-                      mutable vec[ty.t] t_bound_params,\n-                      mutable vec[ty.t] t_vars,\n-                      hashmap[t,t] others);\n+const uint idx_nil      = 0u;\n+const uint idx_bool     = 1u;\n+const uint idx_int      = 2u;\n+const uint idx_float    = 3u;\n+const uint idx_uint     = 4u;\n+const uint idx_i8       = 5u;\n+const uint idx_i16      = 6u;\n+const uint idx_i32      = 7u;\n+const uint idx_i64      = 8u;\n+const uint idx_u8       = 9u;\n+const uint idx_u16      = 10u;\n+const uint idx_u32      = 11u;\n+const uint idx_u64      = 12u;\n+const uint idx_f32      = 13u;\n+const uint idx_f64      = 14u;\n+const uint idx_char     = 15u;\n+const uint idx_str      = 16u;\n+const uint idx_task     = 17u;\n+const uint idx_native   = 18u;\n+const uint idx_type     = 19u;\n+const uint idx_first_others = 20u;\n+\n+type type_store = rec(mutable vec[raw_t] others,\n+                      hashmap[raw_t,uint] other_structural);\n \n fn mk_type_store() -> @type_store {\n-    auto hasher = hash_ty;\n-    auto eqer = eq_ty_full;\n-\n-    ret @rec(empty_vec_ty = Vec.empty[ty.t](),\n-             empty_vec_mutable_ty = Vec.empty_mut[ty.t](),\n-             t_nil = mk_ty_full(ty_nil, none[str]),\n-             t_bool = mk_ty_full(ty_bool, none[str]),\n-             t_int = mk_ty_full(ty_int, none[str]),\n-             t_float = mk_ty_full(ty_float, none[str]),\n-             t_uint = mk_ty_full(ty_uint, none[str]),\n-\n-             t_i8 = mk_ty_full(ty_machine(ty_i8), none[str]),\n-             t_i16 = mk_ty_full(ty_machine(ty_i16), none[str]),\n-             t_i32 = mk_ty_full(ty_machine(ty_i32), none[str]),\n-             t_i64 = mk_ty_full(ty_machine(ty_i64), none[str]),\n-\n-             t_u8 = mk_ty_full(ty_machine(ty_u8), none[str]),\n-             t_u16 = mk_ty_full(ty_machine(ty_u16), none[str]),\n-             t_u32 = mk_ty_full(ty_machine(ty_u32), none[str]),\n-             t_u64 = mk_ty_full(ty_machine(ty_u64), none[str]),\n-\n-             t_f32 = mk_ty_full(ty_machine(ty_f32), none[str]),\n-             t_f64 = mk_ty_full(ty_machine(ty_f64), none[str]),\n-\n-             t_char = mk_ty_full(ty_char, none[str]),\n-             t_str = mk_ty_full(ty_str, none[str]),\n-\n-             t_task = mk_ty_full(ty_task, none[str]),\n-             t_native = mk_ty_full(ty_native, none[str]),\n-             t_type = mk_ty_full(ty_type, none[str]),\n-\n-             mutable t_params = Vec.empty[ty.t](),\n-             mutable t_bound_params = Vec.empty[ty.t](),\n-             mutable t_vars = Vec.empty[ty.t](),\n-\n-             others=Map.mk_hashmap[t,t](hasher, eqer));\n+    let vec[raw_t] others = vec();\n+    let hashmap[raw_t,uint] ost =\n+        Map.mk_hashmap[raw_t,uint](hash_raw_ty, eq_raw_ty);\n+\n+    auto ts = @rec(mutable others=others, other_structural=ost);\n+\n+    intern(ts, ty_nil, none[str]);\n+    intern(ts, ty_bool, none[str]);\n+    intern(ts, ty_int, none[str]);\n+    intern(ts, ty_float, none[str]);\n+    intern(ts, ty_uint, none[str]);\n+    intern(ts, ty_machine(ty_i8), none[str]);\n+    intern(ts, ty_machine(ty_i16), none[str]);\n+    intern(ts, ty_machine(ty_i32), none[str]);\n+    intern(ts, ty_machine(ty_i64), none[str]);\n+    intern(ts, ty_machine(ty_u8), none[str]);\n+    intern(ts, ty_machine(ty_u16), none[str]);\n+    intern(ts, ty_machine(ty_u32), none[str]);\n+    intern(ts, ty_machine(ty_u64), none[str]);\n+    intern(ts, ty_machine(ty_f32), none[str]);\n+    intern(ts, ty_machine(ty_f64), none[str]);\n+    intern(ts, ty_char, none[str]);\n+    intern(ts, ty_str, none[str]);\n+    intern(ts, ty_task, none[str]);\n+    intern(ts, ty_native, none[str]);\n+    intern(ts, ty_type, none[str]);\n+\n+    assert Vec.len(ts.others) == idx_first_others;\n+\n+    ret ts;\n }\n \n fn mk_rcache() -> creader_cache {\n@@ -231,57 +216,64 @@ fn mk_ctxt(session.session s) -> ctxt {\n             short_names_cache =\n                 Map.mk_hashmap[ty.t,str](ty.hash_ty, ty.eq_ty));\n }\n+\n+\n // Type constructors\n \n-fn mk_ty_full(&sty st, &Option.t[str] cname) -> t {\n+fn mk_raw_ty(&@type_store ts, &sty st, &Option.t[str] cname) -> raw_t {\n     auto h = hash_type_info(st, cname);\n \n     let bool has_params = false;\n     let bool has_bound_params = false;\n     let bool has_vars = false;\n     let bool has_locals = false;\n \n-    fn derive_flags_t(&mutable bool has_params,\n+    fn derive_flags_t(@type_store ts,\n+                      &mutable bool has_params,\n                       &mutable bool has_bound_params,\n                       &mutable bool has_vars,\n                       &mutable bool has_locals,\n                       &t tt) {\n-        has_params = has_params || tt.has_params;\n-        has_bound_params = has_bound_params || tt.has_bound_params;\n-        has_vars = has_vars || tt.has_vars;\n-        has_locals = has_locals || tt.has_locals;\n+        auto rt = ts.others.(tt);\n+        has_params = has_params || rt.has_params;\n+        has_bound_params = has_bound_params || rt.has_bound_params;\n+        has_vars = has_vars || rt.has_vars;\n+        has_locals = has_locals || rt.has_locals;\n     }\n \n-    fn derive_flags_mt(&mutable bool has_params,\n+    fn derive_flags_mt(@type_store ts,\n+                       &mutable bool has_params,\n                        &mutable bool has_bound_params,\n                        &mutable bool has_vars,\n                        &mutable bool has_locals,\n                        &mt m) {\n-        derive_flags_t(has_params, has_bound_params,\n+        derive_flags_t(ts, has_params, has_bound_params,\n                        has_vars, has_locals, m.ty);\n     }\n \n \n-    fn derive_flags_arg(&mutable bool has_params,\n+    fn derive_flags_arg(@type_store ts,\n+                        &mutable bool has_params,\n                         &mutable bool has_bound_params,\n                         &mutable bool has_vars,\n                         &mutable bool has_locals,\n                         &arg a) {\n-        derive_flags_t(has_params, has_bound_params,\n+        derive_flags_t(ts, has_params, has_bound_params,\n                        has_vars, has_locals, a.ty);\n     }\n \n-    fn derive_flags_sig(&mutable bool has_params,\n+    fn derive_flags_sig(@type_store ts,\n+                        &mutable bool has_params,\n                         &mutable bool has_bound_params,\n                         &mutable bool has_vars,\n                         &mutable bool has_locals,\n                         &vec[arg] args,\n                         &t tt) {\n         for (arg a in args) {\n-            derive_flags_arg(has_params, has_bound_params,\n+            derive_flags_arg(ts, has_params, has_bound_params,\n                              has_vars, has_locals, a);\n         }\n-        derive_flags_t(has_params, has_bound_params,\n+        derive_flags_t(ts, has_params, has_bound_params,\n                        has_vars, has_locals, tt);\n     }\n \n@@ -292,84 +284,95 @@ fn mk_ty_full(&sty st, &Option.t[str] cname) -> t {\n         case (ty_local(_)) { has_locals = true; }\n         case (ty_tag(_, ?tys)) {\n             for (t tt in tys) {\n-                derive_flags_t(has_params, has_bound_params,\n+                derive_flags_t(ts, has_params, has_bound_params,\n                                has_vars, has_locals, tt);\n             }\n         }\n         case (ty_box(?m)) {\n-            derive_flags_mt(has_params, has_bound_params,\n+            derive_flags_mt(ts, has_params, has_bound_params,\n                             has_vars, has_locals, m);\n         }\n \n         case (ty_vec(?m)) {\n-            derive_flags_mt(has_params, has_bound_params,\n+            derive_flags_mt(ts, has_params, has_bound_params,\n                             has_vars, has_locals, m);\n         }\n \n         case (ty_port(?tt)) {\n-            derive_flags_t(has_params, has_bound_params,\n+            derive_flags_t(ts, has_params, has_bound_params,\n                            has_vars, has_locals, tt);\n         }\n \n         case (ty_chan(?tt)) {\n-            derive_flags_t(has_params, has_bound_params,\n+            derive_flags_t(ts, has_params, has_bound_params,\n                            has_vars, has_locals, tt);\n         }\n \n         case (ty_tup(?mts)) {\n             for (mt m in mts) {\n-                derive_flags_mt(has_params, has_bound_params,\n+                derive_flags_mt(ts, has_params, has_bound_params,\n                                 has_vars, has_locals, m);\n             }\n         }\n \n         case (ty_rec(?flds)) {\n             for (field f in flds) {\n-                derive_flags_mt(has_params, has_bound_params,\n+                derive_flags_mt(ts, has_params, has_bound_params,\n                                 has_vars, has_locals, f.mt);\n             }\n         }\n \n         case (ty_fn(_, ?args, ?tt)) {\n-            derive_flags_sig(has_params, has_bound_params,\n+            derive_flags_sig(ts, has_params, has_bound_params,\n                              has_vars, has_locals, args, tt);\n         }\n \n         case (ty_native_fn(_, ?args, ?tt)) {\n-            derive_flags_sig(has_params, has_bound_params,\n+            derive_flags_sig(ts, has_params, has_bound_params,\n                              has_vars, has_locals, args, tt);\n         }\n \n         case (ty_obj(?meths)) {\n             for (method m in meths) {\n-                derive_flags_sig(has_params, has_bound_params,\n+                derive_flags_sig(ts, has_params, has_bound_params,\n                                  has_vars, has_locals,\n                                  m.inputs, m.output);\n             }\n         }\n         case (_) { }\n     }\n \n-    ret @rec(struct=st, cname=cname, hash=h,\n-             has_params = has_params,\n-             has_bound_params = has_bound_params,\n-             has_vars = has_vars,\n-             has_locals = has_locals);\n+    ret rec(struct=st, cname=cname, hash=h,\n+            has_params = has_params,\n+            has_bound_params = has_bound_params,\n+            has_vars = has_vars,\n+            has_locals = has_locals);\n+}\n+\n+fn intern_raw_ty(&@type_store ts, &raw_t rt) {\n+    auto type_num = Vec.len[raw_t](ts.others);\n+    ts.others += vec(rt);\n+    ts.other_structural.insert(rt, type_num);\n+}\n+\n+fn intern(&@type_store ts, &sty st, &Option.t[str] cname) {\n+    intern_raw_ty(ts, mk_raw_ty(ts, st, cname));\n }\n \n fn gen_ty_full(&ctxt cx, &sty st, &Option.t[str] cname) -> t {\n-    auto new_type = mk_ty_full(st, cname);\n+    auto raw_type = mk_raw_ty(cx.ts, st, cname);\n \n     // Is it interned?\n-    alt (cx.ts.others.find(new_type)) {\n+    alt (cx.ts.other_structural.find(raw_type)) {\n         case (some[t](?typ)) {\n             ret typ;\n         }\n         case (none[t]) {\n             // Nope. Insert it and return.\n-            cx.ts.others.insert(new_type, new_type);\n-            // log_err \"added: \" + ty_to_str(tystore, new_type);\n-            ret new_type;\n+            auto type_num = Vec.len[raw_t](cx.ts.others);\n+            intern_raw_ty(cx.ts, raw_type);\n+            // log_err \"added: \" + ty_to_str(tystore, raw_type);\n+            ret type_num;\n         }\n     }\n }\n@@ -380,32 +383,32 @@ fn gen_ty(&ctxt cx, &sty st) -> t {\n     ret gen_ty_full(cx, st, none[str]);\n }\n \n-fn mk_nil(&ctxt cx) -> t          { ret cx.ts.t_nil; }\n-fn mk_bool(&ctxt cx) -> t         { ret cx.ts.t_bool; }\n-fn mk_int(&ctxt cx) -> t          { ret cx.ts.t_int; }\n-fn mk_float(&ctxt cx) -> t        { ret cx.ts.t_float; }\n-fn mk_uint(&ctxt cx) -> t         { ret cx.ts.t_uint; }\n+fn mk_nil(&ctxt cx) -> t          { ret idx_nil; }\n+fn mk_bool(&ctxt cx) -> t         { ret idx_bool; }\n+fn mk_int(&ctxt cx) -> t          { ret idx_int; }\n+fn mk_float(&ctxt cx) -> t        { ret idx_float; }\n+fn mk_uint(&ctxt cx) -> t         { ret idx_uint; }\n \n fn mk_mach(&ctxt cx, &util.common.ty_mach tm) -> t {\n     alt (tm) {\n-        case (ty_u8)  { ret cx.ts.t_u8; }\n-        case (ty_u16) { ret cx.ts.t_u16; }\n-        case (ty_u32) { ret cx.ts.t_u32; }\n-        case (ty_u64) { ret cx.ts.t_u64; }\n+        case (ty_u8)  { ret idx_u8; }\n+        case (ty_u16) { ret idx_u16; }\n+        case (ty_u32) { ret idx_u32; }\n+        case (ty_u64) { ret idx_u64; }\n \n-        case (ty_i8)  { ret cx.ts.t_i8; }\n-        case (ty_i16) { ret cx.ts.t_i16; }\n-        case (ty_i32) { ret cx.ts.t_i32; }\n-        case (ty_i64) { ret cx.ts.t_i64; }\n+        case (ty_i8)  { ret idx_i8; }\n+        case (ty_i16) { ret idx_i16; }\n+        case (ty_i32) { ret idx_i32; }\n+        case (ty_i64) { ret idx_i64; }\n \n-        case (ty_f32) { ret cx.ts.t_f32; }\n-        case (ty_f64) { ret cx.ts.t_f64; }\n+        case (ty_f32) { ret idx_f32; }\n+        case (ty_f64) { ret idx_f64; }\n     }\n     fail;\n }\n \n-fn mk_char(&ctxt cx) -> t    { ret cx.ts.t_char; }\n-fn mk_str(&ctxt cx) -> t     { ret cx.ts.t_str; }\n+fn mk_char(&ctxt cx) -> t    { ret idx_char; }\n+fn mk_str(&ctxt cx) -> t     { ret idx_str; }\n \n fn mk_tag(&ctxt cx, &ast.def_id did, &vec[t] tys) -> t {\n     ret gen_ty(cx, ty_tag(did, tys));\n@@ -450,40 +453,30 @@ fn mk_obj(&ctxt cx, &vec[method] meths) -> t {\n }\n \n fn mk_var(&ctxt cx, int v) -> t {\n-    ret mk_ty_full(ty_var(v), none[str]);\n+    ret gen_ty(cx, ty_var(v));\n }\n \n fn mk_local(&ctxt cx, ast.def_id did) -> t {\n-    ret mk_ty_full(ty_local(did), none[str]);\n+    ret gen_ty(cx, ty_local(did));\n }\n \n fn mk_param(&ctxt cx, uint n) -> t {\n-    let uint i = Vec.len[t](cx.ts.t_params);\n-    while (i <= n) {\n-        cx.ts.t_params += vec(mk_ty_full(ty_param(i), none[str]));\n-        i += 1u;\n-    }\n-    ret cx.ts.t_params.(n);\n+    ret gen_ty(cx, ty_param(n));\n }\n \n fn mk_bound_param(&ctxt cx, uint n) -> t {\n-    let uint i = Vec.len[t](cx.ts.t_bound_params);\n-    while (i <= n) {\n-        cx.ts.t_bound_params += vec(mk_ty_full(ty_bound_param(i), none[str]));\n-        i += 1u;\n-    }\n-    ret cx.ts.t_bound_params.(n);\n+    ret gen_ty(cx, ty_bound_param(n));\n }\n \n-fn mk_type(&ctxt cx) -> t    { ret cx.ts.t_type; }\n-fn mk_native(&ctxt cx) -> t  { ret cx.ts.t_native; }\n+fn mk_type(&ctxt cx) -> t    { ret idx_type; }\n+fn mk_native(&ctxt cx) -> t  { ret idx_native; }\n \n \n // Returns the one-level-deep type structure of the given type.\n-fn struct(&ctxt cx, &t typ) -> sty { ret typ.struct; }\n+fn struct(&ctxt cx, &t typ) -> sty { ret cx.ts.others.(typ).struct; }\n \n // Returns the canonical name of the given type.\n-fn cname(&ctxt cx, &t typ) -> Option.t[str] { ret typ.cname; }\n+fn cname(&ctxt cx, &t typ) -> Option.t[str] { ret cx.ts.others.(typ).cname; }\n \n \n // Stringification\n@@ -825,7 +818,7 @@ fn rename(ctxt cx, t typ, str new_cname) -> t {\n // Returns a type with the structural part taken from `struct_ty` and the\n // canonical name from `cname_ty`.\n fn copy_cname(ctxt cx, t struct_ty, t cname_ty) -> t {\n-    ret gen_ty_full(cx, struct(cx, struct_ty), cname_ty.cname);\n+    ret gen_ty_full(cx, struct(cx, struct_ty), cname(cx, cname_ty));\n }\n \n fn type_is_nil(&ctxt cx, &t ty) -> bool {\n@@ -1154,7 +1147,9 @@ fn hash_type_info(&sty st, &Option.t[str] cname_opt) -> uint {\n     ret h;\n }\n \n-fn hash_ty(&t typ) -> uint { ret typ.hash; }\n+fn hash_raw_ty(&raw_t rt) -> uint { ret rt.hash; }\n+\n+fn hash_ty(&t typ) -> uint { ret typ; }\n \n \n // Type equality. This function is private to this module (and slow); external\n@@ -1399,7 +1394,7 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n // module.\n //\n // FIXME: Use structural comparison, but this loops forever and segfaults.\n-fn eq_ty_full(&t a, &t b) -> bool {\n+fn eq_raw_ty(&raw_t a, &raw_t b) -> bool {\n     // Check hashes (fast path).\n     if (a.hash != b.hash) {\n         ret false;\n@@ -1429,7 +1424,7 @@ fn eq_ty_full(&t a, &t b) -> bool {\n \n // This is the equality function the public should use. It works as long as\n // the types are interned.\n-fn eq_ty(&t a, &t b) -> bool { ret Box.ptr_eq[raw_t](a, b); }\n+fn eq_ty(&t a, &t b) -> bool { ret a == b; }\n \n \n fn ann_to_type(&ast.ann ann) -> t {\n@@ -1515,19 +1510,19 @@ fn count_ty_params(ctxt cx, t ty) -> uint {\n }\n \n fn type_contains_vars(&ctxt cx, &t typ) -> bool {\n-    ret typ.has_vars;\n+    ret cx.ts.others.(typ).has_vars;\n }\n \n fn type_contains_locals(&ctxt cx, &t typ) -> bool {\n-    ret typ.has_locals;\n+    ret cx.ts.others.(typ).has_locals;\n }\n \n fn type_contains_params(&ctxt cx, &t typ) -> bool {\n-    ret typ.has_params;\n+    ret cx.ts.others.(typ).has_params;\n }\n \n fn type_contains_bound_params(&ctxt cx, &t typ) -> bool {\n-    ret typ.has_bound_params;\n+    ret cx.ts.others.(typ).has_bound_params;\n }\n \n // Type accessors for substructures of types"}]}