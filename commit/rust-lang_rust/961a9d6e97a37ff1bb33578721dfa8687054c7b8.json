{"sha": "961a9d6e97a37ff1bb33578721dfa8687054c7b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MWE5ZDZlOTdhMzdmZjFiYjMzNTc4NzIxZGZhODY4NzA1NGM3Yjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-11T23:29:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-11T23:29:20Z"}, "message": "Auto merge of #61741 - Centril:rollup-fgro5kz, r=Centril\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #61518 (Add loops to doc list of things not stable in const fn)\n - #61526 (move some tests into subfolders)\n - #61550 (Windows 10 SDK is also required now.)\n - #61606 (Remove some legacy proc macro flavors)\n - #61652 (Mention slice patterns in array)\n - #61686 (librustc_errors: Add some more documentation)\n - #61698 (typeck: Fix const generic in repeat param ICE.)\n - #61707 (Azure: retry failed awscli installs)\n - #61715 (make sure make_ascii_lowercase actually leaves upper-case non-ASCII characters alone)\n - #61724 (core: use memcmp optimization for 128 bit integer slices)\n - #61726 (Use `for_each` in `Iterator::partition`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1fb645923cd8e80998b706e12839320f8ec08000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fb645923cd8e80998b706e12839320f8ec08000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/961a9d6e97a37ff1bb33578721dfa8687054c7b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/961a9d6e97a37ff1bb33578721dfa8687054c7b8", "html_url": "https://github.com/rust-lang/rust/commit/961a9d6e97a37ff1bb33578721dfa8687054c7b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/961a9d6e97a37ff1bb33578721dfa8687054c7b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f3656ce9a2212fad872605b7a4ee103a155e9f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f3656ce9a2212fad872605b7a4ee103a155e9f3", "html_url": "https://github.com/rust-lang/rust/commit/5f3656ce9a2212fad872605b7a4ee103a155e9f3"}, {"sha": "681712be090b72ecc73f08ffe98dd05b6f352052", "url": "https://api.github.com/repos/rust-lang/rust/commits/681712be090b72ecc73f08ffe98dd05b6f352052", "html_url": "https://github.com/rust-lang/rust/commit/681712be090b72ecc73f08ffe98dd05b6f352052"}], "stats": {"total": 1135, "additions": 386, "deletions": 749}, "files": [{"sha": "49bac629e7285a028c57b55baa702e7255b965dd", "filename": ".azure-pipelines/steps/run.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/.azure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/.azure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Frun.yml?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -74,8 +74,9 @@ steps:\n # images, etc.\n - bash: |\n     set -e\n+    source src/ci/shared.sh\n     sudo apt-get install -y python3-setuptools\n-    pip3 install awscli --upgrade --user\n+    retry pip3 install awscli --upgrade --user\n     echo \"##vso[task.prependpath]$HOME/.local/bin\"\n   displayName: Install awscli (Linux)\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux'))"}, {"sha": "15d09f4aada3b0090780252a39f96eddb026c7ed", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -130,9 +130,9 @@ build.\n \n MSVC builds of Rust additionally require an installation of Visual Studio 2017\n (or later) so `rustc` can use its linker.  The simplest way is to get the\n-[Visual Studio Build Tools] and check the \u201cC++ build tools\u201d workload.\n+[Visual Studio], check the \u201cC++ build tools\u201d and \u201cWindows 10 SDK\u201d workload.\n \n-[Visual Studio Build Tools]: https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019\n+[Visual Studio]: https://visualstudio.microsoft.com/downloads/\n \n (If you're installing cmake yourself, be careful that \u201cC++ CMake tools for\n Windows\u201d doesn't get included under \u201cIndividual components\u201d.)"}, {"sha": "30923c7414504c1a6863d9b50cec569c668ac430", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -1495,13 +1495,13 @@ pub trait Iterator {\n         let mut left: B = Default::default();\n         let mut right: B = Default::default();\n \n-        for x in self {\n+        self.for_each(|x| {\n             if f(&x) {\n                 left.extend(Some(x))\n             } else {\n                 right.extend(Some(x))\n             }\n-        }\n+        });\n \n         (left, right)\n     }"}, {"sha": "c9c73f4d66ee9f85fe63f756fa8c6233dc558bcc", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -5420,7 +5420,7 @@ macro_rules! impl_marker_for {\n }\n \n impl_marker_for!(BytewiseEquality,\n-                 u8 i8 u16 i16 u32 i32 u64 i64 usize isize char bool);\n+                 u8 i8 u16 i16 u32 i32 u64 i64 u128 i128 usize isize char bool);\n \n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {"}, {"sha": "34f2d8917ea472a9f5d25af24e3875448378bedf", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -4000,11 +4000,11 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut s = String::from(\"Gr\u00fc\u00dfe, J\u00fcrgen \u2764\");\n+    /// let mut s = String::from(\"GR\u00dc\u00dfE, J\u00dcRGEN \u2764\");\n     ///\n     /// s.make_ascii_lowercase();\n     ///\n-    /// assert_eq!(\"gr\u00fc\u00dfe, j\u00fcrgen \u2764\", s);\n+    /// assert_eq!(\"gr\u00dc\u00dfe, j\u00dcrgen \u2764\", s);\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     pub fn make_ascii_lowercase(&mut self) {"}, {"sha": "f4d523b92338ce95de4a255b37642c396fffdf40", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -227,13 +227,17 @@ impl OutputType {\n     }\n }\n \n+/// The type of diagnostics output to generate.\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum ErrorOutputType {\n+    /// Output meant for the consumption of humans.\n     HumanReadable(HumanReadableErrorType),\n+    /// Output that's consumed by other tools such as `rustfix` or the `RLS`.\n     Json {\n-        /// Render the json in a human readable way (with indents and newlines)\n+        /// Render the JSON in a human readable way (with indents and newlines).\n         pretty: bool,\n-        /// The way the `rendered` field is created\n+        /// The JSON output includes a `rendered` field that includes the rendered\n+        /// human output.\n         json_rendered: HumanReadableErrorType,\n     },\n }"}, {"sha": "fc74e43ff5739e770ec056b8edd45a84acdd18ae", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -348,7 +348,7 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// struct_* methods on Handler.\n-    pub fn new_with_code(handler: &'a Handler,\n+    crate fn new_with_code(handler: &'a Handler,\n                          level: Level,\n                          code: Option<DiagnosticId>,\n                          message: &str)"}, {"sha": "fca8298409a61f5add93a7a787e6c4f6ba04cda2", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -1,3 +1,12 @@\n+//! The current rustc diagnostics emitter.\n+//!\n+//! An `Emitter` takes care of generating the output from a `DiagnosticBuilder` struct.\n+//!\n+//! There are various `Emitter` implementations that generate different output formats such as\n+//! JSON and human readable output.\n+//!\n+//! The output types are defined in `librustc::session::config::ErrorOutputType`.\n+\n use Destination::*;\n \n use syntax_pos::{SourceFile, Span, MultiSpan};"}, {"sha": "05cee6dff230935626a535485da859ad0cf1011f", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -1,5 +1,10 @@\n+//! Diagnostics creation and emission for `rustc`.\n+//!\n+//! This module contains the code for creating and emitting diagnostics.\n+\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(crate_visibility_modifier)]\n #![allow(unused_attributes)]\n #![cfg_attr(unix, feature(libc))]\n #![feature(nll)]"}, {"sha": "7ffba41e2569a4f32e3077e4622ffc9e17596fa2", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -614,7 +614,7 @@ impl<'a> CrateLoader<'a> {\n             match decl {\n                 ProcMacro::CustomDerive { trait_name, attributes, client } => {\n                     let attrs = attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                    (trait_name, SyntaxExtension::ProcMacroDerive(\n+                    (trait_name, SyntaxExtension::Derive(\n                         Box::new(ProcMacroDerive {\n                             client,\n                             attrs: attrs.clone(),\n@@ -624,13 +624,13 @@ impl<'a> CrateLoader<'a> {\n                     ))\n                 }\n                 ProcMacro::Attr { name, client } => {\n-                    (name, SyntaxExtension::AttrProcMacro(\n+                    (name, SyntaxExtension::Attr(\n                         Box::new(AttrProcMacro { client }),\n                         root.edition,\n                     ))\n                 }\n                 ProcMacro::Bang { name, client } => {\n-                    (name, SyntaxExtension::ProcMacro {\n+                    (name, SyntaxExtension::Bang {\n                         expander: Box::new(BangProcMacro { client }),\n                         allow_internal_unstable: None,\n                         edition: root.edition,"}, {"sha": "35faa1df82b845f3a4ef0cf18b1a86cae2d174b3", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -430,7 +430,7 @@ impl cstore::CStore {\n             use syntax_ext::proc_macro_impl::BangProcMacro;\n \n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-            let ext = SyntaxExtension::ProcMacro {\n+            let ext = SyntaxExtension::Bang {\n                 expander: Box::new(BangProcMacro { client }),\n                 allow_internal_unstable: Some(vec![sym::proc_macro_def_site].into()),\n                 edition: data.root.edition,"}, {"sha": "7bafef79acd1a48ef5e18ce9ff6d5e3c4aea0b2b", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -299,7 +299,7 @@ fn check_terminator(\n \n         TerminatorKind::FalseEdges { .. } | TerminatorKind::SwitchInt { .. } => Err((\n             span,\n-            \"`if`, `match`, `&&` and `||` are not stable in const fn\".into(),\n+            \"loops and conditional expressions are not stable in const fn\".into(),\n         )),\n         | TerminatorKind::Abort | TerminatorKind::Unreachable => {\n             Err((span, \"const fn with unreachable code is not stable\".into()))"}, {"sha": "dd5e42684c4276581471ff68738e55078e4c8e44", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -4,8 +4,9 @@ use rustc::lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n \n-use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n+use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension};\n use syntax::ext::base::MacroExpanderFn;\n+use syntax::ext::hygiene::Transparency;\n use syntax::symbol::{Symbol, sym};\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n@@ -84,47 +85,26 @@ impl<'a> Registry<'a> {\n     /// Register a syntax extension of any kind.\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n-    pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n+    pub fn register_syntax_extension(&mut self, name: ast::Name, mut extension: SyntaxExtension) {\n         if name == sym::macro_rules {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n-        self.syntax_exts.push((name, match extension {\n-            NormalTT {\n-                expander,\n-                def_info: _,\n-                allow_internal_unstable,\n-                allow_internal_unsafe,\n-                local_inner_macros,\n-                unstable_feature,\n-                edition,\n-            } => {\n-                let nid = ast::CRATE_NODE_ID;\n-                NormalTT {\n-                    expander,\n-                    def_info: Some((nid, self.krate_span)),\n-                    allow_internal_unstable,\n-                    allow_internal_unsafe,\n-                    local_inner_macros,\n-                    unstable_feature,\n-                    edition,\n-                }\n-            }\n-            IdentTT { expander, span: _, allow_internal_unstable } => {\n-                IdentTT { expander, span: Some(self.krate_span), allow_internal_unstable }\n-            }\n-            _ => extension,\n-        }));\n+        if let SyntaxExtension::LegacyBang { def_info: ref mut def_info @ None, .. } = extension {\n+            *def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n+        }\n+        self.syntax_exts.push((name, extension));\n     }\n \n     /// Register a macro of the usual kind.\n     ///\n     /// This is a convenience wrapper for `register_syntax_extension`.\n-    /// It builds for you a `NormalTT` that calls `expander`,\n+    /// It builds for you a `SyntaxExtension::LegacyBang` that calls `expander`,\n     /// and also takes care of interning the macro's name.\n     pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n-        self.register_syntax_extension(Symbol::intern(name), NormalTT {\n+        self.register_syntax_extension(Symbol::intern(name), SyntaxExtension::LegacyBang {\n             expander: Box::new(expander),\n             def_info: None,\n+            transparency: Transparency::SemiTransparent,\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,"}, {"sha": "2369bddf4f75fca13ae27304aa474f65e4dc9c21", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -242,8 +242,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn check_unused_macros(&self) {\n         for did in self.unused_macros.iter() {\n             let id_span = match *self.macro_map[did] {\n-                SyntaxExtension::NormalTT { def_info, .. } |\n-                SyntaxExtension::DeclMacro { def_info, .. } => def_info,\n+                SyntaxExtension::LegacyBang { def_info, .. } => def_info,\n                 _ => None,\n             };\n             if let Some((id, span)) = id_span {\n@@ -587,7 +586,7 @@ impl<'a> Resolver<'a> {\n                         match self.resolve_macro_to_res(derive, MacroKind::Derive,\n                                                         &parent_scope, true, force) {\n                             Ok((_, ext)) => {\n-                                if let SyntaxExtension::ProcMacroDerive(_, helpers, _) = &*ext {\n+                                if let SyntaxExtension::Derive(_, helpers, _) = &*ext {\n                                     if helpers.contains(&ident.name) {\n                                         let binding =\n                                             (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),"}, {"sha": "5a46c9d440b5d82bb1378d636ed8fc8201409b93", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -2155,6 +2155,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         result_ty\n     }\n \n+    /// Returns the `DefId` of the constant parameter that the provided expression is a path to.\n+    pub fn const_param_def_id(&self, expr: &hir::Expr) -> Option<DefId> {\n+        match &expr.node {\n+            ExprKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n+                Res::Def(DefKind::ConstParam, did) => Some(did),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n     pub fn ast_const_to_const(\n         &self,\n         ast_const: &hir::AnonConst,\n@@ -2185,19 +2196,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n         }\n \n-        if let ExprKind::Path(ref qpath) = expr.node {\n-            if let hir::QPath::Resolved(_, ref path) = qpath {\n-                if let Res::Def(DefKind::ConstParam, def_id) = path.res {\n-                    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-                    let item_id = tcx.hir().get_parent_node(node_id);\n-                    let item_def_id = tcx.hir().local_def_id(item_id);\n-                    let generics = tcx.generics_of(item_def_id);\n-                    let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(node_id)];\n-                    let name = tcx.hir().name(node_id).as_interned_str();\n-                    const_.val = ConstValue::Param(ty::ParamConst::new(index, name));\n-                }\n-            }\n-        };\n+        if let Some(def_id) = self.const_param_def_id(expr) {\n+            // Find the name and index of the const parameter by indexing the generics of the\n+            // parent item and construct a `ParamConst`.\n+            let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+            let item_id = tcx.hir().get_parent_node(node_id);\n+            let item_def_id = tcx.hir().local_def_id(item_id);\n+            let generics = tcx.generics_of(item_def_id);\n+            let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(node_id)];\n+            let name = tcx.hir().name(node_id).as_interned_str();\n+            const_.val = ConstValue::Param(ty::ParamConst::new(index, name));\n+        }\n \n         tcx.mk_const(const_)\n     }"}, {"sha": "e35df6cd494a2fbfbb8a251d4d0c10b0eb0573e5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -2504,6 +2504,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n+    /// Returns the `DefId` of the constant parameter that the provided expression is a path to.\n+    pub fn const_param_def_id(&self, hir_c: &hir::AnonConst) -> Option<DefId> {\n+        AstConv::const_param_def_id(self, &self.tcx.hir().body(hir_c.body).value)\n+    }\n+\n     pub fn to_const(&self, ast_c: &hir::AnonConst, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n         AstConv::ast_const_to_const(self, ast_c, ty)\n     }\n@@ -4479,19 +4484,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Repeat(ref element, ref count) => {\n                 let count_def_id = tcx.hir().local_def_id_from_hir_id(count.hir_id);\n-                let param_env = ty::ParamEnv::empty();\n-                let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n-                let instance = ty::Instance::resolve(\n-                    tcx.global_tcx(),\n-                    param_env,\n-                    count_def_id,\n-                    substs,\n-                ).unwrap();\n-                let global_id = GlobalId {\n-                    instance,\n-                    promoted: None\n+                let count = if self.const_param_def_id(count).is_some() {\n+                    Ok(self.to_const(count, self.tcx.type_of(count_def_id)))\n+                } else {\n+                    let param_env = ty::ParamEnv::empty();\n+                    let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n+                    let instance = ty::Instance::resolve(\n+                        tcx.global_tcx(),\n+                        param_env,\n+                        count_def_id,\n+                        substs,\n+                    ).unwrap();\n+                    let global_id = GlobalId {\n+                        instance,\n+                        promoted: None\n+                    };\n+\n+                    tcx.const_eval(param_env.and(global_id))\n                 };\n-                let count = tcx.const_eval(param_env.and(global_id));\n \n                 let uty = match expected {\n                     ExpectHasType(uty) => {"}, {"sha": "5a5540e7e38556096e7f0206aa626d407de3d59f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -471,7 +471,7 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n         }\n         LoadedMacro::ProcMacro(ext) => {\n             let helpers = match &*ext {\n-                &SyntaxExtension::ProcMacroDerive(_, ref syms, ..) => { syms.clean(cx) }\n+                &SyntaxExtension::Derive(_, ref syms, ..) => { syms.clean(cx) }\n                 _ => Vec::new(),\n             };\n "}, {"sha": "7fbfc3e1fc0f4a1030de025ee972c1a7582da564", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -433,7 +433,7 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n             if let Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) = res {\n                 // skip proc-macro stubs, they'll cause `get_macro` to crash\n             } else {\n-                if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(res) {\n+                if let SyntaxExtension::LegacyBang { .. } = *resolver.get_macro(res) {\n                     return Some(res.map_id(|_| panic!(\"unexpected id\")));\n                 }\n             }"}, {"sha": "e78a5defdf3bb793c06b6a56ddce25a0c0d99632", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -482,8 +482,8 @@ mod prim_pointer { }\n /// an array. Indeed, this provides most of the API for working with arrays.\n /// Slices have a dynamic size and do not coerce to arrays.\n ///\n-/// There is no way to move elements out of an array. See [`mem::replace`][replace]\n-/// for an alternative.\n+/// You can move elements out of an array with a slice pattern. If you want\n+/// one element, see [`mem::replace`][replace].\n ///\n /// # Examples\n ///\n@@ -525,6 +525,16 @@ mod prim_pointer { }\n /// for x in &array { }\n /// ```\n ///\n+/// You can use a slice pattern to move elements out of an array:\n+///\n+/// ```\n+/// fn move_away(_: String) { /* Do interesting things. */ }\n+///\n+/// let [john, roa] = [\"John\".to_string(), \"Roa\".to_string()];\n+/// move_away(john);\n+/// move_away(roa);\n+/// ```\n+///\n /// [slice]: primitive.slice.html\n /// [copy]: marker/trait.Copy.html\n /// [clone]: clone/trait.Clone.html"}, {"sha": "38b7dee40c447f52a09ba554340a4d79cb6481b6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 77, "deletions": 146, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -1,6 +1,4 @@\n-pub use SyntaxExtension::*;\n-\n-use crate::ast::{self, Attribute, Name, PatKind, MetaItem};\n+use crate::ast::{self, Attribute, Name, PatKind};\n use crate::attr::HasAttrs;\n use crate::source_map::{SourceMap, Spanned, respan};\n use crate::edition::Edition;\n@@ -137,29 +135,6 @@ impl Annotatable {\n     }\n }\n \n-// A more flexible ItemDecorator.\n-pub trait MultiItemDecorator {\n-    fn expand(&self,\n-              ecx: &mut ExtCtxt<'_>,\n-              sp: Span,\n-              meta_item: &ast::MetaItem,\n-              item: &Annotatable,\n-              push: &mut dyn FnMut(Annotatable));\n-}\n-\n-impl<F> MultiItemDecorator for F\n-    where F : Fn(&mut ExtCtxt<'_>, Span, &ast::MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n-{\n-    fn expand(&self,\n-              ecx: &mut ExtCtxt<'_>,\n-              sp: Span,\n-              meta_item: &ast::MetaItem,\n-              item: &Annotatable,\n-              push: &mut dyn FnMut(Annotatable)) {\n-        (*self)(ecx, sp, meta_item, item, push)\n-    }\n-}\n-\n // `meta_item` is the annotation, and `item` is the item being modified.\n // FIXME Decorators should follow the same pattern too.\n pub trait MultiItemModifier {\n@@ -288,34 +263,6 @@ impl<F> TTMacroExpander for F\n     }\n }\n \n-pub trait IdentMacroExpander {\n-    fn expand<'cx>(&self,\n-                   cx: &'cx mut ExtCtxt<'_>,\n-                   sp: Span,\n-                   ident: ast::Ident,\n-                   token_tree: Vec<tokenstream::TokenTree>)\n-                   -> Box<dyn MacResult+'cx>;\n-}\n-\n-pub type IdentMacroExpanderFn =\n-    for<'cx> fn(&'cx mut ExtCtxt<'_>, Span, ast::Ident, Vec<tokenstream::TokenTree>)\n-                -> Box<dyn MacResult+'cx>;\n-\n-impl<F> IdentMacroExpander for F\n-    where F : for<'cx> Fn(&'cx mut ExtCtxt<'_>, Span, ast::Ident,\n-                          Vec<tokenstream::TokenTree>) -> Box<dyn MacResult+'cx>\n-{\n-    fn expand<'cx>(&self,\n-                   cx: &'cx mut ExtCtxt<'_>,\n-                   sp: Span,\n-                   ident: ast::Ident,\n-                   token_tree: Vec<tokenstream::TokenTree>)\n-                   -> Box<dyn MacResult+'cx>\n-    {\n-        (*self)(cx, sp, ident, token_tree)\n-    }\n-}\n-\n // Use a macro because forwarding to a simple function has type system issues\n macro_rules! make_stmts_default {\n     ($me:expr) => {\n@@ -570,9 +517,6 @@ impl MacResult for DummyResult {\n     }\n }\n \n-pub type BuiltinDeriveFn =\n-    for<'cx> fn(&'cx mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable));\n-\n /// Represents different kinds of macro invocations that can be resolved.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MacroKind {\n@@ -606,129 +550,116 @@ impl MacroKind {\n \n /// An enum representing the different kinds of syntax extensions.\n pub enum SyntaxExtension {\n-    /// A trivial \"extension\" that does nothing, only keeps the attribute and marks it as known.\n-    NonMacroAttr { mark_used: bool },\n-\n-    /// A syntax extension that is attached to an item and creates new items\n-    /// based upon it.\n-    ///\n-    /// `#[derive(...)]` is a `MultiItemDecorator`.\n-    ///\n-    /// Prefer ProcMacro or MultiModifier since they are more flexible.\n-    MultiDecorator(Box<dyn MultiItemDecorator + sync::Sync + sync::Send>),\n-\n-    /// A syntax extension that is attached to an item and modifies it\n-    /// in-place. Also allows decoration, i.e., creating new items.\n-    MultiModifier(Box<dyn MultiItemModifier + sync::Sync + sync::Send>),\n-\n-    /// A function-like procedural macro. TokenStream -> TokenStream.\n-    ProcMacro {\n+    /// A token-based function-like macro.\n+    Bang {\n+        /// An expander with signature TokenStream -> TokenStream.\n         expander: Box<dyn ProcMacro + sync::Sync + sync::Send>,\n-        /// Whitelist of unstable features that are treated as stable inside this macro\n+        /// Whitelist of unstable features that are treated as stable inside this macro.\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+        /// Edition of the crate in which this macro is defined.\n         edition: Edition,\n     },\n \n-    /// An attribute-like procedural macro. TokenStream, TokenStream -> TokenStream.\n-    /// The first TokenSteam is the attribute, the second is the annotated item.\n-    /// Allows modification of the input items and adding new items, similar to\n-    /// MultiModifier, but uses TokenStreams, rather than AST nodes.\n-    AttrProcMacro(Box<dyn AttrProcMacro + sync::Sync + sync::Send>, Edition),\n-\n-    /// A normal, function-like syntax extension.\n-    ///\n-    /// `bytes!` is a `NormalTT`.\n-    NormalTT {\n+    /// An AST-based function-like macro.\n+    LegacyBang {\n+        /// An expander with signature TokenStream -> AST.\n         expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n+        /// Some info about the macro's definition point.\n         def_info: Option<(ast::NodeId, Span)>,\n-        /// Whether the contents of the macro can\n-        /// directly use `#[unstable]` things.\n-        ///\n-        /// Only allows things that require a feature gate in the given whitelist\n+        /// Hygienic properties of identifiers produced by this macro.\n+        transparency: Transparency,\n+        /// Whitelist of unstable features that are treated as stable inside this macro.\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Whether the contents of the macro can use `unsafe`\n-        /// without triggering the `unsafe_code` lint.\n+        /// Suppresses the `unsafe_code` lint for code produced by this macro.\n         allow_internal_unsafe: bool,\n-        /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`)\n-        /// for a given macro.\n+        /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n         local_inner_macros: bool,\n-        /// The macro's feature name if it is unstable, and the stability feature\n+        /// The macro's feature name and tracking issue number if it is unstable.\n         unstable_feature: Option<(Symbol, u32)>,\n-        /// Edition of the crate in which the macro is defined\n+        /// Edition of the crate in which this macro is defined.\n         edition: Edition,\n     },\n \n-    /// A function-like syntax extension that has an extra ident before\n-    /// the block.\n-    IdentTT {\n-        expander: Box<dyn IdentMacroExpander + sync::Sync + sync::Send>,\n-        span: Option<Span>,\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    /// A token-based attribute macro.\n+    Attr(\n+        /// An expander with signature (TokenStream, TokenStream) -> TokenStream.\n+        /// The first TokenSteam is the attribute itself, the second is the annotated item.\n+        /// The produced TokenSteam replaces the input TokenSteam.\n+        Box<dyn AttrProcMacro + sync::Sync + sync::Send>,\n+        /// Edition of the crate in which this macro is defined.\n+        Edition,\n+    ),\n+\n+    /// An AST-based attribute macro.\n+    LegacyAttr(\n+        /// An expander with signature (AST, AST) -> AST.\n+        /// The first AST fragment is the attribute itself, the second is the annotated item.\n+        /// The produced AST fragment replaces the input AST fragment.\n+        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+    ),\n+\n+    /// A trivial attribute \"macro\" that does nothing,\n+    /// only keeps the attribute and marks it as known.\n+    NonMacroAttr {\n+        /// Suppresses the `unused_attributes` lint for this attribute.\n+        mark_used: bool,\n     },\n \n-    /// An attribute-like procedural macro. TokenStream -> TokenStream.\n-    /// The input is the annotated item.\n-    /// Allows generating code to implement a Trait for a given struct\n-    /// or enum item.\n-    ProcMacroDerive(Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n-                    Vec<Symbol> /* inert attribute names */, Edition),\n-\n-    /// An attribute-like procedural macro that derives a builtin trait.\n-    BuiltinDerive(BuiltinDeriveFn),\n-\n-    /// A declarative macro, e.g., `macro m() {}`.\n-    DeclMacro {\n-        expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n-        def_info: Option<(ast::NodeId, Span)>,\n-        is_transparent: bool,\n-        edition: Edition,\n-    }\n+    /// A token-based derive macro.\n+    Derive(\n+        /// An expander with signature TokenStream -> TokenStream (not yet).\n+        /// The produced TokenSteam is appended to the input TokenSteam.\n+        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+        /// Names of helper attributes registered by this macro.\n+        Vec<Symbol>,\n+        /// Edition of the crate in which this macro is defined.\n+        Edition,\n+    ),\n+\n+    /// An AST-based derive macro.\n+    LegacyDerive(\n+        /// An expander with signature AST -> AST.\n+        /// The produced AST fragment is appended to the input AST fragment.\n+        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+    ),\n }\n \n impl SyntaxExtension {\n     /// Returns which kind of macro calls this syntax extension.\n     pub fn kind(&self) -> MacroKind {\n         match *self {\n-            SyntaxExtension::DeclMacro { .. } |\n-            SyntaxExtension::NormalTT { .. } |\n-            SyntaxExtension::IdentTT { .. } |\n-            SyntaxExtension::ProcMacro { .. } =>\n-                MacroKind::Bang,\n-            SyntaxExtension::NonMacroAttr { .. } |\n-            SyntaxExtension::MultiDecorator(..) |\n-            SyntaxExtension::MultiModifier(..) |\n-            SyntaxExtension::AttrProcMacro(..) =>\n-                MacroKind::Attr,\n-            SyntaxExtension::ProcMacroDerive(..) |\n-            SyntaxExtension::BuiltinDerive(..) =>\n-                MacroKind::Derive,\n+            SyntaxExtension::Bang { .. } |\n+            SyntaxExtension::LegacyBang { .. } => MacroKind::Bang,\n+            SyntaxExtension::Attr(..) |\n+            SyntaxExtension::LegacyAttr(..) |\n+            SyntaxExtension::NonMacroAttr { .. } => MacroKind::Attr,\n+            SyntaxExtension::Derive(..) |\n+            SyntaxExtension::LegacyDerive(..) => MacroKind::Derive,\n         }\n     }\n \n     pub fn default_transparency(&self) -> Transparency {\n         match *self {\n-            SyntaxExtension::ProcMacro { .. } |\n-            SyntaxExtension::AttrProcMacro(..) |\n-            SyntaxExtension::ProcMacroDerive(..) |\n-            SyntaxExtension::DeclMacro { is_transparent: false, .. } => Transparency::Opaque,\n-            SyntaxExtension::DeclMacro { is_transparent: true, .. } => Transparency::Transparent,\n-            _ => Transparency::SemiTransparent,\n+            SyntaxExtension::LegacyBang { transparency, .. } => transparency,\n+            SyntaxExtension::Bang { .. } |\n+            SyntaxExtension::Attr(..) |\n+            SyntaxExtension::Derive(..) |\n+            SyntaxExtension::NonMacroAttr { .. } => Transparency::Opaque,\n+            SyntaxExtension::LegacyAttr(..) |\n+            SyntaxExtension::LegacyDerive(..) => Transparency::SemiTransparent,\n         }\n     }\n \n     pub fn edition(&self, default_edition: Edition) -> Edition {\n         match *self {\n-            SyntaxExtension::NormalTT { edition, .. } |\n-            SyntaxExtension::DeclMacro { edition, .. } |\n-            SyntaxExtension::ProcMacro { edition, .. } |\n-            SyntaxExtension::AttrProcMacro(.., edition) |\n-            SyntaxExtension::ProcMacroDerive(.., edition) => edition,\n+            SyntaxExtension::Bang { edition, .. } |\n+            SyntaxExtension::LegacyBang { edition, .. } |\n+            SyntaxExtension::Attr(.., edition) |\n+            SyntaxExtension::Derive(.., edition) => edition,\n             // Unstable legacy stuff\n             SyntaxExtension::NonMacroAttr { .. } |\n-            SyntaxExtension::IdentTT { .. } |\n-            SyntaxExtension::MultiDecorator(..) |\n-            SyntaxExtension::MultiModifier(..) |\n-            SyntaxExtension::BuiltinDerive(..) => default_edition,\n+            SyntaxExtension::LegacyAttr(..) |\n+            SyntaxExtension::LegacyDerive(..) => default_edition,\n         }\n     }\n }"}, {"sha": "084d4fd3820172258374abbf414471d5a82fb624", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 33, "deletions": 71, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -389,7 +389,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         let item = match self.cx.resolver.resolve_macro_path(\n                                 path, MacroKind::Derive, Mark::root(), Vec::new(), false) {\n                             Ok(ext) => match *ext {\n-                                BuiltinDerive(..) => item_with_markers.clone(),\n+                                SyntaxExtension::LegacyDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),\n                             },\n                             _ => item.clone(),\n@@ -548,7 +548,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        if let NonMacroAttr { mark_used: false } = *ext {} else {\n+        if let SyntaxExtension::NonMacroAttr { mark_used: false } = *ext {} else {\n             // Macro attrs are always used when expanded,\n             // non-macro attrs are considered used when the field says so.\n             attr::mark_used(&attr);\n@@ -564,26 +564,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         });\n \n         match *ext {\n-            NonMacroAttr { .. } => {\n+            SyntaxExtension::NonMacroAttr { .. } => {\n                 attr::mark_known(&attr);\n                 item.visit_attrs(|attrs| attrs.push(attr));\n                 Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n             }\n-            MultiModifier(ref mac) => {\n+            SyntaxExtension::LegacyAttr(ref mac) => {\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .map_err(|mut e| { e.emit(); }).ok()?;\n                 let item = mac.expand(self.cx, attr.span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(item))\n             }\n-            MultiDecorator(ref mac) => {\n-                let mut items = Vec::new();\n-                let meta = attr.parse_meta(self.cx.parse_sess)\n-                               .expect(\"derive meta should already have been parsed\");\n-                mac.expand(self.cx, attr.span, &meta, &item, &mut |item| items.push(item));\n-                items.push(item);\n-                Some(invoc.fragment_kind.expect_from_annotatables(items))\n-            }\n-            AttrProcMacro(ref mac, ..) => {\n+            SyntaxExtension::Attr(ref mac, ..) => {\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n                 let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n                     Annotatable::Item(item) => token::NtItem(item),\n@@ -600,7 +592,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 self.gate_proc_macro_expansion(attr.span, &res);\n                 res\n             }\n-            ProcMacroDerive(..) | BuiltinDerive(..) => {\n+            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive macro\", attr.path));\n                 self.cx.trace_macros_diag();\n                 invoc.fragment_kind.dummy(attr.span)\n@@ -755,24 +747,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         let opt_expanded = match *ext {\n-            DeclMacro { ref expander, def_info, edition, .. } => {\n-                if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n-                                                                    None, false, false, None,\n-                                                                    edition) {\n-                    dummy_span\n-                } else {\n-                    kind.make_from(expander.expand(self.cx, span, mac.node.stream(), None))\n-                }\n-            }\n-\n-            NormalTT {\n+            SyntaxExtension::LegacyBang {\n                 ref expander,\n                 def_info,\n                 ref allow_internal_unstable,\n                 allow_internal_unsafe,\n                 local_inner_macros,\n                 unstable_feature,\n                 edition,\n+                ..\n             } => {\n                 if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n                                                                     allow_internal_unstable.clone(),\n@@ -791,43 +774,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n             }\n \n-            IdentTT { ref expander, span: tt_span, ref allow_internal_unstable } => {\n-                if ident.name == kw::Invalid {\n-                    self.cx.span_err(path.span,\n-                                    &format!(\"macro {}! expects an ident argument\", path));\n-                    self.cx.trace_macros_diag();\n-                    kind.dummy(span)\n-                } else {\n-                    invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                        call_site: span,\n-                        def_site: tt_span,\n-                        format: macro_bang_format(path),\n-                        allow_internal_unstable: allow_internal_unstable.clone(),\n-                        allow_internal_unsafe: false,\n-                        local_inner_macros: false,\n-                        edition: self.cx.parse_sess.edition,\n-                    });\n-\n-                    let input: Vec<_> = mac.node.stream().into_trees().collect();\n-                    kind.make_from(expander.expand(self.cx, span, ident, input))\n-                }\n-            }\n-\n-            MultiDecorator(..) | MultiModifier(..) |\n-            AttrProcMacro(..) | SyntaxExtension::NonMacroAttr { .. } => {\n+            SyntaxExtension::Attr(..) |\n+            SyntaxExtension::LegacyAttr(..) |\n+            SyntaxExtension::NonMacroAttr { .. } => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            ProcMacroDerive(..) | BuiltinDerive(..) => {\n+            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive macro\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::ProcMacro { ref expander, ref allow_internal_unstable, edition } => {\n+            SyntaxExtension::Bang { ref expander, ref allow_internal_unstable, edition } => {\n                 if ident.name != kw::Invalid {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n@@ -924,29 +886,29 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             edition: ext.edition(self.cx.parse_sess.edition),\n         };\n \n-        match *ext {\n-            ProcMacroDerive(ref ext, ..) => {\n-                invoc.expansion_data.mark.set_expn_info(expn_info);\n-                let span = span.with_ctxt(self.cx.backtrace());\n-                let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n-                    path: Path::from_ident(Ident::invalid()),\n-                    span: DUMMY_SP,\n-                    node: ast::MetaItemKind::Word,\n+        match ext {\n+            SyntaxExtension::Derive(expander, ..) | SyntaxExtension::LegacyDerive(expander) => {\n+                let meta = match ext {\n+                    SyntaxExtension::Derive(..) => ast::MetaItem { // FIXME(jseyfried) avoid this\n+                        path: Path::from_ident(Ident::invalid()),\n+                        span: DUMMY_SP,\n+                        node: ast::MetaItemKind::Word,\n+                    },\n+                    _ => {\n+                        expn_info.allow_internal_unstable = Some(vec![\n+                            sym::rustc_attrs,\n+                            Symbol::intern(\"derive_clone_copy\"),\n+                            Symbol::intern(\"derive_eq\"),\n+                            // RustcDeserialize and RustcSerialize\n+                            Symbol::intern(\"libstd_sys_internals\"),\n+                        ].into());\n+                        attr.meta()?\n+                    }\n                 };\n-                let items = ext.expand(self.cx, span, &dummy, item);\n-                Some(invoc.fragment_kind.expect_from_annotatables(items))\n-            }\n-            BuiltinDerive(func) => {\n-                expn_info.allow_internal_unstable = Some(vec![\n-                    sym::rustc_attrs,\n-                    Symbol::intern(\"derive_clone_copy\"),\n-                    Symbol::intern(\"derive_eq\"),\n-                    Symbol::intern(\"libstd_sys_internals\"), // RustcDeserialize and RustcSerialize\n-                ].into());\n+\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n-                let mut items = Vec::new();\n-                func(self.cx, span, &attr.meta()?, &item, &mut |a| items.push(a));\n+                let items = expander.expand(self.cx, span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             _ => {"}, {"sha": "5dbf21867afa6df02811e60f539ef32559878ec2", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -1,8 +1,8 @@\n use crate::{ast, attr};\n use crate::edition::Edition;\n-use crate::ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n-use crate::ext::base::{NormalTT, TTMacroExpander};\n+use crate::ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension, TTMacroExpander};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n+use crate::ext::hygiene::Transparency;\n use crate::ext::tt::macro_parser::{Success, Error, Failure};\n use crate::ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use crate::ext::tt::macro_parser::{parse, parse_failure_msg};\n@@ -374,65 +374,65 @@ pub fn compile(\n         valid,\n     });\n \n-    if body.legacy {\n-        let allow_internal_unstable = attr::find_by_name(&def.attrs, sym::allow_internal_unstable)\n-            .map(|attr| attr\n-                .meta_item_list()\n-                .map(|list| list.iter()\n-                    .filter_map(|it| {\n-                        let name = it.ident().map(|ident| ident.name);\n-                        if name.is_none() {\n-                            sess.span_diagnostic.span_err(it.span(),\n-                                \"allow internal unstable expects feature names\")\n-                        }\n-                        name\n-                    })\n-                    .collect::<Vec<Symbol>>().into()\n-                )\n-                .unwrap_or_else(|| {\n-                    sess.span_diagnostic.span_warn(\n-                        attr.span, \"allow_internal_unstable expects list of feature names. In the \\\n-                        future this will become a hard error. Please use `allow_internal_unstable(\\\n-                        foo, bar)` to only allow the `foo` and `bar` features\",\n-                    );\n-                    vec![sym::allow_internal_unstable_backcompat_hack].into()\n+    let transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n+        Transparency::Transparent\n+    } else if body.legacy {\n+        Transparency::SemiTransparent\n+    } else {\n+        Transparency::Opaque\n+    };\n+\n+    let allow_internal_unstable = attr::find_by_name(&def.attrs, sym::allow_internal_unstable)\n+        .map(|attr| attr\n+            .meta_item_list()\n+            .map(|list| list.iter()\n+                .filter_map(|it| {\n+                    let name = it.ident().map(|ident| ident.name);\n+                    if name.is_none() {\n+                        sess.span_diagnostic.span_err(it.span(),\n+                            \"allow internal unstable expects feature names\")\n+                    }\n+                    name\n                 })\n-            );\n-        let allow_internal_unsafe = attr::contains_name(&def.attrs, sym::allow_internal_unsafe);\n-        let mut local_inner_macros = false;\n-        if let Some(macro_export) = attr::find_by_name(&def.attrs, sym::macro_export) {\n-            if let Some(l) = macro_export.meta_item_list() {\n-                local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n-            }\n-        }\n+                .collect::<Vec<Symbol>>().into()\n+            )\n+            .unwrap_or_else(|| {\n+                sess.span_diagnostic.span_warn(\n+                    attr.span, \"allow_internal_unstable expects list of feature names. In the \\\n+                    future this will become a hard error. Please use `allow_internal_unstable(\\\n+                    foo, bar)` to only allow the `foo` and `bar` features\",\n+                );\n+                vec![sym::allow_internal_unstable_backcompat_hack].into()\n+            })\n+        );\n \n-        let unstable_feature = attr::find_stability(&sess,\n-                                                    &def.attrs, def.span).and_then(|stability| {\n-            if let attr::StabilityLevel::Unstable { issue, .. } = stability.level {\n-                Some((stability.feature, issue))\n-            } else {\n-                None\n-            }\n-        });\n-\n-        NormalTT {\n-            expander,\n-            def_info: Some((def.id, def.span)),\n-            allow_internal_unstable,\n-            allow_internal_unsafe,\n-            local_inner_macros,\n-            unstable_feature,\n-            edition,\n+    let allow_internal_unsafe = attr::contains_name(&def.attrs, sym::allow_internal_unsafe);\n+\n+    let mut local_inner_macros = false;\n+    if let Some(macro_export) = attr::find_by_name(&def.attrs, sym::macro_export) {\n+        if let Some(l) = macro_export.meta_item_list() {\n+            local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n         }\n-    } else {\n-        let is_transparent = attr::contains_name(&def.attrs, sym::rustc_transparent_macro);\n+    }\n \n-        SyntaxExtension::DeclMacro {\n-            expander,\n-            def_info: Some((def.id, def.span)),\n-            is_transparent,\n-            edition,\n+    let unstable_feature = attr::find_stability(&sess,\n+                                                &def.attrs, def.span).and_then(|stability| {\n+        if let attr::StabilityLevel::Unstable { issue, .. } = stability.level {\n+            Some((stability.feature, issue))\n+        } else {\n+            None\n         }\n+    });\n+\n+    SyntaxExtension::LegacyBang {\n+        expander,\n+        def_info: Some((def.id, def.span)),\n+        transparency,\n+        allow_internal_unstable,\n+        allow_internal_unsafe,\n+        local_inner_macros,\n+        unstable_feature,\n+        edition,\n     }\n }\n "}, {"sha": "cf54eacc3d46c8d715218c557f79a9c603750881", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -1,8 +1,8 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n use rustc_data_structures::sync::Lrc;\n-use syntax::ast;\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n+use syntax::ast::{self, MetaItem};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver, MultiItemModifier};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n@@ -39,9 +39,25 @@ pub mod partial_ord;\n #[path=\"cmp/ord.rs\"]\n pub mod ord;\n \n-\n pub mod generic;\n \n+struct BuiltinDerive(\n+    fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n+);\n+\n+impl MultiItemModifier for BuiltinDerive {\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt<'_>,\n+              span: Span,\n+              meta_item: &MetaItem,\n+              item: Annotatable)\n+              -> Vec<Annotatable> {\n+        let mut items = Vec::new();\n+        (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n+        items\n+    }\n+}\n+\n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n         pub fn is_builtin_trait(name: ast::Name) -> bool {\n@@ -55,7 +71,7 @@ macro_rules! derive_traits {\n             $(\n                 resolver.add_builtin(\n                     ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n-                    Lrc::new(SyntaxExtension::BuiltinDerive($func))\n+                    Lrc::new(SyntaxExtension::LegacyDerive(Box::new(BuiltinDerive($func))))\n                 );\n             )*\n         }"}, {"sha": "3dd17207cb8e93ed6d41e2122771a269b9115d60", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -42,7 +42,9 @@ pub mod proc_macro_impl;\n \n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension, MultiModifier};\n+\n+use syntax::ext::base::{MacroExpanderFn, NamedSyntaxExtension, SyntaxExtension};\n+use syntax::ext::hygiene::Transparency;\n use syntax::edition::Edition;\n use syntax::symbol::{sym, Symbol};\n \n@@ -57,9 +59,10 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n             register(Symbol::intern(stringify!($name)),\n-                     NormalTT {\n+                     SyntaxExtension::LegacyBang {\n                         expander: Box::new($f as MacroExpanderFn),\n                         def_info: None,\n+                        transparency: Transparency::SemiTransparent,\n                         allow_internal_unstable: None,\n                         allow_internal_unsafe: false,\n                         local_inner_macros: false,\n@@ -94,25 +97,27 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         assert: assert::expand_assert,\n     }\n \n-    register(sym::test_case, MultiModifier(Box::new(test_case::expand)));\n-    register(sym::test, MultiModifier(Box::new(test::expand_test)));\n-    register(sym::bench, MultiModifier(Box::new(test::expand_bench)));\n+    register(sym::test_case, SyntaxExtension::LegacyAttr(Box::new(test_case::expand)));\n+    register(sym::test, SyntaxExtension::LegacyAttr(Box::new(test::expand_test)));\n+    register(sym::bench, SyntaxExtension::LegacyAttr(Box::new(test::expand_bench)));\n \n     // format_args uses `unstable` things internally.\n     register(Symbol::intern(\"format_args\"),\n-             NormalTT {\n+             SyntaxExtension::LegacyBang {\n                 expander: Box::new(format::expand_format_args),\n                 def_info: None,\n+                transparency: Transparency::SemiTransparent,\n                 allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n                 allow_internal_unsafe: false,\n                 local_inner_macros: false,\n                 unstable_feature: None,\n                 edition,\n             });\n     register(sym::format_args_nl,\n-             NormalTT {\n+             SyntaxExtension::LegacyBang {\n                  expander: Box::new(format::expand_format_args_nl),\n                  def_info: None,\n+                 transparency: Transparency::SemiTransparent,\n                  allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n                  allow_internal_unsafe: false,\n                  local_inner_macros: false,"}, {"sha": "68eaa39997a15c91a3b716945f01c9e80297b9c8", "filename": "src/test/codegen/intrinsics/exact_div.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Fexact_div.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Fexact_div.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Fexact_div.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -8,13 +8,13 @@ use std::intrinsics::exact_div;\n // CHECK-LABEL: @exact_sdiv\n #[no_mangle]\n pub unsafe fn exact_sdiv(x: i32, y: i32) -> i32 {\n-// CHECK: sdiv exact\n+    // CHECK: sdiv exact\n     exact_div(x, y)\n }\n \n // CHECK-LABEL: @exact_udiv\n #[no_mangle]\n pub unsafe fn exact_udiv(x: u32, y: u32) -> u32 {\n-// CHECK: udiv exact\n+    // CHECK: udiv exact\n     exact_div(x, y)\n }", "previous_filename": "src/test/codegen/exact_div.rs"}, {"sha": "c5a0185bd482b5bbae6ecda73faffb15880b07f6", "filename": "src/test/codegen/intrinsics/likely.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Flikely.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Flikely.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Flikely.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "previous_filename": "src/test/codegen/likely.rs"}, {"sha": "6222536b506007871dcafb71ad15d4d353074dca", "filename": "src/test/codegen/intrinsics/move-val-init.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Fmove-val-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Fmove-val-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Fmove-val-init.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "previous_filename": "src/test/codegen/move-val-init.rs"}, {"sha": "3a41fb4fab3b7a3046ab9591eb4880a9b662ee0d", "filename": "src/test/codegen/intrinsics/nontemporal.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Fnontemporal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Fnontemporal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Fnontemporal.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "previous_filename": "src/test/codegen/nontemporal.rs"}, {"sha": "4cd38e142824ab12a93c7a4d83feedc7db9cce2d", "filename": "src/test/codegen/intrinsics/prefetch.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Fprefetch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Fprefetch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Fprefetch.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "previous_filename": "src/test/codegen/prefetch.rs"}, {"sha": "419c120ede9eccdb1ac12cf8b90d25c2bf282991", "filename": "src/test/codegen/intrinsics/unchecked_math.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Funchecked_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fcodegen%2Fintrinsics%2Funchecked_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fintrinsics%2Funchecked_math.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "previous_filename": "src/test/codegen/unchecked_math.rs"}, {"sha": "4d6ff47a3ee918666b944fd64676f1043982221d", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-partial-eq.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-partial-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-partial-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-partial-eq.rs?ref=5f3656ce9a2212fad872605b7a4ee103a155e9f3", "patch": "@@ -1,71 +0,0 @@\n-// force-host\n-\n-#![feature(plugin_registrar, rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_ext;\n-extern crate rustc_plugin;\n-\n-use syntax_ext::deriving;\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n-\n-use rustc_plugin::Registry;\n-use syntax::ast::*;\n-use syntax::source_map::Span;\n-use syntax::ext::base::*;\n-use syntax::ext::build::AstBuilder;\n-use syntax::symbol::Symbol;\n-use syntax::ptr::P;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(Symbol::intern(\"derive_CustomPartialEq\"),\n-                                  MultiDecorator(Box::new(expand_deriving_partial_eq)));\n-}\n-\n-fn expand_deriving_partial_eq(cx: &mut ExtCtxt, span: Span, mitem: &MetaItem, item: &Annotatable,\n-                              push: &mut FnMut(Annotatable)) {\n-    // structures are equal if all fields are equal, and non equal, if\n-    // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_fold(true,\n-                |cx, span, subexpr, self_f, other_fs| {\n-                    let other_f = (other_fs.len(), other_fs.get(0)).1.unwrap();\n-                    let eq = cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone());\n-                    cx.expr_binary(span, BinOpKind::And, subexpr, eq)\n-                },\n-                cx.expr_bool(span, true),\n-                Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n-                cx,\n-                span,\n-                substr)\n-    }\n-\n-    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n-    let attrs = vec![cx.attribute(span, inline)];\n-    let methods = vec![MethodDef {\n-        name: \"eq\",\n-        generics: LifetimeBounds::empty(),\n-        explicit_self: borrowed_explicit_self(),\n-        args: vec![(borrowed_self(), \"other\")],\n-        ret_ty: Literal(deriving::generic::ty::Path::new_local(\"bool\")),\n-        attributes: attrs,\n-        is_unsafe: false,\n-        unify_fieldless_variants: true,\n-        combine_substructure: combine_substructure(Box::new(cs_eq)),\n-    }];\n-\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: Vec::new(),\n-        path: deriving::generic::ty::Path::new(vec![\"cmp\", \"PartialEq\"]),\n-        additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n-        is_unsafe: false,\n-        supports_unions: false,\n-        methods: methods,\n-        associated_types: Vec::new(),\n-    };\n-    trait_def.expand(cx, mitem, item, push)\n-}"}, {"sha": "c6b33fbc75ee23dbd29e30c3a5c2ff325eea6a95", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-plugin-attr.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin-attr.rs?ref=5f3656ce9a2212fad872605b7a4ee103a155e9f3", "patch": "@@ -1,84 +0,0 @@\n-// force-host\n-\n-#![feature(plugin_registrar)]\n-#![feature(box_syntax)]\n-#![feature(rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_ext;\n-extern crate syntax_pos;\n-extern crate rustc;\n-extern crate rustc_plugin;\n-\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n-use syntax::ext::build::AstBuilder;\n-use syntax::symbol::{Symbol, sym};\n-use syntax::ptr::P;\n-use syntax_ext::deriving::generic::{TraitDef, MethodDef, combine_substructure};\n-use syntax_ext::deriving::generic::{Substructure, Struct, EnumMatching};\n-use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n-use syntax_pos::Span;\n-use rustc_plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"rustc_derive_TotalSum\"),\n-        MultiDecorator(box expand));\n-}\n-\n-fn expand(cx: &mut ExtCtxt,\n-          span: Span,\n-          mitem: &ast::MetaItem,\n-          item: &Annotatable,\n-          push: &mut FnMut(Annotatable)) {\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: vec![],\n-        path: Path::new_local(\"TotalSum\"),\n-        additional_bounds: vec![],\n-        generics: LifetimeBounds::empty(),\n-        associated_types: vec![],\n-        is_unsafe: false,\n-        supports_unions: false,\n-        methods: vec![\n-            MethodDef {\n-                name: \"total_sum\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec![],\n-                ret_ty: Literal(Path::new_local(\"isize\")),\n-                attributes: vec![],\n-                is_unsafe: false,\n-                unify_fieldless_variants: true,\n-                combine_substructure: combine_substructure(Box::new(totalsum_substructure)),\n-            },\n-        ],\n-    };\n-\n-    trait_def.expand(cx, mitem, item, push)\n-}\n-\n-// Mostly copied from syntax::ext::deriving::hash\n-/// Defines how the implementation for `trace()` is to be generated\n-fn totalsum_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                         substr: &Substructure) -> P<ast::Expr> {\n-    let fields = match *substr.fields {\n-        Struct(_, ref fs) | EnumMatching(.., ref fs) => fs,\n-        _ => cx.span_bug(trait_span, \"impossible substructure\")\n-    };\n-\n-    fields.iter().fold(cx.expr_isize(trait_span, 0), |acc, ref item| {\n-        if attr::contains_name(&item.attrs, sym::ignore) {\n-            acc\n-        } else {\n-            cx.expr_binary(item.span, ast::BinOpKind::Add, acc,\n-                           cx.expr_method_call(item.span,\n-                                               item.self_.clone(),\n-                                               substr.method_ident,\n-                                               Vec::new()))\n-        }\n-    })\n-}"}, {"sha": "874a0ec7c13fba640680bc324d34e4521b1fd89e", "filename": "src/test/run-pass-fulldeps/auxiliary/custom-derive-plugin.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom-derive-plugin.rs?ref=5f3656ce9a2212fad872605b7a4ee103a155e9f3", "patch": "@@ -1,76 +0,0 @@\n-// force-host\n-\n-#![feature(plugin_registrar)]\n-#![feature(box_syntax)]\n-#![feature(rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_ext;\n-extern crate syntax_pos;\n-extern crate rustc;\n-extern crate rustc_plugin;\n-\n-use syntax::ast;\n-use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n-use syntax::ext::build::AstBuilder;\n-use syntax::symbol::Symbol;\n-use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n-use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n-use syntax_pos::Span;\n-use rustc_plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"derive_TotalSum\"),\n-        MultiDecorator(box expand));\n-\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"derive_Nothing\"),\n-        MultiDecorator(box noop));\n-}\n-\n-fn noop(_: &mut ExtCtxt, _: Span, _: &ast::MetaItem, _: &Annotatable, _: &mut FnMut(Annotatable)) {}\n-\n-fn expand(cx: &mut ExtCtxt,\n-          span: Span,\n-          mitem: &ast::MetaItem,\n-          item: &Annotatable,\n-          push: &mut FnMut(Annotatable)) {\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: vec![],\n-        path: Path::new_local(\"TotalSum\"),\n-        additional_bounds: vec![],\n-        generics: LifetimeBounds::empty(),\n-        associated_types: vec![],\n-        is_unsafe: false,\n-        supports_unions: false,\n-        methods: vec![\n-            MethodDef {\n-                name: \"total_sum\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec![],\n-                ret_ty: Literal(Path::new_local(\"isize\")),\n-                attributes: vec![],\n-                is_unsafe: false,\n-                unify_fieldless_variants: true,\n-                combine_substructure: combine_substructure(box |cx, span, substr| {\n-                    let zero = cx.expr_isize(span, 0);\n-                    cs_fold(false,\n-                            |cx, span, subexpr, field, _| {\n-                                cx.expr_binary(span, ast::BinOpKind::Add, subexpr,\n-                                    cx.expr_method_call(span, field,\n-                                        ast::Ident::from_str(\"total_sum\"), vec![]))\n-                            },\n-                            zero,\n-                            box |cx, span, _, _| { cx.span_bug(span, \"wtf??\"); },\n-                            cx, span, substr)\n-                }),\n-            },\n-        ],\n-    };\n-\n-    trait_def.expand(cx, mitem, item, push)\n-}"}, {"sha": "330459fc08f551cfdb9b099c46009898458cd1fd", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin-args.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -10,11 +10,10 @@ extern crate rustc_plugin;\n \n use std::borrow::ToOwned;\n use syntax::ast;\n-use syntax::ext::hygiene;\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager, NormalTT};\n+use syntax::ext::base::{SyntaxExtension, TTMacroExpander, ExtCtxt, MacResult, MacEager};\n+use syntax::ext::hygiene::Transparency;\n use syntax::print::pprust;\n-use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenStream;\n@@ -29,7 +28,7 @@ impl TTMacroExpander for Expander {\n                    ecx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    _: TokenStream,\n-                   _: Option<Span>) -> Box<MacResult+'cx> {\n+                   _: Option<Span>) -> Box<dyn MacResult+'cx> {\n         let args = self.args.iter().map(|i| pprust::meta_list_item_to_string(i))\n             .collect::<Vec<_>>().join(\", \");\n         MacEager::expr(ecx.expr_str(sp, Symbol::intern(&args)))\n@@ -40,9 +39,10 @@ impl TTMacroExpander for Expander {\n pub fn plugin_registrar(reg: &mut Registry) {\n     let args = reg.args().to_owned();\n     reg.register_syntax_extension(Symbol::intern(\"plugin_args\"),\n-        NormalTT {\n+        SyntaxExtension::LegacyBang {\n             expander: Box::new(Expander { args: args, }),\n             def_info: None,\n+            transparency: Transparency::SemiTransparent,\n             allow_internal_unstable: None,\n             allow_internal_unsafe: false,\n             local_inner_macros: false,"}, {"sha": "ac8fff4f6bfad0c49b0407dc389117163c79d51b", "filename": "src/test/run-pass-fulldeps/custom-derive-partial-eq.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcustom-derive-partial-eq.rs?ref=5f3656ce9a2212fad872605b7a4ee103a155e9f3", "patch": "@@ -1,10 +0,0 @@\n-// aux-build:custom-derive-partial-eq.rs\n-// ignore-stage1\n-#![feature(plugin)]\n-#![plugin(custom_derive_partial_eq)]\n-#![allow(unused)]\n-\n-#[derive_CustomPartialEq] // Check that this is not a stability error.\n-enum E { V1, V2 }\n-\n-fn main() {}"}, {"sha": "38eaa71dd6abaa8fd455ac27c7b229b6cdd85864", "filename": "src/test/run-pass-fulldeps/derive-totalsum-attr.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum-attr.rs?ref=5f3656ce9a2212fad872605b7a4ee103a155e9f3", "patch": "@@ -1,64 +0,0 @@\n-// aux-build:custom-derive-plugin-attr.rs\n-// ignore-stage1\n-\n-#![feature(plugin, rustc_attrs)]\n-#![plugin(custom_derive_plugin_attr)]\n-\n-trait TotalSum {\n-    fn total_sum(&self) -> isize;\n-}\n-\n-impl TotalSum for isize {\n-    fn total_sum(&self) -> isize {\n-        *self\n-    }\n-}\n-\n-struct Seven;\n-\n-impl TotalSum for Seven {\n-    fn total_sum(&self) -> isize {\n-        7\n-    }\n-}\n-\n-#[rustc_derive_TotalSum]\n-struct Foo {\n-    seven: Seven,\n-    bar: Bar,\n-    baz: isize,\n-    #[ignore]\n-    nan: NaN,\n-}\n-\n-#[rustc_derive_TotalSum]\n-struct Bar {\n-    quux: isize,\n-    bleh: isize,\n-    #[ignore]\n-    nan: NaN2\n-}\n-\n-struct NaN;\n-\n-impl TotalSum for NaN {\n-    fn total_sum(&self) -> isize {\n-        panic!();\n-    }\n-}\n-\n-struct NaN2;\n-\n-pub fn main() {\n-    let v = Foo {\n-        seven: Seven,\n-        bar: Bar {\n-            quux: 9,\n-            bleh: 3,\n-            nan: NaN2\n-        },\n-        baz: 80,\n-        nan: NaN\n-    };\n-    assert_eq!(v.total_sum(), 99);\n-}"}, {"sha": "2b0bb51d90aec59a345e384140c3074aaada1613", "filename": "src/test/run-pass-fulldeps/derive-totalsum.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fderive-totalsum.rs?ref=5f3656ce9a2212fad872605b7a4ee103a155e9f3", "patch": "@@ -1,49 +0,0 @@\n-// aux-build:custom-derive-plugin.rs\n-// ignore-stage1\n-\n-#![feature(plugin)]\n-#![plugin(custom_derive_plugin)]\n-\n-trait TotalSum {\n-    fn total_sum(&self) -> isize;\n-}\n-\n-impl TotalSum for isize {\n-    fn total_sum(&self) -> isize {\n-        *self\n-    }\n-}\n-\n-struct Seven;\n-\n-impl TotalSum for Seven {\n-    fn total_sum(&self) -> isize {\n-        7\n-    }\n-}\n-\n-#[derive_TotalSum]\n-struct Foo {\n-    seven: Seven,\n-    bar: Bar,\n-    baz: isize,\n-}\n-\n-#[derive_TotalSum]\n-struct Bar {\n-    quux: isize,\n-    bleh: isize,\n-}\n-\n-\n-pub fn main() {\n-    let v = Foo {\n-        seven: Seven,\n-        bar: Bar {\n-            quux: 9,\n-            bleh: 3,\n-        },\n-        baz: 80,\n-    };\n-    assert_eq!(v.total_sum(), 99);\n-}"}, {"sha": "133f6302bde57cf15834f7801b95f6f9e2c526d3", "filename": "src/test/run-pass-fulldeps/issue-40663.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fissue-40663.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3656ce9a2212fad872605b7a4ee103a155e9f3/src%2Ftest%2Frun-pass-fulldeps%2Fissue-40663.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-40663.rs?ref=5f3656ce9a2212fad872605b7a4ee103a155e9f3", "patch": "@@ -1,13 +0,0 @@\n-#![allow(dead_code)]\n-// aux-build:custom-derive-plugin.rs\n-// ignore-stage1\n-\n-#![feature(plugin)]\n-#![plugin(custom_derive_plugin)]\n-\n-#[derive_Nothing]\n-#[derive_Nothing]\n-#[derive_Nothing]\n-struct S;\n-\n-fn main() {}"}, {"sha": "5b5e431bf2ff6d6824e010b8469010d88f753cad", "filename": "src/test/ui/const-generics/issue-61336-1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-1.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -0,0 +1,12 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n+    [x; N]\n+    //~^ ERROR array lengths can't depend on generic parameters\n+}\n+\n+fn main() {\n+    let x: [u32; 5] = f::<u32, 5>(3);\n+    assert_eq!(x, [3u32; 5]);\n+}"}, {"sha": "1a5bb9f763bcf73a4ab4a709254ecb02ab220217", "filename": "src/test/ui/const-generics/issue-61336-1.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336-1.stderr?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -0,0 +1,14 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-61336-1.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+\n+error: array lengths can't depend on generic parameters\n+  --> $DIR/issue-61336-1.rs:5:9\n+   |\n+LL |     [x; N]\n+   |         ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "95930371d59744af11fc93105be874800ac1acc4", "filename": "src/test/ui/const-generics/issue-61336.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -0,0 +1,16 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n+    [x; N]\n+}\n+\n+fn g<T, const N: usize>(x: T) -> [T; N] {\n+    [x; N]\n+    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied [E0277]\n+}\n+\n+fn main() {\n+    let x: [u32; 5] = f::<u32, 5>(3);\n+    assert_eq!(x, [3u32; 5]);\n+}"}, {"sha": "9939a5998340f5efcb74a89590dae72b49f9df2c", "filename": "src/test/ui/const-generics/issue-61336.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61336.stderr?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -0,0 +1,18 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-61336.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-61336.rs:9:5\n+   |\n+LL |     [x; N]\n+   |     ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+   = help: consider adding a `where T: std::marker::Copy` bound\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "abbdb4ab632dc2d7a2956d00be7ef452f82e2982", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -160,7 +160,7 @@ LL | const fn foo30_2_with_unsafe(x: *mut u32) -> usize { unsafe { x as usize }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:100:38\n    |\n LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n@@ -169,7 +169,7 @@ LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:102:29\n    |\n LL | const fn foo30_5(b: bool) { while b { } }\n@@ -178,7 +178,7 @@ LL | const fn foo30_5(b: bool) { while b { } }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:104:44\n    |\n LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n@@ -187,7 +187,7 @@ LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:106:44\n    |\n LL | const fn foo37(a: bool, b: bool) -> bool { a || b }"}, {"sha": "40e7107e4a15e1654309a068a612819d59d0e576", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -98,13 +98,13 @@ const fn foo30_2(x: *mut u32) -> usize { x as usize }\n const fn foo30_2_with_unsafe(x: *mut u32) -> usize { unsafe { x as usize } }\n //~^ ERROR casting pointers to ints is unstable\n const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n-//~^ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n+//~^ ERROR loops and conditional expressions are not stable in const fn\n const fn foo30_5(b: bool) { while b { } } //~ ERROR not stable in const fn\n const fn foo30_6() -> bool { let x = true; x }\n const fn foo36(a: bool, b: bool) -> bool { a && b }\n-//~^ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n+//~^ ERROR loops and conditional expressions are not stable in const fn\n const fn foo37(a: bool, b: bool) -> bool { a || b }\n-//~^ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n+//~^ ERROR loops and conditional expressions are not stable in const fn\n const fn inc(x: &mut i32) { *x += 1 }\n //~^ ERROR mutable references in const fn are unstable\n "}, {"sha": "28a5ffb2015945ecefd3c7aea04d668b614c004e", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -160,7 +160,7 @@ LL | const fn foo30_2_with_unsafe(x: *mut u32) -> usize { unsafe { x as usize }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:100:38\n    |\n LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n@@ -169,7 +169,7 @@ LL | const fn foo30_4(b: bool) -> usize { if b { 1 } else { 42 } }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:102:29\n    |\n LL | const fn foo30_5(b: bool) { while b { } }\n@@ -178,7 +178,7 @@ LL | const fn foo30_5(b: bool) { while b { } }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:104:44\n    |\n LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n@@ -187,7 +187,7 @@ LL | const fn foo36(a: bool, b: bool) -> bool { a && b }\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/min_const_fn.rs:106:44\n    |\n LL | const fn foo37(a: bool, b: bool) -> bool { a || b }"}, {"sha": "6002506689e12c8cb3a0a55e57d1637bd7db0643", "filename": "src/test/ui/consts/single_variant_match_ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.rs?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -15,7 +15,7 @@ impl Foo {\n         use self::Foo::*;\n \n         match *self {\n-            Prob => 0x1, //~ ERROR `if`, `match`, `&&` and `||` are not stable in const fn\n+            Prob => 0x1, //~ ERROR loops and conditional expressions are not stable in const fn\n         }\n     }\n }"}, {"sha": "1e092c8af99674bdc8ddaa7468ead797dd74a0af", "filename": "src/test/ui/consts/single_variant_match_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fsingle_variant_match_ice.stderr?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -10,7 +10,7 @@ error[E0019]: constant contains unimplemented expression type\n LL |     x => 42,\n    |     ^\n \n-error[E0723]: `if`, `match`, `&&` and `||` are not stable in const fn\n+error[E0723]: loops and conditional expressions are not stable in const fn\n   --> $DIR/single_variant_match_ice.rs:18:13\n    |\n LL |             Prob => 0x1,"}, {"sha": "93cc97d45830b2a9ae9a651c535eb272fb4be198", "filename": "src/test/ui/macros/nonterminal-matching.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fmacros%2Fnonterminal-matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/961a9d6e97a37ff1bb33578721dfa8687054c7b8/src%2Ftest%2Fui%2Fmacros%2Fnonterminal-matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fnonterminal-matching.stderr?ref=961a9d6e97a37ff1bb33578721dfa8687054c7b8", "patch": "@@ -1,6 +1,9 @@\n error: no rules expected the token `enum E { }`\n   --> $DIR/nonterminal-matching.rs:19:10\n    |\n+LL |     macro n(a $nt_item b) {\n+   |     --------------------- when calling this macro\n+...\n LL |     n!(a $nt_item b);\n    |          ^^^^^^^^ no rules expected this token in macro call\n ..."}]}