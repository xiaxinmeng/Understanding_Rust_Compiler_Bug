{"sha": "2b38c4bdea7acf72b8322660de5a4f86d561a65c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMzhjNGJkZWE3YWNmNzJiODMyMjY2MGRlNWE0Zjg2ZDU2MWE2NWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-21T16:33:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-28T16:05:04Z"}, "message": "Extend DepGraph so it can track \"work-products\"\n\nA work product right now is just a `.o` file. In the future it probably\nincludes other kinds of files, such as `.bc` files saving the\nunoptimized LLVM IR.\n\nHowever, because WorkProductIds must be independent of DefIds, so that\nthey don't need translation, this system may not be suitable *as is* for\nstoring fine-grained information (such as the MIR for individual defs),\nas it was originally intended. We will want to refactor some for that.", "tree": {"sha": "6f7e4e39127c96be68f1b98f3e8ecbb97fb2ebe9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f7e4e39127c96be68f1b98f3e8ecbb97fb2ebe9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b38c4bdea7acf72b8322660de5a4f86d561a65c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b38c4bdea7acf72b8322660de5a4f86d561a65c", "html_url": "https://github.com/rust-lang/rust/commit/2b38c4bdea7acf72b8322660de5a4f86d561a65c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b38c4bdea7acf72b8322660de5a4f86d561a65c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cec262e55a92ad15196c4ea6d490fb6ef6bccab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cec262e55a92ad15196c4ea6d490fb6ef6bccab4", "html_url": "https://github.com/rust-lang/rust/commit/cec262e55a92ad15196c4ea6d490fb6ef6bccab4"}], "stats": {"total": 137, "additions": 128, "deletions": 9}, "files": [{"sha": "dd7f0286574d0b46f11758b21a21f4c32a82f11c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2b38c4bdea7acf72b8322660de5a4f86d561a65c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b38c4bdea7acf72b8322660de5a4f86d561a65c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=2b38c4bdea7acf72b8322660de5a4f86d561a65c", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::fmt::Debug;\n+use std::sync::Arc;\n \n macro_rules! try_opt {\n     ($e:expr) => (\n@@ -45,6 +46,10 @@ pub enum DepNode<D: Clone + Debug> {\n     // in an extern crate.\n     MetaData(D),\n \n+    // Represents some artifact that we save to disk. Note that these\n+    // do not have a def-id as part of their identifier.\n+    WorkProduct(Arc<WorkProductId>),\n+\n     // Represents different phases in the compiler.\n     CrateReader,\n     CollectLanguageItems,\n@@ -189,6 +194,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrate => Some(TransCrate),\n             TransWriteMetadata => Some(TransWriteMetadata),\n             LinkBinary => Some(LinkBinary),\n+\n+            // work product names do not need to be mapped, because\n+            // they are always absolute.\n+            WorkProduct(ref id) => Some(WorkProduct(id.clone())),\n+\n             Hir(ref d) => op(d).map(Hir),\n             MetaData(ref d) => op(d).map(MetaData),\n             CollectItem(ref d) => op(d).map(CollectItem),\n@@ -229,3 +239,14 @@ impl<D: Clone + Debug> DepNode<D> {\n         }\n     }\n }\n+\n+/// A \"work product\" corresponds to a `.o` (or other) file that we\n+/// save in between runs. These ids do not have a DefId but rather\n+/// some independent path or string that persists between runs without\n+/// the need to be mapped or unmapped. (This ensures we can serialize\n+/// them even in the absence of a tcx.)\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum WorkProductId {\n+    PartitionObjectFile(String), // see (*TransPartition) below\n+}\n+"}, {"sha": "ab7013df33f14c23a63715f1d3ec5d6ed2f8beb1", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 105, "deletions": 9, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/2b38c4bdea7acf72b8322660de5a4f86d561a65c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b38c4bdea7acf72b8322660de5a4f86d561a65c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=2b38c4bdea7acf72b8322660de5a4f86d561a65c", "patch": "@@ -9,42 +9,64 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n+use rustc_data_structures::fnv::FnvHashMap;\n+use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n+use std::sync::Arc;\n \n-use super::dep_node::DepNode;\n+use super::dep_node::{DepNode, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n use super::thread::{DepGraphThreadData, DepMessage};\n \n #[derive(Clone)]\n pub struct DepGraph {\n-    data: Rc<DepGraphThreadData>\n+    data: Rc<DepGraphData>\n+}\n+\n+struct DepGraphData {\n+    /// we send messages to the thread to let it build up the dep-graph\n+    /// from the current run\n+    thread: DepGraphThreadData,\n+\n+    /// when we load, there may be `.o` files, cached mir, or other such\n+    /// things available to us. If we find that they are not dirty, we\n+    /// load the path to the file storing those work-products here into\n+    /// this map. We can later look for and extract that data.\n+    previous_work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n+\n+    /// work-products that we generate in this run\n+    work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n }\n \n impl DepGraph {\n     pub fn new(enabled: bool) -> DepGraph {\n         DepGraph {\n-            data: Rc::new(DepGraphThreadData::new(enabled))\n+            data: Rc::new(DepGraphData {\n+                thread: DepGraphThreadData::new(enabled),\n+                previous_work_products: RefCell::new(FnvHashMap()),\n+                work_products: RefCell::new(FnvHashMap())\n+            })\n         }\n     }\n \n     /// True if we are actually building a dep-graph. If this returns false,\n     /// then the other methods on this `DepGraph` will have no net effect.\n     #[inline]\n     pub fn enabled(&self) -> bool {\n-        self.data.enabled()\n+        self.data.thread.enabled()\n     }\n \n     pub fn query(&self) -> DepGraphQuery<DefId> {\n-        self.data.query()\n+        self.data.thread.query()\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> raii::IgnoreTask<'graph> {\n-        raii::IgnoreTask::new(&self.data)\n+        raii::IgnoreTask::new(&self.data.thread)\n     }\n \n     pub fn in_task<'graph>(&'graph self, key: DepNode<DefId>) -> raii::DepTask<'graph> {\n-        raii::DepTask::new(&self.data, key)\n+        raii::DepTask::new(&self.data.thread, key)\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n@@ -62,10 +84,84 @@ impl DepGraph {\n     }\n \n     pub fn read(&self, v: DepNode<DefId>) {\n-        self.data.enqueue(DepMessage::Read(v));\n+        self.data.thread.enqueue(DepMessage::Read(v));\n     }\n \n     pub fn write(&self, v: DepNode<DefId>) {\n-        self.data.enqueue(DepMessage::Write(v));\n+        self.data.thread.enqueue(DepMessage::Write(v));\n+    }\n+\n+    /// Indicates that a previous work product exists for `v`. This is\n+    /// invoked during initial start-up based on what nodes are clean\n+    /// (and what files exist in the incr. directory).\n+    pub fn insert_previous_work_product(&self, v: &Arc<WorkProductId>, data: WorkProduct) {\n+        debug!(\"insert_previous_work_product({:?}, {:?})\", v, data);\n+        self.data.previous_work_products.borrow_mut()\n+                                        .insert(v.clone(), data);\n+    }\n+\n+    /// Indicates that we created the given work-product in this run\n+    /// for `v`. This record will be preserved and loaded in the next\n+    /// run.\n+    pub fn insert_work_product(&self, v: &Arc<WorkProductId>, data: WorkProduct) {\n+        debug!(\"insert_work_product({:?}, {:?})\", v, data);\n+        self.data.work_products.borrow_mut()\n+                               .insert(v.clone(), data);\n     }\n+\n+    /// Check whether a previous work product exists for `v` and, if\n+    /// so, return the path that leads to it. Used to skip doing work.\n+    pub fn previous_work_product(&self, v: &Arc<WorkProductId>) -> Option<WorkProduct> {\n+        self.data.previous_work_products.borrow()\n+                                        .get(v)\n+                                        .cloned()\n+    }\n+\n+    /// Access the map of work-products created during this run. Only\n+    /// used during saving of the dep-graph.\n+    pub fn work_products(&self) -> Ref<FnvHashMap<Arc<WorkProductId>, WorkProduct>> {\n+        self.data.work_products.borrow()\n+    }\n+}\n+\n+/// A \"work product\" is an intermediate result that we save into the\n+/// incremental directory for later re-use. The primary example are\n+/// the object files that we save for each partition at code\n+/// generation time.\n+///\n+/// Each work product is associated with a dep-node, representing the\n+/// process that produced the work-product. If that dep-node is found\n+/// to be dirty when we load up, then we will delete the work-product\n+/// at load time. If the work-product is found to be clean, the we\n+/// will keep a record in the `previous_work_products` list.\n+///\n+/// In addition, work products have an associated hash. This hash is\n+/// an extra hash that can be used to decide if the work-product from\n+/// a previous compilation can be re-used (in addition to the dirty\n+/// edges check).\n+///\n+/// As the primary example, consider the object files we generate for\n+/// each partition. In the first run, we create partitions based on\n+/// the symbols that need to be compiled. For each partition P, we\n+/// hash the symbols in P and create a `WorkProduct` record associated\n+/// with `DepNode::TransPartition(P)`; the hash is the set of symbols\n+/// in P.\n+///\n+/// The next time we compile, if the `DepNode::TransPartition(P)` is\n+/// judged to be clean (which means none of the things we read to\n+/// generate the partition were found to be dirty), it will be loaded\n+/// into previous work products. We will then regenerate the set of\n+/// symbols in the partition P and hash them (note that new symbols\n+/// may be added -- for example, new monomorphizations -- even if\n+/// nothing in P changed!). We will compare that hash against the\n+/// previous hash. If it matches up, we can reuse the object file.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct WorkProduct {\n+    /// extra hash used to decide if work-product is still suitable;\n+    /// note that this is *not* a hash of the work-product itself.\n+    /// See documentation on `WorkProduct` type for an example.\n+    pub input_hash: u64,\n+\n+    /// filename storing this work-product (found in the incr. comp. directory)\n+    pub file_name: String,\n }"}, {"sha": "a499cb10f2325d3032f72d58b106ef18a5559d10", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b38c4bdea7acf72b8322660de5a4f86d561a65c/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b38c4bdea7acf72b8322660de5a4f86d561a65c/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=2b38c4bdea7acf72b8322660de5a4f86d561a65c", "patch": "@@ -20,7 +20,9 @@ mod visit;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;\n+pub use self::dep_node::WorkProductId;\n pub use self::graph::DepGraph;\n+pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n pub use self::visit::visit_all_items_in_krate;\n pub use self::raii::DepTask;"}]}