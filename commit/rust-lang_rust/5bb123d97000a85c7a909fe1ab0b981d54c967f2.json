{"sha": "5bb123d97000a85c7a909fe1ab0b981d54c967f2", "node_id": "C_kwDOAAsO6NoAKDViYjEyM2Q5NzAwMGE4NWM3YTkwOWZlMWFiMGI5ODFkNTRjOTY3ZjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-24T17:42:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-24T17:42:00Z"}, "message": "Auto merge of #12520 - Veykril:flycheck-cancel, r=Veykril\n\ninternal: Bring back JodChild into flychecking for cancellation\n\ncc https://github.com/rust-lang/rust-analyzer/pull/10517/files#r895241975", "tree": {"sha": "ab752d39b1b5a867c17006473fd0fd00b1298387", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab752d39b1b5a867c17006473fd0fd00b1298387"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bb123d97000a85c7a909fe1ab0b981d54c967f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bb123d97000a85c7a909fe1ab0b981d54c967f2", "html_url": "https://github.com/rust-lang/rust/commit/5bb123d97000a85c7a909fe1ab0b981d54c967f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bb123d97000a85c7a909fe1ab0b981d54c967f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "401a71d1d7e99cd5563253da77d4b293de9b6731", "url": "https://api.github.com/repos/rust-lang/rust/commits/401a71d1d7e99cd5563253da77d4b293de9b6731", "html_url": "https://github.com/rust-lang/rust/commit/401a71d1d7e99cd5563253da77d4b293de9b6731"}, {"sha": "59799312e293b5a5613ec15615e32d651fa4af0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/59799312e293b5a5613ec15615e32d651fa4af0b", "html_url": "https://github.com/rust-lang/rust/commit/59799312e293b5a5613ec15615e32d651fa4af0b"}], "stats": {"total": 199, "additions": 131, "deletions": 68}, "files": [{"sha": "df666ae097bec4fc8f0db05e3a4a316bcf6868c9", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 75, "deletions": 30, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5bb123d97000a85c7a909fe1ab0b981d54c967f2/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb123d97000a85c7a909fe1ab0b981d54c967f2/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=5bb123d97000a85c7a909fe1ab0b981d54c967f2", "patch": "@@ -2,12 +2,16 @@\n //! another compatible command (f.x. clippy) in a background thread and provide\n //! LSP diagnostics based on the output of the command.\n \n-use std::{fmt, io, process::Command, time::Duration};\n+use std::{\n+    fmt, io,\n+    process::{ChildStderr, ChildStdout, Command, Stdio},\n+    time::Duration,\n+};\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n use paths::AbsPathBuf;\n use serde::Deserialize;\n-use stdx::process::streaming_output;\n+use stdx::{process::streaming_output, JodChild};\n \n pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,\n@@ -117,7 +121,7 @@ struct FlycheckActor {\n     sender: Box<dyn Fn(Message) + Send>,\n     config: FlycheckConfig,\n     workspace_root: AbsPathBuf,\n-    /// WatchThread exists to wrap around the communication needed to be able to\n+    /// CargoHandle exists to wrap around the communication needed to be able to\n     /// run `cargo check` without blocking. Currently the Rust standard library\n     /// doesn't provide a way to read sub-process output without blocking, so we\n     /// have to wrap sub-processes output handling in a thread and pass messages\n@@ -153,18 +157,36 @@ impl FlycheckActor {\n         while let Some(event) = self.next_event(&inbox) {\n             match event {\n                 Event::Restart(Restart) => {\n+                    if let Some(cargo_handle) = self.cargo_handle.take() {\n+                        // Cancel the previously spawned process\n+                        cargo_handle.cancel();\n+                    }\n                     while let Ok(Restart) = inbox.recv_timeout(Duration::from_millis(50)) {}\n-\n-                    self.cancel_check_process();\n+                    self.progress(Progress::DidCancel);\n \n                     let command = self.check_command();\n-                    tracing::info!(\"restart flycheck {:?}\", command);\n-                    self.cargo_handle = Some(CargoHandle::spawn(command));\n-                    self.progress(Progress::DidStart);\n+                    tracing::debug!(?command, \"will restart flycheck\");\n+                    match CargoHandle::spawn(command) {\n+                        Ok(cargo_handle) => {\n+                            tracing::debug!(\n+                                command = ?self.check_command(),\n+                                \"did  restart flycheck\"\n+                            );\n+                            self.cargo_handle = Some(cargo_handle);\n+                            self.progress(Progress::DidStart);\n+                        }\n+                        Err(error) => {\n+                            tracing::error!(\n+                                command = ?self.check_command(),\n+                                %error, \"failed to restart flycheck\"\n+                            );\n+                        }\n+                    }\n                 }\n                 Event::CheckEvent(None) => {\n-                    // Watcher finished, replace it with a never channel to\n-                    // avoid busy-waiting.\n+                    tracing::debug!(\"flycheck finished\");\n+\n+                    // Watcher finished\n                     let cargo_handle = self.cargo_handle.take().unwrap();\n                     let res = cargo_handle.join();\n                     if res.is_err() {\n@@ -192,8 +214,10 @@ impl FlycheckActor {\n         // If we rerun the thread, we need to discard the previous check results first\n         self.cancel_check_process();\n     }\n+\n     fn cancel_check_process(&mut self) {\n-        if self.cargo_handle.take().is_some() {\n+        if let Some(cargo_handle) = self.cargo_handle.take() {\n+            cargo_handle.cancel();\n             self.progress(Progress::DidCancel);\n         }\n     }\n@@ -249,37 +273,64 @@ impl FlycheckActor {\n     }\n }\n \n+/// A handle to a cargo process used for fly-checking.\n struct CargoHandle {\n-    thread: jod_thread::JoinHandle<io::Result<()>>,\n+    /// The handle to the actual cargo process. As we cannot cancel directly from with\n+    /// a read syscall dropping and therefor terminating the process is our best option.\n+    child: JodChild,\n+    thread: jod_thread::JoinHandle<io::Result<(bool, String)>>,\n     receiver: Receiver<CargoMessage>,\n }\n \n impl CargoHandle {\n-    fn spawn(command: Command) -> CargoHandle {\n+    fn spawn(mut command: Command) -> std::io::Result<CargoHandle> {\n+        command.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n+        let mut child = JodChild::spawn(command)?;\n+\n+        let stdout = child.stdout.take().unwrap();\n+        let stderr = child.stderr.take().unwrap();\n+\n         let (sender, receiver) = unbounded();\n-        let actor = CargoActor::new(sender);\n+        let actor = CargoActor::new(sender, stdout, stderr);\n         let thread = jod_thread::Builder::new()\n             .name(\"CargoHandle\".to_owned())\n-            .spawn(move || actor.run(command))\n+            .spawn(move || actor.run())\n             .expect(\"failed to spawn thread\");\n-        CargoHandle { thread, receiver }\n+        Ok(CargoHandle { child, thread, receiver })\n     }\n \n-    fn join(self) -> io::Result<()> {\n-        self.thread.join()\n+    fn cancel(mut self) {\n+        let _ = self.child.kill();\n+        let _ = self.child.wait();\n+    }\n+\n+    fn join(mut self) -> io::Result<()> {\n+        let _ = self.child.kill();\n+        let exit_status = self.child.wait()?;\n+        let (read_at_least_one_message, error) = self.thread.join()?;\n+        if read_at_least_one_message || exit_status.success() {\n+            Ok(())\n+        } else {\n+            Err(io::Error::new(io::ErrorKind::Other, format!(\n+                \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?}):\\n{}\",\n+                exit_status, error\n+            )))\n+        }\n     }\n }\n \n struct CargoActor {\n     sender: Sender<CargoMessage>,\n+    stdout: ChildStdout,\n+    stderr: ChildStderr,\n }\n \n impl CargoActor {\n-    fn new(sender: Sender<CargoMessage>) -> CargoActor {\n-        CargoActor { sender }\n+    fn new(sender: Sender<CargoMessage>, stdout: ChildStdout, stderr: ChildStderr) -> CargoActor {\n+        CargoActor { sender, stdout, stderr }\n     }\n \n-    fn run(self, command: Command) -> io::Result<()> {\n+    fn run(self) -> io::Result<(bool, String)> {\n         // We manually read a line at a time, instead of using serde's\n         // stream deserializers, because the deserializer cannot recover\n         // from an error, resulting in it getting stuck, because we try to\n@@ -292,7 +343,8 @@ impl CargoActor {\n         let mut error = String::new();\n         let mut read_at_least_one_message = false;\n         let output = streaming_output(\n-            command,\n+            self.stdout,\n+            self.stderr,\n             &mut |line| {\n                 read_at_least_one_message = true;\n \n@@ -325,14 +377,7 @@ impl CargoActor {\n             },\n         );\n         match output {\n-            Ok(_) if read_at_least_one_message => Ok(()),\n-            Ok(output) if output.status.success() => Ok(()),\n-            Ok(output)  => {\n-                Err(io::Error::new(io::ErrorKind::Other, format!(\n-                    \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?}):\\n{}\",\n-                    output.status, error\n-                )))\n-            }\n+            Ok(_) => Ok((read_at_least_one_message, error)),\n             Err(e) => Err(io::Error::new(e.kind(), format!(\"{:?}: {}\", e, error))),\n         }\n     }"}, {"sha": "ee7f8339a76a1f3f73f990c91e6de37db9f80988", "filename": "crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bb123d97000a85c7a909fe1ab0b981d54c967f2/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb123d97000a85c7a909fe1ab0b981d54c967f2/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=5bb123d97000a85c7a909fe1ab0b981d54c967f2", "patch": "@@ -110,7 +110,7 @@ impl WorkspaceBuildScripts {\n         };\n \n         tracing::info!(\"Running build scripts: {:?}\", cmd);\n-        let output = stdx::process::streaming_output(\n+        let output = stdx::process::spawn_with_streaming_output(\n             cmd,\n             &mut |line| {\n                 // Copy-pasted from existing cargo_metadata. It seems like we"}, {"sha": "66fa25ec2318b01af57afbc2cb08c779361b384e", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5bb123d97000a85c7a909fe1ab0b981d54c967f2/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb123d97000a85c7a909fe1ab0b981d54c967f2/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=5bb123d97000a85c7a909fe1ab0b981d54c967f2", "patch": "@@ -1,6 +1,7 @@\n //! Missing batteries for standard libraries.\n-use std::iter;\n+use std::process::Command;\n use std::{cmp::Ordering, ops, time::Instant};\n+use std::{io as sio, iter};\n \n mod macros;\n pub mod process;\n@@ -132,6 +133,7 @@ pub fn defer<F: FnOnce()>(f: F) -> impl Drop {\n     D(Some(f))\n }\n \n+/// A [`std::process::Child`] wrapper that will kill the child on drop.\n #[cfg_attr(not(target_arch = \"wasm32\"), repr(transparent))]\n #[derive(Debug)]\n pub struct JodChild(pub std::process::Child);\n@@ -157,6 +159,10 @@ impl Drop for JodChild {\n }\n \n impl JodChild {\n+    pub fn spawn(mut command: Command) -> sio::Result<Self> {\n+        command.spawn().map(Self)\n+    }\n+\n     pub fn into_inner(self) -> std::process::Child {\n         if cfg!(target_arch = \"wasm32\") {\n             panic!(\"no processes on wasm\");"}, {"sha": "e5aa3436518762d393fab6a601da6d06c996813a", "filename": "crates/stdx/src/process.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5bb123d97000a85c7a909fe1ab0b981d54c967f2/crates%2Fstdx%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb123d97000a85c7a909fe1ab0b981d54c967f2/crates%2Fstdx%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fprocess.rs?ref=5bb123d97000a85c7a909fe1ab0b981d54c967f2", "patch": "@@ -5,54 +5,66 @@\n \n use std::{\n     io,\n-    process::{Command, Output, Stdio},\n+    process::{ChildStderr, ChildStdout, Command, Output, Stdio},\n };\n \n+use crate::JodChild;\n+\n pub fn streaming_output(\n-    mut cmd: Command,\n+    out: ChildStdout,\n+    err: ChildStderr,\n     on_stdout_line: &mut dyn FnMut(&str),\n     on_stderr_line: &mut dyn FnMut(&str),\n-) -> io::Result<Output> {\n+) -> io::Result<(Vec<u8>, Vec<u8>)> {\n     let mut stdout = Vec::new();\n     let mut stderr = Vec::new();\n \n-    let cmd = cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n-\n-    let status = {\n-        let mut child = cmd.spawn()?;\n-        let out = child.stdout.take().unwrap();\n-        let err = child.stderr.take().unwrap();\n-        imp::read2(out, err, &mut |is_out, data, eof| {\n-            let idx = if eof {\n-                data.len()\n-            } else {\n-                match data.iter().rposition(|b| *b == b'\\n') {\n-                    Some(i) => i + 1,\n-                    None => return,\n-                }\n+    imp::read2(out, err, &mut |is_out, data, eof| {\n+        let idx = if eof {\n+            data.len()\n+        } else {\n+            match data.iter().rposition(|b| *b == b'\\n') {\n+                Some(i) => i + 1,\n+                None => return,\n+            }\n+        };\n+        {\n+            // scope for new_lines\n+            let new_lines = {\n+                let dst = if is_out { &mut stdout } else { &mut stderr };\n+                let start = dst.len();\n+                let data = data.drain(..idx);\n+                dst.extend(data);\n+                &dst[start..]\n             };\n-            {\n-                // scope for new_lines\n-                let new_lines = {\n-                    let dst = if is_out { &mut stdout } else { &mut stderr };\n-                    let start = dst.len();\n-                    let data = data.drain(..idx);\n-                    dst.extend(data);\n-                    &dst[start..]\n-                };\n-                for line in String::from_utf8_lossy(new_lines).lines() {\n-                    if is_out {\n-                        on_stdout_line(line);\n-                    } else {\n-                        on_stderr_line(line);\n-                    }\n+            for line in String::from_utf8_lossy(new_lines).lines() {\n+                if is_out {\n+                    on_stdout_line(line);\n+                } else {\n+                    on_stderr_line(line);\n                 }\n             }\n-        })?;\n-        let _ = child.kill();\n-        child.wait()?\n-    };\n+        }\n+    })?;\n+\n+    Ok((stdout, stderr))\n+}\n+\n+pub fn spawn_with_streaming_output(\n+    mut cmd: Command,\n+    on_stdout_line: &mut dyn FnMut(&str),\n+    on_stderr_line: &mut dyn FnMut(&str),\n+) -> io::Result<Output> {\n+    let cmd = cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n \n+    let mut child = JodChild(cmd.spawn()?);\n+    let (stdout, stderr) = streaming_output(\n+        child.stdout.take().unwrap(),\n+        child.stderr.take().unwrap(),\n+        on_stdout_line,\n+        on_stderr_line,\n+    )?;\n+    let status = child.wait()?;\n     Ok(Output { status, stdout, stderr })\n }\n "}]}