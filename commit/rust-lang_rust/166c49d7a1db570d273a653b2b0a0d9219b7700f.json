{"sha": "166c49d7a1db570d273a653b2b0a0d9219b7700f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NmM0OWQ3YTFkYjU3MGQyNzNhNjUzYjJiMGEwZDkyMTliNzcwMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-24T07:48:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-24T07:48:29Z"}, "message": "Auto merge of #62012 - wesleywiser:const_prop_use_ecx, r=oli-obk\n\nUse ecx for const-prop local storage\n\nr? @oli-obk", "tree": {"sha": "911ab1403cb9f8c6b7561cf59dfd9ad9011dde41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/911ab1403cb9f8c6b7561cf59dfd9ad9011dde41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/166c49d7a1db570d273a653b2b0a0d9219b7700f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/166c49d7a1db570d273a653b2b0a0d9219b7700f", "html_url": "https://github.com/rust-lang/rust/commit/166c49d7a1db570d273a653b2b0a0d9219b7700f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/166c49d7a1db570d273a653b2b0a0d9219b7700f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cc34867339356a34428e9ec3efa618d86228fed", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cc34867339356a34428e9ec3efa618d86228fed", "html_url": "https://github.com/rust-lang/rust/commit/3cc34867339356a34428e9ec3efa618d86228fed"}, {"sha": "c686130a38b405c3a73509c551d344407099cdb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c686130a38b405c3a73509c551d344407099cdb5", "html_url": "https://github.com/rust-lang/rust/commit/c686130a38b405c3a73509c551d344407099cdb5"}], "stats": {"total": 141, "additions": 116, "deletions": 25}, "files": [{"sha": "fbba8d10326a9d9057282b2d562f4e8dfaed4315", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/166c49d7a1db570d273a653b2b0a0d9219b7700f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166c49d7a1db570d273a653b2b0a0d9219b7700f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=166c49d7a1db570d273a653b2b0a0d9219b7700f", "patch": "@@ -319,7 +319,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         t: T,\n     ) -> InterpResult<'tcx, T> {\n         match self.stack.last() {\n-            Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)),\n+            Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n             None => if t.needs_subst() {\n                 err!(TooGeneric).into()\n             } else {\n@@ -332,11 +332,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         &self,\n         t: T,\n         substs: SubstsRef<'tcx>\n-    ) -> T {\n+    ) -> InterpResult<'tcx, T> {\n         // miri doesn't care about lifetimes, and will choke on some crazy ones\n         // let's simply get rid of them\n         let substituted = t.subst(*self.tcx, substs);\n-        self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted)\n+\n+        if substituted.needs_subst() {\n+            return err!(TooGeneric);\n+        }\n+\n+        Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n     }\n \n     pub fn layout_of_local(\n@@ -349,7 +354,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             None => {\n                 let layout = crate::interpret::operand::from_known_layout(layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n-                    let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs);\n+                    let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs)?;\n                     self.layout_of(local_ty)\n                 })?;\n                 // Layouts of locals are requested a lot, so we cache them."}, {"sha": "c7a2fdd93830f64c166e956308e0059757a097e7", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 107, "deletions": 21, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/166c49d7a1db570d273a653b2b0a0d9219b7700f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166c49d7a1db570d273a653b2b0a0d9219b7700f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=166c49d7a1db570d273a653b2b0a0d9219b7700f", "patch": "@@ -1,6 +1,8 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n+use std::cell::Cell;\n+\n use rustc::hir::def::DefKind;\n use rustc::mir::{\n     AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue,\n@@ -21,7 +23,8 @@ use rustc::ty::layout::{\n };\n \n use crate::interpret::{\n-    self, InterpretCx, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind,\n+    self, InterpretCx, ScalarMaybeUndef, Immediate, OpTy,\n+    ImmTy, MemoryKind, StackPopCleanup, LocalValue, LocalState,\n };\n use crate::const_eval::{\n     CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n@@ -56,21 +59,54 @@ impl MirPass for ConstProp {\n \n         trace!(\"ConstProp starting for {:?}\", source.def_id());\n \n+        // Steal some data we need from `body`.\n+        let source_scope_local_data = std::mem::replace(\n+            &mut body.source_scope_local_data,\n+            ClearCrossCrate::Clear\n+        );\n+        let promoted = std::mem::replace(\n+            &mut body.promoted,\n+            IndexVec::new()\n+        );\n+\n+        let dummy_body =\n+            &Body::new(\n+                body.basic_blocks().clone(),\n+                Default::default(),\n+                ClearCrossCrate::Clear,\n+                Default::default(),\n+                None,\n+                body.local_decls.clone(),\n+                Default::default(),\n+                body.arg_count,\n+                Default::default(),\n+                tcx.def_span(source.def_id()),\n+                Default::default(),\n+            );\n+\n         // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold\n         // constants, instead of just checking for const-folding succeeding.\n         // That would require an uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n-        let mut optimization_finder = ConstPropagator::new(body, tcx, source);\n+        let mut optimization_finder = ConstPropagator::new(\n+            body,\n+            dummy_body,\n+            source_scope_local_data,\n+            promoted,\n+            tcx,\n+            source\n+        );\n         optimization_finder.visit_body(body);\n \n         // put back the data we stole from `mir`\n+        let (source_scope_local_data, promoted) = optimization_finder.release_stolen_data();\n         std::mem::replace(\n             &mut body.source_scope_local_data,\n-            optimization_finder.source_scope_local_data\n+            source_scope_local_data\n         );\n         std::mem::replace(\n             &mut body.promoted,\n-            optimization_finder.promoted\n+            promoted\n         );\n \n         trace!(\"ConstProp done for {:?}\", source.def_id());\n@@ -84,7 +120,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n-    places: IndexVec<Local, Option<Const<'tcx>>>,\n     can_const_prop: IndexVec<Local, bool>,\n     param_env: ParamEnv<'tcx>,\n     source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n@@ -117,36 +152,87 @@ impl<'mir, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n \n impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn new(\n-        body: &mut Body<'tcx>,\n+        body: &Body<'tcx>,\n+        dummy_body: &'mir Body<'tcx>,\n+        source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n+        promoted: IndexVec<Promoted, Body<'tcx>>,\n         tcx: TyCtxt<'tcx>,\n         source: MirSource<'tcx>,\n     ) -> ConstPropagator<'mir, 'tcx> {\n-        let param_env = tcx.param_env(source.def_id());\n-        let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id()), param_env);\n+        let def_id = source.def_id();\n+        let param_env = tcx.param_env(def_id);\n+        let span = tcx.def_span(def_id);\n+        let mut ecx = mk_eval_cx(tcx, span, param_env);\n         let can_const_prop = CanConstProp::check(body);\n-        let source_scope_local_data = std::mem::replace(\n-            &mut body.source_scope_local_data,\n-            ClearCrossCrate::Clear\n-        );\n-        let promoted = std::mem::replace(\n-            &mut body.promoted,\n-            IndexVec::new()\n-        );\n+\n+        ecx.push_stack_frame(\n+            Instance::new(def_id, &InternalSubsts::identity_for_item(tcx, def_id)),\n+            span,\n+            dummy_body,\n+            None,\n+            StackPopCleanup::None {\n+                cleanup: false,\n+            },\n+        ).expect(\"failed to push initial stack frame\");\n \n         ConstPropagator {\n             ecx,\n             tcx,\n             source,\n             param_env,\n             can_const_prop,\n-            places: IndexVec::from_elem(None, &body.local_decls),\n             source_scope_local_data,\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n             promoted,\n         }\n     }\n \n+    fn release_stolen_data(\n+        self,\n+    ) -> (\n+        ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n+        IndexVec<Promoted, Body<'tcx>>,\n+    ) {\n+        (self.source_scope_local_data, self.promoted)\n+    }\n+\n+    fn get_const(&self, local: Local) -> Option<Const<'tcx>> {\n+        let l = &self.ecx.frame().locals[local];\n+\n+        // If the local is `Unitialized` or `Dead` then we haven't propagated a value into it.\n+        //\n+        // `InterpretCx::access_local()` mostly takes care of this for us however, for ZSTs,\n+        // it will synthesize a value for us. In doing so, that will cause the\n+        // `get_const(l).is_empty()` assert right before we call `set_const()` in `visit_statement`\n+        // to fail.\n+        if let LocalValue::Uninitialized | LocalValue::Dead = l.value {\n+            return None;\n+        }\n+\n+        self.ecx.access_local(self.ecx.frame(), local, None).ok()\n+    }\n+\n+    fn set_const(&mut self, local: Local, c: Const<'tcx>) {\n+        let frame = self.ecx.frame_mut();\n+\n+        if let Some(layout) = frame.locals[local].layout.get() {\n+            debug_assert_eq!(c.layout, layout);\n+        }\n+\n+        frame.locals[local] = LocalState {\n+            value: LocalValue::Live(*c),\n+            layout: Cell::new(Some(c.layout)),\n+        };\n+    }\n+\n+    fn remove_const(&mut self, local: Local) {\n+        self.ecx.frame_mut().locals[local] = LocalState {\n+            value: LocalValue::Uninitialized,\n+            layout: Cell::new(None),\n+        };\n+    }\n+\n     fn use_ecx<F, T>(\n         &mut self,\n         source_info: SourceInfo,\n@@ -296,7 +382,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         trace!(\"eval_place(place={:?})\", place);\n         place.iterate(|place_base, place_projection| {\n             let mut eval = match place_base {\n-                PlaceBase::Local(loc) => self.places[*loc].clone()?,\n+                PlaceBase::Local(loc) => self.get_const(*loc).clone()?,\n                 PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..}) => {\n                     let generics = self.tcx.generics_of(self.source.def_id());\n                     if generics.requires_monomorphization(self.tcx) {\n@@ -699,8 +785,8 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                         trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n                         if self.can_const_prop[local] {\n                             trace!(\"storing {:?} to {:?}\", value, local);\n-                            assert!(self.places[local].is_none());\n-                            self.places[local] = Some(value);\n+                            assert!(self.get_const(local).is_none());\n+                            self.set_const(local, value);\n \n                             if self.should_const_prop() {\n                                 self.replace_with_const(\n@@ -740,7 +826,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                                     place = &proj.base;\n                                 }\n                                 if let Place::Base(PlaceBase::Local(local)) = *place {\n-                                    self.places[local] = None;\n+                                    self.remove_const(local);\n                                 }\n                             },\n                             Operand::Constant(_) => {}"}]}