{"sha": "c7377c3555c37d23b0c31a727b3d7b95427767d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3Mzc3YzM1NTVjMzdkMjNiMGMzMWE3MjdiM2Q3Yjk1NDI3NzY3ZDM=", "commit": {"author": {"name": "Ryan Leckey", "email": "ryan@launchbadge.com", "date": "2018-09-28T05:31:17Z"}, "committer": {"name": "Ryan Leckey", "email": "ryan@launchbadge.com", "date": "2018-09-28T05:31:17Z"}, "message": "Fix help message for edition config option", "tree": {"sha": "473b085706423c5edbbecf70b098704136df315a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/473b085706423c5edbbecf70b098704136df315a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7377c3555c37d23b0c31a727b3d7b95427767d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7377c3555c37d23b0c31a727b3d7b95427767d3", "html_url": "https://github.com/rust-lang/rust/commit/c7377c3555c37d23b0c31a727b3d7b95427767d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7377c3555c37d23b0c31a727b3d7b95427767d3/comments", "author": {"login": "mehcode", "id": 753919, "node_id": "MDQ6VXNlcjc1MzkxOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/753919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mehcode", "html_url": "https://github.com/mehcode", "followers_url": "https://api.github.com/users/mehcode/followers", "following_url": "https://api.github.com/users/mehcode/following{/other_user}", "gists_url": "https://api.github.com/users/mehcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/mehcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mehcode/subscriptions", "organizations_url": "https://api.github.com/users/mehcode/orgs", "repos_url": "https://api.github.com/users/mehcode/repos", "events_url": "https://api.github.com/users/mehcode/events{/privacy}", "received_events_url": "https://api.github.com/users/mehcode/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mehcode", "id": 753919, "node_id": "MDQ6VXNlcjc1MzkxOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/753919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mehcode", "html_url": "https://github.com/mehcode", "followers_url": "https://api.github.com/users/mehcode/followers", "following_url": "https://api.github.com/users/mehcode/following{/other_user}", "gists_url": "https://api.github.com/users/mehcode/gists{/gist_id}", "starred_url": "https://api.github.com/users/mehcode/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mehcode/subscriptions", "organizations_url": "https://api.github.com/users/mehcode/orgs", "repos_url": "https://api.github.com/users/mehcode/repos", "events_url": "https://api.github.com/users/mehcode/events{/privacy}", "received_events_url": "https://api.github.com/users/mehcode/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86fff9eafae995bd226260f7eb9f0114b7836bc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/86fff9eafae995bd226260f7eb9f0114b7836bc4", "html_url": "https://github.com/rust-lang/rust/commit/86fff9eafae995bd226260f7eb9f0114b7836bc4"}], "stats": {"total": 38, "additions": 26, "deletions": 12}, "files": [{"sha": "34b6ea0dde6584a1976746bc6bc48cb9bf48a63b", "filename": "src/config/options.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c7377c3555c37d23b0c31a727b3d7b95427767d3/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7377c3555c37d23b0c31a727b3d7b95427767d3/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=c7377c3555c37d23b0c31a727b3d7b95427767d3", "patch": "@@ -17,17 +17,21 @@ use isatty::stdout_isatty;\n use std::collections::HashSet;\n use std::path::{Path, PathBuf};\n \n-/// Macro for deriving implementations of Serialize/Deserialize for enums\n+/// Macro that will stringify the enum variants or a provided textual repr\n #[macro_export]\n-macro_rules! impl_enum_serialize_and_deserialize {\n-    (@stringify $variant:ident) => (\n+macro_rules! configuration_option_enum_stringify {\n+    ($variant:ident) => {\n         stringify!($variant)\n-    );\n+    };\n \n-    (@stringify $_variant:ident: $value:expr) => (\n+    ($_variant:ident: $value:expr) => {\n         stringify!($value)\n-    );\n+    };\n+}\n \n+/// Macro for deriving implementations of Serialize/Deserialize for enums\n+#[macro_export]\n+macro_rules! impl_enum_serialize_and_deserialize {\n     ( $e:ident, $( $variant:ident $(: $value:expr)* ),* ) => {\n         impl ::serde::ser::Serialize for $e {\n             fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n@@ -40,7 +44,7 @@ macro_rules! impl_enum_serialize_and_deserialize {\n                 match *self {\n                     $(\n                         $e::$variant => serializer.serialize_str(\n-                            impl_enum_serialize_and_deserialize!(@stringify $variant $(: $value)*)\n+                            configuration_option_enum_stringify!($variant $(: $value)*)\n                         ),\n                     )*\n                     _ => {\n@@ -69,13 +73,13 @@ macro_rules! impl_enum_serialize_and_deserialize {\n                 }\n                 let s = d.deserialize_string(StringOnly::<D>(PhantomData))?;\n                 $(\n-                    if impl_enum_serialize_and_deserialize!(@stringify $variant $(: $value)*)\n+                    if configuration_option_enum_stringify!($variant $(: $value)*)\n                         .eq_ignore_ascii_case(&s) {\n                       return Ok($e::$variant);\n                     }\n                 )*\n                 static ALLOWED: &'static[&str] = &[\n-                    $(impl_enum_serialize_and_deserialize!(@stringify $variant $(: $value)*),)*];\n+                    $(configuration_option_enum_stringify!($variant $(: $value)*),)*];\n                 Err(D::Error::unknown_variant(&s, ALLOWED))\n             }\n         }\n@@ -85,7 +89,7 @@ macro_rules! impl_enum_serialize_and_deserialize {\n \n             fn from_str(s: &str) -> Result<Self, Self::Err> {\n                 $(\n-                    if impl_enum_serialize_and_deserialize!(@stringify $variant $(: $value)*)\n+                    if configuration_option_enum_stringify!($variant $(: $value)*)\n                         .eq_ignore_ascii_case(s) {\n                         return Ok($e::$variant);\n                     }\n@@ -99,7 +103,7 @@ macro_rules! impl_enum_serialize_and_deserialize {\n                 let mut variants = Vec::new();\n                 $(\n                     variants.push(\n-                        impl_enum_serialize_and_deserialize!(@stringify $variant $(: $value)*)\n+                        configuration_option_enum_stringify!($variant $(: $value)*)\n                     );\n                 )*\n                 format!(\"[{}]\", variants.join(\"|\"))\n@@ -110,11 +114,21 @@ macro_rules! impl_enum_serialize_and_deserialize {\n \n macro_rules! configuration_option_enum {\n     ($e:ident: $( $name:ident $(: $value:expr)* ),+ $(,)*) => (\n-        #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+        #[derive(Copy, Clone, Eq, PartialEq)]\n         pub enum $e {\n             $( $name ),+\n         }\n \n+        impl ::std::fmt::Debug for $e {\n+            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+                f.write_str(match self {\n+                    $(\n+                        $e::$name => configuration_option_enum_stringify!($name $(: $value)*),\n+                    )+\n+                })\n+            }\n+        }\n+\n         impl_enum_serialize_and_deserialize!($e, $( $name $(: $value)* ),+);\n     );\n }"}]}