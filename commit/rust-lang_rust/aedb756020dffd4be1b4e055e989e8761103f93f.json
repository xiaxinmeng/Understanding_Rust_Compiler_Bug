{"sha": "aedb756020dffd4be1b4e055e989e8761103f93f", "node_id": "C_kwDOAAsO6NoAKGFlZGI3NTYwMjBkZmZkNGJlMWI0ZTA1NWU5ODllODc2MTEwM2Y5M2Y", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-12-18T17:40:36Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2023-01-14T21:28:22Z"}, "message": "Leak amplification for peek_mut() to ensure BinaryHeap's invariant is always met", "tree": {"sha": "fd8ac6fd1748353539406b9625063a0ef92c9e96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd8ac6fd1748353539406b9625063a0ef92c9e96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aedb756020dffd4be1b4e055e989e8761103f93f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmPDHnYACgkQ+boUO5X/\nbYIHXQ/+LlsDc+atWDmtLEJHK5tYdo4TP46sz+IGtf7cJLQ4XNDXIuS8U0pVnufJ\n0ZhzGwSb5joB364rbvBXeiak5YohGj4qLlr13oPzy8iMVnSroYS+lEGgm9N1+JUQ\nlG5i/SEAOjZY7LWCUMhEKxTazz5/gdkNMDo2I8J5EgN1sAvDadhjgKuDv6TnAzwD\n4/314OyVJWVHunClfE1FcOleNrBHv7Ab/0f5vP63qPvtxzvcgpMBNOSSxDUmIOCN\ncQXUkzYrghMhxqAHp6QgrKWN7wL7CyNy0T2CEhA27igJz+aGqFalz7SFELFaI5Bs\nFQp0lv1Vn9bFY1AcywKvj12Zgc3OZAFhR282UEUNOarkeJi0izbdKZNIlqgHZ4RE\nK5iLhVrXUYpXr45btx5xu0rTSqKGPvR2MhezDdV22HNaMDvILT02zDIxiuUpwnda\nwfBCz4xx162lKkfbh7L/wXd7EkY85oJ+DGZIi+nAaC1IZ1Gn/y8GTssW30plehgD\n+IMNCYj3OabqL+EFiLpflsdcihOaLgmWKFVTpO8X9y/k2sTp1gHw+ddoxZxdPIJj\nezcwhDsS7+2ZlG3lL1j8ANdyROdo7LVYcqqST4jZ9rIuJotmHvJEag5Dt8FqM4Hd\nodD7FK9Qvde8hOhsZ155ipTMRa94BEWAl6b212IDAg61srvrFAA=\n=JHY0\n-----END PGP SIGNATURE-----", "payload": "tree fd8ac6fd1748353539406b9625063a0ef92c9e96\nparent 4fe167f83a90f3f193c3cb5dafb4c2862d0671e9\nauthor David Tolnay <dtolnay@gmail.com> 1671385236 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1673731702 -0800\n\nLeak amplification for peek_mut() to ensure BinaryHeap's invariant is always met\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aedb756020dffd4be1b4e055e989e8761103f93f", "html_url": "https://github.com/rust-lang/rust/commit/aedb756020dffd4be1b4e055e989e8761103f93f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aedb756020dffd4be1b4e055e989e8761103f93f/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fe167f83a90f3f193c3cb5dafb4c2862d0671e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe167f83a90f3f193c3cb5dafb4c2862d0671e9", "html_url": "https://github.com/rust-lang/rust/commit/4fe167f83a90f3f193c3cb5dafb4c2862d0671e9"}], "stats": {"total": 55, "additions": 46, "deletions": 9}, "files": [{"sha": "e3fef96613bd9375c89efc5bc318b4075f0b12cb", "filename": "library/alloc/src/collections/binary_heap/mod.rs", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/aedb756020dffd4be1b4e055e989e8761103f93f/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aedb756020dffd4be1b4e055e989e8761103f93f/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Fmod.rs?ref=aedb756020dffd4be1b4e055e989e8761103f93f", "patch": "@@ -146,6 +146,7 @@\n use core::fmt;\n use core::iter::{FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen};\n use core::mem::{self, swap, ManuallyDrop};\n+use core::num::NonZeroUsize;\n use core::ops::{Deref, DerefMut};\n use core::ptr;\n \n@@ -279,7 +280,9 @@ pub struct BinaryHeap<T> {\n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n pub struct PeekMut<'a, T: 'a + Ord> {\n     heap: &'a mut BinaryHeap<T>,\n-    sift: bool,\n+    // If a set_len + sift_down are required, this is Some. If a &mut T has not\n+    // yet been exposed to peek_mut()'s caller, it's None.\n+    original_len: Option<NonZeroUsize>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -292,7 +295,14 @@ impl<T: Ord + fmt::Debug> fmt::Debug for PeekMut<'_, T> {\n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n impl<T: Ord> Drop for PeekMut<'_, T> {\n     fn drop(&mut self) {\n-        if self.sift {\n+        if let Some(original_len) = self.original_len {\n+            // SAFETY: That's how many elements were in the Vec at the time of\n+            // the PeekMut::deref_mut call, and therefore also at the time of\n+            // the BinaryHeap::peek_mut call. Since the PeekMut did not end up\n+            // getting leaked, we are now undoing the leak amplification that\n+            // the DerefMut prepared for.\n+            unsafe { self.heap.data.set_len(original_len.get()) };\n+\n             // SAFETY: PeekMut is only instantiated for non-empty heaps.\n             unsafe { self.heap.sift_down(0) };\n         }\n@@ -313,7 +323,26 @@ impl<T: Ord> Deref for PeekMut<'_, T> {\n impl<T: Ord> DerefMut for PeekMut<'_, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         debug_assert!(!self.heap.is_empty());\n-        self.sift = true;\n+\n+        let len = self.heap.len();\n+        if len > 1 {\n+            // Here we preemptively leak all the rest of the underlying vector\n+            // after the currently max element. If the caller mutates the &mut T\n+            // we're about to give them, and then leaks the PeekMut, all these\n+            // elements will remain leaked. If they don't leak the PeekMut, then\n+            // either Drop or PeekMut::pop will un-leak the vector elements.\n+            //\n+            // This is technique is described throughout several other places in\n+            // the standard library as \"leak amplification\".\n+            unsafe {\n+                // SAFETY: len > 1 so len != 0.\n+                self.original_len = Some(NonZeroUsize::new_unchecked(len));\n+                // SAFETY: len > 1 so all this does for now is leak elements,\n+                // which is safe.\n+                self.heap.data.set_len(1);\n+            }\n+        }\n+\n         // SAFE: PeekMut is only instantiated for non-empty heaps\n         unsafe { self.heap.data.get_unchecked_mut(0) }\n     }\n@@ -323,9 +352,16 @@ impl<'a, T: Ord> PeekMut<'a, T> {\n     /// Removes the peeked value from the heap and returns it.\n     #[stable(feature = \"binary_heap_peek_mut_pop\", since = \"1.18.0\")]\n     pub fn pop(mut this: PeekMut<'a, T>) -> T {\n-        let value = this.heap.pop().unwrap();\n-        this.sift = false;\n-        value\n+        if let Some(original_len) = this.original_len.take() {\n+            // SAFETY: This is how many elements were in the Vec at the time of\n+            // the BinaryHeap::peek_mut call.\n+            unsafe { this.heap.data.set_len(original_len.get()) };\n+\n+            // Unlike in Drop, here we don't also need to do a sift_down even if\n+            // the caller could've mutated the element. It is removed from the\n+            // heap on the next line and pop() is not sensitive to its value.\n+        }\n+        this.heap.pop().unwrap()\n     }\n }\n \n@@ -398,8 +434,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// Returns a mutable reference to the greatest item in the binary heap, or\n     /// `None` if it is empty.\n     ///\n-    /// Note: If the `PeekMut` value is leaked, the heap may be in an\n-    /// inconsistent state.\n+    /// Note: If the `PeekMut` value is leaked, some heap elements might get\n+    /// leaked along with it, but the remaining elements will remain a valid\n+    /// heap.\n     ///\n     /// # Examples\n     ///\n@@ -426,7 +463,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// otherwise it's *O*(1).\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n-        if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: false }) }\n+        if self.is_empty() { None } else { Some(PeekMut { heap: self, original_len: None }) }\n     }\n \n     /// Removes the greatest item from the binary heap and returns it, or `None` if it"}]}