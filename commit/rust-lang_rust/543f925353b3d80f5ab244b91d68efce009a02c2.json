{"sha": "543f925353b3d80f5ab244b91d68efce009a02c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0M2Y5MjUzNTNiM2Q4MGY1YWIyNDRiOTFkNjhlZmNlMDA5YTAyYzI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-24T18:57:02Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-24T18:57:02Z"}, "message": "Highlight loop break points", "tree": {"sha": "437af72a05bdb6e99956e46f89892f65c44954b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/437af72a05bdb6e99956e46f89892f65c44954b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/543f925353b3d80f5ab244b91d68efce009a02c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/543f925353b3d80f5ab244b91d68efce009a02c2", "html_url": "https://github.com/rust-lang/rust/commit/543f925353b3d80f5ab244b91d68efce009a02c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/543f925353b3d80f5ab244b91d68efce009a02c2/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d77655e5c3c6c09bc968715b2b7a3db6224f7883", "url": "https://api.github.com/repos/rust-lang/rust/commits/d77655e5c3c6c09bc968715b2b7a3db6224f7883", "html_url": "https://github.com/rust-lang/rust/commit/d77655e5c3c6c09bc968715b2b7a3db6224f7883"}], "stats": {"total": 254, "additions": 243, "deletions": 11}, "files": [{"sha": "bc5e5eaebc541af6c52976e3ecc4308180d1a40b", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 243, "deletions": 11, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/543f925353b3d80f5ab244b91d68efce009a02c2/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543f925353b3d80f5ab244b91d68efce009a02c2/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=543f925353b3d80f5ab244b91d68efce009a02c2", "patch": "@@ -24,6 +24,7 @@ pub struct HighlightedRange {\n // - if on an identifier, highlights all references to that identifier in the current file\n // - if on an `async` or `await token, highlights all yield points for that async context\n // - if on a `return` token, `?` character or `->` return type arrow, highlights all exit points for that context\n+// - if on a `break`, `loop`, `while` or `for` token, highlights all break points for that loop or block context\n pub(crate) fn highlight_related(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n@@ -33,13 +34,21 @@ pub(crate) fn highlight_related(\n \n     let token = pick_best_token(syntax.token_at_offset(position.offset), |kind| match kind {\n         T![?] => 2, // prefer `?` when the cursor is sandwiched like `await$0?`\n-        T![await] | T![async] | T![return] | T![->] => 1,\n+        T![await]\n+        | T![async]\n+        | T![return]\n+        | T![break]\n+        | T![loop]\n+        | T![for]\n+        | T![while]\n+        | T![->] => 1,\n         _ => 0,\n     })?;\n \n     match token.kind() {\n         T![return] | T![?] | T![->] => highlight_exit_points(sema, token),\n         T![await] | T![async] => highlight_yield_points(token),\n+        T![break] | T![loop] | T![for] | T![while] => highlight_break_points(token),\n         _ => highlight_references(sema, &syntax, position),\n     }\n }\n@@ -112,8 +121,13 @@ fn highlight_exit_points(\n \n         if let Some(tail) = tail {\n             for_each_inner_tail(&tail, &mut |tail| {\n-                highlights\n-                    .push(HighlightedRange { access: None, range: tail.syntax().text_range() })\n+                let range = match tail {\n+                    ast::Expr::BreakExpr(b) => b\n+                        .break_token()\n+                        .map_or_else(|| tail.syntax().text_range(), |tok| tok.text_range()),\n+                    _ => tail.syntax().text_range(),\n+                };\n+                highlights.push(HighlightedRange { access: None, range })\n             });\n         }\n         Some(highlights)\n@@ -135,6 +149,65 @@ fn highlight_exit_points(\n     None\n }\n \n+fn highlight_break_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n+    fn hl(\n+        token: Option<SyntaxToken>,\n+        label: Option<ast::Label>,\n+        body: Option<ast::BlockExpr>,\n+    ) -> Option<Vec<HighlightedRange>> {\n+        let mut highlights = Vec::new();\n+        let range = cover_range(\n+            token.map(|tok| tok.text_range()),\n+            label.as_ref().map(|it| it.syntax().text_range()),\n+        );\n+        highlights.extend(range.map(|range| HighlightedRange { access: None, range }));\n+        for_each_break(label, body, &mut |break_| {\n+            let range = cover_range(\n+                break_.break_token().map(|it| it.text_range()),\n+                break_.lifetime().map(|it| it.syntax().text_range()),\n+            );\n+            highlights.extend(range.map(|range| HighlightedRange { access: None, range }));\n+        });\n+        Some(highlights)\n+    }\n+    let parent = token.parent()?;\n+    let lbl = match_ast! {\n+        match parent {\n+            ast::BreakExpr(b) => b.lifetime(),\n+            ast::LoopExpr(l) => l.label().and_then(|it| it.lifetime()),\n+            ast::ForExpr(f) => f.label().and_then(|it| it.lifetime()),\n+            ast::WhileExpr(w) => w.label().and_then(|it| it.lifetime()),\n+            ast::EffectExpr(b) => Some(b.label().and_then(|it| it.lifetime())?),\n+            _ => return None,\n+        }\n+    };\n+    let lbl = lbl.as_ref();\n+    let label_matches = |def_lbl: Option<ast::Label>| match lbl {\n+        Some(lbl) => {\n+            Some(lbl.text()) == def_lbl.and_then(|it| it.lifetime()).as_ref().map(|it| it.text())\n+        }\n+        None => true,\n+    };\n+    for anc in token.ancestors().flat_map(ast::Expr::cast) {\n+        return match anc {\n+            ast::Expr::LoopExpr(l) if label_matches(l.label()) => {\n+                hl(l.loop_token(), l.label(), l.loop_body())\n+            }\n+            ast::Expr::ForExpr(f) if label_matches(f.label()) => {\n+                hl(f.for_token(), f.label(), f.loop_body())\n+            }\n+            ast::Expr::WhileExpr(w) if label_matches(w.label()) => {\n+                hl(w.while_token(), w.label(), w.loop_body())\n+            }\n+            ast::Expr::EffectExpr(e) if e.label().is_some() && label_matches(e.label()) => {\n+                hl(None, e.label(), e.block_expr())\n+            }\n+            _ => continue,\n+        };\n+    }\n+    None\n+}\n+\n fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n     fn hl(\n         async_token: Option<SyntaxToken>,\n@@ -231,7 +304,9 @@ fn for_each_inner_tail(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n         ast::Expr::IfExpr(if_) => {\n             if_.blocks().for_each(|block| for_each_inner_tail(&ast::Expr::BlockExpr(block), cb))\n         }\n-        ast::Expr::LoopExpr(l) => for_each_break(l, cb),\n+        ast::Expr::LoopExpr(l) => {\n+            for_each_break(l.label(), l.loop_body(), &mut |b| cb(&ast::Expr::BreakExpr(b)))\n+        }\n         ast::Expr::MatchExpr(m) => {\n             if let Some(arms) = m.match_arm_list() {\n                 arms.arms().filter_map(|arm| arm.expr()).for_each(|e| for_each_inner_tail(&e, cb));\n@@ -267,10 +342,14 @@ fn for_each_inner_tail(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n     }\n }\n \n-fn for_each_break(l: &ast::LoopExpr, cb: &mut dyn FnMut(&ast::Expr)) {\n-    let label = l.label().and_then(|lbl| lbl.lifetime());\n+fn for_each_break(\n+    label: Option<ast::Label>,\n+    body: Option<ast::BlockExpr>,\n+    cb: &mut dyn FnMut(ast::BreakExpr),\n+) {\n+    let label = label.and_then(|lbl| lbl.lifetime());\n     let mut depth = 0;\n-    if let Some(b) = l.loop_body() {\n+    if let Some(b) = body {\n         let preorder = &mut b.syntax().preorder();\n         let ev_as_expr = |ev| match ev {\n             WalkEvent::Enter(it) => Some(WalkEvent::Enter(ast::Expr::cast(it)?)),\n@@ -281,13 +360,13 @@ fn for_each_break(l: &ast::LoopExpr, cb: &mut dyn FnMut(&ast::Expr)) {\n         };\n         while let Some(node) = preorder.find_map(ev_as_expr) {\n             match node {\n-                WalkEvent::Enter(expr) => match &expr {\n+                WalkEvent::Enter(expr) => match expr {\n                     ast::Expr::LoopExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::ForExpr(_) => {\n                         depth += 1\n                     }\n                     ast::Expr::EffectExpr(e) if e.label().is_some() => depth += 1,\n                     ast::Expr::BreakExpr(b) if depth == 0 || eq_label(b.lifetime()) => {\n-                        cb(&expr);\n+                        cb(b);\n                     }\n                     _ => (),\n                 },\n@@ -303,6 +382,15 @@ fn for_each_break(l: &ast::LoopExpr, cb: &mut dyn FnMut(&ast::Expr)) {\n     }\n }\n \n+fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange> {\n+    match (r0, r1) {\n+        (Some(r0), Some(r1)) => Some(r0.cover(r1)),\n+        (Some(range), None) => Some(range),\n+        (None, Some(range)) => Some(range),\n+        (None, None) => None,\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::fixture;\n@@ -564,12 +652,12 @@ fn foo() ->$0 u32 {\n               // ^^^\n             7 => loop {\n                 break 5;\n-             // ^^^^^^^\n+             // ^^^^^\n             }\n             8 => 'a: loop {\n                 'b: loop {\n                     break 'a 5;\n-                 // ^^^^^^^^^^\n+                 // ^^^^^\n                     break 'b 5;\n                     break 5;\n                 };\n@@ -580,6 +668,150 @@ fn foo() ->$0 u32 {\n         }\n     }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_loop() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: loop {\n+ // ^^^^^^^^^^^^\n+         break;\n+      // ^^^^^\n+         'inner: loop {\n+            break;\n+            'innermost: loop {\n+                break 'outer;\n+             // ^^^^^^^^^^^^\n+                break 'inner;\n+            }\n+            break$0 'outer;\n+         // ^^^^^^^^^^^^\n+            break;\n+        }\n+        break;\n+     // ^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_for() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: for _ in () {\n+ // ^^^^^^^^^^^\n+         break;\n+      // ^^^^^\n+         'inner: for _ in () {\n+            break;\n+            'innermost: for _ in () {\n+                break 'outer;\n+             // ^^^^^^^^^^^^\n+                break 'inner;\n+            }\n+            break$0 'outer;\n+         // ^^^^^^^^^^^^\n+            break;\n+        }\n+        break;\n+     // ^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_while() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: while true {\n+ // ^^^^^^^^^^^^^\n+         break;\n+      // ^^^^^\n+         'inner: while true {\n+            break;\n+            'innermost: while true {\n+                break 'outer;\n+             // ^^^^^^^^^^^^\n+                break 'inner;\n+            }\n+            break$0 'outer;\n+         // ^^^^^^^^^^^^\n+            break;\n+        }\n+        break;\n+     // ^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_labeled_block() {\n+        check(\n+            r#\"\n+fn foo() {\n+    'outer: {\n+ // ^^^^^^^\n+         break;\n+      // ^^^^^\n+         'inner: {\n+            break;\n+            'innermost: {\n+                break 'outer;\n+             // ^^^^^^^^^^^^\n+                break 'inner;\n+            }\n+            break$0 'outer;\n+         // ^^^^^^^^^^^^\n+            break;\n+        }\n+        break;\n+     // ^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_unlabeled_loop() {\n+        check(\n+            r#\"\n+fn foo() {\n+    loop {\n+ // ^^^^\n+        break$0;\n+     // ^^^^^\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_break_unlabeled_block_in_loop() {\n+        check(\n+            r#\"\n+fn foo() {\n+    loop {\n+ // ^^^^\n+        {\n+            break$0;\n+         // ^^^^^\n+        }\n+    }\n+}\n \"#,\n         );\n     }"}]}