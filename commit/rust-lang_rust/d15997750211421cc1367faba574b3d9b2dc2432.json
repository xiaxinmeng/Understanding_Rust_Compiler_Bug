{"sha": "d15997750211421cc1367faba574b3d9b2dc2432", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxNTk5Nzc1MDIxMTQyMWNjMTM2N2ZhYmE1NzRiM2Q5YjJkYzI0MzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-07T14:33:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-12T21:58:22Z"}, "message": "Generalize the outlives rule for projections to handle the new cases;\nalso, generalize VerifyBounds to include OR conditions.", "tree": {"sha": "66dfa8bdd07302e252202c12d9b9bc2686c51137", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66dfa8bdd07302e252202c12d9b9bc2686c51137"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d15997750211421cc1367faba574b3d9b2dc2432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d15997750211421cc1367faba574b3d9b2dc2432", "html_url": "https://github.com/rust-lang/rust/commit/d15997750211421cc1367faba574b3d9b2dc2432", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d15997750211421cc1367faba574b3d9b2dc2432/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75ee8f156204cef3140d6e153d36f9970ca2bfa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ee8f156204cef3140d6e153d36f9970ca2bfa1", "html_url": "https://github.com/rust-lang/rust/commit/75ee8f156204cef3140d6e153d36f9970ca2bfa1"}], "stats": {"total": 642, "additions": 541, "deletions": 101}, "files": [{"sha": "61c166e11d28023d115bce1ce913e8ea723f7508", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d15997750211421cc1367faba574b3d9b2dc2432/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15997750211421cc1367faba574b3d9b2dc2432/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=d15997750211421cc1367faba574b3d9b2dc2432", "patch": "@@ -17,7 +17,7 @@ pub use self::TypeOrigin::*;\n pub use self::ValuePairs::*;\n pub use middle::ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n-pub use self::region_inference::GenericKind;\n+pub use self::region_inference::{GenericKind, VerifyBound};\n \n use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n@@ -1416,13 +1416,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n                                 a: ty::Region,\n-                                bs: Vec<ty::Region>) {\n+                                bound: VerifyBound) {\n         debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n                kind,\n                a,\n-               bs);\n+               bound);\n \n-        self.region_vars.verify_generic_bound(origin, kind, a, bs);\n+        self.region_vars.verify_generic_bound(origin, kind, a, bound);\n     }\n \n     pub fn can_equate<'b,T>(&'b self, a: &T, b: &T) -> UnitResult<'tcx>"}, {"sha": "e8f8dbfbb0e638cf5123abac14d1abd831354599", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 153, "deletions": 40, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/d15997750211421cc1367faba574b3d9b2dc2432/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15997750211421cc1367faba574b3d9b2dc2432/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=d15997750211421cc1367faba574b3d9b2dc2432", "patch": "@@ -64,15 +64,41 @@ pub enum Verify<'tcx> {\n     // outlive `RS`. Therefore verify that `R <= RS[i]` for some\n     // `i`. Inference variables may be involved (but this verification\n     // step doesn't influence inference).\n-    VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, Vec<Region>),\n+    VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, VerifyBound),\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n     Projection(ty::ProjectionTy<'tcx>),\n }\n \n+// When we introduce a verification step, we wish to test that a\n+// particular region (let's call it `'min`) meets some bound.\n+// The bound is described the by the following grammar:\n+#[derive(Debug)]\n+pub enum VerifyBound {\n+    // B = exists {R} --> some 'r in {R} must outlive 'min\n+    //\n+    // Put another way, the subject value is known to outlive all\n+    // regions in {R}, so if any of those outlives 'min, then the\n+    // bound is met.\n+    AnyRegion(Vec<Region>),\n+\n+    // B = forall {R} --> all 'r in {R} must outlive 'min\n+    //\n+    // Put another way, the subject value is known to outlive some\n+    // region in {R}, so if all of those outlives 'min, then the bound\n+    // is met.\n+    AllRegions(Vec<Region>),\n+\n+    // B = exists {B} --> 'min must meet some bound b in {B}\n+    AnyBound(Vec<VerifyBound>),\n+\n+    // B = forall {B} --> 'min must meet all bounds b in {B}\n+    AllBounds(Vec<VerifyBound>),\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct TwoRegions {\n     a: Region,\n@@ -102,12 +128,11 @@ pub enum RegionResolutionError<'tcx> {\n     /// `o` requires that `a <= b`, but this does not hold\n     ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n \n-    /// `GenericBoundFailure(p, s, a, bs)\n+    /// `GenericBoundFailure(p, s, a)\n     ///\n     /// The parameter/associated-type `p` must be known to outlive the lifetime\n-    /// `a`, but it is only known to outlive `bs` (and none of the\n-    /// regions in `bs` outlive `a`).\n-    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region, Vec<Region>),\n+    /// `a` (but none of the known bounds are sufficient).\n+    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region),\n \n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n@@ -408,6 +433,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         debug!(\"RegionVarBindings: add_verify({:?})\",\n                verify);\n \n+        // skip no-op cases known to be satisfied\n+        match verify {\n+            VerifyGenericBound(_, _, _, VerifyBound::AllBounds(ref bs)) if bs.len() == 0 => {\n+                return;\n+            }\n+            _ => { }\n+        }\n+\n         let mut verifys = self.verifys.borrow_mut();\n         let index = verifys.len();\n         verifys.push(verify);\n@@ -497,8 +530,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n                                 sub: Region,\n-                                sups: Vec<Region>) {\n-        self.add_verify(VerifyGenericBound(kind, origin, sub, sups));\n+                                bound: VerifyBound) {\n+        self.add_verify(VerifyGenericBound(kind, origin, sub, bound));\n     }\n \n     pub fn lub_regions(&self,\n@@ -663,12 +696,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                     &mut result_set, r,\n                                     a, b);\n                             }\n-                            VerifyGenericBound(_, _, a, ref bs) => {\n-                                for &b in bs {\n-                                    consider_adding_bidirectional_edges(\n-                                        &mut result_set, r,\n-                                        a, b);\n-                                }\n+                            VerifyGenericBound(_, _, a, ref bound) => {\n+                                bound.for_each_region(&mut |b| {\n+                                    consider_adding_bidirectional_edges(&mut result_set, r,\n+                                                                        a, b)\n+                                });\n                             }\n                         }\n                     }\n@@ -1258,26 +1290,22 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         continue;\n                     }\n \n-                    debug!(\"ConcreteFailure: !(sub <= sup): sub={:?}, sup={:?}\",\n-                           sub,\n-                           sup);\n+                    debug!(\"region inference error at {:?}: {:?} <= {:?} is not true\",\n+                           origin, sub, sup);\n+\n                     errors.push(ConcreteFailure((*origin).clone(), sub, sup));\n                 }\n \n-                VerifyGenericBound(ref kind, ref origin, sub, ref sups) => {\n+                VerifyGenericBound(ref kind, ref origin, sub, ref bound) => {\n                     let sub = normalize(values, sub);\n-                    if sups.iter()\n-                           .map(|&sup| normalize(values, sup))\n-                           .any(|sup| free_regions.is_subregion_of(self.tcx, sub, sup))\n-                    {\n+                    if bound.is_met(self.tcx, free_regions, values, sub) {\n                         continue;\n                     }\n \n-                    let sups = sups.iter().map(|&sup| normalize(values, sup))\n-                                          .collect();\n-                    errors.push(\n-                        GenericBoundFailure(\n-                            (*origin).clone(), kind.clone(), sub, sups));\n+                    debug!(\"region inference error at {:?}: verifying {:?} <= {:?}\",\n+                           origin, sub, bound);\n+\n+                    errors.push(GenericBoundFailure((*origin).clone(), kind.clone(), sub));\n                 }\n             }\n         }\n@@ -1438,10 +1466,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 if !free_regions.is_subregion_of(self.tcx,\n                                                  lower_bound.region,\n                                                  upper_bound.region) {\n-                    debug!(\"pushing SubSupConflict sub: {:?} sup: {:?}\",\n-                           lower_bound.region, upper_bound.region);\n+                    let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n+                    debug!(\"region inference error at {:?} for {:?}: \\\n+                            SubSupConflict sub: {:?} sup: {:?}\",\n+                           origin, node_idx, lower_bound.region, upper_bound.region);\n                     errors.push(SubSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index as usize].clone(),\n+                        origin,\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n@@ -1484,16 +1514,20 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 match self.glb_concrete_regions(free_regions,\n                                                 upper_bound_1.region,\n                                                 upper_bound_2.region) {\n-                  Ok(_) => {}\n-                  Err(_) => {\n-                    errors.push(SupSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index as usize].clone(),\n-                        upper_bound_1.origin.clone(),\n-                        upper_bound_1.region,\n-                        upper_bound_2.origin.clone(),\n-                        upper_bound_2.region));\n-                    return;\n-                  }\n+                    Ok(_) => {}\n+                    Err(_) => {\n+                        let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n+                        debug!(\"region inference error at {:?} for {:?}: \\\n+                                SupSupConflict sub: {:?} sup: {:?}\",\n+                               origin, node_idx, upper_bound_1.region, upper_bound_2.region);\n+                        errors.push(SupSupConflict(\n+                            origin,\n+                            upper_bound_1.origin.clone(),\n+                            upper_bound_1.region,\n+                            upper_bound_2.origin.clone(),\n+                            upper_bound_2.region));\n+                        return;\n+                    }\n                 }\n             }\n         }\n@@ -1676,3 +1710,82 @@ impl<'tcx> GenericKind<'tcx> {\n         }\n     }\n }\n+\n+impl VerifyBound {\n+    fn for_each_region(&self, f: &mut FnMut(ty::Region)) {\n+        match self {\n+            &VerifyBound::AnyRegion(ref rs) |\n+            &VerifyBound::AllRegions(ref rs) =>\n+                for &r in rs { f(r); },\n+\n+            &VerifyBound::AnyBound(ref bs) |\n+            &VerifyBound::AllBounds(ref bs) =>\n+                for b in bs { b.for_each_region(f); },\n+        }\n+    }\n+\n+    pub fn must_hold(&self) -> bool {\n+        match self {\n+            &VerifyBound::AnyRegion(ref bs) => bs.contains(&ty::ReStatic),\n+            &VerifyBound::AllRegions(ref bs) => bs.is_empty(),\n+            &VerifyBound::AnyBound(ref bs) => bs.iter().any(|b| b.must_hold()),\n+            &VerifyBound::AllBounds(ref bs) => bs.iter().all(|b| b.must_hold()),\n+        }\n+    }\n+\n+    pub fn cannot_hold(&self) -> bool {\n+        match self {\n+            &VerifyBound::AnyRegion(ref bs) => bs.is_empty(),\n+            &VerifyBound::AllRegions(ref bs) => bs.contains(&ty::ReEmpty),\n+            &VerifyBound::AnyBound(ref bs) => bs.iter().all(|b| b.cannot_hold()),\n+            &VerifyBound::AllBounds(ref bs) => bs.iter().any(|b| b.cannot_hold()),\n+        }\n+    }\n+\n+    pub fn or(self, vb: VerifyBound) -> VerifyBound {\n+        if self.must_hold() || vb.cannot_hold() {\n+            self\n+        } else if self.cannot_hold() || vb.must_hold() {\n+            vb\n+        } else {\n+            VerifyBound::AnyBound(vec![self, vb])\n+        }\n+    }\n+\n+    pub fn and(self, vb: VerifyBound) -> VerifyBound {\n+        if self.must_hold() && vb.must_hold() {\n+            self\n+        } else if self.cannot_hold() && vb.cannot_hold() {\n+            self\n+        } else {\n+            VerifyBound::AllBounds(vec![self, vb])\n+        }\n+    }\n+\n+    fn is_met<'tcx>(&self,\n+                    tcx: &ty::ctxt<'tcx>,\n+                    free_regions: &FreeRegionMap,\n+                    var_values: &Vec<VarValue>,\n+                    min: ty::Region)\n+                    -> bool {\n+        match self {\n+            &VerifyBound::AnyRegion(ref rs) =>\n+                rs.iter()\n+                  .map(|&r| normalize(var_values, r))\n+                  .any(|r| free_regions.is_subregion_of(tcx, min, r)),\n+\n+            &VerifyBound::AllRegions(ref rs) =>\n+                rs.iter()\n+                  .map(|&r| normalize(var_values, r))\n+                  .all(|r| free_regions.is_subregion_of(tcx, min, r)),\n+\n+            &VerifyBound::AnyBound(ref bs) =>\n+                bs.iter()\n+                  .any(|b| b.is_met(tcx, free_regions, var_values, min)),\n+\n+            &VerifyBound::AllBounds(ref bs) =>\n+                bs.iter()\n+                  .all(|b| b.is_met(tcx, free_regions, var_values, min)),\n+        }\n+    }\n+}"}, {"sha": "1fed29ec68e718298f8ca088bc8a8c2fb589227d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 384, "deletions": 57, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/d15997750211421cc1367faba574b3d9b2dc2432/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15997750211421cc1367faba574b3d9b2dc2432/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d15997750211421cc1367faba574b3d9b2dc2432", "patch": "@@ -568,7 +568,29 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     type_must_outlive(rcx, infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                       expr_ty, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n \n-    let has_method_map = rcx.fcx.infcx().is_method_call(expr.id);\n+    let method_call = MethodCall::expr(expr.id);\n+    let opt_method_callee = rcx.fcx.inh.tables.borrow().method_map.get(&method_call).cloned();\n+    let has_method_map = opt_method_callee.is_some();\n+\n+    // the region corresponding to this expression\n+    let expr_region = ty::ReScope(CodeExtent::from_node_id(expr.id));\n+\n+    // If we are calling a method (either explicitly or via an\n+    // overloaded operator), check that all of the types provided as\n+    // arguments for its type parameters are well-formed, and all the regions\n+    // provided as arguments outlive the call.\n+    if let Some(callee) = opt_method_callee {\n+        let origin = match expr.node {\n+            ast::ExprMethodCall(..) =>\n+                infer::ParameterOrigin::MethodCall,\n+            ast::ExprUnary(op, _) if op == ast::UnDeref =>\n+                infer::ParameterOrigin::OverloadedDeref,\n+            _ =>\n+                infer::ParameterOrigin::OverloadedOperator\n+        };\n+\n+        substs_wf_in_scope(rcx, origin, &callee.substs, expr.span, expr_region);\n+    }\n \n     // Check any autoderefs or autorefs that appear.\n     let adjustment = rcx.fcx.inh.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n@@ -639,6 +661,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     }\n \n     match expr.node {\n+        ast::ExprPath(..) => {\n+            rcx.fcx.opt_node_ty_substs(expr.id, |item_substs| {\n+                let origin = infer::ParameterOrigin::Path;\n+                substs_wf_in_scope(rcx, origin, &item_substs.substs, expr.span, expr_region);\n+            });\n+        }\n+\n         ast::ExprCall(ref callee, ref args) => {\n             if has_method_map {\n                 constrain_call(rcx, expr, Some(&**callee),\n@@ -949,6 +978,9 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 debug!(\"constrain_autoderefs: #{} is overloaded, method={:?}\",\n                        i, method);\n \n+                let origin = infer::ParameterOrigin::OverloadedDeref;\n+                substs_wf_in_scope(rcx, origin, method.substs, deref_expr.span, r_deref_expr);\n+\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = method.ty.fn_sig();\n@@ -1250,6 +1282,9 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let mut borrow_cmt = borrow_cmt;\n     let mut borrow_kind = borrow_kind;\n \n+    let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n+    type_must_outlive(rcx, origin, borrow_cmt.ty, *borrow_region);\n+\n     loop {\n         debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n                borrow_region,\n@@ -1449,74 +1484,371 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     }\n }\n \n-/// Ensures that all borrowed data reachable via `ty` outlives `region`.\n-pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n-                               origin: infer::SubregionOrigin<'tcx>,\n-                               ty: Ty<'tcx>,\n-                               region: ty::Region)\n+/// Checks that the values provided for type/region arguments in a given\n+/// expression are well-formed and in-scope.\n+pub fn substs_wf_in_scope<'a,'tcx>(rcx: &mut Rcx<'a,'tcx>,\n+                                   origin: infer::ParameterOrigin,\n+                                   substs: &Substs<'tcx>,\n+                                   expr_span: Span,\n+                                   expr_region: ty::Region) {\n+    debug!(\"substs_wf_in_scope(substs={:?}, \\\n+            expr_region={:?}, \\\n+            origin={:?}, \\\n+            expr_span={:?})\",\n+           substs, expr_region, origin, expr_span);\n+\n+    let origin = infer::ParameterInScope(origin, expr_span);\n+\n+    for &region in substs.regions() {\n+        rcx.fcx.mk_subr(origin.clone(), expr_region, region);\n+    }\n+\n+    for &ty in &substs.types {\n+        let ty = rcx.resolve_type(ty);\n+        type_must_outlive(rcx, origin.clone(), ty, expr_region);\n+    }\n+}\n+\n+/// Ensures that type is well-formed in `region`, which implies (among\n+/// other things) that all borrowed data reachable via `ty` outlives\n+/// `region`.\n+pub fn type_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                   origin: infer::SubregionOrigin<'tcx>,\n+                                   ty: Ty<'tcx>,\n+                                   region: ty::Region)\n {\n+    let ty = rcx.resolve_type(ty);\n+\n     debug!(\"type_must_outlive(ty={:?}, region={:?})\",\n            ty,\n            region);\n \n-    let implications = implicator::implications(rcx.fcx.infcx(), rcx.body_id,\n-                                                ty, region, origin.span());\n-    for implication in implications {\n-        debug!(\"implication: {:?}\", implication);\n-        match implication {\n-            implicator::Implication::RegionSubRegion(None, r_a, r_b) => {\n-                rcx.fcx.mk_subr(origin.clone(), r_a, r_b);\n+    assert!(!ty.has_escaping_regions());\n+\n+    let components = outlives::components(rcx.infcx(), ty);\n+    components_must_outlive(rcx, origin, components, region);\n+}\n+\n+fn components_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                     origin: infer::SubregionOrigin<'tcx>,\n+                                     components: Vec<outlives::Component<'tcx>>,\n+                                     region: ty::Region)\n+{\n+    for component in components {\n+        let origin = origin.clone();\n+        match component {\n+            outlives::Component::Region(region1) => {\n+                rcx.fcx.mk_subr(origin, region, region1);\n             }\n-            implicator::Implication::RegionSubRegion(Some(ty), r_a, r_b) => {\n-                let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n-                rcx.fcx.mk_subr(o1, r_a, r_b);\n+            outlives::Component::Param(param_ty) => {\n+                param_ty_must_outlive(rcx, origin, region, param_ty);\n             }\n-            implicator::Implication::RegionSubGeneric(None, r_a, ref generic_b) => {\n-                generic_must_outlive(rcx, origin.clone(), r_a, generic_b);\n+            outlives::Component::Projection(projection_ty) => {\n+                projection_must_outlive(rcx, origin, region, projection_ty);\n             }\n-            implicator::Implication::RegionSubGeneric(Some(ty), r_a, ref generic_b) => {\n-                let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n-                generic_must_outlive(rcx, o1, r_a, generic_b);\n+            outlives::Component::EscapingProjection(subcomponents) => {\n+                components_must_outlive(rcx, origin, subcomponents, region);\n             }\n-            implicator::Implication::Predicate(def_id, predicate) => {\n-                let cause = traits::ObligationCause::new(origin.span(),\n-                                                         rcx.body_id,\n-                                                         traits::ItemObligation(def_id));\n-                let obligation = traits::Obligation::new(cause, predicate);\n-                rcx.fcx.register_predicate(obligation);\n+            outlives::Component::UnresolvedInferenceVariable(_) => {\n+                // ignore this, we presume it will yield an error\n+                // later, since if a type variable is not resolved by\n+                // this point it never will be\n+            }\n+            outlives::Component::RFC1214(subcomponents) => {\n+                let suborigin = infer::RFC1214Subregion(Rc::new(origin));\n+                components_must_outlive(rcx, suborigin, subcomponents, region);\n             }\n         }\n     }\n }\n \n-fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                  origin: infer::SubregionOrigin<'tcx>,\n-                                  region: ty::Region,\n-                                  generic: &GenericKind<'tcx>) {\n-    let param_env = &rcx.fcx.inh.infcx.parameter_environment;\n+/// Checks that all data reachable via `ty` *strictly* outlives `scope`.\n+/// This is used by dropck.\n+///\n+/// CAUTION: It is mostly but not entirely equivalent to `T:'parent`\n+/// where `'parent` is the parent of `scope`. The difference is subtle\n+/// and has to do with trait objects, primarily. In particular, if you\n+/// have `Foo<'y>+'z`, then we require that `'z:'parent` but not\n+/// `'y:'parent` (same with lifetimes appearing in fn arguments). This\n+/// is because there is no actual reference to the trait object that\n+/// outlives `scope`, so we don't need to require that the type could\n+/// be named outside `scope`.  Because trait objects are always\n+/// considered \"suspicious\" by dropck, if we don't add this special\n+/// case, you wind up with some kind of annoying and odd limitations\n+/// that crop up\n+/// `src/test/compile-fail/regions-early-bound-trait-param.rs`.\n+/// Basically there we have `&'foo Trait<'foo>+'bar`, and thus forcing\n+/// `'foo` to outlive `'parent` also forces the borrow to outlive\n+/// `'parent`, which is longer than should be necessary. The existence\n+/// of this \"the same but different\" predicate is somewhat bothersome\n+/// and questionable.\n+pub fn type_strictly_outlives<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                                        origin: infer::SubregionOrigin<'tcx>,\n+                                        ty: Ty<'tcx>,\n+                                        scope: CodeExtent)\n+{\n+    debug!(\"type_strictly_outlives(ty={:?}, scope={:?})\",\n+           ty, scope);\n \n-    debug!(\"param_must_outlive(region={:?}, generic={:?})\",\n-           region,\n-           generic);\n+    let span = origin.span();\n \n-    // To start, collect bounds from user:\n-    let mut param_bounds = rcx.tcx().required_region_bounds(generic.to_ty(rcx.tcx()),\n-                                                            param_env.caller_bounds.clone());\n+    let parent_region =\n+        match rcx.tcx().region_maps.opt_encl_scope(scope) {\n+            Some(parent_scope) => ty::ReScope(parent_scope),\n+            None => rcx.tcx().sess.span_bug(\n+                span, &format!(\"no enclosing scope found for scope: {:?}\",\n+                               scope)),\n+        };\n+\n+    type_must_outlive(rcx, origin, ty, parent_region);\n+}\n+\n+fn param_ty_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                   origin: infer::SubregionOrigin<'tcx>,\n+                                   region: ty::Region,\n+                                   param_ty: ty::ParamTy) {\n+    debug!(\"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n+           region, param_ty, origin);\n+\n+    let verify_bound = param_bound(rcx, param_ty);\n+    let generic = GenericKind::Param(param_ty);\n+    rcx.fcx.infcx().verify_generic_bound(origin, generic, region, verify_bound);\n+}\n+\n+fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                     origin: infer::SubregionOrigin<'tcx>,\n+                                     region: ty::Region,\n+                                     projection_ty: ty::ProjectionTy<'tcx>) {\n+    debug!(\"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n+           region, projection_ty, origin);\n+\n+    // This is a particularly thorny situation for inference, and for\n+    // now we don't have a complete solution, we just do the best we\n+    // can. The problem is that there are multiple ways for `<P0 as\n+    // TraitRef<P1..Pn>>::Foo: 'r` to be satisfied:\n+    //\n+    // 1. If `Pi: 'r` forall i, it is satisfied.\n+    // 2. If there is a suitable where-clause, it can be satisfied.\n+    // 3. The trait declaration may declare `'static` bounds on `Foo` as well.\n+    //\n+    // The fact that there are so many options here makes this thorny.\n+    // In the case of parameter relations like `T: 'r`, it's somewhat\n+    // simpler, because checking such a relation does not affect\n+    // inference.  This is true because the region bounds we can\n+    // derive for `T` never involve region variables -- they are\n+    // always free regions.  The only place a region variable can come\n+    // is on the RHS, and in that case, the smaller the region, the\n+    // better. This means that our current inference, which always\n+    // infers the smallest region it can, can just be used, and we'll\n+    // know what the smallest value for `'r` is when it's done. We can\n+    // then compare that to the regions in the LHS, which are already\n+    // as big as possible, and we're all done.\n+    //\n+    // Projections can in fact be this simple as well. In particular,\n+    // if the parameters `P0..Pn` do not involve any region variables,\n+    // that's the same situation.\n+    //\n+    // Where things get thorny is when region variables are involved,\n+    // because in that case relating `Pi: 'r` may influence the\n+    // inference process, since it could cause `'r` to be inferred to\n+    // a larger value. But the problem is that if we add that as a\n+    // constraint into our dataflow graph, we've essentially committed\n+    // to using option 1 (above) to show that `<P0 as\n+    // Trait<P1..Pn>>::Foo: 'r` is satisfied, and it may be that\n+    // Option 1 does not apply, but Option 2 or 3 does. But we can't\n+    // know that now.\n+    //\n+    // For now we choose to accept this. It's a conservative choice,\n+    // so we can move to a more sophisticated inference model later.\n+    // And it's sometimes possible to workaround by introducing\n+    // explicit type parameters or type annotations. But it ain't\n+    // great!\n+\n+    let declared_bounds = projection_declared_bounds(rcx, origin.span(), projection_ty);\n+\n+    debug!(\"projection_must_outlive: declared_bounds={:?}\",\n+           declared_bounds);\n+\n+    // If we know that the projection outlives 'static, then we're done here.\n+    if declared_bounds.contains(&ty::ReStatic) {\n+        return;\n+    }\n+\n+    // Determine whether any of regions that appear in the projection\n+    // were declared as bounds by the user. This is typically a situation\n+    // like this:\n+    //\n+    //     trait Foo<'a> {\n+    //         type Bar: 'a;\n+    //     }\n+    //\n+    // where we are checking `<T as Foo<'_#0r>>: '_#1r`. In such a\n+    // case, if we use the conservative rule, we will check that\n+    // BOTH of the following hold:\n+    //\n+    //     T: _#1r\n+    //     _#0r: _#1r\n+    //\n+    // This is overkill, since the declared bounds tell us that the\n+    // the latter is sufficient.\n+    let intersection_bounds: Vec<_> =\n+        projection_ty.trait_ref.substs.regions()\n+                                      .iter()\n+                                      .filter(|r| declared_bounds.contains(r))\n+                                      .collect();\n+    let intersection_bounds_needs_infer =\n+        intersection_bounds.iter()\n+                           .any(|r| r.needs_infer());\n+    if intersection_bounds_needs_infer {\n+        // If the upper bound(s) (`_#0r` in the above example) are\n+        // region variables, then introduce edges into the inference\n+        // graph, because we need to ensure that `_#0r` is inferred to\n+        // something big enough. But if the upper bound has no\n+        // inference, then fallback (below) to the verify path, where\n+        // we just check after the fact that it was big enough. This\n+        // is more flexible, because it only requires that there\n+        // exists SOME intersection bound that is big enough, whereas\n+        // this path requires that ALL intersection bounds be big\n+        // enough.\n+        debug!(\"projection_must_outlive: intersection_bounds={:?}\",\n+               intersection_bounds);\n+        for &r in intersection_bounds {\n+            rcx.fcx.mk_subr(origin.clone(), region, r);\n+        }\n+        return;\n+    }\n+\n+    // If there are no intersection bounds, but there are still\n+    // inference variables involves, then fallback to the most\n+    // conservative rule, where we require all components of the\n+    // projection outlive the bound.\n+    if\n+        intersection_bounds.is_empty() && (\n+            projection_ty.trait_ref.substs.types.iter().any(|t| t.needs_infer()) ||\n+                projection_ty.trait_ref.substs.regions().iter().any(|r| r.needs_infer()))\n+    {\n+        debug!(\"projection_must_outlive: fallback to rule #1\");\n \n-    // In the case of a projection T::Foo, we may be able to extract bounds from the trait def:\n-    match *generic {\n-        GenericKind::Param(..) => { }\n-        GenericKind::Projection(ref projection_ty) => {\n-            param_bounds.push_all(\n-                &projection_bounds(rcx, origin.span(), projection_ty));\n+        for &component_ty in &projection_ty.trait_ref.substs.types {\n+            type_must_outlive(rcx, origin.clone(), component_ty, region);\n         }\n+\n+        for &r in projection_ty.trait_ref.substs.regions() {\n+            rcx.fcx.mk_subr(origin.clone(), region, r);\n+        }\n+\n+        return;\n     }\n \n+    // Inform region inference that this generic must be properly\n+    // bounded.\n+    let verify_bound = projection_bound(rcx, origin.span(), declared_bounds, projection_ty);\n+    let generic = GenericKind::Projection(projection_ty);\n+    rcx.fcx.infcx().verify_generic_bound(origin, generic.clone(), region, verify_bound);\n+}\n+\n+fn type_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n+    match ty.sty {\n+        ty::TyParam(p) => {\n+            param_bound(rcx, p)\n+        }\n+        ty::TyProjection(data) => {\n+            let declared_bounds = projection_declared_bounds(rcx, span, data);\n+            projection_bound(rcx, span, declared_bounds, data)\n+        }\n+        _ => {\n+            recursive_type_bound(rcx, span, ty)\n+        }\n+    }\n+}\n+\n+fn param_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, param_ty: ty::ParamTy) -> VerifyBound {\n+    let param_env = &rcx.infcx().parameter_environment;\n+\n+    debug!(\"param_bound(param_ty={:?})\",\n+           param_ty);\n+\n+    let mut param_bounds = declared_generic_bounds_from_env(rcx, GenericKind::Param(param_ty));\n+\n     // Add in the default bound of fn body that applies to all in\n     // scope type parameters:\n     param_bounds.push(param_env.implicit_region_bound);\n \n-    // Finally, collect regions we scraped from the well-formedness\n+    VerifyBound::AnyRegion(param_bounds)\n+}\n+\n+fn projection_declared_bounds<'a, 'tcx>(rcx: &Rcx<'a,'tcx>,\n+                                        span: Span,\n+                                        projection_ty: ty::ProjectionTy<'tcx>)\n+                                        -> Vec<ty::Region>\n+{\n+    // First assemble bounds from where clauses and traits.\n+\n+    let mut declared_bounds =\n+        declared_generic_bounds_from_env(rcx, GenericKind::Projection(projection_ty));\n+\n+    declared_bounds.push_all(\n+        &declared_projection_bounds_from_trait(rcx, span, projection_ty));\n+\n+    declared_bounds\n+}\n+\n+fn projection_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                              span: Span,\n+                              declared_bounds: Vec<ty::Region>,\n+                              projection_ty: ty::ProjectionTy<'tcx>)\n+                              -> VerifyBound {\n+    debug!(\"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n+           declared_bounds, projection_ty);\n+\n+    // see the extensive comment in projection_must_outlive\n+\n+    // this routine is not invoked in this case\n+    assert!(\n+        !projection_ty.trait_ref.substs.types.iter().any(|t| t.needs_infer()) &&\n+            !projection_ty.trait_ref.substs.regions().iter().any(|r| r.needs_infer()));\n+\n+    let ty = rcx.tcx().mk_projection(projection_ty.trait_ref, projection_ty.item_name);\n+    let recursive_bound = recursive_type_bound(rcx, span, ty);\n+\n+    VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n+}\n+\n+fn recursive_type_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                  span: Span,\n+                                  ty: Ty<'tcx>)\n+                                  -> VerifyBound {\n+    let mut bounds = vec![];\n+\n+    for subty in ty.walk_shallow() {\n+        bounds.push(type_bound(rcx, span, subty));\n+    }\n+\n+    let mut regions = ty.regions();\n+    regions.retain(|r| !r.is_bound()); // ignore late-bound regions\n+    bounds.push(VerifyBound::AllRegions(ty.regions()));\n+\n+    // remove bounds that must hold, since they are not interesting\n+    bounds.retain(|b| !b.must_hold());\n+\n+    if bounds.len() == 1 {\n+        bounds.pop().unwrap()\n+    } else {\n+        VerifyBound::AllBounds(bounds)\n+    }\n+}\n+\n+fn declared_generic_bounds_from_env<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                              generic: GenericKind<'tcx>)\n+                                              -> Vec<ty::Region>\n+{\n+    let param_env = &rcx.infcx().parameter_environment;\n+\n+    // To start, collect bounds from user:\n+    let mut param_bounds = rcx.tcx().required_region_bounds(generic.to_ty(rcx.tcx()),\n+                                                            param_env.caller_bounds.clone());\n+\n+    // Next, collect regions we scraped from the well-formedness\n     // constraints in the fn signature. To do that, we walk the list\n     // of known relations from the fn ctxt.\n     //\n@@ -1527,27 +1859,22 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // The problem is that the type of `x` is `&'a A`. To be\n     // well-formed, then, A must be lower-generic by `'a`, but we\n     // don't know that this holds from first principles.\n-    for &(ref r, ref p) in &rcx.region_bound_pairs {\n+    for &(r, p) in &rcx.region_bound_pairs {\n         debug!(\"generic={:?} p={:?}\",\n                generic,\n                p);\n         if generic == p {\n-            param_bounds.push(*r);\n+            param_bounds.push(r);\n         }\n     }\n \n-    // Inform region inference that this generic must be properly\n-    // bounded.\n-    rcx.fcx.infcx().verify_generic_bound(origin,\n-                                         generic.clone(),\n-                                         region,\n-                                         param_bounds);\n+    param_bounds\n }\n \n-fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                              span: Span,\n-                              projection_ty: &ty::ProjectionTy<'tcx>)\n-                              -> Vec<ty::Region>\n+fn declared_projection_bounds_from_trait<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                                  span: Span,\n+                                                  projection_ty: ty::ProjectionTy<'tcx>)\n+                                                  -> Vec<ty::Region>\n {\n     let fcx = rcx.fcx;\n     let tcx = fcx.tcx();"}]}