{"sha": "19a17b3d1d0d25155c8bd11c73bf88238f9bd180", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YTE3YjNkMWQwZDI1MTU1YzhiZDExYzczYmY4ODIzOGY5YmQxODA=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-19T22:42:45Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-19T23:08:49Z"}, "message": "Style and indentation cleanups.", "tree": {"sha": "c5a36716128eba9cc04e30c111f1fb340436c8b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5a36716128eba9cc04e30c111f1fb340436c8b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19a17b3d1d0d25155c8bd11c73bf88238f9bd180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19a17b3d1d0d25155c8bd11c73bf88238f9bd180", "html_url": "https://github.com/rust-lang/rust/commit/19a17b3d1d0d25155c8bd11c73bf88238f9bd180", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19a17b3d1d0d25155c8bd11c73bf88238f9bd180/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00e017f60ee032c7d7c733c622fc62c2596e2bef", "url": "https://api.github.com/repos/rust-lang/rust/commits/00e017f60ee032c7d7c733c622fc62c2596e2bef", "html_url": "https://github.com/rust-lang/rust/commit/00e017f60ee032c7d7c733c622fc62c2596e2bef"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "b9ec14eef4472d9e8186aad7b5539674b293b5c0", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/19a17b3d1d0d25155c8bd11c73bf88238f9bd180/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19a17b3d1d0d25155c8bd11c73bf88238f9bd180/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=19a17b3d1d0d25155c8bd11c73bf88238f9bd180", "patch": "@@ -250,14 +250,14 @@ fn type_is_scalar(&@fn_ctxt fcx, &span sp, ty::t typ) -> bool {\n // corresponding to a definition ID:\n fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n     alt (tcx.ast_ty_to_ty_cache.find(ast_ty)) {\n-        case (some[option::t[ty::t]](some[ty::t](?ty))) { ret ty; }\n-        case (some[option::t[ty::t]](none)) {\n+        case (some(some(?ty))) { ret ty; }\n+        case (some(none)) {\n             tcx.sess.span_fatal(ast_ty.span,\n                               \"illegal recursive type \\\n                               insert a tag in the cycle, \\\n                               if this is desired)\");\n         }\n-        case (none[option::t[ty::t]]) { }\n+        case (none) { }\n     } /* go on */\n \n     tcx.ast_ty_to_ty_cache.insert(ast_ty, none[ty::t]);\n@@ -1201,7 +1201,7 @@ fn gather_locals(&@crate_ctxt ccx, &ast::_fn f,\n \n     // Add object fields, if any.\n     alt (get_obj_info(ccx)) {\n-        case (option::some(?oinfo)) {\n+        case (some(?oinfo)) {\n             alt (oinfo) {\n                 case (regular_obj(?obj_fields, _)) {\n                     for (ast::obj_field f in obj_fields) {\n@@ -1219,7 +1219,7 @@ fn gather_locals(&@crate_ctxt ccx, &ast::_fn f,\n                 }\n             }\n         }\n-        case (option::none) {/* no fields */ }\n+        case (none) {/* no fields */ }\n     }\n     // Add formal parameters.\n     auto args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n@@ -1240,7 +1240,7 @@ fn gather_locals(&@crate_ctxt ccx, &ast::_fn f,\n             case (none) {\n                 // Auto slot.\n                 assign(ccx.tcx, vb, locals, local_names, nvi, local.node.id,\n-                       local.node.ident, none[ty::t]);\n+                       local.node.ident, none);\n             }\n             case (some(?ast_ty)) {\n                 // Explicitly typed slot.\n@@ -1261,7 +1261,7 @@ fn gather_locals(&@crate_ctxt ccx, &ast::_fn f,\n         alt (p.node) {\n             case (ast::pat_bind(?ident)) {\n                 assign(ccx.tcx, vb, locals, local_names, nvi,\n-                       p.id, ident, none[ty::t]);\n+                       p.id, ident, none);\n             }\n             case (_) {/* no-op */ }\n         }\n@@ -1296,14 +1296,14 @@ fn replace_expr_type(&@fn_ctxt fcx, &@ast::expr expr,\n     auto new_tps;\n     if (ty::expr_has_ty_params(fcx.ccx.tcx, expr)) {\n         new_tps = some[ty::t[]](new_tyt._0);\n-    } else { new_tps = none[ty::t[]]; }\n+    } else { new_tps = none; }\n     write::ty_fixup(fcx, expr.id, tup(new_tps, new_tyt._1));\n }\n \n // FIXME remove once std::ivec::find makes it into a snapshot\n fn ivec_find[T](fn(&T) -> bool  f, &T[] v) -> option::t[T] {\n     for (T elt in v) { if (f(elt)) { ret some[T](elt); } }\n-    ret none[T];\n+    ret none;\n }\n \n // AST fragment checking\n@@ -1692,16 +1692,16 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         check_block(fcx, thn);\n         auto if_t =\n             alt (elsopt) {\n-                    case (some(?els)) {\n-                        check_expr(fcx, els);\n-                        auto thn_t = block_ty(fcx.ccx.tcx, thn);\n-                        auto elsopt_t = expr_ty(fcx.ccx.tcx, els);\n-                        demand::simple(fcx, sp, thn_t, elsopt_t);\n-                        if (!ty::type_is_bot(fcx.ccx.tcx, elsopt_t)) {\n-                            elsopt_t\n-                                } else { thn_t }\n-                    }\n-                    case (none) { ty::mk_nil(fcx.ccx.tcx) }\n+                case (some(?els)) {\n+                    check_expr(fcx, els);\n+                    auto thn_t = block_ty(fcx.ccx.tcx, thn);\n+                    auto elsopt_t = expr_ty(fcx.ccx.tcx, els);\n+                    demand::simple(fcx, sp, thn_t, elsopt_t);\n+                    if (!ty::type_is_bot(fcx.ccx.tcx, elsopt_t)) {\n+                        elsopt_t\n+                            } else { thn_t }\n+                }\n+                case (none) { ty::mk_nil(fcx.ccx.tcx) }\n             };\n         write::ty_only_fixup(fcx, id, if_t);\n     }"}]}