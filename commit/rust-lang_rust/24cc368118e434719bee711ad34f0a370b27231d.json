{"sha": "24cc368118e434719bee711ad34f0a370b27231d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0Y2MzNjgxMThlNDM0NzE5YmVlNzExYWQzNGYwYTM3MGIyNzIzMWQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-26T00:13:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-26T00:13:24Z"}, "message": "Rollup merge of #61087 - estebank:parsepalooza, r=Centril\n\nTweak `self` arg not as first argument of a method diagnostic\n\nMention that `self` is only valid on \"associated functions\"\n```\nerror: unexpected `self` argument in function\n  --> $DIR/self-in-function-arg.rs:1:15\n   |\nLL | fn foo(x:i32, self: i32) -> i32 { self }\n   |               ^^^^ not valid as function argument\n   |\n   = note: `self` is only valid as the first argument of an associated function\n```\n\nWhen it is a method, mention it must be first\n```\nerror: unexpected `self` argument in function\n  --> $DIR/trait-fn.rs:4:20\n   |\nLL |     fn c(foo: u32, self) {}\n   |                    ^^^^ must be the first associated function argument\n```\n\nMove a bunch of error recovery methods to `diagnostics.rs` away from `parser.rs`.\n\nFix #51547. CC #60015.", "tree": {"sha": "d6a37033f97a5520b1870f7af75963094f5464dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6a37033f97a5520b1870f7af75963094f5464dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24cc368118e434719bee711ad34f0a370b27231d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc6dokCRBK7hj4Ov3rIwAAdHIIAFuJKl7bhk4t2nHDAOjJAblb\nqfzJrakjWFZRJsJdwvcQn3aNrTEx/5Ek+KZoAy9CpS9q0f1z95P/Cpueta9bn8XE\nLLBniJwl6xuXXSuya+CV7RIXnzBGGdGWRoOUaSa2sBwEjJ7zn2eDxJgS/Kr1gODI\nFMluLzeIzN1nxD361OsJvteKdIjeE6qWaHCvGkyxHFkHO1Zx9z0pgUJgEXp0BWOb\nOSgqNHS3l6ppowVXH8yXX+uzYeq9d/prrCVesFLEAXYA8c0akFTQkqQar0GO6njT\nXG55H3ayjFsTryXu6VQ1bJBY3nm+odHCeK862Gz7HrFMBbKmfxXZkG235gwMN14=\n=FCeF\n-----END PGP SIGNATURE-----\n", "payload": "tree d6a37033f97a5520b1870f7af75963094f5464dd\nparent f492693982d1e252f5411ae3e4d560ab0dfea48a\nparent 4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558829604 +0200\ncommitter GitHub <noreply@github.com> 1558829604 +0200\n\nRollup merge of #61087 - estebank:parsepalooza, r=Centril\n\nTweak `self` arg not as first argument of a method diagnostic\n\nMention that `self` is only valid on \"associated functions\"\n```\nerror: unexpected `self` argument in function\n  --> $DIR/self-in-function-arg.rs:1:15\n   |\nLL | fn foo(x:i32, self: i32) -> i32 { self }\n   |               ^^^^ not valid as function argument\n   |\n   = note: `self` is only valid as the first argument of an associated function\n```\n\nWhen it is a method, mention it must be first\n```\nerror: unexpected `self` argument in function\n  --> $DIR/trait-fn.rs:4:20\n   |\nLL |     fn c(foo: u32, self) {}\n   |                    ^^^^ must be the first associated function argument\n```\n\nMove a bunch of error recovery methods to `diagnostics.rs` away from `parser.rs`.\n\nFix #51547. CC #60015.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24cc368118e434719bee711ad34f0a370b27231d", "html_url": "https://github.com/rust-lang/rust/commit/24cc368118e434719bee711ad34f0a370b27231d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24cc368118e434719bee711ad34f0a370b27231d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f492693982d1e252f5411ae3e4d560ab0dfea48a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f492693982d1e252f5411ae3e4d560ab0dfea48a", "html_url": "https://github.com/rust-lang/rust/commit/f492693982d1e252f5411ae3e4d560ab0dfea48a"}, {"sha": "4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "html_url": "https://github.com/rust-lang/rust/commit/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f"}], "stats": {"total": 1222, "additions": 656, "deletions": 566}, "files": [{"sha": "9431b559da55ff8c54d8e012c31eab8ca81b3067", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 580, "deletions": 8, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/24cc368118e434719bee711ad34f0a370b27231d/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24cc368118e434719bee711ad34f0a370b27231d/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=24cc368118e434719bee711ad34f0a370b27231d", "patch": "@@ -1,19 +1,101 @@\n use crate::ast;\n use crate::ast::{\n-    BlockCheckMode, Expr, ExprKind, Item, ItemKind, Pat, PatKind, QSelf, Ty, TyKind, VariantData,\n+    BlockCheckMode, BinOpKind, Expr, ExprKind, Item, ItemKind, Pat, PatKind, PathSegment, QSelf,\n+    Ty, TyKind, VariantData,\n };\n-use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType};\n-use crate::parse::token;\n-use crate::parse::PResult;\n-use crate::parse::Parser;\n+use crate::parse::{SeqSep, token, PResult, Parser};\n+use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType, TokenExpectType};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::Spanned;\n use crate::symbol::kw;\n use crate::ThinVec;\n-use errors::{Applicability, DiagnosticBuilder};\n-use log::debug;\n-use syntax_pos::{Span, DUMMY_SP};\n+use crate::util::parser::AssocOp;\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n+use log::{debug, trace};\n+\n+pub enum Error {\n+    FileNotFoundForModule {\n+        mod_name: String,\n+        default_path: String,\n+        secondary_path: String,\n+        dir_path: String,\n+    },\n+    DuplicatePaths {\n+        mod_name: String,\n+        default_path: String,\n+        secondary_path: String,\n+    },\n+    UselessDocComment,\n+    InclusiveRangeWithNoEnd,\n+}\n+\n+impl Error {\n+    fn span_err<S: Into<MultiSpan>>(\n+        self,\n+        sp: S,\n+        handler: &errors::Handler,\n+    ) -> DiagnosticBuilder<'_> {\n+        match self {\n+            Error::FileNotFoundForModule {\n+                ref mod_name,\n+                ref default_path,\n+                ref secondary_path,\n+                ref dir_path,\n+            } => {\n+                let mut err = struct_span_err!(\n+                    handler,\n+                    sp,\n+                    E0583,\n+                    \"file not found for module `{}`\",\n+                    mod_name,\n+                );\n+                err.help(&format!(\n+                    \"name the file either {} or {} inside the directory \\\"{}\\\"\",\n+                    default_path,\n+                    secondary_path,\n+                    dir_path,\n+                ));\n+                err\n+            }\n+            Error::DuplicatePaths { ref mod_name, ref default_path, ref secondary_path } => {\n+                let mut err = struct_span_err!(\n+                    handler,\n+                    sp,\n+                    E0584,\n+                    \"file for module `{}` found at both {} and {}\",\n+                    mod_name,\n+                    default_path,\n+                    secondary_path,\n+                );\n+                err.help(\"delete or rename one of them to remove the ambiguity\");\n+                err\n+            }\n+            Error::UselessDocComment => {\n+                let mut err = struct_span_err!(\n+                    handler,\n+                    sp,\n+                    E0585,\n+                    \"found a documentation comment that doesn't document anything\",\n+                );\n+                err.help(\"doc comments must come before what they document, maybe a comment was \\\n+                          intended with `//`?\");\n+                err\n+            }\n+            Error::InclusiveRangeWithNoEnd => {\n+                let mut err = struct_span_err!(\n+                    handler,\n+                    sp,\n+                    E0586,\n+                    \"inclusive range with no end\",\n+                );\n+                err.help(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\");\n+                err\n+            }\n+        }\n+    }\n+}\n \n pub trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n@@ -63,6 +145,364 @@ impl RecoverQPath for Expr {\n }\n \n impl<'a> Parser<'a> {\n+    pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n+        self.span_fatal(self.span, m)\n+    }\n+\n+    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n+        self.sess.span_diagnostic.struct_span_fatal(sp, m)\n+    }\n+\n+    pub fn span_fatal_err<S: Into<MultiSpan>>(&self, sp: S, err: Error) -> DiagnosticBuilder<'a> {\n+        err.span_err(sp, self.diagnostic())\n+    }\n+\n+    pub fn bug(&self, m: &str) -> ! {\n+        self.sess.span_diagnostic.span_bug(self.span, m)\n+    }\n+\n+    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n+        self.sess.span_diagnostic.span_err(sp, m)\n+    }\n+\n+    crate fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n+        self.sess.span_diagnostic.struct_span_err(sp, m)\n+    }\n+\n+    crate fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> ! {\n+        self.sess.span_diagnostic.span_bug(sp, m)\n+    }\n+\n+    crate fn cancel(&self, err: &mut DiagnosticBuilder<'_>) {\n+        self.sess.span_diagnostic.cancel(err)\n+    }\n+\n+    crate fn diagnostic(&self) -> &'a errors::Handler {\n+        &self.sess.span_diagnostic\n+    }\n+\n+    crate fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n+        let mut err = self.struct_span_err(\n+            self.span,\n+            &format!(\"expected identifier, found {}\", self.this_token_descr()),\n+        );\n+        if let token::Ident(ident, false) = &self.token {\n+            if ident.is_raw_guess() {\n+                err.span_suggestion(\n+                    self.span,\n+                    \"you can escape reserved keywords to use them as identifiers\",\n+                    format!(\"r#{}\", ident),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+        if let Some(token_descr) = self.token_descr() {\n+            err.span_label(self.span, format!(\"expected identifier, found {}\", token_descr));\n+        } else {\n+            err.span_label(self.span, \"expected identifier\");\n+            if self.token == token::Comma && self.look_ahead(1, |t| t.is_ident()) {\n+                err.span_suggestion(\n+                    self.span,\n+                    \"remove this comma\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        err\n+    }\n+\n+    pub fn expected_one_of_not_found(\n+        &mut self,\n+        edible: &[token::Token],\n+        inedible: &[token::Token],\n+    ) -> PResult<'a, bool /* recovered */> {\n+        fn tokens_to_string(tokens: &[TokenType]) -> String {\n+            let mut i = tokens.iter();\n+            // This might be a sign we need a connect method on Iterator.\n+            let b = i.next()\n+                     .map_or(String::new(), |t| t.to_string());\n+            i.enumerate().fold(b, |mut b, (i, a)| {\n+                if tokens.len() > 2 && i == tokens.len() - 2 {\n+                    b.push_str(\", or \");\n+                } else if tokens.len() == 2 && i == tokens.len() - 2 {\n+                    b.push_str(\" or \");\n+                } else {\n+                    b.push_str(\", \");\n+                }\n+                b.push_str(&a.to_string());\n+                b\n+            })\n+        }\n+\n+        let mut expected = edible.iter()\n+            .map(|x| TokenType::Token(x.clone()))\n+            .chain(inedible.iter().map(|x| TokenType::Token(x.clone())))\n+            .chain(self.expected_tokens.iter().cloned())\n+            .collect::<Vec<_>>();\n+        expected.sort_by_cached_key(|x| x.to_string());\n+        expected.dedup();\n+        let expect = tokens_to_string(&expected[..]);\n+        let actual = self.this_token_to_string();\n+        let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n+            let short_expect = if expected.len() > 6 {\n+                format!(\"{} possible tokens\", expected.len())\n+            } else {\n+                expect.clone()\n+            };\n+            (format!(\"expected one of {}, found `{}`\", expect, actual),\n+                (self.sess.source_map().next_point(self.prev_span),\n+                format!(\"expected one of {} here\", short_expect)))\n+        } else if expected.is_empty() {\n+            (format!(\"unexpected token: `{}`\", actual),\n+                (self.prev_span, \"unexpected token after this\".to_string()))\n+        } else {\n+            (format!(\"expected {}, found `{}`\", expect, actual),\n+                (self.sess.source_map().next_point(self.prev_span),\n+                format!(\"expected {} here\", expect)))\n+        };\n+        self.last_unexpected_token_span = Some(self.span);\n+        let mut err = self.fatal(&msg_exp);\n+        if self.token.is_ident_named(\"and\") {\n+            err.span_suggestion_short(\n+                self.span,\n+                \"use `&&` instead of `and` for the boolean operator\",\n+                \"&&\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        if self.token.is_ident_named(\"or\") {\n+            err.span_suggestion_short(\n+                self.span,\n+                \"use `||` instead of `or` for the boolean operator\",\n+                \"||\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        let sp = if self.token == token::Token::Eof {\n+            // This is EOF, don't want to point at the following char, but rather the last token\n+            self.prev_span\n+        } else {\n+            label_sp\n+        };\n+        match self.recover_closing_delimiter(&expected.iter().filter_map(|tt| match tt {\n+            TokenType::Token(t) => Some(t.clone()),\n+            _ => None,\n+        }).collect::<Vec<_>>(), err) {\n+            Err(e) => err = e,\n+            Ok(recovered) => {\n+                return Ok(recovered);\n+            }\n+        }\n+\n+        let is_semi_suggestable = expected.iter().any(|t| match t {\n+            TokenType::Token(token::Semi) => true, // we expect a `;` here\n+            _ => false,\n+        }) && ( // a `;` would be expected before the current keyword\n+            self.token.is_keyword(kw::Break) ||\n+            self.token.is_keyword(kw::Continue) ||\n+            self.token.is_keyword(kw::For) ||\n+            self.token.is_keyword(kw::If) ||\n+            self.token.is_keyword(kw::Let) ||\n+            self.token.is_keyword(kw::Loop) ||\n+            self.token.is_keyword(kw::Match) ||\n+            self.token.is_keyword(kw::Return) ||\n+            self.token.is_keyword(kw::While)\n+        );\n+        let cm = self.sess.source_map();\n+        match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n+            (Ok(ref a), Ok(ref b)) if a.line != b.line && is_semi_suggestable => {\n+                // The spans are in different lines, expected `;` and found `let` or `return`.\n+                // High likelihood that it is only a missing `;`.\n+                err.span_suggestion_short(\n+                    label_sp,\n+                    \"a semicolon may be missing here\",\n+                    \";\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err.emit();\n+                return Ok(true);\n+            }\n+            (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n+                // When the spans are in the same line, it means that the only content between\n+                // them is whitespace, point at the found token in that case:\n+                //\n+                // X |     () => { syntax error };\n+                //   |                    ^^^^^ expected one of 8 possible tokens here\n+                //\n+                // instead of having:\n+                //\n+                // X |     () => { syntax error };\n+                //   |                   -^^^^^ unexpected token\n+                //   |                   |\n+                //   |                   expected one of 8 possible tokens here\n+                err.span_label(self.span, label_exp);\n+            }\n+            _ if self.prev_span == syntax_pos::DUMMY_SP => {\n+                // Account for macro context where the previous span might not be\n+                // available to avoid incorrect output (#54841).\n+                err.span_label(self.span, \"unexpected token\");\n+            }\n+            _ => {\n+                err.span_label(sp, label_exp);\n+                err.span_label(self.span, \"unexpected token\");\n+            }\n+        }\n+        Err(err)\n+    }\n+\n+    /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n+    /// passes through any errors encountered. Used for error recovery.\n+    crate fn eat_to_tokens(&mut self, kets: &[&token::Token]) {\n+        let handler = self.diagnostic();\n+\n+        if let Err(ref mut err) = self.parse_seq_to_before_tokens(\n+            kets,\n+            SeqSep::none(),\n+            TokenExpectType::Expect,\n+            |p| Ok(p.parse_token_tree()),\n+        ) {\n+            handler.cancel(err);\n+        }\n+    }\n+\n+    /// This function checks if there are trailing angle brackets and produces\n+    /// a diagnostic to suggest removing them.\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n+    ///                                                        ^^ help: remove extra angle brackets\n+    /// ```\n+    crate fn check_trailing_angle_brackets(&mut self, segment: &PathSegment, end: token::Token) {\n+        // This function is intended to be invoked after parsing a path segment where there are two\n+        // cases:\n+        //\n+        // 1. A specific token is expected after the path segment.\n+        //    eg. `x.foo(`, `x.foo::<u32>(` (parenthesis - method call),\n+        //        `Foo::`, or `Foo::<Bar>::` (mod sep - continued path).\n+        // 2. No specific token is expected after the path segment.\n+        //    eg. `x.foo` (field access)\n+        //\n+        // This function is called after parsing `.foo` and before parsing the token `end` (if\n+        // present). This includes any angle bracket arguments, such as `.foo::<u32>` or\n+        // `Foo::<Bar>`.\n+\n+        // We only care about trailing angle brackets if we previously parsed angle bracket\n+        // arguments. This helps stop us incorrectly suggesting that extra angle brackets be\n+        // removed in this case:\n+        //\n+        // `x.foo >> (3)` (where `x.foo` is a `u32` for example)\n+        //\n+        // This case is particularly tricky as we won't notice it just looking at the tokens -\n+        // it will appear the same (in terms of upcoming tokens) as below (since the `::<u32>` will\n+        // have already been parsed):\n+        //\n+        // `x.foo::<u32>>>(3)`\n+        let parsed_angle_bracket_args = segment.args\n+            .as_ref()\n+            .map(|args| args.is_angle_bracketed())\n+            .unwrap_or(false);\n+\n+        debug!(\n+            \"check_trailing_angle_brackets: parsed_angle_bracket_args={:?}\",\n+            parsed_angle_bracket_args,\n+        );\n+        if !parsed_angle_bracket_args {\n+            return;\n+        }\n+\n+        // Keep the span at the start so we can highlight the sequence of `>` characters to be\n+        // removed.\n+        let lo = self.span;\n+\n+        // We need to look-ahead to see if we have `>` characters without moving the cursor forward\n+        // (since we might have the field access case and the characters we're eating are\n+        // actual operators and not trailing characters - ie `x.foo >> 3`).\n+        let mut position = 0;\n+\n+        // We can encounter `>` or `>>` tokens in any order, so we need to keep track of how\n+        // many of each (so we can correctly pluralize our error messages) and continue to\n+        // advance.\n+        let mut number_of_shr = 0;\n+        let mut number_of_gt = 0;\n+        while self.look_ahead(position, |t| {\n+            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n+            if *t == token::BinOp(token::BinOpToken::Shr) {\n+                number_of_shr += 1;\n+                true\n+            } else if *t == token::Gt {\n+                number_of_gt += 1;\n+                true\n+            } else {\n+                false\n+            }\n+        }) {\n+            position += 1;\n+        }\n+\n+        // If we didn't find any trailing `>` characters, then we have nothing to error about.\n+        debug!(\n+            \"check_trailing_angle_brackets: number_of_gt={:?} number_of_shr={:?}\",\n+            number_of_gt, number_of_shr,\n+        );\n+        if number_of_gt < 1 && number_of_shr < 1 {\n+            return;\n+        }\n+\n+        // Finally, double check that we have our end token as otherwise this is the\n+        // second case.\n+        if self.look_ahead(position, |t| {\n+            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n+            *t == end\n+        }) {\n+            // Eat from where we started until the end token so that parsing can continue\n+            // as if we didn't have those extra angle brackets.\n+            self.eat_to_tokens(&[&end]);\n+            let span = lo.until(self.span);\n+\n+            let plural = number_of_gt > 1 || number_of_shr >= 1;\n+            self.diagnostic()\n+                .struct_span_err(\n+                    span,\n+                    &format!(\"unmatched angle bracket{}\", if plural { \"s\" } else { \"\" }),\n+                )\n+                .span_suggestion(\n+                    span,\n+                    &format!(\"remove extra angle bracket{}\", if plural { \"s\" } else { \"\" }),\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        }\n+    }\n+\n+    /// Produce an error if comparison operators are chained (RFC #558).\n+    /// We only need to check lhs, not rhs, because all comparison ops\n+    /// have same precedence and are left-associative\n+    crate fn check_no_chained_comparison(&self, lhs: &Expr, outer_op: &AssocOp) {\n+        debug_assert!(outer_op.is_comparison(),\n+                      \"check_no_chained_comparison: {:?} is not comparison\",\n+                      outer_op);\n+        match lhs.node {\n+            ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n+                // respan to include both operators\n+                let op_span = op.span.to(self.span);\n+                let mut err = self.diagnostic().struct_span_err(op_span,\n+                    \"chained comparison operators require parentheses\");\n+                if op.node == BinOpKind::Lt &&\n+                    *outer_op == AssocOp::Less ||  // Include `<` to provide this recommendation\n+                    *outer_op == AssocOp::Greater  // even in a case like the following:\n+                {                                  //     Foo<Bar<Baz<Qux, ()>>>\n+                    err.help(\n+                        \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n+                    err.help(\"or use `(...)` if you meant to specify fn arguments\");\n+                }\n+                err.emit();\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     crate fn maybe_report_ambiguous_plus(\n         &mut self,\n         allow_plus: bool,\n@@ -594,6 +1034,138 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    crate fn check_for_for_in_in_typo(&mut self, in_span: Span) {\n+        if self.eat_keyword(kw::In) {\n+            // a common typo: `for _ in in bar {}`\n+            let mut err = self.sess.span_diagnostic.struct_span_err(\n+                self.prev_span,\n+                \"expected iterable, found keyword `in`\",\n+            );\n+            err.span_suggestion_short(\n+                in_span.until(self.prev_span),\n+                \"remove the duplicated `in`\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+            err.emit();\n+        }\n+    }\n+\n+    crate fn expected_semi_or_open_brace(&mut self) -> PResult<'a, ast::TraitItem> {\n+        let token_str = self.this_token_descr();\n+        let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n+        err.span_label(self.span, \"expected `;` or `{`\");\n+        Err(err)\n+    }\n+\n+    crate fn eat_incorrect_doc_comment(&mut self, applied_to: &str) {\n+        if let token::DocComment(_) = self.token {\n+            let mut err = self.diagnostic().struct_span_err(\n+                self.span,\n+                &format!(\"documentation comments cannot be applied to {}\", applied_to),\n+            );\n+            err.span_label(self.span, \"doc comments are not allowed here\");\n+            err.emit();\n+            self.bump();\n+        } else if self.token == token::Pound && self.look_ahead(1, |t| {\n+            *t == token::OpenDelim(token::Bracket)\n+        }) {\n+            let lo = self.span;\n+            // Skip every token until next possible arg.\n+            while self.token != token::CloseDelim(token::Bracket) {\n+                self.bump();\n+            }\n+            let sp = lo.to(self.span);\n+            self.bump();\n+            let mut err = self.diagnostic().struct_span_err(\n+                sp,\n+                &format!(\"attributes cannot be applied to {}\", applied_to),\n+            );\n+            err.span_label(sp, \"attributes are not allowed here\");\n+            err.emit();\n+        }\n+    }\n+\n+    crate fn argument_without_type(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        pat: P<ast::Pat>,\n+        require_name: bool,\n+        is_trait_item: bool,\n+    ) {\n+        // If we find a pattern followed by an identifier, it could be an (incorrect)\n+        // C-style parameter declaration.\n+        if self.check_ident() && self.look_ahead(1, |t| {\n+            *t == token::Comma || *t == token::CloseDelim(token::Paren)\n+        }) {\n+            let ident = self.parse_ident().unwrap();\n+            let span = pat.span.with_hi(ident.span.hi());\n+\n+            err.span_suggestion(\n+                span,\n+                \"declare the type after the parameter binding\",\n+                String::from(\"<identifier>: <type>\"),\n+                Applicability::HasPlaceholders,\n+            );\n+        } else if require_name && is_trait_item {\n+            if let PatKind::Ident(_, ident, _) = pat.node {\n+                err.span_suggestion(\n+                    pat.span,\n+                    \"explicitly ignore parameter\",\n+                    format!(\"_: {}\", ident),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+\n+            err.note(\"anonymous parameters are removed in the 2018 edition (see RFC 1685)\");\n+        }\n+    }\n+\n+    crate fn recover_arg_parse(&mut self) -> PResult<'a, (P<ast::Pat>, P<ast::Ty>)> {\n+        let pat = self.parse_pat(Some(\"argument name\"))?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+\n+        let mut err = self.diagnostic().struct_span_err_with_code(\n+            pat.span,\n+            \"patterns aren't allowed in methods without bodies\",\n+            DiagnosticId::Error(\"E0642\".into()),\n+        );\n+        err.span_suggestion_short(\n+            pat.span,\n+            \"give this argument a name or use an underscore to ignore it\",\n+            \"_\".to_owned(),\n+            Applicability::MachineApplicable,\n+        );\n+        err.emit();\n+\n+        // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n+        let pat = P(Pat {\n+            node: PatKind::Wild,\n+            span: pat.span,\n+            id: ast::DUMMY_NODE_ID\n+        });\n+        Ok((pat, ty))\n+    }\n+\n+    crate fn recover_bad_self_arg(\n+        &mut self,\n+        mut arg: ast::Arg,\n+        is_trait_item: bool,\n+    ) -> PResult<'a, ast::Arg> {\n+        let sp = arg.pat.span;\n+        arg.ty.node = TyKind::Err;\n+        let mut err = self.struct_span_err(sp, \"unexpected `self` parameter in function\");\n+        if is_trait_item {\n+            err.span_label(sp, \"must be the first associated function parameter\");\n+        } else {\n+            err.span_label(sp, \"not valid as function parameter\");\n+            err.note(\"`self` is only valid as the first parameter of an associated function\");\n+        }\n+        err.emit();\n+        Ok(arg)\n+    }\n+\n     crate fn consume_block(&mut self, delim: token::DelimToken) {\n         let mut brace_depth = 0;\n         loop {"}, {"sha": "6c29437362c89cd7f666e8f5843739358021fcfb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 43, "deletions": 544, "changes": 587, "blob_url": "https://github.com/rust-lang/rust/blob/24cc368118e434719bee711ad34f0a370b27231d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24cc368118e434719bee711ad34f0a370b27231d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=24cc368118e434719bee711ad34f0a370b27231d", "patch": "@@ -47,14 +47,12 @@ use crate::parse::PResult;\n use crate::ThinVec;\n use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n use crate::symbol::{kw, sym, Symbol};\n+use crate::parse::diagnostics::Error;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n-use syntax_pos::{\n-    BytePos, DUMMY_SP, FileName, MultiSpan, Span,\n-    hygiene::CompilerDesugaringKind,\n-};\n-use log::{debug, trace};\n+use syntax_pos::{Span, BytePos, DUMMY_SP, FileName, hygiene::CompilerDesugaringKind};\n+use log::debug;\n \n use std::borrow::Cow;\n use std::cmp;\n@@ -217,7 +215,7 @@ pub struct Parser<'a> {\n     /// into modules, and sub-parsers have new values for this name.\n     pub root_module_name: Option<String>,\n     crate expected_tokens: Vec<TokenType>,\n-    token_cursor: TokenCursor,\n+    crate token_cursor: TokenCursor,\n     desugar_doc_comments: bool,\n     /// Whether we should configure out of line modules as we parse.\n     pub cfg_mods: bool,\n@@ -232,7 +230,7 @@ pub struct Parser<'a> {\n     /// it gets removed from here. Every entry left at the end gets emitted as an independent\n     /// error.\n     crate unclosed_delims: Vec<UnmatchedBrace>,\n-    last_unexpected_token_span: Option<Span>,\n+    crate last_unexpected_token_span: Option<Span>,\n     /// If present, this `Parser` is not parsing Rust code but rather a macro call.\n     crate subparser_name: Option<&'static str>,\n }\n@@ -245,19 +243,19 @@ impl<'a> Drop for Parser<'a> {\n }\n \n #[derive(Clone)]\n-struct TokenCursor {\n-    frame: TokenCursorFrame,\n-    stack: Vec<TokenCursorFrame>,\n+crate struct TokenCursor {\n+    crate frame: TokenCursorFrame,\n+    crate stack: Vec<TokenCursorFrame>,\n }\n \n #[derive(Clone)]\n-struct TokenCursorFrame {\n-    delim: token::DelimToken,\n-    span: DelimSpan,\n-    open_delim: bool,\n-    tree_cursor: tokenstream::Cursor,\n-    close_delim: bool,\n-    last_token: LastToken,\n+crate struct TokenCursorFrame {\n+    crate delim: token::DelimToken,\n+    crate span: DelimSpan,\n+    crate open_delim: bool,\n+    crate tree_cursor: tokenstream::Cursor,\n+    crate close_delim: bool,\n+    crate last_token: LastToken,\n }\n \n /// This is used in `TokenCursorFrame` above to track tokens that are consumed\n@@ -278,7 +276,7 @@ struct TokenCursorFrame {\n /// You can find some more example usage of this in the `collect_tokens` method\n /// on the parser.\n #[derive(Clone)]\n-enum LastToken {\n+crate enum LastToken {\n     Collecting(Vec<TreeAndJoint>),\n     Was(Option<TreeAndJoint>),\n }\n@@ -430,65 +428,6 @@ pub struct ModulePathSuccess {\n     warn: bool,\n }\n \n-pub enum Error {\n-    FileNotFoundForModule {\n-        mod_name: String,\n-        default_path: String,\n-        secondary_path: String,\n-        dir_path: String,\n-    },\n-    DuplicatePaths {\n-        mod_name: String,\n-        default_path: String,\n-        secondary_path: String,\n-    },\n-    UselessDocComment,\n-    InclusiveRangeWithNoEnd,\n-}\n-\n-impl Error {\n-    fn span_err<S: Into<MultiSpan>>(self,\n-                                        sp: S,\n-                                        handler: &errors::Handler) -> DiagnosticBuilder<'_> {\n-        match self {\n-            Error::FileNotFoundForModule { ref mod_name,\n-                                           ref default_path,\n-                                           ref secondary_path,\n-                                           ref dir_path } => {\n-                let mut err = struct_span_err!(handler, sp, E0583,\n-                                               \"file not found for module `{}`\", mod_name);\n-                err.help(&format!(\"name the file either {} or {} inside the directory \\\"{}\\\"\",\n-                                  default_path,\n-                                  secondary_path,\n-                                  dir_path));\n-                err\n-            }\n-            Error::DuplicatePaths { ref mod_name, ref default_path, ref secondary_path } => {\n-                let mut err = struct_span_err!(handler, sp, E0584,\n-                                               \"file for module `{}` found at both {} and {}\",\n-                                               mod_name,\n-                                               default_path,\n-                                               secondary_path);\n-                err.help(\"delete or rename one of them to remove the ambiguity\");\n-                err\n-            }\n-            Error::UselessDocComment => {\n-                let mut err = struct_span_err!(handler, sp, E0585,\n-                                  \"found a documentation comment that doesn't document anything\");\n-                err.help(\"doc comments must come before what they document, maybe a comment was \\\n-                          intended with `//`?\");\n-                err\n-            }\n-            Error::InclusiveRangeWithNoEnd => {\n-                let mut err = struct_span_err!(handler, sp, E0586,\n-                                               \"inclusive range with no end\");\n-                err.help(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\");\n-                err\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Debug)]\n enum LhsExpr {\n     NotYetParsed,\n@@ -529,7 +468,7 @@ fn dummy_arg(span: Span) -> Arg {\n }\n \n #[derive(Copy, Clone, Debug)]\n-enum TokenExpectType {\n+crate enum TokenExpectType {\n     Expect,\n     NoExpect,\n }\n@@ -610,7 +549,7 @@ impl<'a> Parser<'a> {\n         pprust::token_to_string(&self.token)\n     }\n \n-    fn token_descr(&self) -> Option<&'static str> {\n+    crate fn token_descr(&self) -> Option<&'static str> {\n         Some(match &self.token {\n             t if t.is_special_ident() => \"reserved identifier\",\n             t if t.is_used_keyword() => \"keyword\",\n@@ -657,23 +596,6 @@ impl<'a> Parser<'a> {\n         edible: &[token::Token],\n         inedible: &[token::Token],\n     ) -> PResult<'a, bool /* recovered */> {\n-        fn tokens_to_string(tokens: &[TokenType]) -> String {\n-            let mut i = tokens.iter();\n-            // This might be a sign we need a connect method on Iterator.\n-            let b = i.next()\n-                     .map_or(String::new(), |t| t.to_string());\n-            i.enumerate().fold(b, |mut b, (i, a)| {\n-                if tokens.len() > 2 && i == tokens.len() - 2 {\n-                    b.push_str(\", or \");\n-                } else if tokens.len() == 2 && i == tokens.len() - 2 {\n-                    b.push_str(\" or \");\n-                } else {\n-                    b.push_str(\", \");\n-                }\n-                b.push_str(&a.to_string());\n-                b\n-            })\n-        }\n         if edible.contains(&self.token) {\n             self.bump();\n             Ok(false)\n@@ -683,127 +605,15 @@ impl<'a> Parser<'a> {\n         } else if self.last_unexpected_token_span == Some(self.span) {\n             FatalError.raise();\n         } else {\n-            let mut expected = edible.iter()\n-                .map(|x| TokenType::Token(x.clone()))\n-                .chain(inedible.iter().map(|x| TokenType::Token(x.clone())))\n-                .chain(self.expected_tokens.iter().cloned())\n-                .collect::<Vec<_>>();\n-            expected.sort_by_cached_key(|x| x.to_string());\n-            expected.dedup();\n-            let expect = tokens_to_string(&expected[..]);\n-            let actual = self.this_token_to_string();\n-            let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n-                let short_expect = if expected.len() > 6 {\n-                    format!(\"{} possible tokens\", expected.len())\n-                } else {\n-                    expect.clone()\n-                };\n-                (format!(\"expected one of {}, found `{}`\", expect, actual),\n-                 (self.sess.source_map().next_point(self.prev_span),\n-                  format!(\"expected one of {} here\", short_expect)))\n-            } else if expected.is_empty() {\n-                (format!(\"unexpected token: `{}`\", actual),\n-                 (self.prev_span, \"unexpected token after this\".to_string()))\n-            } else {\n-                (format!(\"expected {}, found `{}`\", expect, actual),\n-                 (self.sess.source_map().next_point(self.prev_span),\n-                  format!(\"expected {} here\", expect)))\n-            };\n-            self.last_unexpected_token_span = Some(self.span);\n-            let mut err = self.fatal(&msg_exp);\n-            if self.token.is_ident_named(\"and\") {\n-                err.span_suggestion_short(\n-                    self.span,\n-                    \"use `&&` instead of `and` for the boolean operator\",\n-                    \"&&\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            if self.token.is_ident_named(\"or\") {\n-                err.span_suggestion_short(\n-                    self.span,\n-                    \"use `||` instead of `or` for the boolean operator\",\n-                    \"||\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            let sp = if self.token == token::Token::Eof {\n-                // This is EOF, don't want to point at the following char, but rather the last token\n-                self.prev_span\n-            } else {\n-                label_sp\n-            };\n-            match self.recover_closing_delimiter(&expected.iter().filter_map(|tt| match tt {\n-                TokenType::Token(t) => Some(t.clone()),\n-                _ => None,\n-            }).collect::<Vec<_>>(), err) {\n-                Err(e) => err = e,\n-                Ok(recovered) => {\n-                    return Ok(recovered);\n-                }\n-            }\n-\n-            let is_semi_suggestable = expected.iter().any(|t| match t {\n-                TokenType::Token(token::Semi) => true, // we expect a `;` here\n-                _ => false,\n-            }) && ( // a `;` would be expected before the current keyword\n-                self.token.is_keyword(kw::Break) ||\n-                self.token.is_keyword(kw::Continue) ||\n-                self.token.is_keyword(kw::For) ||\n-                self.token.is_keyword(kw::If) ||\n-                self.token.is_keyword(kw::Let) ||\n-                self.token.is_keyword(kw::Loop) ||\n-                self.token.is_keyword(kw::Match) ||\n-                self.token.is_keyword(kw::Return) ||\n-                self.token.is_keyword(kw::While)\n-            );\n-            let cm = self.sess.source_map();\n-            match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n-                (Ok(ref a), Ok(ref b)) if a.line != b.line && is_semi_suggestable => {\n-                    // The spans are in different lines, expected `;` and found `let` or `return`.\n-                    // High likelihood that it is only a missing `;`.\n-                    err.span_suggestion_short(\n-                        label_sp,\n-                        \"a semicolon may be missing here\",\n-                        \";\".to_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.emit();\n-                    return Ok(true);\n-                }\n-                (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n-                    // When the spans are in the same line, it means that the only content between\n-                    // them is whitespace, point at the found token in that case:\n-                    //\n-                    // X |     () => { syntax error };\n-                    //   |                    ^^^^^ expected one of 8 possible tokens here\n-                    //\n-                    // instead of having:\n-                    //\n-                    // X |     () => { syntax error };\n-                    //   |                   -^^^^^ unexpected token\n-                    //   |                   |\n-                    //   |                   expected one of 8 possible tokens here\n-                    err.span_label(self.span, label_exp);\n-                }\n-                _ if self.prev_span == DUMMY_SP => {\n-                    // Account for macro context where the previous span might not be\n-                    // available to avoid incorrect output (#54841).\n-                    err.span_label(self.span, \"unexpected token\");\n-                }\n-                _ => {\n-                    err.span_label(sp, label_exp);\n-                    err.span_label(self.span, \"unexpected token\");\n-                }\n-            }\n-            Err(err)\n+            self.expected_one_of_not_found(edible, inedible)\n         }\n     }\n \n     /// Returns the span of expr, if it was not interpolated or the span of the interpolated token.\n-    fn interpolated_or_expr_span(&self,\n-                                 expr: PResult<'a, P<Expr>>)\n-                                 -> PResult<'a, (Span, P<Expr>)> {\n+    fn interpolated_or_expr_span(\n+        &self,\n+        expr: PResult<'a, P<Expr>>,\n+    ) -> PResult<'a, (Span, P<Expr>)> {\n         expr.map(|e| {\n             if self.prev_token_kind == PrevTokenKind::Interpolated {\n                 (self.prev_span, e)\n@@ -813,36 +623,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n-        let mut err = self.struct_span_err(self.span,\n-                                           &format!(\"expected identifier, found {}\",\n-                                                    self.this_token_descr()));\n-        if let token::Ident(ident, false) = &self.token {\n-            if ident.is_raw_guess() {\n-                err.span_suggestion(\n-                    self.span,\n-                    \"you can escape reserved keywords to use them as identifiers\",\n-                    format!(\"r#{}\", ident),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-        }\n-        if let Some(token_descr) = self.token_descr() {\n-            err.span_label(self.span, format!(\"expected identifier, found {}\", token_descr));\n-        } else {\n-            err.span_label(self.span, \"expected identifier\");\n-            if self.token == token::Comma && self.look_ahead(1, |t| t.is_ident()) {\n-                err.span_suggestion(\n-                    self.span,\n-                    \"remove this comma\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-        err\n-    }\n-\n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n         self.parse_ident_common(true)\n     }\n@@ -925,7 +705,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn check_ident(&mut self) -> bool {\n+    crate fn check_ident(&mut self) -> bool {\n         if self.token.is_ident() {\n             true\n         } else {\n@@ -1115,19 +895,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n-    /// passes through any errors encountered. Used for error recovery.\n-    fn eat_to_tokens(&mut self, kets: &[&token::Token]) {\n-        let handler = self.diagnostic();\n-\n-        if let Err(ref mut err) = self.parse_seq_to_before_tokens(kets,\n-                                                                  SeqSep::none(),\n-                                                                  TokenExpectType::Expect,\n-                                                                  |p| Ok(p.parse_token_tree())) {\n-            handler.cancel(err);\n-        }\n-    }\n-\n     /// Parses a sequence, including the closing delimiter. The function\n     /// `f` must consume tokens until reaching the next separator or\n     /// closing bracket.\n@@ -1159,7 +926,7 @@ impl<'a> Parser<'a> {\n         self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n     }\n \n-    fn parse_seq_to_before_tokens<T, F>(\n+    crate fn parse_seq_to_before_tokens<T, F>(\n         &mut self,\n         kets: &[&token::Token],\n         sep: SeqSep,\n@@ -1319,35 +1086,6 @@ impl<'a> Parser<'a> {\n             None => self.look_ahead_span(dist - 1),\n         }\n     }\n-    pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n-        self.sess.span_diagnostic.struct_span_fatal(self.span, m)\n-    }\n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n-        self.sess.span_diagnostic.struct_span_fatal(sp, m)\n-    }\n-    fn span_fatal_err<S: Into<MultiSpan>>(&self, sp: S, err: Error) -> DiagnosticBuilder<'a> {\n-        err.span_err(sp, self.diagnostic())\n-    }\n-    fn bug(&self, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_bug(self.span, m)\n-    }\n-    fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n-        self.sess.span_diagnostic.span_err(sp, m)\n-    }\n-    crate fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n-        self.sess.span_diagnostic.struct_span_err(sp, m)\n-    }\n-    crate fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_bug(sp, m)\n-    }\n-\n-    fn cancel(&self, err: &mut DiagnosticBuilder<'_>) {\n-        self.sess.span_diagnostic.cancel(err)\n-    }\n-\n-    crate fn diagnostic(&self) -> &'a errors::Handler {\n-        &self.sess.span_diagnostic\n-    }\n \n     /// Is the current token one of the keywords that signals a bare function type?\n     fn token_is_bare_fn_keyword(&mut self) -> bool {\n@@ -1507,20 +1245,12 @@ impl<'a> Parser<'a> {\n                             Some(body)\n                         }\n                         _ => {\n-                            let token_str = self.this_token_descr();\n-                            let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\",\n-                                                              token_str));\n-                            err.span_label(self.span, \"expected `;` or `{`\");\n-                            return Err(err);\n+                            return self.expected_semi_or_open_brace();\n                         }\n                     }\n                 }\n                 _ => {\n-                    let token_str = self.this_token_descr();\n-                    let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\",\n-                                                      token_str));\n-                    err.span_label(self.span, \"expected `;` or `{`\");\n-                    return Err(err);\n+                    return self.expected_semi_or_open_brace();\n                 }\n             };\n             (ident, ast::TraitItemKind::Method(sig, body), generics)\n@@ -1776,79 +1506,24 @@ impl<'a> Parser<'a> {\n \n     /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n     /// error.\n-    fn eat_incorrect_doc_comment(&mut self, applied_to: &str) {\n-        if let token::DocComment(_) = self.token {\n-            let mut err = self.diagnostic().struct_span_err(\n-                self.span,\n-                &format!(\"documentation comments cannot be applied to {}\", applied_to),\n-            );\n-            err.span_label(self.span, \"doc comments are not allowed here\");\n-            err.emit();\n-            self.bump();\n-        } else if self.token == token::Pound && self.look_ahead(1, |t| {\n-            *t == token::OpenDelim(token::Bracket)\n-        }) {\n-            let lo = self.span;\n-            // Skip every token until next possible arg.\n-            while self.token != token::CloseDelim(token::Bracket) {\n-                self.bump();\n-            }\n-            let sp = lo.to(self.span);\n-            self.bump();\n-            let mut err = self.diagnostic().struct_span_err(\n-                sp,\n-                &format!(\"attributes cannot be applied to {}\", applied_to),\n-            );\n-            err.span_label(sp, \"attributes are not allowed here\");\n-            err.emit();\n-        }\n-    }\n-\n     /// This version of parse arg doesn't necessarily require identifier names.\n-    fn parse_arg_general(&mut self, require_name: bool, is_trait_item: bool,\n-                         allow_c_variadic: bool) -> PResult<'a, Arg> {\n-        if let Ok(Some(_)) = self.parse_self_arg() {\n-            let mut err = self.struct_span_err(self.prev_span,\n-                \"unexpected `self` argument in function\");\n-            err.span_label(self.prev_span,\n-                \"`self` is only valid as the first argument of an associated function\");\n-            return Err(err);\n+    fn parse_arg_general(\n+        &mut self,\n+        require_name: bool,\n+        is_trait_item: bool,\n+        allow_c_variadic: bool,\n+    ) -> PResult<'a, Arg> {\n+        if let Ok(Some(arg)) = self.parse_self_arg() {\n+            return self.recover_bad_self_arg(arg, is_trait_item);\n         }\n \n         let (pat, ty) = if require_name || self.is_named_argument() {\n-            debug!(\"parse_arg_general parse_pat (require_name:{})\",\n-                   require_name);\n+            debug!(\"parse_arg_general parse_pat (require_name:{})\", require_name);\n             self.eat_incorrect_doc_comment(\"method arguments\");\n             let pat = self.parse_pat(Some(\"argument name\"))?;\n \n             if let Err(mut err) = self.expect(&token::Colon) {\n-                // If we find a pattern followed by an identifier, it could be an (incorrect)\n-                // C-style parameter declaration.\n-                if self.check_ident() && self.look_ahead(1, |t| {\n-                    *t == token::Comma || *t == token::CloseDelim(token::Paren)\n-                }) {\n-                    let ident = self.parse_ident().unwrap();\n-                    let span = pat.span.with_hi(ident.span.hi());\n-\n-                    err.span_suggestion(\n-                        span,\n-                        \"declare the type after the parameter binding\",\n-                        String::from(\"<identifier>: <type>\"),\n-                        Applicability::HasPlaceholders,\n-                    );\n-                } else if require_name && is_trait_item {\n-                    if let PatKind::Ident(_, ident, _) = pat.node {\n-                        err.span_suggestion(\n-                            pat.span,\n-                            \"explicitly ignore parameter\",\n-                            format!(\"_: {}\", ident),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-\n-                    err.note(\"anonymous parameters are removed in the 2018 edition (see RFC 1685)\");\n-                }\n-\n+                self.argument_without_type(&mut err, pat, require_name, is_trait_item);\n                 return Err(err);\n             }\n \n@@ -1885,42 +1560,14 @@ impl<'a> Parser<'a> {\n                     // Recover from attempting to parse the argument as a type without pattern.\n                     err.cancel();\n                     mem::replace(self, parser_snapshot_before_ty);\n-                    let pat = self.parse_pat(Some(\"argument name\"))?;\n-                    self.expect(&token::Colon)?;\n-                    let ty = self.parse_ty()?;\n-\n-                    let mut err = self.diagnostic().struct_span_err_with_code(\n-                        pat.span,\n-                        \"patterns aren't allowed in methods without bodies\",\n-                        DiagnosticId::Error(\"E0642\".into()),\n-                    );\n-                    err.span_suggestion_short(\n-                        pat.span,\n-                        \"give this argument a name or use an underscore to ignore it\",\n-                        \"_\".to_owned(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n-\n-                    // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n-                    let pat = P(Pat {\n-                        node: PatKind::Wild,\n-                        span: pat.span,\n-                        id: ast::DUMMY_NODE_ID\n-                    });\n-                    (pat, ty)\n+                    self.recover_arg_parse()?\n                 }\n             }\n         };\n \n         Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID, source: ast::ArgSource::Normal })\n     }\n \n-    /// Parses a single function argument.\n-    crate fn parse_arg(&mut self) -> PResult<'a, Arg> {\n-        self.parse_arg_general(true, false, false)\n-    }\n-\n     /// Parses an argument in a lambda header (e.g., `|arg, arg|`).\n     fn parse_fn_block_arg(&mut self) -> PResult<'a, Arg> {\n         let pat = self.parse_pat(Some(\"argument name\"))?;\n@@ -2885,116 +2532,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// This function checks if there are trailing angle brackets and produces\n-    /// a diagnostic to suggest removing them.\n-    ///\n-    /// ```ignore (diagnostic)\n-    /// let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n-    ///                                                        ^^ help: remove extra angle brackets\n-    /// ```\n-    fn check_trailing_angle_brackets(&mut self, segment: &PathSegment, end: token::Token) {\n-        // This function is intended to be invoked after parsing a path segment where there are two\n-        // cases:\n-        //\n-        // 1. A specific token is expected after the path segment.\n-        //    eg. `x.foo(`, `x.foo::<u32>(` (parenthesis - method call),\n-        //        `Foo::`, or `Foo::<Bar>::` (mod sep - continued path).\n-        // 2. No specific token is expected after the path segment.\n-        //    eg. `x.foo` (field access)\n-        //\n-        // This function is called after parsing `.foo` and before parsing the token `end` (if\n-        // present). This includes any angle bracket arguments, such as `.foo::<u32>` or\n-        // `Foo::<Bar>`.\n-\n-        // We only care about trailing angle brackets if we previously parsed angle bracket\n-        // arguments. This helps stop us incorrectly suggesting that extra angle brackets be\n-        // removed in this case:\n-        //\n-        // `x.foo >> (3)` (where `x.foo` is a `u32` for example)\n-        //\n-        // This case is particularly tricky as we won't notice it just looking at the tokens -\n-        // it will appear the same (in terms of upcoming tokens) as below (since the `::<u32>` will\n-        // have already been parsed):\n-        //\n-        // `x.foo::<u32>>>(3)`\n-        let parsed_angle_bracket_args = segment.args\n-            .as_ref()\n-            .map(|args| args.is_angle_bracketed())\n-            .unwrap_or(false);\n-\n-        debug!(\n-            \"check_trailing_angle_brackets: parsed_angle_bracket_args={:?}\",\n-            parsed_angle_bracket_args,\n-        );\n-        if !parsed_angle_bracket_args {\n-            return;\n-        }\n-\n-        // Keep the span at the start so we can highlight the sequence of `>` characters to be\n-        // removed.\n-        let lo = self.span;\n-\n-        // We need to look-ahead to see if we have `>` characters without moving the cursor forward\n-        // (since we might have the field access case and the characters we're eating are\n-        // actual operators and not trailing characters - ie `x.foo >> 3`).\n-        let mut position = 0;\n-\n-        // We can encounter `>` or `>>` tokens in any order, so we need to keep track of how\n-        // many of each (so we can correctly pluralize our error messages) and continue to\n-        // advance.\n-        let mut number_of_shr = 0;\n-        let mut number_of_gt = 0;\n-        while self.look_ahead(position, |t| {\n-            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n-            if *t == token::BinOp(token::BinOpToken::Shr) {\n-                number_of_shr += 1;\n-                true\n-            } else if *t == token::Gt {\n-                number_of_gt += 1;\n-                true\n-            } else {\n-                false\n-            }\n-        }) {\n-            position += 1;\n-        }\n-\n-        // If we didn't find any trailing `>` characters, then we have nothing to error about.\n-        debug!(\n-            \"check_trailing_angle_brackets: number_of_gt={:?} number_of_shr={:?}\",\n-            number_of_gt, number_of_shr,\n-        );\n-        if number_of_gt < 1 && number_of_shr < 1 {\n-            return;\n-        }\n-\n-        // Finally, double check that we have our end token as otherwise this is the\n-        // second case.\n-        if self.look_ahead(position, |t| {\n-            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n-            *t == end\n-        }) {\n-            // Eat from where we started until the end token so that parsing can continue\n-            // as if we didn't have those extra angle brackets.\n-            self.eat_to_tokens(&[&end]);\n-            let span = lo.until(self.span);\n-\n-            let plural = number_of_gt > 1 || number_of_shr >= 1;\n-            self.diagnostic()\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"unmatched angle bracket{}\", if plural { \"s\" } else { \"\" }),\n-                )\n-                .span_suggestion(\n-                    span,\n-                    &format!(\"remove extra angle bracket{}\", if plural { \"s\" } else { \"\" }),\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n-        }\n-    }\n-\n     fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         let mut e = e0;\n         let mut hi;\n@@ -3556,33 +3093,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Produce an error if comparison operators are chained (RFC #558).\n-    /// We only need to check lhs, not rhs, because all comparison ops\n-    /// have same precedence and are left-associative\n-    fn check_no_chained_comparison(&self, lhs: &Expr, outer_op: &AssocOp) {\n-        debug_assert!(outer_op.is_comparison(),\n-                      \"check_no_chained_comparison: {:?} is not comparison\",\n-                      outer_op);\n-        match lhs.node {\n-            ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n-                // respan to include both operators\n-                let op_span = op.span.to(self.span);\n-                let mut err = self.diagnostic().struct_span_err(op_span,\n-                    \"chained comparison operators require parentheses\");\n-                if op.node == BinOpKind::Lt &&\n-                    *outer_op == AssocOp::Less ||  // Include `<` to provide this recommendation\n-                    *outer_op == AssocOp::Greater  // even in a case like the following:\n-                {                                  //     Foo<Bar<Baz<Qux, ()>>>\n-                    err.help(\n-                        \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n-                    err.help(\"or use `(...)` if you meant to specify fn arguments\");\n-                }\n-                err.emit();\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     /// Parse prefix-forms of range notation: `..expr`, `..`, `..=expr`\n     fn parse_prefix_range_expr(&mut self,\n                                already_parsed_attrs: Option<ThinVec<Attribute>>)\n@@ -3609,7 +3119,7 @@ impl<'a> Parser<'a> {\n                     hi = x.span;\n                     x\n                 })?)\n-         } else {\n+        } else {\n             None\n         };\n         let limits = if tok == token::DotDot {\n@@ -3759,20 +3269,7 @@ impl<'a> Parser<'a> {\n             err.emit();\n         }\n         let in_span = self.prev_span;\n-        if self.eat_keyword(kw::In) {\n-            // a common typo: `for _ in in bar {}`\n-            let mut err = self.sess.span_diagnostic.struct_span_err(\n-                self.prev_span,\n-                \"expected iterable, found keyword `in`\",\n-            );\n-            err.span_suggestion_short(\n-                in_span.until(self.prev_span),\n-                \"remove the duplicated `in`\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n-        }\n+        self.check_for_for_in_in_typo(in_span);\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n@@ -6354,7 +5851,9 @@ impl<'a> Parser<'a> {\n             let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n-            let mut decl = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n+            let mut decl = self.parse_fn_decl_with_self(|p| {\n+                p.parse_arg_general(true, true, false)\n+            })?;\n             generics.where_clause = self.parse_where_clause()?;\n             self.construct_async_arguments(&mut asyncness, &mut decl);\n             *at_end = true;"}, {"sha": "a003a01941bdee3981b4cd322c7273d7be338f4e", "filename": "src/test/ui/invalid-self-argument/bare-fn-start.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs?ref=24cc368118e434719bee711ad34f0a370b27231d", "patch": "@@ -1,5 +1,6 @@\n fn a(&self) { }\n-//~^ ERROR unexpected `self` argument in function\n-//~| NOTE `self` is only valid as the first argument of an associated function\n+//~^ ERROR unexpected `self` parameter in function\n+//~| NOTE not valid as function parameter\n+//~| NOTE `self` is only valid as the first parameter of an associated function\n \n fn main() { }"}, {"sha": "23de6502094f0e7cf5093f4c92e75980856d1475", "filename": "src/test/ui/invalid-self-argument/bare-fn-start.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr?ref=24cc368118e434719bee711ad34f0a370b27231d", "patch": "@@ -1,8 +1,10 @@\n-error: unexpected `self` argument in function\n-  --> $DIR/bare-fn-start.rs:1:7\n+error: unexpected `self` parameter in function\n+  --> $DIR/bare-fn-start.rs:1:6\n    |\n LL | fn a(&self) { }\n-   |       ^^^^ `self` is only valid as the first argument of an associated function\n+   |      ^^^^^ not valid as function parameter\n+   |\n+   = note: `self` is only valid as the first parameter of an associated function\n \n error: aborting due to previous error\n "}, {"sha": "73d68e8b7a5ab340375bb570688a08f734313d92", "filename": "src/test/ui/invalid-self-argument/bare-fn.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs?ref=24cc368118e434719bee711ad34f0a370b27231d", "patch": "@@ -1,5 +1,6 @@\n fn b(foo: u32, &mut self) { }\n-//~^ ERROR unexpected `self` argument in function\n-//~| NOTE `self` is only valid as the first argument of an associated function\n+//~^ ERROR unexpected `self` parameter in function\n+//~| NOTE not valid as function parameter\n+//~| NOTE `self` is only valid as the first parameter of an associated function\n \n fn main() { }"}, {"sha": "601a51bb4a96a4b8f535477acf4ade088d69e4bc", "filename": "src/test/ui/invalid-self-argument/bare-fn.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr?ref=24cc368118e434719bee711ad34f0a370b27231d", "patch": "@@ -1,8 +1,10 @@\n-error: unexpected `self` argument in function\n-  --> $DIR/bare-fn.rs:1:21\n+error: unexpected `self` parameter in function\n+  --> $DIR/bare-fn.rs:1:16\n    |\n LL | fn b(foo: u32, &mut self) { }\n-   |                     ^^^^ `self` is only valid as the first argument of an associated function\n+   |                ^^^^^^^^^ not valid as function parameter\n+   |\n+   = note: `self` is only valid as the first parameter of an associated function\n \n error: aborting due to previous error\n "}, {"sha": "1e8220d7b4a781743c41f810a3f3957a9e2f7479", "filename": "src/test/ui/invalid-self-argument/trait-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs?ref=24cc368118e434719bee711ad34f0a370b27231d", "patch": "@@ -2,8 +2,8 @@ struct Foo {}\n \n impl Foo {\n     fn c(foo: u32, self) {}\n-    //~^ ERROR unexpected `self` argument in function\n-    //~| NOTE `self` is only valid as the first argument of an associated function\n+    //~^ ERROR unexpected `self` parameter in function\n+    //~| NOTE must be the first associated function parameter\n \n     fn good(&mut self, foo: u32) {}\n }"}, {"sha": "96a2251c036b19658c016a5f6dab9110e7219c60", "filename": "src/test/ui/invalid-self-argument/trait-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr?ref=24cc368118e434719bee711ad34f0a370b27231d", "patch": "@@ -1,8 +1,8 @@\n-error: unexpected `self` argument in function\n+error: unexpected `self` parameter in function\n   --> $DIR/trait-fn.rs:4:20\n    |\n LL |     fn c(foo: u32, self) {}\n-   |                    ^^^^ `self` is only valid as the first argument of an associated function\n+   |                    ^^^^ must be the first associated function parameter\n \n error: aborting due to previous error\n "}, {"sha": "6172ffe1b0347aee9440f8a84b15ea04a82c93b2", "filename": "src/test/ui/parser/self-in-function-arg.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.rs?ref=24cc368118e434719bee711ad34f0a370b27231d", "patch": "@@ -0,0 +1,3 @@\n+fn foo(x:i32, self: i32) -> i32 { self } //~ ERROR unexpected `self` parameter in function\n+\n+fn main() {}"}, {"sha": "f58df9b9e79b327a20c0c389d42b7affd2a3d444", "filename": "src/test/ui/parser/self-in-function-arg.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/24cc368118e434719bee711ad34f0a370b27231d/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.stderr?ref=24cc368118e434719bee711ad34f0a370b27231d", "patch": "@@ -0,0 +1,10 @@\n+error: unexpected `self` parameter in function\n+  --> $DIR/self-in-function-arg.rs:1:15\n+   |\n+LL | fn foo(x:i32, self: i32) -> i32 { self }\n+   |               ^^^^ not valid as function parameter\n+   |\n+   = note: `self` is only valid as the first parameter of an associated function\n+\n+error: aborting due to previous error\n+"}]}