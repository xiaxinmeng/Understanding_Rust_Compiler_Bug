{"sha": "b8398d947d160ad4f26cc22da66e5fbc7030817b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4Mzk4ZDk0N2QxNjBhZDRmMjZjYzIyZGE2NmU1ZmJjNzAzMDgxN2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-11T18:11:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-11T18:11:01Z"}, "message": "Auto merge of #47752 - mark-i-m:at-most-once-rep, r=nikomatsakis\n\nImplement `?` macro repetition\n\nSee rust-lang/rfcs#2298 (with disposition merge)", "tree": {"sha": "915e92eb58e30190ca3fa21aa4c8dc72e3e99438", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/915e92eb58e30190ca3fa21aa4c8dc72e3e99438"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8398d947d160ad4f26cc22da66e5fbc7030817b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8398d947d160ad4f26cc22da66e5fbc7030817b", "html_url": "https://github.com/rust-lang/rust/commit/b8398d947d160ad4f26cc22da66e5fbc7030817b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8398d947d160ad4f26cc22da66e5fbc7030817b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0196b20f6943963fd7598c0486ce3f58189c04d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0196b20f6943963fd7598c0486ce3f58189c04d1", "html_url": "https://github.com/rust-lang/rust/commit/0196b20f6943963fd7598c0486ce3f58189c04d1"}, {"sha": "b92e542ddd41affaf6fb5d1267b8e8dfc03089a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b92e542ddd41affaf6fb5d1267b8e8dfc03089a5", "html_url": "https://github.com/rust-lang/rust/commit/b92e542ddd41affaf6fb5d1267b8e8dfc03089a5"}], "stats": {"total": 430, "additions": 374, "deletions": 56}, "files": [{"sha": "dbaf91b6e78b2a1236bf5f6853a864571c5d219d", "filename": "src/doc/unstable-book/src/language-features/macro-at-most-once-rep.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -0,0 +1,17 @@\n+# `macro_at_most_once_rep`\n+\n+The tracking issue for this feature is: TODO(mark-i-m)\n+\n+With this feature gate enabled, one can use `?` as a Kleene operator meaning \"0\n+or 1 repetitions\" in a macro definition. Previously only `+` and `*` were allowed.\n+\n+For example:\n+```rust\n+macro_rules! foo {\n+    (something $(,)?) // `?` indicates `,` is \"optional\"...\n+        => {}\n+}\n+```\n+\n+------------------------\n+"}, {"sha": "0621f728e2a9d0fa6a33988977c9e618c9a63959", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -181,6 +181,8 @@ struct MatcherPos {\n     match_hi: usize,\n \n     // Specifically used if we are matching a repetition. If we aren't both should be `None`.\n+    /// The KleeneOp of this sequence if we are in a repetition.\n+    seq_op: Option<quoted::KleeneOp>,\n     /// The separator if we are in a repetition\n     sep: Option<Token>,\n     /// The \"parent\" matcher position if we are in a repetition. That is, the matcher position just\n@@ -263,6 +265,7 @@ fn initial_matcher_pos(ms: Vec<TokenTree>, lo: BytePos) -> Box<MatcherPos> {\n         stack: vec![],\n \n         // Haven't descended into any sequences, so both of these are `None`.\n+        seq_op: None,\n         sep: None,\n         up: None,\n     })\n@@ -466,8 +469,8 @@ fn inner_parse_loop(\n                     }\n                 }\n                 // We don't need a separator. Move the \"dot\" back to the beginning of the matcher\n-                // and try to match again.\n-                else {\n+                // and try to match again UNLESS we are only allowed to have _one_ repetition.\n+                else if item.seq_op != Some(quoted::KleeneOp::ZeroOrOne) {\n                     item.match_cur = item.match_lo;\n                     item.idx = 0;\n                     cur_items.push(item);\n@@ -486,8 +489,10 @@ fn inner_parse_loop(\n             match item.top_elts.get_tt(idx) {\n                 // Need to descend into a sequence\n                 TokenTree::Sequence(sp, seq) => {\n-                    if seq.op == quoted::KleeneOp::ZeroOrMore {\n-                        // Examine the case where there are 0 matches of this sequence\n+                    // Examine the case where there are 0 matches of this sequence\n+                    if seq.op == quoted::KleeneOp::ZeroOrMore\n+                        || seq.op == quoted::KleeneOp::ZeroOrOne\n+                    {\n                         let mut new_item = item.clone();\n                         new_item.match_cur += seq.num_captures;\n                         new_item.idx += 1;\n@@ -497,11 +502,11 @@ fn inner_parse_loop(\n                         cur_items.push(new_item);\n                     }\n \n-                    // Examine the case where there is at least one match of this sequence\n                     let matches = create_matches(item.matches.len());\n                     cur_items.push(Box::new(MatcherPos {\n                         stack: vec![],\n                         sep: seq.separator.clone(),\n+                        seq_op: Some(seq.op),\n                         idx: 0,\n                         matches,\n                         match_lo: item.match_cur,"}, {"sha": "5254c751e6b621b500e1620f320aebda91eb7020", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -237,7 +237,8 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n             s.iter().map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n+                        let tt = quoted::parse(tt.clone().into(), true, sess, features, &def.attrs)\n+                            .pop().unwrap();\n                         valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n@@ -253,7 +254,8 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n             s.iter().map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return quoted::parse(tt.clone().into(), false, sess).pop().unwrap();\n+                        return quoted::parse(tt.clone().into(), false, sess, features, &def.attrs)\n+                            .pop().unwrap();\n                     }\n                 }\n                 sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")"}, {"sha": "982b60b81e47ec7a62219d4889288dc0f8997bd5", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 157, "deletions": 46, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n+use {ast, attr};\n use ext::tt::macro_parser;\n+use feature_gate::{self, emit_feature_err, Features, GateIssue};\n use parse::{token, ParseSess};\n use print::pprust;\n use symbol::keywords;\n use syntax_pos::{BytePos, Span, DUMMY_SP};\n use tokenstream;\n \n+use std::cell::RefCell;\n+use std::iter::Peekable;\n use std::rc::Rc;\n \n /// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n@@ -78,6 +81,7 @@ pub enum KleeneOp {\n     ZeroOrMore,\n     /// Kleene plus (`+`) for one or more repetitions\n     OneOrMore,\n+    ZeroOrOne,\n }\n \n /// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, and `$(...)`\n@@ -169,6 +173,8 @@ impl TokenTree {\n ///   `ident` are \"matchers\". They are not present in the body of a macro rule -- just in the\n ///   pattern, so we pass a parameter to indicate whether to expect them or not.\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n+/// - `features`, `attrs`: language feature flags and attributes so that we know whether to use\n+///   unstable features or not.\n ///\n /// # Returns\n ///\n@@ -177,18 +183,19 @@ pub fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,\n+    features: &RefCell<Features>,\n+    attrs: &[ast::Attribute],\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n \n     // For each token tree in `input`, parse the token into a `self::TokenTree`, consuming\n     // additional trees if need be.\n-    let mut trees = input.trees();\n+    let mut trees = input.trees().peekable();\n     while let Some(tree) = trees.next() {\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess);\n-\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e. in `$id:ident` this would parse the `:` and `ident`).\n+        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, features, attrs);\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -237,11 +244,15 @@ pub fn parse(\n ///   converting `tree`\n /// - `expect_matchers`: same as for `parse` (see above).\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n+/// - `features`, `attrs`: language feature flags and attributes so that we know whether to use\n+///   unstable features or not.\n fn parse_tree<I>(\n     tree: tokenstream::TokenTree,\n-    trees: &mut I,\n+    trees: &mut Peekable<I>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n+    features: &RefCell<Features>,\n+    attrs: &[ast::Attribute],\n ) -> TokenTree\n where\n     I: Iterator<Item = tokenstream::TokenTree>,\n@@ -260,9 +271,9 @@ where\n                     sess.span_diagnostic.span_err(span, &msg);\n                 }\n                 // Parse the contents of the sequence itself\n-                let sequence = parse(delimited.tts.into(), expect_matchers, sess);\n+                let sequence = parse(delimited.tts.into(), expect_matchers, sess, features, attrs);\n                 // Get the Kleene operator and optional separator\n-                let (separator, op) = parse_sep_and_kleene_op(trees, span, sess);\n+                let (separator, op) = parse_sep_and_kleene_op(trees, span, sess, features, attrs);\n                 // Count the number of captured \"names\" (i.e. named metavars)\n                 let name_captures = macro_parser::count_names(&sequence);\n                 TokenTree::Sequence(\n@@ -315,12 +326,46 @@ where\n             span,\n             Rc::new(Delimited {\n                 delim: delimited.delim,\n-                tts: parse(delimited.tts.into(), expect_matchers, sess),\n+                tts: parse(delimited.tts.into(), expect_matchers, sess, features, attrs),\n             }),\n         ),\n     }\n }\n \n+/// Takes a token and returns `Some(KleeneOp)` if the token is `+` `*` or `?`. Otherwise, return\n+/// `None`.\n+fn kleene_op(token: &token::Token) -> Option<KleeneOp> {\n+    match *token {\n+        token::BinOp(token::Star) => Some(KleeneOp::ZeroOrMore),\n+        token::BinOp(token::Plus) => Some(KleeneOp::OneOrMore),\n+        token::Question => Some(KleeneOp::ZeroOrOne),\n+        _ => None,\n+    }\n+}\n+\n+/// Parse the next token tree of the input looking for a KleeneOp. Returns\n+///\n+/// - Ok(Ok(op)) if the next token tree is a KleeneOp\n+/// - Ok(Err(tok, span)) if the next token tree is a token but not a KleeneOp\n+/// - Err(span) if the next token tree is not a token\n+fn parse_kleene_op<I>(\n+    input: &mut I,\n+    span: Span,\n+) -> Result<Result<KleeneOp, (token::Token, Span)>, Span>\n+where\n+    I: Iterator<Item = tokenstream::TokenTree>,\n+{\n+    match input.next() {\n+        Some(tokenstream::TokenTree::Token(span, tok)) => match kleene_op(&tok) {\n+            Some(op) => Ok(Ok(op)),\n+            None => Ok(Err((tok, span))),\n+        },\n+        tree => Err(tree.as_ref()\n+            .map(tokenstream::TokenTree::span)\n+            .unwrap_or(span)),\n+    }\n+}\n+\n /// Attempt to parse a single Kleene star, possibly with a separator.\n ///\n /// For example, in a pattern such as `$(a),*`, `a` is the pattern to be repeated, `,` is the\n@@ -334,55 +379,121 @@ where\n /// operator and separator, then a tuple with `(separator, KleeneOp)` is returned. Otherwise, an\n /// error with the appropriate span is emitted to `sess` and a dummy value is returned.\n fn parse_sep_and_kleene_op<I>(\n-    input: &mut I,\n+    input: &mut Peekable<I>,\n     span: Span,\n     sess: &ParseSess,\n+    features: &RefCell<Features>,\n+    attrs: &[ast::Attribute],\n ) -> (Option<token::Token>, KleeneOp)\n where\n     I: Iterator<Item = tokenstream::TokenTree>,\n {\n-    fn kleene_op(token: &token::Token) -> Option<KleeneOp> {\n-        match *token {\n-            token::BinOp(token::Star) => Some(KleeneOp::ZeroOrMore),\n-            token::BinOp(token::Plus) => Some(KleeneOp::OneOrMore),\n-            _ => None,\n+    // We basically look at two token trees here, denoted as #1 and #2 below\n+    let span = match parse_kleene_op(input, span) {\n+        // #1 is a `+` or `*` KleeneOp\n+        //\n+        // `?` is ambiguous: it could be a separator or a Kleene::ZeroOrOne, so we need to look\n+        // ahead one more token to be sure.\n+        Ok(Ok(op)) if op != KleeneOp::ZeroOrOne => return (None, op),\n+\n+        // #1 is `?` token, but it could be a Kleene::ZeroOrOne without a separator or it could\n+        // be a `?` separator followed by any Kleene operator. We need to look ahead 1 token to\n+        // find out which.\n+        Ok(Ok(op)) => {\n+            assert_eq!(op, KleeneOp::ZeroOrOne);\n+\n+            // Lookahead at #2. If it is a KleenOp, then #1 is a separator.\n+            let is_1_sep = if let Some(&tokenstream::TokenTree::Token(_, ref tok2)) = input.peek() {\n+                kleene_op(tok2).is_some()\n+            } else {\n+                false\n+            };\n+\n+            if is_1_sep {\n+                // #1 is a separator and #2 should be a KleepeOp::*\n+                // (N.B. We need to advance the input iterator.)\n+                match parse_kleene_op(input, span) {\n+                    // #2 is a KleeneOp (this is the only valid option) :)\n+                    Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n+                        if !features.borrow().macro_at_most_once_rep\n+                            && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+                        {\n+                            let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n+                            emit_feature_err(\n+                                sess,\n+                                \"macro_at_most_once_rep\",\n+                                span,\n+                                GateIssue::Language,\n+                                explain,\n+                            );\n+                        }\n+                        return (Some(token::Question), op);\n+                    }\n+                    Ok(Ok(op)) => return (Some(token::Question), op),\n+\n+                    // #2 is a random token (this is an error) :(\n+                    Ok(Err((_, span))) => span,\n+\n+                    // #2 is not even a token at all :(\n+                    Err(span) => span,\n+                }\n+            } else {\n+                if !features.borrow().macro_at_most_once_rep\n+                    && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+                {\n+                    let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n+                    emit_feature_err(\n+                        sess,\n+                        \"macro_at_most_once_rep\",\n+                        span,\n+                        GateIssue::Language,\n+                        explain,\n+                    );\n+                }\n+\n+                // #2 is a random tree and #1 is KleeneOp::ZeroOrOne\n+                return (None, op);\n+            }\n         }\n-    }\n \n-    // We attempt to look at the next two token trees in `input`. I will call the first #1 and the\n-    // second #2. If #1 and #2 don't match a valid KleeneOp with/without separator, that is an\n-    // error, and we should emit an error on the most specific span possible.\n-    let span = match input.next() {\n-        // #1 is a token\n-        Some(tokenstream::TokenTree::Token(span, tok)) => match kleene_op(&tok) {\n-            // #1 is a KleeneOp with no separator\n-            Some(op) => return (None, op),\n-\n-            // #1 is not a KleeneOp, but may be a separator... need to look at #2\n-            None => match input.next() {\n-                // #2 is a token\n-                Some(tokenstream::TokenTree::Token(span, tok2)) => match kleene_op(&tok2) {\n-                    // #2 is a KleeneOp, so #1 must be a separator\n-                    Some(op) => return (Some(tok), op),\n-\n-                    // #2 is not a KleeneOp... error\n-                    None => span,\n-                },\n-\n-                // #2 is not a token at all... error\n-                tree => tree.as_ref()\n-                    .map(tokenstream::TokenTree::span)\n-                    .unwrap_or(span),\n-            },\n+        // #1 is a separator followed by #2, a KleeneOp\n+        Ok(Err((tok, span))) => match parse_kleene_op(input, span) {\n+            // #2 is a KleeneOp :D\n+            Ok(Ok(op)) if op == KleeneOp::ZeroOrOne => {\n+                if !features.borrow().macro_at_most_once_rep\n+                    && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+                {\n+                    let explain = feature_gate::EXPLAIN_MACRO_AT_MOST_ONCE_REP;\n+                    emit_feature_err(\n+                        sess,\n+                        \"macro_at_most_once_rep\",\n+                        span,\n+                        GateIssue::Language,\n+                        explain,\n+                    );\n+                }\n+                return (Some(tok), op);\n+            }\n+            Ok(Ok(op)) => return (Some(tok), op),\n+\n+            // #2 is a random token :(\n+            Ok(Err((_, span))) => span,\n+\n+            // #2 is not a token at all :(\n+            Err(span) => span,\n         },\n \n-        // #1 is not a token at all... error\n-        tree => tree.as_ref()\n-            .map(tokenstream::TokenTree::span)\n-            .unwrap_or(span),\n+        // #1 is not a token\n+        Err(span) => span,\n     };\n \n-    // Error...\n-    sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");\n+    if !features.borrow().macro_at_most_once_rep\n+        && !attr::contains_name(attrs, \"allow_internal_unstable\")\n+    {\n+        sess.span_diagnostic\n+            .span_err(span, \"expected one of: `*`, `+`, or `?`\");\n+    } else {\n+        sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");\n+    }\n     (None, KleeneOp::ZeroOrMore)\n }"}, {"sha": "ea916d5168c335afa289e36f5f923500bc82a1b9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -446,6 +446,9 @@ declare_features! (\n \n     // Allows `#[repr(transparent)]` attribute on newtype structs\n     (active, repr_transparent, \"1.25.0\", Some(43036)),\n+\n+    // Use `?` as the Kleene \"at most one\" operator\n+    (active, macro_at_most_once_rep, \"1.25.0\", Some(48075)),\n );\n \n declare_features! (\n@@ -1258,6 +1261,9 @@ pub const EXPLAIN_PLACEMENT_IN: &'static str =\n pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &'static str =\n     \"Unsized tuple coercion is not stable enough for use and is subject to change\";\n \n+pub const EXPLAIN_MACRO_AT_MOST_ONCE_REP: &'static str =\n+    \"Using the `?` macro Kleene operator for \\\"at most one\\\" repetition is unstable\";\n+\n struct PostExpansionVisitor<'a> {\n     context: &'a Context<'a>,\n }"}, {"sha": "6da049374086a28cc65b793654c4eeb1e7b8e9cb", "filename": "src/test/compile-fail/issue-39388.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Fcompile-fail%2Fissue-39388.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Fcompile-fail%2Fissue-39388.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39388.rs?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -11,7 +11,7 @@\n #![allow(unused_macros)]\n \n macro_rules! assign {\n-    (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR expected `*` or `+`\n+    (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR expected one of: `*`, `+`, or `?`\n         $($a)* = $($b)*\n     }\n }"}, {"sha": "a5660f8b41f8da43aeeea29deefa8607dc764bf4", "filename": "src/test/compile-fail/macro-at-most-once-rep-ambig.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Fcompile-fail%2Fmacro-at-most-once-rep-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Fcompile-fail%2Fmacro-at-most-once-rep-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-at-most-once-rep-ambig.rs?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The logic for parsing Kleene operators in macros has a special case to disambiguate `?`.\n+// Specifically, `$(pat)?` is the ZeroOrOne operator whereas `$(pat)?+` or `$(pat)?*` are the\n+// ZeroOrMore and OneOrMore operators using `?` as a separator. These tests are intended to\n+// exercise that logic in the macro parser.\n+//\n+// Moreover, we also throw in some tests for using a separator with `?`, which is meaningless but\n+// included for consistency with `+` and `*`.\n+//\n+// This test focuses on error cases.\n+\n+#![feature(macro_at_most_once_rep)]\n+\n+macro_rules! foo {\n+    ($(a)?) => {}\n+}\n+\n+macro_rules! baz {\n+    ($(a),?) => {} // comma separator is meaningless for `?`\n+}\n+\n+macro_rules! barplus {\n+    ($(a)?+) => {}\n+}\n+\n+macro_rules! barstar {\n+    ($(a)?*) => {}\n+}\n+\n+pub fn main() {\n+    foo!(a?a?a); //~ ERROR no rules expected the token `?`\n+    foo!(a?a); //~ ERROR no rules expected the token `?`\n+    foo!(a?); //~ ERROR no rules expected the token `?`\n+    baz!(a?a?a); //~ ERROR no rules expected the token `?`\n+    baz!(a?a); //~ ERROR no rules expected the token `?`\n+    baz!(a?); //~ ERROR no rules expected the token `?`\n+    baz!(a,); //~ ERROR unexpected end of macro invocation\n+    baz!(a?a?a,); //~ ERROR no rules expected the token `?`\n+    baz!(a?a,); //~ ERROR no rules expected the token `?`\n+    baz!(a?,); //~ ERROR no rules expected the token `?`\n+    barplus!(); //~ ERROR unexpected end of macro invocation\n+    barplus!(a?); //~ ERROR unexpected end of macro invocation\n+    barstar!(a?); //~ ERROR unexpected end of macro invocation\n+}"}, {"sha": "af90d0a83c926c86e8f9519cc8c87a32a8ace65e", "filename": "src/test/parse-fail/issue-33569.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Fparse-fail%2Fissue-33569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Fparse-fail%2Fissue-33569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-33569.rs?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -13,7 +13,7 @@\n macro_rules! foo {\n     { $+ } => { //~ ERROR expected identifier, found `+`\n                 //~^ ERROR missing fragment specifier\n-        $(x)(y) //~ ERROR expected `*` or `+`\n+        $(x)(y) //~ ERROR expected one of: `*`, `+`, or `?`\n     }\n }\n "}, {"sha": "9ebc438ad5a0071e8bed7f8c1c902845adf47743", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -18,6 +18,7 @@ extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n+use syntax::feature_gate::Features;\n use syntax::parse::token::{NtExpr, NtPat};\n use syntax::ast::{Ident, Pat};\n use syntax::tokenstream::{TokenTree};\n@@ -31,11 +32,17 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n+use std::cell::RefCell;\n+\n fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n         -> Box<MacResult + 'static> {\n \n     let mbe_matcher = quote_tokens!(cx, $$matched:expr, $$($$pat:pat)|+);\n-    let mbe_matcher = quoted::parse(mbe_matcher.into_iter().collect(), true, cx.parse_sess);\n+    let mbe_matcher = quoted::parse(mbe_matcher.into_iter().collect(),\n+                                    true,\n+                                    cx.parse_sess,\n+                                    &RefCell::new(Features::new()),\n+                                    &[]);\n     let map = match TokenTree::parse(cx, &mbe_matcher, args.iter().cloned().collect()) {\n         Success(map) => map,\n         Failure(_, tok) => {"}, {"sha": "b7e942f938321ae8f033a65909cea38975d856e2", "filename": "src/test/run-pass/macro-at-most-once-rep.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-at-most-once-rep.rs?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The logic for parsing Kleene operators in macros has a special case to disambiguate `?`.\n+// Specifically, `$(pat)?` is the ZeroOrOne operator whereas `$(pat)?+` or `$(pat)?*` are the\n+// ZeroOrMore and OneOrMore operators using `?` as a separator. These tests are intended to\n+// exercise that logic in the macro parser.\n+//\n+// Moreover, we also throw in some tests for using a separator with `?`, which is meaningless but\n+// included for consistency with `+` and `*`.\n+//\n+// This test focuses on non-error cases and making sure the correct number of repetitions happen.\n+\n+#![feature(macro_at_most_once_rep)]\n+\n+macro_rules! foo {\n+    ($($a:ident)? ; $num:expr) => { {\n+        let mut x = 0;\n+\n+        $(\n+            x += $a;\n+         )?\n+\n+        assert_eq!(x, $num);\n+    } }\n+}\n+\n+macro_rules! baz {\n+    ($($a:ident),? ; $num:expr) => { { // comma separator is meaningless for `?`\n+        let mut x = 0;\n+\n+        $(\n+            x += $a;\n+         )?\n+\n+        assert_eq!(x, $num);\n+    } }\n+}\n+\n+macro_rules! barplus {\n+    ($($a:ident)?+ ; $num:expr) => { {\n+        let mut x = 0;\n+\n+        $(\n+            x += $a;\n+         )+\n+\n+        assert_eq!(x, $num);\n+    } }\n+}\n+\n+macro_rules! barstar {\n+    ($($a:ident)?* ; $num:expr) => { {\n+        let mut x = 0;\n+\n+        $(\n+            x += $a;\n+         )*\n+\n+        assert_eq!(x, $num);\n+    } }\n+}\n+\n+pub fn main() {\n+    let a = 1;\n+\n+    // accept 0 or 1 repetitions\n+    foo!( ; 0);\n+    foo!(a ; 1);\n+    baz!( ; 0);\n+    baz!(a ; 1);\n+\n+    // Make sure using ? as a separator works as before\n+    barplus!(a ; 1);\n+    barplus!(a?a ; 2);\n+    barplus!(a?a?a ; 3);\n+    barstar!( ; 0);\n+    barstar!(a ; 1);\n+    barstar!(a?a ; 2);\n+    barstar!(a?a?a ; 3);\n+}"}, {"sha": "19f5aca5730e1b18d0f2b4ae83462de391378d25", "filename": "src/test/ui/feature-gate-macro_at_most_once_rep.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.rs?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `?` macro Kleene operator can not be used when the `macro_at_most_once_rep` feature\n+// gate is not used.\n+\n+macro_rules! m { ($(a)?) => {} }\n+//~^ ERROR Using the `?` macro Kleene operator for \"at most one\" repetition is unstable\n+\n+fn main() {\n+    m!();\n+}"}, {"sha": "02dbab07bdeccd6bbba96bf2aee7c20abc453b30", "filename": "src/test/ui/feature-gate-macro_at_most_once_rep.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8398d947d160ad4f26cc22da66e5fbc7030817b/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macro_at_most_once_rep.stderr?ref=b8398d947d160ad4f26cc22da66e5fbc7030817b", "patch": "@@ -0,0 +1,10 @@\n+error[E0658]: Using the `?` macro Kleene operator for \"at most one\" repetition is unstable (see issue #48075)\n+  --> $DIR/feature-gate-macro_at_most_once_rep.rs:14:20\n+   |\n+14 | macro_rules! m { ($(a)?) => {} }\n+   |                    ^^^\n+   |\n+   = help: add #![feature(macro_at_most_once_rep)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}]}