{"sha": "d737ea7902fb10fd3161d8001ceaec70ebe074d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MzdlYTc5MDJmYjEwZmQzMTYxZDgwMDFjZWFlYzcwZWJlMDc0ZDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-11T14:00:05Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-11T14:00:05Z"}, "message": "resolve_lifetime: rustfmt", "tree": {"sha": "6777406cc0aaf8f450810ef5427469e55220f9a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6777406cc0aaf8f450810ef5427469e55220f9a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d737ea7902fb10fd3161d8001ceaec70ebe074d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d737ea7902fb10fd3161d8001ceaec70ebe074d2", "html_url": "https://github.com/rust-lang/rust/commit/d737ea7902fb10fd3161d8001ceaec70ebe074d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d737ea7902fb10fd3161d8001ceaec70ebe074d2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33245fe682874fd138bb6d49b9e5d72e5b915800", "url": "https://api.github.com/repos/rust-lang/rust/commits/33245fe682874fd138bb6d49b9e5d72e5b915800", "html_url": "https://github.com/rust-lang/rust/commit/33245fe682874fd138bb6d49b9e5d72e5b915800"}], "stats": {"total": 1197, "additions": 721, "deletions": 476}, "files": [{"sha": "96e537eedacb4f8c5ef6b7657a271b31531efb17", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 721, "deletions": 476, "changes": 1197, "blob_url": "https://github.com/rust-lang/rust/blob/d737ea7902fb10fd3161d8001ceaec70ebe074d2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d737ea7902fb10fd3161d8001ceaec70ebe074d2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d737ea7902fb10fd3161d8001ceaec70ebe074d2", "patch": "@@ -30,11 +30,11 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n use util::common::ErrorReported;\n-use util::nodemap::{NodeMap, NodeSet, FxHashSet, FxHashMap, DefIdMap};\n+use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n use std::slice;\n \n use hir;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use hir::intravisit::{self, NestedVisitorMap, Visitor};\n \n /// The origin of a named lifetime definition.\n ///\n@@ -60,16 +60,26 @@ impl LifetimeDefOrigin {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum Region {\n     Static,\n-    EarlyBound(/* index */ u32, /* lifetime decl */ DefId, LifetimeDefOrigin),\n-    LateBound(ty::DebruijnIndex, /* lifetime decl */ DefId, LifetimeDefOrigin),\n+    EarlyBound(\n+        /* index */ u32,\n+        /* lifetime decl */ DefId,\n+        LifetimeDefOrigin,\n+    ),\n+    LateBound(\n+        ty::DebruijnIndex,\n+        /* lifetime decl */ DefId,\n+        LifetimeDefOrigin,\n+    ),\n     LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n \n impl Region {\n-    fn early(hir_map: &Map, index: &mut u32, def: &hir::LifetimeDef)\n-        -> (hir::LifetimeName, Region)\n-    {\n+    fn early(\n+        hir_map: &Map,\n+        index: &mut u32,\n+        def: &hir::LifetimeDef,\n+    ) -> (hir::LifetimeName, Region) {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(def.lifetime.id);\n@@ -94,12 +104,11 @@ impl Region {\n \n     fn id(&self) -> Option<DefId> {\n         match *self {\n-            Region::Static |\n-            Region::LateBoundAnon(..) => None,\n+            Region::Static | Region::LateBoundAnon(..) => None,\n \n-            Region::EarlyBound(_, id, _) |\n-            Region::LateBound(_, id, _) |\n-            Region::Free(_, id) => Some(id)\n+            Region::EarlyBound(_, id, _) | Region::LateBound(_, id, _) | Region::Free(_, id) => {\n+                Some(id)\n+            }\n         }\n     }\n \n@@ -111,32 +120,34 @@ impl Region {\n             Region::LateBoundAnon(depth, index) => {\n                 Region::LateBoundAnon(depth.shifted(amount), index)\n             }\n-            _ => self\n+            _ => self,\n         }\n     }\n \n     fn from_depth(self, depth: u32) -> Region {\n         match self {\n-            Region::LateBound(debruijn, id, origin) => {\n-                Region::LateBound(ty::DebruijnIndex {\n-                    depth: debruijn.depth - (depth - 1)\n-                }, id, origin)\n-            }\n-            Region::LateBoundAnon(debruijn, index) => {\n-                Region::LateBoundAnon(ty::DebruijnIndex {\n-                    depth: debruijn.depth - (depth - 1)\n-                }, index)\n-            }\n-            _ => self\n+            Region::LateBound(debruijn, id, origin) => Region::LateBound(\n+                ty::DebruijnIndex {\n+                    depth: debruijn.depth - (depth - 1),\n+                },\n+                id,\n+                origin,\n+            ),\n+            Region::LateBoundAnon(debruijn, index) => Region::LateBoundAnon(\n+                ty::DebruijnIndex {\n+                    depth: debruijn.depth - (depth - 1),\n+                },\n+                index,\n+            ),\n+            _ => self,\n         }\n     }\n \n-    fn subst(self, params: &[hir::Lifetime], map: &NamedRegionMap)\n-             -> Option<Region> {\n+    fn subst(self, params: &[hir::Lifetime], map: &NamedRegionMap) -> Option<Region> {\n         if let Region::EarlyBound(index, _, _) = self {\n-            params.get(index as usize).and_then(|lifetime| {\n-                map.defs.get(&lifetime.id).cloned()\n-            })\n+            params\n+                .get(index as usize)\n+                .and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n         } else {\n             Some(self)\n         }\n@@ -150,7 +161,7 @@ impl Region {\n pub enum Set1<T> {\n     Empty,\n     One(T),\n-    Many\n+    Many,\n }\n \n impl<T: PartialEq> Set1<T> {\n@@ -233,7 +244,7 @@ enum Scope<'a> {\n         /// we should use for an early-bound region?\n         next_early_index: u32,\n \n-        s: ScopeRef<'a>\n+        s: ScopeRef<'a>,\n     },\n \n     /// Lifetimes introduced by a fn are scoped to the call-site for that fn,\n@@ -242,25 +253,25 @@ enum Scope<'a> {\n     /// e.g. `(&T, fn(&T) -> &T);` becomes `(&'_ T, for<'a> fn(&'a T) -> &'a T)`.\n     Body {\n         id: hir::BodyId,\n-        s: ScopeRef<'a>\n+        s: ScopeRef<'a>,\n     },\n \n     /// A scope which either determines unspecified lifetimes or errors\n     /// on them (e.g. due to ambiguity). For more details, see `Elide`.\n     Elision {\n         elide: Elide,\n-        s: ScopeRef<'a>\n+        s: ScopeRef<'a>,\n     },\n \n     /// Use a specific lifetime (if `Some`) or leave it unset (to be\n     /// inferred in a function body or potentially error outside one),\n     /// for the default choice of lifetime in a trait object type.\n     ObjectLifetimeDefault {\n         lifetime: Option<Region>,\n-        s: ScopeRef<'a>\n+        s: ScopeRef<'a>,\n     },\n \n-    Root\n+    Root,\n }\n \n #[derive(Clone, Debug)]\n@@ -271,7 +282,7 @@ enum Elide {\n     /// Always use this one lifetime.\n     Exact(Region),\n     /// Less or more than one lifetime were found, error on unspecified.\n-    Error(Vec<ElisionFailureInfo>)\n+    Error(Vec<ElisionFailureInfo>),\n }\n \n #[derive(Clone, Debug)]\n@@ -281,17 +292,18 @@ struct ElisionFailureInfo {\n     /// The index of the argument in the original definition.\n     index: usize,\n     lifetime_count: usize,\n-    have_bound_regions: bool\n+    have_bound_regions: bool,\n }\n \n type ScopeRef<'a> = &'a Scope<'a>;\n \n const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n \n-pub fn krate(sess: &Session,\n-             cstore: &CrateStore,\n-             hir_map: &Map)\n-             -> Result<NamedRegionMap, ErrorReported> {\n+pub fn krate(\n+    sess: &Session,\n+    cstore: &CrateStore,\n+    hir_map: &Map,\n+) -> Result<NamedRegionMap, ErrorReported> {\n     let krate = hir_map.krate();\n     let mut map = NamedRegionMap {\n         defs: NodeMap(),\n@@ -330,9 +342,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n         let body = self.hir_map.body(body);\n         extract_labels(self, body);\n-        self.with(Scope::Body { id: body.id(), s: self.scope }, |_, this| {\n-            this.visit_body(body);\n-        });\n+        self.with(\n+            Scope::Body {\n+                id: body.id(),\n+                s: self.scope,\n+            },\n+            |_, this| {\n+                this.visit_body(body);\n+            },\n+        );\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n@@ -343,44 +361,45 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemAutoImpl(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) => {\n+            hir::ItemExternCrate(_)\n+            | hir::ItemUse(..)\n+            | hir::ItemMod(..)\n+            | hir::ItemAutoImpl(..)\n+            | hir::ItemForeignMod(..)\n+            | hir::ItemGlobalAsm(..) => {\n                 // These sorts of items have no lifetime parameters at all.\n                 intravisit::walk_item(self, item);\n             }\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) => {\n+            hir::ItemStatic(..) | hir::ItemConst(..) => {\n                 // No lifetime parameters, but implied 'static.\n                 let scope = Scope::Elision {\n                     elide: Elide::Exact(Region::Static),\n-                    s: ROOT_SCOPE\n+                    s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemTy(_, ref generics) |\n-            hir::ItemEnum(_, ref generics) |\n-            hir::ItemStruct(_, ref generics) |\n-            hir::ItemUnion(_, ref generics) |\n-            hir::ItemTrait(_, _, ref generics, ..) |\n-            hir::ItemImpl(_, _, _, ref generics, ..) => {\n+            hir::ItemTy(_, ref generics)\n+            | hir::ItemEnum(_, ref generics)\n+            | hir::ItemStruct(_, ref generics)\n+            | hir::ItemUnion(_, ref generics)\n+            | hir::ItemTrait(_, _, ref generics, ..)\n+            | hir::ItemImpl(_, _, _, ref generics, ..) => {\n                 // These kinds of items have only early bound lifetime parameters.\n                 let mut index = if let hir::ItemTrait(..) = item.node {\n                     1 // Self comes before lifetimes\n                 } else {\n                     0\n                 };\n-                let lifetimes = generics.lifetimes.iter().map(|def| {\n-                    Region::early(self.hir_map, &mut index, def)\n-                }).collect();\n+                let lifetimes = generics\n+                    .lifetimes\n+                    .iter()\n+                    .map(|def| Region::early(self.hir_map, &mut index, def))\n+                    .collect();\n                 let next_early_index = index + generics.ty_params.len() as u32;\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n-                    s: ROOT_SCOPE\n+                    s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_defs(old_scope, &generics.lifetimes);\n@@ -414,11 +433,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n                 self.is_in_fn_syntax = true;\n                 let scope = Scope::Binder {\n-                    lifetimes: c.lifetimes.iter().map(|def| {\n-                        Region::late(self.hir_map, def)\n-                    }).collect(),\n+                    lifetimes: c.lifetimes\n+                        .iter()\n+                        .map(|def| Region::late(self.hir_map, def))\n+                        .collect(),\n                     next_early_index,\n-                    s: self.scope\n+                    s: self.scope,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -442,7 +462,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.visit_lifetime(lifetime_ref);\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: self.map.defs.get(&lifetime_ref.id).cloned(),\n-                    s: self.scope\n+                    s: self.scope,\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n@@ -467,13 +487,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n                             let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n                             let krate = self.hir_map.forest.krate();\n-                            if !(krate.items.contains_key(&parent_id) ||\n-                                 krate.impl_items.contains_key(&parent_impl_id) ||\n-                                 krate.trait_items.contains_key(&parent_trait_id))\n+                            if !(krate.items.contains_key(&parent_id)\n+                                || krate.impl_items.contains_key(&parent_impl_id)\n+                                || krate.trait_items.contains_key(&parent_trait_id))\n                             {\n-                                span_err!(self.sess, lifetime.span, E0657,\n-                                  \"`impl Trait` can only capture lifetimes \\\n-                                  bound at the fn or impl level\");\n+                                span_err!(\n+                                    self.sess,\n+                                    lifetime.span,\n+                                    E0657,\n+                                    \"`impl Trait` can only capture lifetimes \\\n+                                     bound at the fn or impl level\"\n+                                );\n                             }\n                         }\n                     }\n@@ -484,34 +508,43 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n                 //                          ^            ^ this gets resolved in the scope of\n                 //                                         the exist_ty generics\n-                let hir::ExistTy { ref generics, ref bounds } = *exist_ty;\n+                let hir::ExistTy {\n+                    ref generics,\n+                    ref bounds,\n+                } = *exist_ty;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.lifetimes.iter()\n+                let lifetimes = generics\n+                    .lifetimes\n+                    .iter()\n                     .map(|lt_def| Region::early(self.hir_map, &mut index, lt_def))\n                     .collect();\n \n                 let next_early_index = index + generics.ty_params.len() as u32;\n-                let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n+                let scope = Scope::Binder {\n+                    lifetimes,\n+                    next_early_index,\n+                    s: self.scope,\n+                };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n                     for bound in bounds {\n                         this.visit_ty_param_bound(bound);\n                     }\n                 });\n             }\n-            _ => {\n-                intravisit::walk_ty(self, ty)\n-            }\n+            _ => intravisit::walk_ty(self, ty),\n         }\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         if let hir::TraitItemKind::Method(ref sig, _) = trait_item.node {\n             self.visit_early_late(\n                 Some(self.hir_map.get_parent(trait_item.id)),\n-                &sig.decl, &trait_item.generics,\n-                |this| intravisit::walk_trait_item(this, trait_item))\n+                &sig.decl,\n+                &trait_item.generics,\n+                |this| intravisit::walk_trait_item(this, trait_item),\n+            )\n         } else {\n             intravisit::walk_trait_item(self, trait_item);\n         }\n@@ -521,8 +554,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n             self.visit_early_late(\n                 Some(self.hir_map.get_parent(impl_item.id)),\n-                &sig.decl, &impl_item.generics,\n-                |this| intravisit::walk_impl_item(this, impl_item))\n+                &sig.decl,\n+                &impl_item.generics,\n+                |this| intravisit::walk_impl_item(this, impl_item),\n+            )\n         } else {\n             intravisit::walk_impl_item(self, impl_item);\n         }\n@@ -552,7 +587,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl) {\n         let output = match fd.output {\n             hir::DefaultReturn(_) => None,\n-            hir::Return(ref ty) => Some(ty)\n+            hir::Return(ref ty) => Some(ty),\n         };\n         self.visit_fn_like_elision(&fd.inputs, output);\n     }\n@@ -567,19 +602,22 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ ref bounded_ty,\n-                                                                               ref bounds,\n-                                                                               ref bound_lifetimes,\n-                                                                               .. }) => {\n+                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                    ref bounded_ty,\n+                    ref bounds,\n+                    ref bound_lifetimes,\n+                    ..\n+                }) => {\n                     if !bound_lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n-                            lifetimes: bound_lifetimes.iter().map(|def| {\n-                                    Region::late(self.hir_map, def)\n-                            }).collect(),\n+                            lifetimes: bound_lifetimes\n+                                .iter()\n+                                .map(|def| Region::late(self.hir_map, def))\n+                                .collect(),\n                             next_early_index,\n-                            s: self.scope\n+                            s: self.scope,\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_defs(old_scope, bound_lifetimes);\n@@ -593,42 +631,53 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         walk_list!(self, visit_ty_param_bound, bounds);\n                     }\n                 }\n-                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n-                                                                                ref bounds,\n-                                                                                .. }) => {\n-\n+                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                    ref lifetime,\n+                    ref bounds,\n+                    ..\n+                }) => {\n                     self.visit_lifetime(lifetime);\n                     for bound in bounds {\n                         self.visit_lifetime(bound);\n                     }\n                 }\n-                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ref lhs_ty,\n-                                                                        ref rhs_ty,\n-                                                                        .. }) => {\n+                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n+                    ref lhs_ty,\n+                    ref rhs_ty,\n+                    ..\n+                }) => {\n                     self.visit_ty(lhs_ty);\n                     self.visit_ty(rhs_ty);\n                 }\n             }\n         }\n     }\n \n-    fn visit_poly_trait_ref(&mut self,\n-                            trait_ref: &'tcx hir::PolyTraitRef,\n-                            _modifier: hir::TraitBoundModifier) {\n+    fn visit_poly_trait_ref(\n+        &mut self,\n+        trait_ref: &'tcx hir::PolyTraitRef,\n+        _modifier: hir::TraitBoundModifier,\n+    ) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n             if self.trait_ref_hack {\n-                span_err!(self.sess, trait_ref.span, E0316,\n-                          \"nested quantification of lifetimes\");\n+                span_err!(\n+                    self.sess,\n+                    trait_ref.span,\n+                    E0316,\n+                    \"nested quantification of lifetimes\"\n+                );\n             }\n             let next_early_index = self.next_early_index();\n             let scope = Scope::Binder {\n-                lifetimes: trait_ref.bound_lifetimes.iter().map(|def| {\n-                        Region::late(self.hir_map, def)\n-                }).collect(),\n+                lifetimes: trait_ref\n+                    .bound_lifetimes\n+                    .iter()\n+                    .map(|def| Region::late(self.hir_map, def))\n+                    .collect(),\n                 next_early_index,\n-                s: self.scope\n+                s: self.scope,\n             };\n             self.with(scope, |old_scope, this| {\n                 this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n@@ -644,21 +693,42 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-enum ShadowKind { Label, Lifetime }\n-struct Original { kind: ShadowKind, span: Span }\n-struct Shadower { kind: ShadowKind, span: Span }\n+enum ShadowKind {\n+    Label,\n+    Lifetime,\n+}\n+struct Original {\n+    kind: ShadowKind,\n+    span: Span,\n+}\n+struct Shadower {\n+    kind: ShadowKind,\n+    span: Span,\n+}\n \n fn original_label(span: Span) -> Original {\n-    Original { kind: ShadowKind::Label, span: span }\n+    Original {\n+        kind: ShadowKind::Label,\n+        span: span,\n+    }\n }\n fn shadower_label(span: Span) -> Shadower {\n-    Shadower { kind: ShadowKind::Label, span: span }\n+    Shadower {\n+        kind: ShadowKind::Label,\n+        span: span,\n+    }\n }\n fn original_lifetime(span: Span) -> Original {\n-    Original { kind: ShadowKind::Lifetime, span: span }\n+    Original {\n+        kind: ShadowKind::Lifetime,\n+        span: span,\n+    }\n }\n fn shadower_lifetime(l: &hir::Lifetime) -> Shadower {\n-    Shadower { kind: ShadowKind::Lifetime, span: l.span }\n+    Shadower {\n+        kind: ShadowKind::Lifetime,\n+        span: l.span,\n+    }\n }\n \n impl ShadowKind {\n@@ -670,17 +740,20 @@ impl ShadowKind {\n     }\n }\n \n-fn check_mixed_explicit_and_in_band_defs(\n-    sess: &Session,\n-    lifetime_defs: &[hir::LifetimeDef],\n-) {\n+fn check_mixed_explicit_and_in_band_defs(sess: &Session, lifetime_defs: &[hir::LifetimeDef]) {\n     let oob_def = lifetime_defs.iter().find(|lt| !lt.in_band);\n     let in_band_def = lifetime_defs.iter().find(|lt| lt.in_band);\n \n     if let (Some(oob_def), Some(in_band_def)) = (oob_def, in_band_def) {\n-        struct_span_err!(sess, in_band_def.lifetime.span, E0688,\n-                         \"cannot mix in-band and explicit lifetime definitions\")\n-            .span_label(in_band_def.lifetime.span, \"in-band lifetime definition here\")\n+        struct_span_err!(\n+            sess,\n+            in_band_def.lifetime.span,\n+            E0688,\n+            \"cannot mix in-band and explicit lifetime definitions\"\n+        ).span_label(\n+            in_band_def.lifetime.span,\n+            \"in-band lifetime definition here\",\n+        )\n             .span_label(oob_def.lifetime.span, \"explicit lifetime definition here\")\n             .emit();\n     }\n@@ -689,21 +762,32 @@ fn check_mixed_explicit_and_in_band_defs(\n fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, shadower: Shadower) {\n     let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n         // lifetime/lifetime shadowing is an error\n-        struct_span_err!(sess, shadower.span, E0496,\n-                         \"{} name `{}` shadows a \\\n-                          {} name that is already in scope\",\n-                         shadower.kind.desc(), name, orig.kind.desc())\n+        struct_span_err!(\n+            sess,\n+            shadower.span,\n+            E0496,\n+            \"{} name `{}` shadows a \\\n+             {} name that is already in scope\",\n+            shadower.kind.desc(),\n+            name,\n+            orig.kind.desc()\n+        )\n     } else {\n         // shadowing involving a label is only a warning, due to issues with\n         // labels and lifetimes not being macro-hygienic.\n-        sess.struct_span_warn(shadower.span,\n-                              &format!(\"{} name `{}` shadows a \\\n-                                        {} name that is already in scope\",\n-                                       shadower.kind.desc(), name, orig.kind.desc()))\n+        sess.struct_span_warn(\n+            shadower.span,\n+            &format!(\n+                \"{} name `{}` shadows a \\\n+                 {} name that is already in scope\",\n+                shadower.kind.desc(),\n+                name,\n+                orig.kind.desc()\n+            ),\n+        )\n     };\n     err.span_label(orig.span, \"first declared here\");\n-    err.span_label(shadower.span,\n-                   format!(\"lifetime {} already in scope\", name));\n+    err.span_label(shadower.span, format!(\"lifetime {} already in scope\", name));\n     err.emit();\n }\n \n@@ -735,18 +819,22 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n                 for &(prior, prior_span) in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n                     if label == prior {\n-                        signal_shadowing_problem(self.sess,\n-                                                 label,\n-                                                 original_label(prior_span),\n-                                                 shadower_label(label_span));\n+                        signal_shadowing_problem(\n+                            self.sess,\n+                            label,\n+                            original_label(prior_span),\n+                            shadower_label(label_span),\n+                        );\n                     }\n                 }\n \n-                check_if_label_shadows_lifetime(self.sess,\n-                                                self.hir_map,\n-                                                self.scope,\n-                                                label,\n-                                                label_span);\n+                check_if_label_shadows_lifetime(\n+                    self.sess,\n+                    self.hir_map,\n+                    self.scope,\n+                    label,\n+                    label_span,\n+                );\n \n                 self.labels_in_fn.push((label, label_span));\n             }\n@@ -756,36 +844,47 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n \n     fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n         match ex.node {\n-            hir::ExprWhile(.., Some(label)) |\n-            hir::ExprLoop(_, Some(label), _) => Some((label.node, label.span)),\n+            hir::ExprWhile(.., Some(label)) | hir::ExprLoop(_, Some(label), _) => {\n+                Some((label.node, label.span))\n+            }\n             _ => None,\n         }\n     }\n \n-    fn check_if_label_shadows_lifetime<'a>(sess: &'a Session,\n-                                           hir_map: &Map,\n-                                           mut scope: ScopeRef<'a>,\n-                                           label: ast::Name,\n-                                           label_span: Span) {\n+    fn check_if_label_shadows_lifetime<'a>(\n+        sess: &'a Session,\n+        hir_map: &Map,\n+        mut scope: ScopeRef<'a>,\n+        label: ast::Name,\n+        label_span: Span,\n+    ) {\n         loop {\n             match *scope {\n-                Scope::Body { s, .. } |\n-                Scope::Elision { s, .. } |\n-                Scope::ObjectLifetimeDefault { s, .. } => { scope = s; }\n+                Scope::Body { s, .. }\n+                | Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. } => {\n+                    scope = s;\n+                }\n \n-                Scope::Root => { return; }\n+                Scope::Root => {\n+                    return;\n+                }\n \n-                Scope::Binder { ref lifetimes, s, next_early_index: _ } => {\n+                Scope::Binder {\n+                    ref lifetimes,\n+                    s,\n+                    next_early_index: _,\n+                } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::LifetimeName::Name(label)) {\n-                        let node_id = hir_map.as_local_node_id(def.id().unwrap())\n-                                             .unwrap();\n+                        let node_id = hir_map.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             sess,\n                             label,\n                             original_lifetime(hir_map.span(node_id)),\n-                            shadower_label(label_span));\n+                            shadower_label(label_span),\n+                        );\n                         return;\n                     }\n                     scope = s;\n@@ -795,32 +894,38 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n     }\n }\n \n-fn compute_object_lifetime_defaults(sess: &Session, hir_map: &Map)\n-                                    -> NodeMap<Vec<ObjectLifetimeDefault>> {\n+fn compute_object_lifetime_defaults(\n+    sess: &Session,\n+    hir_map: &Map,\n+) -> NodeMap<Vec<ObjectLifetimeDefault>> {\n     let mut map = NodeMap();\n     for item in hir_map.krate().items.values() {\n         match item.node {\n-            hir::ItemStruct(_, ref generics) |\n-            hir::ItemUnion(_, ref generics) |\n-            hir::ItemEnum(_, ref generics) |\n-            hir::ItemTy(_, ref generics) |\n-            hir::ItemTrait(_, _, ref generics, ..) => {\n+            hir::ItemStruct(_, ref generics)\n+            | hir::ItemUnion(_, ref generics)\n+            | hir::ItemEnum(_, ref generics)\n+            | hir::ItemTy(_, ref generics)\n+            | hir::ItemTrait(_, _, ref generics, ..) => {\n                 let result = object_lifetime_defaults_for_item(hir_map, generics);\n \n                 // Debugging aid.\n                 if attr::contains_name(&item.attrs, \"rustc_object_lifetime_default\") {\n-                    let object_lifetime_default_reprs: String =\n-                        result.iter().map(|set| {\n-                            match *set {\n-                                Set1::Empty => \"BaseDefault\".to_string(),\n-                                Set1::One(Region::Static) => \"'static\".to_string(),\n-                                Set1::One(Region::EarlyBound(i, _, _)) => {\n-                                    generics.lifetimes[i as usize].lifetime.name.name().to_string()\n-                                }\n-                                Set1::One(_) => bug!(),\n-                                Set1::Many => \"Ambiguous\".to_string(),\n-                            }\n-                        }).collect::<Vec<String>>().join(\",\");\n+                    let object_lifetime_default_reprs: String = result\n+                        .iter()\n+                        .map(|set| match *set {\n+                            Set1::Empty => \"BaseDefault\".to_string(),\n+                            Set1::One(Region::Static) => \"'static\".to_string(),\n+                            Set1::One(Region::EarlyBound(i, _, _)) => generics.lifetimes\n+                                [i as usize]\n+                                .lifetime\n+                                .name\n+                                .name()\n+                                .to_string(),\n+                            Set1::One(_) => bug!(),\n+                            Set1::Many => \"Ambiguous\".to_string(),\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\",\");\n                     sess.span_err(item.span, &object_lifetime_default_reprs);\n                 }\n \n@@ -835,8 +940,10 @@ fn compute_object_lifetime_defaults(sess: &Session, hir_map: &Map)\n /// Scan the bounds and where-clauses on parameters to extract bounds\n /// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n /// for each type parameter.\n-fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n-                                     -> Vec<ObjectLifetimeDefault> {\n+fn object_lifetime_defaults_for_item(\n+    hir_map: &Map,\n+    generics: &hir::Generics,\n+) -> Vec<ObjectLifetimeDefault> {\n     fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::TyParamBound]) {\n         for bound in bounds {\n             if let hir::RegionTyParamBound(ref lifetime) = *bound {\n@@ -845,67 +952,82 @@ fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n         }\n     }\n \n-    generics.ty_params.iter().map(|param| {\n-        let mut set = Set1::Empty;\n+    generics\n+        .ty_params\n+        .iter()\n+        .map(|param| {\n+            let mut set = Set1::Empty;\n \n-        add_bounds(&mut set, &param.bounds);\n+            add_bounds(&mut set, &param.bounds);\n \n-        let param_def_id = hir_map.local_def_id(param.id);\n-        for predicate in &generics.where_clause.predicates {\n-            // Look for `type: ...` where clauses.\n-            let data = match *predicate {\n-                hir::WherePredicate::BoundPredicate(ref data) => data,\n-                _ => continue\n-            };\n+            let param_def_id = hir_map.local_def_id(param.id);\n+            for predicate in &generics.where_clause.predicates {\n+                // Look for `type: ...` where clauses.\n+                let data = match *predicate {\n+                    hir::WherePredicate::BoundPredicate(ref data) => data,\n+                    _ => continue,\n+                };\n \n-            // Ignore `for<'a> type: ...` as they can change what\n-            // lifetimes mean (although we could \"just\" handle it).\n-            if !data.bound_lifetimes.is_empty() {\n-                continue;\n-            }\n+                // Ignore `for<'a> type: ...` as they can change what\n+                // lifetimes mean (although we could \"just\" handle it).\n+                if !data.bound_lifetimes.is_empty() {\n+                    continue;\n+                }\n \n-            let def = match data.bounded_ty.node {\n-                hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n-                _ => continue\n-            };\n+                let def = match data.bounded_ty.node {\n+                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n+                    _ => continue,\n+                };\n \n-            if def == Def::TyParam(param_def_id) {\n-                add_bounds(&mut set, &data.bounds);\n+                if def == Def::TyParam(param_def_id) {\n+                    add_bounds(&mut set, &data.bounds);\n+                }\n             }\n-        }\n \n-        match set {\n-            Set1::Empty => Set1::Empty,\n-            Set1::One(name) => {\n-                if name == hir::LifetimeName::Static {\n-                    Set1::One(Region::Static)\n-                } else {\n-                    generics.lifetimes.iter().enumerate().find(|&(_, def)| {\n-                        def.lifetime.name == name\n-                    }).map_or(Set1::Many, |(i, def)| {\n-                        let def_id = hir_map.local_def_id(def.lifetime.id);\n-                        let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n-                        Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n-                    })\n+            match set {\n+                Set1::Empty => Set1::Empty,\n+                Set1::One(name) => {\n+                    if name == hir::LifetimeName::Static {\n+                        Set1::One(Region::Static)\n+                    } else {\n+                        generics\n+                            .lifetimes\n+                            .iter()\n+                            .enumerate()\n+                            .find(|&(_, def)| def.lifetime.name == name)\n+                            .map_or(Set1::Many, |(i, def)| {\n+                                let def_id = hir_map.local_def_id(def.lifetime.id);\n+                                let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n+                                Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n+                            })\n+                    }\n                 }\n+                Set1::Many => Set1::Many,\n             }\n-            Set1::Many => Set1::Many\n-        }\n-    }).collect()\n+        })\n+        .collect()\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     // FIXME(#37666) this works around a limitation in the region inferencer\n-    fn hack<F>(&mut self, f: F) where\n+    fn hack<F>(&mut self, f: F)\n+    where\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         f(self)\n     }\n \n-    fn with<F>(&mut self, wrap_scope: Scope, f: F) where\n+    fn with<F>(&mut self, wrap_scope: Scope, f: F)\n+    where\n         F: for<'b> FnOnce(ScopeRef, &mut LifetimeContext<'b, 'tcx>),\n     {\n-        let LifetimeContext {sess, cstore, hir_map, ref mut map, ..} = *self;\n+        let LifetimeContext {\n+            sess,\n+            cstore,\n+            hir_map,\n+            ref mut map,\n+            ..\n+        } = *self;\n         let labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n         let xcrate_object_lifetime_defaults =\n             replace(&mut self.xcrate_object_lifetime_defaults, DefIdMap());\n@@ -945,11 +1067,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// already in scope (for a fn item, that will be 0, but for a method it might not be). Late\n     /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n     /// ordering is not important there.\n-    fn visit_early_late<F>(&mut self,\n-                           parent_id: Option<ast::NodeId>,\n-                           decl: &'tcx hir::FnDecl,\n-                           generics: &'tcx hir::Generics,\n-                           walk: F) where\n+    fn visit_early_late<F>(\n+        &mut self,\n+        parent_id: Option<ast::NodeId>,\n+        decl: &'tcx hir::FnDecl,\n+        generics: &'tcx hir::Generics,\n+        walk: F,\n+    ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n         insert_late_bound_lifetimes(self.map, decl, generics);\n@@ -962,28 +1086,32 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 index += 1; // Self comes first.\n             }\n             match parent.node {\n-                hir::ItemTrait(_, _, ref generics, ..) |\n-                hir::ItemImpl(_, _, _, ref generics, ..) => {\n+                hir::ItemTrait(_, _, ref generics, ..)\n+                | hir::ItemImpl(_, _, _, ref generics, ..) => {\n                     index += (generics.lifetimes.len() + generics.ty_params.len()) as u32;\n                 }\n                 _ => {}\n             }\n         }\n \n-        let lifetimes = generics.lifetimes.iter().map(|def| {\n-            if self.map.late_bound.contains(&def.lifetime.id) {\n-                Region::late(self.hir_map, def)\n-            } else {\n-                Region::early(self.hir_map, &mut index, def)\n-            }\n-        }).collect();\n+        let lifetimes = generics\n+            .lifetimes\n+            .iter()\n+            .map(|def| {\n+                if self.map.late_bound.contains(&def.lifetime.id) {\n+                    Region::late(self.hir_map, def)\n+                } else {\n+                    Region::early(self.hir_map, &mut index, def)\n+                }\n+            })\n+            .collect();\n \n         let next_early_index = index + generics.ty_params.len() as u32;\n \n         let scope = Scope::Binder {\n             lifetimes,\n             next_early_index,\n-            s: self.scope\n+            s: self.scope,\n         };\n         self.with(scope, move |old_scope, this| {\n             this.check_lifetime_defs(old_scope, &generics.lifetimes);\n@@ -997,16 +1125,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n-                Scope::Root =>\n-                    return 0,\n+                Scope::Root => return 0,\n \n-                Scope::Binder { next_early_index, .. } =>\n-                    return next_early_index,\n+                Scope::Binder {\n+                    next_early_index, ..\n+                } => return next_early_index,\n \n-                Scope::Body { s, .. } |\n-                Scope::Elision { s, .. } |\n-                Scope::ObjectLifetimeDefault { s, .. } =>\n-                    scope = s,\n+                Scope::Body { s, .. }\n+                | Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n             }\n         }\n     }\n@@ -1032,7 +1159,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, s, next_early_index: _ } => {\n+                Scope::Binder {\n+                    ref lifetimes,\n+                    s,\n+                    next_early_index: _,\n+                } => {\n                     if let Some(&def) = lifetimes.get(&lifetime_ref.name) {\n                         break Some(def.shifted(late_depth));\n                     } else {\n@@ -1041,8 +1172,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     }\n                 }\n \n-                Scope::Elision { s, .. } |\n-                Scope::ObjectLifetimeDefault { s, .. } => {\n+                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -1055,13 +1185,16 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let fn_id = self.hir_map.body_owner(body_id);\n                 match self.hir_map.get(fn_id) {\n                     hir::map::NodeItem(&hir::Item {\n-                        node: hir::ItemFn(..), ..\n-                    }) |\n-                    hir::map::NodeTraitItem(&hir::TraitItem {\n-                        node: hir::TraitItemKind::Method(..), ..\n-                    }) |\n-                    hir::map::NodeImplItem(&hir::ImplItem {\n-                        node: hir::ImplItemKind::Method(..), ..\n+                        node: hir::ItemFn(..),\n+                        ..\n+                    })\n+                    | hir::map::NodeTraitItem(&hir::TraitItem {\n+                        node: hir::TraitItemKind::Method(..),\n+                        ..\n+                    })\n+                    | hir::map::NodeImplItem(&hir::ImplItem {\n+                        node: hir::ImplItemKind::Method(..),\n+                        ..\n                     }) => {\n                         let scope = self.hir_map.local_def_id(fn_id);\n                         def = Region::Free(scope, def.id().unwrap());\n@@ -1073,38 +1206,45 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             // Check for fn-syntax conflicts with in-band lifetime definitions\n             if self.is_in_fn_syntax {\n                 match def {\n-                    Region::EarlyBound(_, _, LifetimeDefOrigin::InBand) |\n-                    Region::LateBound(_, _, LifetimeDefOrigin::InBand) => {\n-                        struct_span_err!(self.sess, lifetime_ref.span, E0687,\n+                    Region::EarlyBound(_, _, LifetimeDefOrigin::InBand)\n+                    | Region::LateBound(_, _, LifetimeDefOrigin::InBand) => {\n+                        struct_span_err!(\n+                            self.sess,\n+                            lifetime_ref.span,\n+                            E0687,\n                             \"lifetimes used in `fn` or `Fn` syntax must be \\\n-                            explicitly declared using `<...>` binders\")\n-                            .span_label(lifetime_ref.span,\n-                                        \"in-band lifetime definition\")\n+                             explicitly declared using `<...>` binders\"\n+                        ).span_label(lifetime_ref.span, \"in-band lifetime definition\")\n                             .emit();\n-                    },\n+                    }\n \n-                    Region::Static |\n-                    Region::EarlyBound(_, _, LifetimeDefOrigin::Explicit) |\n-                    Region::LateBound(_, _, LifetimeDefOrigin::Explicit) |\n-                    Region::LateBoundAnon(..) |\n-                    Region::Free(..) => {}\n+                    Region::Static\n+                    | Region::EarlyBound(_, _, LifetimeDefOrigin::Explicit)\n+                    | Region::LateBound(_, _, LifetimeDefOrigin::Explicit)\n+                    | Region::LateBoundAnon(..)\n+                    | Region::Free(..) => {}\n                 }\n             }\n \n             self.insert_lifetime(lifetime_ref, def);\n         } else {\n-            struct_span_err!(self.sess, lifetime_ref.span, E0261,\n-                \"use of undeclared lifetime name `{}`\", lifetime_ref.name.name())\n-                .span_label(lifetime_ref.span, \"undeclared lifetime\")\n+            struct_span_err!(\n+                self.sess,\n+                lifetime_ref.span,\n+                E0261,\n+                \"use of undeclared lifetime name `{}`\",\n+                lifetime_ref.name.name()\n+            ).span_label(lifetime_ref.span, \"undeclared lifetime\")\n                 .emit();\n         }\n     }\n \n-    fn visit_segment_parameters(&mut self,\n-                                def: Def,\n-                                depth: usize,\n-                                params: &'tcx hir::PathParameters) {\n-\n+    fn visit_segment_parameters(\n+        &mut self,\n+        def: Def,\n+        depth: usize,\n+        params: &'tcx hir::PathParameters,\n+    ) {\n         if params.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n@@ -1116,7 +1256,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if params.lifetimes.iter().all(|l| l.is_elided()) {\n             self.resolve_elided_lifetimes(&params.lifetimes);\n         } else {\n-            for l in &params.lifetimes { self.visit_lifetime(l); }\n+            for l in &params.lifetimes {\n+                self.visit_lifetime(l);\n+            }\n         }\n \n         // Figure out if this is a type/trait segment,\n@@ -1129,22 +1271,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n             DefId {\n                 krate: def_id.krate,\n-                index: def_key.parent.expect(\"missing parent\")\n+                index: def_key.parent.expect(\"missing parent\"),\n             }\n         };\n         let type_def_id = match def {\n-            Def::AssociatedTy(def_id) if depth == 1 => {\n-                Some(parent_def_id(self, def_id))\n-            }\n-            Def::Variant(def_id) if depth == 0 => {\n-                Some(parent_def_id(self, def_id))\n+            Def::AssociatedTy(def_id) if depth == 1 => Some(parent_def_id(self, def_id)),\n+            Def::Variant(def_id) if depth == 0 => Some(parent_def_id(self, def_id)),\n+            Def::Struct(def_id)\n+            | Def::Union(def_id)\n+            | Def::Enum(def_id)\n+            | Def::TyAlias(def_id)\n+            | Def::Trait(def_id) if depth == 0 =>\n+            {\n+                Some(def_id)\n             }\n-            Def::Struct(def_id) |\n-            Def::Union(def_id) |\n-            Def::Enum(def_id) |\n-            Def::TyAlias(def_id) |\n-            Def::Trait(def_id) if depth == 0 => Some(def_id),\n-            _ => None\n+            _ => None,\n         };\n \n         let object_lifetime_defaults = type_def_id.map_or(vec![], |def_id| {\n@@ -1156,9 +1297,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                         Scope::Body { .. } => break true,\n \n-                        Scope::Binder { s, .. } |\n-                        Scope::Elision { s, .. } |\n-                        Scope::ObjectLifetimeDefault { s, .. } => {\n+                        Scope::Binder { s, .. }\n+                        | Scope::Elision { s, .. }\n+                        | Scope::ObjectLifetimeDefault { s, .. } => {\n                             scope = s;\n                         }\n                     }\n@@ -1171,17 +1312,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else {\n                 let cstore = self.cstore;\n                 let sess = self.sess;\n-                self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n-                    cstore.item_generics_cloned_untracked(def_id, sess)\n-                          .types\n-                          .into_iter()\n-                          .map(|def| {\n-                        def.object_lifetime_default\n-                    }).collect()\n-                })\n+                self.xcrate_object_lifetime_defaults\n+                    .entry(def_id)\n+                    .or_insert_with(|| {\n+                        cstore\n+                            .item_generics_cloned_untracked(def_id, sess)\n+                            .types\n+                            .into_iter()\n+                            .map(|def| def.object_lifetime_default)\n+                            .collect()\n+                    })\n             };\n-            unsubst.iter().map(|set| {\n-                match *set {\n+            unsubst\n+                .iter()\n+                .map(|set| match *set {\n                     Set1::Empty => {\n                         if in_body {\n                             None\n@@ -1190,32 +1334,37 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n                     }\n                     Set1::One(r) => r.subst(&params.lifetimes, map),\n-                    Set1::Many => None\n-                }\n-            }).collect()\n+                    Set1::Many => None,\n+                })\n+                .collect()\n         });\n \n         for (i, ty) in params.types.iter().enumerate() {\n             if let Some(&lt) = object_lifetime_defaults.get(i) {\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: lt,\n-                    s: self.scope\n+                    s: self.scope,\n                 };\n                 self.with(scope, |_, this| this.visit_ty(ty));\n             } else {\n                 self.visit_ty(ty);\n             }\n         }\n \n-        for b in &params.bindings { self.visit_assoc_type_binding(b); }\n+        for b in &params.bindings {\n+            self.visit_assoc_type_binding(b);\n+        }\n     }\n \n-    fn visit_fn_like_elision(&mut self, inputs: &'tcx [P<hir::Ty>],\n-                             output: Option<&'tcx P<hir::Ty>>) {\n+    fn visit_fn_like_elision(\n+        &mut self,\n+        inputs: &'tcx [P<hir::Ty>],\n+        output: Option<&'tcx P<hir::Ty>>,\n+    ) {\n         let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n         let arg_scope = Scope::Elision {\n             elide: arg_elide.clone(),\n-            s: self.scope\n+            s: self.scope,\n         };\n         self.with(arg_scope, |_, this| {\n             for input in inputs {\n@@ -1225,13 +1374,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Elision { ref elide, .. } => {\n                     arg_elide = elide.clone();\n                 }\n-                _ => bug!()\n+                _ => bug!(),\n             }\n         });\n \n         let output = match output {\n             Some(ty) => ty,\n-            None => return\n+            None => return,\n         };\n \n         // Figure out if there's a body we can get argument names from,\n@@ -1242,16 +1391,23 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let body = match self.hir_map.get(parent) {\n             // `fn` definitions and methods.\n             hir::map::NodeItem(&hir::Item {\n-                node: hir::ItemFn(.., body), ..\n-            })  => Some(body),\n+                node: hir::ItemFn(.., body),\n+                ..\n+            }) => Some(body),\n \n             hir::map::NodeTraitItem(&hir::TraitItem {\n-                node: hir::TraitItemKind::Method(_, ref m), ..\n+                node: hir::TraitItemKind::Method(_, ref m),\n+                ..\n             }) => {\n-                match self.hir_map.expect_item(self.hir_map.get_parent(parent)).node {\n+                match self.hir_map\n+                    .expect_item(self.hir_map.get_parent(parent))\n+                    .node\n+                {\n                     hir::ItemTrait(.., ref trait_items) => {\n-                        assoc_item_kind = trait_items.iter().find(|ti| ti.id.node_id == parent)\n-                                                            .map(|ti| ti.kind);\n+                        assoc_item_kind = trait_items\n+                            .iter()\n+                            .find(|ti| ti.id.node_id == parent)\n+                            .map(|ti| ti.kind);\n                     }\n                     _ => {}\n                 }\n@@ -1262,13 +1418,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             hir::map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Method(_, body), ..\n+                node: hir::ImplItemKind::Method(_, body),\n+                ..\n             }) => {\n-                match self.hir_map.expect_item(self.hir_map.get_parent(parent)).node {\n+                match self.hir_map\n+                    .expect_item(self.hir_map.get_parent(parent))\n+                    .node\n+                {\n                     hir::ItemImpl(.., ref self_ty, ref impl_items) => {\n                         impl_self = Some(self_ty);\n-                        assoc_item_kind = impl_items.iter().find(|ii| ii.id.node_id == parent)\n-                                                           .map(|ii| ii.kind);\n+                        assoc_item_kind = impl_items\n+                            .iter()\n+                            .find(|ii| ii.id.node_id == parent)\n+                            .map(|ii| ii.kind);\n                     }\n                     _ => {}\n                 }\n@@ -1288,7 +1450,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let has_self = match assoc_item_kind {\n             Some(hir::AssociatedItemKind::Method { has_self }) => has_self,\n-            _ => false\n+            _ => false,\n         };\n \n         // In accordance with the rules for lifetime elision, we can determine\n@@ -1311,10 +1473,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         // Whitelist the types that unambiguously always\n                         // result in the same type constructor being used\n                         // (it can't differ between `Self` and `self`).\n-                        Def::Struct(_) |\n-                        Def::Union(_) |\n-                        Def::Enum(_) |\n-                        Def::PrimTy(_) => return def == path.def,\n+                        Def::Struct(_) | Def::Union(_) | Def::Enum(_) | Def::PrimTy(_) => {\n+                            return def == path.def\n+                        }\n                         _ => {}\n                     }\n                 }\n@@ -1328,7 +1489,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n                             let scope = Scope::Elision {\n                                 elide: Elide::Exact(lifetime),\n-                                s: self.scope\n+                                s: self.scope,\n                             };\n                             self.with(scope, |_, this| this.visit_ty(output));\n                             return;\n@@ -1343,31 +1504,36 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // have that lifetime.\n         let mut possible_implied_output_region = None;\n         let mut lifetime_count = 0;\n-        let arg_lifetimes = inputs.iter().enumerate().skip(has_self as usize).map(|(i, input)| {\n-            let mut gather = GatherLifetimes {\n-                map: self.map,\n-                binder_depth: 1,\n-                have_bound_regions: false,\n-                lifetimes: FxHashSet()\n-            };\n-            gather.visit_ty(input);\n+        let arg_lifetimes = inputs\n+            .iter()\n+            .enumerate()\n+            .skip(has_self as usize)\n+            .map(|(i, input)| {\n+                let mut gather = GatherLifetimes {\n+                    map: self.map,\n+                    binder_depth: 1,\n+                    have_bound_regions: false,\n+                    lifetimes: FxHashSet(),\n+                };\n+                gather.visit_ty(input);\n \n-            lifetime_count += gather.lifetimes.len();\n+                lifetime_count += gather.lifetimes.len();\n \n-            if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n-                // there's a chance that the unique lifetime of this\n-                // iteration will be the appropriate lifetime for output\n-                // parameters, so lets store it.\n-                possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n-            }\n+                if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n+                    // there's a chance that the unique lifetime of this\n+                    // iteration will be the appropriate lifetime for output\n+                    // parameters, so lets store it.\n+                    possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n+                }\n \n-            ElisionFailureInfo {\n-                parent: body,\n-                index: i,\n-                lifetime_count: gather.lifetimes.len(),\n-                have_bound_regions: gather.have_bound_regions\n-            }\n-        }).collect();\n+                ElisionFailureInfo {\n+                    parent: body,\n+                    index: i,\n+                    lifetime_count: gather.lifetimes.len(),\n+                    have_bound_regions: gather.have_bound_regions,\n+                }\n+            })\n+            .collect();\n \n         let elide = if lifetime_count == 1 {\n             Elide::Exact(possible_implied_output_region.unwrap())\n@@ -1377,7 +1543,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let scope = Scope::Elision {\n             elide,\n-            s: self.scope\n+            s: self.scope,\n         };\n         self.with(scope, |_, this| this.visit_ty(output));\n \n@@ -1415,34 +1581,38 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            fn visit_poly_trait_ref(&mut self,\n-                                    trait_ref: &hir::PolyTraitRef,\n-                                    modifier: hir::TraitBoundModifier) {\n+            fn visit_poly_trait_ref(\n+                &mut self,\n+                trait_ref: &hir::PolyTraitRef,\n+                modifier: hir::TraitBoundModifier,\n+            ) {\n                 self.binder_depth += 1;\n                 intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n                 self.binder_depth -= 1;\n             }\n \n             fn visit_lifetime_def(&mut self, lifetime_def: &hir::LifetimeDef) {\n-                for l in &lifetime_def.bounds { self.visit_lifetime(l); }\n+                for l in &lifetime_def.bounds {\n+                    self.visit_lifetime(l);\n+                }\n             }\n \n             fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n                 if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n                     match lifetime {\n-                        Region::LateBound(debruijn, _, _) |\n-                        Region::LateBoundAnon(debruijn, _)\n-                                if debruijn.depth < self.binder_depth => {\n+                        Region::LateBound(debruijn, _, _) | Region::LateBoundAnon(debruijn, _)\n+                            if debruijn.depth < self.binder_depth =>\n+                        {\n                             self.have_bound_regions = true;\n                         }\n                         _ => {\n-                            self.lifetimes.insert(lifetime.from_depth(self.binder_depth));\n+                            self.lifetimes\n+                                .insert(lifetime.from_depth(self.binder_depth));\n                         }\n                     }\n                 }\n             }\n         }\n-\n     }\n \n     fn resolve_elided_lifetimes(&mut self, lifetime_refs: &[hir::Lifetime]) {\n@@ -1475,7 +1645,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             return;\n                         }\n                         Elide::Exact(l) => l.shifted(late_depth),\n-                        Elide::Error(ref e) => break Some(e)\n+                        Elide::Error(ref e) => break Some(e),\n                     };\n                     for lifetime_ref in lifetime_refs {\n                         self.insert_lifetime(lifetime_ref, lifetime);\n@@ -1489,9 +1659,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let mut err = struct_span_err!(self.sess, span, E0106,\n+        let mut err = struct_span_err!(\n+            self.sess,\n+            span,\n+            E0106,\n             \"missing lifetime specifier{}\",\n-            if lifetime_refs.len() > 1 { \"s\" } else { \"\" });\n+            if lifetime_refs.len() > 1 { \"s\" } else { \"\" }\n+        );\n         let msg = if lifetime_refs.len() > 1 {\n             format!(\"expected {} lifetime parameters\", lifetime_refs.len())\n         } else {\n@@ -1507,21 +1681,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_elision_failure(&mut self,\n-                              db: &mut DiagnosticBuilder,\n-                              params: &[ElisionFailureInfo]) {\n+    fn report_elision_failure(\n+        &mut self,\n+        db: &mut DiagnosticBuilder,\n+        params: &[ElisionFailureInfo],\n+    ) {\n         let mut m = String::new();\n         let len = params.len();\n \n-        let elided_params: Vec<_> = params.iter().cloned()\n-                                          .filter(|info| info.lifetime_count > 0)\n-                                          .collect();\n+        let elided_params: Vec<_> = params\n+            .iter()\n+            .cloned()\n+            .filter(|info| info.lifetime_count > 0)\n+            .collect();\n \n         let elided_len = elided_params.len();\n \n         for (i, info) in elided_params.into_iter().enumerate() {\n             let ElisionFailureInfo {\n-                parent, index, lifetime_count: n, have_bound_regions\n+                parent,\n+                index,\n+                lifetime_count: n,\n+                have_bound_regions,\n             } = info;\n \n             let help_name = if let Some(body) = parent {\n@@ -1531,12 +1712,18 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 format!(\"argument {}\", index + 1)\n             };\n \n-            m.push_str(&(if n == 1 {\n-                help_name\n-            } else {\n-                format!(\"one of {}'s {} {}lifetimes\", help_name, n,\n-                        if have_bound_regions { \"free \" } else { \"\" } )\n-            })[..]);\n+            m.push_str(\n+                &(if n == 1 {\n+                    help_name\n+                } else {\n+                    format!(\n+                        \"one of {}'s {} {}lifetimes\",\n+                        help_name,\n+                        n,\n+                        if have_bound_regions { \"free \" } else { \"\" }\n+                    )\n+                })[..],\n+            );\n \n             if elided_len == 2 && i == 0 {\n                 m.push_str(\" or \");\n@@ -1545,33 +1732,41 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if i != elided_len - 1 {\n                 m.push_str(\", \");\n             }\n-\n         }\n \n         if len == 0 {\n-            help!(db,\n-                  \"this function's return type contains a borrowed value, but \\\n-                   there is no value for it to be borrowed from\");\n-            help!(db,\n-                  \"consider giving it a 'static lifetime\");\n+            help!(\n+                db,\n+                \"this function's return type contains a borrowed value, but \\\n+                 there is no value for it to be borrowed from\"\n+            );\n+            help!(db, \"consider giving it a 'static lifetime\");\n         } else if elided_len == 0 {\n-            help!(db,\n-                  \"this function's return type contains a borrowed value with \\\n-                   an elided lifetime, but the lifetime cannot be derived from \\\n-                   the arguments\");\n-            help!(db,\n-                  \"consider giving it an explicit bounded or 'static \\\n-                   lifetime\");\n+            help!(\n+                db,\n+                \"this function's return type contains a borrowed value with \\\n+                 an elided lifetime, but the lifetime cannot be derived from \\\n+                 the arguments\"\n+            );\n+            help!(\n+                db,\n+                \"consider giving it an explicit bounded or 'static \\\n+                 lifetime\"\n+            );\n         } else if elided_len == 1 {\n-            help!(db,\n-                  \"this function's return type contains a borrowed value, but \\\n-                   the signature does not say which {} it is borrowed from\",\n-                  m);\n+            help!(\n+                db,\n+                \"this function's return type contains a borrowed value, but \\\n+                 the signature does not say which {} it is borrowed from\",\n+                m\n+            );\n         } else {\n-            help!(db,\n-                  \"this function's return type contains a borrowed value, but \\\n-                   the signature does not say whether it is borrowed from {}\",\n-                  m);\n+            help!(\n+                db,\n+                \"this function's return type contains a borrowed value, but \\\n+                 the signature does not say whether it is borrowed from {}\",\n+                m\n+            );\n         }\n     }\n \n@@ -1585,13 +1780,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root |\n-                Scope::Elision { .. } => break Region::Static,\n+                Scope::Root | Scope::Elision { .. } => break Region::Static,\n \n-                Scope::Body { .. } |\n-                Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n+                Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n-                Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l\n+                Scope::ObjectLifetimeDefault {\n+                    lifetime: Some(l), ..\n+                } => break l,\n             }\n         };\n         self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n@@ -1606,10 +1801,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     hir::LifetimeName::Static | hir::LifetimeName::Underscore => {\n                         let lifetime = lifetime.lifetime;\n                         let name = lifetime.name.name();\n-                        let mut err = struct_span_err!(self.sess, lifetime.span, E0262,\n-                                      \"invalid lifetime parameter name: `{}`\", name);\n-                        err.span_label(lifetime.span,\n-                                       format!(\"{} is a reserved lifetime name\", name));\n+                        let mut err = struct_span_err!(\n+                            self.sess,\n+                            lifetime.span,\n+                            E0262,\n+                            \"invalid lifetime parameter name: `{}`\",\n+                            name\n+                        );\n+                        err.span_label(\n+                            lifetime.span,\n+                            format!(\"{} is a reserved lifetime name\", name),\n+                        );\n                         err.emit();\n                     }\n                     hir::LifetimeName::Implicit | hir::LifetimeName::Name(_) => {}\n@@ -1621,13 +1823,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let lifetime_j = &lifetimes[j];\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n-                    struct_span_err!(self.sess, lifetime_j.lifetime.span, E0263,\n-                                     \"lifetime name `{}` declared twice in the same scope\",\n-                                     lifetime_j.lifetime.name.name())\n-                        .span_label(lifetime_j.lifetime.span,\n-                                    \"declared twice\")\n-                        .span_label(lifetime_i.lifetime.span,\n-                                   \"previous declaration here\")\n+                    struct_span_err!(\n+                        self.sess,\n+                        lifetime_j.lifetime.span,\n+                        E0263,\n+                        \"lifetime name `{}` declared twice in the same scope\",\n+                        lifetime_j.lifetime.name.name()\n+                    ).span_label(lifetime_j.lifetime.span, \"declared twice\")\n+                        .span_label(lifetime_i.lifetime.span, \"previous declaration here\")\n                         .emit();\n                 }\n             }\n@@ -1638,68 +1841,80 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             for bound in &lifetime_i.bounds {\n                 match bound.name {\n                     hir::LifetimeName::Underscore => {\n-                        let mut err = struct_span_err!(self.sess, bound.span, E0637,\n-                            \"invalid lifetime bound name: `'_`\");\n+                        let mut err = struct_span_err!(\n+                            self.sess,\n+                            bound.span,\n+                            E0637,\n+                            \"invalid lifetime bound name: `'_`\"\n+                        );\n                         err.span_label(bound.span, \"`'_` is a reserved lifetime name\");\n                         err.emit();\n                     }\n                     hir::LifetimeName::Static => {\n                         self.insert_lifetime(bound, Region::Static);\n-                        self.sess.struct_span_warn(lifetime_i.lifetime.span.to(bound.span),\n-                            &format!(\"unnecessary lifetime parameter `{}`\",\n-                                    lifetime_i.lifetime.name.name()))\n+                        self.sess\n+                            .struct_span_warn(\n+                                lifetime_i.lifetime.span.to(bound.span),\n+                                &format!(\n+                                    \"unnecessary lifetime parameter `{}`\",\n+                                    lifetime_i.lifetime.name.name()\n+                                ),\n+                            )\n                             .help(&format!(\n                                 \"you can use the `'static` lifetime directly, in place \\\n-                                of `{}`\", lifetime_i.lifetime.name.name()))\n+                                 of `{}`\",\n+                                lifetime_i.lifetime.name.name()\n+                            ))\n                             .emit();\n                     }\n-                    hir::LifetimeName::Implicit |\n-                    hir::LifetimeName::Name(_) => {\n+                    hir::LifetimeName::Implicit | hir::LifetimeName::Name(_) => {\n                         self.resolve_lifetime_ref(bound);\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn check_lifetime_def_for_shadowing(&self,\n-                                        mut old_scope: ScopeRef,\n-                                        lifetime: &hir::Lifetime)\n-    {\n+    fn check_lifetime_def_for_shadowing(&self, mut old_scope: ScopeRef, lifetime: &hir::Lifetime) {\n         for &(label, label_span) in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n             if lifetime.name.name() == label {\n-                signal_shadowing_problem(self.sess,\n-                                         label,\n-                                         original_label(label_span),\n-                                         shadower_lifetime(&lifetime));\n+                signal_shadowing_problem(\n+                    self.sess,\n+                    label,\n+                    original_label(label_span),\n+                    shadower_lifetime(&lifetime),\n+                );\n                 return;\n             }\n         }\n \n         loop {\n             match *old_scope {\n-                Scope::Body { s, .. } |\n-                Scope::Elision { s, .. } |\n-                Scope::ObjectLifetimeDefault { s, .. } => {\n+                Scope::Body { s, .. }\n+                | Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. } => {\n                     old_scope = s;\n                 }\n \n                 Scope::Root => {\n                     return;\n                 }\n \n-                Scope::Binder { ref lifetimes, s, next_early_index: _ } => {\n+                Scope::Binder {\n+                    ref lifetimes,\n+                    s,\n+                    next_early_index: _,\n+                } => {\n                     if let Some(&def) = lifetimes.get(&lifetime.name) {\n-                        let node_id = self.hir_map\n-                                          .as_local_node_id(def.id().unwrap())\n-                                          .unwrap();\n+                        let node_id = self.hir_map.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             self.sess,\n                             lifetime.name.name(),\n                             original_lifetime(self.hir_map.span(node_id)),\n-                            shadower_lifetime(&lifetime));\n+                            shadower_lifetime(&lifetime),\n+                        );\n                         return;\n                     }\n \n@@ -1709,19 +1924,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn insert_lifetime(&mut self,\n-                       lifetime_ref: &hir::Lifetime,\n-                       def: Region) {\n+    fn insert_lifetime(&mut self, lifetime_ref: &hir::Lifetime, def: Region) {\n         if lifetime_ref.id == ast::DUMMY_NODE_ID {\n-            span_bug!(lifetime_ref.span,\n-                      \"lifetime reference not renumbered, \\\n-                       probably a bug in syntax::fold\");\n+            span_bug!(\n+                lifetime_ref.span,\n+                \"lifetime reference not renumbered, \\\n+                 probably a bug in syntax::fold\"\n+            );\n         }\n \n-        debug!(\"insert_lifetime: {} resolved to {:?} span={:?}\",\n-               self.hir_map.node_to_string(lifetime_ref.id),\n-               def,\n-               self.sess.codemap().span_to_string(lifetime_ref.span));\n+        debug!(\n+            \"insert_lifetime: {} resolved to {:?} span={:?}\",\n+            self.hir_map.node_to_string(lifetime_ref.id),\n+            def,\n+            self.sess.codemap().span_to_string(lifetime_ref.span)\n+        );\n         self.map.defs.insert(lifetime_ref.id, def);\n     }\n }\n@@ -1738,12 +1955,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// \"Constrained\" basically means that it appears in any type but\n /// not amongst the inputs to a projection.  In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n-fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n-                               decl: &hir::FnDecl,\n-                               generics: &hir::Generics) {\n-    debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n+fn insert_late_bound_lifetimes(\n+    map: &mut NamedRegionMap,\n+    decl: &hir::FnDecl,\n+    generics: &hir::Generics,\n+) {\n+    debug!(\n+        \"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n+        decl,\n+        generics\n+    );\n \n-    let mut constrained_by_input = ConstrainedCollector { regions: FxHashSet() };\n+    let mut constrained_by_input = ConstrainedCollector {\n+        regions: FxHashSet(),\n+    };\n     for arg_ty in &decl.inputs {\n         constrained_by_input.visit_ty(arg_ty);\n     }\n@@ -1753,8 +1978,10 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     };\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n \n-    debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n-           constrained_by_input.regions);\n+    debug!(\n+        \"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n+        constrained_by_input.regions\n+    );\n \n     // Walk the lifetimes that appear in where clauses.\n     //\n@@ -1764,33 +1991,41 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         regions: FxHashSet(),\n     };\n     for ty_param in generics.ty_params.iter() {\n-        walk_list!(&mut appears_in_where_clause,\n-                   visit_ty_param_bound,\n-                   &ty_param.bounds);\n+        walk_list!(\n+            &mut appears_in_where_clause,\n+            visit_ty_param_bound,\n+            &ty_param.bounds\n+        );\n     }\n-    walk_list!(&mut appears_in_where_clause,\n-               visit_where_predicate,\n-               &generics.where_clause.predicates);\n+    walk_list!(\n+        &mut appears_in_where_clause,\n+        visit_where_predicate,\n+        &generics.where_clause.predicates\n+    );\n     // We need to collect argument impl Trait lifetimes as well,\n     // we do so here.\n-    walk_list!(&mut appears_in_where_clause,\n-               visit_ty,\n-               decl.inputs.iter().filter(|ty| {\n-                   if let hir::TyImplTraitUniversal(..) = ty.node {\n-                       true\n-                   } else {\n-                       false\n-                   }\n-               }));\n+    walk_list!(\n+        &mut appears_in_where_clause,\n+        visit_ty,\n+        decl.inputs.iter().filter(|ty| {\n+            if let hir::TyImplTraitUniversal(..) = ty.node {\n+                true\n+            } else {\n+                false\n+            }\n+        })\n+    );\n     for lifetime_def in &generics.lifetimes {\n         if !lifetime_def.bounds.is_empty() {\n             // `'a: 'b` means both `'a` and `'b` are referenced\n             appears_in_where_clause.visit_lifetime_def(lifetime_def);\n         }\n     }\n \n-    debug!(\"insert_late_bound_lifetimes: appears_in_where_clause={:?}\",\n-           appears_in_where_clause.regions);\n+    debug!(\n+        \"insert_late_bound_lifetimes: appears_in_where_clause={:?}\",\n+        appears_in_where_clause.regions\n+    );\n \n     // Late bound regions are those that:\n     // - appear in the inputs\n@@ -1800,20 +2035,30 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         let name = lifetime.lifetime.name;\n \n         // appears in the where clauses? early-bound.\n-        if appears_in_where_clause.regions.contains(&name) { continue; }\n+        if appears_in_where_clause.regions.contains(&name) {\n+            continue;\n+        }\n \n         // does not appear in the inputs, but appears in the return type? early-bound.\n-        if !constrained_by_input.regions.contains(&name) &&\n-            appears_in_output.regions.contains(&name) {\n+        if !constrained_by_input.regions.contains(&name)\n+            && appears_in_output.regions.contains(&name)\n+        {\n             continue;\n         }\n \n-        debug!(\"insert_late_bound_lifetimes: \\\n-                lifetime {:?} with id {:?} is late-bound\",\n-               lifetime.lifetime.name, lifetime.lifetime.id);\n+        debug!(\n+            \"insert_late_bound_lifetimes: \\\n+             lifetime {:?} with id {:?} is late-bound\",\n+            lifetime.lifetime.name,\n+            lifetime.lifetime.id\n+        );\n \n         let inserted = map.late_bound.insert(lifetime.lifetime.id);\n-        assert!(inserted, \"visited lifetime {:?} twice\", lifetime.lifetime.id);\n+        assert!(\n+            inserted,\n+            \"visited lifetime {:?} twice\",\n+            lifetime.lifetime.id\n+        );\n     }\n \n     return;\n@@ -1829,8 +2074,8 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n \n         fn visit_ty(&mut self, ty: &'v hir::Ty) {\n             match ty.node {\n-                hir::TyPath(hir::QPath::Resolved(Some(_), _)) |\n-                hir::TyPath(hir::QPath::TypeRelative(..)) => {\n+                hir::TyPath(hir::QPath::Resolved(Some(_), _))\n+                | hir::TyPath(hir::QPath::TypeRelative(..)) => {\n                     // ignore lifetimes appearing in associated type\n                     // projections, as they are not *constrained*\n                     // (defined above)"}]}