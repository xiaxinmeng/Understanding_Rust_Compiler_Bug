{"sha": "0f02309e4b0ea05ee905205278fb6d131341c41f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMDIzMDllNGIwZWEwNWVlOTA1MjA1Mjc4ZmI2ZDEzMTM0MWM0MWY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-03-23T03:01:37Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-03-23T03:01:37Z"}, "message": "try! -> ?\n\nAutomated conversion using the untry tool [1] and the following command:\n\n```\n$ find -name '*.rs' -type f | xargs untry\n```\n\nat the root of the Rust repo.\n\n[1]: https://github.com/japaric/untry", "tree": {"sha": "a259129eeb84705de15b51587ddebd0f82735075", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a259129eeb84705de15b51587ddebd0f82735075"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f02309e4b0ea05ee905205278fb6d131341c41f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f02309e4b0ea05ee905205278fb6d131341c41f", "html_url": "https://github.com/rust-lang/rust/commit/0f02309e4b0ea05ee905205278fb6d131341c41f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f02309e4b0ea05ee905205278fb6d131341c41f/comments", "author": null, "committer": null, "parents": [{"sha": "0dcc413e42f15f4fc51a0ca88a99cc89454ec43d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dcc413e42f15f4fc51a0ca88a99cc89454ec43d", "html_url": "https://github.com/rust-lang/rust/commit/0dcc413e42f15f4fc51a0ca88a99cc89454ec43d"}], "stats": {"total": 7535, "additions": 3760, "deletions": 3775}, "files": [{"sha": "4c845efdf344c8c6ca864d3f0dc395c964a70ab0", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -280,16 +280,16 @@ fn collect_tests_from_dir(config: &Config,\n                           -> io::Result<()> {\n     // Ignore directories that contain a file\n     // `compiletest-ignore-dir`.\n-    for file in try!(fs::read_dir(dir)) {\n-        let file = try!(file);\n+    for file in fs::read_dir(dir)? {\n+        let file = file?;\n         if file.file_name() == *\"compiletest-ignore-dir\" {\n             return Ok(());\n         }\n     }\n \n-    let dirs = try!(fs::read_dir(dir));\n+    let dirs = fs::read_dir(dir)?;\n     for file in dirs {\n-        let file = try!(file);\n+        let file = file?;\n         let file_path = file.path();\n         debug!(\"inspecting file {:?}\", file_path.display());\n         if is_test(config, &file_path) {\n@@ -310,11 +310,11 @@ fn collect_tests_from_dir(config: &Config,\n             tests.push(make_test(config, &paths))\n         } else if file_path.is_dir() {\n             let relative_file_path = relative_dir_path.join(file.file_name());\n-            try!(collect_tests_from_dir(config,\n+            collect_tests_from_dir(config,\n                                         base,\n                                         &file_path,\n                                         &relative_file_path,\n-                                        tests));\n+                                        tests)?;\n         }\n     }\n     Ok(())"}, {"sha": "d33746389a0a0a6081fdf791b5b4265f5940cb27", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> {\n     fn write_str(&mut self, mut s: &str) -> fmt::Result {\n         while !s.is_empty() {\n             if self.on_newline {\n-                try!(self.fmt.write_str(\"    \"));\n+                self.fmt.write_str(\"    \")?;\n             }\n \n             let split = match s.find('\\n') {\n@@ -42,7 +42,7 @@ impl<'a, 'b: 'a> fmt::Write for PadAdapter<'a, 'b> {\n                     s.len()\n                 }\n             };\n-            try!(self.fmt.write_str(&s[..split]));\n+            self.fmt.write_str(&s[..split])?;\n             s = &s[split..];\n         }\n \n@@ -169,10 +169,10 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n         if self.fields > 0 {\n             self.result = self.result.and_then(|_| {\n                 if self.is_pretty() {\n-                    try!(self.fmt.write_str(\"\\n\"));\n+                    self.fmt.write_str(\"\\n\")?;\n                 }\n                 if self.fields == 1 && self.empty_name {\n-                    try!(self.fmt.write_str(\",\"));\n+                    self.fmt.write_str(\",\")?;\n                 }\n                 self.fmt.write_str(\")\")\n             });"}, {"sha": "2f02f5c21f51b8768c837f04fe07d07fe9b2d12e", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -795,24 +795,24 @@ pub fn write(output: &mut Write, args: Arguments) -> Result {\n         None => {\n             // We can use default formatting parameters for all arguments.\n             for (arg, piece) in args.args.iter().zip(pieces.by_ref()) {\n-                try!(formatter.buf.write_str(*piece));\n-                try!((arg.formatter)(arg.value, &mut formatter));\n+                formatter.buf.write_str(*piece)?;\n+                (arg.formatter)(arg.value, &mut formatter)?;\n             }\n         }\n         Some(fmt) => {\n             // Every spec has a corresponding argument that is preceded by\n             // a string piece.\n             for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n-                try!(formatter.buf.write_str(*piece));\n-                try!(formatter.run(arg));\n+                formatter.buf.write_str(*piece)?;\n+                formatter.run(arg)?;\n             }\n         }\n     }\n \n     // There can be only one trailing string piece left.\n     match pieces.next() {\n         Some(piece) => {\n-            try!(formatter.buf.write_str(*piece));\n+            formatter.buf.write_str(*piece)?;\n         }\n         None => {}\n     }\n@@ -897,9 +897,9 @@ impl<'a> Formatter<'a> {\n         // Writes the sign if it exists, and then the prefix if it was requested\n         let write_prefix = |f: &mut Formatter| {\n             if let Some(c) = sign {\n-                try!(f.buf.write_str(unsafe {\n+                f.buf.write_str(unsafe {\n                     str::from_utf8_unchecked(c.encode_utf8().as_slice())\n-                }));\n+                })?;\n             }\n             if prefixed { f.buf.write_str(prefix) }\n             else { Ok(()) }\n@@ -910,26 +910,26 @@ impl<'a> Formatter<'a> {\n             // If there's no minimum length requirements then we can just\n             // write the bytes.\n             None => {\n-                try!(write_prefix(self)); self.buf.write_str(buf)\n+                write_prefix(self)?; self.buf.write_str(buf)\n             }\n             // Check if we're over the minimum width, if so then we can also\n             // just write the bytes.\n             Some(min) if width >= min => {\n-                try!(write_prefix(self)); self.buf.write_str(buf)\n+                write_prefix(self)?; self.buf.write_str(buf)\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n             Some(min) if self.sign_aware_zero_pad() => {\n                 self.fill = '0';\n-                try!(write_prefix(self));\n+                write_prefix(self)?;\n                 self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n                     f.buf.write_str(buf)\n                 })\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n                 self.with_padding(min - width, rt::v1::Alignment::Right, |f| {\n-                    try!(write_prefix(f)); f.buf.write_str(buf)\n+                    write_prefix(f)?; f.buf.write_str(buf)\n                 })\n             }\n         }\n@@ -1008,13 +1008,13 @@ impl<'a> Formatter<'a> {\n         };\n \n         for _ in 0..pre_pad {\n-            try!(self.buf.write_str(fill));\n+            self.buf.write_str(fill)?;\n         }\n \n-        try!(f(self));\n+        f(self)?;\n \n         for _ in 0..post_pad {\n-            try!(self.buf.write_str(fill));\n+            self.buf.write_str(fill)?;\n         }\n \n         Ok(())\n@@ -1033,7 +1033,7 @@ impl<'a> Formatter<'a> {\n             if self.sign_aware_zero_pad() {\n                 // a sign always goes first\n                 let sign = unsafe { str::from_utf8_unchecked(formatted.sign) };\n-                try!(self.buf.write_str(sign));\n+                self.buf.write_str(sign)?;\n \n                 // remove the sign from the formatted parts\n                 formatted.sign = b\"\";\n@@ -1065,19 +1065,19 @@ impl<'a> Formatter<'a> {\n         }\n \n         if !formatted.sign.is_empty() {\n-            try!(write_bytes(self.buf, formatted.sign));\n+            write_bytes(self.buf, formatted.sign)?;\n         }\n         for part in formatted.parts {\n             match *part {\n                 flt2dec::Part::Zero(mut nzeroes) => {\n                     const ZEROES: &'static str = // 64 zeroes\n                         \"0000000000000000000000000000000000000000000000000000000000000000\";\n                     while nzeroes > ZEROES.len() {\n-                        try!(self.buf.write_str(ZEROES));\n+                        self.buf.write_str(ZEROES)?;\n                         nzeroes -= ZEROES.len();\n                     }\n                     if nzeroes > 0 {\n-                        try!(self.buf.write_str(&ZEROES[..nzeroes]));\n+                        self.buf.write_str(&ZEROES[..nzeroes])?;\n                     }\n                 }\n                 flt2dec::Part::Num(mut v) => {\n@@ -1087,10 +1087,10 @@ impl<'a> Formatter<'a> {\n                         *c = b'0' + (v % 10) as u8;\n                         v /= 10;\n                     }\n-                    try!(write_bytes(self.buf, &s[..len]));\n+                    write_bytes(self.buf, &s[..len])?;\n                 }\n                 flt2dec::Part::Copy(buf) => {\n-                    try!(write_bytes(self.buf, buf));\n+                    write_bytes(self.buf, buf)?;\n                 }\n             }\n         }\n@@ -1349,20 +1349,20 @@ impl Display for bool {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        try!(f.write_char('\"'));\n+        f.write_char('\"')?;\n         let mut from = 0;\n         for (i, c) in self.char_indices() {\n             let esc = c.escape_default();\n             // If char needs escaping, flush backlog so far and write, else skip\n             if esc.size_hint() != (1, Some(1)) {\n-                try!(f.write_str(&self[from..i]));\n+                f.write_str(&self[from..i])?;\n                 for c in esc {\n-                    try!(f.write_char(c));\n+                    f.write_char(c)?;\n                 }\n                 from = i + c.len_utf8();\n             }\n         }\n-        try!(f.write_str(&self[from..]));\n+        f.write_str(&self[from..])?;\n         f.write_char('\"')\n     }\n }\n@@ -1377,9 +1377,9 @@ impl Display for str {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Debug for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        try!(f.write_char('\\''));\n+        f.write_char('\\'')?;\n         for c in self.escape_default() {\n-            try!(f.write_char(c))\n+            f.write_char(c)?\n         }\n         f.write_char('\\'')\n     }"}, {"sha": "484810783a45ec5de1b5dea9e765cde511a1ff0f", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -214,7 +214,7 @@ fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     }\n     let (sign, s) = extract_sign(s);\n     let flt = match parse_decimal(s) {\n-        ParseResult::Valid(decimal) => try!(convert(decimal)),\n+        ParseResult::Valid(decimal) => convert(decimal)?,\n         ParseResult::ShortcutToInf => T::infinity(),\n         ParseResult::ShortcutToZero => T::zero(),\n         ParseResult::Invalid => match s {"}, {"sha": "8f21f109e81b7da372fa6229a7b4c743e7730825", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -240,7 +240,7 @@ impl Utf8Error {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n-    try!(run_utf8_validation(v));\n+    run_utf8_validation(v)?;\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n "}, {"sha": "d4d3ac93c97b906f69dbcd0ae594fd2b1704d12b", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -662,7 +662,7 @@ pub fn render_opts<'a, N, E, G, W>(g: &'a G,\n {\n     fn writeln<W: Write>(w: &mut W, arg: &[&str]) -> io::Result<()> {\n         for &s in arg {\n-            try!(w.write_all(s.as_bytes()));\n+            w.write_all(s.as_bytes())?;\n         }\n         write!(w, \"\\n\")\n     }\n@@ -671,9 +671,9 @@ pub fn render_opts<'a, N, E, G, W>(g: &'a G,\n         w.write_all(b\"    \")\n     }\n \n-    try!(writeln(w, &[\"digraph \", g.graph_id().as_slice(), \" {\"]));\n+    writeln(w, &[\"digraph \", g.graph_id().as_slice(), \" {\"])?;\n     for n in g.nodes().iter() {\n-        try!(indent(w));\n+        indent(w)?;\n         let id = g.node_id(n);\n \n         let escaped = &g.node_label(n).to_dot_string();\n@@ -702,12 +702,12 @@ pub fn render_opts<'a, N, E, G, W>(g: &'a G,\n         }\n \n         text.push(\";\");\n-        try!(writeln(w, &text));\n+        writeln(w, &text)?;\n     }\n \n     for e in g.edges().iter() {\n         let escaped_label = &g.edge_label(e).to_dot_string();\n-        try!(indent(w));\n+        indent(w)?;\n         let source = g.source(e);\n         let target = g.target(e);\n         let source_id = g.node_id(&source);\n@@ -729,7 +729,7 @@ pub fn render_opts<'a, N, E, G, W>(g: &'a G,\n         }\n \n         text.push(\";\");\n-        try!(writeln(w, &text));\n+        writeln(w, &text)?;\n     }\n \n     writeln(w, &[\"}\"])\n@@ -959,7 +959,7 @@ mod tests {\n         let mut writer = Vec::new();\n         render(&g, &mut writer).unwrap();\n         let mut s = String::new();\n-        try!(Read::read_to_string(&mut &*writer, &mut s));\n+        Read::read_to_string(&mut &*writer, &mut s)?;\n         Ok(s)\n     }\n "}, {"sha": "a02c02cc0308819e06aa4d0ddccbe21b13dd7f53", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -398,8 +398,8 @@ pub mod reader {\n     }\n \n     pub fn doc_at<'a>(data: &'a [u8], start: usize) -> DecodeResult<TaggedDoc<'a>> {\n-        let elt_tag = try!(tag_at(data, start));\n-        let elt_size = try!(tag_len_at(data, elt_tag));\n+        let elt_tag = tag_at(data, start)?;\n+        let elt_size = tag_len_at(data, elt_tag)?;\n         let end = elt_size.next + elt_size.val;\n         Ok(TaggedDoc {\n             tag: elt_tag.val,\n@@ -581,7 +581,7 @@ pub mod reader {\n             if self.pos >= self.parent.end {\n                 return Err(Expected(format!(\"no more documents in current node!\")));\n             }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = try!(doc_at(self.parent.data, self.pos));\n+            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n             debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n                    self.parent.start,\n                    self.parent.end,\n@@ -607,12 +607,12 @@ pub mod reader {\n         fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T>\n             where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n         {\n-            let d = try!(self.next_doc(exp_tag));\n+            let d = self.next_doc(exp_tag)?;\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n             self.parent = d;\n             self.pos = d.start;\n-            let r = try!(f(self));\n+            let r = f(self)?;\n             self.parent = old_parent;\n             self.pos = old_pos;\n             Ok(r)\n@@ -624,7 +624,7 @@ pub mod reader {\n                 return Ok(0);\n             }\n \n-            let TaggedDoc { tag: r_tag, doc: r_doc } = try!(doc_at(self.parent.data, self.pos));\n+            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n             let r = if r_tag == (EsSub8 as usize) {\n                 doc_as_u8(r_doc) as usize\n             } else if r_tag == (EsSub32 as usize) {\n@@ -659,7 +659,7 @@ pub mod reader {\n                 return Err(Expected(format!(\"no more documents in current node!\")));\n             }\n \n-            let TaggedDoc { tag: r_tag, doc: r_doc } = try!(doc_at(self.parent.data, self.pos));\n+            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n             let r = if first_tag as usize <= r_tag && r_tag <= last_tag as usize {\n                 match r_tag - first_tag as usize {\n                     0 => doc_as_u8(r_doc) as u64,\n@@ -689,11 +689,11 @@ pub mod reader {\n         pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R>\n             where F: FnOnce(&mut opaque::Decoder, Doc) -> DecodeResult<R>\n         {\n-            let doc = try!(self.next_doc(EsOpaque));\n+            let doc = self.next_doc(EsOpaque)?;\n \n             let result = {\n                 let mut opaque_decoder = opaque::Decoder::new(doc.data, doc.start);\n-                try!(op(&mut opaque_decoder, doc))\n+                op(&mut opaque_decoder, doc)?\n             };\n \n             Ok(result)\n@@ -718,16 +718,16 @@ pub mod reader {\n             self._next_int(EsU8, EsU64)\n         }\n         fn read_u32(&mut self) -> DecodeResult<u32> {\n-            Ok(try!(self._next_int(EsU8, EsU32)) as u32)\n+            Ok(self._next_int(EsU8, EsU32)? as u32)\n         }\n         fn read_u16(&mut self) -> DecodeResult<u16> {\n-            Ok(try!(self._next_int(EsU8, EsU16)) as u16)\n+            Ok(self._next_int(EsU8, EsU16)? as u16)\n         }\n         fn read_u8(&mut self) -> DecodeResult<u8> {\n-            Ok(doc_as_u8(try!(self.next_doc(EsU8))))\n+            Ok(doc_as_u8(self.next_doc(EsU8)?))\n         }\n         fn read_uint(&mut self) -> DecodeResult<usize> {\n-            let v = try!(self._next_int(EsU8, EsU64));\n+            let v = self._next_int(EsU8, EsU64)?;\n             if v > (::std::usize::MAX as u64) {\n                 Err(IntTooBig(v as usize))\n             } else {\n@@ -736,19 +736,19 @@ pub mod reader {\n         }\n \n         fn read_i64(&mut self) -> DecodeResult<i64> {\n-            Ok(try!(self._next_int(EsI8, EsI64)) as i64)\n+            Ok(self._next_int(EsI8, EsI64)? as i64)\n         }\n         fn read_i32(&mut self) -> DecodeResult<i32> {\n-            Ok(try!(self._next_int(EsI8, EsI32)) as i32)\n+            Ok(self._next_int(EsI8, EsI32)? as i32)\n         }\n         fn read_i16(&mut self) -> DecodeResult<i16> {\n-            Ok(try!(self._next_int(EsI8, EsI16)) as i16)\n+            Ok(self._next_int(EsI8, EsI16)? as i16)\n         }\n         fn read_i8(&mut self) -> DecodeResult<i8> {\n-            Ok(doc_as_u8(try!(self.next_doc(EsI8))) as i8)\n+            Ok(doc_as_u8(self.next_doc(EsI8)?) as i8)\n         }\n         fn read_int(&mut self) -> DecodeResult<isize> {\n-            let v = try!(self._next_int(EsI8, EsI64)) as i64;\n+            let v = self._next_int(EsI8, EsI64)? as i64;\n             if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n                 Err(IntTooBig(v as usize))\n@@ -758,22 +758,22 @@ pub mod reader {\n         }\n \n         fn read_bool(&mut self) -> DecodeResult<bool> {\n-            Ok(doc_as_u8(try!(self.next_doc(EsBool))) != 0)\n+            Ok(doc_as_u8(self.next_doc(EsBool)?) != 0)\n         }\n \n         fn read_f64(&mut self) -> DecodeResult<f64> {\n-            let bits = doc_as_u64(try!(self.next_doc(EsF64)));\n+            let bits = doc_as_u64(self.next_doc(EsF64)?);\n             Ok(unsafe { transmute(bits) })\n         }\n         fn read_f32(&mut self) -> DecodeResult<f32> {\n-            let bits = doc_as_u32(try!(self.next_doc(EsF32)));\n+            let bits = doc_as_u32(self.next_doc(EsF32)?);\n             Ok(unsafe { transmute(bits) })\n         }\n         fn read_char(&mut self) -> DecodeResult<char> {\n-            Ok(char::from_u32(doc_as_u32(try!(self.next_doc(EsChar)))).unwrap())\n+            Ok(char::from_u32(doc_as_u32(self.next_doc(EsChar)?)).unwrap())\n         }\n         fn read_str(&mut self) -> DecodeResult<String> {\n-            Ok(try!(self.next_doc(EsStr)).as_str())\n+            Ok(self.next_doc(EsStr)?.as_str())\n         }\n \n         // Compound types:\n@@ -782,13 +782,13 @@ pub mod reader {\n         {\n             debug!(\"read_enum({})\", name);\n \n-            let doc = try!(self.next_doc(EsEnum));\n+            let doc = self.next_doc(EsEnum)?;\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n             self.parent = doc;\n             self.pos = self.parent.start;\n \n-            let result = try!(f(self));\n+            let result = f(self)?;\n \n             self.parent = old_parent;\n             self.pos = old_pos;\n@@ -799,7 +799,7 @@ pub mod reader {\n             where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n         {\n             debug!(\"read_enum_variant()\");\n-            let idx = try!(self._next_sub());\n+            let idx = self._next_sub()?;\n             debug!(\"  idx={}\", idx);\n \n             f(self, idx)\n@@ -816,7 +816,7 @@ pub mod reader {\n             where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n         {\n             debug!(\"read_enum_struct_variant()\");\n-            let idx = try!(self._next_sub());\n+            let idx = self._next_sub()?;\n             debug!(\"  idx={}\", idx);\n \n             f(self, idx)\n@@ -904,7 +904,7 @@ pub mod reader {\n         {\n             debug!(\"read_seq()\");\n             self.push_doc(EsVec, move |d| {\n-                let len = try!(d._next_sub());\n+                let len = d._next_sub()?;\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n@@ -922,7 +922,7 @@ pub mod reader {\n         {\n             debug!(\"read_map()\");\n             self.push_doc(EsMap, move |d| {\n-                let len = try!(d._next_sub());\n+                let len = d._next_sub()?;\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n@@ -1020,19 +1020,19 @@ pub mod writer {\n             assert!(tag_id >= NUM_IMPLICIT_TAGS);\n \n             // Write the enum ID:\n-            try!(write_tag(self.writer, tag_id));\n+            write_tag(self.writer, tag_id)?;\n \n             // Write a placeholder four-byte size.\n-            let cur_pos = try!(self.writer.seek(SeekFrom::Current(0)));\n+            let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n             self.size_positions.push(cur_pos);\n             let zeroes: &[u8] = &[0, 0, 0, 0];\n             self.writer.write_all(zeroes)\n         }\n \n         pub fn end_tag(&mut self) -> EncodeResult {\n             let last_size_pos = self.size_positions.pop().unwrap();\n-            let cur_pos = try!(self.writer.seek(SeekFrom::Current(0)));\n-            try!(self.writer.seek(SeekFrom::Start(last_size_pos)));\n+            let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n+            self.writer.seek(SeekFrom::Start(last_size_pos))?;\n             let size = (cur_pos - last_size_pos - 4) as usize;\n \n             // relax the size encoding for small tags (bigger tags are costly to move).\n@@ -1048,12 +1048,12 @@ pub mod writer {\n                 }\n \n                 // overwrite the size and data and continue\n-                try!(write_vuint(self.writer, size));\n-                try!(self.writer.write_all(&buf[..size]));\n+                write_vuint(self.writer, size)?;\n+                self.writer.write_all(&buf[..size])?;\n             } else {\n                 // overwrite the size with an overlong encoding and skip past the data\n-                try!(write_sized_vuint(self.writer, size, 4));\n-                try!(self.writer.seek(SeekFrom::Start(cur_pos)));\n+                write_sized_vuint(self.writer, size, 4)?;\n+                self.writer.seek(SeekFrom::Start(cur_pos))?;\n             }\n \n             debug!(\"End tag (size = {:?})\", size);\n@@ -1063,15 +1063,15 @@ pub mod writer {\n         pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult\n             where F: FnOnce() -> EncodeResult\n         {\n-            try!(self.start_tag(tag_id));\n-            try!(blk());\n+            self.start_tag(tag_id)?;\n+            blk()?;\n             self.end_tag()\n         }\n \n         pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n             assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-            try!(write_tag(self.writer, tag_id));\n-            try!(write_vuint(self.writer, b.len()));\n+            write_tag(self.writer, tag_id)?;\n+            write_vuint(self.writer, b.len())?;\n             self.writer.write_all(b)\n         }\n \n@@ -1124,7 +1124,7 @@ pub mod writer {\n \n         // for auto-serialization\n         fn wr_tagged_raw_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-            try!(write_tag(self.writer, tag_id));\n+            write_tag(self.writer, tag_id)?;\n             self.writer.write_all(b)\n         }\n \n@@ -1200,11 +1200,11 @@ pub mod writer {\n         pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult\n             where F: FnOnce(&mut opaque::Encoder) -> EncodeResult\n         {\n-            try!(self.start_tag(EsOpaque as usize));\n+            self.start_tag(EsOpaque as usize)?;\n \n             {\n                 let mut opaque_encoder = opaque::Encoder::new(self.writer);\n-                try!(f(&mut opaque_encoder));\n+                f(&mut opaque_encoder)?;\n             }\n \n             self.mark_stable_position();\n@@ -1298,15 +1298,15 @@ pub mod writer {\n         fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n             where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n-            try!(self.start_tag(EsEnum as usize));\n-            try!(f(self));\n+            self.start_tag(EsEnum as usize)?;\n+            f(self)?;\n             self.end_tag()\n         }\n \n         fn emit_enum_variant<F>(&mut self, _: &str, v_id: usize, _: usize, f: F) -> EncodeResult\n             where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n-            try!(self._emit_tagged_sub(v_id));\n+            self._emit_tagged_sub(v_id)?;\n             f(self)\n         }\n \n@@ -1390,18 +1390,18 @@ pub mod writer {\n                 return self.wr_tagged_bytes(EsVec as usize, &[]);\n             }\n \n-            try!(self.start_tag(EsVec as usize));\n-            try!(self._emit_tagged_sub(len));\n-            try!(f(self));\n+            self.start_tag(EsVec as usize)?;\n+            self._emit_tagged_sub(len)?;\n+            f(self)?;\n             self.end_tag()\n         }\n \n         fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n             where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n \n-            try!(self.start_tag(EsVecElt as usize));\n-            try!(f(self));\n+            self.start_tag(EsVecElt as usize)?;\n+            f(self)?;\n             self.end_tag()\n         }\n \n@@ -1413,26 +1413,26 @@ pub mod writer {\n                 return self.wr_tagged_bytes(EsMap as usize, &[]);\n             }\n \n-            try!(self.start_tag(EsMap as usize));\n-            try!(self._emit_tagged_sub(len));\n-            try!(f(self));\n+            self.start_tag(EsMap as usize)?;\n+            self._emit_tagged_sub(len)?;\n+            f(self)?;\n             self.end_tag()\n         }\n \n         fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n             where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n \n-            try!(self.start_tag(EsMapKey as usize));\n-            try!(f(self));\n+            self.start_tag(EsMapKey as usize)?;\n+            f(self)?;\n             self.end_tag()\n         }\n \n         fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n             where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n         {\n-            try!(self.start_tag(EsMapVal as usize));\n-            try!(f(self));\n+            self.start_tag(EsMapVal as usize)?;\n+            f(self)?;\n             self.end_tag()\n         }\n     }"}, {"sha": "10f419d169181da14639fa1eee06bf9d1d6cb1ee", "filename": "src/librbml/opaque.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrbml%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrbml%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fopaque.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -120,7 +120,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     }\n \n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n-        try!(self.emit_uint(v.len()));\n+        self.emit_uint(v.len())?;\n         let _ = self.cursor.write_all(v.as_bytes());\n         Ok(())\n     }\n@@ -139,7 +139,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n                             -> EncodeResult\n         where F: FnOnce(&mut Self) -> EncodeResult\n     {\n-        try!(self.emit_uint(v_id));\n+        self.emit_uint(v_id)?;\n         f(self)\n     }\n \n@@ -221,7 +221,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n         where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n-        try!(self.emit_uint(len));\n+        self.emit_uint(len)?;\n         f(self)\n     }\n \n@@ -234,7 +234,7 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n     fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n         where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n     {\n-        try!(self.emit_uint(len));\n+        self.emit_uint(len)?;\n         f(self)\n     }\n \n@@ -356,27 +356,27 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     }\n \n     fn read_bool(&mut self) -> Result<bool, Self::Error> {\n-        let value = try!(self.read_u8());\n+        let value = self.read_u8()?;\n         Ok(value != 0)\n     }\n \n     fn read_f64(&mut self) -> Result<f64, Self::Error> {\n-        let bits = try!(self.read_u64());\n+        let bits = self.read_u64()?;\n         Ok(unsafe { ::std::mem::transmute(bits) })\n     }\n \n     fn read_f32(&mut self) -> Result<f32, Self::Error> {\n-        let bits = try!(self.read_u32());\n+        let bits = self.read_u32()?;\n         Ok(unsafe { ::std::mem::transmute(bits) })\n     }\n \n     fn read_char(&mut self) -> Result<char, Self::Error> {\n-        let bits = try!(self.read_u32());\n+        let bits = self.read_u32()?;\n         Ok(::std::char::from_u32(bits).unwrap())\n     }\n \n     fn read_str(&mut self) -> Result<String, Self::Error> {\n-        let len = try!(self.read_uint());\n+        let len = self.read_uint()?;\n         let s = ::std::str::from_utf8(&self.data[self.position..self.position + len]).unwrap();\n         self.position += len;\n         Ok(s.to_string())\n@@ -391,7 +391,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n-        let disr = try!(self.read_uint());\n+        let disr = self.read_uint()?;\n         f(self, disr)\n     }\n \n@@ -404,7 +404,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n-        let disr = try!(self.read_uint());\n+        let disr = self.read_uint()?;\n         f(self, disr)\n     }\n \n@@ -483,7 +483,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n-        let len = try!(self.read_uint());\n+        let len = self.read_uint()?;\n         f(self, len)\n     }\n \n@@ -496,7 +496,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>\n     {\n-        let len = try!(self.read_uint());\n+        let len = self.read_uint()?;\n         f(self, len)\n     }\n "}, {"sha": "b5e1d5899967fd16c55324227bf26eab622999ec", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -68,7 +68,7 @@ struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n /// ++++++++++++++++++++++++++\n impl<'a> fmt::Debug for Matrix<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"\\n\"));\n+        write!(f, \"\\n\")?;\n \n         let &Matrix(ref m) = self;\n         let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n@@ -85,16 +85,16 @@ impl<'a> fmt::Debug for Matrix<'a> {\n \n         let total_width = column_widths.iter().cloned().sum::<usize>() + column_count * 3 + 1;\n         let br = repeat('+').take(total_width).collect::<String>();\n-        try!(write!(f, \"{}\\n\", br));\n+        write!(f, \"{}\\n\", br)?;\n         for row in pretty_printed_matrix {\n-            try!(write!(f, \"+\"));\n+            write!(f, \"+\")?;\n             for (column, pat_str) in row.into_iter().enumerate() {\n-                try!(write!(f, \" \"));\n-                try!(write!(f, \"{:1$}\", pat_str, column_widths[column]));\n-                try!(write!(f, \" +\"));\n+                write!(f, \" \")?;\n+                write!(f, \"{:1$}\", pat_str, column_widths[column])?;\n+                write!(f, \" +\")?;\n             }\n-            try!(write!(f, \"\\n\"));\n-            try!(write!(f, \"{}\\n\", br));\n+            write!(f, \"\\n\")?;\n+            write!(f, \"{}\\n\", br)?;\n         }\n         Ok(())\n     }"}, {"sha": "a8c2a73e72f5192c29c3b3018ab98fcd903a064a", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -639,14 +639,14 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                 _ => {},\n             }\n         }\n-        match try!(eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)) {\n+        match eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)? {\n           Float(f) => Float(-f),\n           Integral(i) => Integral(math!(e, -i)),\n           const_val => signal!(e, NegateOn(const_val)),\n         }\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)) {\n+        match eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)? {\n           Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n           const_val => signal!(e, NotOn(const_val)),\n@@ -661,8 +661,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         // gives us a type through a type-suffix, cast or const def type\n         // we need to re-eval the other value of the BinOp if it was\n         // not inferred\n-        match (try!(eval_const_expr_partial(tcx, &a, ty_hint, fn_args)),\n-               try!(eval_const_expr_partial(tcx, &b, b_ty, fn_args))) {\n+        match (eval_const_expr_partial(tcx, &a, ty_hint, fn_args)?,\n+               eval_const_expr_partial(tcx, &b, b_ty, fn_args)?) {\n           (Float(a), Float(b)) => {\n             match op.node {\n               hir::BiAdd => Float(a + b),\n@@ -744,7 +744,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                     // we had a type hint, so we can't have an unknown type\n                     None => unreachable!(),\n                 };\n-                try!(eval_const_expr_partial(tcx, &base, hint, fn_args))\n+                eval_const_expr_partial(tcx, &base, hint, fn_args)?\n             },\n             Err(e) => return Err(e),\n         };\n@@ -781,14 +781,14 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n                           Some(ty) => ty_hint.checked_or(ty),\n                           None => ty_hint,\n                       };\n-                      try!(eval_const_expr_partial(tcx, e, item_hint, None))\n+                      eval_const_expr_partial(tcx, e, item_hint, None)?\n                   } else {\n                       signal!(e, NonConstPath);\n                   }\n               },\n               Def::Variant(enum_def, variant_def) => {\n                   if let Some(const_expr) = lookup_variant_by_id(tcx, enum_def, variant_def) {\n-                      try!(eval_const_expr_partial(tcx, const_expr, ty_hint, None))\n+                      eval_const_expr_partial(tcx, const_expr, ty_hint, None)?\n                   } else {\n                       signal!(e, NonConstPath);\n                   }\n@@ -810,7 +810,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n       }\n       hir::ExprCall(ref callee, ref args) => {\n           let sub_ty_hint = ty_hint.erase_hint();\n-          let callee_val = try!(eval_const_expr_partial(tcx, callee, sub_ty_hint, fn_args));\n+          let callee_val = eval_const_expr_partial(tcx, callee, sub_ty_hint, fn_args)?;\n           let did = match callee_val {\n               Function(did) => did,\n               callee => signal!(e, CallOn(callee)),\n@@ -826,37 +826,37 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           let mut call_args = NodeMap();\n           for (arg, arg_expr) in decl.inputs.iter().zip(args.iter()) {\n               let arg_hint = ty_hint.erase_hint();\n-              let arg_val = try!(eval_const_expr_partial(\n+              let arg_val = eval_const_expr_partial(\n                   tcx,\n                   arg_expr,\n                   arg_hint,\n                   fn_args\n-              ));\n+              )?;\n               debug!(\"const call arg: {:?}\", arg);\n               let old = call_args.insert(arg.pat.id, arg_val);\n               assert!(old.is_none());\n           }\n           debug!(\"const call({:?})\", call_args);\n-          try!(eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args)))\n+          eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args))?\n       },\n-      hir::ExprLit(ref lit) => try!(lit_to_const(&lit.node, tcx, ety, lit.span)),\n+      hir::ExprLit(ref lit) => lit_to_const(&lit.node, tcx, ety, lit.span)?,\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => try!(eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)),\n+            Some(ref expr) => eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)?,\n             None => unreachable!(),\n         }\n       }\n-      hir::ExprType(ref e, _) => try!(eval_const_expr_partial(tcx, &e, ty_hint, fn_args)),\n+      hir::ExprType(ref e, _) => eval_const_expr_partial(tcx, &e, ty_hint, fn_args)?,\n       hir::ExprTup(_) => Tuple(e.id),\n       hir::ExprStruct(..) => Struct(e.id),\n       hir::ExprIndex(ref arr, ref idx) => {\n         if !tcx.sess.features.borrow().const_indexing {\n             signal!(e, IndexOpFeatureGated);\n         }\n         let arr_hint = ty_hint.erase_hint();\n-        let arr = try!(eval_const_expr_partial(tcx, arr, arr_hint, fn_args));\n+        let arr = eval_const_expr_partial(tcx, arr, arr_hint, fn_args)?;\n         let idx_hint = ty_hint.checked_or(tcx.types.usize);\n-        let idx = match try!(eval_const_expr_partial(tcx, idx, idx_hint, fn_args)) {\n+        let idx = match eval_const_expr_partial(tcx, idx, idx_hint, fn_args)? {\n             Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n             Integral(_) => unreachable!(),\n             _ => signal!(idx, IndexNotInt),\n@@ -866,18 +866,18 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n             Array(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n             Array(v, n) => if let hir::ExprVec(ref v) = tcx.map.expect_expr(v).node {\n                 assert_eq!(n as usize as u64, n);\n-                try!(eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args))\n+                eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args)?\n             } else {\n                 unreachable!()\n             },\n \n             Repeat(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n-            Repeat(elem, _) => try!(eval_const_expr_partial(\n+            Repeat(elem, _) => eval_const_expr_partial(\n                 tcx,\n                 &tcx.map.expect_expr(elem),\n                 ty_hint,\n                 fn_args,\n-            )),\n+            )?,\n \n             ByteStr(ref data) if idx >= data.len() as u64 => signal!(e, IndexOutOfBounds),\n             ByteStr(data) => {\n@@ -894,7 +894,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           let len_hint = ty_hint.checked_or(tcx.types.usize);\n           Repeat(\n               e.id,\n-              match try!(eval_const_expr_partial(tcx, &n, len_hint, fn_args)) {\n+              match eval_const_expr_partial(tcx, &n, len_hint, fn_args)? {\n                   Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n                   Integral(_) => signal!(e, RepeatCountNotNatural),\n                   _ => signal!(e, RepeatCountNotInt),\n@@ -903,11 +903,11 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n       },\n       hir::ExprTupField(ref base, index) => {\n         let base_hint = ty_hint.erase_hint();\n-        let c = try!(eval_const_expr_partial(tcx, base, base_hint, fn_args));\n+        let c = eval_const_expr_partial(tcx, base, base_hint, fn_args)?;\n         if let Tuple(tup_id) = c {\n             if let hir::ExprTup(ref fields) = tcx.map.expect_expr(tup_id).node {\n                 if index.node < fields.len() {\n-                    try!(eval_const_expr_partial(tcx, &fields[index.node], ty_hint, fn_args))\n+                    eval_const_expr_partial(tcx, &fields[index.node], ty_hint, fn_args)?\n                 } else {\n                     signal!(e, TupleIndexOutOfBounds);\n                 }\n@@ -921,14 +921,14 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n       hir::ExprField(ref base, field_name) => {\n         let base_hint = ty_hint.erase_hint();\n         // Get the base expression if it is a struct and it is constant\n-        let c = try!(eval_const_expr_partial(tcx, base, base_hint, fn_args));\n+        let c = eval_const_expr_partial(tcx, base, base_hint, fn_args)?;\n         if let Struct(struct_id) = c {\n             if let hir::ExprStruct(_, ref fields, _) = tcx.map.expect_expr(struct_id).node {\n                 // Check that the given field exists and evaluate it\n                 // if the idents are compared run-pass/issue-19244 fails\n                 if let Some(f) = fields.iter().find(|f| f.name.node\n                                                      == field_name.node) {\n-                    try!(eval_const_expr_partial(tcx, &f.expr, ty_hint, fn_args))\n+                    eval_const_expr_partial(tcx, &f.expr, ty_hint, fn_args)?\n                 } else {\n                     signal!(e, MissingStructField);\n                 }\n@@ -943,7 +943,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n     };\n \n     match (ety.map(|t| &t.sty), result) {\n-        (Some(ref ty_hint), Integral(i)) => Ok(Integral(try!(infer(i, tcx, ty_hint, e.span)))),\n+        (Some(ref ty_hint), Integral(i)) => Ok(Integral(infer(i, tcx, ty_hint, e.span)?)),\n         (_, result) => Ok(result),\n     }\n }\n@@ -1105,14 +1105,14 @@ fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastRe\n         ty::TyFloat(ast::FloatTy::F64) if val.is_negative() => {\n             // FIXME: this could probably be prettier\n             // there's no easy way to turn an `Infer` into a f64\n-            let val = try!((-val).map_err(Math));\n+            let val = (-val).map_err(Math)?;\n             let val = val.to_u64().unwrap() as f64;\n             let val = -val;\n             Ok(Float(val))\n         },\n         ty::TyFloat(ast::FloatTy::F64) => Ok(Float(val.to_u64().unwrap() as f64)),\n         ty::TyFloat(ast::FloatTy::F32) if val.is_negative() => {\n-            let val = try!((-val).map_err(Math));\n+            let val = (-val).map_err(Math)?;\n             let val = val.to_u64().unwrap() as f32;\n             let val = -val;\n             Ok(Float(val as f64))"}, {"sha": "d8cffa3c2c9f967a69c8fd66830ca94628d92774", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -152,10 +152,10 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n                 \"\".to_string()\n             };\n \n-            try!(ps.synth_comment(\n+            ps.synth_comment(\n                 format!(\"id {}: {}{}{}{}\", id, entry_str,\n-                        gens_str, action_kills_str, scope_kills_str)));\n-            try!(pp::space(&mut ps.s));\n+                        gens_str, action_kills_str, scope_kills_str))?;\n+            pp::space(&mut ps.s)?;\n         }\n         Ok(())\n     }\n@@ -534,9 +534,9 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n     fn pretty_print_to<'b>(&self, wr: Box<io::Write + 'b>,\n                            blk: &hir::Block) -> io::Result<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self, None);\n-        try!(ps.cbox(pprust::indent_unit));\n-        try!(ps.ibox(0));\n-        try!(ps.print_block(blk));\n+        ps.cbox(pprust::indent_unit)?;\n+        ps.ibox(0)?;\n+        ps.print_block(blk)?;\n         pp::eof(&mut ps.s)\n     }\n }"}, {"sha": "98fdcc65835fe83ae25a4c4a14b4bf2f929b7dd2", "filename": "src/librustc/middle/def_id.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef_id.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -55,21 +55,21 @@ pub struct DefId {\n \n impl fmt::Debug for DefId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"DefId {{ krate: {:?}, node: {:?}\",\n-                    self.krate, self.index));\n+        write!(f, \"DefId {{ krate: {:?}, node: {:?}\",\n+                    self.krate, self.index)?;\n \n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n         if self.is_local() { // (1)\n             // (1) side-step fact that not all external things have paths at\n             // the moment, such as type parameters\n-            try!(ty::tls::with_opt(|opt_tcx| {\n+            ty::tls::with_opt(|opt_tcx| {\n                 if let Some(tcx) = opt_tcx {\n-                    try!(write!(f, \" => {}\", tcx.item_path_str(*self)));\n+                    write!(f, \" => {}\", tcx.item_path_str(*self))?;\n                 }\n                 Ok(())\n-            }));\n+            })?;\n         }\n \n         write!(f, \" }}\")"}, {"sha": "ded64fa1d30574ca393362387aa631ccba09d6d8", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -1182,7 +1182,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = upvar_def.var_id();\n-        let var_ty = try!(self.typer.node_ty(var_id));\n+        let var_ty = self.typer.node_ty(var_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }"}, {"sha": "76a87675e3da6b0ccc41c5732b74fdacbc4cb191", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -86,12 +86,12 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n             }\n \n             (&ty::TyInfer(TyVar(a_id)), _) => {\n-                try!(self.fields.instantiate(b, BiTo, a_id));\n+                self.fields.instantiate(b, BiTo, a_id)?;\n                 Ok(a)\n             }\n \n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                try!(self.fields.instantiate(a, BiTo, b_id));\n+                self.fields.instantiate(a, BiTo, b_id)?;\n                 Ok(a)\n             }\n \n@@ -111,7 +111,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n     {\n         let a1 = self.tcx().erase_late_bound_regions(a);\n         let b1 = self.tcx().erase_late_bound_regions(b);\n-        let c = try!(self.relate(&a1, &b1));\n+        let c = self.relate(&a1, &b1)?;\n         Ok(ty::Binder(c))\n     }\n }"}, {"sha": "cbb5586f720c5d4cc3ff7b44b3352ae108229e93", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -70,10 +70,10 @@ pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n     match (&a.sty, &b.sty) {\n         // Relate integral variables to other types\n         (&ty::TyInfer(ty::IntVar(a_id)), &ty::TyInfer(ty::IntVar(b_id))) => {\n-            try!(infcx.int_unification_table\n+            infcx.int_unification_table\n                       .borrow_mut()\n                       .unify_var_var(a_id, b_id)\n-                      .map_err(|e| int_unification_error(a_is_expected, e)));\n+                      .map_err(|e| int_unification_error(a_is_expected, e))?;\n             Ok(a)\n         }\n         (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n@@ -91,10 +91,10 @@ pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n \n         // Relate floating-point variables to other types\n         (&ty::TyInfer(ty::FloatVar(a_id)), &ty::TyInfer(ty::FloatVar(b_id))) => {\n-            try!(infcx.float_unification_table\n+            infcx.float_unification_table\n                       .borrow_mut()\n                       .unify_var_var(a_id, b_id)\n-                      .map_err(|e| float_unification_error(relation.a_is_expected(), e)));\n+                      .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n             Ok(a)\n         }\n         (&ty::TyInfer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n@@ -123,11 +123,11 @@ fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                     val: ty::IntVarValue)\n                                     -> RelateResult<'tcx, Ty<'tcx>>\n {\n-    try!(infcx\n+    infcx\n          .int_unification_table\n          .borrow_mut()\n          .unify_var_value(vid, val)\n-         .map_err(|e| int_unification_error(vid_is_expected, e)));\n+         .map_err(|e| int_unification_error(vid_is_expected, e))?;\n     match val {\n         IntType(v) => Ok(infcx.tcx.mk_mach_int(v)),\n         UintType(v) => Ok(infcx.tcx.mk_mach_uint(v)),\n@@ -140,11 +140,11 @@ fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                  val: ast::FloatTy)\n                                  -> RelateResult<'tcx, Ty<'tcx>>\n {\n-    try!(infcx\n+    infcx\n          .float_unification_table\n          .borrow_mut()\n          .unify_var_value(vid, val)\n-         .map_err(|e| float_unification_error(vid_is_expected, e)));\n+         .map_err(|e| float_unification_error(vid_is_expected, e))?;\n     Ok(infcx.tcx.mk_mach_float(val))\n }\n \n@@ -229,10 +229,10 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n                 Some(t) => t, // ...already instantiated.\n                 None => {     // ...not yet instantiated:\n                     // Generalize type if necessary.\n-                    let generalized_ty = try!(match dir {\n+                    let generalized_ty = match dir {\n                         EqTo => self.generalize(a_ty, b_vid, false),\n                         BiTo | SupertypeOf | SubtypeOf => self.generalize(a_ty, b_vid, true),\n-                    });\n+                    }?;\n                     debug!(\"instantiate(a_ty={:?}, dir={:?}, \\\n                                         b_vid={:?}, generalized_ty={:?})\",\n                            a_ty, dir, b_vid,\n@@ -252,12 +252,12 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n             // relations wind up attributed to the same spans. We need\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n-            try!(match dir {\n+            match dir {\n                 BiTo => self.bivariate().relate(&a_ty, &b_ty),\n                 EqTo => self.equate().relate(&a_ty, &b_ty),\n                 SubtypeOf => self.sub().relate(&a_ty, &b_ty),\n                 SupertypeOf => self.sub().relate_with_variance(ty::Contravariant, &a_ty, &b_ty),\n-            });\n+            }?;\n         }\n \n         Ok(())"}, {"sha": "dd576c75ba3b4b61e2752fed8f4ced5b351d0cfd", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -59,17 +59,17 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n             }\n \n             (&ty::TyInfer(TyVar(a_id)), _) => {\n-                try!(self.fields.instantiate(b, EqTo, a_id));\n+                self.fields.instantiate(b, EqTo, a_id)?;\n                 Ok(a)\n             }\n \n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                try!(self.fields.instantiate(a, EqTo, b_id));\n+                self.fields.instantiate(a, EqTo, b_id)?;\n                 Ok(a)\n             }\n \n             _ => {\n-                try!(combine::super_combine_tys(self.fields.infcx, self, a, b));\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)?;\n                 Ok(a)\n             }\n         }\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'a, 'tcx>\n     {\n-        try!(self.fields.higher_ranked_sub(a, b));\n+        self.fields.higher_ranked_sub(a, b)?;\n         self.fields.higher_ranked_sub(b, a)\n     }\n }"}, {"sha": "7779be896cf57d71cafc5025a0a3d41e5246afea", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -78,8 +78,8 @@ impl<'a, 'tcx> LatticeDir<'a,'tcx> for Glb<'a, 'tcx> {\n \n     fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub();\n-        try!(sub.relate(&v, &a));\n-        try!(sub.relate(&v, &b));\n+        sub.relate(&v, &a)?;\n+        sub.relate(&v, &b)?;\n         Ok(())\n     }\n }"}, {"sha": "44ba6ec4a7a7dfad9c73ba1d878e2838731bc42c", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -75,7 +75,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n             debug!(\"b_prime={:?}\", b_prime);\n \n             // Compare types now that bound regions have been replaced.\n-            let result = try!(self.sub().relate(&a_prime, &b_prime));\n+            let result = self.sub().relate(&a_prime, &b_prime)?;\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n@@ -118,7 +118,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n \n             // Collect constraints.\n             let result0 =\n-                try!(self.lub().relate(&a_with_fresh, &b_with_fresh));\n+                self.lub().relate(&a_with_fresh, &b_with_fresh)?;\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"lub result0 = {:?}\", result0);\n@@ -212,7 +212,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n \n             // Collect constraints.\n             let result0 =\n-                try!(self.glb().relate(&a_with_fresh, &b_with_fresh));\n+                self.glb().relate(&a_with_fresh, &b_with_fresh)?;\n             let result0 =\n                 self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"glb result0 = {:?}\", result0);"}, {"sha": "dc4cbd14a5da20f1715c79bf92cf2a396867f453", "filename": "src/librustc/middle/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -66,14 +66,14 @@ pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n         (&ty::TyInfer(TyVar(..)), &ty::TyInfer(TyVar(..)))\n             if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {\n             let v = infcx.next_diverging_ty_var();\n-            try!(this.relate_bound(v, a, b));\n+            this.relate_bound(v, a, b)?;\n             Ok(v)\n         }\n \n         (&ty::TyInfer(TyVar(..)), _) |\n         (_, &ty::TyInfer(TyVar(..))) => {\n             let v = infcx.next_ty_var();\n-            try!(this.relate_bound(v, a, b));\n+            this.relate_bound(v, a, b)?;\n             Ok(v)\n         }\n "}, {"sha": "7202e4afc5a468aa621d0d18da73f3ad5a943601", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -78,8 +78,8 @@ impl<'a, 'tcx> LatticeDir<'a,'tcx> for Lub<'a, 'tcx> {\n \n     fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub();\n-        try!(sub.relate(&a, &v));\n-        try!(sub.relate(&b, &v));\n+        sub.relate(&a, &v)?;\n+        sub.relate(&b, &v)?;\n         Ok(())\n     }\n }"}, {"sha": "645e5323ef4aec282b69e3840802ec8e7ab26ef5", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -960,7 +960,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = TypeOrigin::EquatePredicate(span);\n-            let () = try!(mk_eqty(self, false, origin, a, b));\n+            let () = mk_eqty(self, false, origin, a, b)?;\n             self.leak_check(&skol_map, snapshot)\n         })\n     }"}, {"sha": "34b9953c529ec2b01c3d9eded1cd8a16282dc77e", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -75,13 +75,13 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n                 Ok(a)\n             }\n             (&ty::TyInfer(TyVar(a_id)), _) => {\n-                try!(self.fields\n+                self.fields\n                          .switch_expected()\n-                         .instantiate(b, SupertypeOf, a_id));\n+                         .instantiate(b, SupertypeOf, a_id)?;\n                 Ok(a)\n             }\n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                try!(self.fields.instantiate(a, SubtypeOf, b_id));\n+                self.fields.instantiate(a, SubtypeOf, b_id)?;\n                 Ok(a)\n             }\n \n@@ -90,7 +90,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n             }\n \n             _ => {\n-                try!(combine::super_combine_tys(self.fields.infcx, self, a, b));\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)?;\n                 Ok(a)\n             }\n         }"}, {"sha": "9507c379b4fe13c4355678970d98b3c911b6649b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -686,7 +686,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         for var_idx in 0..self.ir.num_vars {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n-                try!(write!(wr, \" {:?}\", Variable(var_idx)));\n+                write!(wr, \" {:?}\", Variable(var_idx))?;\n             }\n         }\n         Ok(())"}, {"sha": "d2bc80a2cb203c1a6a35dadc7d066676976b2e05", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -378,7 +378,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     }\n \n     fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let unadjusted_ty = try!(self.expr_ty(expr));\n+        let unadjusted_ty = self.expr_ty(expr)?;\n         Ok(unadjusted_ty.adjust(\n             self.tcx(), expr.span, expr.id,\n             self.typer.adjustments().get(&expr.id),\n@@ -390,7 +390,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     }\n \n     fn pat_ty(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n-        let base_ty = try!(self.typer.node_ty(pat.id));\n+        let base_ty = self.typer.node_ty(pat.id)?;\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n@@ -436,7 +436,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                                adjustment,\n                                expr);\n                         // Result is an rvalue.\n-                        let expr_ty = try!(self.expr_ty_adjusted(expr));\n+                        let expr_ty = self.expr_ty_adjusted(expr)?;\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n                 }\n@@ -448,28 +448,28 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                                expr: &hir::Expr,\n                                autoderefs: usize)\n                                -> McResult<cmt<'tcx>> {\n-        let mut cmt = try!(self.cat_expr_unadjusted(expr));\n+        let mut cmt = self.cat_expr_unadjusted(expr)?;\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={:?}\",\n                autoderefs,\n                cmt);\n         for deref in 1..autoderefs + 1 {\n-            cmt = try!(self.cat_deref(expr, cmt, deref, None));\n+            cmt = self.cat_deref(expr, cmt, deref, None)?;\n         }\n         return Ok(cmt);\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.id, expr);\n \n-        let expr_ty = try!(self.expr_ty(expr));\n+        let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n-            let base_cmt = try!(self.cat_expr(&e_base));\n+            let base_cmt = self.cat_expr(&e_base)?;\n             self.cat_deref(expr, base_cmt, 0, None)\n           }\n \n           hir::ExprField(ref base, f_name) => {\n-            let base_cmt = try!(self.cat_expr(&base));\n+            let base_cmt = self.cat_expr(&base)?;\n             debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n                    expr,\n@@ -478,7 +478,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n \n           hir::ExprTupField(ref base, idx) => {\n-            let base_cmt = try!(self.cat_expr(&base));\n+            let base_cmt = self.cat_expr(&base)?;\n             Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n           }\n \n@@ -509,7 +509,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                     self.cat_deref_common(expr, base_cmt, 1, elem_ty, Some(context), true)\n                 }\n                 None => {\n-                    self.cat_index(expr, try!(self.cat_expr(&base)), context)\n+                    self.cat_index(expr, self.cat_expr(&base)?, context)\n                 }\n             }\n           }\n@@ -575,7 +575,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n \n           Def::Upvar(_, var_id, _, fn_node_id) => {\n-              let ty = try!(self.node_ty(fn_node_id));\n+              let ty = self.node_ty(fn_node_id)?;\n               match ty.sty {\n                   ty::TyClosure(closure_id, _) => {\n                       match self.typer.closure_kind(closure_id) {\n@@ -649,7 +649,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n \n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n-        let var_ty = try!(self.node_ty(var_id));\n+        let var_ty = self.node_ty(var_id)?;\n \n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx(), var_id);\n@@ -921,7 +921,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                                     implicit: bool)\n                                     -> McResult<cmt<'tcx>>\n     {\n-        let (m, cat) = match try!(deref_kind(base_cmt.ty, deref_context)) {\n+        let (m, cat) = match deref_kind(base_cmt.ty, deref_context)? {\n             deref_ptr(ptr) => {\n                 let ptr = if implicit {\n                     match ptr {\n@@ -1030,7 +1030,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                              context: InteriorOffsetKind)\n                              -> McResult<cmt<'tcx>>\n     {\n-        let ret = match try!(deref_kind(base_cmt.ty, Some(context))) {\n+        let ret = match deref_kind(base_cmt.ty, Some(context))? {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n@@ -1069,13 +1069,13 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                              vec_cmt: cmt<'tcx>,\n                              slice_pat: &hir::Pat)\n                              -> McResult<(cmt<'tcx>, hir::Mutability, ty::Region)> {\n-        let slice_ty = try!(self.node_ty(slice_pat.id));\n+        let slice_ty = self.node_ty(slice_pat.id)?;\n         let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n                                                     slice_pat,\n                                                     slice_ty);\n         let context = InteriorOffsetKind::Pattern;\n-        let cmt_vec = try!(self.deref_vec(slice_pat, vec_cmt, context));\n-        let cmt_slice = try!(self.cat_index(slice_pat, cmt_vec, context));\n+        let cmt_vec = self.deref_vec(slice_pat, vec_cmt, context)?;\n+        let cmt_slice = self.cat_index(slice_pat, cmt_vec, context)?;\n         return Ok((cmt_slice, slice_mutbl, slice_r));\n \n         /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n@@ -1235,29 +1235,29 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 Some(Def::Variant(..)) => {\n                     // variant(x, y, z)\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n+                        let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        try!(self.cat_pattern_(subcmt, &subpat, op));\n+                        self.cat_pattern_(subcmt, &subpat, op)?;\n                     }\n                 }\n                 Some(Def::Struct(..)) => {\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n+                        let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        try!(self.cat_pattern_(cmt_field, &subpat, op));\n+                        self.cat_pattern_(cmt_field, &subpat, op)?;\n                     }\n                 }\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {\n                     for subpat in subpats {\n-                        try!(self.cat_pattern_(cmt.clone(), &subpat, op));\n+                        self.cat_pattern_(cmt.clone(), &subpat, op)?;\n                     }\n                 }\n                 _ => {\n@@ -1273,52 +1273,52 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n \n           PatKind::Ident(_, _, Some(ref subpat)) => {\n-              try!(self.cat_pattern_(cmt, &subpat, op));\n+              self.cat_pattern_(cmt, &subpat, op)?;\n           }\n \n           PatKind::Struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats {\n-                let field_ty = try!(self.pat_ty(&fp.node.pat)); // see (*2)\n+                let field_ty = self.pat_ty(&fp.node.pat)?; // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.name, field_ty);\n-                try!(self.cat_pattern_(cmt_field, &fp.node.pat, op));\n+                self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n             }\n           }\n \n           PatKind::Tup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n+                let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                try!(self.cat_pattern_(subcmt, &subpat, op));\n+                self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n \n           PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatKind::Ref since that information is already contained\n             // in the type.\n-            let subcmt = try!(self.cat_deref(pat, cmt, 0, None));\n-              try!(self.cat_pattern_(subcmt, &subpat, op));\n+            let subcmt = self.cat_deref(pat, cmt, 0, None)?;\n+              self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n           PatKind::Vec(ref before, ref slice, ref after) => {\n               let context = InteriorOffsetKind::Pattern;\n-              let vec_cmt = try!(self.deref_vec(pat, cmt, context));\n-              let elt_cmt = try!(self.cat_index(pat, vec_cmt, context));\n+              let vec_cmt = self.deref_vec(pat, cmt, context)?;\n+              let elt_cmt = self.cat_index(pat, vec_cmt, context)?;\n               for before_pat in before {\n-                  try!(self.cat_pattern_(elt_cmt.clone(), &before_pat, op));\n+                  self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n               }\n               if let Some(ref slice_pat) = *slice {\n-                  let slice_ty = try!(self.pat_ty(&slice_pat));\n+                  let slice_ty = self.pat_ty(&slice_pat)?;\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  try!(self.cat_pattern_(slice_cmt, &slice_pat, op));\n+                  self.cat_pattern_(slice_cmt, &slice_pat, op)?;\n               }\n               for after_pat in after {\n-                  try!(self.cat_pattern_(elt_cmt.clone(), &after_pat, op));\n+                  self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n               }\n           }\n "}, {"sha": "eb375205deee178c7c67c1cbeb089d1d3b6bc6cd", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -41,15 +41,15 @@ pub struct CodeExtent(u32);\n \n impl fmt::Debug for CodeExtent {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"CodeExtent({:?}\", self.0));\n+        write!(f, \"CodeExtent({:?}\", self.0)?;\n \n-        try!(ty::tls::with_opt(|opt_tcx| {\n+        ty::tls::with_opt(|opt_tcx| {\n             if let Some(tcx) = opt_tcx {\n                 let data = tcx.region_maps.code_extents.borrow()[self.0 as usize];\n-                try!(write!(f, \"/{:?}\", data));\n+                write!(f, \"/{:?}\", data)?;\n             }\n             Ok(())\n-        }));\n+        })?;\n \n         write!(f, \")\")\n     }"}, {"sha": "a80b130e5be5f13eab01b6d4f080a2f3a71089dd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -102,7 +102,7 @@ pub fn krate(sess: &Session,\n     let _task = hir_map.dep_graph.in_task(DepNode::ResolveLifetimes);\n     let krate = hir_map.krate();\n     let mut named_region_map = NodeMap();\n-    try!(sess.track_errors(|| {\n+    sess.track_errors(|| {\n         krate.visit_all_items(&mut LifetimeContext {\n             sess: sess,\n             named_region_map: &mut named_region_map,\n@@ -111,7 +111,7 @@ pub fn krate(sess: &Session,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n         });\n-    }));\n+    })?;\n     Ok(named_region_map)\n }\n "}, {"sha": "937196b5e8e7ab0efdbe67adcc2764a4e3c8bbcb", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -211,7 +211,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                    infcx: &InferCtxt<'a,'tcx>)\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        try!(self.select_where_possible(infcx));\n+        self.select_where_possible(infcx)?;\n         let errors: Vec<_> =\n             self.predicates.to_errors(CodeAmbiguity)\n                            .into_iter()"}, {"sha": "ffef509de958a78bd6977f0f433c6267ceea64c4", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -320,12 +320,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let _task = self.tcx().dep_graph.in_task(dep_node);\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n-        match try!(self.candidate_from_obligation(&stack)) {\n+        match self.candidate_from_obligation(&stack)? {\n             None => {\n                 self.consider_unification_despite_ambiguity(obligation);\n                 Ok(None)\n             }\n-            Some(candidate) => Ok(Some(try!(self.confirm_candidate(obligation, candidate)))),\n+            Some(candidate) => Ok(Some(self.confirm_candidate(obligation, candidate)?)),\n         }\n     }\n \n@@ -786,7 +786,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(None);\n         }\n \n-        let candidate_set = try!(self.assemble_candidates(stack));\n+        let candidate_set = self.assemble_candidates(stack)?;\n \n         if candidate_set.ambiguous {\n             debug!(\"candidate set contains ambig\");\n@@ -1034,19 +1034,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // User-defined copy impls are permitted, but only for\n                 // structs and enums.\n-                try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n+                self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n \n                 // For other types, we'll use the builtin rules.\n-                try!(self.assemble_builtin_bound_candidates(ty::BoundCopy,\n+                self.assemble_builtin_bound_candidates(ty::BoundCopy,\n                                                             obligation,\n-                                                            &mut candidates));\n+                                                            &mut candidates)?;\n             }\n             Some(bound @ ty::BoundSized) => {\n                 // Sized is never implementable by end-users, it is\n                 // always automatically computed.\n-                try!(self.assemble_builtin_bound_candidates(bound,\n+                self.assemble_builtin_bound_candidates(bound,\n                                                             obligation,\n-                                                            &mut candidates));\n+                                                            &mut candidates)?;\n             }\n \n             None if self.tcx().lang_items.unsize_trait() ==\n@@ -1057,19 +1057,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Some(ty::BoundSend) |\n             Some(ty::BoundSync) |\n             None => {\n-                try!(self.assemble_closure_candidates(obligation, &mut candidates));\n-                try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n-                try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n+                self.assemble_closure_candidates(obligation, &mut candidates)?;\n+                self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n+                self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n                 self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n             }\n         }\n \n         self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n-        try!(self.assemble_candidates_from_caller_bounds(stack, &mut candidates));\n+        self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;\n         // Default implementations have lower priority, so we only\n         // consider triggering a default if there is no other impl that can apply.\n         if candidates.vec.is_empty() {\n-            try!(self.assemble_candidates_from_default_impls(obligation, &mut candidates));\n+            self.assemble_candidates_from_default_impls(obligation, &mut candidates)?;\n         }\n         debug!(\"candidate list size: {}\", candidates.vec.len());\n         Ok(candidates)\n@@ -2044,7 +2044,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match candidate {\n             BuiltinCandidate(builtin_bound) => {\n                 Ok(VtableBuiltin(\n-                    try!(self.confirm_builtin_candidate(obligation, builtin_bound))))\n+                    self.confirm_builtin_candidate(obligation, builtin_bound)?))\n             }\n \n             ParamCandidate(param) => {\n@@ -2064,13 +2064,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ImplCandidate(impl_def_id) => {\n                 let vtable_impl =\n-                    try!(self.confirm_impl_candidate(obligation, impl_def_id));\n+                    self.confirm_impl_candidate(obligation, impl_def_id)?;\n                 Ok(VtableImpl(vtable_impl))\n             }\n \n             ClosureCandidate(closure_def_id, substs) => {\n                 let vtable_closure =\n-                    try!(self.confirm_closure_candidate(obligation, closure_def_id, substs));\n+                    self.confirm_closure_candidate(obligation, closure_def_id, substs)?;\n                 Ok(VtableClosure(vtable_closure))\n             }\n \n@@ -2090,7 +2090,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             FnPointerCandidate => {\n                 let fn_type =\n-                    try!(self.confirm_fn_pointer_candidate(obligation));\n+                    self.confirm_fn_pointer_candidate(obligation)?;\n                 Ok(VtableFnPointer(fn_type))\n             }\n \n@@ -2100,7 +2100,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             BuiltinUnsizeCandidate => {\n-                let data = try!(self.confirm_builtin_unsize_candidate(obligation));\n+                let data = self.confirm_builtin_unsize_candidate(obligation)?;\n                 Ok(VtableBuiltin(data))\n             }\n         }\n@@ -2152,7 +2152,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_builtin_candidate({:?})\",\n                obligation);\n \n-        match try!(self.builtin_bound(bound, obligation)) {\n+        match self.builtin_bound(bound, obligation)? {\n             If(nested) => Ok(self.vtable_builtin_data(obligation, bound, nested)),\n             AmbiguousBuiltin | ParameterBuiltin => {\n                 self.tcx().sess.span_bug(\n@@ -2421,9 +2421,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                     util::TupleArgumentsFlag::Yes)\n             .map_bound(|(trait_ref, _)| trait_ref);\n \n-        try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n+        self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n-                                          trait_ref));\n+                                          trait_ref)?;\n         Ok(self_ty)\n     }\n \n@@ -2449,9 +2449,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                trait_ref,\n                obligations);\n \n-        try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n+        self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n-                                          trait_ref));\n+                                          trait_ref)?;\n \n         Ok(VtableClosureData {\n             closure_def_id: closure_def_id,\n@@ -2795,7 +2795,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n-        try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref));\n+        self.match_poly_trait_ref(obligation, where_clause_trait_ref)?;\n         Ok(Vec::new())\n     }\n "}, {"sha": "9f984bc1fc63aac14540dd3f2471cd7b13ce7106", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -418,7 +418,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n-    let trait_ref = try!(trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n+    let trait_ref = trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty)?;\n     Ok(predicate_for_trait_ref(cause, trait_ref, recursion_depth))\n }\n "}, {"sha": "fe54334da3db6c96b2f2af736db3b8a423f4906a", "filename": "src/librustc/middle/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2F_match.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -91,6 +91,6 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'a,'tcx>\n     {\n-        Ok(ty::Binder(try!(self.relate(a.skip_binder(), b.skip_binder()))))\n+        Ok(ty::Binder(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n }"}, {"sha": "6a081cb8dd10264ab2ba3dedc7de6e0e348506d5", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -1473,7 +1473,7 @@ impl<'tcx> Encodable for AdtDef<'tcx> {\n \n impl<'tcx> Decodable for AdtDef<'tcx> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<AdtDef<'tcx>, D::Error> {\n-        let def_id: DefId = try!{ Decodable::decode(d) };\n+        let def_id: DefId = Decodable::decode(d)?;\n \n         cstore::tls::with_decoding_context(d, |dcx, _| {\n             let def_id = dcx.translate_def_id(def_id);"}, {"sha": "b67fee7239b54664f0182d75006c70be332e3ded", "filename": "src/librustc/middle/ty/relate.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -108,7 +108,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TypeAndMut<'tcx> {\n                 ast::Mutability::MutImmutable => ty::Covariant,\n                 ast::Mutability::MutMutable => ty::Invariant,\n             };\n-            let ty = try!(relation.relate_with_variance(variance, &a.ty, &b.ty));\n+            let ty = relation.relate_with_variance(variance, &a.ty, &b.ty)?;\n             Ok(ty::TypeAndMut {ty: ty, mutbl: mutbl})\n         }\n     }\n@@ -152,7 +152,7 @@ pub fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n         let a_tps = a_subst.types.get_slice(space);\n         let b_tps = b_subst.types.get_slice(space);\n         let t_variances = variances.map(|v| v.types.get_slice(space));\n-        let tps = try!(relate_type_params(relation, t_variances, a_tps, b_tps));\n+        let tps = relate_type_params(relation, t_variances, a_tps, b_tps)?;\n         substs.types.replace(space, tps);\n     }\n \n@@ -166,10 +166,10 @@ pub fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n                 let a_regions = a.get_slice(space);\n                 let b_regions = b.get_slice(space);\n                 let r_variances = variances.map(|v| v.regions.get_slice(space));\n-                let regions = try!(relate_region_params(relation,\n+                let regions = relate_region_params(relation,\n                                                         r_variances,\n                                                         a_regions,\n-                                                        b_regions));\n+                                                        b_regions)?;\n                 substs.mut_regions().replace(space, regions);\n             }\n         }\n@@ -239,9 +239,9 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BareFnTy<'tcx> {\n                  -> RelateResult<'tcx, ty::BareFnTy<'tcx>>\n         where R: TypeRelation<'a,'tcx>\n     {\n-        let unsafety = try!(relation.relate(&a.unsafety, &b.unsafety));\n-        let abi = try!(relation.relate(&a.abi, &b.abi));\n-        let sig = try!(relation.relate(&a.sig, &b.sig));\n+        let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n+        let abi = relation.relate(&a.abi, &b.abi)?;\n+        let sig = relation.relate(&a.sig, &b.sig)?;\n         Ok(ty::BareFnTy {unsafety: unsafety,\n                          abi: abi,\n                          sig: sig})\n@@ -260,19 +260,19 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n                 expected_found(relation, &a.variadic, &b.variadic)));\n         }\n \n-        let inputs = try!(relate_arg_vecs(relation,\n+        let inputs = relate_arg_vecs(relation,\n                                           &a.inputs,\n-                                          &b.inputs));\n+                                          &b.inputs)?;\n \n-        let output = try!(match (a.output, b.output) {\n+        let output = match (a.output, b.output) {\n             (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n-                Ok(ty::FnConverging(try!(relation.relate(&a_ty, &b_ty)))),\n+                Ok(ty::FnConverging(relation.relate(&a_ty, &b_ty)?)),\n             (ty::FnDiverging, ty::FnDiverging) =>\n                 Ok(ty::FnDiverging),\n             (a, b) =>\n                 Err(TypeError::ConvergenceMismatch(\n                     expected_found(relation, &(a != ty::FnDiverging), &(b != ty::FnDiverging)))),\n-        });\n+        }?;\n \n         return Ok(ty::FnSig {inputs: inputs,\n                              output: output,\n@@ -336,7 +336,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n             Err(TypeError::ProjectionNameMismatched(\n                 expected_found(relation, &a.item_name, &b.item_name)))\n         } else {\n-            let trait_ref = try!(relation.relate(&a.trait_ref, &b.trait_ref));\n+            let trait_ref = relation.relate(&a.trait_ref, &b.trait_ref)?;\n             Ok(ty::ProjectionTy { trait_ref: trait_ref, item_name: a.item_name })\n         }\n     }\n@@ -349,8 +349,8 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionPredicate<'tcx> {\n                  -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n         where R: TypeRelation<'a,'tcx>\n     {\n-        let projection_ty = try!(relation.relate(&a.projection_ty, &b.projection_ty));\n-        let ty = try!(relation.relate(&a.ty, &b.ty));\n+        let projection_ty = relation.relate(&a.projection_ty, &b.projection_ty)?;\n+        let ty = relation.relate(&a.ty, &b.ty)?;\n         Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n     }\n }\n@@ -385,13 +385,13 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ExistentialBounds<'tcx> {\n         where R: TypeRelation<'a,'tcx>\n     {\n         let r =\n-            try!(relation.with_cause(\n+            relation.with_cause(\n                 Cause::ExistentialRegionBound,\n                 |relation| relation.relate_with_variance(ty::Contravariant,\n                                                          &a.region_bound,\n-                                                         &b.region_bound)));\n-        let nb = try!(relation.relate(&a.builtin_bounds, &b.builtin_bounds));\n-        let pb = try!(relation.relate(&a.projection_bounds, &b.projection_bounds));\n+                                                         &b.region_bound))?;\n+        let nb = relation.relate(&a.builtin_bounds, &b.builtin_bounds)?;\n+        let pb = relation.relate(&a.projection_bounds, &b.projection_bounds)?;\n         Ok(ty::ExistentialBounds { region_bound: r,\n                                    builtin_bounds: nb,\n                                    projection_bounds: pb })\n@@ -426,7 +426,7 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TraitRef<'tcx> {\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n-            let substs = try!(relate_item_substs(relation, a.def_id, a.substs, b.substs));\n+            let substs = relate_item_substs(relation, a.def_id, a.substs, b.substs)?;\n             Ok(ty::TraitRef { def_id: a.def_id, substs: relation.tcx().mk_substs(substs) })\n         }\n     }\n@@ -489,21 +489,21 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n         (&ty::TyEnum(a_def, a_substs), &ty::TyEnum(b_def, b_substs))\n             if a_def == b_def =>\n         {\n-            let substs = try!(relate_item_substs(relation, a_def.did, a_substs, b_substs));\n+            let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n             Ok(tcx.mk_enum(a_def, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyTrait(ref a_), &ty::TyTrait(ref b_)) =>\n         {\n-            let principal = try!(relation.relate(&a_.principal, &b_.principal));\n-            let bounds = try!(relation.relate(&a_.bounds, &b_.bounds));\n+            let principal = relation.relate(&a_.principal, &b_.principal)?;\n+            let bounds = relation.relate(&a_.bounds, &b_.bounds)?;\n             Ok(tcx.mk_trait(principal, bounds))\n         }\n \n         (&ty::TyStruct(a_def, a_substs), &ty::TyStruct(b_def, b_substs))\n             if a_def == b_def =>\n         {\n-            let substs = try!(relate_item_substs(relation, a_def.did, a_substs, b_substs));\n+            let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n             Ok(tcx.mk_struct(a_def, tcx.mk_substs(substs)))\n         }\n \n@@ -514,32 +514,32 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             // All TyClosure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n-            let substs = try!(relation.relate(a_substs, b_substs));\n+            let substs = relation.relate(a_substs, b_substs)?;\n             Ok(tcx.mk_closure_from_closure_substs(a_id, substs))\n         }\n \n         (&ty::TyBox(a_inner), &ty::TyBox(b_inner)) =>\n         {\n-            let typ = try!(relation.relate(&a_inner, &b_inner));\n+            let typ = relation.relate(&a_inner, &b_inner)?;\n             Ok(tcx.mk_box(typ))\n         }\n \n         (&ty::TyRawPtr(ref a_mt), &ty::TyRawPtr(ref b_mt)) =>\n         {\n-            let mt = try!(relation.relate(a_mt, b_mt));\n+            let mt = relation.relate(a_mt, b_mt)?;\n             Ok(tcx.mk_ptr(mt))\n         }\n \n         (&ty::TyRef(a_r, ref a_mt), &ty::TyRef(b_r, ref b_mt)) =>\n         {\n-            let r = try!(relation.relate_with_variance(ty::Contravariant, a_r, b_r));\n-            let mt = try!(relation.relate(a_mt, b_mt));\n+            let r = relation.relate_with_variance(ty::Contravariant, a_r, b_r)?;\n+            let mt = relation.relate(a_mt, b_mt)?;\n             Ok(tcx.mk_ref(tcx.mk_region(r), mt))\n         }\n \n         (&ty::TyArray(a_t, sz_a), &ty::TyArray(b_t, sz_b)) =>\n         {\n-            let t = try!(relation.relate(&a_t, &b_t));\n+            let t = relation.relate(&a_t, &b_t)?;\n             if sz_a == sz_b {\n                 Ok(tcx.mk_array(t, sz_a))\n             } else {\n@@ -549,16 +549,16 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n \n         (&ty::TySlice(a_t), &ty::TySlice(b_t)) =>\n         {\n-            let t = try!(relation.relate(&a_t, &b_t));\n+            let t = relation.relate(&a_t, &b_t)?;\n             Ok(tcx.mk_slice(t))\n         }\n \n         (&ty::TyTuple(ref as_), &ty::TyTuple(ref bs)) =>\n         {\n             if as_.len() == bs.len() {\n-                let ts = try!(as_.iter().zip(bs)\n+                let ts = as_.iter().zip(bs)\n                                  .map(|(a, b)| relation.relate(a, b))\n-                                 .collect::<Result<_, _>>());\n+                                 .collect::<Result<_, _>>()?;\n                 Ok(tcx.mk_tup(ts))\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(TypeError::TupleSize(\n@@ -572,20 +572,20 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n          &ty::TyFnDef(b_def_id, b_substs, b_fty))\n             if a_def_id == b_def_id =>\n         {\n-            let substs = try!(relate_substs(relation, None, a_substs, b_substs));\n-            let fty = try!(relation.relate(a_fty, b_fty));\n+            let substs = relate_substs(relation, None, a_substs, b_substs)?;\n+            let fty = relation.relate(a_fty, b_fty)?;\n             Ok(tcx.mk_fn_def(a_def_id, tcx.mk_substs(substs), fty))\n         }\n \n         (&ty::TyFnPtr(a_fty), &ty::TyFnPtr(b_fty)) =>\n         {\n-            let fty = try!(relation.relate(a_fty, b_fty));\n+            let fty = relation.relate(a_fty, b_fty)?;\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n         (&ty::TyProjection(ref a_data), &ty::TyProjection(ref b_data)) =>\n         {\n-            let projection_ty = try!(relation.relate(a_data, b_data));\n+            let projection_ty = relation.relate(a_data, b_data)?;\n             Ok(tcx.mk_projection(projection_ty.trait_ref, projection_ty.item_name))\n         }\n \n@@ -603,8 +603,8 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ClosureSubsts<'tcx> {\n                  -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n         where R: TypeRelation<'a,'tcx>\n     {\n-        let func_substs = try!(relate_substs(relation, None, a.func_substs, b.func_substs));\n-        let upvar_tys = try!(relation.relate_zip(&a.upvar_tys, &b.upvar_tys));\n+        let func_substs = relate_substs(relation, None, a.func_substs, b.func_substs)?;\n+        let upvar_tys = relation.relate_zip(&a.upvar_tys, &b.upvar_tys)?;\n         Ok(ty::ClosureSubsts { func_substs: relation.tcx().mk_substs(func_substs),\n                                upvar_tys: upvar_tys })\n     }\n@@ -645,7 +645,7 @@ impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Rc<T>\n     {\n         let a: &T = a;\n         let b: &T = b;\n-        Ok(Rc::new(try!(relation.relate(a, b))))\n+        Ok(Rc::new(relation.relate(a, b)?))\n     }\n }\n \n@@ -660,7 +660,7 @@ impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n     {\n         let a: &T = a;\n         let b: &T = b;\n-        Ok(Box::new(try!(relation.relate(a, b))))\n+        Ok(Box::new(relation.relate(a, b)?))\n     }\n }\n "}, {"sha": "6b1ccf3b1624a8fd5252911fdd9aaf2bef01a3bd", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -250,7 +250,7 @@ pub struct ClosureSubsts<'tcx> {\n \n impl<'tcx> Decodable for &'tcx ClosureSubsts<'tcx> {\n     fn decode<S: Decoder>(s: &mut S) -> Result<&'tcx ClosureSubsts<'tcx>, S::Error> {\n-        let closure_substs = try! { Decodable::decode(s) };\n+        let closure_substs = Decodable::decode(s)?;\n         let dummy_def_id: DefId = unsafe { mem::zeroed() };\n \n         cstore::tls::with_decoding_context(s, |dcx, _| {"}, {"sha": "8c4a91bd88d4bfeeb3864618b48a15347723db37", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -356,7 +356,7 @@ impl<'tcx> BasicBlockData<'tcx> {\n \n impl<'tcx> Debug for Terminator<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n-        try!(self.fmt_head(fmt));\n+        self.fmt_head(fmt)?;\n         let successors = self.successors();\n         let labels = self.fmt_successor_labels();\n         assert_eq!(successors.len(), labels.len());\n@@ -367,12 +367,12 @@ impl<'tcx> Debug for Terminator<'tcx> {\n             1 => write!(fmt, \" -> {:?}\", successors[0]),\n \n             _ => {\n-                try!(write!(fmt, \" -> [\"));\n+                write!(fmt, \" -> [\")?;\n                 for (i, target) in successors.iter().enumerate() {\n                     if i > 0 {\n-                        try!(write!(fmt, \", \"));\n+                        write!(fmt, \", \")?;\n                     }\n-                    try!(write!(fmt, \"{}: {:?}\", labels[i], target));\n+                    write!(fmt, \"{}: {:?}\", labels[i], target)?;\n                 }\n                 write!(fmt, \"]\")\n             }\n@@ -397,14 +397,14 @@ impl<'tcx> Terminator<'tcx> {\n             Drop { ref value, .. } => write!(fmt, \"drop({:?})\", value),\n             Call { ref func, ref args, ref destination, .. } => {\n                 if let Some((ref destination, _)) = *destination {\n-                    try!(write!(fmt, \"{:?} = \", destination));\n+                    write!(fmt, \"{:?} = \", destination)?;\n                 }\n-                try!(write!(fmt, \"{:?}(\", func));\n+                write!(fmt, \"{:?}(\", func)?;\n                 for (index, arg) in args.iter().enumerate() {\n                     if index > 0 {\n-                        try!(write!(fmt, \", \"));\n+                        write!(fmt, \", \")?;\n                     }\n-                    try!(write!(fmt, \"{:?}\", arg));\n+                    write!(fmt, \"{:?}\", arg)?;\n                 }\n                 write!(fmt, \")\")\n             }\n@@ -808,11 +808,11 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     Adt(adt_def, variant, substs) => {\n                         let variant_def = &adt_def.variants[variant];\n \n-                        try!(ppaux::parameterized(fmt, substs, variant_def.did,\n+                        ppaux::parameterized(fmt, substs, variant_def.did,\n                                                   ppaux::Ns::Value, &[],\n                                                   |tcx| {\n                             tcx.lookup_item_type(variant_def.did).generics\n-                        }));\n+                        })?;\n \n                         match variant_def.kind() {\n                             ty::VariantKind::Unit => Ok(()),\n@@ -903,7 +903,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n                                      |tcx| tcx.lookup_item_type(def_id).generics)\n             }\n             Value { ref value } => {\n-                try!(write!(fmt, \"const \"));\n+                write!(fmt, \"const \")?;\n                 fmt_const_val(fmt, value)\n             }\n         }"}, {"sha": "cdf8912a3c4b0c9a6e988840dabe941feaf1c4bd", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -34,23 +34,23 @@ fn fn_sig(f: &mut fmt::Formatter,\n           variadic: bool,\n           output: ty::FnOutput)\n           -> fmt::Result {\n-    try!(write!(f, \"(\"));\n+    write!(f, \"(\")?;\n     let mut inputs = inputs.iter();\n     if let Some(&ty) = inputs.next() {\n-        try!(write!(f, \"{}\", ty));\n+        write!(f, \"{}\", ty)?;\n         for &ty in inputs {\n-            try!(write!(f, \", {}\", ty));\n+            write!(f, \", {}\", ty)?;\n         }\n         if variadic {\n-            try!(write!(f, \", ...\"));\n+            write!(f, \", ...\")?;\n         }\n     }\n-    try!(write!(f, \")\"));\n+    write!(f, \")\")?;\n \n     match output {\n         ty::FnConverging(ty) => {\n             if !ty.is_nil() {\n-                try!(write!(f, \" -> {}\", ty));\n+                write!(f, \" -> {}\", ty)?;\n             }\n             Ok(())\n         }\n@@ -77,10 +77,10 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     where GG: for<'tcx> FnOnce(&TyCtxt<'tcx>) -> ty::Generics<'tcx>\n {\n     if let (Ns::Value, Some(self_ty)) = (ns, substs.self_ty()) {\n-        try!(write!(f, \"<{} as \", self_ty));\n+        write!(f, \"<{} as \", self_ty)?;\n     }\n \n-    let (fn_trait_kind, verbose, last_name) = try!(ty::tls::with(|tcx| {\n+    let (fn_trait_kind, verbose, last_name) = ty::tls::with(|tcx| {\n         let (did, last_name) = if ns == Ns::Value {\n             // Try to get the impl/trait parent, if this is an\n             // associated value item (method or constant).\n@@ -89,9 +89,9 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n         } else {\n             (did, None)\n         };\n-        try!(write!(f, \"{}\", tcx.item_path_str(did)));\n+        write!(f, \"{}\", tcx.item_path_str(did))?;\n         Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose(), last_name))\n-    }));\n+    })?;\n \n     let mut empty = true;\n     let mut start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n@@ -106,25 +106,25 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     if verbose {\n         match substs.regions {\n             subst::ErasedRegions => {\n-                try!(start_or_continue(f, \"<\", \", \"));\n-                try!(write!(f, \"..\"));\n+                start_or_continue(f, \"<\", \", \")?;\n+                write!(f, \"..\")?;\n             }\n             subst::NonerasedRegions(ref regions) => {\n                 for region in regions {\n-                    try!(start_or_continue(f, \"<\", \", \"));\n-                    try!(write!(f, \"{:?}\", region));\n+                    start_or_continue(f, \"<\", \", \")?;\n+                    write!(f, \"{:?}\", region)?;\n                 }\n             }\n         }\n         for &ty in &substs.types {\n-            try!(start_or_continue(f, \"<\", \", \"));\n-            try!(write!(f, \"{}\", ty));\n+            start_or_continue(f, \"<\", \", \")?;\n+            write!(f, \"{}\", ty)?;\n         }\n         for projection in projections {\n-            try!(start_or_continue(f, \"<\", \", \"));\n-            try!(write!(f, \"{}={}\",\n+            start_or_continue(f, \"<\", \", \")?;\n+            write!(f, \"{}={}\",\n                         projection.projection_ty.item_name,\n-                        projection.ty));\n+                        projection.ty)?;\n         }\n         return start_or_continue(f, \"\", \">\");\n     }\n@@ -140,17 +140,17 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n         subst::ErasedRegions => { }\n         subst::NonerasedRegions(ref regions) => {\n             for &r in regions {\n-                try!(start_or_continue(f, \"<\", \", \"));\n+                start_or_continue(f, \"<\", \", \")?;\n                 let s = r.to_string();\n                 if s.is_empty() {\n                     // This happens when the value of the region\n                     // parameter is not easily serialized. This may be\n                     // because the user omitted it in the first place,\n                     // or because it refers to some block in the code,\n                     // etc. I'm not sure how best to serialize this.\n-                    try!(write!(f, \"'_\"));\n+                    write!(f, \"'_\")?;\n                 } else {\n-                    try!(write!(f, \"{}\", s));\n+                    write!(f, \"{}\", s)?;\n                 }\n             }\n         }\n@@ -194,35 +194,35 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     });\n \n     for &ty in &tps[..tps.len() - num_defaults] {\n-        try!(start_or_continue(f, \"<\", \", \"));\n-        try!(write!(f, \"{}\", ty));\n+        start_or_continue(f, \"<\", \", \")?;\n+        write!(f, \"{}\", ty)?;\n     }\n \n     for projection in projections {\n-        try!(start_or_continue(f, \"<\", \", \"));\n-        try!(write!(f, \"{}={}\",\n+        start_or_continue(f, \"<\", \", \")?;\n+        write!(f, \"{}={}\",\n                     projection.projection_ty.item_name,\n-                    projection.ty));\n+                    projection.ty)?;\n     }\n \n-    try!(start_or_continue(f, \"\", \">\"));\n+    start_or_continue(f, \"\", \">\")?;\n \n     // For values, also print their name and type parameters.\n     if ns == Ns::Value {\n         if substs.self_ty().is_some() {\n-            try!(write!(f, \">\"));\n+            write!(f, \">\")?;\n         }\n \n         if let Some(name) = last_name {\n-            try!(write!(f, \"::{}\", name));\n+            write!(f, \"::{}\", name)?;\n         }\n         let tps = substs.types.get_slice(subst::FnSpace);\n         if !tps.is_empty() {\n-            try!(write!(f, \"::<{}\", tps[0]));\n+            write!(f, \"::<{}\", tps[0])?;\n             for ty in &tps[1..] {\n-                try!(write!(f, \", {}\", ty));\n+                write!(f, \", {}\", ty)?;\n             }\n-            try!(write!(f, \">\"));\n+            write!(f, \">\")?;\n         }\n     }\n \n@@ -273,7 +273,7 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n         })\n     }).0;\n \n-    try!(start_or_continue(f, \"\", \"> \"));\n+    start_or_continue(f, \"\", \"> \")?;\n     write!(f, \"{}\", new_value)\n }\n \n@@ -317,7 +317,7 @@ impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n         let bounds = &self.bounds;\n \n         // Generate the main trait ref, including associated types.\n-        try!(ty::tls::with(|tcx| {\n+        ty::tls::with(|tcx| {\n             let principal = tcx.lift(&self.principal.0)\n                                .expect(\"could not lift TraitRef for printing\");\n             let projections = tcx.lift(&bounds.projection_bounds[..])\n@@ -326,11 +326,11 @@ impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n \n             let tap = ty::Binder(TraitAndProjections(principal, projections));\n             in_binder(f, tcx, &ty::Binder(\"\"), Some(tap))\n-        }));\n+        })?;\n \n         // Builtin bounds.\n         for bound in &bounds.builtin_bounds {\n-            try!(write!(f, \" + {:?}\", bound));\n+            write!(f, \" + {:?}\", bound)?;\n         }\n \n         // FIXME: It'd be nice to compute from context when this bound\n@@ -340,7 +340,7 @@ impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n         // people aware that it's there.\n         let bound = bounds.region_bound.to_string();\n         if !bound.is_empty() {\n-            try!(write!(f, \" + {}\", bound));\n+            write!(f, \" + {}\", bound)?;\n         }\n \n         Ok(())\n@@ -648,19 +648,19 @@ impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n \n impl<'tcx> fmt::Debug for ty::ImplOrTraitItem<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"ImplOrTraitItem(\"));\n-        try!(match *self {\n+        write!(f, \"ImplOrTraitItem(\")?;\n+        match *self {\n             ty::ImplOrTraitItem::MethodTraitItem(ref i) => write!(f, \"{:?}\", i),\n             ty::ImplOrTraitItem::ConstTraitItem(ref i) => write!(f, \"{:?}\", i),\n             ty::ImplOrTraitItem::TypeTraitItem(ref i) => write!(f, \"{:?}\", i),\n-        });\n+        }?;\n         write!(f, \")\")\n     }\n }\n \n impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"fn\"));\n+        write!(f, \"fn\")?;\n         fn_sig(f, &self.inputs, self.variadic, self.output)\n     }\n }\n@@ -679,18 +679,18 @@ impl<'tcx> fmt::Debug for ty::ExistentialBounds<'tcx> {\n \n         let region_str = format!(\"{:?}\", self.region_bound);\n         if !region_str.is_empty() {\n-            try!(maybe_continue(f));\n-            try!(write!(f, \"{}\", region_str));\n+            maybe_continue(f)?;\n+            write!(f, \"{}\", region_str)?;\n         }\n \n         for bound in &self.builtin_bounds {\n-            try!(maybe_continue(f));\n-            try!(write!(f, \"{:?}\", bound));\n+            maybe_continue(f)?;\n+            write!(f, \"{:?}\", bound)?;\n         }\n \n         for projection_bound in &self.projection_bounds {\n-            try!(maybe_continue(f));\n-            try!(write!(f, \"{:?}\", projection_bound));\n+            maybe_continue(f)?;\n+            write!(f, \"{:?}\", projection_bound)?;\n         }\n \n         Ok(())\n@@ -701,9 +701,9 @@ impl fmt::Display for ty::BuiltinBounds {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut bounds = self.iter();\n         if let Some(bound) = bounds.next() {\n-            try!(write!(f, \"{:?}\", bound));\n+            write!(f, \"{:?}\", bound)?;\n             for bound in bounds {\n-                try!(write!(f, \" + {:?}\", bound));\n+                write!(f, \" + {:?}\", bound)?;\n             }\n         }\n         Ok(())\n@@ -832,49 +832,49 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 },  tm.ty)\n             }\n             TyRef(r, ref tm) => {\n-                try!(write!(f, \"&\"));\n+                write!(f, \"&\")?;\n                 let s = r.to_string();\n-                try!(write!(f, \"{}\", s));\n+                write!(f, \"{}\", s)?;\n                 if !s.is_empty() {\n-                    try!(write!(f, \" \"));\n+                    write!(f, \" \")?;\n                 }\n                 write!(f, \"{}\", tm)\n             }\n             TyTuple(ref tys) => {\n-                try!(write!(f, \"(\"));\n+                write!(f, \"(\")?;\n                 let mut tys = tys.iter();\n                 if let Some(&ty) = tys.next() {\n-                    try!(write!(f, \"{},\", ty));\n+                    write!(f, \"{},\", ty)?;\n                     if let Some(&ty) = tys.next() {\n-                        try!(write!(f, \" {}\", ty));\n+                        write!(f, \" {}\", ty)?;\n                         for &ty in tys {\n-                            try!(write!(f, \", {}\", ty));\n+                            write!(f, \", {}\", ty)?;\n                         }\n                     }\n                 }\n                 write!(f, \")\")\n             }\n             TyFnDef(def_id, substs, ref bare_fn) => {\n                 if bare_fn.unsafety == hir::Unsafety::Unsafe {\n-                    try!(write!(f, \"unsafe \"));\n+                    write!(f, \"unsafe \")?;\n                 }\n \n                 if bare_fn.abi != Abi::Rust {\n-                    try!(write!(f, \"extern {} \", bare_fn.abi));\n+                    write!(f, \"extern {} \", bare_fn.abi)?;\n                 }\n \n-                try!(write!(f, \"{} {{\", bare_fn.sig.0));\n-                try!(parameterized(f, substs, def_id, Ns::Value, &[],\n-                                   |tcx| tcx.lookup_item_type(def_id).generics));\n+                write!(f, \"{} {{\", bare_fn.sig.0)?;\n+                parameterized(f, substs, def_id, Ns::Value, &[],\n+                                   |tcx| tcx.lookup_item_type(def_id).generics)?;\n                 write!(f, \"}}\")\n             }\n             TyFnPtr(ref bare_fn) => {\n                 if bare_fn.unsafety == hir::Unsafety::Unsafe {\n-                    try!(write!(f, \"unsafe \"));\n+                    write!(f, \"unsafe \")?;\n                 }\n \n                 if bare_fn.abi != Abi::Rust {\n-                    try!(write!(f, \"extern {} \", bare_fn.abi));\n+                    write!(f, \"extern {} \", bare_fn.abi)?;\n                 }\n \n                 write!(f, \"{}\", bare_fn.sig.0)\n@@ -897,30 +897,30 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n             TyStr => write!(f, \"str\"),\n             TyClosure(did, ref substs) => ty::tls::with(|tcx| {\n-                try!(write!(f, \"[closure\"));\n+                write!(f, \"[closure\")?;\n \n                 if let Some(node_id) = tcx.map.as_local_node_id(did) {\n-                    try!(write!(f, \"@{:?}\", tcx.map.span(node_id)));\n+                    write!(f, \"@{:?}\", tcx.map.span(node_id))?;\n                     let mut sep = \" \";\n-                    try!(tcx.with_freevars(node_id, |freevars| {\n+                    tcx.with_freevars(node_id, |freevars| {\n                         for (freevar, upvar_ty) in freevars.iter().zip(&substs.upvar_tys) {\n                             let node_id = freevar.def.var_id();\n-                            try!(write!(f,\n+                            write!(f,\n                                         \"{}{}:{}\",\n                                         sep,\n                                         tcx.local_var_name_str(node_id),\n-                                        upvar_ty));\n+                                        upvar_ty)?;\n                             sep = \", \";\n                         }\n                         Ok(())\n-                    }))\n+                    })?\n                 } else {\n                     // cross-crate closure types should only be\n                     // visible in trans bug reports, I imagine.\n-                    try!(write!(f, \"@{:?}\", did));\n+                    write!(f, \"@{:?}\", did)?;\n                     let mut sep = \" \";\n                     for (index, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n-                        try!(write!(f, \"{}{}:{}\", sep, index, upvar_ty));\n+                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n                         sep = \", \";\n                     }\n                 }"}, {"sha": "3fc19f9bed562e25aacdc3db8947e125b77815d5", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -464,11 +464,11 @@ impl Target {\n         use serialize::json;\n \n         fn load_file(path: &Path) -> Result<Target, String> {\n-            let mut f = try!(File::open(path).map_err(|e| e.to_string()));\n+            let mut f = File::open(path).map_err(|e| e.to_string())?;\n             let mut contents = Vec::new();\n-            try!(f.read_to_end(&mut contents).map_err(|e| e.to_string()));\n-            let obj = try!(json::from_reader(&mut &contents[..])\n-                                .map_err(|e| e.to_string()));\n+            f.read_to_end(&mut contents).map_err(|e| e.to_string())?;\n+            let obj = json::from_reader(&mut &contents[..])\n+                                .map_err(|e| e.to_string())?;\n             Ok(Target::from_json(obj))\n         }\n "}, {"sha": "e3e89223f2d656f0295fef24a641fb3717a7b00b", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -45,7 +45,7 @@ impl TempDir {\n         let storage;\n         let mut tmpdir = tmpdir;\n         if !tmpdir.is_absolute() {\n-            let cur_dir = try!(env::current_dir());\n+            let cur_dir = env::current_dir()?;\n             storage = cur_dir.join(tmpdir);\n             tmpdir = &storage;\n             // return TempDir::new_in(&cur_dir.join(tmpdir), prefix);"}, {"sha": "826284f1d78c075530e8eed6ae908a0519e781dc", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -112,15 +112,15 @@ impl<'tcx> PreMovePath<'tcx> {\n \n impl<'tcx> fmt::Debug for MovePath<'tcx> {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(w, \"MovePath {{\"));\n+        write!(w, \"MovePath {{\")?;\n         if let Some(parent) = self.parent {\n-            try!(write!(w, \" parent: {:?},\", parent));\n+            write!(w, \" parent: {:?},\", parent)?;\n         }\n         if let Some(first_child) = self.first_child {\n-            try!(write!(w, \" first_child: {:?},\", first_child));\n+            write!(w, \" first_child: {:?},\", first_child)?;\n         }\n         if let Some(next_sibling) = self.next_sibling {\n-            try!(write!(w, \" next_sibling: {:?}\", next_sibling));\n+            write!(w, \" next_sibling: {:?}\", next_sibling)?;\n         }\n         write!(w, \" content: {:?} }}\", self.content)\n     }"}, {"sha": "b1d3b215ab4ed9c83c29bda95d201699abd9264c", "filename": "src/librustc_borrowck/borrowck/mir/graphviz.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgraphviz.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -31,7 +31,7 @@ pub fn print_borrowck_graph_to(mbcx: &MirBorrowckCtxt,\n                                path: &str) -> io::Result<()> {\n     let g = Graph { mbcx: mbcx, context: context };\n     let mut v = Vec::new();\n-    try!(dot::render(&g, &mut v));\n+    dot::render(&g, &mut v)?;\n     println!(\"print_borrowck_graph_to path: {} context: {} node_id: {}\",\n              path, context, mbcx.node_id);\n     File::create(path).and_then(|mut f| f.write_all(&v))\n@@ -121,18 +121,18 @@ impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n             for c in interpreted.chunks(chunk_size) {\n                 if seen_one {\n                     // if not the first row, finish off the previous row\n-                    try!(write!(w, \"</td><td></td><td></td></tr>\"));\n+                    write!(w, \"</td><td></td><td></td></tr>\")?;\n                 }\n-                try!(write!(w, \"<tr><td></td><td {bg} {align}>{objs:?}\",\n+                write!(w, \"<tr><td></td><td {bg} {align}>{objs:?}\",\n                             bg = BG_FLOWCONTENT,\n                             align = ALIGN_RIGHT,\n-                            objs = c));\n+                            objs = c)?;\n                 seen_one = true;\n             }\n             if !seen_one {\n-                try!(write!(w, \"<tr><td></td><td {bg} {align}>[]\",\n+                write!(w, \"<tr><td></td><td {bg} {align}>[]\",\n                             bg = BG_FLOWCONTENT,\n-                            align = ALIGN_RIGHT));\n+                            align = ALIGN_RIGHT)?;\n             }\n             Ok(())\n         }\n@@ -141,7 +141,7 @@ impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n             |w| {\n                 let flow = &self.mbcx.flow_state;\n                 let entry = flow.interpret_set(flow.sets.on_entry_set_for(i));\n-                try!(chunked_present_left(w, &entry[..], chunk_size));\n+                chunked_present_left(w, &entry[..], chunk_size)?;\n                 write!(w, \"= ENTRY:</td><td {bg}><FONT {face}>{entrybits:?}</FONT></td>\\\n                                         <td></td></tr>\",\n                        bg = BG_FLOWCONTENT,\n@@ -153,40 +153,40 @@ impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n                 let flow = &self.mbcx.flow_state;\n                 let gen = flow.interpret_set( flow.sets.gen_set_for(i));\n                 let kill = flow.interpret_set(flow.sets.kill_set_for(i));\n-                try!(chunked_present_left(w, &gen[..], chunk_size));\n-                try!(write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n+                chunked_present_left(w, &gen[..], chunk_size)?;\n+                write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n                                             <td></td></tr>\",\n                             bg = BG_FLOWCONTENT,\n                             face = FACE_MONOSPACE,\n                             genbits=bits_to_string( flow.sets.gen_set_for(i),\n-                                                    flow.sets.bytes_per_block())));\n-                try!(write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n+                                                    flow.sets.bytes_per_block()))?;\n+                write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n                                              <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n                             bg = BG_FLOWCONTENT,\n                             align = ALIGN_RIGHT,\n                             face = FACE_MONOSPACE,\n                             killbits=bits_to_string(flow.sets.kill_set_for(i),\n-                                                    flow.sets.bytes_per_block())));\n+                                                    flow.sets.bytes_per_block()))?;\n \n                 // (chunked_present_right)\n                 let mut seen_one = false;\n                 for k in kill.chunks(chunk_size) {\n                     if !seen_one {\n                         // continuation of row; this is fourth <td>\n-                        try!(write!(w, \"<td {bg}>= {kill:?}</td></tr>\",\n+                        write!(w, \"<td {bg}>= {kill:?}</td></tr>\",\n                                     bg = BG_FLOWCONTENT,\n-                                    kill=k));\n+                                    kill=k)?;\n                     } else {\n                         // new row, with indent of three <td>'s\n-                        try!(write!(w, \"<tr><td></td><td></td><td></td><td {bg}>{kill:?}</td></tr>\",\n+                        write!(w, \"<tr><td></td><td></td><td></td><td {bg}>{kill:?}</td></tr>\",\n                                     bg = BG_FLOWCONTENT,\n-                                    kill=k));\n+                                    kill=k)?;\n                     }\n                     seen_one = true;\n                 }\n                 if !seen_one {\n-                    try!(write!(w, \"<td {bg}>= []</td></tr>\",\n-                                bg = BG_FLOWCONTENT));\n+                    write!(w, \"<td {bg}>= []</td></tr>\",\n+                                bg = BG_FLOWCONTENT)?;\n                 }\n \n                 Ok(())"}, {"sha": "7576a984bec7ac183efd2ced8114f22c31c38ae2", "filename": "src/librustc_const_eval/int.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_const_eval%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_const_eval%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fint.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -220,7 +220,7 @@ impl ConstInt {\n \n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<::std::cmp::Ordering, ConstMathErr> {\n-        match try!(self.infer(rhs)) {\n+        match self.infer(rhs)? {\n             (I8(a), I8(b)) => Ok(a.cmp(&b)),\n             (I16(a), I16(b)) => Ok(a.cmp(&b)),\n             (I32(a), I32(b)) => Ok(a.cmp(&b)),\n@@ -420,8 +420,8 @@ fn check_division(\n impl ::std::ops::Div for ConstInt {\n     type Output = Result<Self, ConstMathErr>;\n     fn div(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let (lhs, rhs) = try!(self.infer(rhs));\n-        try!(check_division(lhs, rhs, Op::Div, DivisionByZero));\n+        let (lhs, rhs) = self.infer(rhs)?;\n+        check_division(lhs, rhs, Op::Div, DivisionByZero)?;\n         match (lhs, rhs) {\n             (I8(a), I8(b)) => Ok(I8(a/b)),\n             (I16(a), I16(b)) => Ok(I16(a/b)),\n@@ -447,9 +447,9 @@ impl ::std::ops::Div for ConstInt {\n impl ::std::ops::Rem for ConstInt {\n     type Output = Result<Self, ConstMathErr>;\n     fn rem(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let (lhs, rhs) = try!(self.infer(rhs));\n+        let (lhs, rhs) = self.infer(rhs)?;\n         // should INT_MIN%-1 be zero or an error?\n-        try!(check_division(lhs, rhs, Op::Rem, RemainderByZero));\n+        check_division(lhs, rhs, Op::Rem, RemainderByZero)?;\n         match (lhs, rhs) {\n             (I8(a), I8(b)) => Ok(I8(a%b)),\n             (I16(a), I16(b)) => Ok(I16(a%b)),\n@@ -475,7 +475,7 @@ impl ::std::ops::Rem for ConstInt {\n impl ::std::ops::Shl<ConstInt> for ConstInt {\n     type Output = Result<Self, ConstMathErr>;\n     fn shl(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let b = try!(rhs.to_u32().ok_or(ShiftNegative));\n+        let b = rhs.to_u32().ok_or(ShiftNegative)?;\n         match self {\n             I8(a) => Ok(I8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             I16(a) => Ok(I16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n@@ -498,7 +498,7 @@ impl ::std::ops::Shl<ConstInt> for ConstInt {\n impl ::std::ops::Shr<ConstInt> for ConstInt {\n     type Output = Result<Self, ConstMathErr>;\n     fn shr(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let b = try!(rhs.to_u32().ok_or(ShiftNegative));\n+        let b = rhs.to_u32().ok_or(ShiftNegative)?;\n         match self {\n             I8(a) => Ok(I8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             I16(a) => Ok(I16(overflowing!(a.overflowing_shr(b), Op::Shr))),"}, {"sha": "c64e6d1801d296385e9761ea171d0f0b6290f2a9", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -99,11 +99,11 @@ pub fn compile_input(sess: &Session,\n \n             let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n             let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n-            let expanded_crate = try!(phase_2_configure_and_expand(sess,\n+            let expanded_crate = phase_2_configure_and_expand(sess,\n                                                                    &cstore,\n                                                                    krate,\n                                                                    &id[..],\n-                                                                   addl_plugins));\n+                                                                   addl_plugins)?;\n \n             (outputs, expanded_crate, id)\n         };\n@@ -168,7 +168,7 @@ pub fn compile_input(sess: &Session,\n             None\n         };\n \n-        try!(try!(phase_3_run_analysis_passes(sess,\n+        phase_3_run_analysis_passes(sess,\n                                               &cstore,\n                                               hir_map,\n                                               &arenas,\n@@ -196,7 +196,7 @@ pub fn compile_input(sess: &Session,\n                 }\n             }\n \n-            try!(result);\n+            result?;\n \n             if log_enabled!(::log::INFO) {\n                 println!(\"Pre-trans\");\n@@ -215,7 +215,7 @@ pub fn compile_input(sess: &Session,\n             token::get_ident_interner().clear();\n \n             Ok((outputs, trans))\n-        })))\n+        })??\n     };\n \n     let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n@@ -224,7 +224,7 @@ pub fn compile_input(sess: &Session,\n                             sess,\n                             CompileState::state_after_llvm(input, sess, outdir, &trans),\n                             phase5_result);\n-    try!(phase5_result);\n+    phase5_result?;\n \n     phase_6_link_output(sess, &trans, &outputs);\n \n@@ -428,7 +428,7 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n     syntax::ext::mtwt::reset_tables();\n     token::reset_ident_interner();\n \n-    let krate = try!(time(sess.time_passes(), \"parsing\", || {\n+    let krate = time(sess.time_passes(), \"parsing\", || {\n         match *input {\n             Input::File(ref file) => {\n                 parse::parse_crate_from_file(file, cfg.clone(), &sess.parse_sess)\n@@ -440,7 +440,7 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n                                                    &sess.parse_sess)\n             }\n         }\n-    }));\n+    })?;\n \n     if sess.opts.debugging_opts.ast_json_noexpand {\n         println!(\"{}\", json::as_json(&krate));\n@@ -491,13 +491,13 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // baz! should not use this definition unless foo is enabled.\n \n     let mut feature_gated_cfgs = vec![];\n-    krate = try!(time(time_passes, \"configuration 1\", || {\n+    krate = time(time_passes, \"configuration 1\", || {\n         sess.track_errors(|| {\n             syntax::config::strip_unconfigured_items(sess.diagnostic(),\n                                                      krate,\n                                                      &mut feature_gated_cfgs)\n         })\n-    }));\n+    })?;\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n     *sess.crate_metadata.borrow_mut() = collect_crate_metadata(sess, &krate.attrs);\n@@ -506,7 +506,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n     });\n \n-    try!(time(time_passes, \"gated macro checking\", || {\n+    time(time_passes, \"gated macro checking\", || {\n         sess.track_errors(|| {\n             let features =\n               syntax::feature_gate::check_crate_macros(sess.codemap(),\n@@ -516,7 +516,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             // these need to be set \"early\" so that expansion sees `quote` if enabled.\n             *sess.features.borrow_mut() = features;\n         })\n-    }));\n+    })?;\n \n \n     krate = time(time_passes, \"crate injection\", || {\n@@ -553,7 +553,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let Registry { syntax_exts, early_lint_passes, late_lint_passes, lint_groups,\n                    llvm_passes, attributes, mir_passes, .. } = registry;\n \n-    try!(sess.track_errors(|| {\n+    sess.track_errors(|| {\n         let mut ls = sess.lint_store.borrow_mut();\n         for pass in early_lint_passes {\n             ls.register_early_pass(Some(sess), true, pass);\n@@ -569,14 +569,14 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         *sess.plugin_llvm_passes.borrow_mut() = llvm_passes;\n         sess.mir_passes.borrow_mut().extend(mir_passes);\n         *sess.plugin_attributes.borrow_mut() = attributes.clone();\n-    }));\n+    })?;\n \n     // Lint plugins are registered; now we can process command line flags.\n     if sess.opts.describe_lints {\n         super::describe_lints(&sess.lint_store.borrow(), true);\n         return Err(0);\n     }\n-    try!(sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess)));\n+    sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess))?;\n \n     krate = time(time_passes, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n@@ -619,7 +619,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // of macro expansion.  This runs before #[cfg] to try to catch as\n     // much as possible (e.g. help the programmer avoid platform\n     // specific differences)\n-    try!(time(time_passes, \"complete gated feature checking 1\", || {\n+    time(time_passes, \"complete gated feature checking 1\", || {\n         sess.track_errors(|| {\n             let features = syntax::feature_gate::check_crate(sess.codemap(),\n                                                              &sess.parse_sess.span_diagnostic,\n@@ -628,12 +628,12 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                                              sess.opts.unstable_features);\n             *sess.features.borrow_mut() = features;\n         })\n-    }));\n+    })?;\n \n     // JBC: make CFG processing part of expansion to avoid this problem:\n \n     // strip again, in case expansion added anything with a #[cfg].\n-    krate = try!(sess.track_errors(|| {\n+    krate = sess.track_errors(|| {\n         let krate = time(time_passes, \"configuration 2\", || {\n             syntax::config::strip_unconfigured_items(sess.diagnostic(),\n                                                      krate,\n@@ -650,7 +650,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         });\n \n         krate\n-    }));\n+    })?;\n \n     krate = time(time_passes, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(&sess.parse_sess, &sess.opts.cfg, krate, sess.diagnostic())\n@@ -671,7 +671,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // One final feature gating of the true AST that gets compiled\n     // later, to make sure we've got everything (e.g. configuration\n     // can insert new attributes via `cfg_attr`)\n-    try!(time(time_passes, \"complete gated feature checking 2\", || {\n+    time(time_passes, \"complete gated feature checking 2\", || {\n         sess.track_errors(|| {\n             let features = syntax::feature_gate::check_crate(sess.codemap(),\n                                                              &sess.parse_sess.span_diagnostic,\n@@ -680,11 +680,11 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                                              sess.opts.unstable_features);\n             *sess.features.borrow_mut() = features;\n         })\n-    }));\n+    })?;\n \n-    try!(time(time_passes,\n+    time(time_passes,\n               \"const fn bodies and arguments\",\n-              || const_fn::check_crate(sess, &krate)));\n+              || const_fn::check_crate(sess, &krate))?;\n \n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n@@ -756,11 +756,11 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n          \"external crate/lib resolution\",\n          || LocalCrateReader::new(sess, cstore, &hir_map).read_crates());\n \n-    let lang_items = try!(time(time_passes, \"language item collection\", || {\n+    let lang_items = time(time_passes, \"language item collection\", || {\n         sess.track_errors(|| {\n             middle::lang_items::collect_language_items(&sess, &hir_map)\n         })\n-    }));\n+    })?;\n \n     let resolve::CrateMap {\n         def_map,\n@@ -780,11 +780,11 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         glob_map: glob_map,\n     };\n \n-    let named_region_map = try!(time(time_passes,\n+    let named_region_map = time(time_passes,\n                                      \"lifetime resolution\",\n                                      || middle::resolve_lifetime::krate(sess,\n                                                                         &hir_map,\n-                                                                        &def_map.borrow())));\n+                                                                        &def_map.borrow()))?;\n \n     time(time_passes,\n          \"looking for entry point\",\n@@ -802,9 +802,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n          \"loop checking\",\n          || loops::check_crate(sess, &hir_map));\n \n-    try!(time(time_passes,\n+    time(time_passes,\n               \"static item recursion checking\",\n-              || static_recursion::check_crate(sess, &def_map.borrow(), &hir_map)));\n+              || static_recursion::check_crate(sess, &def_map.borrow(), &hir_map))?;\n \n     let index = stability::Index::new(&hir_map);\n \n@@ -1023,16 +1023,16 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, id: &str) {\n                                          .filter(|fmap| !fmap.is_imported())\n                                          .map(|fmap| escape_dep_filename(&fmap.name))\n                                          .collect();\n-            let mut file = try!(fs::File::create(&deps_filename));\n+            let mut file = fs::File::create(&deps_filename)?;\n             for path in &out_filenames {\n-                try!(write!(file, \"{}: {}\\n\\n\", path.display(), files.join(\" \")));\n+                write!(file, \"{}: {}\\n\\n\", path.display(), files.join(\" \"))?;\n             }\n \n             // Emit a fake target for each input file to the compilation. This\n             // prevents `make` from spitting out an error if a file is later\n             // deleted. For more info see #28735\n             for path in files {\n-                try!(writeln!(file, \"{}:\", path));\n+                writeln!(file, \"{}:\", path)?;\n             }\n             Ok(())\n         })();"}, {"sha": "726dd02dd2567842a0a838b692b562948a25eb2e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -325,24 +325,24 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n             pprust::NodeIdent(_) | pprust::NodeName(_) => Ok(()),\n \n             pprust::NodeItem(item) => {\n-                try!(pp::space(&mut s.s));\n+                pp::space(&mut s.s)?;\n                 s.synth_comment(item.id.to_string())\n             }\n             pprust::NodeSubItem(id) => {\n-                try!(pp::space(&mut s.s));\n+                pp::space(&mut s.s)?;\n                 s.synth_comment(id.to_string())\n             }\n             pprust::NodeBlock(blk) => {\n-                try!(pp::space(&mut s.s));\n+                pp::space(&mut s.s)?;\n                 s.synth_comment(format!(\"block {}\", blk.id))\n             }\n             pprust::NodeExpr(expr) => {\n-                try!(pp::space(&mut s.s));\n-                try!(s.synth_comment(expr.id.to_string()));\n+                pp::space(&mut s.s)?;\n+                s.synth_comment(expr.id.to_string())?;\n                 s.pclose()\n             }\n             pprust::NodePat(pat) => {\n-                try!(pp::space(&mut s.s));\n+                pp::space(&mut s.s)?;\n                 s.synth_comment(format!(\"pat {}\", pat.id))\n             }\n         }\n@@ -374,24 +374,24 @@ impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n         match node {\n             pprust_hir::NodeName(_) => Ok(()),\n             pprust_hir::NodeItem(item) => {\n-                try!(pp::space(&mut s.s));\n+                pp::space(&mut s.s)?;\n                 s.synth_comment(item.id.to_string())\n             }\n             pprust_hir::NodeSubItem(id) => {\n-                try!(pp::space(&mut s.s));\n+                pp::space(&mut s.s)?;\n                 s.synth_comment(id.to_string())\n             }\n             pprust_hir::NodeBlock(blk) => {\n-                try!(pp::space(&mut s.s));\n+                pp::space(&mut s.s)?;\n                 s.synth_comment(format!(\"block {}\", blk.id))\n             }\n             pprust_hir::NodeExpr(expr) => {\n-                try!(pp::space(&mut s.s));\n-                try!(s.synth_comment(expr.id.to_string()));\n+                pp::space(&mut s.s)?;\n+                s.synth_comment(expr.id.to_string())?;\n                 s.pclose()\n             }\n             pprust_hir::NodePat(pat) => {\n-                try!(pp::space(&mut s.s));\n+                pp::space(&mut s.s)?;\n                 s.synth_comment(format!(\"pat {}\", pat.id))\n             }\n         }\n@@ -421,13 +421,13 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeIdent(&ast::Ident { name: ast::Name(nm), ctxt }) => {\n-                try!(pp::space(&mut s.s));\n+                pp::space(&mut s.s)?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n                 s.synth_comment(format!(\"{}#{}\", nm, ctxt.0))\n             }\n             pprust::NodeName(&ast::Name(nm)) => {\n-                try!(pp::space(&mut s.s));\n+                pp::space(&mut s.s)?;\n                 s.synth_comment(nm.to_string())\n             }\n             _ => Ok(()),\n@@ -464,10 +464,10 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     fn post(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeExpr(expr) => {\n-                try!(pp::space(&mut s.s));\n-                try!(pp::word(&mut s.s, \"as\"));\n-                try!(pp::space(&mut s.s));\n-                try!(pp::word(&mut s.s, &self.tcx.expr_ty(expr).to_string()));\n+                pp::space(&mut s.s)?;\n+                pp::word(&mut s.s, \"as\")?;\n+                pp::space(&mut s.s)?;\n+                pp::word(&mut s.s, &self.tcx.expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),\n@@ -806,10 +806,10 @@ pub fn pretty_print_input(sess: Session,\n                                                       Some(ast_map.krate()));\n                 for node_id in uii.all_matching_node_ids(ast_map) {\n                     let node = ast_map.get(node_id);\n-                    try!(pp_state.print_node(&node));\n-                    try!(pp::space(&mut pp_state.s));\n-                    try!(pp_state.synth_comment(ast_map.path_to_string(node_id)));\n-                    try!(pp::hardbreak(&mut pp_state.s));\n+                    pp_state.print_node(&node)?;\n+                    pp::space(&mut pp_state.s)?;\n+                    pp_state.synth_comment(ast_map.path_to_string(node_id))?;\n+                    pp::hardbreak(&mut pp_state.s)?;\n                 }\n                 pp::eof(&mut pp_state.s)\n             })\n@@ -836,15 +836,15 @@ pub fn pretty_print_input(sess: Session,\n                         let mir = mir_map.map.get(&nodeid).unwrap_or_else(|| {\n                             sess.fatal(&format!(\"no MIR map entry for node {}\", nodeid))\n                         });\n-                        try!(match pp_type {\n+                        match pp_type {\n                             PpmMir => write_mir_pretty(tcx, iter::once((&nodeid, mir)), &mut out),\n                             _ => write_mir_graphviz(tcx, iter::once((&nodeid, mir)), &mut out)\n-                        });\n+                        }?;\n                     } else {\n-                        try!(match pp_type {\n+                        match pp_type {\n                             PpmMir => write_mir_pretty(tcx, mir_map.map.iter(), &mut out),\n                             _ => write_mir_graphviz(tcx, mir_map.map.iter(), &mut out)\n-                        });\n+                        }?;\n                     }\n                 }\n                 Ok(())"}, {"sha": "cd8fb09406e4714fdaa3dff4b4d79a0438252add", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -119,7 +119,7 @@ impl Encodable for Ident {\n \n impl Decodable for Ident {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(Ident::from_name(try!(Name::decode(d))))\n+        Ok(Ident::from_name(Name::decode(d)?))\n     }\n }\n "}, {"sha": "a647ba8b57cf887743ec1d3a6191d45a5a419a69", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 697, "deletions": 697, "changes": 1394, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f"}, {"sha": "0c736feeefeee0daa3e956ff8df26bda5dc2ece6", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -1221,11 +1221,11 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n \n fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n                          out: &mut io::Write) -> io::Result<()> {\n-    try!(write!(out, \"=Crate Attributes ({})=\\n\", *hash));\n+    write!(out, \"=Crate Attributes ({})=\\n\", *hash)?;\n \n     let r = get_attributes(md);\n     for attr in &r {\n-        try!(write!(out, \"{}\\n\", pprust::attribute_to_string(attr)));\n+        write!(out, \"{}\\n\", pprust::attribute_to_string(attr))?;\n     }\n \n     write!(out, \"\\n\\n\")\n@@ -1267,11 +1267,11 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n }\n \n fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n-    try!(write!(out, \"=External Dependencies=\\n\"));\n+    write!(out, \"=External Dependencies=\\n\")?;\n     for dep in &get_crate_deps(data) {\n-        try!(write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash));\n+        write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash)?;\n     }\n-    try!(write!(out, \"\\n\"));\n+    write!(out, \"\\n\")?;\n     Ok(())\n }\n \n@@ -1308,7 +1308,7 @@ pub fn get_crate_name(data: &[u8]) -> String {\n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Write) -> io::Result<()> {\n     let hash = get_crate_hash(bytes);\n     let md = rbml::Doc::new(bytes);\n-    try!(list_crate_attributes(md, &hash, out));\n+    list_crate_attributes(md, &hash, out)?;\n     list_crate_deps(bytes, out)\n }\n "}, {"sha": "349d8e786c4182a547bcc42a6bb9704ef10594b4", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -19,26 +19,26 @@ use syntax::ast::NodeId;\n pub fn write_mir_graphviz<'a, 't, W, I>(tcx: &ty::TyCtxt<'t>, iter: I, w: &mut W) -> io::Result<()>\n where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n     for (&nodeid, mir) in iter {\n-        try!(writeln!(w, \"digraph Mir_{} {{\", nodeid));\n+        writeln!(w, \"digraph Mir_{} {{\", nodeid)?;\n \n         // Global graph properties\n-        try!(writeln!(w, r#\"    graph [fontname=\"monospace\"];\"#));\n-        try!(writeln!(w, r#\"    node [fontname=\"monospace\"];\"#));\n-        try!(writeln!(w, r#\"    edge [fontname=\"monospace\"];\"#));\n+        writeln!(w, r#\"    graph [fontname=\"monospace\"];\"#)?;\n+        writeln!(w, r#\"    node [fontname=\"monospace\"];\"#)?;\n+        writeln!(w, r#\"    edge [fontname=\"monospace\"];\"#)?;\n \n         // Graph label\n-        try!(write_graph_label(tcx, nodeid, mir, w));\n+        write_graph_label(tcx, nodeid, mir, w)?;\n \n         // Nodes\n         for block in mir.all_basic_blocks() {\n-            try!(write_node(block, mir, w));\n+            write_node(block, mir, w)?;\n         }\n \n         // Edges\n         for source in mir.all_basic_blocks() {\n-            try!(write_edges(source, mir, w));\n+            write_edges(source, mir, w)?;\n         }\n-        try!(writeln!(w, \"}}\"))\n+        writeln!(w, \"}}\")?\n     }\n     Ok(())\n }\n@@ -61,32 +61,32 @@ pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n {\n     let data = mir.basic_block_data(block);\n \n-    try!(write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#));\n+    write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#)?;\n \n     // Basic block number at the top.\n-    try!(write!(w, r#\"<tr><td {attrs} colspan=\"{colspan}\">{blk}</td></tr>\"#,\n+    write!(w, r#\"<tr><td {attrs} colspan=\"{colspan}\">{blk}</td></tr>\"#,\n                 attrs=r#\"bgcolor=\"gray\" align=\"center\"\"#,\n                 colspan=num_cols,\n-                blk=block.index()));\n+                blk=block.index())?;\n \n-    try!(init(w));\n+    init(w)?;\n \n     // List of statements in the middle.\n     if !data.statements.is_empty() {\n-        try!(write!(w, r#\"<tr><td align=\"left\" balign=\"left\">\"#));\n+        write!(w, r#\"<tr><td align=\"left\" balign=\"left\">\"#)?;\n         for statement in &data.statements {\n-            try!(write!(w, \"{}<br/>\", escape(statement)));\n+            write!(w, \"{}<br/>\", escape(statement))?;\n         }\n-        try!(write!(w, \"</td></tr>\"));\n+        write!(w, \"</td></tr>\")?;\n     }\n \n     // Terminator head at the bottom, not including the list of successor blocks. Those will be\n     // displayed as labels on the edges between blocks.\n     let mut terminator_head = String::new();\n     data.terminator().fmt_head(&mut terminator_head).unwrap();\n-    try!(write!(w, r#\"<tr><td align=\"left\">{}</td></tr>\"#, dot::escape_html(&terminator_head)));\n+    write!(w, r#\"<tr><td align=\"left\">{}</td></tr>\"#, dot::escape_html(&terminator_head))?;\n \n-    try!(fini(w));\n+    fini(w)?;\n \n     // Close the table\n     writeln!(w, \"</table>\")\n@@ -95,8 +95,8 @@ pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n /// Write a graphviz DOT node for the given basic block.\n fn write_node<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n     // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n-    try!(write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(block)));\n-    try!(write_node_label(block, mir, w, 1, |_| Ok(()), |_| Ok(())));\n+    write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(block))?;\n+    write_node_label(block, mir, w, 1, |_| Ok(()), |_| Ok(()))?;\n     // Close the node label and the node itself.\n     writeln!(w, \">];\")\n }\n@@ -107,7 +107,7 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result\n     let labels = terminator.fmt_successor_labels();\n \n     for (&target, label) in terminator.successors().iter().zip(labels) {\n-        try!(writeln!(w, r#\"    {} -> {} [label=\"{}\"];\"#, node(source), node(target), label));\n+        writeln!(w, r#\"    {} -> {} [label=\"{}\"];\"#, node(source), node(target), label)?;\n     }\n \n     Ok(())\n@@ -118,40 +118,40 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result\n /// all the variables and temporaries.\n fn write_graph_label<W: Write>(tcx: &ty::TyCtxt, nid: NodeId, mir: &Mir, w: &mut W)\n -> io::Result<()> {\n-    try!(write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.map.path_to_string(nid))));\n+    write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.map.path_to_string(nid)))?;\n \n     // fn argument types.\n     for (i, arg) in mir.arg_decls.iter().enumerate() {\n         if i > 0 {\n-            try!(write!(w, \", \"));\n+            write!(w, \", \")?;\n         }\n-        try!(write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), escape(&arg.ty)));\n+        write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), escape(&arg.ty))?;\n     }\n \n-    try!(write!(w, \") -&gt; \"));\n+    write!(w, \") -&gt; \")?;\n \n     // fn return type.\n     match mir.return_ty {\n-        ty::FnOutput::FnConverging(ty) => try!(write!(w, \"{}\", escape(ty))),\n-        ty::FnOutput::FnDiverging => try!(write!(w, \"!\")),\n+        ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", escape(ty))?,\n+        ty::FnOutput::FnDiverging => write!(w, \"!\")?,\n     }\n \n-    try!(write!(w, r#\"<br align=\"left\"/>\"#));\n+    write!(w, r#\"<br align=\"left\"/>\"#)?;\n \n     // User variable types (including the user's name in a comment).\n     for (i, var) in mir.var_decls.iter().enumerate() {\n-        try!(write!(w, \"let \"));\n+        write!(w, \"let \")?;\n         if var.mutability == Mutability::Mut {\n-            try!(write!(w, \"mut \"));\n+            write!(w, \"mut \")?;\n         }\n-        try!(write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n-                    Lvalue::Var(i as u32), escape(&var.ty), var.name));\n+        write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n+                    Lvalue::Var(i as u32), escape(&var.ty), var.name)?;\n     }\n \n     // Compiler-introduced temporary types.\n     for (i, temp) in mir.temp_decls.iter().enumerate() {\n-        try!(write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n-                    Lvalue::Temp(i as u32), escape(&temp.ty)));\n+        write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n+                    Lvalue::Temp(i as u32), escape(&temp.ty))?;\n     }\n \n     writeln!(w, \">;\")"}, {"sha": "b8bb1b4ee1157c2af06883b4e8e17c7d931964ee", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -19,12 +19,12 @@ const INDENT: &'static str = \"    \";\n pub fn write_mir_pretty<'a, 't, W, I>(tcx: &ty::TyCtxt<'t>, iter: I, w: &mut W) -> io::Result<()>\n where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n     for (&nodeid, mir) in iter {\n-        try!(write_mir_intro(tcx, nodeid, mir, w));\n+        write_mir_intro(tcx, nodeid, mir, w)?;\n         // Nodes\n         for block in mir.all_basic_blocks() {\n-            try!(write_basic_block(block, mir, w));\n+            write_basic_block(block, mir, w)?;\n         }\n-        try!(writeln!(w, \"}}\"))\n+        writeln!(w, \"}}\")?\n     }\n     Ok(())\n }\n@@ -34,15 +34,15 @@ fn write_basic_block<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::R\n     let data = mir.basic_block_data(block);\n \n     // Basic block label at the top.\n-    try!(writeln!(w, \"\\n{}{:?}: {{\", INDENT, block));\n+    writeln!(w, \"\\n{}{:?}: {{\", INDENT, block)?;\n \n     // List of statements in the middle.\n     for statement in &data.statements {\n-        try!(writeln!(w, \"{0}{0}{1:?};\", INDENT, statement));\n+        writeln!(w, \"{0}{0}{1:?};\", INDENT, statement)?;\n     }\n \n     // Terminator at the bottom.\n-    try!(writeln!(w, \"{0}{0}{1:?};\", INDENT, data.terminator()));\n+    writeln!(w, \"{0}{0}{1:?};\", INDENT, data.terminator())?;\n \n     writeln!(w, \"{}}}\", INDENT)\n }\n@@ -52,38 +52,38 @@ fn write_basic_block<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::R\n fn write_mir_intro<W: Write>(tcx: &ty::TyCtxt, nid: NodeId, mir: &Mir, w: &mut W)\n -> io::Result<()> {\n \n-    try!(write!(w, \"fn {}(\", tcx.map.path_to_string(nid)));\n+    write!(w, \"fn {}(\", tcx.map.path_to_string(nid))?;\n \n     // fn argument types.\n     for (i, arg) in mir.arg_decls.iter().enumerate() {\n         if i > 0 {\n-            try!(write!(w, \", \"));\n+            write!(w, \", \")?;\n         }\n-        try!(write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), arg.ty));\n+        write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), arg.ty)?;\n     }\n \n-    try!(write!(w, \") -> \"));\n+    write!(w, \") -> \")?;\n \n     // fn return type.\n     match mir.return_ty {\n-        ty::FnOutput::FnConverging(ty) => try!(write!(w, \"{}\", ty)),\n-        ty::FnOutput::FnDiverging => try!(write!(w, \"!\")),\n+        ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", ty)?,\n+        ty::FnOutput::FnDiverging => write!(w, \"!\")?,\n     }\n \n-    try!(writeln!(w, \" {{\"));\n+    writeln!(w, \" {{\")?;\n \n     // User variable types (including the user's name in a comment).\n     for (i, var) in mir.var_decls.iter().enumerate() {\n-        try!(write!(w, \"{}let \", INDENT));\n+        write!(w, \"{}let \", INDENT)?;\n         if var.mutability == Mutability::Mut {\n-            try!(write!(w, \"mut \"));\n+            write!(w, \"mut \")?;\n         }\n-        try!(writeln!(w, \"{:?}: {}; // {}\", Lvalue::Var(i as u32), var.ty, var.name));\n+        writeln!(w, \"{:?}: {}; // {}\", Lvalue::Var(i as u32), var.ty, var.name)?;\n     }\n \n     // Compiler-introduced temporary types.\n     for (i, temp) in mir.temp_decls.iter().enumerate() {\n-        try!(writeln!(w, \"{}let mut {:?}: {};\", INDENT, Lvalue::Temp(i as u32), temp.ty));\n+        writeln!(w, \"{}let mut {:?}: {};\", INDENT, Lvalue::Temp(i as u32), temp.ty)?;\n     }\n \n     Ok(())"}, {"sha": "f5b480810103f466ba6f9a009e8cbe9dcdba3883", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -254,8 +254,8 @@ impl<'a> ArchiveBuilder<'a> {\n         // want to modify this archive, so we use `io::copy` to not preserve\n         // permission bits.\n         if let Some(ref s) = self.config.src {\n-            try!(io::copy(&mut try!(File::open(s)),\n-                          &mut try!(File::create(&self.config.dst))));\n+            io::copy(&mut File::open(s)?,\n+                          &mut File::create(&self.config.dst)?)?;\n         }\n \n         if removals.len() > 0 {\n@@ -267,12 +267,12 @@ impl<'a> ArchiveBuilder<'a> {\n             match addition {\n                 Addition::File { path, name_in_archive } => {\n                     let dst = self.work_dir.path().join(&name_in_archive);\n-                    try!(fs::copy(&path, &dst));\n+                    fs::copy(&path, &dst)?;\n                     members.push(PathBuf::from(name_in_archive));\n                 }\n                 Addition::Archive { archive, archive_name, mut skip } => {\n-                    try!(self.add_archive_members(&mut members, archive,\n-                                                  &archive_name, &mut *skip));\n+                    self.add_archive_members(&mut members, archive,\n+                                                  &archive_name, &mut *skip)?;\n                 }\n             }\n         }\n@@ -334,7 +334,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // all SYMDEF files as these are just magical placeholders which get\n         // re-created when we make a new archive anyway.\n         for file in archive.iter() {\n-            let file = try!(file.map_err(string_to_io_error));\n+            let file = file.map_err(string_to_io_error)?;\n             if !is_relevant_child(&file) {\n                 continue\n             }\n@@ -388,7 +388,7 @@ impl<'a> ArchiveBuilder<'a> {\n                 }\n             }\n             let dst = self.work_dir.path().join(&new_filename);\n-            try!(try!(File::create(&dst)).write_all(file.data()));\n+            File::create(&dst)?.write_all(file.data())?;\n             members.push(PathBuf::from(new_filename));\n         }\n         Ok(())\n@@ -455,7 +455,7 @@ impl<'a> ArchiveBuilder<'a> {\n         unsafe {\n             if let Some(archive) = self.src_archive() {\n                 for child in archive.iter() {\n-                    let child = try!(child.map_err(string_to_io_error));\n+                    let child = child.map_err(string_to_io_error)?;\n                     let child_name = match child.name() {\n                         Some(s) => s,\n                         None => continue,\n@@ -464,7 +464,7 @@ impl<'a> ArchiveBuilder<'a> {\n                         continue\n                     }\n \n-                    let name = try!(CString::new(child_name));\n+                    let name = CString::new(child_name)?;\n                     members.push(llvm::LLVMRustArchiveMemberNew(ptr::null(),\n                                                                 name.as_ptr(),\n                                                                 child.raw()));\n@@ -474,8 +474,8 @@ impl<'a> ArchiveBuilder<'a> {\n             for addition in mem::replace(&mut self.additions, Vec::new()) {\n                 match addition {\n                     Addition::File { path, name_in_archive } => {\n-                        let path = try!(CString::new(path.to_str().unwrap()));\n-                        let name = try!(CString::new(name_in_archive));\n+                        let path = CString::new(path.to_str().unwrap())?;\n+                        let name = CString::new(name_in_archive)?;\n                         members.push(llvm::LLVMRustArchiveMemberNew(path.as_ptr(),\n                                                                     name.as_ptr(),\n                                                                     ptr::null_mut()));\n@@ -484,7 +484,7 @@ impl<'a> ArchiveBuilder<'a> {\n                     }\n                     Addition::Archive { archive, archive_name: _, mut skip } => {\n                         for child in archive.iter() {\n-                            let child = try!(child.map_err(string_to_io_error));\n+                            let child = child.map_err(string_to_io_error)?;\n                             if !is_relevant_child(&child) {\n                                 continue\n                             }\n@@ -502,7 +502,7 @@ impl<'a> ArchiveBuilder<'a> {\n                             let child_name = Path::new(child_name)\n                                                   .file_name().unwrap()\n                                                   .to_str().unwrap();\n-                            let name = try!(CString::new(child_name));\n+                            let name = CString::new(child_name)?;\n                             let m = llvm::LLVMRustArchiveMemberNew(ptr::null(),\n                                                                    name.as_ptr(),\n                                                                    child.raw());\n@@ -515,7 +515,7 @@ impl<'a> ArchiveBuilder<'a> {\n             }\n \n             let dst = self.config.dst.to_str().unwrap().as_bytes();\n-            let dst = try!(CString::new(dst));\n+            let dst = CString::new(dst)?;\n             let r = llvm::LLVMRustWriteArchive(dst.as_ptr(),\n                                                members.len() as libc::size_t,\n                                                members.as_ptr(),"}, {"sha": "acb458f8cc6eebf26be5aa5895dcb3f09b93eec8", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -757,9 +757,9 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n                                  bc_data_deflated: &[u8]) -> io::Result<()> {\n     let bc_data_deflated_size: u64 = bc_data_deflated.len() as u64;\n \n-    try!(writer.write_all(RLIB_BYTECODE_OBJECT_MAGIC));\n-    try!(writer.write_all(&[1, 0, 0, 0]));\n-    try!(writer.write_all(&[\n+    writer.write_all(RLIB_BYTECODE_OBJECT_MAGIC)?;\n+    writer.write_all(&[1, 0, 0, 0])?;\n+    writer.write_all(&[\n         (bc_data_deflated_size >>  0) as u8,\n         (bc_data_deflated_size >>  8) as u8,\n         (bc_data_deflated_size >> 16) as u8,\n@@ -768,8 +768,8 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n         (bc_data_deflated_size >> 40) as u8,\n         (bc_data_deflated_size >> 48) as u8,\n         (bc_data_deflated_size >> 56) as u8,\n-    ]));\n-    try!(writer.write_all(&bc_data_deflated));\n+    ])?;\n+    writer.write_all(&bc_data_deflated)?;\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -781,7 +781,7 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n     // padding byte to make it even. This works around a crash bug in LLDB\n     // (see issue #15950)\n     if number_of_bytes_written_so_far % 2 == 1 {\n-        try!(writer.write_all(&[0]));\n+        writer.write_all(&[0])?;\n     }\n \n     return Ok(());"}, {"sha": "b6b330c3734b0310f67d1202634aa743164baf10", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -327,16 +327,16 @@ impl<'a> Linker for MsvcLinker<'a> {\n                       tmpdir: &Path) {\n         let path = tmpdir.join(\"lib.def\");\n         let res = (|| -> io::Result<()> {\n-            let mut f = BufWriter::new(try!(File::create(&path)));\n+            let mut f = BufWriter::new(File::create(&path)?);\n \n             // Start off with the standard module name header and then go\n             // straight to exports.\n-            try!(writeln!(f, \"LIBRARY\"));\n-            try!(writeln!(f, \"EXPORTS\"));\n+            writeln!(f, \"LIBRARY\")?;\n+            writeln!(f, \"EXPORTS\")?;\n \n             // Write out all our local symbols\n             for sym in trans.reachable.iter() {\n-                try!(writeln!(f, \"  {}\", sym));\n+                writeln!(f, \"  {}\", sym)?;\n             }\n \n             // Take a look at how all upstream crates are linked into this\n@@ -357,7 +357,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n                 cstore.item_symbol(did)\n             });\n             for symbol in symbols {\n-                try!(writeln!(f, \"  {}\", symbol));\n+                writeln!(f, \"  {}\", symbol)?;\n             }\n             Ok(())\n         })();"}, {"sha": "bd2d05915f6db1655cee07b7db499492b3b6e526", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -175,9 +175,9 @@ impl<'blk, 'tcx: 'blk> fmt::Debug for CleanupScopeKind<'blk, 'tcx> {\n             CustomScopeKind => write!(f, \"CustomScopeKind\"),\n             AstScopeKind(nid) => write!(f, \"AstScopeKind({})\", nid),\n             LoopScopeKind(nid, ref blks) => {\n-                try!(write!(f, \"LoopScopeKind({}, [\", nid));\n+                write!(f, \"LoopScopeKind({}, [\", nid)?;\n                 for blk in blks {\n-                    try!(write!(f, \"{:p}, \", blk));\n+                    write!(f, \"{:p}, \", blk)?;\n                 }\n                 write!(f, \"])\")\n             }"}, {"sha": "12bcd34a663360d3d591a57aab89f9fa02b09458", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -316,9 +316,9 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let val = if qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n         // Avoid autorefs as they would create global instead of stack\n         // references, even when only the latter are correct.\n-        try!(const_expr_unadjusted(ccx, expr, ty, param_substs, None, trueconst))\n+        const_expr_unadjusted(ccx, expr, ty, param_substs, None, trueconst)?\n     } else {\n-        try!(const_expr(ccx, expr, param_substs, None, trueconst)).0\n+        const_expr(ccx, expr, param_substs, None, trueconst)?.0\n     };\n \n     // boolean SSA values are i1, but they have to be stored in i8 slots,\n@@ -344,7 +344,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             -> Result<(ValueRef, Ty<'tcx>), ConstEvalFailure> {\n     let ety = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n                                                &cx.tcx().expr_ty(e));\n-    let llconst = try!(const_expr_unadjusted(cx, e, ety, param_substs, fn_args, trueconst));\n+    let llconst = const_expr_unadjusted(cx, e, ety, param_substs, fn_args, trueconst)?;\n     let mut llconst = llconst;\n     let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n                                                             &cx.tcx().expr_ty_adjusted(e));\n@@ -594,18 +594,18 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprBinary(b, ref e1, ref e2) => {\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n-            let (te1, ty) = try!(const_expr(cx, &e1, param_substs, fn_args, trueconst));\n+            let (te1, ty) = const_expr(cx, &e1, param_substs, fn_args, trueconst)?;\n             debug!(\"const_expr_unadjusted: te1={:?}, ty={:?}\",\n                    Value(te1), ty);\n             assert!(!ty.is_simd());\n             let is_float = ty.is_fp();\n             let signed = ty.is_signed();\n \n-            let (te2, ty2) = try!(const_expr(cx, &e2, param_substs, fn_args, trueconst));\n+            let (te2, ty2) = const_expr(cx, &e2, param_substs, fn_args, trueconst)?;\n             debug!(\"const_expr_unadjusted: te2={:?}, ty={:?}\",\n                    Value(te2), ty2);\n \n-            try!(check_binary_expr_validity(cx, e, ty, te1, te2, trueconst));\n+            check_binary_expr_validity(cx, e, ty, te1, te2, trueconst)?;\n \n             unsafe { match b.node {\n                 hir::BiAdd if is_float => llvm::LLVMConstFAdd(te1, te2),\n@@ -651,9 +651,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } } // unsafe { match b.node {\n         },\n         hir::ExprUnary(u, ref inner_e) => {\n-            let (te, ty) = try!(const_expr(cx, &inner_e, param_substs, fn_args, trueconst));\n+            let (te, ty) = const_expr(cx, &inner_e, param_substs, fn_args, trueconst)?;\n \n-            try!(check_unary_expr_validity(cx, e, ty, te, trueconst));\n+            check_unary_expr_validity(cx, e, ty, te, trueconst)?;\n \n             let is_float = ty.is_fp();\n             unsafe { match u {\n@@ -664,21 +664,21 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } }\n         },\n         hir::ExprField(ref base, field) => {\n-            let (bv, bt) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n+            let (bv, bt) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n             let ix = vinfo.field_index(field.node);\n             adt::const_get_field(cx, &brepr, bv, vinfo.discr, ix)\n         },\n         hir::ExprTupField(ref base, idx) => {\n-            let (bv, bt) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n+            let (bv, bt) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n             adt::const_get_field(cx, &brepr, bv, vinfo.discr, idx.node)\n         },\n         hir::ExprIndex(ref base, ref index) => {\n-            let (bv, bt) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n-            let iv = try!(const_expr(cx, &index, param_substs, fn_args, TrueConst::Yes)).0;\n+            let (bv, bt) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n+            let iv = const_expr(cx, &index, param_substs, fn_args, TrueConst::Yes)?.0;\n             let iv = if let Some(iv) = const_to_opt_uint(iv) {\n                 iv\n             } else {\n@@ -729,7 +729,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprCast(ref base, _) => {\n             let t_cast = ety;\n             let llty = type_of::type_of(cx, t_cast);\n-            let (v, t_expr) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n+            let (v, t_expr) = const_expr(cx, &base, param_substs, fn_args, trueconst)?;\n             debug!(\"trans_const_cast({:?} as {:?})\", t_expr, t_cast);\n             if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n                 return Ok(v);\n@@ -811,30 +811,30 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } else {\n                 // If this isn't the address of a static, then keep going through\n                 // normal constant evaluation.\n-                let (v, ty) = try!(const_expr(cx, &sub, param_substs, fn_args, trueconst));\n+                let (v, ty) = const_expr(cx, &sub, param_substs, fn_args, trueconst)?;\n                 addr_of(cx, v, type_of::align_of(cx, ty), \"ref\")\n             }\n         },\n         hir::ExprAddrOf(hir::MutMutable, ref sub) => {\n-            let (v, ty) = try!(const_expr(cx, &sub, param_substs, fn_args, trueconst));\n+            let (v, ty) = const_expr(cx, &sub, param_substs, fn_args, trueconst)?;\n             addr_of_mut(cx, v, type_of::align_of(cx, ty), \"ref_mut_slice\")\n         },\n         hir::ExprTup(ref es) => {\n             let repr = adt::represent_type(cx, ety);\n-            let vals = try!(map_list(&es[..]));\n+            let vals = map_list(&es[..])?;\n             adt::trans_const(cx, &repr, Disr(0), &vals[..])\n         },\n         hir::ExprStruct(_, ref fs, ref base_opt) => {\n             let repr = adt::represent_type(cx, ety);\n \n             let base_val = match *base_opt {\n-                Some(ref base) => Some(try!(const_expr(\n+                Some(ref base) => Some(const_expr(\n                     cx,\n                     &base,\n                     param_substs,\n                     fn_args,\n                     trueconst,\n-                ))),\n+                )?),\n                 None => None\n             };\n \n@@ -851,7 +851,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             .collect::<Vec<Result<_, ConstEvalFailure>>>()\n             .into_iter()\n             .collect::<Result<Vec<_>,ConstEvalFailure>>();\n-            let cs = try!(cs);\n+            let cs = cs?;\n             if ety.is_simd() {\n                 C_vector(&cs[..])\n             } else {\n@@ -872,7 +872,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                        .collect::<Vec<Result<_, ConstEvalFailure>>>()\n                        .into_iter()\n                        .collect::<Result<Vec<_>, ConstEvalFailure>>();\n-            let vs = try!(vs);\n+            let vs = vs?;\n             // If the vector contains enums, an LLVM array won't work.\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, &vs[..], false)\n@@ -884,7 +884,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = cx.tcx().eval_repeat_count(count);\n-            let unit_val = try!(const_expr(cx, &elem, param_substs, fn_args, trueconst)).0;\n+            let unit_val = const_expr(cx, &elem, param_substs, fn_args, trueconst)?.0;\n             let vs = vec![unit_val; n];\n             if val_ty(unit_val) != llunitty {\n                 C_struct(cx, &vs[..], false)\n@@ -904,7 +904,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n                 Def::Fn(..) | Def::Method(..) => C_nil(cx),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                    load_const(cx, try!(get_const_val(cx, def_id, e, param_substs)),\n+                    load_const(cx, get_const_val(cx, def_id, e, param_substs)?,\n                                ety)\n                 }\n                 Def::Variant(enum_did, variant_did) => {\n@@ -940,17 +940,17 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 };\n             }\n             let def = cx.tcx().def_map.borrow()[&callee.id].full_def();\n-            let arg_vals = try!(map_list(args));\n+            let arg_vals = map_list(args)?;\n             match def {\n                 Def::Fn(did) | Def::Method(did) => {\n-                    try!(const_fn_call(\n+                    const_fn_call(\n                         cx,\n                         did,\n                         cx.tcx().node_id_item_substs(callee.id).substs,\n                         &arg_vals,\n                         param_substs,\n                         trueconst,\n-                    ))\n+                    )?\n                 }\n                 Def::Struct(..) => {\n                     if ety.is_simd() {\n@@ -972,22 +972,22 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         },\n         hir::ExprMethodCall(_, _, ref args) => {\n-            let arg_vals = try!(map_list(args));\n+            let arg_vals = map_list(args)?;\n             let method_call = ty::MethodCall::expr(e.id);\n             let method = cx.tcx().tables.borrow().method_map[&method_call];\n-            try!(const_fn_call(cx, method.def_id, method.substs.clone(),\n-                               &arg_vals, param_substs, trueconst))\n+            const_fn_call(cx, method.def_id, method.substs.clone(),\n+                               &arg_vals, param_substs, trueconst)?\n         },\n-        hir::ExprType(ref e, _) => try!(const_expr(cx, &e, param_substs, fn_args, trueconst)).0,\n+        hir::ExprType(ref e, _) => const_expr(cx, &e, param_substs, fn_args, trueconst)?.0,\n         hir::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => try!(const_expr(\n+                Some(ref expr) => const_expr(\n                     cx,\n                     &expr,\n                     param_substs,\n                     fn_args,\n                     trueconst,\n-                )).0,\n+                )?.0,\n                 None => C_nil(cx),\n             }\n         },\n@@ -1149,13 +1149,13 @@ pub fn trans_static(ccx: &CrateContext,\n         let datum = get_static(ccx, def_id);\n \n         let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-        let (v, _) = try!(const_expr(\n+        let (v, _) = const_expr(\n             ccx,\n             expr,\n             empty_substs,\n             None,\n             TrueConst::Yes,\n-        ).map_err(|e| e.into_inner()));\n+        ).map_err(|e| e.into_inner())?;\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected"}, {"sha": "0cc1fb9e1c79613da690efdee7b0ae936189d191", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -934,7 +934,7 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n                                                  tcx.mk_substs(dummy_substs)));\n     }\n \n-    try!(this.ensure_super_predicates(binding.span, trait_ref.def_id()));\n+    this.ensure_super_predicates(binding.span, trait_ref.def_id())?;\n \n     let mut candidates: Vec<ty::PolyTraitRef> =\n         traits::supertraits(tcx, trait_ref.clone())\n@@ -953,11 +953,11 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n         }\n     }\n \n-    let candidate = try!(one_bound_for_assoc_type(tcx,\n+    let candidate = one_bound_for_assoc_type(tcx,\n                                                   candidates,\n                                                   &trait_ref.to_string(),\n                                                   &binding.item_name.as_str(),\n-                                                  binding.span));\n+                                                  binding.span)?;\n \n     Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n         projection_ty: ty::ProjectionTy {               //                           |"}, {"sha": "c62922a33de2c62ec9b8b040cb68a43a4e00966f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -220,7 +220,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let (r_a, mt_a) = match a.sty {\n             ty::TyRef(r_a, mt_a) => {\n-                try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+                coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n             }\n             _ => return self.unify_and_identity(a, b)\n@@ -414,15 +414,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n         let (source, reborrow) = match (&source.sty, &target.sty) {\n             (&ty::TyRef(_, mt_a), &ty::TyRef(_, mt_b)) => {\n-                try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+                coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n \n                 let coercion = Coercion(self.origin.span());\n                 let r_borrow = self.fcx.infcx().next_region_var(coercion);\n                 let region = self.tcx().mk_region(r_borrow);\n                 (mt_a.ty, Some(AutoPtr(region, mt_b.mutbl)))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n-                try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n+                coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (mt_a.ty, Some(AutoUnsafe(mt_b.mutbl)))\n             }\n             _ => (source, None)\n@@ -564,8 +564,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Check that the types which they point at are compatible.\n         let a_unsafe = self.tcx().mk_ptr(ty::TypeAndMut{ mutbl: mutbl_b, ty: mt_a.ty });\n-        let (ty, noop) = try!(self.unify_and_identity(a_unsafe, b));\n-        try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n+        let (ty, noop) = self.unify_and_identity(a_unsafe, b)?;\n+        coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n \n         // Although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that\n@@ -592,7 +592,7 @@ fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx>,\n     where E: Fn() -> I,\n           I: IntoIterator<Item=&'b hir::Expr> {\n \n-    let (ty, adjustment) = try!(indent(|| coerce.coerce(exprs, a, b)));\n+    let (ty, adjustment) = indent(|| coerce.coerce(exprs, a, b))?;\n \n     let fcx = coerce.fcx;\n     if let AdjustDerefRef(auto) = adjustment {\n@@ -621,7 +621,7 @@ pub fn try<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let mut coerce = Coerce::new(fcx, TypeOrigin::ExprAssignable(expr.span));\n     fcx.infcx().commit_if_ok(|_| {\n         let (ty, adjustment) =\n-            try!(apply(&mut coerce, &|| Some(expr), source, target));\n+            apply(&mut coerce, &|| Some(expr), source, target)?;\n         if !adjustment.is_identity() {\n             debug!(\"Success, coerced with {:?}\", adjustment);\n             assert!(!fcx.inh.tables.borrow().adjustments.contains_key(&expr.id));\n@@ -657,7 +657,7 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n          &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n             // The signature must always match.\n-            let fty = try!(lub.relate(a_fty, b_fty));\n+            let fty = lub.relate(a_fty, b_fty)?;\n \n             if a_def_id == b_def_id {\n                 // Same function, maybe the parameters match."}, {"sha": "ee5dbd032f3ee7c5389fa95043f46f797e90abc9", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -323,7 +323,7 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n         debug!(\"compare_impl_method: trait_fty={:?}\",\n                trait_fty);\n \n-        try!(infer::mk_subty(&infcx, false, origin, impl_fty, trait_fty));\n+        infer::mk_subty(&infcx, false, origin, impl_fty, trait_fty)?;\n \n         infcx.leak_check(&skol_map, snapshot)\n     });"}, {"sha": "c79a35b2f33ce9f509dd81d0df70dc20e9dde700", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -46,11 +46,11 @@ pub fn check_drop_impl(tcx: &TyCtxt, drop_impl_did: DefId) -> Result<(), ()> {\n     match dtor_self_type.sty {\n         ty::TyEnum(adt_def, self_to_impl_substs) |\n         ty::TyStruct(adt_def, self_to_impl_substs) => {\n-            try!(ensure_drop_params_and_item_params_correspond(tcx,\n+            ensure_drop_params_and_item_params_correspond(tcx,\n                                                                drop_impl_did,\n                                                                dtor_generics,\n                                                                &dtor_self_type,\n-                                                               adt_def.did));\n+                                                               adt_def.did)?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(tcx,\n                                                             drop_impl_did,\n@@ -452,15 +452,15 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n                     let fty = field.ty(tcx, substs);\n                     let fty = cx.rcx.fcx.resolve_type_vars_if_possible(\n                         cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n-                    try!(iterate_over_potentially_unsafe_regions_in_type(\n+                    iterate_over_potentially_unsafe_regions_in_type(\n                         cx,\n                         TypeContext::ADT {\n                             def_id: did,\n                             field: field.name,\n                             variant: variant.name,\n                         },\n                         fty,\n-                        depth+1))\n+                        depth+1)?\n                 }\n             }\n             Ok(())\n@@ -469,8 +469,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n         ty::TyTuple(ref tys) |\n         ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. }) => {\n             for ty in tys {\n-                try!(iterate_over_potentially_unsafe_regions_in_type(\n-                    cx, context, ty, depth+1))\n+                iterate_over_potentially_unsafe_regions_in_type(\n+                    cx, context, ty, depth+1)?\n             }\n             Ok(())\n         }"}, {"sha": "7f982c466a70441436588fc4cff249eaf5c585bd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -124,7 +124,7 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     let mode = probe::Mode::MethodCall;\n     let self_ty = fcx.infcx().resolve_type_vars_if_possible(&self_ty);\n-    let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, call_expr.id));\n+    let pick = probe::probe(fcx, span, mode, method_name, self_ty, call_expr.id)?;\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }\n \n@@ -337,7 +337,7 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               -> Result<Def, MethodError<'tcx>>\n {\n     let mode = probe::Mode::Path;\n-    let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n+    let pick = probe::probe(fcx, span, mode, method_name, self_ty, expr_id)?;\n     let def = pick.item.def();\n \n     if let probe::InherentImplPick = pick.kind {"}, {"sha": "b522de8d13586399c29fd680d8e36290072b220c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -186,7 +186,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                              steps,\n                                              opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n-        try!(probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id));\n+        probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?;\n         probe_cx.pick()\n     })\n }\n@@ -568,7 +568,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for &trait_did in applicable_traits {\n                 if duplicates.insert(trait_did) {\n-                    try!(self.assemble_extension_candidates_for_trait(trait_did));\n+                    self.assemble_extension_candidates_for_trait(trait_did)?;\n                 }\n             }\n         }\n@@ -579,7 +579,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let mut duplicates = HashSet::new();\n         for trait_info in suggest::all_traits(self.fcx.ccx) {\n             if duplicates.insert(trait_info.def_id) {\n-                try!(self.assemble_extension_candidates_for_trait(trait_info.def_id));\n+                self.assemble_extension_candidates_for_trait(trait_info.def_id)?;\n             }\n         }\n         Ok(())\n@@ -612,7 +612,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         self.assemble_extension_candidates_for_trait_impls(trait_def_id, item.clone());\n \n-        try!(self.assemble_closure_candidates(trait_def_id, item.clone()));\n+        self.assemble_closure_candidates(trait_def_id, item.clone())?;\n \n         self.assemble_projection_candidates(trait_def_id, item.clone());\n \n@@ -854,7 +854,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let span = self.span;\n         let tcx = self.tcx();\n \n-        try!(self.assemble_extension_candidates_for_all_traits());\n+        self.assemble_extension_candidates_for_all_traits()?;\n \n         let out_of_scope_traits = match self.pick_core() {\n             Some(Ok(p)) => vec![p.item.container().id()],"}, {"sha": "3f8f31ce3ce80230df2a7d94567ef45e63e252f2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -292,7 +292,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n             let def_ids = ensure_super_predicates_step(self, trait_def_id);\n \n             for def_id in def_ids {\n-                try!(self.ensure_super_predicates(span, def_id));\n+                self.ensure_super_predicates(span, def_id)?;\n             }\n \n             Ok(())"}, {"sha": "ac760cc905603d78c217b2c3c45f0820e5790d75", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -339,31 +339,31 @@ pub fn check_crate(tcx: &TyCtxt, trait_map: ty::TraitMap) -> CompileResult {\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n-    try!(tcx.sess.track_errors(|| {\n+    tcx.sess.track_errors(|| {\n         time(time_passes, \"type collecting\", ||\n              collect::collect_item_types(tcx));\n \n-    }));\n+    })?;\n \n     time(time_passes, \"variance inference\", ||\n          variance::infer_variance(tcx));\n \n-    try!(tcx.sess.track_errors(|| {\n+    tcx.sess.track_errors(|| {\n       time(time_passes, \"coherence checking\", ||\n           coherence::check_coherence(&ccx));\n-    }));\n+    })?;\n \n-    try!(time(time_passes, \"wf checking\", ||\n-        check::check_wf_new(&ccx)));\n+    time(time_passes, \"wf checking\", ||\n+        check::check_wf_new(&ccx))?;\n \n-    try!(time(time_passes, \"item-types checking\", ||\n-        check::check_item_types(&ccx)));\n+    time(time_passes, \"item-types checking\", ||\n+        check::check_item_types(&ccx))?;\n \n-    try!(time(time_passes, \"item-bodies checking\", ||\n-        check::check_item_bodies(&ccx)));\n+    time(time_passes, \"item-bodies checking\", ||\n+        check::check_item_bodies(&ccx))?;\n \n-    try!(time(time_passes, \"drop-impl checking\", ||\n-        check::check_drop_impls(&ccx)));\n+    time(time_passes, \"drop-impl checking\", ||\n+        check::check_drop_impls(&ccx))?;\n \n     check_for_entry_fn(&ccx);\n "}, {"sha": "2ecb071fcc2a4228694c8eeb47c693b19b246fd9", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -38,9 +38,9 @@ impl ExternalHtml {\n }\n \n pub fn load_string(input: &Path) -> io::Result<Option<String>> {\n-    let mut f = try!(File::open(input));\n+    let mut f = File::open(input)?;\n     let mut d = Vec::new();\n-    try!(f.read_to_end(&mut d));\n+    f.read_to_end(&mut d)?;\n     Ok(str::from_utf8(&d).map(|s| s.to_string()).ok())\n }\n "}, {"sha": "1173e6447f50cacc0b0cf1bfe3df33f83fefc424", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -29,7 +29,7 @@ impl<'a> fmt::Display for Escape<'a> {\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n-                    try!(fmt.write_str(&pile_o_bits[last.. i]));\n+                    fmt.write_str(&pile_o_bits[last.. i])?;\n                     let s = match ch as char {\n                         '>' => \"&gt;\",\n                         '<' => \"&lt;\",\n@@ -38,15 +38,15 @@ impl<'a> fmt::Display for Escape<'a> {\n                         '\"' => \"&quot;\",\n                         _ => unreachable!()\n                     };\n-                    try!(fmt.write_str(s));\n+                    fmt.write_str(s)?;\n                     last = i + 1;\n                 }\n                 _ => {}\n             }\n         }\n \n         if last < s.len() {\n-            try!(fmt.write_str(&pile_o_bits[last..]));\n+            fmt.write_str(&pile_o_bits[last..])?;\n         }\n         Ok(())\n     }"}, {"sha": "f666a0a10176af7cd4e2c358328f4080aa0a3248", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -77,8 +77,8 @@ impl ConstnessSpace {\n impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, item) in self.0.iter().enumerate() {\n-            if i != 0 { try!(write!(f, \", \")); }\n-            try!(write!(f, \"{}\", item));\n+            if i != 0 { write!(f, \", \")?; }\n+            write!(f, \"{}\", item)?;\n         }\n         Ok(())\n     }\n@@ -89,9 +89,9 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n         let &TyParamBounds(bounds) = self;\n         for (i, bound) in bounds.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write_str(\" + \"));\n+                f.write_str(\" + \")?;\n             }\n-            try!(write!(f, \"{}\", *bound));\n+            write!(f, \"{}\", *bound)?;\n         }\n         Ok(())\n     }\n@@ -100,36 +100,36 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n impl fmt::Display for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.is_empty() && self.type_params.is_empty() { return Ok(()) }\n-        try!(f.write_str(\"&lt;\"));\n+        f.write_str(\"&lt;\")?;\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write_str(\", \"));\n+                f.write_str(\", \")?;\n             }\n-            try!(write!(f, \"{}\", *life));\n+            write!(f, \"{}\", *life)?;\n         }\n \n         if !self.type_params.is_empty() {\n             if !self.lifetimes.is_empty() {\n-                try!(f.write_str(\", \"));\n+                f.write_str(\", \")?;\n             }\n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n-                    try!(f.write_str(\", \"))\n+                    f.write_str(\", \")?\n                 }\n-                try!(f.write_str(&tp.name));\n+                f.write_str(&tp.name)?;\n \n                 if !tp.bounds.is_empty() {\n-                    try!(write!(f, \": {}\", TyParamBounds(&tp.bounds)));\n+                    write!(f, \": {}\", TyParamBounds(&tp.bounds))?;\n                 }\n \n                 match tp.default {\n-                    Some(ref ty) => { try!(write!(f, \" = {}\", ty)); },\n+                    Some(ref ty) => { write!(f, \" = {}\", ty)?; },\n                     None => {}\n                 };\n             }\n         }\n-        try!(f.write_str(\"&gt;\"));\n+        f.write_str(\"&gt;\")?;\n         Ok(())\n     }\n }\n@@ -140,55 +140,55 @@ impl<'a> fmt::Display for WhereClause<'a> {\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n         }\n-        try!(f.write_str(\" <span class='where'>where \"));\n+        f.write_str(\" <span class='where'>where \")?;\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write_str(\", \"));\n+                f.write_str(\", \")?;\n             }\n             match pred {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n-                    try!(write!(f, \"{}: {}\", ty, TyParamBounds(bounds)));\n+                    write!(f, \"{}: {}\", ty, TyParamBounds(bounds))?;\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime,\n                                                           ref bounds } => {\n-                    try!(write!(f, \"{}: \", lifetime));\n+                    write!(f, \"{}: \", lifetime)?;\n                     for (i, lifetime) in bounds.iter().enumerate() {\n                         if i > 0 {\n-                            try!(f.write_str(\" + \"));\n+                            f.write_str(\" + \")?;\n                         }\n \n-                        try!(write!(f, \"{}\", lifetime));\n+                        write!(f, \"{}\", lifetime)?;\n                     }\n                 }\n                 &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n-                    try!(write!(f, \"{} == {}\", lhs, rhs));\n+                    write!(f, \"{} == {}\", lhs, rhs)?;\n                 }\n             }\n         }\n-        try!(f.write_str(\"</span>\"));\n+        f.write_str(\"</span>\")?;\n         Ok(())\n     }\n }\n \n impl fmt::Display for clean::Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(f.write_str(self.get_ref()));\n+        f.write_str(self.get_ref())?;\n         Ok(())\n     }\n }\n \n impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if !self.lifetimes.is_empty() {\n-            try!(f.write_str(\"for&lt;\"));\n+            f.write_str(\"for&lt;\")?;\n             for (i, lt) in self.lifetimes.iter().enumerate() {\n                 if i > 0 {\n-                    try!(f.write_str(\", \"));\n+                    f.write_str(\", \")?;\n                 }\n-                try!(write!(f, \"{}\", lt));\n+                write!(f, \"{}\", lt)?;\n             }\n-            try!(f.write_str(\"&gt; \"));\n+            f.write_str(\"&gt; \")?;\n         }\n         write!(f, \"{}\", self.trait_)\n     }\n@@ -218,46 +218,46 @@ impl fmt::Display for clean::PathParameters {\n                 ref lifetimes, ref types, ref bindings\n             } => {\n                 if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n-                    try!(f.write_str(\"&lt;\"));\n+                    f.write_str(\"&lt;\")?;\n                     let mut comma = false;\n                     for lifetime in lifetimes {\n                         if comma {\n-                            try!(f.write_str(\", \"));\n+                            f.write_str(\", \")?;\n                         }\n                         comma = true;\n-                        try!(write!(f, \"{}\", *lifetime));\n+                        write!(f, \"{}\", *lifetime)?;\n                     }\n                     for ty in types {\n                         if comma {\n-                            try!(f.write_str(\", \"));\n+                            f.write_str(\", \")?;\n                         }\n                         comma = true;\n-                        try!(write!(f, \"{}\", *ty));\n+                        write!(f, \"{}\", *ty)?;\n                     }\n                     for binding in bindings {\n                         if comma {\n-                            try!(f.write_str(\", \"));\n+                            f.write_str(\", \")?;\n                         }\n                         comma = true;\n-                        try!(write!(f, \"{}\", *binding));\n+                        write!(f, \"{}\", *binding)?;\n                     }\n-                    try!(f.write_str(\"&gt;\"));\n+                    f.write_str(\"&gt;\")?;\n                 }\n             }\n             clean::PathParameters::Parenthesized { ref inputs, ref output } => {\n-                try!(f.write_str(\"(\"));\n+                f.write_str(\"(\")?;\n                 let mut comma = false;\n                 for ty in inputs {\n                     if comma {\n-                        try!(f.write_str(\", \"));\n+                        f.write_str(\", \")?;\n                     }\n                     comma = true;\n-                    try!(write!(f, \"{}\", *ty));\n+                    write!(f, \"{}\", *ty)?;\n                 }\n-                try!(f.write_str(\")\"));\n+                f.write_str(\")\")?;\n                 if let Some(ref ty) = *output {\n-                    try!(f.write_str(\" -&gt; \"));\n-                    try!(write!(f, \"{}\", ty));\n+                    f.write_str(\" -&gt; \")?;\n+                    write!(f, \"{}\", ty)?;\n                 }\n             }\n         }\n@@ -267,22 +267,22 @@ impl fmt::Display for clean::PathParameters {\n \n impl fmt::Display for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(f.write_str(&self.name));\n+        f.write_str(&self.name)?;\n         write!(f, \"{}\", self.params)\n     }\n }\n \n impl fmt::Display for clean::Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.global {\n-            try!(f.write_str(\"::\"))\n+            f.write_str(\"::\")?\n         }\n \n         for (i, seg) in self.segments.iter().enumerate() {\n             if i > 0 {\n-                try!(f.write_str(\"::\"))\n+                f.write_str(\"::\")?\n             }\n-            try!(write!(f, \"{}\", seg));\n+            write!(f, \"{}\", seg)?;\n         }\n         Ok(())\n     }\n@@ -339,33 +339,33 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n             Some(mut root) => {\n                 for seg in &path.segments[..amt] {\n                     if \"super\" == seg.name || \"self\" == seg.name {\n-                        try!(write!(w, \"{}::\", seg.name));\n+                        write!(w, \"{}::\", seg.name)?;\n                     } else {\n                         root.push_str(&seg.name);\n                         root.push_str(\"/\");\n-                        try!(write!(w, \"<a class='mod'\n+                        write!(w, \"<a class='mod'\n                                             href='{}index.html'>{}</a>::\",\n                                       root,\n-                                      seg.name));\n+                                      seg.name)?;\n                     }\n                 }\n             }\n             None => {\n                 for seg in &path.segments[..amt] {\n-                    try!(write!(w, \"{}::\", seg.name));\n+                    write!(w, \"{}::\", seg.name)?;\n                 }\n             }\n         }\n     }\n \n     match href(did) {\n         Some((url, shortty, fqp)) => {\n-            try!(write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n-                          shortty, url, fqp.join(\"::\"), last.name));\n+            write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n+                          shortty, url, fqp.join(\"::\"), last.name)?;\n         }\n-        _ => try!(write!(w, \"{}\", last.name)),\n+        _ => write!(w, \"{}\", last.name)?,\n     }\n-    try!(write!(w, \"{}\", last.params));\n+    write!(w, \"{}\", last.params)?;\n     Ok(())\n }\n \n@@ -378,9 +378,9 @@ fn primitive_link(f: &mut fmt::Formatter,\n         Some(&LOCAL_CRATE) => {\n             let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n             let len = if len == 0 {0} else {len - 1};\n-            try!(write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n+            write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n                         repeat(\"../\").take(len).collect::<String>(),\n-                        prim.to_url_str()));\n+                        prim.to_url_str())?;\n             needs_termination = true;\n         }\n         Some(&cnum) => {\n@@ -398,20 +398,20 @@ fn primitive_link(f: &mut fmt::Formatter,\n             };\n             match loc {\n                 Some(root) => {\n-                    try!(write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n+                    write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n                                 root,\n                                 path.0.first().unwrap(),\n-                                prim.to_url_str()));\n+                                prim.to_url_str())?;\n                     needs_termination = true;\n                 }\n                 None => {}\n             }\n         }\n         None => {}\n     }\n-    try!(write!(f, \"{}\", name));\n+    write!(f, \"{}\", name)?;\n     if needs_termination {\n-        try!(write!(f, \"</a>\"));\n+        write!(f, \"</a>\")?;\n     }\n     Ok(())\n }\n@@ -422,8 +422,8 @@ fn tybounds(w: &mut fmt::Formatter,\n     match *typarams {\n         Some(ref params) => {\n             for param in params {\n-                try!(write!(w, \" + \"));\n-                try!(write!(w, \"{}\", *param));\n+                write!(w, \" + \")?;\n+                write!(w, \"{}\", *param)?;\n             }\n             Ok(())\n         }\n@@ -439,7 +439,7 @@ impl fmt::Display for clean::Type {\n             }\n             clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n                 // Paths like T::Output and Self::Output should be rendered with all segments\n-                try!(resolved_path(f, did, path, is_generic));\n+                resolved_path(f, did, path, is_generic)?;\n                 tybounds(f, typarams)\n             }\n             clean::Infer => write!(f, \"_\"),\n@@ -459,25 +459,25 @@ impl fmt::Display for clean::Type {\n                 match &**typs {\n                     [] => primitive_link(f, clean::PrimitiveTuple, \"()\"),\n                     [ref one] => {\n-                        try!(primitive_link(f, clean::PrimitiveTuple, \"(\"));\n-                        try!(write!(f, \"{},\", one));\n+                        primitive_link(f, clean::PrimitiveTuple, \"(\")?;\n+                        write!(f, \"{},\", one)?;\n                         primitive_link(f, clean::PrimitiveTuple, \")\")\n                     }\n                     many => {\n-                        try!(primitive_link(f, clean::PrimitiveTuple, \"(\"));\n-                        try!(write!(f, \"{}\", CommaSep(&many)));\n+                        primitive_link(f, clean::PrimitiveTuple, \"(\")?;\n+                        write!(f, \"{}\", CommaSep(&many))?;\n                         primitive_link(f, clean::PrimitiveTuple, \")\")\n                     }\n                 }\n             }\n             clean::Vector(ref t) => {\n-                try!(primitive_link(f, clean::Slice, &format!(\"[\")));\n-                try!(write!(f, \"{}\", t));\n+                primitive_link(f, clean::Slice, &format!(\"[\"))?;\n+                write!(f, \"{}\", t)?;\n                 primitive_link(f, clean::Slice, &format!(\"]\"))\n             }\n             clean::FixedVector(ref t, ref s) => {\n-                try!(primitive_link(f, clean::PrimitiveType::Array, \"[\"));\n-                try!(write!(f, \"{}\", t));\n+                primitive_link(f, clean::PrimitiveType::Array, \"[\")?;\n+                write!(f, \"{}\", t)?;\n                 primitive_link(f, clean::PrimitiveType::Array,\n                                &format!(\"; {}]\", *s))\n             }\n@@ -489,8 +489,8 @@ impl fmt::Display for clean::Type {\n                                        &format!(\"*{}{}\", RawMutableSpace(m), t))\n                     }\n                     _ => {\n-                        try!(primitive_link(f, clean::PrimitiveType::PrimitiveRawPointer,\n-                                            &format!(\"*{}\", RawMutableSpace(m))));\n+                        primitive_link(f, clean::PrimitiveType::PrimitiveRawPointer,\n+                                            &format!(\"*{}\", RawMutableSpace(m)))?;\n                         write!(f, \"{}\", t)\n                     }\n                 }\n@@ -508,9 +508,9 @@ impl fmt::Display for clean::Type {\n                                 primitive_link(f, clean::Slice,\n                                     &format!(\"&amp;{}{}[{}]\", lt, m, **bt)),\n                             _ => {\n-                                try!(primitive_link(f, clean::Slice,\n-                                    &format!(\"&amp;{}{}[\", lt, m)));\n-                                try!(write!(f, \"{}\", **bt));\n+                                primitive_link(f, clean::Slice,\n+                                    &format!(\"&amp;{}{}[\", lt, m))?;\n+                                write!(f, \"{}\", **bt)?;\n                                 primitive_link(f, clean::Slice, \"]\")\n                             }\n                         }\n@@ -523,9 +523,9 @@ impl fmt::Display for clean::Type {\n             clean::PolyTraitRef(ref bounds) => {\n                 for (i, bound) in bounds.iter().enumerate() {\n                     if i != 0 {\n-                        try!(write!(f, \" + \"));\n+                        write!(f, \" + \")?;\n                     }\n-                    try!(write!(f, \"{}\", *bound));\n+                    write!(f, \"{}\", *bound)?;\n                 }\n                 Ok(())\n             }\n@@ -544,9 +544,9 @@ impl fmt::Display for clean::Type {\n                 ref self_type,\n                 trait_: box clean::ResolvedPath { did, ref typarams, .. },\n             } => {\n-                try!(write!(f, \"{}::\", self_type));\n+                write!(f, \"{}::\", self_type)?;\n                 let path = clean::Path::singleton(name.clone());\n-                try!(resolved_path(f, did, &path, false));\n+                resolved_path(f, did, &path, false)?;\n \n                 // FIXME: `typarams` are not rendered, and this seems bad?\n                 drop(typarams);\n@@ -564,25 +564,25 @@ impl fmt::Display for clean::Type {\n \n impl fmt::Display for clean::Impl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"impl{} \", self.generics));\n+        write!(f, \"impl{} \", self.generics)?;\n         if let Some(ref ty) = self.trait_ {\n-            try!(write!(f, \"{}{} for \",\n+            write!(f, \"{}{} for \",\n                         if self.polarity == Some(clean::ImplPolarity::Negative) { \"!\" } else { \"\" },\n-                        *ty));\n+                        *ty)?;\n         }\n-        try!(write!(f, \"{}{}\", self.for_, WhereClause(&self.generics)));\n+        write!(f, \"{}{}\", self.for_, WhereClause(&self.generics))?;\n         Ok(())\n     }\n }\n \n impl fmt::Display for clean::Arguments {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n-            if i > 0 { try!(write!(f, \", \")); }\n+            if i > 0 { write!(f, \", \")?; }\n             if !input.name.is_empty() {\n-                try!(write!(f, \"{}: \", input.name));\n+                write!(f, \"{}: \", input.name)?;\n             }\n-            try!(write!(f, \"{}\", input.type_));\n+            write!(f, \"{}\", input.type_)?;\n         }\n         Ok(())\n     }\n@@ -678,12 +678,12 @@ impl fmt::Display for clean::Import {\n                 write!(f, \"use {}::*;\", *src)\n             }\n             clean::ImportList(ref src, ref names) => {\n-                try!(write!(f, \"use {}::{{\", *src));\n+                write!(f, \"use {}::{{\", *src)?;\n                 for (i, n) in names.iter().enumerate() {\n                     if i > 0 {\n-                        try!(write!(f, \", \"));\n+                        write!(f, \", \")?;\n                     }\n-                    try!(write!(f, \"{}\", *n));\n+                    write!(f, \"{}\", *n)?;\n                 }\n                 write!(f, \"}};\")\n             }\n@@ -698,9 +698,9 @@ impl fmt::Display for clean::ImportSource {\n             _ => {\n                 for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {\n-                        try!(write!(f, \"::\"))\n+                        write!(f, \"::\")?\n                     }\n-                    try!(write!(f, \"{}\", seg.name));\n+                    write!(f, \"{}\", seg.name)?;\n                 }\n                 Ok(())\n             }\n@@ -713,13 +713,13 @@ impl fmt::Display for clean::ViewListIdent {\n         match self.source {\n             Some(did) => {\n                 let path = clean::Path::singleton(self.name.clone());\n-                try!(resolved_path(f, did, &path, false));\n+                resolved_path(f, did, &path, false)?;\n             }\n-            _ => try!(write!(f, \"{}\", self.name)),\n+            _ => write!(f, \"{}\", self.name)?,\n         }\n \n         if let Some(ref name) = self.rename {\n-            try!(write!(f, \" as {}\", name));\n+            write!(f, \" as {}\", name)?;\n         }\n         Ok(())\n     }"}, {"sha": "778d34c008012b413ed2d689d79f13d5bb185274", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -48,12 +48,12 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n         out: &mut Write) -> io::Result<()> {\n     use syntax::parse::lexer::Reader;\n \n-    try!(write!(out, \"<pre \"));\n+    write!(out, \"<pre \")?;\n     match id {\n-        Some(id) => try!(write!(out, \"id='{}' \", id)),\n+        Some(id) => write!(out, \"id='{}' \", id)?,\n         None => {}\n     }\n-    try!(write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\")));\n+    write!(out, \"class='rust {}'>\\n\", class.unwrap_or(\"\"))?;\n     let mut is_attribute = false;\n     let mut is_macro = false;\n     let mut is_macro_nonterminal = false;\n@@ -66,16 +66,16 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n \n         let klass = match next.tok {\n             token::Whitespace => {\n-                try!(write!(out, \"{}\", Escape(&snip(next.sp))));\n+                write!(out, \"{}\", Escape(&snip(next.sp)))?;\n                 continue\n             },\n             token::Comment => {\n-                try!(write!(out, \"<span class='comment'>{}</span>\",\n-                            Escape(&snip(next.sp))));\n+                write!(out, \"<span class='comment'>{}</span>\",\n+                            Escape(&snip(next.sp)))?;\n                 continue\n             },\n             token::Shebang(s) => {\n-                try!(write!(out, \"{}\", Escape(&s.as_str())));\n+                write!(out, \"{}\", Escape(&s.as_str()))?;\n                 continue\n             },\n             // If this '&' token is directly adjacent to another token, assume\n@@ -114,13 +114,13 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n             // span when we see the ']'.\n             token::Pound => {\n                 is_attribute = true;\n-                try!(write!(out, r\"<span class='attribute'>#\"));\n+                write!(out, r\"<span class='attribute'>#\")?;\n                 continue\n             }\n             token::CloseDelim(token::Bracket) => {\n                 if is_attribute {\n                     is_attribute = false;\n-                    try!(write!(out, \"]</span>\"));\n+                    write!(out, \"]</span>\")?;\n                     continue\n                 } else {\n                     \"\"\n@@ -178,10 +178,10 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n         // stringifying this token\n         let snip = sess.codemap().span_to_snippet(next.sp).unwrap();\n         if klass == \"\" {\n-            try!(write!(out, \"{}\", Escape(&snip)));\n+            write!(out, \"{}\", Escape(&snip))?;\n         } else {\n-            try!(write!(out, \"<span class='{}'>{}</span>\", klass,\n-                          Escape(&snip)));\n+            write!(out, \"<span class='{}'>{}</span>\", klass,\n+                          Escape(&snip))?;\n         }\n     }\n "}, {"sha": "689b8bd93950b44f827dd48f697dbaf69642c479", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 283, "deletions": 283, "changes": 566, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -535,8 +535,8 @@ pub fn run(mut krate: clean::Crate,\n     CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n     CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n \n-    try!(write_shared(&cx, &krate, &*cache, index));\n-    let krate = try!(render_sources(&mut cx, krate));\n+    write_shared(&cx, &krate, &*cache, index)?;\n+    let krate = render_sources(&mut cx, krate)?;\n \n     // And finally render the whole crate's documentation\n     cx.krate(krate)\n@@ -629,53 +629,53 @@ fn write_shared(cx: &Context,\n \n     // Add all the static files. These may already exist, but we just\n     // overwrite them anyway to make sure that they're fresh and up-to-date.\n-    try!(write(cx.dst.join(\"jquery.js\"),\n-               include_bytes!(\"static/jquery-2.1.4.min.js\")));\n-    try!(write(cx.dst.join(\"main.js\"),\n-               include_bytes!(\"static/main.js\")));\n-    try!(write(cx.dst.join(\"playpen.js\"),\n-               include_bytes!(\"static/playpen.js\")));\n-    try!(write(cx.dst.join(\"rustdoc.css\"),\n-               include_bytes!(\"static/rustdoc.css\")));\n-    try!(write(cx.dst.join(\"main.css\"),\n-               include_bytes!(\"static/styles/main.css\")));\n-    try!(write(cx.dst.join(\"normalize.css\"),\n-               include_bytes!(\"static/normalize.css\")));\n-    try!(write(cx.dst.join(\"FiraSans-Regular.woff\"),\n-               include_bytes!(\"static/FiraSans-Regular.woff\")));\n-    try!(write(cx.dst.join(\"FiraSans-Medium.woff\"),\n-               include_bytes!(\"static/FiraSans-Medium.woff\")));\n-    try!(write(cx.dst.join(\"FiraSans-LICENSE.txt\"),\n-               include_bytes!(\"static/FiraSans-LICENSE.txt\")));\n-    try!(write(cx.dst.join(\"Heuristica-Italic.woff\"),\n-               include_bytes!(\"static/Heuristica-Italic.woff\")));\n-    try!(write(cx.dst.join(\"Heuristica-LICENSE.txt\"),\n-               include_bytes!(\"static/Heuristica-LICENSE.txt\")));\n-    try!(write(cx.dst.join(\"SourceSerifPro-Regular.woff\"),\n-               include_bytes!(\"static/SourceSerifPro-Regular.woff\")));\n-    try!(write(cx.dst.join(\"SourceSerifPro-Bold.woff\"),\n-               include_bytes!(\"static/SourceSerifPro-Bold.woff\")));\n-    try!(write(cx.dst.join(\"SourceSerifPro-LICENSE.txt\"),\n-               include_bytes!(\"static/SourceSerifPro-LICENSE.txt\")));\n-    try!(write(cx.dst.join(\"SourceCodePro-Regular.woff\"),\n-               include_bytes!(\"static/SourceCodePro-Regular.woff\")));\n-    try!(write(cx.dst.join(\"SourceCodePro-Semibold.woff\"),\n-               include_bytes!(\"static/SourceCodePro-Semibold.woff\")));\n-    try!(write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"),\n-               include_bytes!(\"static/SourceCodePro-LICENSE.txt\")));\n-    try!(write(cx.dst.join(\"LICENSE-MIT.txt\"),\n-               include_bytes!(\"static/LICENSE-MIT.txt\")));\n-    try!(write(cx.dst.join(\"LICENSE-APACHE.txt\"),\n-               include_bytes!(\"static/LICENSE-APACHE.txt\")));\n-    try!(write(cx.dst.join(\"COPYRIGHT.txt\"),\n-               include_bytes!(\"static/COPYRIGHT.txt\")));\n+    write(cx.dst.join(\"jquery.js\"),\n+               include_bytes!(\"static/jquery-2.1.4.min.js\"))?;\n+    write(cx.dst.join(\"main.js\"),\n+               include_bytes!(\"static/main.js\"))?;\n+    write(cx.dst.join(\"playpen.js\"),\n+               include_bytes!(\"static/playpen.js\"))?;\n+    write(cx.dst.join(\"rustdoc.css\"),\n+               include_bytes!(\"static/rustdoc.css\"))?;\n+    write(cx.dst.join(\"main.css\"),\n+               include_bytes!(\"static/styles/main.css\"))?;\n+    write(cx.dst.join(\"normalize.css\"),\n+               include_bytes!(\"static/normalize.css\"))?;\n+    write(cx.dst.join(\"FiraSans-Regular.woff\"),\n+               include_bytes!(\"static/FiraSans-Regular.woff\"))?;\n+    write(cx.dst.join(\"FiraSans-Medium.woff\"),\n+               include_bytes!(\"static/FiraSans-Medium.woff\"))?;\n+    write(cx.dst.join(\"FiraSans-LICENSE.txt\"),\n+               include_bytes!(\"static/FiraSans-LICENSE.txt\"))?;\n+    write(cx.dst.join(\"Heuristica-Italic.woff\"),\n+               include_bytes!(\"static/Heuristica-Italic.woff\"))?;\n+    write(cx.dst.join(\"Heuristica-LICENSE.txt\"),\n+               include_bytes!(\"static/Heuristica-LICENSE.txt\"))?;\n+    write(cx.dst.join(\"SourceSerifPro-Regular.woff\"),\n+               include_bytes!(\"static/SourceSerifPro-Regular.woff\"))?;\n+    write(cx.dst.join(\"SourceSerifPro-Bold.woff\"),\n+               include_bytes!(\"static/SourceSerifPro-Bold.woff\"))?;\n+    write(cx.dst.join(\"SourceSerifPro-LICENSE.txt\"),\n+               include_bytes!(\"static/SourceSerifPro-LICENSE.txt\"))?;\n+    write(cx.dst.join(\"SourceCodePro-Regular.woff\"),\n+               include_bytes!(\"static/SourceCodePro-Regular.woff\"))?;\n+    write(cx.dst.join(\"SourceCodePro-Semibold.woff\"),\n+               include_bytes!(\"static/SourceCodePro-Semibold.woff\"))?;\n+    write(cx.dst.join(\"SourceCodePro-LICENSE.txt\"),\n+               include_bytes!(\"static/SourceCodePro-LICENSE.txt\"))?;\n+    write(cx.dst.join(\"LICENSE-MIT.txt\"),\n+               include_bytes!(\"static/LICENSE-MIT.txt\"))?;\n+    write(cx.dst.join(\"LICENSE-APACHE.txt\"),\n+               include_bytes!(\"static/LICENSE-APACHE.txt\"))?;\n+    write(cx.dst.join(\"COPYRIGHT.txt\"),\n+               include_bytes!(\"static/COPYRIGHT.txt\"))?;\n \n     fn collect(path: &Path, krate: &str,\n                key: &str) -> io::Result<Vec<String>> {\n         let mut ret = Vec::new();\n         if path.exists() {\n-            for line in BufReader::new(try!(File::open(path))).lines() {\n-                let line = try!(line);\n+            for line in BufReader::new(File::open(path)?).lines() {\n+                let line = line?;\n                 if !line.starts_with(key) {\n                     continue\n                 }\n@@ -885,7 +885,7 @@ impl<'a> SourceCollector<'a> {\n         }\n \n         let mut contents = Vec::new();\n-        try!(File::open(&p).and_then(|mut f| f.read_to_end(&mut contents)));\n+        File::open(&p).and_then(|mut f| f.read_to_end(&mut contents))?;\n \n         let contents = str::from_utf8(&contents).unwrap();\n \n@@ -913,7 +913,7 @@ impl<'a> SourceCollector<'a> {\n         cur.push(&fname[..]);\n         href.push_str(&fname.to_string_lossy());\n \n-        let mut w = BufWriter::new(try!(File::create(&cur)));\n+        let mut w = BufWriter::new(File::create(&cur)?);\n         let title = format!(\"{} -- source\", cur.file_name().unwrap()\n                                                .to_string_lossy());\n         let desc = format!(\"Source to the Rust file `{}`.\", filename);\n@@ -924,9 +924,9 @@ impl<'a> SourceCollector<'a> {\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n         };\n-        try!(layout::render(&mut w, &self.cx.layout,\n-                            &page, &(\"\"), &Source(contents)));\n-        try!(w.flush());\n+        layout::render(&mut w, &self.cx.layout,\n+                            &page, &(\"\"), &Source(contents))?;\n+        w.flush()?;\n         self.cx.local_sources.insert(p, href);\n         Ok(())\n     }\n@@ -1231,9 +1231,9 @@ impl Context {\n         let mut work = vec!((self, item));\n         loop {\n             match work.pop() {\n-                Some((mut cx, item)) => try!(cx.item(item, |cx, item| {\n+                Some((mut cx, item)) => cx.item(item, |cx, item| {\n                     work.push((cx.clone(), item));\n-                })),\n+                })?,\n                 None => break,\n             }\n         }\n@@ -1289,9 +1289,9 @@ impl Context {\n             // write syscall all the time.\n             let mut writer = BufWriter::new(w);\n             if !cx.render_redirect_pages {\n-                try!(layout::render(&mut writer, &cx.layout, &page,\n+                layout::render(&mut writer, &cx.layout, &page,\n                                     &Sidebar{ cx: cx, item: it },\n-                                    &Item{ cx: cx, item: it }));\n+                                    &Item{ cx: cx, item: it })?;\n             } else {\n                 let mut url = repeat(\"../\").take(cx.current.len())\n                                            .collect::<String>();\n@@ -1302,7 +1302,7 @@ impl Context {\n                             url.push_str(\"/\");\n                         }\n                         url.push_str(&item_path(it));\n-                        try!(layout::redirect(&mut writer, &url));\n+                        layout::redirect(&mut writer, &url)?;\n                     }\n                     None => {}\n                 }\n@@ -1492,18 +1492,18 @@ impl<'a> Item<'a> {\n impl<'a> fmt::Display for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Write the breadcrumb trail header for the top\n-        try!(write!(fmt, \"\\n<h1 class='fqn'><span class='in-band'>\"));\n+        write!(fmt, \"\\n<h1 class='fqn'><span class='in-band'>\")?;\n         match self.item.inner {\n             clean::ModuleItem(ref m) => if m.is_crate {\n-                    try!(write!(fmt, \"Crate \"));\n+                    write!(fmt, \"Crate \")?;\n                 } else {\n-                    try!(write!(fmt, \"Module \"));\n+                    write!(fmt, \"Module \")?;\n                 },\n-            clean::FunctionItem(..) => try!(write!(fmt, \"Function \")),\n-            clean::TraitItem(..) => try!(write!(fmt, \"Trait \")),\n-            clean::StructItem(..) => try!(write!(fmt, \"Struct \")),\n-            clean::EnumItem(..) => try!(write!(fmt, \"Enum \")),\n-            clean::PrimitiveItem(..) => try!(write!(fmt, \"Primitive Type \")),\n+            clean::FunctionItem(..) => write!(fmt, \"Function \")?,\n+            clean::TraitItem(..) => write!(fmt, \"Trait \")?,\n+            clean::StructItem(..) => write!(fmt, \"Struct \")?,\n+            clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n+            clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n             _ => {}\n         }\n         let is_primitive = match self.item.inner {\n@@ -1514,23 +1514,23 @@ impl<'a> fmt::Display for Item<'a> {\n             let cur = &self.cx.current;\n             let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n             for (i, component) in cur.iter().enumerate().take(amt) {\n-                try!(write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n+                write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n                             repeat(\"../\").take(cur.len() - i - 1)\n                                          .collect::<String>(),\n-                            component));\n+                            component)?;\n             }\n         }\n-        try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n-                    shortty(self.item), self.item.name.as_ref().unwrap()));\n+        write!(fmt, \"<a class='{}' href=''>{}</a>\",\n+                    shortty(self.item), self.item.name.as_ref().unwrap())?;\n \n-        try!(write!(fmt, \"</span>\")); // in-band\n-        try!(write!(fmt, \"<span class='out-of-band'>\"));\n-        try!(write!(fmt,\n+        write!(fmt, \"</span>\")?; // in-band\n+        write!(fmt, \"<span class='out-of-band'>\")?;\n+        write!(fmt,\n         r##\"<span id='render-detail'>\n             <a id=\"toggle-all-docs\" href=\"javascript:void(0)\" title=\"collapse all docs\">\n                 [<span class='inner'>&#x2212;</span>]\n             </a>\n-        </span>\"##));\n+        </span>\"##)?;\n \n         // Write `src` tag\n         //\n@@ -1540,15 +1540,15 @@ impl<'a> fmt::Display for Item<'a> {\n         // used to find the link to auto-click.\n         if self.cx.include_sources && !is_primitive {\n             if let Some(l) = self.href() {\n-                try!(write!(fmt, \"<a id='src-{}' class='srclink' \\\n+                write!(fmt, \"<a id='src-{}' class='srclink' \\\n                                    href='{}' title='{}'>[src]</a>\",\n-                            self.item.def_id.index.as_usize(), l, \"goto source code\"));\n+                            self.item.def_id.index.as_usize(), l, \"goto source code\")?;\n             }\n         }\n \n-        try!(write!(fmt, \"</span>\")); // out-of-band\n+        write!(fmt, \"</span>\")?; // out-of-band\n \n-        try!(write!(fmt, \"</h1>\\n\"));\n+        write!(fmt, \"</h1>\\n\")?;\n \n         match self.item.inner {\n             clean::ModuleItem(ref m) => {\n@@ -1609,17 +1609,17 @@ fn plain_summary_line(s: Option<&str>) -> String {\n \n fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Result {\n     if let Some(s) = short_stability(item, cx, true) {\n-        try!(write!(w, \"<div class='stability'>{}</div>\", s));\n+        write!(w, \"<div class='stability'>{}</div>\", s)?;\n     }\n     if let Some(s) = item.doc_value() {\n-        try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n+        write!(w, \"<div class='docblock'>{}</div>\", Markdown(s))?;\n     }\n     Ok(())\n }\n \n fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n-    try!(document(w, cx, item));\n+    document(w, cx, item)?;\n \n     let mut indices = (0..items.len()).filter(|i| {\n         !cx.ignore_private_item(&items[*i])\n@@ -1673,7 +1673,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             curty = myty;\n         } else if myty != curty {\n             if curty.is_some() {\n-                try!(write!(w, \"</table>\"));\n+                write!(w, \"</table>\")?;\n             }\n             curty = myty;\n             let (short, name) = match myty.unwrap() {\n@@ -1697,31 +1697,31 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ItemType::AssociatedType  => (\"associated-types\", \"Associated Types\"),\n                 ItemType::AssociatedConst => (\"associated-consts\", \"Associated Constants\"),\n             };\n-            try!(write!(w, \"<h2 id='{id}' class='section-header'>\\\n+            write!(w, \"<h2 id='{id}' class='section-header'>\\\n                            <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n-                           id = derive_id(short.to_owned()), name = name));\n+                           id = derive_id(short.to_owned()), name = name)?;\n         }\n \n         match myitem.inner {\n             clean::ExternCrateItem(ref name, ref src) => {\n                 match *src {\n                     Some(ref src) => {\n-                        try!(write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n+                        write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n                                     VisSpace(myitem.visibility),\n                                     src,\n-                                    name))\n+                                    name)?\n                     }\n                     None => {\n-                        try!(write!(w, \"<tr><td><code>{}extern crate {};\",\n-                                    VisSpace(myitem.visibility), name))\n+                        write!(w, \"<tr><td><code>{}extern crate {};\",\n+                                    VisSpace(myitem.visibility), name)?\n                     }\n                 }\n-                try!(write!(w, \"</code></td></tr>\"));\n+                write!(w, \"</code></td></tr>\")?;\n             }\n \n             clean::ImportItem(ref import) => {\n-                try!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                            VisSpace(myitem.visibility), *import));\n+                write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n+                            VisSpace(myitem.visibility), *import)?;\n             }\n \n             _ => {\n@@ -1732,7 +1732,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                     String::new()\n                 };\n                 let doc_value = myitem.doc_value().unwrap_or(\"\");\n-                try!(write!(w, \"\n+                write!(w, \"\n                     <tr class='{stab} module-item'>\n                         <td><a class='{class}' href='{href}'\n                                title='{title}'>{name}</a></td>\n@@ -1747,7 +1747,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 class = shortty(myitem),\n                 stab = myitem.stability_class(),\n                 href = item_path(myitem),\n-                title = full_path(cx, myitem)));\n+                title = full_path(cx, myitem))?;\n             }\n         }\n     }\n@@ -1816,31 +1816,31 @@ impl<'a> fmt::Display for Initializer<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Initializer(s) = *self;\n         if s.is_empty() { return Ok(()); }\n-        try!(write!(f, \"<code> = </code>\"));\n+        write!(f, \"<code> = </code>\")?;\n         write!(f, \"<code>{}</code>\", s)\n     }\n }\n \n fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                  c: &clean::Constant) -> fmt::Result {\n-    try!(write!(w, \"<pre class='rust const'>{vis}const \\\n+    write!(w, \"<pre class='rust const'>{vis}const \\\n                     {name}: {typ}{init}</pre>\",\n            vis = VisSpace(it.visibility),\n            name = it.name.as_ref().unwrap(),\n            typ = c.type_,\n-           init = Initializer(&c.expr)));\n+           init = Initializer(&c.expr))?;\n     document(w, cx, it)\n }\n \n fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                s: &clean::Static) -> fmt::Result {\n-    try!(write!(w, \"<pre class='rust static'>{vis}static {mutability}\\\n+    write!(w, \"<pre class='rust static'>{vis}static {mutability}\\\n                     {name}: {typ}{init}</pre>\",\n            vis = VisSpace(it.visibility),\n            mutability = MutableSpace(s.mutability),\n            name = it.name.as_ref().unwrap(),\n            typ = s.type_,\n-           init = Initializer(&s.expr)));\n+           init = Initializer(&s.expr))?;\n     document(w, cx, it)\n }\n \n@@ -1850,7 +1850,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         UnstableFeatures::Allow => f.constness,\n         _ => hir::Constness::NotConst\n     };\n-    try!(write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n+    write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n                     {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(it.visibility),\n            constness = ConstnessSpace(vis_constness),\n@@ -1859,8 +1859,8 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            name = it.name.as_ref().unwrap(),\n            generics = f.generics,\n            where_clause = WhereClause(&f.generics),\n-           decl = f.decl));\n-    try!(render_stability_since_raw(w, it.stable_since(), None));\n+           decl = f.decl)?;\n+    render_stability_since_raw(w, it.stable_since(), None)?;\n     document(w, cx, it)\n }\n \n@@ -1879,136 +1879,136 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }\n \n     // Output the trait definition\n-    try!(write!(w, \"<pre class='rust trait'>{}{}trait {}{}{}{} \",\n+    write!(w, \"<pre class='rust trait'>{}{}trait {}{}{}{} \",\n                   VisSpace(it.visibility),\n                   UnsafetySpace(t.unsafety),\n                   it.name.as_ref().unwrap(),\n                   t.generics,\n                   bounds,\n-                  WhereClause(&t.generics)));\n+                  WhereClause(&t.generics))?;\n \n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n     let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n     let provided = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n \n     if t.items.is_empty() {\n-        try!(write!(w, \"{{ }}\"));\n+        write!(w, \"{{ }}\")?;\n     } else {\n-        try!(write!(w, \"{{\\n\"));\n+        write!(w, \"{{\\n\")?;\n         for t in &types {\n-            try!(write!(w, \"    \"));\n-            try!(render_assoc_item(w, t, AssocItemLink::Anchor));\n-            try!(write!(w, \";\\n\"));\n+            write!(w, \"    \")?;\n+            render_assoc_item(w, t, AssocItemLink::Anchor)?;\n+            write!(w, \";\\n\")?;\n         }\n         if !types.is_empty() && !consts.is_empty() {\n-            try!(w.write_str(\"\\n\"));\n+            w.write_str(\"\\n\")?;\n         }\n         for t in &consts {\n-            try!(write!(w, \"    \"));\n-            try!(render_assoc_item(w, t, AssocItemLink::Anchor));\n-            try!(write!(w, \";\\n\"));\n+            write!(w, \"    \")?;\n+            render_assoc_item(w, t, AssocItemLink::Anchor)?;\n+            write!(w, \";\\n\")?;\n         }\n         if !consts.is_empty() && !required.is_empty() {\n-            try!(w.write_str(\"\\n\"));\n+            w.write_str(\"\\n\")?;\n         }\n         for m in &required {\n-            try!(write!(w, \"    \"));\n-            try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n-            try!(write!(w, \";\\n\"));\n+            write!(w, \"    \")?;\n+            render_assoc_item(w, m, AssocItemLink::Anchor)?;\n+            write!(w, \";\\n\")?;\n         }\n         if !required.is_empty() && !provided.is_empty() {\n-            try!(w.write_str(\"\\n\"));\n+            w.write_str(\"\\n\")?;\n         }\n         for m in &provided {\n-            try!(write!(w, \"    \"));\n-            try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n-            try!(write!(w, \" {{ ... }}\\n\"));\n+            write!(w, \"    \")?;\n+            render_assoc_item(w, m, AssocItemLink::Anchor)?;\n+            write!(w, \" {{ ... }}\\n\")?;\n         }\n-        try!(write!(w, \"}}\"));\n+        write!(w, \"}}\")?;\n     }\n-    try!(write!(w, \"</pre>\"));\n+    write!(w, \"</pre>\")?;\n \n     // Trait documentation\n-    try!(document(w, cx, it));\n+    document(w, cx, it)?;\n \n     fn trait_item(w: &mut fmt::Formatter, cx: &Context, m: &clean::Item, t: &clean::Item)\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n         let id = derive_id(format!(\"{}.{}\", shortty(m), name));\n-        try!(write!(w, \"<h3 id='{id}' class='method stab {stab}'><code>\",\n+        write!(w, \"<h3 id='{id}' class='method stab {stab}'><code>\",\n                        id = id,\n-                       stab = m.stability_class()));\n-        try!(render_assoc_item(w, m, AssocItemLink::Anchor));\n-        try!(write!(w, \"</code>\"));\n-        try!(render_stability_since(w, m, t));\n-        try!(write!(w, \"</h3>\"));\n-        try!(document(w, cx, m));\n+                       stab = m.stability_class())?;\n+        render_assoc_item(w, m, AssocItemLink::Anchor)?;\n+        write!(w, \"</code>\")?;\n+        render_stability_since(w, m, t)?;\n+        write!(w, \"</h3>\")?;\n+        document(w, cx, m)?;\n         Ok(())\n     }\n \n     if !types.is_empty() {\n-        try!(write!(w, \"\n+        write!(w, \"\n             <h2 id='associated-types'>Associated Types</h2>\n             <div class='methods'>\n-        \"));\n+        \")?;\n         for t in &types {\n-            try!(trait_item(w, cx, *t, it));\n+            trait_item(w, cx, *t, it)?;\n         }\n-        try!(write!(w, \"</div>\"));\n+        write!(w, \"</div>\")?;\n     }\n \n     if !consts.is_empty() {\n-        try!(write!(w, \"\n+        write!(w, \"\n             <h2 id='associated-const'>Associated Constants</h2>\n             <div class='methods'>\n-        \"));\n+        \")?;\n         for t in &consts {\n-            try!(trait_item(w, cx, *t, it));\n+            trait_item(w, cx, *t, it)?;\n         }\n-        try!(write!(w, \"</div>\"));\n+        write!(w, \"</div>\")?;\n     }\n \n     // Output the documentation for each function individually\n     if !required.is_empty() {\n-        try!(write!(w, \"\n+        write!(w, \"\n             <h2 id='required-methods'>Required Methods</h2>\n             <div class='methods'>\n-        \"));\n+        \")?;\n         for m in &required {\n-            try!(trait_item(w, cx, *m, it));\n+            trait_item(w, cx, *m, it)?;\n         }\n-        try!(write!(w, \"</div>\"));\n+        write!(w, \"</div>\")?;\n     }\n     if !provided.is_empty() {\n-        try!(write!(w, \"\n+        write!(w, \"\n             <h2 id='provided-methods'>Provided Methods</h2>\n             <div class='methods'>\n-        \"));\n+        \")?;\n         for m in &provided {\n-            try!(trait_item(w, cx, *m, it));\n+            trait_item(w, cx, *m, it)?;\n         }\n-        try!(write!(w, \"</div>\"));\n+        write!(w, \"</div>\")?;\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    try!(render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All));\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)?;\n \n     let cache = cache();\n-    try!(write!(w, \"\n+    write!(w, \"\n         <h2 id='implementors'>Implementors</h2>\n         <ul class='item-list' id='implementors-list'>\n-    \"));\n+    \")?;\n     match cache.implementors.get(&it.def_id) {\n         Some(implementors) => {\n             for i in implementors {\n-                try!(writeln!(w, \"<li><code>{}</code></li>\", i.impl_));\n+                writeln!(w, \"<li><code>{}</code></li>\", i.impl_)?;\n             }\n         }\n         None => {}\n     }\n-    try!(write!(w, \"</ul>\"));\n-    try!(write!(w, r#\"<script type=\"text/javascript\" async\n+    write!(w, \"</ul>\")?;\n+    write!(w, r#\"<script type=\"text/javascript\" async\n                               src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n                       </script>\"#,\n                 root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n@@ -2019,17 +2019,17 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                     path[..path.len() - 1].join(\"/\")\n                 },\n                 ty = shortty(it).to_static_str(),\n-                name = *it.name.as_ref().unwrap()));\n+                name = *it.name.as_ref().unwrap())?;\n     Ok(())\n }\n \n fn assoc_const(w: &mut fmt::Formatter, it: &clean::Item,\n                ty: &clean::Type, default: Option<&String>)\n                -> fmt::Result {\n-    try!(write!(w, \"const {}\", it.name.as_ref().unwrap()));\n-    try!(write!(w, \": {}\", ty));\n+    write!(w, \"const {}\", it.name.as_ref().unwrap())?;\n+    write!(w, \": {}\", ty)?;\n     if let Some(default) = default {\n-        try!(write!(w, \" = {}\", default));\n+        write!(w, \" = {}\", default)?;\n     }\n     Ok(())\n }\n@@ -2038,12 +2038,12 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n               bounds: &Vec<clean::TyParamBound>,\n               default: &Option<clean::Type>)\n               -> fmt::Result {\n-    try!(write!(w, \"type {}\", it.name.as_ref().unwrap()));\n+    write!(w, \"type {}\", it.name.as_ref().unwrap())?;\n     if !bounds.is_empty() {\n-        try!(write!(w, \": {}\", TyParamBounds(bounds)))\n+        write!(w, \": {}\", TyParamBounds(bounds))?\n     }\n     if let Some(ref default) = *default {\n-        try!(write!(w, \" = {}\", default));\n+        write!(w, \" = {}\", default)?;\n     }\n     Ok(())\n }\n@@ -2053,8 +2053,8 @@ fn render_stability_since_raw<'a>(w: &mut fmt::Formatter,\n                                   containing_ver: Option<&'a str>) -> fmt::Result {\n     if let Some(v) = ver {\n         if containing_ver != ver && v.len() > 0 {\n-            try!(write!(w, \"<span class=\\\"since\\\">{}</span>\",\n-                        v))\n+            write!(w, \"<span class=\\\"since\\\">{}</span>\",\n+                        v)?\n         }\n     }\n     Ok(())\n@@ -2128,19 +2128,19 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n \n fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n-    try!(write!(w, \"<pre class='rust struct'>\"));\n-    try!(render_attributes(w, it));\n-    try!(render_struct(w,\n+    write!(w, \"<pre class='rust struct'>\")?;\n+    render_attributes(w, it)?;\n+    render_struct(w,\n                        it,\n                        Some(&s.generics),\n                        s.struct_type,\n                        &s.fields,\n                        \"\",\n-                       true));\n-    try!(write!(w, \"</pre>\"));\n-    try!(render_stability_since_raw(w, it.stable_since(), None));\n+                       true)?;\n+    write!(w, \"</pre>\")?;\n+    render_stability_since_raw(w, it.stable_since(), None)?;\n \n-    try!(document(w, cx, it));\n+    document(w, cx, it)?;\n     let mut fields = s.fields.iter().filter(|f| {\n         match f.inner {\n             clean::StructFieldItem(clean::HiddenStructField) => false,\n@@ -2150,83 +2150,83 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }).peekable();\n     if let doctree::Plain = s.struct_type {\n         if fields.peek().is_some() {\n-            try!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n+            write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\")?;\n             for field in fields {\n-                try!(write!(w, \"<tr class='stab {stab}'>\n+                write!(w, \"<tr class='stab {stab}'>\n                                   <td id='structfield.{name}'>\\\n                                     <code>{name}</code></td><td>\",\n                             stab = field.stability_class(),\n-                            name = field.name.as_ref().unwrap()));\n-                try!(document(w, cx, field));\n-                try!(write!(w, \"</td></tr>\"));\n+                            name = field.name.as_ref().unwrap())?;\n+                document(w, cx, field)?;\n+                write!(w, \"</td></tr>\")?;\n             }\n-            try!(write!(w, \"</table>\"));\n+            write!(w, \"</table>\")?;\n         }\n     }\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n-    try!(write!(w, \"<pre class='rust enum'>\"));\n-    try!(render_attributes(w, it));\n-    try!(write!(w, \"{}enum {}{}{}\",\n+    write!(w, \"<pre class='rust enum'>\")?;\n+    render_attributes(w, it)?;\n+    write!(w, \"{}enum {}{}{}\",\n                   VisSpace(it.visibility),\n                   it.name.as_ref().unwrap(),\n                   e.generics,\n-                  WhereClause(&e.generics)));\n+                  WhereClause(&e.generics))?;\n     if e.variants.is_empty() && !e.variants_stripped {\n-        try!(write!(w, \" {{}}\"));\n+        write!(w, \" {{}}\")?;\n     } else {\n-        try!(write!(w, \" {{\\n\"));\n+        write!(w, \" {{\\n\")?;\n         for v in &e.variants {\n-            try!(write!(w, \"    \"));\n+            write!(w, \"    \")?;\n             let name = v.name.as_ref().unwrap();\n             match v.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n-                        clean::CLikeVariant => try!(write!(w, \"{}\", name)),\n+                        clean::CLikeVariant => write!(w, \"{}\", name)?,\n                         clean::TupleVariant(ref tys) => {\n-                            try!(write!(w, \"{}(\", name));\n+                            write!(w, \"{}(\", name)?;\n                             for (i, ty) in tys.iter().enumerate() {\n                                 if i > 0 {\n-                                    try!(write!(w, \", \"))\n+                                    write!(w, \", \")?\n                                 }\n-                                try!(write!(w, \"{}\", *ty));\n+                                write!(w, \"{}\", *ty)?;\n                             }\n-                            try!(write!(w, \")\"));\n+                            write!(w, \")\")?;\n                         }\n                         clean::StructVariant(ref s) => {\n-                            try!(render_struct(w,\n+                            render_struct(w,\n                                                v,\n                                                None,\n                                                s.struct_type,\n                                                &s.fields,\n                                                \"    \",\n-                                               false));\n+                                               false)?;\n                         }\n                     }\n                 }\n                 _ => unreachable!()\n             }\n-            try!(write!(w, \",\\n\"));\n+            write!(w, \",\\n\")?;\n         }\n \n         if e.variants_stripped {\n-            try!(write!(w, \"    // some variants omitted\\n\"));\n+            write!(w, \"    // some variants omitted\\n\")?;\n         }\n-        try!(write!(w, \"}}\"));\n+        write!(w, \"}}\")?;\n     }\n-    try!(write!(w, \"</pre>\"));\n-    try!(render_stability_since_raw(w, it.stable_since(), None));\n+    write!(w, \"</pre>\")?;\n+    render_stability_since_raw(w, it.stable_since(), None)?;\n \n-    try!(document(w, cx, it));\n+    document(w, cx, it)?;\n     if !e.variants.is_empty() {\n-        try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table class='variants_table'>\"));\n+        write!(w, \"<h2 class='variants'>Variants</h2>\\n<table class='variants_table'>\")?;\n         for variant in &e.variants {\n-            try!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n-                          name = variant.name.as_ref().unwrap()));\n-            try!(document(w, cx, variant));\n+            write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n+                          name = variant.name.as_ref().unwrap())?;\n+            document(w, cx, variant)?;\n \n             use clean::{Variant, StructVariant};\n             if let clean::VariantItem( Variant { kind: StructVariant(ref s) } ) = variant.inner {\n@@ -2236,37 +2236,37 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                         _ => false,\n                     }\n                 });\n-                try!(write!(w, \"<h3 class='fields'>Fields</h3>\\n\n-                                  <table>\"));\n+                write!(w, \"<h3 class='fields'>Fields</h3>\\n\n+                                  <table>\")?;\n                 for field in fields {\n-                    try!(write!(w, \"<tr><td \\\n+                    write!(w, \"<tr><td \\\n                                       id='variant.{v}.field.{f}'>\\\n                                       <code>{f}</code></td><td>\",\n                                   v = variant.name.as_ref().unwrap(),\n-                                  f = field.name.as_ref().unwrap()));\n-                    try!(document(w, cx, field));\n-                    try!(write!(w, \"</td></tr>\"));\n+                                  f = field.name.as_ref().unwrap())?;\n+                    document(w, cx, field)?;\n+                    write!(w, \"</td></tr>\")?;\n                 }\n-                try!(write!(w, \"</table>\"));\n+                write!(w, \"</table>\")?;\n             }\n-            try!(write!(w, \"</td><td>\"));\n-            try!(render_stability_since(w, variant, it));\n-            try!(write!(w, \"</td></tr>\"));\n+            write!(w, \"</td><td>\")?;\n+            render_stability_since(w, variant, it)?;\n+            write!(w, \"</td></tr>\")?;\n         }\n-        try!(write!(w, \"</table>\"));\n+        write!(w, \"</table>\")?;\n     }\n-    try!(render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All));\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)?;\n     Ok(())\n }\n \n fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     for attr in &it.attrs {\n         match *attr {\n             clean::Word(ref s) if *s == \"must_use\" => {\n-                try!(write!(w, \"#[{}]\\n\", s));\n+                write!(w, \"#[{}]\\n\", s)?;\n             }\n             clean::NameValue(ref k, ref v) if *k == \"must_use\" => {\n-                try!(write!(w, \"#[{} = \\\"{}\\\"]\\n\", k, v));\n+                write!(w, \"#[{} = \\\"{}\\\"]\\n\", k, v)?;\n             }\n             _ => ()\n         }\n@@ -2280,58 +2280,58 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  fields: &[clean::Item],\n                  tab: &str,\n                  structhead: bool) -> fmt::Result {\n-    try!(write!(w, \"{}{}{}\",\n+    write!(w, \"{}{}{}\",\n                   VisSpace(it.visibility),\n                   if structhead {\"struct \"} else {\"\"},\n-                  it.name.as_ref().unwrap()));\n+                  it.name.as_ref().unwrap())?;\n     if let Some(g) = g {\n-        try!(write!(w, \"{}{}\", *g, WhereClause(g)))\n+        write!(w, \"{}{}\", *g, WhereClause(g))?\n     }\n     match ty {\n         doctree::Plain => {\n-            try!(write!(w, \" {{\\n{}\", tab));\n+            write!(w, \" {{\\n{}\", tab)?;\n             let mut fields_stripped = false;\n             for field in fields {\n                 match field.inner {\n                     clean::StructFieldItem(clean::HiddenStructField) => {\n                         fields_stripped = true;\n                     }\n                     clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n-                        try!(write!(w, \"    {}{}: {},\\n{}\",\n+                        write!(w, \"    {}{}: {},\\n{}\",\n                                       VisSpace(field.visibility),\n                                       field.name.as_ref().unwrap(),\n                                       *ty,\n-                                      tab));\n+                                      tab)?;\n                     }\n                     _ => unreachable!(),\n                 };\n             }\n \n             if fields_stripped {\n-                try!(write!(w, \"    // some fields omitted\\n{}\", tab));\n+                write!(w, \"    // some fields omitted\\n{}\", tab)?;\n             }\n-            try!(write!(w, \"}}\"));\n+            write!(w, \"}}\")?;\n         }\n         doctree::Tuple | doctree::Newtype => {\n-            try!(write!(w, \"(\"));\n+            write!(w, \"(\")?;\n             for (i, field) in fields.iter().enumerate() {\n                 if i > 0 {\n-                    try!(write!(w, \", \"));\n+                    write!(w, \", \")?;\n                 }\n                 match field.inner {\n                     clean::StructFieldItem(clean::HiddenStructField) => {\n-                        try!(write!(w, \"_\"))\n+                        write!(w, \"_\")?\n                     }\n                     clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n-                        try!(write!(w, \"{}{}\", VisSpace(field.visibility), *ty))\n+                        write!(w, \"{}{}\", VisSpace(field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n                 }\n             }\n-            try!(write!(w, \");\"));\n+            write!(w, \");\")?;\n         }\n         doctree::Unit => {\n-            try!(write!(w, \";\"));\n+            write!(w, \";\")?;\n         }\n     }\n     Ok(())\n@@ -2364,18 +2364,18 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n     if !non_trait.is_empty() {\n         let render_header = match what {\n             AssocItemRender::All => {\n-                try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n+                write!(w, \"<h2 id='methods'>Methods</h2>\")?;\n                 true\n             }\n             AssocItemRender::DerefFor { trait_, type_ } => {\n-                try!(write!(w, \"<h2 id='deref-methods'>Methods from \\\n-                                    {}&lt;Target={}&gt;</h2>\", trait_, type_));\n+                write!(w, \"<h2 id='deref-methods'>Methods from \\\n+                                    {}&lt;Target={}&gt;</h2>\", trait_, type_)?;\n                 false\n             }\n         };\n         for i in &non_trait {\n-            try!(render_impl(w, cx, i, AssocItemLink::Anchor, render_header,\n-                             containing_item.stable_since()));\n+            render_impl(w, cx, i, AssocItemLink::Anchor, render_header,\n+                             containing_item.stable_since())?;\n         }\n     }\n     if let AssocItemRender::DerefFor { .. } = what {\n@@ -2391,26 +2391,26 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n             }\n         });\n         if let Some(impl_) = deref_impl {\n-            try!(render_deref_methods(w, cx, impl_, containing_item));\n+            render_deref_methods(w, cx, impl_, containing_item)?;\n         }\n-        try!(write!(w, \"<h2 id='implementations'>Trait \\\n-                          Implementations</h2>\"));\n+        write!(w, \"<h2 id='implementations'>Trait \\\n+                          Implementations</h2>\")?;\n         let (derived, manual): (Vec<_>, Vec<&Impl>) = traits.iter().partition(|i| {\n             i.impl_.derived\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            try!(render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n-                             containing_item.stable_since()));\n+            render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n+                             containing_item.stable_since())?;\n         }\n         if !derived.is_empty() {\n-            try!(write!(w, \"<h3 id='derived_implementations'>\\\n+            write!(w, \"<h3 id='derived_implementations'>\\\n                 Derived Implementations \\\n-            </h3>\"));\n+            </h3>\")?;\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                try!(render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n-                                 containing_item.stable_since()));\n+                render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n+                                 containing_item.stable_since())?;\n             }\n         }\n     }\n@@ -2433,7 +2433,7 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n             if let Some(prim) = target.primitive_type() {\n                 if let Some(c) = cache().primitive_locations.get(&prim) {\n                     let did = DefId { krate: *c, index: prim.to_def_index() };\n-                    try!(render_assoc_items(w, cx, container_item, did, what));\n+                    render_assoc_items(w, cx, container_item, did, what)?;\n                 }\n             }\n             Ok(())\n@@ -2447,12 +2447,12 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLink,\n                render_header: bool, outer_version: Option<&str>) -> fmt::Result {\n     if render_header {\n-        try!(write!(w, \"<h3 class='impl'><code>{}</code>\", i.impl_));\n+        write!(w, \"<h3 class='impl'><code>{}</code>\", i.impl_)?;\n         let since = i.stability.as_ref().map(|s| &s.since[..]);\n-        try!(render_stability_since_raw(w, since, outer_version));\n-        try!(write!(w, \"</h3>\"));\n+        render_stability_since_raw(w, since, outer_version)?;\n+        write!(w, \"</h3>\")?;\n         if let Some(ref dox) = i.dox {\n-            try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox)));\n+            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox))?;\n         }\n     }\n \n@@ -2472,36 +2472,36 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 // Only render when the method is not static or we allow static methods\n                 if !is_static || render_static {\n                     let id = derive_id(format!(\"method.{}\", name));\n-                    try!(write!(w, \"<h4 id='{}' class='{}'>\", id, shortty(item)));\n-                    try!(render_stability_since_raw(w, item.stable_since(), outer_version));\n-                    try!(write!(w, \"<code>\"));\n-                    try!(render_assoc_item(w, item, link));\n-                    try!(write!(w, \"</code></h4>\\n\"));\n+                    write!(w, \"<h4 id='{}' class='{}'>\", id, shortty(item))?;\n+                    render_stability_since_raw(w, item.stable_since(), outer_version)?;\n+                    write!(w, \"<code>\")?;\n+                    render_assoc_item(w, item, link)?;\n+                    write!(w, \"</code></h4>\\n\")?;\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n                 let id = derive_id(format!(\"associatedtype.{}\", name));\n-                try!(write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item)));\n-                try!(write!(w, \"type {} = {}\", name, tydef.type_));\n-                try!(write!(w, \"</code></h4>\\n\"));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item))?;\n+                write!(w, \"type {} = {}\", name, tydef.type_)?;\n+                write!(w, \"</code></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n                 let id = derive_id(format!(\"associatedconstant.{}\", name));\n-                try!(write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item)));\n-                try!(assoc_const(w, item, ty, default.as_ref()));\n-                try!(write!(w, \"</code></h4>\\n\"));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item))?;\n+                assoc_const(w, item, ty, default.as_ref())?;\n+                write!(w, \"</code></h4>\\n\")?;\n             }\n             clean::ConstantItem(ref c) => {\n                 let id = derive_id(format!(\"associatedconstant.{}\", name));\n-                try!(write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item)));\n-                try!(assoc_const(w, item, &c.type_, Some(&c.expr)));\n-                try!(write!(w, \"</code></h4>\\n\"));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item))?;\n+                assoc_const(w, item, &c.type_, Some(&c.expr))?;\n+                write!(w, \"</code></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let id = derive_id(format!(\"associatedtype.{}\", name));\n-                try!(write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item)));\n-                try!(assoc_type(w, item, bounds, default));\n-                try!(write!(w, \"</code></h4>\\n\"));\n+                write!(w, \"<h4 id='{}' class='{}'><code>\", id, shortty(item))?;\n+                assoc_type(w, item, bounds, default)?;\n+                write!(w, \"</code></h4>\\n\")?;\n             }\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n@@ -2514,9 +2514,9 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n     }\n \n-    try!(write!(w, \"<div class='impl-items'>\"));\n+    write!(w, \"<div class='impl-items'>\")?;\n     for trait_item in &i.impl_.items {\n-        try!(doctraititem(w, cx, trait_item, link, render_header, outer_version));\n+        doctraititem(w, cx, trait_item, link, render_header, outer_version)?;\n     }\n \n     fn render_default_items(w: &mut fmt::Formatter,\n@@ -2532,8 +2532,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 continue;\n             }\n \n-            try!(doctraititem(w, cx, trait_item, AssocItemLink::GotoSource(did), render_static,\n-                              outer_version));\n+            doctraititem(w, cx, trait_item, AssocItemLink::GotoSource(did), render_static,\n+                              outer_version)?;\n         }\n         Ok(())\n     }\n@@ -2544,20 +2544,20 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     // for them work.\n     if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n         if let Some(t) = cache().traits.get(&did) {\n-            try!(render_default_items(w, cx, did, t, &i.impl_, render_header, outer_version));\n+            render_default_items(w, cx, did, t, &i.impl_, render_header, outer_version)?;\n         }\n     }\n-    try!(write!(w, \"</div>\"));\n+    write!(w, \"</div>\")?;\n     Ok(())\n }\n \n fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n-    try!(write!(w, \"<pre class='rust typedef'>type {}{}{where_clause} = {type_};</pre>\",\n+    write!(w, \"<pre class='rust typedef'>type {}{}{where_clause} = {type_};</pre>\",\n                   it.name.as_ref().unwrap(),\n                   t.generics,\n                   where_clause = WhereClause(&t.generics),\n-                  type_ = t.type_));\n+                  type_ = t.type_)?;\n \n     document(w, cx, it)\n }\n@@ -2576,34 +2576,34 @@ impl<'a> fmt::Display for Sidebar<'a> {\n         // as much HTML as possible in order to allow non-JS-enabled browsers\n         // to navigate the documentation (though slightly inefficiently).\n \n-        try!(write!(fmt, \"<p class='location'>\"));\n+        write!(fmt, \"<p class='location'>\")?;\n         for (i, name) in cx.current.iter().take(parentlen).enumerate() {\n             if i > 0 {\n-                try!(write!(fmt, \"::<wbr>\"));\n+                write!(fmt, \"::<wbr>\")?;\n             }\n-            try!(write!(fmt, \"<a href='{}index.html'>{}</a>\",\n+            write!(fmt, \"<a href='{}index.html'>{}</a>\",\n                           &cx.root_path[..(cx.current.len() - i - 1) * 3],\n-                          *name));\n+                          *name)?;\n         }\n-        try!(write!(fmt, \"</p>\"));\n+        write!(fmt, \"</p>\")?;\n \n         // sidebar refers to the enclosing module, not this module\n         let relpath = if it.is_mod() { \"../\" } else { \"\" };\n-        try!(write!(fmt,\n+        write!(fmt,\n                     \"<script>window.sidebarCurrent = {{\\\n                         name: '{name}', \\\n                         ty: '{ty}', \\\n                         relpath: '{path}'\\\n                      }};</script>\",\n                     name = it.name.as_ref().map(|x| &x[..]).unwrap_or(\"\"),\n                     ty = shortty(it).to_static_str(),\n-                    path = relpath));\n+                    path = relpath)?;\n         if parentlen == 0 {\n             // there is no sidebar-items.js beyond the crate root path\n             // FIXME maybe dynamic crate loading can be merged here\n         } else {\n-            try!(write!(fmt, \"<script defer src=\\\"{path}sidebar-items.js\\\"></script>\",\n-                        path = relpath));\n+            write!(fmt, \"<script defer src=\\\"{path}sidebar-items.js\\\"></script>\",\n+                        path = relpath)?;\n         }\n \n         Ok(())\n@@ -2620,29 +2620,29 @@ impl<'a> fmt::Display for Source<'a> {\n             cols += 1;\n             tmp /= 10;\n         }\n-        try!(write!(fmt, \"<pre class=\\\"line-numbers\\\">\"));\n+        write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n         for i in 1..lines + 1 {\n-            try!(write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols));\n+            write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n         }\n-        try!(write!(fmt, \"</pre>\"));\n-        try!(write!(fmt, \"{}\", highlight::highlight(s, None, None)));\n+        write!(fmt, \"</pre>\")?;\n+        write!(fmt, \"{}\", highlight::highlight(s, None, None))?;\n         Ok(())\n     }\n }\n \n fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Macro) -> fmt::Result {\n-    try!(w.write_str(&highlight::highlight(&t.source,\n+    w.write_str(&highlight::highlight(&t.source,\n                                           Some(\"macro\"),\n-                                          None)));\n-    try!(render_stability_since_raw(w, it.stable_since(), None));\n+                                          None))?;\n+    render_stability_since_raw(w, it.stable_since(), None)?;\n     document(w, cx, it)\n }\n \n fn item_primitive(w: &mut fmt::Formatter, cx: &Context,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {\n-    try!(document(w, cx, it));\n+    document(w, cx, it)?;\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n "}, {"sha": "b9d41471d41ff00e5ca26bf5dea316305f6d1c92", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -183,15 +183,15 @@ impl fmt::Debug for Toc {\n \n impl fmt::Display for Toc {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"<ul>\"));\n+        write!(fmt, \"<ul>\")?;\n         for entry in &self.entries {\n             // recursively format this table of contents (the\n             // `{children}` is the key).\n-            try!(write!(fmt,\n+            write!(fmt,\n                         \"\\n<li><a href=\\\"#{id}\\\">{num} {name}</a>{children}</li>\",\n                         id = entry.id,\n                         num = entry.sec_number, name = entry.name,\n-                        children = entry.children))\n+                        children = entry.children)?\n         }\n         write!(fmt, \"</ul>\")\n     }"}, {"sha": "9dec4eb32d7fb0e08c4c6ea966182ab8b0cc2fc5", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -332,10 +332,10 @@ fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n     let mut externs = HashMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(2, '=');\n-        let name = try!(parts.next().ok_or(\"--extern value must not be empty\".to_string()));\n-        let location = try!(parts.next()\n+        let name = parts.next().ok_or(\"--extern value must not be empty\".to_string())?;\n+        let location = parts.next()\n                                  .ok_or(\"--extern value must be of the format `foo=bar`\"\n-                                    .to_string()));\n+                                    .to_string())?;\n         let name = name.to_string();\n         externs.entry(name).or_insert(vec![]).push(location.to_string());\n     }\n@@ -502,6 +502,6 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     json.insert(\"crate\".to_string(), crate_json);\n     json.insert(\"plugins\".to_string(), Json::Object(plugins_json));\n \n-    let mut file = try!(File::create(&dst));\n+    let mut file = File::create(&dst)?;\n     write!(&mut file, \"{}\", Json::Object(json))\n }"}, {"sha": "5d652ba2f55bbc72775d16613171bf40c3ffbaa1", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -23,7 +23,7 @@ impl<\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+                s.emit_seq_elt(i, |s| e.encode(s))?;\n             }\n             Ok(())\n         })\n@@ -35,7 +35,7 @@ impl<T:Decodable> Decodable for LinkedList<T> {\n         d.read_seq(|d, len| {\n             let mut list = LinkedList::new();\n             for i in 0..len {\n-                list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+                list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n             }\n             Ok(list)\n         })\n@@ -46,7 +46,7 @@ impl<T: Encodable> Encodable for VecDeque<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+                s.emit_seq_elt(i, |s| e.encode(s))?;\n             }\n             Ok(())\n         })\n@@ -58,7 +58,7 @@ impl<T:Decodable> Decodable for VecDeque<T> {\n         d.read_seq(|d, len| {\n             let mut deque: VecDeque<T> = VecDeque::new();\n             for i in 0..len {\n-                deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+                deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n             }\n             Ok(deque)\n         })\n@@ -73,8 +73,8 @@ impl<\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self {\n-                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n-                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n+                e.emit_map_elt_key(i, |e| key.encode(e))?;\n+                e.emit_map_elt_val(i, |e| val.encode(e))?;\n                 i += 1;\n             }\n             Ok(())\n@@ -90,8 +90,8 @@ impl<\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n             for i in 0..len {\n-                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n-                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d))?;\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d))?;\n                 map.insert(key, val);\n             }\n             Ok(map)\n@@ -106,7 +106,7 @@ impl<\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+                s.emit_seq_elt(i, |s| e.encode(s))?;\n                 i += 1;\n             }\n             Ok(())\n@@ -121,7 +121,7 @@ impl<\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n             for i in 0..len {\n-                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n             }\n             Ok(set)\n         })\n@@ -144,7 +144,7 @@ impl<\n     T: Decodable + CLike\n > Decodable for EnumSet<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<EnumSet<T>, D::Error> {\n-        let bits = try!(d.read_uint());\n+        let bits = d.read_uint()?;\n         let mut set = EnumSet::new();\n         for bit in 0..(mem::size_of::<usize>()*8) {\n             if bits & (1 << bit) != 0 {\n@@ -164,8 +164,8 @@ impl<K, V, S> Encodable for HashMap<K, V, S>\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self {\n-                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n-                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n+                e.emit_map_elt_key(i, |e| key.encode(e))?;\n+                e.emit_map_elt_val(i, |e| val.encode(e))?;\n                 i += 1;\n             }\n             Ok(())\n@@ -183,8 +183,8 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n             let state = Default::default();\n             let mut map = HashMap::with_capacity_and_hasher(len, state);\n             for i in 0..len {\n-                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n-                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d))?;\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d))?;\n                 map.insert(key, val);\n             }\n             Ok(map)\n@@ -200,7 +200,7 @@ impl<T, S> Encodable for HashSet<T, S>\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+                s.emit_seq_elt(i, |s| e.encode(s))?;\n                 i += 1;\n             }\n             Ok(())\n@@ -217,7 +217,7 @@ impl<T, S> Decodable for HashSet<T, S>\n             let state = Default::default();\n             let mut set = HashSet::with_capacity_and_hasher(len, state);\n             for i in 0..len {\n-                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n             }\n             Ok(set)\n         })"}, {"sha": "a7d723515664da6242ebc9a7c3c55c8b77cda021", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 90, "deletions": 90, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -319,7 +319,7 @@ pub fn encode<T: ::Encodable>(object: &T) -> Result<string::String, EncoderError\n     let mut s = String::new();\n     {\n         let mut encoder = Encoder::new(&mut s);\n-        try!(object.encode(&mut encoder));\n+        object.encode(&mut encoder)?;\n     }\n     Ok(s)\n }\n@@ -371,7 +371,7 @@ pub type EncodeResult = Result<(), EncoderError>;\n pub type DecodeResult<T> = Result<T, DecoderError>;\n \n fn escape_str(wr: &mut fmt::Write, v: &str) -> EncodeResult {\n-    try!(wr.write_str(\"\\\"\"));\n+    wr.write_str(\"\\\"\")?;\n \n     let mut start = 0;\n \n@@ -416,19 +416,19 @@ fn escape_str(wr: &mut fmt::Write, v: &str) -> EncodeResult {\n         };\n \n         if start < i {\n-            try!(wr.write_str(&v[start..i]));\n+            wr.write_str(&v[start..i])?;\n         }\n \n-        try!(wr.write_str(escaped));\n+        wr.write_str(escaped)?;\n \n         start = i + 1;\n     }\n \n     if start != v.len() {\n-        try!(wr.write_str(&v[start..]));\n+        wr.write_str(&v[start..])?;\n     }\n \n-    try!(wr.write_str(\"\\\"\"));\n+    wr.write_str(\"\\\"\")?;\n     Ok(())\n }\n \n@@ -442,12 +442,12 @@ fn spaces(wr: &mut fmt::Write, mut n: usize) -> EncodeResult {\n     const BUF: &'static str = \"                \";\n \n     while n >= BUF.len() {\n-        try!(wr.write_str(BUF));\n+        wr.write_str(BUF)?;\n         n -= BUF.len();\n     }\n \n     if n > 0 {\n-        try!(wr.write_str(&BUF[..n]));\n+        wr.write_str(&BUF[..n])?;\n     }\n     Ok(())\n }\n@@ -491,7 +491,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n \n     fn emit_nil(&mut self) -> EncodeResult {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        try!(write!(self.writer, \"null\"));\n+        write!(self.writer, \"null\")?;\n         Ok(())\n     }\n \n@@ -510,9 +510,9 @@ impl<'a> ::Encoder for Encoder<'a> {\n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if v {\n-            try!(write!(self.writer, \"true\"));\n+            write!(self.writer, \"true\")?;\n         } else {\n-            try!(write!(self.writer, \"false\"));\n+            write!(self.writer, \"false\")?;\n         }\n         Ok(())\n     }\n@@ -551,11 +551,11 @@ impl<'a> ::Encoder for Encoder<'a> {\n             escape_str(self.writer, name)\n         } else {\n             if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-            try!(write!(self.writer, \"{{\\\"variant\\\":\"));\n-            try!(escape_str(self.writer, name));\n-            try!(write!(self.writer, \",\\\"fields\\\":[\"));\n-            try!(f(self));\n-            try!(write!(self.writer, \"]}}\"));\n+            write!(self.writer, \"{{\\\"variant\\\":\")?;\n+            escape_str(self.writer, name)?;\n+            write!(self.writer, \",\\\"fields\\\":[\")?;\n+            f(self)?;\n+            write!(self.writer, \"]}}\")?;\n             Ok(())\n         }\n     }\n@@ -565,7 +565,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n-            try!(write!(self.writer, \",\"));\n+            write!(self.writer, \",\")?;\n         }\n         f(self)\n     }\n@@ -595,19 +595,19 @@ impl<'a> ::Encoder for Encoder<'a> {\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        try!(write!(self.writer, \"{{\"));\n-        try!(f(self));\n-        try!(write!(self.writer, \"}}\"));\n+        write!(self.writer, \"{{\")?;\n+        f(self)?;\n+        write!(self.writer, \"}}\")?;\n         Ok(())\n     }\n \n     fn emit_struct_field<F>(&mut self, name: &str, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        if idx != 0 { try!(write!(self.writer, \",\")); }\n-        try!(escape_str(self.writer, name));\n-        try!(write!(self.writer, \":\"));\n+        if idx != 0 { write!(self.writer, \",\")?; }\n+        escape_str(self.writer, name)?;\n+        write!(self.writer, \":\")?;\n         f(self)\n     }\n \n@@ -658,9 +658,9 @@ impl<'a> ::Encoder for Encoder<'a> {\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        try!(write!(self.writer, \"[\"));\n-        try!(f(self));\n-        try!(write!(self.writer, \"]\"));\n+        write!(self.writer, \"[\")?;\n+        f(self)?;\n+        write!(self.writer, \"]\")?;\n         Ok(())\n     }\n \n@@ -669,7 +669,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n-            try!(write!(self.writer, \",\"));\n+            write!(self.writer, \",\")?;\n         }\n         f(self)\n     }\n@@ -678,19 +678,19 @@ impl<'a> ::Encoder for Encoder<'a> {\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        try!(write!(self.writer, \"{{\"));\n-        try!(f(self));\n-        try!(write!(self.writer, \"}}\"));\n+        write!(self.writer, \"{{\")?;\n+        f(self)?;\n+        write!(self.writer, \"}}\")?;\n         Ok(())\n     }\n \n     fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        if idx != 0 { try!(write!(self.writer, \",\")) }\n+        if idx != 0 { write!(self.writer, \",\")? }\n         self.is_emitting_map_key = true;\n-        try!(f(self));\n+        f(self)?;\n         self.is_emitting_map_key = false;\n         Ok(())\n     }\n@@ -699,7 +699,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        try!(write!(self.writer, \":\"));\n+        write!(self.writer, \":\")?;\n         f(self)\n     }\n }\n@@ -739,7 +739,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n \n     fn emit_nil(&mut self) -> EncodeResult {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        try!(write!(self.writer, \"null\"));\n+        write!(self.writer, \"null\")?;\n         Ok(())\n     }\n \n@@ -758,9 +758,9 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if v {\n-            try!(write!(self.writer, \"true\"));\n+            write!(self.writer, \"true\")?;\n         } else {\n-            try!(write!(self.writer, \"false\"));\n+            write!(self.writer, \"false\")?;\n         }\n         Ok(())\n     }\n@@ -797,23 +797,23 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             escape_str(self.writer, name)\n         } else {\n             if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-            try!(write!(self.writer, \"{{\\n\"));\n+            write!(self.writer, \"{{\\n\")?;\n             self.curr_indent += self.indent;\n-            try!(spaces(self.writer, self.curr_indent));\n-            try!(write!(self.writer, \"\\\"variant\\\": \"));\n-            try!(escape_str(self.writer, name));\n-            try!(write!(self.writer, \",\\n\"));\n-            try!(spaces(self.writer, self.curr_indent));\n-            try!(write!(self.writer, \"\\\"fields\\\": [\\n\"));\n+            spaces(self.writer, self.curr_indent)?;\n+            write!(self.writer, \"\\\"variant\\\": \")?;\n+            escape_str(self.writer, name)?;\n+            write!(self.writer, \",\\n\")?;\n+            spaces(self.writer, self.curr_indent)?;\n+            write!(self.writer, \"\\\"fields\\\": [\\n\")?;\n             self.curr_indent += self.indent;\n-            try!(f(self));\n+            f(self)?;\n             self.curr_indent -= self.indent;\n-            try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.curr_indent));\n+            write!(self.writer, \"\\n\")?;\n+            spaces(self.writer, self.curr_indent)?;\n             self.curr_indent -= self.indent;\n-            try!(write!(self.writer, \"]\\n\"));\n-            try!(spaces(self.writer, self.curr_indent));\n-            try!(write!(self.writer, \"}}\"));\n+            write!(self.writer, \"]\\n\")?;\n+            spaces(self.writer, self.curr_indent)?;\n+            write!(self.writer, \"}}\")?;\n             Ok(())\n         }\n     }\n@@ -823,9 +823,9 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n-            try!(write!(self.writer, \",\\n\"));\n+            write!(self.writer, \",\\n\")?;\n         }\n-        try!(spaces(self.writer, self.curr_indent));\n+        spaces(self.writer, self.curr_indent)?;\n         f(self)\n     }\n \n@@ -856,15 +856,15 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if len == 0 {\n-            try!(write!(self.writer, \"{{}}\"));\n+            write!(self.writer, \"{{}}\")?;\n         } else {\n-            try!(write!(self.writer, \"{{\"));\n+            write!(self.writer, \"{{\")?;\n             self.curr_indent += self.indent;\n-            try!(f(self));\n+            f(self)?;\n             self.curr_indent -= self.indent;\n-            try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.curr_indent));\n-            try!(write!(self.writer, \"}}\"));\n+            write!(self.writer, \"\\n\")?;\n+            spaces(self.writer, self.curr_indent)?;\n+            write!(self.writer, \"}}\")?;\n         }\n         Ok(())\n     }\n@@ -874,13 +874,13 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n-            try!(write!(self.writer, \"\\n\"));\n+            write!(self.writer, \"\\n\")?;\n         } else {\n-            try!(write!(self.writer, \",\\n\"));\n+            write!(self.writer, \",\\n\")?;\n         }\n-        try!(spaces(self.writer, self.curr_indent));\n-        try!(escape_str(self.writer, name));\n-        try!(write!(self.writer, \": \"));\n+        spaces(self.writer, self.curr_indent)?;\n+        escape_str(self.writer, name)?;\n+        write!(self.writer, \": \")?;\n         f(self)\n     }\n \n@@ -932,15 +932,15 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if len == 0 {\n-            try!(write!(self.writer, \"[]\"));\n+            write!(self.writer, \"[]\")?;\n         } else {\n-            try!(write!(self.writer, \"[\"));\n+            write!(self.writer, \"[\")?;\n             self.curr_indent += self.indent;\n-            try!(f(self));\n+            f(self)?;\n             self.curr_indent -= self.indent;\n-            try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.curr_indent));\n-            try!(write!(self.writer, \"]\"));\n+            write!(self.writer, \"\\n\")?;\n+            spaces(self.writer, self.curr_indent)?;\n+            write!(self.writer, \"]\")?;\n         }\n         Ok(())\n     }\n@@ -950,11 +950,11 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n-            try!(write!(self.writer, \"\\n\"));\n+            write!(self.writer, \"\\n\")?;\n         } else {\n-            try!(write!(self.writer, \",\\n\"));\n+            write!(self.writer, \",\\n\")?;\n         }\n-        try!(spaces(self.writer, self.curr_indent));\n+        spaces(self.writer, self.curr_indent)?;\n         f(self)\n     }\n \n@@ -963,15 +963,15 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if len == 0 {\n-            try!(write!(self.writer, \"{{}}\"));\n+            write!(self.writer, \"{{}}\")?;\n         } else {\n-            try!(write!(self.writer, \"{{\"));\n+            write!(self.writer, \"{{\")?;\n             self.curr_indent += self.indent;\n-            try!(f(self));\n+            f(self)?;\n             self.curr_indent -= self.indent;\n-            try!(write!(self.writer, \"\\n\"));\n-            try!(spaces(self.writer, self.curr_indent));\n-            try!(write!(self.writer, \"}}\"));\n+            write!(self.writer, \"\\n\")?;\n+            spaces(self.writer, self.curr_indent)?;\n+            write!(self.writer, \"}}\")?;\n         }\n         Ok(())\n     }\n@@ -981,13 +981,13 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n-            try!(write!(self.writer, \"\\n\"));\n+            write!(self.writer, \"\\n\")?;\n         } else {\n-            try!(write!(self.writer, \",\\n\"));\n+            write!(self.writer, \",\\n\")?;\n         }\n-        try!(spaces(self.writer, self.curr_indent));\n+        spaces(self.writer, self.curr_indent)?;\n         self.is_emitting_map_key = true;\n-        try!(f(self));\n+        f(self)?;\n         self.is_emitting_map_key = false;\n         Ok(())\n     }\n@@ -996,7 +996,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-        try!(write!(self.writer, \": \"));\n+        write!(self.writer, \": \")?;\n         f(self)\n     }\n }\n@@ -1695,7 +1695,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n                     'n' => res.push('\\n'),\n                     'r' => res.push('\\r'),\n                     't' => res.push('\\t'),\n-                    'u' => match try!(self.decode_hex_escape()) {\n+                    'u' => match self.decode_hex_escape()? {\n                         0xDC00 ... 0xDFFF => {\n                             return self.error(LoneLeadingSurrogateInHexEscape)\n                         }\n@@ -1708,7 +1708,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n                                 _ => return self.error(UnexpectedEndOfHexEscape),\n                             }\n \n-                            let n2 = try!(self.decode_hex_escape());\n+                            let n2 = self.decode_hex_escape()?;\n                             if n2 < 0xDC00 || n2 > 0xDFFF {\n                                 return self.error(LoneLeadingSurrogateInHexEscape)\n                             }\n@@ -2174,7 +2174,7 @@ impl ::Decoder for Decoder {\n     }\n \n     fn read_char(&mut self) -> DecodeResult<char> {\n-        let s = try!(self.read_str());\n+        let s = self.read_str()?;\n         {\n             let mut it = s.chars();\n             match (it.next(), it.next()) {\n@@ -2264,7 +2264,7 @@ impl ::Decoder for Decoder {\n     fn read_struct<T, F>(&mut self, _name: &str, _len: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        let value = try!(f(self));\n+        let value = f(self)?;\n         self.pop();\n         Ok(value)\n     }\n@@ -2276,7 +2276,7 @@ impl ::Decoder for Decoder {\n                                -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        let mut obj = try!(expect!(self.pop(), Object));\n+        let mut obj = expect!(self.pop(), Object)?;\n \n         let value = match obj.remove(&name.to_string()) {\n             None => {\n@@ -2290,7 +2290,7 @@ impl ::Decoder for Decoder {\n             },\n             Some(json) => {\n                 self.stack.push(json);\n-                try!(f(self))\n+                f(self)?\n             }\n         };\n         self.stack.push(Json::Object(obj));\n@@ -2346,7 +2346,7 @@ impl ::Decoder for Decoder {\n     fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder, usize) -> DecodeResult<T>,\n     {\n-        let array = try!(expect!(self.pop(), Array));\n+        let array = expect!(self.pop(), Array)?;\n         let len = array.len();\n         for v in array.into_iter().rev() {\n             self.stack.push(v);\n@@ -2363,7 +2363,7 @@ impl ::Decoder for Decoder {\n     fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder, usize) -> DecodeResult<T>,\n     {\n-        let obj = try!(expect!(self.pop(), Object));\n+        let obj = expect!(self.pop(), Object)?;\n         let len = obj.len();\n         for (key, value) in obj {\n             self.stack.push(value);"}, {"sha": "0fcab1347d160f1cfc69bab158cbfc9672081872", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -410,13 +410,13 @@ impl<T: ?Sized + Encodable> Encodable for Box<T> {\n \n impl< T: Decodable> Decodable for Box<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> {\n-        Ok(box try!(Decodable::decode(d)))\n+        Ok(box Decodable::decode(d)?)\n     }\n }\n \n impl< T: Decodable> Decodable for Box<[T]> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Box<[T]>, D::Error> {\n-        let v: Vec<T> = try!(Decodable::decode(d));\n+        let v: Vec<T> = Decodable::decode(d)?;\n         Ok(v.into_boxed_slice())\n     }\n }\n@@ -431,15 +431,15 @@ impl<T:Encodable> Encodable for Rc<T> {\n impl<T:Decodable> Decodable for Rc<T> {\n     #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Rc<T>, D::Error> {\n-        Ok(Rc::new(try!(Decodable::decode(d))))\n+        Ok(Rc::new(Decodable::decode(d)?))\n     }\n }\n \n impl<T:Encodable> Encodable for [T] {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)))\n+                s.emit_seq_elt(i, |s| e.encode(s))?\n             }\n             Ok(())\n         })\n@@ -450,7 +450,7 @@ impl<T:Encodable> Encodable for Vec<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n-                try!(s.emit_seq_elt(i, |s| e.encode(s)))\n+                s.emit_seq_elt(i, |s| e.encode(s))?\n             }\n             Ok(())\n         })\n@@ -462,7 +462,7 @@ impl<T:Decodable> Decodable for Vec<T> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in 0..len {\n-                v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+                v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n             }\n             Ok(v)\n         })\n@@ -484,7 +484,7 @@ impl<T:Decodable> Decodable for Option<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Option<T>, D::Error> {\n         d.read_option(|d, b| {\n             if b {\n-                Ok(Some(try!(Decodable::decode(d))))\n+                Ok(Some(Decodable::decode(d)?))\n             } else {\n                 Ok(None)\n             }\n@@ -546,7 +546,7 @@ impl Encodable for path::PathBuf {\n \n impl Decodable for path::PathBuf {\n     fn decode<D: Decoder>(d: &mut D) -> Result<path::PathBuf, D::Error> {\n-        let bytes: String = try!(Decodable::decode(d));\n+        let bytes: String = Decodable::decode(d)?;\n         Ok(path::PathBuf::from(bytes))\n     }\n }\n@@ -559,7 +559,7 @@ impl<T: Encodable + Copy> Encodable for Cell<T> {\n \n impl<T: Decodable + Copy> Decodable for Cell<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Cell<T>, D::Error> {\n-        Ok(Cell::new(try!(Decodable::decode(d))))\n+        Ok(Cell::new(Decodable::decode(d)?))\n     }\n }\n \n@@ -576,7 +576,7 @@ impl<T: Encodable> Encodable for RefCell<T> {\n \n impl<T: Decodable> Decodable for RefCell<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<RefCell<T>, D::Error> {\n-        Ok(RefCell::new(try!(Decodable::decode(d))))\n+        Ok(RefCell::new(Decodable::decode(d)?))\n     }\n }\n \n@@ -588,7 +588,7 @@ impl<T:Encodable> Encodable for Arc<T> {\n \n impl<T:Decodable+Send+Sync> Decodable for Arc<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Arc<T>, D::Error> {\n-        Ok(Arc::new(try!(Decodable::decode(d))))\n+        Ok(Arc::new(Decodable::decode(d)?))\n     }\n }\n \n@@ -607,9 +607,9 @@ impl<S:Encoder> EncoderHelpers for S {\n     {\n         self.emit_seq(v.len(), |this| {\n             for (i, e) in v.iter().enumerate() {\n-                try!(this.emit_seq_elt(i, |this| {\n+                this.emit_seq_elt(i, |this| {\n                     f(this, e)\n-                }));\n+                })?;\n             }\n             Ok(())\n         })\n@@ -629,7 +629,7 @@ impl<D: Decoder> DecoderHelpers for D {\n         self.read_seq(|this, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in 0..len {\n-                v.push(try!(this.read_seq_elt(i, |this| f(this))));\n+                v.push(this.read_seq_elt(i, |this| f(this))?);\n             }\n             Ok(v)\n         })"}, {"sha": "52d7bb128d5a21423af9fe26f080328521d67eb1", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -318,9 +318,9 @@ impl From<CString> for Vec<u8> {\n #[stable(feature = \"cstr_debug\", since = \"1.3.0\")]\n impl fmt::Debug for CStr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"\\\"\"));\n+        write!(f, \"\\\"\")?;\n         for byte in self.to_bytes().iter().flat_map(|&b| ascii::escape_default(b)) {\n-            try!(f.write_char(byte as char));\n+            f.write_char(byte as char)?;\n         }\n         write!(f, \"\\\"\")\n     }"}, {"sha": "d8af73816c9c0e8893ab4864f67f329776c4b4fd", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -305,7 +305,7 @@ impl File {\n     #[unstable(feature = \"file_try_clone\", reason = \"newly added\", issue = \"31405\")]\n     pub fn try_clone(&self) -> io::Result<File> {\n         Ok(File {\n-            inner: try!(self.inner.duplicate())\n+            inner: self.inner.duplicate()?\n         })\n     }\n }\n@@ -565,7 +565,7 @@ impl OpenOptions {\n     }\n \n     fn _open(&self, path: &Path) -> io::Result<File> {\n-        let inner = try!(fs_imp::File::open(path, &self.0));\n+        let inner = fs_imp::File::open(path, &self.0)?;\n         Ok(File { inner: inner })\n     }\n }\n@@ -1440,7 +1440,7 @@ impl DirBuilder {\n     fn create_dir_all(&self, path: &Path) -> io::Result<()> {\n         if path == Path::new(\"\") || path.is_dir() { return Ok(()) }\n         if let Some(p) = path.parent() {\n-            try!(self.create_dir_all(p))\n+            self.create_dir_all(p)?\n         }\n         self.inner.mkdir(path)\n     }"}, {"sha": "632ef3db80451b5ad65e570cfb3e42583dd3204e", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -172,8 +172,8 @@ impl<R: Read> Read for BufReader<R> {\n             return self.inner.read(buf);\n         }\n         let nread = {\n-            let mut rem = try!(self.fill_buf());\n-            try!(rem.read(buf))\n+            let mut rem = self.fill_buf()?;\n+            rem.read(buf)?\n         };\n         self.consume(nread);\n         Ok(nread)\n@@ -186,7 +186,7 @@ impl<R: Read> BufRead for BufReader<R> {\n         // If we've reached the end of our internal buffer then we need to fetch\n         // some more data from the underlying reader.\n         if self.pos == self.cap {\n-            self.cap = try!(self.inner.read(&mut self.buf));\n+            self.cap = self.inner.read(&mut self.buf)?;\n             self.pos = 0;\n         }\n         Ok(&self.buf[self.pos..self.cap])\n@@ -237,16 +237,16 @@ impl<R: Seek> Seek for BufReader<R> {\n             // support seeking by i64::min_value() so we need to handle underflow when subtracting\n             // remainder.\n             if let Some(offset) = n.checked_sub(remainder) {\n-                result = try!(self.inner.seek(SeekFrom::Current(offset)));\n+                result = self.inner.seek(SeekFrom::Current(offset))?;\n             } else {\n                 // seek backwards by our remainder, and then by the offset\n-                try!(self.inner.seek(SeekFrom::Current(-remainder)));\n+                self.inner.seek(SeekFrom::Current(-remainder))?;\n                 self.pos = self.cap; // empty the buffer\n-                result = try!(self.inner.seek(SeekFrom::Current(n)));\n+                result = self.inner.seek(SeekFrom::Current(n))?;\n             }\n         } else {\n             // Seeking with Start/End doesn't care about our buffer length.\n-            result = try!(self.inner.seek(pos));\n+            result = self.inner.seek(pos)?;\n         }\n         self.pos = self.cap; // empty the buffer\n         Ok(result)\n@@ -461,7 +461,7 @@ impl<W: Write> BufWriter<W> {\n impl<W: Write> Write for BufWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         if self.buf.len() + buf.len() > self.buf.capacity() {\n-            try!(self.flush_buf());\n+            self.flush_buf()?;\n         }\n         if buf.len() >= self.buf.capacity() {\n             self.panicked = true;\n@@ -761,7 +761,7 @@ impl<W: Write> Write for LineWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         match memchr::memrchr(b'\\n', buf) {\n             Some(i) => {\n-                let n = try!(self.inner.write(&buf[..i + 1]));\n+                let n = self.inner.write(&buf[..i + 1])?;\n                 if n != i + 1 || self.inner.flush().is_err() {\n                     // Do not return errors on partial writes.\n                     return Ok(n);"}, {"sha": "a1002fdb645fcb6119b9ff0d9b845a2ff3ab52fd", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -213,7 +213,7 @@ impl<T> io::Seek for Cursor<T> where T: AsRef<[u8]> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Read for Cursor<T> where T: AsRef<[u8]> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        let n = try!(Read::read(&mut try!(self.fill_buf()), buf));\n+        let n = Read::read(&mut self.fill_buf()?, buf)?;\n         self.pos += n as u64;\n         Ok(n)\n     }\n@@ -232,7 +232,7 @@ impl<T> BufRead for Cursor<T> where T: AsRef<[u8]> {\n impl<'a> Write for Cursor<&'a mut [u8]> {\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         let pos = cmp::min(self.pos, self.inner.len() as u64);\n-        let amt = try!((&mut self.inner[(pos as usize)..]).write(data));\n+        let amt = (&mut self.inner[(pos as usize)..]).write(data)?;\n         self.pos += amt as u64;\n         Ok(amt)\n     }\n@@ -271,7 +271,7 @@ impl Write for Cursor<Vec<u8>> {\n impl Write for Cursor<Box<[u8]>> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         let pos = cmp::min(self.pos, self.inner.len() as u64);\n-        let amt = try!((&mut self.inner[(pos as usize)..]).write(buf));\n+        let amt = (&mut self.inner[(pos as usize)..]).write(buf)?;\n         self.pos += amt as u64;\n         Ok(amt)\n     }"}, {"sha": "317993815630b93fa698649c422d7ffa4eed0093", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -196,7 +196,7 @@ impl<'a> Write for &'a mut [u8] {\n \n     #[inline]\n     fn write_all(&mut self, data: &[u8]) -> io::Result<()> {\n-        if try!(self.write(data)) == data.len() {\n+        if self.write(data)? == data.len() {\n             Ok(())\n         } else {\n             Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"))"}, {"sha": "28492b30e0f8837a3576c45d90d8c48c8d3a0730", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -1433,7 +1433,7 @@ pub struct Chain<T, U> {\n impl<T: Read, U: Read> Read for Chain<T, U> {\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n         if !self.done_first {\n-            match try!(self.first.read(buf)) {\n+            match self.first.read(buf)? {\n                 0 => { self.done_first = true; }\n                 n => return Ok(n),\n             }\n@@ -1475,7 +1475,7 @@ impl<T: Read> Read for Take<T> {\n         }\n \n         let max = cmp::min(buf.len() as u64, self.limit) as usize;\n-        let n = try!(self.inner.read(&mut buf[..max]));\n+        let n = self.inner.read(&mut buf[..max])?;\n         self.limit -= n as u64;\n         Ok(n)\n     }\n@@ -1484,7 +1484,7 @@ impl<T: Read> Read for Take<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: BufRead> BufRead for Take<T> {\n     fn fill_buf(&mut self) -> Result<&[u8]> {\n-        let buf = try!(self.inner.fill_buf());\n+        let buf = self.inner.fill_buf()?;\n         let cap = cmp::min(buf.len() as u64, self.limit) as usize;\n         Ok(&buf[..cap])\n     }"}, {"sha": "2815c0163d68a86e448dc50f459b0c00663c4e21", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -55,7 +55,7 @@ pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<\n             Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),\n         };\n-        try!(writer.write_all(&buf[..len]));\n+        writer.write_all(&buf[..len])?;\n         written += len as u64;\n     }\n }"}, {"sha": "273a2004fc0f219ad43fa4ac27a306389805af06", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -431,13 +431,13 @@ impl ToSocketAddrs for (Ipv6Addr, u16) {\n }\n \n fn resolve_socket_addr(s: &str, p: u16) -> io::Result<vec::IntoIter<SocketAddr>> {\n-    let ips = try!(lookup_host(s));\n-    let v: Vec<_> = try!(ips.map(|a| {\n+    let ips = lookup_host(s)?;\n+    let v: Vec<_> = ips.map(|a| {\n         a.map(|mut a| {\n             a.set_port(p);\n             a\n         })\n-    }).collect());\n+    }).collect()?;\n     Ok(v.into_iter())\n }\n "}, {"sha": "541daf86c316fcaa5225314a53a3f18a3e4d92da", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -487,16 +487,16 @@ impl fmt::Display for Ipv6Addr {\n                 if zeros_len > 1 {\n                     fn fmt_subslice(segments: &[u16], fmt: &mut fmt::Formatter) -> fmt::Result {\n                         if !segments.is_empty() {\n-                            try!(write!(fmt, \"{:x}\", segments[0]));\n+                            write!(fmt, \"{:x}\", segments[0])?;\n                             for &seg in &segments[1..] {\n-                                try!(write!(fmt, \":{:x}\", seg));\n+                                write!(fmt, \":{:x}\", seg)?;\n                             }\n                         }\n                         Ok(())\n                     }\n \n-                    try!(fmt_subslice(&self.segments()[..zeros_at], fmt));\n-                    try!(fmt.write_str(\"::\"));\n+                    fmt_subslice(&self.segments()[..zeros_at], fmt)?;\n+                    fmt.write_str(\"::\")?;\n                     fmt_subslice(&self.segments()[zeros_at + zeros_len..], fmt)\n                 } else {\n                     let &[a, b, c, d, e, f, g, h] = &self.segments();"}, {"sha": "45070460282710f84e0de8fcd37e179c573f8421", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -74,7 +74,7 @@ fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>\n     where F: FnMut(&SocketAddr) -> io::Result<T>\n {\n     let mut last_err = None;\n-    for addr in try!(addr.to_socket_addrs()) {\n+    for addr in addr.to_socket_addrs()? {\n         match f(&addr) {\n             Ok(l) => return Ok(l),\n             Err(e) => last_err = Some(e),"}, {"sha": "da1cf115e8d5484ad24b736bca11c717f208caa0", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -70,7 +70,7 @@ impl UdpSocket {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A)\n                                      -> io::Result<usize> {\n-        match try!(addr.to_socket_addrs()).next() {\n+        match addr.to_socket_addrs()?.next() {\n             Some(addr) => self.0.send_to(buf, &addr),\n             None => Err(Error::new(ErrorKind::InvalidInput,\n                                    \"no addresses to send data to\")),"}, {"sha": "4462ce24dce048d268c2c966b9e153d6e20bde54", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -315,7 +315,7 @@ pub fn recover<F: FnOnce() -> R + RecoverSafe, R>(f: F) -> Result<R> {\n     let mut result = None;\n     unsafe {\n         let result = &mut result;\n-        try!(unwind::try(move || *result = Some(f())))\n+        unwind::try(move || *result = Some(f()))?\n     }\n     Ok(result.unwrap())\n }"}, {"sha": "e86026758aa0873e7fd04528e3887c9fec424971", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -520,7 +520,7 @@ impl Child {\n             }\n         }\n \n-        let status = try!(self.wait());\n+        let status = self.wait()?;\n         Ok(Output {\n             status: status,\n             stdout: stdout,"}, {"sha": "e0946a5c12a77d25ccd077757a988e870192473e", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -234,7 +234,7 @@ impl<T: ?Sized> Mutex<T> {\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n         unsafe {\n             if self.inner.lock.try_lock() {\n-                Ok(try!(MutexGuard::new(&*self.inner, &self.data)))\n+                Ok(MutexGuard::new(&*self.inner, &self.data)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }\n@@ -353,7 +353,7 @@ impl StaticMutex {\n     pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n         unsafe {\n             if self.lock.try_lock() {\n-                Ok(try!(MutexGuard::new(self, &DUMMY.0)))\n+                Ok(MutexGuard::new(self, &DUMMY.0)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }"}, {"sha": "a37c1c16a45e98b58d2622ca55b80101d2dcdd01", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -205,7 +205,7 @@ impl<T: ?Sized> RwLock<T> {\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n         unsafe {\n             if self.inner.lock.try_read() {\n-                Ok(try!(RwLockReadGuard::new(&*self.inner, &self.data)))\n+                Ok(RwLockReadGuard::new(&*self.inner, &self.data)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }\n@@ -257,7 +257,7 @@ impl<T: ?Sized> RwLock<T> {\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n         unsafe {\n             if self.inner.lock.try_write() {\n-                Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n+                Ok(RwLockWriteGuard::new(&*self.inner, &self.data)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }\n@@ -382,7 +382,7 @@ impl StaticRwLock {\n                     -> TryLockResult<RwLockReadGuard<'static, ()>> {\n         unsafe {\n             if self.lock.try_read(){\n-                Ok(try!(RwLockReadGuard::new(self, &DUMMY.0)))\n+                Ok(RwLockReadGuard::new(self, &DUMMY.0)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }\n@@ -409,7 +409,7 @@ impl StaticRwLock {\n                      -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n         unsafe {\n             if self.lock.try_write() {\n-                Ok(try!(RwLockWriteGuard::new(self, &DUMMY.0)))\n+                Ok(RwLockWriteGuard::new(self, &DUMMY.0)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }"}, {"sha": "b81fb3011c741669b4f9d68d2d5df035c3bae510", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -46,10 +46,10 @@ pub fn log_enabled() -> bool {\n // These output functions should now be used everywhere to ensure consistency.\n pub fn output(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n               s: Option<&[u8]>) -> io::Result<()> {\n-    try!(write!(w, \"  {:2}: {:2$?} - \", idx, addr, HEX_WIDTH));\n+    write!(w, \"  {:2}: {:2$?} - \", idx, addr, HEX_WIDTH)?;\n     match s.and_then(|s| str::from_utf8(s).ok()) {\n-        Some(string) => try!(demangle(w, string)),\n-        None => try!(write!(w, \"<unknown>\")),\n+        Some(string) => demangle(w, string)?,\n+        None => write!(w, \"<unknown>\")?,\n     }\n     w.write_all(&['\\n' as u8])\n }\n@@ -59,9 +59,9 @@ pub fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,\n                        more: bool) -> io::Result<()> {\n     let file = str::from_utf8(file).unwrap_or(\"<unknown>\");\n     // prior line: \"  ##: {:2$} - func\"\n-    try!(write!(w, \"      {:3$}at {}:{}\", \"\", file, line, HEX_WIDTH));\n+    write!(w, \"      {:3$}at {}:{}\", \"\", file, line, HEX_WIDTH)?;\n     if more {\n-        try!(write!(w, \" <... and possibly more>\"));\n+        write!(w, \" <... and possibly more>\")?;\n     }\n     w.write_all(&['\\n' as u8])\n }\n@@ -121,12 +121,12 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n \n     // Alright, let's do this.\n     if !valid {\n-        try!(writer.write_all(s.as_bytes()));\n+        writer.write_all(s.as_bytes())?;\n     } else {\n         let mut first = true;\n         while !inner.is_empty() {\n             if !first {\n-                try!(writer.write_all(b\"::\"));\n+                writer.write_all(b\"::\")?;\n             } else {\n                 first = false;\n             }\n@@ -177,7 +177,7 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n                         None => rest.len(),\n                         Some(i) => i,\n                     };\n-                    try!(writer.write_all(rest[..idx].as_bytes()));\n+                    writer.write_all(rest[..idx].as_bytes())?;\n                     rest = &rest[idx..];\n                 }\n             }"}, {"sha": "db719ccce61e829f22afbe9cec36ef23e2cd0586", "filename": "src/libstd/sys/common/gnu/libbacktrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -172,9 +172,9 @@ pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n                           data_addr as *mut libc::c_void)\n     };\n     if ret == 0 || data.is_null() {\n-        try!(output(w, idx, addr, None));\n+        output(w, idx, addr, None)?;\n     } else {\n-        try!(output(w, idx, addr, Some(unsafe { CStr::from_ptr(data).to_bytes() })));\n+        output(w, idx, addr, Some(unsafe { CStr::from_ptr(data).to_bytes() }))?;\n     }\n \n     // pcinfo may return an arbitrary number of file:line pairs,\n@@ -198,7 +198,7 @@ pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n         for (i, &(file, line)) in fileline_buf[..fileline_count].iter().enumerate() {\n             if file.is_null() { continue; } // just to be sure\n             let file = unsafe { CStr::from_ptr(file).to_bytes() };\n-            try!(output_fileline(w, file, line, i == FILELINE_SIZE - 1));\n+            output_fileline(w, file, line, i == FILELINE_SIZE - 1)?;\n         }\n     }\n "}, {"sha": "07c535bf73038d9adbb11bfb5c49c090391ad044", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -48,8 +48,8 @@ pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,\n                      payload: T) -> io::Result<()> {\n     unsafe {\n         let payload = &payload as *const T as *const c_void;\n-        try!(cvt(c::setsockopt(*sock.as_inner(), opt, val, payload,\n-                               mem::size_of::<T>() as c::socklen_t)));\n+        cvt(c::setsockopt(*sock.as_inner(), opt, val, payload,\n+                               mem::size_of::<T>() as c::socklen_t))?;\n         Ok(())\n     }\n }\n@@ -59,9 +59,9 @@ pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,\n     unsafe {\n         let mut slot: T = mem::zeroed();\n         let mut len = mem::size_of::<T>() as c::socklen_t;\n-        try!(cvt(c::getsockopt(*sock.as_inner(), opt, val,\n+        cvt(c::getsockopt(*sock.as_inner(), opt, val,\n                                &mut slot as *mut _ as *mut _,\n-                               &mut len)));\n+                               &mut len))?;\n         assert_eq!(len as usize, mem::size_of::<T>());\n         Ok(slot)\n     }\n@@ -73,7 +73,7 @@ fn sockname<F>(f: F) -> io::Result<SocketAddr>\n     unsafe {\n         let mut storage: c::sockaddr_storage = mem::zeroed();\n         let mut len = mem::size_of_val(&storage) as c::socklen_t;\n-        try!(cvt(f(&mut storage as *mut _ as *mut _, &mut len)));\n+        cvt(f(&mut storage as *mut _ as *mut _, &mut len))?;\n         sockaddr_to_addr(&storage, len as usize)\n     }\n }\n@@ -143,11 +143,11 @@ impl Drop for LookupHost {\n pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     init();\n \n-    let c_host = try!(CString::new(host));\n+    let c_host = CString::new(host)?;\n     let mut res = ptr::null_mut();\n     unsafe {\n-        try!(cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), ptr::null(),\n-                                   &mut res)));\n+        cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), ptr::null(),\n+                                   &mut res))?;\n         Ok(LookupHost { original: res, cur: res })\n     }\n }\n@@ -164,10 +164,10 @@ impl TcpStream {\n     pub fn connect(addr: &SocketAddr) -> io::Result<TcpStream> {\n         init();\n \n-        let sock = try!(Socket::new(addr, c::SOCK_STREAM));\n+        let sock = Socket::new(addr, c::SOCK_STREAM)?;\n \n         let (addrp, len) = addr.into_inner();\n-        try!(cvt_r(|| unsafe { c::connect(*sock.as_inner(), addrp, len) }));\n+        cvt_r(|| unsafe { c::connect(*sock.as_inner(), addrp, len) })?;\n         Ok(TcpStream { inner: sock })\n     }\n \n@@ -201,12 +201,12 @@ impl TcpStream {\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n-        let ret = try!(cvt(unsafe {\n+        let ret = cvt(unsafe {\n             c::send(*self.inner.as_inner(),\n                     buf.as_ptr() as *const c_void,\n                     len,\n                     0)\n-        }));\n+        })?;\n         Ok(ret as usize)\n     }\n \n@@ -243,7 +243,7 @@ impl TcpStream {\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL));\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL)?;\n         Ok(raw as u32)\n     }\n \n@@ -252,7 +252,7 @@ impl TcpStream {\n     }\n \n     pub fn only_v6(&self) -> io::Result<bool> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY));\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY)?;\n         Ok(raw != 0)\n     }\n \n@@ -301,22 +301,22 @@ impl TcpListener {\n     pub fn bind(addr: &SocketAddr) -> io::Result<TcpListener> {\n         init();\n \n-        let sock = try!(Socket::new(addr, c::SOCK_STREAM));\n+        let sock = Socket::new(addr, c::SOCK_STREAM)?;\n \n         // On platforms with Berkeley-derived sockets, this allows\n         // to quickly rebind a socket, without needing to wait for\n         // the OS to clean up the previous one.\n         if !cfg!(windows) {\n-            try!(setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR,\n-                            1 as c_int));\n+            setsockopt(&sock, c::SOL_SOCKET, c::SO_REUSEADDR,\n+                            1 as c_int)?;\n         }\n \n         // Bind our new socket\n         let (addrp, len) = addr.into_inner();\n-        try!(cvt(unsafe { c::bind(*sock.as_inner(), addrp, len) }));\n+        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len) })?;\n \n         // Start listening\n-        try!(cvt(unsafe { c::listen(*sock.as_inner(), 128) }));\n+        cvt(unsafe { c::listen(*sock.as_inner(), 128) })?;\n         Ok(TcpListener { inner: sock })\n     }\n \n@@ -333,9 +333,9 @@ impl TcpListener {\n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n         let mut storage: c::sockaddr_storage = unsafe { mem::zeroed() };\n         let mut len = mem::size_of_val(&storage) as c::socklen_t;\n-        let sock = try!(self.inner.accept(&mut storage as *mut _ as *mut _,\n-                                          &mut len));\n-        let addr = try!(sockaddr_to_addr(&storage, len as usize));\n+        let sock = self.inner.accept(&mut storage as *mut _ as *mut _,\n+                                          &mut len)?;\n+        let addr = sockaddr_to_addr(&storage, len as usize)?;\n         Ok((TcpStream { inner: sock, }, addr))\n     }\n \n@@ -348,7 +348,7 @@ impl TcpListener {\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL));\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL)?;\n         Ok(raw as u32)\n     }\n \n@@ -357,7 +357,7 @@ impl TcpListener {\n     }\n \n     pub fn only_v6(&self) -> io::Result<bool> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY));\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY)?;\n         Ok(raw != 0)\n     }\n \n@@ -402,9 +402,9 @@ impl UdpSocket {\n     pub fn bind(addr: &SocketAddr) -> io::Result<UdpSocket> {\n         init();\n \n-        let sock = try!(Socket::new(addr, c::SOCK_DGRAM));\n+        let sock = Socket::new(addr, c::SOCK_DGRAM)?;\n         let (addrp, len) = addr.into_inner();\n-        try!(cvt(unsafe { c::bind(*sock.as_inner(), addrp, len) }));\n+        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len) })?;\n         Ok(UdpSocket { inner: sock })\n     }\n \n@@ -423,23 +423,23 @@ impl UdpSocket {\n         let mut addrlen = mem::size_of_val(&storage) as c::socklen_t;\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n \n-        let n = try!(cvt(unsafe {\n+        let n = cvt(unsafe {\n             c::recvfrom(*self.inner.as_inner(),\n                         buf.as_mut_ptr() as *mut c_void,\n                         len, 0,\n                         &mut storage as *mut _ as *mut _, &mut addrlen)\n-        }));\n-        Ok((n as usize, try!(sockaddr_to_addr(&storage, addrlen as usize))))\n+        })?;\n+        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n     }\n \n     pub fn send_to(&self, buf: &[u8], dst: &SocketAddr) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n         let (dstp, dstlen) = dst.into_inner();\n-        let ret = try!(cvt(unsafe {\n+        let ret = cvt(unsafe {\n             c::sendto(*self.inner.as_inner(),\n                       buf.as_ptr() as *const c_void, len,\n                       0, dstp, dstlen)\n-        }));\n+        })?;\n         Ok(ret as usize)\n     }\n \n@@ -468,7 +468,7 @@ impl UdpSocket {\n     }\n \n     pub fn broadcast(&self) -> io::Result<bool> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_BROADCAST));\n+        let raw: c_int = getsockopt(&self.inner, c::SOL_SOCKET, c::SO_BROADCAST)?;\n         Ok(raw != 0)\n     }\n \n@@ -477,7 +477,7 @@ impl UdpSocket {\n     }\n \n     pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP));\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP)?;\n         Ok(raw != 0)\n     }\n \n@@ -486,7 +486,7 @@ impl UdpSocket {\n     }\n \n     pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL));\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL)?;\n         Ok(raw as u32)\n     }\n \n@@ -495,7 +495,7 @@ impl UdpSocket {\n     }\n \n     pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_MULTICAST_LOOP));\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_MULTICAST_LOOP)?;\n         Ok(raw != 0)\n     }\n \n@@ -540,7 +540,7 @@ impl UdpSocket {\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL));\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL)?;\n         Ok(raw as u32)\n     }\n \n@@ -549,7 +549,7 @@ impl UdpSocket {\n     }\n \n     pub fn only_v6(&self) -> io::Result<bool> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY));\n+        let raw: c_int = getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY)?;\n         Ok(raw != 0)\n     }\n \n@@ -567,12 +567,12 @@ impl UdpSocket {\n \n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n-        let ret = try!(cvt(unsafe {\n+        let ret = cvt(unsafe {\n             c::send(*self.inner.as_inner(),\n                     buf.as_ptr() as *const c_void,\n                     len,\n                     0)\n-        }));\n+        })?;\n         Ok(ret as usize)\n     }\n "}, {"sha": "39d4104246732f56d0333aa58aa8ddada075284d", "filename": "src/libstd/sys/common/remutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -99,7 +99,7 @@ impl<T> ReentrantMutex<T> {\n     /// acquired.\n     pub fn try_lock(&self) -> TryLockResult<ReentrantMutexGuard<T>> {\n         if unsafe { self.inner.try_lock() } {\n-            Ok(try!(ReentrantMutexGuard::new(&self)))\n+            Ok(ReentrantMutexGuard::new(&self)?)\n         } else {\n             Err(TryLockError::WouldBlock)\n         }"}, {"sha": "8b79016c2516edb401ee3f4bbade4790430801f9", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -388,32 +388,32 @@ impl fmt::Debug for Wtf8 {\n         fn write_str_escaped(f: &mut fmt::Formatter, s: &str) -> fmt::Result {\n             use fmt::Write;\n             for c in s.chars().flat_map(|c| c.escape_default()) {\n-                try!(f.write_char(c))\n+                f.write_char(c)?\n             }\n             Ok(())\n         }\n \n-        try!(formatter.write_str(\"\\\"\"));\n+        formatter.write_str(\"\\\"\")?;\n         let mut pos = 0;\n         loop {\n             match self.next_surrogate(pos) {\n                 None => break,\n                 Some((surrogate_pos, surrogate)) => {\n-                    try!(write_str_escaped(\n+                    write_str_escaped(\n                         formatter,\n                         unsafe { str::from_utf8_unchecked(\n                             &self.bytes[pos .. surrogate_pos]\n                         )},\n-                    ));\n-                    try!(write!(formatter, \"\\\\u{{{:X}}}\", surrogate));\n+                    )?;\n+                    write!(formatter, \"\\\\u{{{:X}}}\", surrogate)?;\n                     pos = surrogate_pos + 3;\n                 }\n             }\n         }\n-        try!(write_str_escaped(\n+        write_str_escaped(\n             formatter,\n             unsafe { str::from_utf8_unchecked(&self.bytes[pos..]) },\n-        ));\n+        )?;\n         formatter.write_str(\"\\\"\")\n     }\n }"}, {"sha": "de93d3d4e509f18c5b06a4969a56cf1a1fe4c1ac", "filename": "src/libstd/sys/unix/backtrace/tracing/backtrace_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -40,15 +40,15 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     static LOCK: StaticMutex = StaticMutex::new();\n     let _g = LOCK.lock();\n \n-    try!(writeln!(w, \"stack backtrace:\"));\n+    writeln!(w, \"stack backtrace:\")?;\n     // 100 lines should be enough\n     const SIZE: usize = 100;\n     let mut buf: [*mut libc::c_void; SIZE] = unsafe { mem::zeroed() };\n     let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as usize};\n \n     // skipping the first one as it is write itself\n     for i in 1..cnt {\n-        try!(print(w, i as isize, buf[i], buf[i]))\n+        print(w, i as isize, buf[i], buf[i])?\n     }\n     Ok(())\n }"}, {"sha": "8d88091716676ee49c538d4a0a1f336df94ec8a2", "filename": "src/libstd/sys/unix/backtrace/tracing/gcc_s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -33,7 +33,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     static LOCK: StaticMutex = StaticMutex::new();\n     let _g = LOCK.lock();\n \n-    try!(writeln!(w, \"stack backtrace:\"));\n+    writeln!(w, \"stack backtrace:\")?;\n \n     let mut cx = Context { writer: w, last_error: None, idx: 0 };\n     return match unsafe {"}, {"sha": "51ac8cb82d130af0bf2fa066f37893fd13f75399", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -87,7 +87,7 @@ impl SocketAddr {\n         unsafe {\n             let mut addr: libc::sockaddr_un = mem::zeroed();\n             let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n-            try!(cvt(f(&mut addr as *mut _ as *mut _, &mut len)));\n+            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n             SocketAddr::from_parts(addr, len)\n         }\n     }\n@@ -155,9 +155,9 @@ struct AsciiEscaped<'a>(&'a [u8]);\n \n impl<'a> fmt::Display for AsciiEscaped<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"\\\"\"));\n+        write!(fmt, \"\\\"\")?;\n         for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n-            try!(write!(fmt, \"{}\", byte as char));\n+            write!(fmt, \"{}\", byte as char)?;\n         }\n         write!(fmt, \"\\\"\")\n     }\n@@ -200,10 +200,10 @@ impl UnixStream {\n     pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n         fn inner(path: &Path) -> io::Result<UnixStream> {\n             unsafe {\n-                let inner = try!(Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM));\n-                let (addr, len) = try!(sockaddr_un(path));\n+                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+                let (addr, len) = sockaddr_un(path)?;\n \n-                try!(cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len)));\n+                cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n                 Ok(UnixStream(inner))\n             }\n         }\n@@ -214,7 +214,7 @@ impl UnixStream {\n     ///\n     /// Returns two `UnixStream`s which are connected to each other.\n     pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        let (i1, i2) = try!(Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM));\n+        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n         Ok((UnixStream(i1), UnixStream(i2)))\n     }\n \n@@ -395,11 +395,11 @@ impl UnixListener {\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n         fn inner(path: &Path) -> io::Result<UnixListener> {\n             unsafe {\n-                let inner = try!(Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM));\n-                let (addr, len) = try!(sockaddr_un(path));\n+                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+                let (addr, len) = sockaddr_un(path)?;\n \n-                try!(cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len)));\n-                try!(cvt(libc::listen(*inner.as_inner(), 128)));\n+                cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n+                cvt(libc::listen(*inner.as_inner(), 128))?;\n \n                 Ok(UnixListener(inner))\n             }\n@@ -415,8 +415,8 @@ impl UnixListener {\n     pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n         let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n         let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n-        let sock = try!(self.0.accept(&mut storage as *mut _ as *mut _, &mut len));\n-        let addr = try!(SocketAddr::from_parts(storage, len));\n+        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n+        let addr = SocketAddr::from_parts(storage, len)?;\n         Ok((UnixStream(sock), addr))\n     }\n \n@@ -536,10 +536,10 @@ impl UnixDatagram {\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n         fn inner(path: &Path) -> io::Result<UnixDatagram> {\n             unsafe {\n-                let socket = try!(UnixDatagram::unbound());\n-                let (addr, len) = try!(sockaddr_un(path));\n+                let socket = UnixDatagram::unbound()?;\n+                let (addr, len) = sockaddr_un(path)?;\n \n-                try!(cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len)));\n+                cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len))?;\n \n                 Ok(socket)\n             }\n@@ -549,15 +549,15 @@ impl UnixDatagram {\n \n     /// Creates a Unix Datagram socket which is not bound to any address.\n     pub fn unbound() -> io::Result<UnixDatagram> {\n-        let inner = try!(Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM));\n+        let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n         Ok(UnixDatagram(inner))\n     }\n \n     /// Create an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixDatagrams`s which are connected to each other.\n     pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n-        let (i1, i2) = try!(Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM));\n+        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n         Ok((UnixDatagram(i1), UnixDatagram(i2)))\n     }\n \n@@ -568,9 +568,9 @@ impl UnixDatagram {\n     pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n             unsafe {\n-                let (addr, len) = try!(sockaddr_un(path));\n+                let (addr, len) = sockaddr_un(path)?;\n \n-                try!(cvt(libc::connect(*d.0.as_inner(), &addr as *const _ as *const _, len)));\n+                cvt(libc::connect(*d.0.as_inner(), &addr as *const _ as *const _, len))?;\n \n                 Ok(())\n             }\n@@ -605,7 +605,7 @@ impl UnixDatagram {\n     /// whence the data came.\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         let mut count = 0;\n-        let addr = try!(SocketAddr::new(|addr, len| {\n+        let addr = SocketAddr::new(|addr, len| {\n             unsafe {\n                 count = libc::recvfrom(*self.0.as_inner(),\n                                        buf.as_mut_ptr() as *mut _,\n@@ -621,7 +621,7 @@ impl UnixDatagram {\n                     -1\n                 }\n             }\n-        }));\n+        })?;\n \n         Ok((count as usize, addr))\n     }\n@@ -639,14 +639,14 @@ impl UnixDatagram {\n     pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n         fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n             unsafe {\n-                let (addr, len) = try!(sockaddr_un(path));\n+                let (addr, len) = sockaddr_un(path)?;\n \n-                let count = try!(cvt(libc::sendto(*d.0.as_inner(),\n+                let count = cvt(libc::sendto(*d.0.as_inner(),\n                                                   buf.as_ptr() as *const _,\n                                                   buf.len(),\n                                                   0,\n                                                   &addr as *const _ as *const _,\n-                                                  len)));\n+                                                  len))?;\n                 Ok(count as usize)\n             }\n         }"}, {"sha": "94c48be02ffc4b3f3093763b8e8b557100bf6499", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -39,11 +39,11 @@ impl FileDesc {\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let ret = try!(cvt(unsafe {\n+        let ret = cvt(unsafe {\n             libc::read(self.fd,\n                        buf.as_mut_ptr() as *mut c_void,\n                        buf.len() as size_t)\n-        }));\n+        })?;\n         Ok(ret as usize)\n     }\n \n@@ -53,11 +53,11 @@ impl FileDesc {\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        let ret = try!(cvt(unsafe {\n+        let ret = cvt(unsafe {\n             libc::write(self.fd,\n                         buf.as_ptr() as *const c_void,\n                         buf.len() as size_t)\n-        }));\n+        })?;\n         Ok(ret as usize)\n     }\n "}, {"sha": "810a34478c5f90fc7ba11d0582a1dd38c7cc9501", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -418,18 +418,18 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let path = try!(cstr(path));\n+        let path = cstr(path)?;\n         File::open_c(&path, opts)\n     }\n \n     pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n         let flags = libc::O_CLOEXEC |\n-                    try!(opts.get_access_mode()) |\n-                    try!(opts.get_creation_mode()) |\n+                    opts.get_access_mode()? |\n+                    opts.get_creation_mode()? |\n                     (opts.custom_flags as c_int & !libc::O_ACCMODE);\n-        let fd = try!(cvt_r(|| unsafe {\n+        let fd = cvt_r(|| unsafe {\n             open64(path.as_ptr(), flags, opts.mode as c_int)\n-        }));\n+        })?;\n         let fd = FileDesc::new(fd);\n \n         // Currently the standard library supports Linux 2.6.18 which did not\n@@ -448,19 +448,19 @@ impl File {\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n         let mut stat: stat64 = unsafe { mem::zeroed() };\n-        try!(cvt(unsafe {\n+        cvt(unsafe {\n             fstat64(self.0.raw(), &mut stat)\n-        }));\n+        })?;\n         Ok(FileAttr { stat: stat })\n     }\n \n     pub fn fsync(&self) -> io::Result<()> {\n-        try!(cvt_r(|| unsafe { libc::fsync(self.0.raw()) }));\n+        cvt_r(|| unsafe { libc::fsync(self.0.raw()) })?;\n         Ok(())\n     }\n \n     pub fn datasync(&self) -> io::Result<()> {\n-        try!(cvt_r(|| unsafe { os_datasync(self.0.raw()) }));\n+        cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n         return Ok(());\n \n         #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n@@ -476,9 +476,9 @@ impl File {\n     }\n \n     pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        try!(cvt_r(|| unsafe {\n+        cvt_r(|| unsafe {\n             ftruncate64(self.0.raw(), size as off64_t)\n-        }));\n+        })?;\n         Ok(())\n     }\n \n@@ -502,7 +502,7 @@ impl File {\n             SeekFrom::End(off) => (libc::SEEK_END, off as off64_t),\n             SeekFrom::Current(off) => (libc::SEEK_CUR, off as off64_t),\n         };\n-        let n = try!(cvt(unsafe { lseek64(self.0.raw(), pos, whence) }));\n+        let n = cvt(unsafe { lseek64(self.0.raw(), pos, whence) })?;\n         Ok(n as u64)\n     }\n \n@@ -521,8 +521,8 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let p = try!(cstr(p));\n-        try!(cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) }));\n+        let p = cstr(p)?;\n+        cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) })?;\n         Ok(())\n     }\n \n@@ -532,7 +532,7 @@ impl DirBuilder {\n }\n \n fn cstr(path: &Path) -> io::Result<CString> {\n-    Ok(try!(CString::new(path.as_os_str().as_bytes())))\n+    Ok(CString::new(path.as_os_str().as_bytes())?)\n }\n \n impl FromInner<c_int> for File {\n@@ -610,7 +610,7 @@ impl fmt::Debug for File {\n \n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n     let root = Arc::new(p.to_path_buf());\n-    let p = try!(cstr(p));\n+    let p = cstr(p)?;\n     unsafe {\n         let ptr = libc::opendir(p.as_ptr());\n         if ptr.is_null() {\n@@ -622,32 +622,32 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let p = try!(cstr(p));\n-    try!(cvt(unsafe { libc::unlink(p.as_ptr()) }));\n+    let p = cstr(p)?;\n+    cvt(unsafe { libc::unlink(p.as_ptr()) })?;\n     Ok(())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let old = try!(cstr(old));\n-    let new = try!(cstr(new));\n-    try!(cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) }));\n+    let old = cstr(old)?;\n+    let new = cstr(new)?;\n+    cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) })?;\n     Ok(())\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    let p = try!(cstr(p));\n-    try!(cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) }));\n+    let p = cstr(p)?;\n+    cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) })?;\n     Ok(())\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let p = try!(cstr(p));\n-    try!(cvt(unsafe { libc::rmdir(p.as_ptr()) }));\n+    let p = cstr(p)?;\n+    cvt(unsafe { libc::rmdir(p.as_ptr()) })?;\n     Ok(())\n }\n \n pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    let filetype = try!(lstat(path)).file_type();\n+    let filetype = lstat(path)?.file_type();\n     if filetype.is_symlink() {\n         unlink(path)\n     } else {\n@@ -656,27 +656,27 @@ pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n }\n \n fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n-    for child in try!(readdir(path)) {\n-        let child = try!(child);\n-        if try!(child.file_type()).is_dir() {\n-            try!(remove_dir_all_recursive(&child.path()));\n+    for child in readdir(path)? {\n+        let child = child?;\n+        if child.file_type()?.is_dir() {\n+            remove_dir_all_recursive(&child.path())?;\n         } else {\n-            try!(unlink(&child.path()));\n+            unlink(&child.path())?;\n         }\n     }\n     rmdir(path)\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let c_path = try!(cstr(p));\n+    let c_path = cstr(p)?;\n     let p = c_path.as_ptr();\n \n     let mut buf = Vec::with_capacity(256);\n \n     loop {\n-        let buf_read = try!(cvt(unsafe {\n+        let buf_read = cvt(unsafe {\n             libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity() as libc::size_t)\n-        })) as usize;\n+        })? as usize;\n \n         unsafe { buf.set_len(buf_read); }\n \n@@ -694,39 +694,39 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = try!(cstr(src));\n-    let dst = try!(cstr(dst));\n-    try!(cvt(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) }));\n+    let src = cstr(src)?;\n+    let dst = cstr(dst)?;\n+    cvt(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })?;\n     Ok(())\n }\n \n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = try!(cstr(src));\n-    let dst = try!(cstr(dst));\n-    try!(cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) }));\n+    let src = cstr(src)?;\n+    let dst = cstr(dst)?;\n+    cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })?;\n     Ok(())\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let p = try!(cstr(p));\n+    let p = cstr(p)?;\n     let mut stat: stat64 = unsafe { mem::zeroed() };\n-    try!(cvt(unsafe {\n+    cvt(unsafe {\n         stat64(p.as_ptr(), &mut stat as *mut _ as *mut _)\n-    }));\n+    })?;\n     Ok(FileAttr { stat: stat })\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let p = try!(cstr(p));\n+    let p = cstr(p)?;\n     let mut stat: stat64 = unsafe { mem::zeroed() };\n-    try!(cvt(unsafe {\n+    cvt(unsafe {\n         lstat64(p.as_ptr(), &mut stat as *mut _ as *mut _)\n-    }));\n+    })?;\n     Ok(FileAttr { stat: stat })\n }\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n-    let path = try!(CString::new(p.as_os_str().as_bytes()));\n+    let path = CString::new(p.as_os_str().as_bytes())?;\n     let buf;\n     unsafe {\n         let r = libc::realpath(path.as_ptr(), ptr::null_mut());\n@@ -746,11 +746,11 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n                               \"the source path is not an existing regular file\"))\n     }\n \n-    let mut reader = try!(File::open(from));\n-    let mut writer = try!(File::create(to));\n-    let perm = try!(reader.metadata()).permissions();\n+    let mut reader = File::open(from)?;\n+    let mut writer = File::create(to)?;\n+    let perm = reader.metadata()?.permissions();\n \n-    let ret = try!(io::copy(&mut reader, &mut writer));\n-    try!(set_permissions(to, perm));\n+    let ret = io::copy(&mut reader, &mut writer)?;\n+    set_permissions(to, perm)?;\n     Ok(ret)\n }"}, {"sha": "830957a7e59c76943a6f080b28e98473e008b856", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -75,7 +75,7 @@ impl Socket {\n                 }\n             }\n \n-            let fd = try!(cvt(libc::socket(fam, ty, 0)));\n+            let fd = cvt(libc::socket(fam, ty, 0))?;\n             let fd = FileDesc::new(fd);\n             fd.set_cloexec();\n             Ok(Socket(fd))\n@@ -97,7 +97,7 @@ impl Socket {\n                 }\n             }\n \n-            try!(cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr())));\n+            cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr()))?;\n             let a = FileDesc::new(fds[0]);\n             a.set_cloexec();\n             let b = FileDesc::new(fds[1]);\n@@ -128,9 +128,9 @@ impl Socket {\n             }\n         }\n \n-        let fd = try!(cvt_r(|| unsafe {\n+        let fd = cvt_r(|| unsafe {\n             libc::accept(self.0.raw(), storage, len)\n-        }));\n+        })?;\n         let fd = FileDesc::new(fd);\n         fd.set_cloexec();\n         Ok(Socket(fd))\n@@ -185,7 +185,7 @@ impl Socket {\n     }\n \n     pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> {\n-        let raw: libc::timeval = try!(getsockopt(self, libc::SOL_SOCKET, kind));\n+        let raw: libc::timeval = getsockopt(self, libc::SOL_SOCKET, kind)?;\n         if raw.tv_sec == 0 && raw.tv_usec == 0 {\n             Ok(None)\n         } else {\n@@ -201,7 +201,7 @@ impl Socket {\n             Shutdown::Read => libc::SHUT_RD,\n             Shutdown::Both => libc::SHUT_RDWR,\n         };\n-        try!(cvt(unsafe { libc::shutdown(self.0.raw(), how) }));\n+        cvt(unsafe { libc::shutdown(self.0.raw(), how) })?;\n         Ok(())\n     }\n \n@@ -210,7 +210,7 @@ impl Socket {\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n-        let raw: c_int = try!(getsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY));\n+        let raw: c_int = getsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY)?;\n         Ok(raw != 0)\n     }\n \n@@ -220,7 +220,7 @@ impl Socket {\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        let raw: c_int = try!(getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR));\n+        let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n         if raw == 0 {\n             Ok(None)\n         } else {"}, {"sha": "0d77f344914158028f7dea1489e17e51cbc9a943", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -110,7 +110,7 @@ pub fn getcwd() -> io::Result<PathBuf> {\n \n pub fn chdir(p: &path::Path) -> io::Result<()> {\n     let p: &OsStr = p.as_ref();\n-    let p = try!(CString::new(p.as_bytes()));\n+    let p = CString::new(p.as_bytes())?;\n     unsafe {\n         match libc::chdir(p.as_ptr()) == (0 as c_int) {\n             true => Ok(()),\n@@ -180,16 +180,16 @@ pub fn current_exe() -> io::Result<PathBuf> {\n                        libc::KERN_PROC_PATHNAME as c_int,\n                        -1 as c_int];\n         let mut sz: libc::size_t = 0;\n-        try!(cvt(libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n+        cvt(libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                               ptr::null_mut(), &mut sz, ptr::null_mut(),\n-                              0 as libc::size_t)));\n+                              0 as libc::size_t))?;\n         if sz == 0 {\n             return Err(io::Error::last_os_error())\n         }\n         let mut v: Vec<u8> = Vec::with_capacity(sz as usize);\n-        try!(cvt(libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n+        cvt(libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                               v.as_mut_ptr() as *mut libc::c_void, &mut sz,\n-                              ptr::null_mut(), 0 as libc::size_t)));\n+                              ptr::null_mut(), 0 as libc::size_t))?;\n         if sz == 0 {\n             return Err(io::Error::last_os_error());\n         }\n@@ -217,11 +217,11 @@ pub fn current_exe() -> io::Result<PathBuf> {\n                        libc::KERN_PROC_ARGV];\n         let mib = mib.as_mut_ptr();\n         let mut argv_len = 0;\n-        try!(cvt(libc::sysctl(mib, 4, 0 as *mut _, &mut argv_len,\n-                              0 as *mut _, 0)));\n+        cvt(libc::sysctl(mib, 4, 0 as *mut _, &mut argv_len,\n+                              0 as *mut _, 0))?;\n         let mut argv = Vec::<*const libc::c_char>::with_capacity(argv_len as usize);\n-        try!(cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _,\n-                              &mut argv_len, 0 as *mut _, 0)));\n+        cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _,\n+                              &mut argv_len, 0 as *mut _, 0))?;\n         argv.set_len(argv_len as usize);\n         if argv[0].is_null() {\n             return Err(io::Error::new(io::ErrorKind::Other,\n@@ -460,7 +460,7 @@ pub fn env() -> Env {\n pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     // environment variables with a nul byte can't be set, so their value is\n     // always None as well\n-    let k = try!(CString::new(k.as_bytes()));\n+    let k = CString::new(k.as_bytes())?;\n     let _g = ENV_LOCK.lock();\n     Ok(unsafe {\n         let s = libc::getenv(k.as_ptr()) as *const _;\n@@ -473,16 +473,16 @@ pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n }\n \n pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    let k = try!(CString::new(k.as_bytes()));\n-    let v = try!(CString::new(v.as_bytes()));\n+    let k = CString::new(k.as_bytes())?;\n+    let v = CString::new(v.as_bytes())?;\n     let _g = ENV_LOCK.lock();\n     cvt(unsafe {\n         libc::setenv(k.as_ptr(), v.as_ptr(), 1)\n     }).map(|_| ())\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n-    let nbuf = try!(CString::new(n.as_bytes()));\n+    let nbuf = CString::new(n.as_bytes())?;\n     let _g = ENV_LOCK.lock();\n     cvt(unsafe {\n         libc::unsetenv(nbuf.as_ptr())"}, {"sha": "beca2d467536d82a4ea9acf2956b9df7055b3737", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -87,13 +87,13 @@ pub fn read2(p1: AnonPipe,\n     let max = cmp::max(p1.raw(), p2.raw());\n     loop {\n         // wait for either pipe to become readable using `select`\n-        try!(cvt_r(|| unsafe {\n+        cvt_r(|| unsafe {\n             let mut read: libc::fd_set = mem::zeroed();\n             libc::FD_SET(p1.raw(), &mut read);\n             libc::FD_SET(p2.raw(), &mut read);\n             libc::select(max + 1, &mut read, 0 as *mut _, 0 as *mut _,\n                          0 as *mut _)\n-        }));\n+        })?;\n \n         // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n         // EAGAIN. If we hit EOF, then this will happen because the underlying\n@@ -113,11 +113,11 @@ pub fn read2(p1: AnonPipe,\n                 }\n             }\n         };\n-        if try!(read(&p1, v1)) {\n+        if read(&p1, v1)? {\n             p2.set_nonblocking(false);\n             return p2.read_to_end(v2).map(|_| ());\n         }\n-        if try!(read(&p2, v2)) {\n+        if read(&p2, v2)? {\n             p1.set_nonblocking(false);\n             return p1.read_to_end(v1).map(|_| ());\n         }"}, {"sha": "83f76c1cbc5bf09e25930b048eb2346c6427b9f8", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -225,11 +225,11 @@ impl Command {\n                                       \"nul byte found in provided data\"));\n         }\n \n-        let (ours, theirs) = try!(self.setup_io(default, needs_stdin));\n-        let (input, output) = try!(sys::pipe::anon_pipe());\n+        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n+        let (input, output) = sys::pipe::anon_pipe()?;\n \n         let pid = unsafe {\n-            match try!(cvt(libc::fork())) {\n+            match cvt(libc::fork())? {\n                 0 => {\n                     drop(input);\n                     let err = self.do_exec(theirs);\n@@ -343,17 +343,17 @@ impl Command {\n         }\n \n         if let Some(fd) = stdio.stdin.fd() {\n-            try!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO))?;\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            try!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO))?;\n         }\n         if let Some(fd) = stdio.stderr.fd() {\n-            try!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n+            cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;\n         }\n \n         if let Some(u) = self.gid {\n-            try!(cvt(libc::setgid(u as gid_t)));\n+            cvt(libc::setgid(u as gid_t))?;\n         }\n         if let Some(u) = self.uid {\n             // When dropping privileges from root, the `setgroups` call\n@@ -365,7 +365,7 @@ impl Command {\n             // privilege dropping function.\n             let _ = libc::setgroups(0, ptr::null());\n \n-            try!(cvt(libc::setuid(u as uid_t)));\n+            cvt(libc::setuid(u as uid_t))?;\n         }\n         if self.session_leader {\n             // Don't check the error of setsid because it fails if we're the\n@@ -374,7 +374,7 @@ impl Command {\n             let _ = libc::setsid();\n         }\n         if let Some(ref cwd) = self.cwd {\n-            try!(cvt(libc::chdir(cwd.as_ptr())));\n+            cvt(libc::chdir(cwd.as_ptr()))?;\n         }\n         if let Some(ref envp) = self.envp {\n             *sys::os::environ() = envp.as_ptr();\n@@ -390,17 +390,17 @@ impl Command {\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n             let mut set: libc::sigset_t = mem::uninitialized();\n-            try!(cvt(libc::sigemptyset(&mut set)));\n-            try!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n-                                           ptr::null_mut())));\n+            cvt(libc::sigemptyset(&mut set))?;\n+            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+                                           ptr::null_mut()))?;\n             let ret = libc::signal(libc::SIGPIPE, libc::SIG_DFL);\n             if ret == libc::SIG_ERR {\n                 return io::Error::last_os_error()\n             }\n         }\n \n         for callback in self.closures.iter_mut() {\n-            try!(callback());\n+            callback()?;\n         }\n \n         libc::execvp(self.argv[0], self.argv.as_ptr());\n@@ -415,9 +415,9 @@ impl Command {\n         let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n         let stdout = self.stdout.as_ref().unwrap_or(&default);\n         let stderr = self.stderr.as_ref().unwrap_or(&default);\n-        let (their_stdin, our_stdin) = try!(stdin.to_child_stdio(true));\n-        let (their_stdout, our_stdout) = try!(stdout.to_child_stdio(false));\n-        let (their_stderr, our_stderr) = try!(stderr.to_child_stdio(false));\n+        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n+        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n+        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n         let ours = StdioPipes {\n             stdin: our_stdin,\n             stdout: our_stdout,\n@@ -454,14 +454,14 @@ impl Stdio {\n             // overwritten prematurely.\n             Stdio::Fd(ref fd) => {\n                 if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n-                    Ok((ChildStdio::Owned(try!(fd.duplicate())), None))\n+                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n                 } else {\n                     Ok((ChildStdio::Explicit(fd.raw()), None))\n                 }\n             }\n \n             Stdio::MakePipe => {\n-                let (reader, writer) = try!(pipe::anon_pipe());\n+                let (reader, writer) = pipe::anon_pipe()?;\n                 let (ours, theirs) = if readable {\n                     (writer, reader)\n                 } else {\n@@ -477,7 +477,7 @@ impl Stdio {\n                 let path = unsafe {\n                     CStr::from_ptr(\"/dev/null\\0\".as_ptr() as *const _)\n                 };\n-                let fd = try!(File::open_c(&path, &opts));\n+                let fd = File::open_c(&path, &opts)?;\n                 Ok((ChildStdio::Owned(fd.into_fd()), None))\n             }\n         }\n@@ -508,9 +508,9 @@ fn pair_to_key(key: &OsStr, value: &OsStr, saw_nul: &mut bool) -> CString {\n \n impl fmt::Debug for Command {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{:?}\", self.program));\n+        write!(f, \"{:?}\", self.program)?;\n         for arg in &self.args {\n-            try!(write!(f, \" {:?}\", arg));\n+            write!(f, \" {:?}\", arg)?;\n         }\n         Ok(())\n     }\n@@ -589,7 +589,7 @@ impl Process {\n             return Ok(status)\n         }\n         let mut status = 0 as c_int;\n-        try!(cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) }));\n+        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n         self.status = Some(ExitStatus(status));\n         Ok(ExitStatus(status))\n     }"}, {"sha": "92c3bf8829adf272367066f1148a8afde4bd291a", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -138,7 +138,7 @@ mod imp {\n                 return Ok(OsRng { inner: OsGetrandomRng });\n             }\n \n-            let reader = try!(File::open(\"/dev/urandom\"));\n+            let reader = File::open(\"/dev/urandom\")?;\n             let reader_rng = ReaderRng::new(reader);\n \n             Ok(OsRng { inner: OsReaderRng(reader_rng) })"}, {"sha": "0e10a8d8e8dd2619b6da4010a9a5816e722b0d14", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -131,7 +131,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n         // Start from -1 to avoid printing this stack frame, which will\n         // always be exactly the same.\n         let mut i = -1;\n-        try!(write!(w, \"stack backtrace:\\n\"));\n+        write!(w, \"stack backtrace:\\n\")?;\n         while StackWalk64(image, process, thread, &mut frame, &mut context,\n                           ptr::null_mut(),\n                           ptr::null_mut(),\n@@ -144,7 +144,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n             i += 1;\n \n             if i >= 0 {\n-                try!(printing::print(w, i, addr - 1, process, &dbghelp));\n+                printing::print(w, i, addr - 1, process, &dbghelp)?;\n             }\n         }\n "}, {"sha": "dde13ec8364b63533fd4421046f49a485cea1c06", "filename": "src/libstd/sys/windows/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fdynamic_lib.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -36,7 +36,7 @@ impl DynamicLibrary {\n     }\n \n     pub fn symbol(&self, symbol: &str) -> io::Result<usize> {\n-        let symbol = try!(CString::new(symbol));\n+        let symbol = CString::new(symbol)?;\n         unsafe {\n             match c::GetProcAddress(self.handle, symbol.as_ptr()) as usize {\n                 0 => Err(io::Error::last_os_error()),"}, {"sha": "46397e1471853568a7121ea45f61432b3bbb3b1d", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -248,13 +248,13 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let path = try!(to_u16s(path));\n+        let path = to_u16s(path)?;\n         let handle = unsafe {\n             c::CreateFileW(path.as_ptr(),\n-                           try!(opts.get_access_mode()),\n+                           opts.get_access_mode()?,\n                            opts.share_mode,\n                            opts.security_attributes as *mut _,\n-                           try!(opts.get_creation_mode()),\n+                           opts.get_creation_mode()?,\n                            opts.get_flags_and_attributes(),\n                            ptr::null_mut())\n         };\n@@ -266,7 +266,7 @@ impl File {\n     }\n \n     pub fn fsync(&self) -> io::Result<()> {\n-        try!(cvt(unsafe { c::FlushFileBuffers(self.handle.raw()) }));\n+        cvt(unsafe { c::FlushFileBuffers(self.handle.raw()) })?;\n         Ok(())\n     }\n \n@@ -277,20 +277,20 @@ impl File {\n             EndOfFile: size as c::LARGE_INTEGER,\n         };\n         let size = mem::size_of_val(&info);\n-        try!(cvt(unsafe {\n+        cvt(unsafe {\n             c::SetFileInformationByHandle(self.handle.raw(),\n                                           c::FileEndOfFileInfo,\n                                           &mut info as *mut _ as *mut _,\n                                           size as c::DWORD)\n-        }));\n+        })?;\n         Ok(())\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n         unsafe {\n             let mut info: c::BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n-            try!(cvt(c::GetFileInformationByHandle(self.handle.raw(),\n-                                                   &mut info)));\n+            cvt(c::GetFileInformationByHandle(self.handle.raw(),\n+                                                   &mut info))?;\n             let mut attr = FileAttr {\n                 attributes: info.dwFileAttributes,\n                 creation_time: info.ftCreationTime,\n@@ -331,16 +331,16 @@ impl File {\n         };\n         let pos = pos as c::LARGE_INTEGER;\n         let mut newpos = 0;\n-        try!(cvt(unsafe {\n+        cvt(unsafe {\n             c::SetFilePointerEx(self.handle.raw(), pos,\n                                 &mut newpos, whence)\n-        }));\n+        })?;\n         Ok(newpos as u64)\n     }\n \n     pub fn duplicate(&self) -> io::Result<File> {\n         Ok(File {\n-            handle: try!(self.handle.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)),\n+            handle: self.handle.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)?,\n         })\n     }\n \n@@ -353,7 +353,7 @@ impl File {\n                          -> io::Result<(c::DWORD, &'a c::REPARSE_DATA_BUFFER)> {\n         unsafe {\n             let mut bytes = 0;\n-            try!(cvt({\n+            cvt({\n                 c::DeviceIoControl(self.handle.raw(),\n                                    c::FSCTL_GET_REPARSE_POINT,\n                                    ptr::null_mut(),\n@@ -362,14 +362,14 @@ impl File {\n                                    space.len() as c::DWORD,\n                                    &mut bytes,\n                                    ptr::null_mut())\n-            }));\n+            })?;\n             Ok((bytes, &*(space.as_ptr() as *const c::REPARSE_DATA_BUFFER)))\n         }\n     }\n \n     fn readlink(&self) -> io::Result<PathBuf> {\n         let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-        let (_bytes, buf) = try!(self.reparse_point(&mut space));\n+        let (_bytes, buf) = self.reparse_point(&mut space)?;\n         unsafe {\n             let (path_buffer, subst_off, subst_len, relative) = match buf.ReparseTag {\n                 c::IO_REPARSE_TAG_SYMLINK => {\n@@ -516,18 +516,18 @@ impl DirBuilder {\n     pub fn new() -> DirBuilder { DirBuilder }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let p = try!(to_u16s(p));\n-        try!(cvt(unsafe {\n+        let p = to_u16s(p)?;\n+        cvt(unsafe {\n             c::CreateDirectoryW(p.as_ptr(), ptr::null_mut())\n-        }));\n+        })?;\n         Ok(())\n     }\n }\n \n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n     let root = p.to_path_buf();\n     let star = p.join(\"*\");\n-    let path = try!(to_u16s(&star));\n+    let path = to_u16s(&star)?;\n \n     unsafe {\n         let mut wfd = mem::zeroed();\n@@ -545,28 +545,28 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let p_u16s = try!(to_u16s(p));\n-    try!(cvt(unsafe { c::DeleteFileW(p_u16s.as_ptr()) }));\n+    let p_u16s = to_u16s(p)?;\n+    cvt(unsafe { c::DeleteFileW(p_u16s.as_ptr()) })?;\n     Ok(())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let old = try!(to_u16s(old));\n-    let new = try!(to_u16s(new));\n-    try!(cvt(unsafe {\n+    let old = to_u16s(old)?;\n+    let new = to_u16s(new)?;\n+    cvt(unsafe {\n         c::MoveFileExW(old.as_ptr(), new.as_ptr(), c::MOVEFILE_REPLACE_EXISTING)\n-    }));\n+    })?;\n     Ok(())\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let p = try!(to_u16s(p));\n-    try!(cvt(unsafe { c::RemoveDirectoryW(p.as_ptr()) }));\n+    let p = to_u16s(p)?;\n+    cvt(unsafe { c::RemoveDirectoryW(p.as_ptr()) })?;\n     Ok(())\n }\n \n pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    let filetype = try!(lstat(path)).file_type();\n+    let filetype = lstat(path)?.file_type();\n     if filetype.is_symlink() {\n         // On Windows symlinks to files and directories are removed differently.\n         // rmdir only deletes dir symlinks and junctions, not file symlinks.\n@@ -577,15 +577,15 @@ pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n }\n \n fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n-    for child in try!(readdir(path)) {\n-        let child = try!(child);\n-        let child_type = try!(child.file_type());\n+    for child in readdir(path)? {\n+        let child = child?;\n+        let child_type = child.file_type()?;\n         if child_type.is_dir() {\n-            try!(remove_dir_all_recursive(&child.path()));\n+            remove_dir_all_recursive(&child.path())?;\n         } else if child_type.is_symlink_dir() {\n-            try!(rmdir(&child.path()));\n+            rmdir(&child.path())?;\n         } else {\n-            try!(unlink(&child.path()));\n+            unlink(&child.path())?;\n         }\n     }\n     rmdir(path)\n@@ -599,7 +599,7 @@ pub fn readlink(path: &Path) -> io::Result<PathBuf> {\n     opts.access_mode(0);\n     opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT |\n                       c::FILE_FLAG_BACKUP_SEMANTICS);\n-    let file = try!(File::open(&path, &opts));\n+    let file = File::open(&path, &opts)?;\n     file.readlink()\n }\n \n@@ -608,21 +608,21 @@ pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n }\n \n pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n-    let src = try!(to_u16s(src));\n-    let dst = try!(to_u16s(dst));\n+    let src = to_u16s(src)?;\n+    let dst = to_u16s(dst)?;\n     let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };\n-    try!(cvt(unsafe {\n+    cvt(unsafe {\n         c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as c::BOOL\n-    }));\n+    })?;\n     Ok(())\n }\n \n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = try!(to_u16s(src));\n-    let dst = try!(to_u16s(dst));\n-    try!(cvt(unsafe {\n+    let src = to_u16s(src)?;\n+    let dst = to_u16s(dst)?;\n+    cvt(unsafe {\n         c::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::null_mut())\n-    }));\n+    })?;\n     Ok(())\n }\n \n@@ -632,7 +632,7 @@ pub fn stat(path: &Path) -> io::Result<FileAttr> {\n     opts.access_mode(0);\n     // This flag is so we can open directories too\n     opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n-    let file = try!(File::open(path, &opts));\n+    let file = File::open(path, &opts)?;\n     file.file_attr()\n }\n \n@@ -641,14 +641,14 @@ pub fn lstat(path: &Path) -> io::Result<FileAttr> {\n     // No read or write permissions are necessary\n     opts.access_mode(0);\n     opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | c::FILE_FLAG_OPEN_REPARSE_POINT);\n-    let file = try!(File::open(path, &opts));\n+    let file = File::open(path, &opts)?;\n     file.file_attr()\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    let p = try!(to_u16s(p));\n+    let p = to_u16s(p)?;\n     unsafe {\n-        try!(cvt(c::SetFileAttributesW(p.as_ptr(), perm.attrs)));\n+        cvt(c::SetFileAttributesW(p.as_ptr(), perm.attrs))?;\n         Ok(())\n     }\n }\n@@ -668,7 +668,7 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     opts.access_mode(0);\n     // This flag is so we can open directories too\n     opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n-    let f = try!(File::open(p, &opts));\n+    let f = File::open(p, &opts)?;\n     get_path(&f)\n }\n \n@@ -687,13 +687,13 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         *(lpData as *mut i64) = TotalBytesTransferred;\n         c::PROGRESS_CONTINUE\n     }\n-    let pfrom = try!(to_u16s(from));\n-    let pto = try!(to_u16s(to));\n+    let pfrom = to_u16s(from)?;\n+    let pto = to_u16s(to)?;\n     let mut size = 0i64;\n-    try!(cvt(unsafe {\n+    cvt(unsafe {\n         c::CopyFileExW(pfrom.as_ptr(), pto.as_ptr(), Some(callback),\n                        &mut size as *mut _ as *mut _, ptr::null_mut(), 0)\n-    }));\n+    })?;\n     Ok(size as u64)\n }\n \n@@ -710,13 +710,13 @@ pub fn symlink_junction<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::R\n #[allow(dead_code)]\n fn symlink_junction_inner(target: &Path, junction: &Path) -> io::Result<()> {\n     let d = DirBuilder::new();\n-    try!(d.mkdir(&junction));\n+    d.mkdir(&junction)?;\n \n     let mut opts = OpenOptions::new();\n     opts.write(true);\n     opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT |\n                       c::FILE_FLAG_BACKUP_SEMANTICS);\n-    let f = try!(File::open(junction, &opts));\n+    let f = File::open(junction, &opts)?;\n     let h = f.handle().raw();\n \n     unsafe {"}, {"sha": "74546bb893bea8bbde6cc36fc802b9cbb7d71cfb", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -169,22 +169,22 @@ impl RawHandle {\n         // WriteFile takes a DWORD (u32) for the length so it only supports\n         // writing u32::MAX bytes at a time.\n         let len = cmp::min(buf.len(), u32::MAX as usize) as c::DWORD;\n-        try!(cvt(unsafe {\n+        cvt(unsafe {\n             c::WriteFile(self.0, buf.as_ptr() as c::LPVOID,\n                          len, &mut amt, ptr::null_mut())\n-        }));\n+        })?;\n         Ok(amt as usize)\n     }\n \n     pub fn duplicate(&self, access: c::DWORD, inherit: bool,\n                      options: c::DWORD) -> io::Result<Handle> {\n         let mut ret = 0 as c::HANDLE;\n-        try!(cvt(unsafe {\n+        cvt(unsafe {\n             let cur_proc = c::GetCurrentProcess();\n             c::DuplicateHandle(cur_proc, self.0, cur_proc, &mut ret,\n                             access, inherit as c::BOOL,\n                             options)\n-        }));\n+        })?;\n         Ok(Handle::new(ret))\n     }\n }"}, {"sha": "ab2d969fe0a357133a432b4938359f8821c10fbc", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -92,35 +92,35 @@ impl Socket {\n             SocketAddr::V4(..) => c::AF_INET,\n             SocketAddr::V6(..) => c::AF_INET6,\n         };\n-        let socket = try!(unsafe {\n+        let socket = unsafe {\n             match c::WSASocketW(fam, ty, 0, ptr::null_mut(), 0,\n                                 c::WSA_FLAG_OVERLAPPED) {\n                 c::INVALID_SOCKET => Err(last_error()),\n                 n => Ok(Socket(n)),\n             }\n-        });\n-        try!(socket.set_no_inherit());\n+        }?;\n+        socket.set_no_inherit()?;\n         Ok(socket)\n     }\n \n     pub fn accept(&self, storage: *mut c::SOCKADDR,\n                   len: *mut c_int) -> io::Result<Socket> {\n-        let socket = try!(unsafe {\n+        let socket = unsafe {\n             match c::accept(self.0, storage, len) {\n                 c::INVALID_SOCKET => Err(last_error()),\n                 n => Ok(Socket(n)),\n             }\n-        });\n-        try!(socket.set_no_inherit());\n+        }?;\n+        socket.set_no_inherit()?;\n         Ok(socket)\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {\n-        let socket = try!(unsafe {\n+        let socket = unsafe {\n             let mut info: c::WSAPROTOCOL_INFO = mem::zeroed();\n-            try!(cvt(c::WSADuplicateSocketW(self.0,\n+            cvt(c::WSADuplicateSocketW(self.0,\n                                             c::GetCurrentProcessId(),\n-                                            &mut info)));\n+                                            &mut info))?;\n             match c::WSASocketW(info.iAddressFamily,\n                                 info.iSocketType,\n                                 info.iProtocol,\n@@ -129,8 +129,8 @@ impl Socket {\n                 c::INVALID_SOCKET => Err(last_error()),\n                 n => Ok(Socket(n)),\n             }\n-        });\n-        try!(socket.set_no_inherit());\n+        }?;\n+        socket.set_no_inherit()?;\n         Ok(socket)\n     }\n \n@@ -169,7 +169,7 @@ impl Socket {\n     }\n \n     pub fn timeout(&self, kind: c_int) -> io::Result<Option<Duration>> {\n-        let raw: c::DWORD = try!(net::getsockopt(self, c::SOL_SOCKET, kind));\n+        let raw: c::DWORD = net::getsockopt(self, c::SOL_SOCKET, kind)?;\n         if raw == 0 {\n             Ok(None)\n         } else {\n@@ -192,7 +192,7 @@ impl Socket {\n             Shutdown::Read => c::SD_RECEIVE,\n             Shutdown::Both => c::SD_BOTH,\n         };\n-        try!(cvt(unsafe { c::shutdown(self.0, how) }));\n+        cvt(unsafe { c::shutdown(self.0, how) })?;\n         Ok(())\n     }\n \n@@ -211,12 +211,12 @@ impl Socket {\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n-        let raw: c::BYTE = try!(net::getsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY));\n+        let raw: c::BYTE = net::getsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY)?;\n         Ok(raw != 0)\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        let raw: c_int = try!(net::getsockopt(self, c::SOL_SOCKET, c::SO_ERROR));\n+        let raw: c_int = net::getsockopt(self, c::SOL_SOCKET, c::SO_ERROR)?;\n         if raw == 0 {\n             Ok(None)\n         } else {"}, {"sha": "32ca32e76cb626aee457870c00020279bf5d5127", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -239,7 +239,7 @@ pub fn chdir(p: &path::Path) -> io::Result<()> {\n }\n \n pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n-    let k = try!(to_u16s(k));\n+    let k = to_u16s(k)?;\n     let res = super::fill_utf16_buf(|buf, sz| unsafe {\n         c::GetEnvironmentVariableW(k.as_ptr(), buf, sz)\n     }, |buf| {\n@@ -258,16 +258,16 @@ pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n }\n \n pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    let k = try!(to_u16s(k));\n-    let v = try!(to_u16s(v));\n+    let k = to_u16s(k)?;\n+    let v = to_u16s(v)?;\n \n     cvt(unsafe {\n         c::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr())\n     }).map(|_| ())\n }\n \n pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n-    let v = try!(to_u16s(n));\n+    let v = to_u16s(n)?;\n     cvt(unsafe {\n         c::SetEnvironmentVariableW(v.as_ptr(), ptr::null())\n     }).map(|_| ())"}, {"sha": "8631a63d653a3af38843f51e1f3b6e317b176891", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -95,7 +95,7 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n         opts.read(false);\n         opts.share_mode(0);\n         opts.attributes(c::FILE_FLAG_OVERLAPPED);\n-        let writer = try!(File::open(Path::new(&name), &opts));\n+        let writer = File::open(Path::new(&name), &opts)?;\n         let writer = AnonPipe { inner: writer.into_handle() };\n \n         Ok((AnonPipe { inner: reader }, AnonPipe { inner: writer.into_handle() }))\n@@ -126,8 +126,8 @@ pub fn read2(p1: AnonPipe,\n     let p1 = p1.into_handle();\n     let p2 = p2.into_handle();\n \n-    let mut p1 = try!(AsyncPipe::new(p1, v1));\n-    let mut p2 = try!(AsyncPipe::new(p2, v2));\n+    let mut p1 = AsyncPipe::new(p1, v1)?;\n+    let mut p2 = AsyncPipe::new(p2, v2)?;\n     let objs = [p1.event.raw(), p2.event.raw()];\n \n     // In a loop we wait for either pipe's scheduled read operation to complete.\n@@ -143,11 +143,11 @@ pub fn read2(p1: AnonPipe,\n             c::WaitForMultipleObjects(2, objs.as_ptr(), c::FALSE, c::INFINITE)\n         };\n         if res == c::WAIT_OBJECT_0 {\n-            if !try!(p1.result()) || !try!(p1.schedule_read()) {\n+            if !p1.result()? || !p1.schedule_read()? {\n                 return p2.finish()\n             }\n         } else if res == c::WAIT_OBJECT_0 + 1 {\n-            if !try!(p2.result()) || !try!(p2.schedule_read()) {\n+            if !p2.result()? || !p2.schedule_read()? {\n                 return p1.finish()\n             }\n         } else {\n@@ -183,7 +183,7 @@ impl<'a> AsyncPipe<'a> {\n         // WaitForMultipleObjects call above for pipes created initially,\n         // and the only time an even will go back to \"unset\" will be once an\n         // I/O operation is successfully scheduled (what we want).\n-        let event = try!(Handle::new_event(true, true));\n+        let event = Handle::new_event(true, true)?;\n         let mut overlapped: Box<c::OVERLAPPED> = unsafe {\n             Box::new(mem::zeroed())\n         };\n@@ -207,7 +207,7 @@ impl<'a> AsyncPipe<'a> {\n         assert_eq!(self.state, State::NotReading);\n         let amt = unsafe {\n             let slice = slice_to_end(self.dst);\n-            try!(self.pipe.read_overlapped(slice, &mut *self.overlapped))\n+            self.pipe.read_overlapped(slice, &mut *self.overlapped)?\n         };\n \n         // If this read finished immediately then our overlapped event will\n@@ -240,7 +240,7 @@ impl<'a> AsyncPipe<'a> {\n         let amt = match self.state {\n             State::NotReading => return Ok(true),\n             State::Reading => {\n-                try!(self.pipe.overlapped_result(&mut *self.overlapped, true))\n+                self.pipe.overlapped_result(&mut *self.overlapped, true)?\n             }\n             State::Read(amt) => amt,\n         };\n@@ -257,7 +257,7 @@ impl<'a> AsyncPipe<'a> {\n     /// Waits for any pending and schedule read, and then calls `read_to_end`\n     /// if necessary to read all the remaining information.\n     fn finish(&mut self) -> io::Result<()> {\n-        while try!(self.result()) && try!(self.schedule_read()) {\n+        while self.result()? && self.schedule_read()? {\n             // ...\n         }\n         Ok(())"}, {"sha": "9c29ac4082a6b2e3f0b40fdb3fcfcfcb8dffec9e", "filename": "src/libstd/sys/windows/printing/msvc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -53,7 +53,7 @@ pub fn print(w: &mut Write,\n             None\n         };\n \n-        try!(output(w, i, addr as usize as *mut c_void, name));\n+        output(w, i, addr as usize as *mut c_void, name)?;\n \n         // Now find out the filename and line number\n         let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();"}, {"sha": "f479b36ebbdbf1d0a720a12c9e0b0e5879c93462", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -151,7 +151,7 @@ impl Command {\n         si.dwFlags = c::STARTF_USESTDHANDLES;\n \n         let program = program.as_ref().unwrap_or(&self.program);\n-        let mut cmd_str = try!(make_command_line(program, &self.args));\n+        let mut cmd_str = make_command_line(program, &self.args)?;\n         cmd_str.push(0); // add null terminator\n \n         // stolen from the libuv code.\n@@ -160,8 +160,8 @@ impl Command {\n             flags |= c::DETACHED_PROCESS | c::CREATE_NEW_PROCESS_GROUP;\n         }\n \n-        let (envp, _data) = try!(make_envp(self.env.as_ref()));\n-        let (dirp, _data) = try!(make_dirp(self.cwd.as_ref()));\n+        let (envp, _data) = make_envp(self.env.as_ref())?;\n+        let (dirp, _data) = make_dirp(self.cwd.as_ref())?;\n         let mut pi = zeroed_process_information();\n \n         // Prepare all stdio handles to be inherited by the child. This\n@@ -186,23 +186,23 @@ impl Command {\n         let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n         let stdout = self.stdout.as_ref().unwrap_or(&default);\n         let stderr = self.stderr.as_ref().unwrap_or(&default);\n-        let stdin = try!(stdin.to_handle(c::STD_INPUT_HANDLE, &mut pipes.stdin));\n-        let stdout = try!(stdout.to_handle(c::STD_OUTPUT_HANDLE,\n-                                           &mut pipes.stdout));\n-        let stderr = try!(stderr.to_handle(c::STD_ERROR_HANDLE,\n-                                           &mut pipes.stderr));\n+        let stdin = stdin.to_handle(c::STD_INPUT_HANDLE, &mut pipes.stdin)?;\n+        let stdout = stdout.to_handle(c::STD_OUTPUT_HANDLE,\n+                                           &mut pipes.stdout)?;\n+        let stderr = stderr.to_handle(c::STD_ERROR_HANDLE,\n+                                           &mut pipes.stderr)?;\n         si.hStdInput = stdin.raw();\n         si.hStdOutput = stdout.raw();\n         si.hStdError = stderr.raw();\n \n-        try!(unsafe {\n+        unsafe {\n             cvt(c::CreateProcessW(ptr::null(),\n                                   cmd_str.as_mut_ptr(),\n                                   ptr::null_mut(),\n                                   ptr::null_mut(),\n                                   c::TRUE, flags, envp, dirp,\n                                   &mut si, &mut pi))\n-        });\n+        }?;\n \n         // We close the thread handle because we don't care about keeping\n         // the thread id valid, and we aren't keeping the thread handle\n@@ -216,9 +216,9 @@ impl Command {\n \n impl fmt::Debug for Command {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{:?}\", self.program));\n+        write!(f, \"{:?}\", self.program)?;\n         for arg in &self.args {\n-            try!(write!(f, \" {:?}\", arg));\n+            write!(f, \" {:?}\", arg)?;\n         }\n         Ok(())\n     }\n@@ -240,18 +240,18 @@ impl Stdio {\n             }\n \n             Stdio::MakePipe => {\n-                let (reader, writer) = try!(pipe::anon_pipe());\n+                let (reader, writer) = pipe::anon_pipe()?;\n                 let (ours, theirs) = if stdio_id == c::STD_INPUT_HANDLE {\n                     (writer, reader)\n                 } else {\n                     (reader, writer)\n                 };\n                 *pipe = Some(ours);\n-                try!(cvt(unsafe {\n+                cvt(unsafe {\n                     c::SetHandleInformation(theirs.handle().raw(),\n                                             c::HANDLE_FLAG_INHERIT,\n                                             c::HANDLE_FLAG_INHERIT)\n-                }));\n+                })?;\n                 Ok(theirs.into_handle())\n             }\n \n@@ -296,9 +296,9 @@ pub struct Process {\n \n impl Process {\n     pub fn kill(&mut self) -> io::Result<()> {\n-        try!(cvt(unsafe {\n+        cvt(unsafe {\n             c::TerminateProcess(self.handle.raw(), 1)\n-        }));\n+        })?;\n         Ok(())\n     }\n \n@@ -315,7 +315,7 @@ impl Process {\n                 return Err(Error::last_os_error())\n             }\n             let mut status = 0;\n-            try!(cvt(c::GetExitCodeProcess(self.handle.raw(), &mut status)));\n+            cvt(c::GetExitCodeProcess(self.handle.raw(), &mut status))?;\n             Ok(ExitStatus(status))\n         }\n     }\n@@ -381,18 +381,18 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> io::Result<Vec<u16>> {\n     // Encode the command and arguments in a command line string such\n     // that the spawned process may recover them using CommandLineToArgvW.\n     let mut cmd: Vec<u16> = Vec::new();\n-    try!(append_arg(&mut cmd, prog));\n+    append_arg(&mut cmd, prog)?;\n     for arg in args {\n         cmd.push(' ' as u16);\n-        try!(append_arg(&mut cmd, arg));\n+        append_arg(&mut cmd, arg)?;\n     }\n     return Ok(cmd);\n \n     fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr) -> io::Result<()> {\n         // If an argument has 0 characters then we need to quote it to ensure\n         // that it actually gets passed through on the command line or otherwise\n         // it will be dropped entirely when parsed on the other end.\n-        try!(ensure_no_nuls(arg));\n+        ensure_no_nuls(arg)?;\n         let arg_bytes = &arg.as_inner().inner.as_inner();\n         let quote = arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t')\n             || arg_bytes.is_empty();\n@@ -438,9 +438,9 @@ fn make_envp(env: Option<&collections::HashMap<OsString, OsString>>)\n             let mut blk = Vec::new();\n \n             for pair in env {\n-                blk.extend(try!(ensure_no_nuls(pair.0)).encode_wide());\n+                blk.extend(ensure_no_nuls(pair.0)?.encode_wide());\n                 blk.push('=' as u16);\n-                blk.extend(try!(ensure_no_nuls(pair.1)).encode_wide());\n+                blk.extend(ensure_no_nuls(pair.1)?.encode_wide());\n                 blk.push(0);\n             }\n             blk.push(0);\n@@ -454,7 +454,7 @@ fn make_dirp(d: Option<&OsString>) -> io::Result<(*const u16, Vec<u16>)> {\n \n     match d {\n         Some(dir) => {\n-            let mut dir_str: Vec<u16> = try!(ensure_no_nuls(dir)).encode_wide().collect();\n+            let mut dir_str: Vec<u16> = ensure_no_nuls(dir)?.encode_wide().collect();\n             dir_str.push(0);\n             Ok((dir_str.as_ptr(), dir_str))\n         },"}, {"sha": "fa3cab2191edde5ba25924ef0a838e235b6aae75", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -78,13 +78,13 @@ fn write(out: &Output, data: &[u8]) -> io::Result<usize> {\n     };\n     let utf16 = utf8.encode_utf16().collect::<Vec<u16>>();\n     let mut written = 0;\n-    try!(cvt(unsafe {\n+    cvt(unsafe {\n         c::WriteConsoleW(handle,\n                          utf16.as_ptr() as c::LPCVOID,\n                          utf16.len() as u32,\n                          &mut written,\n                          ptr::null_mut())\n-    }));\n+    })?;\n \n     // FIXME if this only partially writes the utf16 buffer then we need to\n     //       figure out how many bytes of `data` were actually written\n@@ -112,13 +112,13 @@ impl Stdin {\n         if utf8.position() as usize == utf8.get_ref().len() {\n             let mut utf16 = vec![0u16; 0x1000];\n             let mut num = 0;\n-            try!(cvt(unsafe {\n+            cvt(unsafe {\n                 c::ReadConsoleW(handle,\n                                 utf16.as_mut_ptr() as c::LPVOID,\n                                 utf16.len() as u32,\n                                 &mut num,\n                                 ptr::null_mut())\n-            }));\n+            })?;\n             utf16.truncate(num as usize);\n             // FIXME: what to do about this data that has already been read?\n             let data = match String::from_utf16(&utf16) {"}, {"sha": "f3139aaf98d836a5c84f7b5eb8550a82624425aa", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -285,7 +285,7 @@ impl Builder {\n \n         Ok(JoinHandle(JoinInner {\n             native: unsafe {\n-                Some(try!(imp::Thread::new(stack_size, Box::new(main))))\n+                Some(imp::Thread::new(stack_size, Box::new(main))?)\n             },\n             thread: my_thread,\n             packet: Packet(my_packet),"}, {"sha": "ac1a07d1cb5f5b2305d2305ce22cc1d9d75e1857", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -83,7 +83,7 @@ impl Encodable for Name {\n \n impl Decodable for Name {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Name, D::Error> {\n-        Ok(token::intern(&try!(d.read_str())[..]))\n+        Ok(token::intern(&d.read_str()?[..]))\n     }\n }\n \n@@ -152,7 +152,7 @@ impl Encodable for Ident {\n \n impl Decodable for Ident {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(Ident::with_empty_ctxt(try!(Name::decode(d))))\n+        Ok(Ident::with_empty_ctxt(Name::decode(d)?))\n     }\n }\n "}, {"sha": "80b806b7b5034579c952ea866a1fdb2745980915", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 32, "deletions": 43, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -86,7 +86,7 @@ impl Encodable for BytePos {\n \n impl Decodable for BytePos {\n     fn decode<D: Decoder>(d: &mut D) -> Result<BytePos, D::Error> {\n-        Ok(BytePos(try!{ d.read_u32() }))\n+        Ok(BytePos(d.read_u32()?))\n     }\n }\n \n@@ -203,9 +203,9 @@ pub struct Spanned<T> {\n impl Encodable for Span {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"Span\", 2, |s| {\n-            try!(s.emit_struct_field(\"lo\", 0, |s| {\n+            s.emit_struct_field(\"lo\", 0, |s| {\n                 self.lo.encode(s)\n-            }));\n+            })?;\n \n             s.emit_struct_field(\"hi\", 1, |s| {\n                 self.hi.encode(s)\n@@ -217,13 +217,13 @@ impl Encodable for Span {\n impl Decodable for Span {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Span, D::Error> {\n         d.read_struct(\"Span\", 2, |d| {\n-            let lo = try!(d.read_struct_field(\"lo\", 0, |d| {\n+            let lo = d.read_struct_field(\"lo\", 0, |d| {\n                 BytePos::decode(d)\n-            }));\n+            })?;\n \n-            let hi = try!(d.read_struct_field(\"hi\", 1, |d| {\n+            let hi = d.read_struct_field(\"hi\", 1, |d| {\n                 BytePos::decode(d)\n-            }));\n+            })?;\n \n             Ok(mk_sp(lo, hi))\n         })\n@@ -526,13 +526,13 @@ pub struct FileMap {\n impl Encodable for FileMap {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"FileMap\", 5, |s| {\n-            try! { s.emit_struct_field(\"name\", 0, |s| self.name.encode(s)) };\n-            try! { s.emit_struct_field(\"start_pos\", 1, |s| self.start_pos.encode(s)) };\n-            try! { s.emit_struct_field(\"end_pos\", 2, |s| self.end_pos.encode(s)) };\n-            try! { s.emit_struct_field(\"lines\", 3, |s| {\n+            s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n+            s.emit_struct_field(\"start_pos\", 1, |s| self.start_pos.encode(s))?;\n+            s.emit_struct_field(\"end_pos\", 2, |s| self.end_pos.encode(s))?;\n+            s.emit_struct_field(\"lines\", 3, |s| {\n                     let lines = self.lines.borrow();\n                     // store the length\n-                    try! { s.emit_u32(lines.len() as u32) };\n+                    s.emit_u32(lines.len() as u32)?;\n \n                     if !lines.is_empty() {\n                         // In order to preserve some space, we exploit the fact that\n@@ -557,25 +557,24 @@ impl Encodable for FileMap {\n                         };\n \n                         // Encode the number of bytes used per diff.\n-                        try! { bytes_per_diff.encode(s) };\n+                        bytes_per_diff.encode(s)?;\n \n                         // Encode the first element.\n-                        try! { lines[0].encode(s) };\n+                        lines[0].encode(s)?;\n \n                         let diff_iter = (&lines[..]).windows(2)\n                                                     .map(|w| (w[1] - w[0]));\n \n                         match bytes_per_diff {\n-                            1 => for diff in diff_iter { try! { (diff.0 as u8).encode(s) } },\n-                            2 => for diff in diff_iter { try! { (diff.0 as u16).encode(s) } },\n-                            4 => for diff in diff_iter { try! { diff.0.encode(s) } },\n+                            1 => for diff in diff_iter { (diff.0 as u8).encode(s)? },\n+                            2 => for diff in diff_iter { (diff.0 as u16).encode(s)? },\n+                            4 => for diff in diff_iter { diff.0.encode(s)? },\n                             _ => unreachable!()\n                         }\n                     }\n \n                     Ok(())\n-                })\n-            };\n+                })?;\n             s.emit_struct_field(\"multibyte_chars\", 4, |s| {\n                 (*self.multibyte_chars.borrow()).encode(s)\n             })\n@@ -587,33 +586,26 @@ impl Decodable for FileMap {\n     fn decode<D: Decoder>(d: &mut D) -> Result<FileMap, D::Error> {\n \n         d.read_struct(\"FileMap\", 5, |d| {\n-            let name: String = try! {\n-                d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))\n-            };\n-            let start_pos: BytePos = try! {\n-                d.read_struct_field(\"start_pos\", 1, |d| Decodable::decode(d))\n-            };\n-            let end_pos: BytePos = try! {\n-                d.read_struct_field(\"end_pos\", 2, |d| Decodable::decode(d))\n-            };\n-            let lines: Vec<BytePos> = try! {\n-                d.read_struct_field(\"lines\", 3, |d| {\n-                    let num_lines: u32 = try! { Decodable::decode(d) };\n+            let name: String = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n+            let start_pos: BytePos = d.read_struct_field(\"start_pos\", 1, |d| Decodable::decode(d))?;\n+            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 2, |d| Decodable::decode(d))?;\n+            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 3, |d| {\n+                    let num_lines: u32 = Decodable::decode(d)?;\n                     let mut lines = Vec::with_capacity(num_lines as usize);\n \n                     if num_lines > 0 {\n                         // Read the number of bytes used per diff.\n-                        let bytes_per_diff: u8 = try! { Decodable::decode(d) };\n+                        let bytes_per_diff: u8 = Decodable::decode(d)?;\n \n                         // Read the first element.\n-                        let mut line_start: BytePos = try! { Decodable::decode(d) };\n+                        let mut line_start: BytePos = Decodable::decode(d)?;\n                         lines.push(line_start);\n \n                         for _ in 1..num_lines {\n                             let diff = match bytes_per_diff {\n-                                1 => try! { d.read_u8() } as u32,\n-                                2 => try! { d.read_u16() } as u32,\n-                                4 => try! { d.read_u32() },\n+                                1 => d.read_u8()? as u32,\n+                                2 => d.read_u16()? as u32,\n+                                4 => d.read_u32()?,\n                                 _ => unreachable!()\n                             };\n \n@@ -624,11 +616,8 @@ impl Decodable for FileMap {\n                     }\n \n                     Ok(lines)\n-                })\n-            };\n-            let multibyte_chars: Vec<MultiByteChar> = try! {\n-                d.read_struct_field(\"multibyte_chars\", 4, |d| Decodable::decode(d))\n-            };\n+                })?;\n+            let multibyte_chars: Vec<MultiByteChar> = d.read_struct_field(\"multibyte_chars\", 4, |d| Decodable::decode(d))?;\n             Ok(FileMap {\n                 name: name,\n                 start_pos: start_pos,\n@@ -730,7 +719,7 @@ impl FileLoader for RealFileLoader {\n \n     fn read_file(&self, path: &Path) -> io::Result<String> {\n         let mut src = String::new();\n-        try!(try!(fs::File::open(path)).read_to_string(&mut src));\n+        fs::File::open(path)?.read_to_string(&mut src)?;\n         Ok(src)\n     }\n }\n@@ -767,7 +756,7 @@ impl CodeMap {\n     }\n \n     pub fn load_file(&self, path: &Path) -> io::Result<Rc<FileMap>> {\n-        let src = try!(self.file_loader.read_file(path));\n+        let src = self.file_loader.read_file(path)?;\n         Ok(self.new_filemap(path.to_str().unwrap().to_string(), src))\n     }\n "}, {"sha": "181b32594f1278d6a24ce365a0243ae277937b51", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -76,11 +76,11 @@ pub fn output_metadata(ecx: &ExtCtxt, prefix: &str, name: &str, err_map: &ErrorM\n {\n     // Create the directory to place the file in.\n     let metadata_dir = get_metadata_dir(prefix);\n-    try!(create_dir_all(&metadata_dir));\n+    create_dir_all(&metadata_dir)?;\n \n     // Open the metadata file.\n     let metadata_path = get_metadata_path(metadata_dir, name);\n-    let mut metadata_file = try!(File::create(&metadata_path));\n+    let mut metadata_file = File::create(&metadata_path)?;\n \n     // Construct a serializable map.\n     let json_map = err_map.iter().map(|(k, &ErrorInfo { description, use_site })| {\n@@ -95,7 +95,7 @@ pub fn output_metadata(ecx: &ExtCtxt, prefix: &str, name: &str, err_map: &ErrorM\n     // Write the data to the file, deleting it if the write fails.\n     let result = write!(&mut metadata_file, \"{}\", as_json(&json_map));\n     if result.is_err() {\n-        try!(remove_file(&metadata_path));\n+        remove_file(&metadata_path)?;\n     }\n-    Ok(try!(result))\n+    Ok(result?)\n }"}, {"sha": "c846b1866a789a0c59012b7f5e60ac8786db931c", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -184,20 +184,20 @@ impl EmitterWriter {\n             self.cm.span_to_string(bounds)\n         };\n \n-        try!(print_diagnostic(&mut self.dst, &ss[..], lvl, msg, code));\n+        print_diagnostic(&mut self.dst, &ss[..], lvl, msg, code)?;\n \n         match *rsp {\n             FullSpan(_) => {\n-                try!(self.highlight_lines(msp, lvl));\n-                try!(self.print_macro_backtrace(bounds));\n+                self.highlight_lines(msp, lvl)?;\n+                self.print_macro_backtrace(bounds)?;\n             }\n             EndSpan(_) => {\n-                try!(self.end_highlight_lines(msp, lvl));\n-                try!(self.print_macro_backtrace(bounds));\n+                self.end_highlight_lines(msp, lvl)?;\n+                self.print_macro_backtrace(bounds)?;\n             }\n             Suggestion(ref suggestion) => {\n-                try!(self.highlight_suggestion(suggestion));\n-                try!(self.print_macro_backtrace(bounds));\n+                self.highlight_suggestion(suggestion)?;\n+                self.print_macro_backtrace(bounds)?;\n             }\n             FileLine(..) => {\n                 // no source text in this case!\n@@ -207,9 +207,9 @@ impl EmitterWriter {\n         if let Some(code) = code {\n             if let Some(_) = self.registry.as_ref()\n                                           .and_then(|registry| registry.find_description(code)) {\n-                try!(print_diagnostic(&mut self.dst, &ss[..], Help,\n+                print_diagnostic(&mut self.dst, &ss[..], Help,\n                                       &format!(\"run `rustc --explain {}` to see a \\\n-                                               detailed explanation\", code), None));\n+                                               detailed explanation\", code), None)?;\n             }\n         }\n         Ok(())\n@@ -233,14 +233,14 @@ impl EmitterWriter {\n         // snippets from the actual error being reported.\n         let mut lines = complete.lines();\n         for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-            try!(write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n-                        fm.name, \"\", max_digits, line));\n+            write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n+                        fm.name, \"\", max_digits, line)?;\n         }\n \n         // if we elided some lines, add an ellipsis\n         if let Some(_) = lines.next() {\n-            try!(write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n-                        \"\", fm.name.len(), max_digits));\n+            write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n+                        \"\", fm.name.len(), max_digits)?;\n         }\n \n         Ok(())\n@@ -254,7 +254,7 @@ impl EmitterWriter {\n         let lines = match self.cm.span_to_lines(msp.to_span_bounds()) {\n             Ok(lines) => lines,\n             Err(_) => {\n-                try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n+                write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\")?;\n                 return Ok(());\n             }\n         };\n@@ -418,26 +418,26 @@ impl EmitterWriter {\n \n             // If we elided something put an ellipsis.\n             if prev_line_index != line.line_index.wrapping_sub(1) && !overflowed {\n-                try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip));\n+                write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip)?;\n             }\n \n             // Print offending code-line\n             remaining_err_lines -= 1;\n-            try!(write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n+            write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n                         fm.name,\n                         line.line_index + 1,\n                         cur_line_str,\n-                        width=digits));\n+                        width=digits)?;\n \n             if s.len() > skip {\n                 // Render the spans we assembled previously (if any).\n-                try!(println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n-                                           \"{}\", s));\n+                println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n+                                           \"{}\", s)?;\n             }\n \n             if !overflowed_buf.is_empty() {\n                 // Print code-lines trailing the rendered spans (when a span overflows)\n-                try!(write!(&mut self.dst, \"{}\", &overflowed_buf));\n+                write!(&mut self.dst, \"{}\", &overflowed_buf)?;\n                 overflowed_buf.clear();\n             } else {\n                 prev_line_index = line.line_index;\n@@ -446,7 +446,7 @@ impl EmitterWriter {\n \n         // If we elided something, put an ellipsis.\n         if lines.next().is_some() {\n-            try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip));\n+            write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip)?;\n         }\n         Ok(())\n     }\n@@ -465,7 +465,7 @@ impl EmitterWriter {\n         let lines = match self.cm.span_to_lines(msp.to_span_bounds()) {\n             Ok(lines) => lines,\n             Err(_) => {\n-                try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n+                write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\")?;\n                 return Ok(());\n             }\n         };\n@@ -556,18 +556,18 @@ impl EmitterWriter {\n \n             if prev_line_index != line.line_index.wrapping_sub(1) {\n                 // If we elided something, put an ellipsis.\n-                try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip));\n+                write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip)?;\n             }\n \n             // Print offending code-lines\n-            try!(write!(&mut self.dst, \"{}:{:>width$} {}\\n\", fm.name,\n-                        line.line_index + 1, line_str, width=digits));\n+            write!(&mut self.dst, \"{}:{:>width$} {}\\n\", fm.name,\n+                        line.line_index + 1, line_str, width=digits)?;\n             remaining_err_lines -= 1;\n \n             if s.len() > skip {\n                 // Render the spans we assembled previously (if any)\n-                try!(println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n-                                           \"{}\", s));\n+                println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n+                                           \"{}\", s)?;\n             }\n             prev_line_index = line.line_index;\n         }\n@@ -612,7 +612,7 @@ impl EmitterWriter {\n                 }\n \n                 let snippet = self.cm.span_to_string(span);\n-                try!(print_diagnostic(&mut self.dst, &snippet, Note, &diag_string, None));\n+                print_diagnostic(&mut self.dst, &snippet, Note, &diag_string, None)?;\n             }\n             last_span = span;\n         }\n@@ -638,18 +638,18 @@ fn print_diagnostic(dst: &mut Destination,\n                     code: Option<&str>)\n                     -> io::Result<()> {\n     if !topic.is_empty() {\n-        try!(write!(dst, \"{} \", topic));\n+        write!(dst, \"{} \", topic)?;\n     }\n \n-    try!(print_maybe_styled!(dst, term::Attr::ForegroundColor(lvl.color()),\n-                             \"{}: \", lvl.to_string()));\n-    try!(print_maybe_styled!(dst, term::Attr::Bold, \"{}\", msg));\n+    print_maybe_styled!(dst, term::Attr::ForegroundColor(lvl.color()),\n+                             \"{}: \", lvl.to_string())?;\n+    print_maybe_styled!(dst, term::Attr::Bold, \"{}\", msg)?;\n \n     if let Some(code) = code {\n         let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-        try!(print_maybe_styled!(dst, style, \" [{}]\", code.clone()));\n+        print_maybe_styled!(dst, style, \" [{}]\", code.clone())?;\n     }\n-    try!(write!(dst, \"\\n\"));\n+    write!(dst, \"\\n\")?;\n     Ok(())\n }\n \n@@ -696,7 +696,7 @@ impl Destination {\n                           -> io::Result<()> {\n         match *self {\n             Terminal(ref mut t) => {\n-                try!(t.attr(color));\n+                t.attr(color)?;\n                 // If `msg` ends in a newline, we need to reset the color before\n                 // the newline. We're making the assumption that we end up writing\n                 // to a `LineBufferedWriter`, which means that emitting the reset\n@@ -710,16 +710,16 @@ impl Destination {\n                 // once, which still leaves the opportunity for interleaved output\n                 // to be miscolored. We assume this is rare enough that we don't\n                 // have to worry about it.\n-                try!(t.write_fmt(args));\n-                try!(t.reset());\n+                t.write_fmt(args)?;\n+                t.reset()?;\n                 if print_newline_at_end {\n                     t.write_all(b\"\\n\")\n                 } else {\n                     Ok(())\n                 }\n             }\n             Raw(ref mut w) => {\n-                try!(w.write_fmt(args));\n+                w.write_fmt(args)?;\n                 if print_newline_at_end {\n                     w.write_all(b\"\\n\")\n                 } else {"}, {"sha": "4e4c644776a5163200273ee26a93415a77384d72", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -208,12 +208,12 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n         match *m {\n             TokenTree::Sequence(_, ref seq) => {\n                 for next_m in &seq.tts {\n-                    try!(n_rec(p_s, next_m, res, ret_val, idx))\n+                    n_rec(p_s, next_m, res, ret_val, idx)?\n                 }\n             }\n             TokenTree::Delimited(_, ref delim) => {\n                 for next_m in &delim.tts {\n-                    try!(n_rec(p_s, next_m, res, ret_val, idx));\n+                    n_rec(p_s, next_m, res, ret_val, idx)?;\n                 }\n             }\n             TokenTree::Token(sp, MatchNt(bind_name, _, _, _)) => {"}, {"sha": "b8e320e36e9b4883f9a68a530d36ba83189e3a7d", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -25,7 +25,7 @@ impl<'a> Parser<'a> {\n             debug!(\"parse_outer_attributes: self.token={:?}\", self.token);\n             match self.token {\n                 token::Pound => {\n-                    attrs.push(try!(self.parse_attribute(false)));\n+                    attrs.push(self.parse_attribute(false)?);\n                 }\n                 token::DocComment(s) => {\n                     let attr = ::attr::mk_sugared_doc_attr(\n@@ -79,10 +79,10 @@ impl<'a> Parser<'a> {\n                     ast::AttrStyle::Outer\n                 };\n \n-                try!(self.expect(&token::OpenDelim(token::Bracket)));\n-                let meta_item = try!(self.parse_meta_item());\n+                self.expect(&token::OpenDelim(token::Bracket))?;\n+                let meta_item = self.parse_meta_item()?;\n                 let hi = self.span.hi;\n-                try!(self.expect(&token::CloseDelim(token::Bracket)));\n+                self.expect(&token::CloseDelim(token::Bracket))?;\n \n                 (mk_sp(lo, hi), meta_item, style)\n             }\n@@ -126,7 +126,7 @@ impl<'a> Parser<'a> {\n                         break;\n                     }\n \n-                    let attr = try!(self.parse_attribute(true));\n+                    let attr = self.parse_attribute(true)?;\n                     assert!(attr.node.style == ast::AttrStyle::Inner);\n                     attrs.push(attr);\n                 }\n@@ -166,12 +166,12 @@ impl<'a> Parser<'a> {\n         }\n \n         let lo = self.span.lo;\n-        let ident = try!(self.parse_ident());\n+        let ident = self.parse_ident()?;\n         let name = self.id_to_interned_str(ident);\n         match self.token {\n             token::Eq => {\n                 self.bump();\n-                let lit = try!(self.parse_lit());\n+                let lit = self.parse_lit()?;\n                 // FIXME #623 Non-string meta items are not serialized correctly;\n                 // just forbid them for now\n                 match lit.node {\n@@ -185,7 +185,7 @@ impl<'a> Parser<'a> {\n                 Ok(P(spanned(lo, hi, ast::MetaItemKind::NameValue(name, lit))))\n             }\n             token::OpenDelim(token::Paren) => {\n-                let inner_items = try!(self.parse_meta_seq());\n+                let inner_items = self.parse_meta_seq()?;\n                 let hi = self.span.hi;\n                 Ok(P(spanned(lo, hi, ast::MetaItemKind::List(name, inner_items))))\n             }"}, {"sha": "827f3331753e60a46762f9dd69f7972cf3fa201b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 489, "deletions": 489, "changes": 978, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f"}, {"sha": "a02a10aa0035a2931ef057eefa1ae1a03e4dc890", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -706,7 +706,7 @@ impl<'a> PartialEq<InternedString> for &'a str {\n \n impl Decodable for InternedString {\n     fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(intern(try!(d.read_str()).as_ref()).as_str())\n+        Ok(intern(d.read_str()?.as_ref()).as_str())\n     }\n }\n "}, {"sha": "c381a3a8437de3965f8cb18a265700a0cdd1f705", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -318,7 +318,7 @@ impl<'a> Printer<'a> {\n           Token::Eof => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n-                try!(self.advance_left());\n+                self.advance_left()?;\n             }\n             self.indent(0);\n             Ok(())\n@@ -399,9 +399,9 @@ impl<'a> Printer<'a> {\n                     self.size[scanned] = SIZE_INFINITY;\n                 }\n             }\n-            try!(self.advance_left());\n+            self.advance_left()?;\n             if self.left != self.right {\n-                try!(self.check_stream());\n+                self.check_stream()?;\n             }\n         }\n         Ok(())\n@@ -464,7 +464,7 @@ impl<'a> Printer<'a> {\n                 _ => 0\n             };\n \n-            try!(self.print(left, left_size));\n+            self.print(left, left_size)?;\n \n             self.left_total += len;\n \n@@ -532,7 +532,7 @@ impl<'a> Printer<'a> {\n     }\n     pub fn print_str(&mut self, s: &str) -> io::Result<()> {\n         while self.pending_indentation > 0 {\n-            try!(write!(self.out, \" \"));\n+            write!(self.out, \" \")?;\n             self.pending_indentation -= 1;\n         }\n         write!(self.out, \"{}\", s)"}, {"sha": "9a3400025a807a1fed6cc2df4d6645ff478be267", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 860, "deletions": 860, "changes": 1720, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f"}, {"sha": "395d966b9f25c74b4066edf257aff62587bef446", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -109,7 +109,7 @@ impl TermInfo {\n     }\n     // Keep the metadata small\n     fn _from_path(path: &Path) -> Result<TermInfo, Error> {\n-        let file = try!(File::open(path).map_err(|e| Error::IoError(e)));\n+        let file = File::open(path).map_err(|e| Error::IoError(e))?;\n         let mut reader = BufReader::new(file);\n         parse(&mut reader, false).map_err(|e| Error::MalformedTerminfo(e))\n     }"}, {"sha": "60b5dffac59ad20f1fc63064f6a818849843475a", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -209,7 +209,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                     'd' | 'o' | 'x' | 'X' | 's' => {\n                         if let Some(arg) = stack.pop() {\n                             let flags = Flags::new();\n-                            let res = try!(format(arg, FormatOp::from_char(cur), flags));\n+                            let res = format(arg, FormatOp::from_char(cur), flags)?;\n                             output.extend(res.iter().map(|x| *x));\n                         } else {\n                             return Err(\"stack is empty\".to_string());\n@@ -317,7 +317,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                 match (*fstate, cur) {\n                     (_, 'd') | (_, 'o') | (_, 'x') | (_, 'X') | (_, 's') => {\n                         if let Some(arg) = stack.pop() {\n-                            let res = try!(format(arg, FormatOp::from_char(cur), *flags));\n+                            let res = format(arg, FormatOp::from_char(cur), *flags)?;\n                             output.extend(res.iter().map(|x| *x));\n                             // will cause state to go to Nothing\n                             old_state = FormatPattern(*flags, *fstate);"}, {"sha": "9ce3a2aadd53b1bfafd8f937323bef60bdd54b98", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -168,7 +168,7 @@ fn read_le_u16(r: &mut io::Read) -> io::Result<u16> {\n     let mut b = [0; 2];\n     let mut amt = 0;\n     while amt < b.len() {\n-        match try!(r.read(&mut b[amt..])) {\n+        match r.read(&mut b[amt..])? {\n             0 => return Err(io::Error::new(io::ErrorKind::Other, \"end of file\")),\n             n => amt += n,\n         }\n@@ -200,7 +200,7 @@ pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n     };\n \n     // Check magic number\n-    let magic = try!(read_le_u16(file));\n+    let magic = read_le_u16(file)?;\n     if magic != 0x011A {\n         return Err(format!(\"invalid magic number: expected {:x}, found {:x}\",\n                            0x011A,\n@@ -243,7 +243,7 @@ pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n \n     // don't read NUL\n     let mut bytes = Vec::new();\n-    try!(file.take((names_bytes - 1) as u64).read_to_end(&mut bytes));\n+    file.take((names_bytes - 1) as u64).read_to_end(&mut bytes)?;\n     let names_str = match String::from_utf8(bytes) {\n         Ok(s) => s,\n         Err(_) => return Err(\"input not utf-8\".to_string()),\n@@ -253,39 +253,35 @@ pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n                                            .map(|s| s.to_string())\n                                            .collect();\n     // consume NUL\n-    if try!(read_byte(file)) != b'\\0' {\n+    if read_byte(file)? != b'\\0' {\n         return Err(\"incompatible file: missing null terminator for names section\".to_string());\n     }\n \n-    let bools_map: HashMap<String, bool> = try! {\n-        (0..bools_bytes).filter_map(|i| match read_byte(file) {\n+    let bools_map: HashMap<String, bool> = (0..bools_bytes).filter_map(|i| match read_byte(file) {\n             Err(e) => Some(Err(e)),\n             Ok(1) => Some(Ok((bnames[i].to_string(), true))),\n             Ok(_) => None\n-        }).collect()\n-    };\n+        }).collect()?;\n \n     if (bools_bytes + names_bytes) % 2 == 1 {\n-        try!(read_byte(file)); // compensate for padding\n+        read_byte(file)?; // compensate for padding\n     }\n \n-    let numbers_map: HashMap<String, u16> = try! {\n-        (0..numbers_count).filter_map(|i| match read_le_u16(file) {\n+    let numbers_map: HashMap<String, u16> = (0..numbers_count).filter_map(|i| match read_le_u16(file) {\n             Ok(0xFFFF) => None,\n             Ok(n) => Some(Ok((nnames[i].to_string(), n))),\n             Err(e) => Some(Err(e))\n-        }).collect()\n-    };\n+        }).collect()?;\n \n     let string_map: HashMap<String, Vec<u8>> = if string_offsets_count > 0 {\n-        let string_offsets: Vec<u16> = try!((0..string_offsets_count)\n+        let string_offsets: Vec<u16> = (0..string_offsets_count)\n                                                 .map(|_| read_le_u16(file))\n-                                                .collect());\n+                                                .collect()?;\n \n         let mut string_table = Vec::new();\n-        try!(file.take(string_table_bytes as u64).read_to_end(&mut string_table));\n+        file.take(string_table_bytes as u64).read_to_end(&mut string_table)?;\n \n-        try!(string_offsets.into_iter().enumerate().filter(|&(_, offset)| {\n+        string_offsets.into_iter().enumerate().filter(|&(_, offset)| {\n             // non-entry\n             offset != 0xFFFF\n         }).map(|(i, offset)| {\n@@ -309,7 +305,7 @@ pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n                 Some(len) => Ok((name.to_string(), string_table[offset..offset + len].to_vec())),\n                 None => Err(\"invalid file: missing NUL in string_table\".to_string()),\n             }\n-        }).collect())\n+        }).collect()?\n     } else {\n         HashMap::new()\n     };"}, {"sha": "e637246a1572c2246b19982f24b114641e1395a5", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -467,7 +467,7 @@ struct ConsoleTestState<T> {\n impl<T: Write> ConsoleTestState<T> {\n     pub fn new(opts: &TestOpts, _: Option<T>) -> io::Result<ConsoleTestState<io::Stdout>> {\n         let log_out = match opts.logfile {\n-            Some(ref path) => Some(try!(File::create(path))),\n+            Some(ref path) => Some(File::create(path)?),\n             None => None,\n         };\n         let out = match term::stdout() {\n@@ -516,7 +516,7 @@ impl<T: Write> ConsoleTestState<T> {\n         if self.quiet {\n             self.write_pretty(quiet, color)\n         } else {\n-            try!(self.write_pretty(verbose, color));\n+            self.write_pretty(verbose, color)?;\n             self.write_plain(\"\\n\")\n         }\n     }\n@@ -525,16 +525,16 @@ impl<T: Write> ConsoleTestState<T> {\n         match self.out {\n             Pretty(ref mut term) => {\n                 if self.use_color {\n-                    try!(term.fg(color));\n+                    term.fg(color)?;\n                 }\n-                try!(term.write_all(word.as_bytes()));\n+                term.write_all(word.as_bytes())?;\n                 if self.use_color {\n-                    try!(term.reset());\n+                    term.reset()?;\n                 }\n                 term.flush()\n             }\n             Raw(ref mut stdout) => {\n-                try!(stdout.write_all(word.as_bytes()));\n+                stdout.write_all(word.as_bytes())?;\n                 stdout.flush()\n             }\n         }\n@@ -543,11 +543,11 @@ impl<T: Write> ConsoleTestState<T> {\n     pub fn write_plain(&mut self, s: &str) -> io::Result<()> {\n         match self.out {\n             Pretty(ref mut term) => {\n-                try!(term.write_all(s.as_bytes()));\n+                term.write_all(s.as_bytes())?;\n                 term.flush()\n             }\n             Raw(ref mut stdout) => {\n-                try!(stdout.write_all(s.as_bytes()));\n+                stdout.write_all(s.as_bytes())?;\n                 stdout.flush()\n             }\n         }\n@@ -578,11 +578,11 @@ impl<T: Write> ConsoleTestState<T> {\n             TrFailed => self.write_failed(),\n             TrIgnored => self.write_ignored(),\n             TrMetrics(ref mm) => {\n-                try!(self.write_metric());\n+                self.write_metric()?;\n                 self.write_plain(&format!(\": {}\\n\", mm.fmt_metrics()))\n             }\n             TrBench(ref bs) => {\n-                try!(self.write_bench());\n+                self.write_bench()?;\n                 self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n             }\n         }\n@@ -607,7 +607,7 @@ impl<T: Write> ConsoleTestState<T> {\n     }\n \n     pub fn write_failures(&mut self) -> io::Result<()> {\n-        try!(self.write_plain(\"\\nfailures:\\n\"));\n+        self.write_plain(\"\\nfailures:\\n\")?;\n         let mut failures = Vec::new();\n         let mut fail_out = String::new();\n         for &(ref f, ref stdout) in &self.failures {\n@@ -620,14 +620,14 @@ impl<T: Write> ConsoleTestState<T> {\n             }\n         }\n         if !fail_out.is_empty() {\n-            try!(self.write_plain(\"\\n\"));\n-            try!(self.write_plain(&fail_out));\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&fail_out)?;\n         }\n \n-        try!(self.write_plain(\"\\nfailures:\\n\"));\n+        self.write_plain(\"\\nfailures:\\n\")?;\n         failures.sort();\n         for name in &failures {\n-            try!(self.write_plain(&format!(\"    {}\\n\", name)));\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n         }\n         Ok(())\n     }\n@@ -637,22 +637,22 @@ impl<T: Write> ConsoleTestState<T> {\n \n         let success = self.failed == 0;\n         if !success {\n-            try!(self.write_failures());\n+            self.write_failures()?;\n         }\n \n-        try!(self.write_plain(\"\\ntest result: \"));\n+        self.write_plain(\"\\ntest result: \")?;\n         if success {\n             // There's no parallelism at this point so it's safe to use color\n-            try!(self.write_pretty(\"ok\", term::color::GREEN));\n+            self.write_pretty(\"ok\", term::color::GREEN)?;\n         } else {\n-            try!(self.write_pretty(\"FAILED\", term::color::RED));\n+            self.write_pretty(\"FAILED\", term::color::RED)?;\n         }\n         let s = format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n                         self.passed,\n                         self.failed,\n                         self.ignored,\n                         self.measured);\n-        try!(self.write_plain(&s));\n+        self.write_plain(&s)?;\n         return Ok(success);\n     }\n }\n@@ -706,8 +706,8 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n             TeResult(test, result, stdout) => {\n-                try!(st.write_log(&test, &result));\n-                try!(st.write_result(&result));\n+                st.write_log(&test, &result)?;\n+                st.write_result(&result)?;\n                 match result {\n                     TrOk => st.passed += 1,\n                     TrIgnored => st.ignored += 1,\n@@ -736,7 +736,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         }\n     }\n \n-    let mut st = try!(ConsoleTestState::new(opts, None::<io::Stdout>));\n+    let mut st = ConsoleTestState::new(opts, None::<io::Stdout>)?;\n     fn len_if_padded(t: &TestDescAndFn) -> usize {\n         match t.testfn.padding() {\n             PadNone => 0,\n@@ -750,7 +750,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         }\n         None => {}\n     }\n-    try!(run_tests(opts, tests, |x| callback(&x, &mut st)));\n+    run_tests(opts, tests, |x| callback(&x, &mut st))?;\n     return st.write_run_finish();\n }\n \n@@ -846,7 +846,7 @@ fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) ->\n                                        .map(|t| t.desc.clone())\n                                        .collect();\n \n-    try!(callback(TeFiltered(filtered_descs)));\n+    callback(TeFiltered(filtered_descs))?;\n \n     let (filtered_tests, filtered_benchs_and_metrics): (Vec<_>, _) =\n         filtered_tests.into_iter().partition(|e| {\n@@ -873,28 +873,28 @@ fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) ->\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                try!(callback(TeWait(test.desc.clone(), test.testfn.padding())));\n+                callback(TeWait(test.desc.clone(), test.testfn.padding()))?;\n             }\n             run_test(opts, !opts.run_tests, test, tx.clone());\n             pending += 1;\n         }\n \n         let (desc, result, stdout) = rx.recv().unwrap();\n         if concurrency != 1 {\n-            try!(callback(TeWait(desc.clone(), PadNone)));\n+            callback(TeWait(desc.clone(), PadNone))?;\n         }\n-        try!(callback(TeResult(desc, result, stdout)));\n+        callback(TeResult(desc, result, stdout))?;\n         pending -= 1;\n     }\n \n     if opts.bench_benchmarks {\n         // All benchmarks run at the end, in serial.\n         // (this includes metric fns)\n         for b in filtered_benchs_and_metrics {\n-            try!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n+            callback(TeWait(b.desc.clone(), b.testfn.padding()))?;\n             run_test(opts, false, b, tx.clone());\n             let (test, result, stdout) = rx.recv().unwrap();\n-            try!(callback(TeResult(test, result, stdout)));\n+            callback(TeResult(test, result, stdout))?;\n         }\n     }\n     Ok(())"}, {"sha": "71fe4d6ece6cb0da360ff417b4bf106aa36c5451", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -40,8 +40,8 @@ impl fmt::Display for C {\n }\n impl fmt::Binary for D {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(f.write_str(\"aa\"));\n-        try!(f.write_char('\u2603'));\n+        f.write_str(\"aa\")?;\n+        f.write_char('\u2603')?;\n         f.write_str(\"bb\")\n     }\n }"}, {"sha": "dcbcc2d44b5dd803464e625f0642bd376b10a9d4", "filename": "src/test/run-pass/issue-17121.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftest%2Frun-pass%2Fissue-17121.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftest%2Frun-pass%2Fissue-17121.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17121.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -27,7 +27,7 @@ impl<R: Read> Lexer<R>\n \n     pub fn new_from_file(p: &str) -> io::Result<Lexer<File>>\n     {\n-        Ok(Lexer::new_from_reader(try!(File::open(p))))\n+        Ok(Lexer::new_from_reader(File::open(p)?))\n     }\n \n     pub fn new_from_str<'a>(s: &'a str) -> Lexer<&'a [u8]>"}, {"sha": "d4c5dfb74633f081144356097262cc2edc06f931", "filename": "src/test/run-pass/issue-20797.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20797.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -55,7 +55,7 @@ pub struct Subpaths<S: Strategy> {\n impl<S: Strategy> Subpaths<S> {\n     /// Create a directory walker with a root path and strategy.\n     pub fn new(p: &S::P, strategy: S) -> io::Result<Subpaths<S>> {\n-        let stack = try!(strategy.get_more(p));\n+        let stack = strategy.get_more(p)?;\n         Ok(Subpaths { stack: stack, strategy: strategy })\n     }\n }"}, {"sha": "6715b71a5f506eb162792c22a5714e1d4e945ec7", "filename": "src/test/run-pass/issue-21400.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftest%2Frun-pass%2Fissue-21400.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftest%2Frun-pass%2Fissue-21400.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21400.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -54,7 +54,7 @@ impl GitConnect {\n         let c = format!(\"git-upload-pack\");\n \n         let mut out = String::new();\n-        let data = try!(self.command(&c));\n+        let data = self.command(&c)?;\n \n         for line in data.iter() {\n             out.push_str(&format!(\"{:?}\", line));"}, {"sha": "7f80c17b7566591eddacde2e2d3fdf4dea9d2409", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -56,7 +56,7 @@ struct MarkdownFormatter;\n \n impl Formatter for HTMLFormatter {\n     fn header(&self, output: &mut Write) -> Result<(), Box<Error>> {\n-        try!(write!(output, r##\"<!DOCTYPE html>\n+        write!(output, r##\"<!DOCTYPE html>\n <html>\n <head>\n <title>Rust Compiler Error Index</title>\n@@ -71,12 +71,12 @@ impl Formatter for HTMLFormatter {\n </style>\n </head>\n <body>\n-\"##));\n+\"##)?;\n         Ok(())\n     }\n \n     fn title(&self, output: &mut Write) -> Result<(), Box<Error>> {\n-        try!(write!(output, \"<h1>Rust Compiler Error Index</h1>\\n\"));\n+        write!(output, \"<h1>Rust Compiler Error Index</h1>\\n\")?;\n         Ok(())\n     }\n \n@@ -91,25 +91,25 @@ impl Formatter for HTMLFormatter {\n             Some(_) => \"error-used\",\n             None => \"error-unused\",\n         };\n-        try!(write!(output, \"<div class=\\\"{} {}\\\">\", desc_desc, use_desc));\n+        write!(output, \"<div class=\\\"{} {}\\\">\", desc_desc, use_desc)?;\n \n         // Error title (with self-link).\n-        try!(write!(output,\n+        write!(output,\n                     \"<h2 id=\\\"{0}\\\" class=\\\"section-header\\\"><a href=\\\"#{0}\\\">{0}</a></h2>\\n\",\n-                    err_code));\n+                    err_code)?;\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => try!(write!(output, \"{}\", Markdown(desc))),\n-            None => try!(write!(output, \"<p>No description.</p>\\n\")),\n+            Some(ref desc) => write!(output, \"{}\", Markdown(desc))?,\n+            None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n \n-        try!(write!(output, \"</div>\\n\"));\n+        write!(output, \"</div>\\n\")?;\n         Ok(())\n     }\n \n     fn footer(&self, output: &mut Write) -> Result<(), Box<Error>> {\n-        try!(write!(output, \"</body>\\n</html>\"));\n+        write!(output, \"</body>\\n</html>\")?;\n         Ok(())\n     }\n }\n@@ -121,14 +121,14 @@ impl Formatter for MarkdownFormatter {\n     }\n \n     fn title(&self, output: &mut Write) -> Result<(), Box<Error>> {\n-        try!(write!(output, \"# Rust Compiler Error Index\\n\"));\n+        write!(output, \"# Rust Compiler Error Index\\n\")?;\n         Ok(())\n     }\n \n     fn error_code_block(&self, output: &mut Write, info: &ErrorMetadata,\n                         err_code: &str) -> Result<(), Box<Error>> {\n         Ok(match info.description {\n-            Some(ref desc) => try!(write!(output, \"## {}\\n{}\\n\", err_code, desc)),\n+            Some(ref desc) => write!(output, \"## {}\\n{}\\n\", err_code, desc)?,\n             None => (),\n         })\n     }\n@@ -143,13 +143,13 @@ impl Formatter for MarkdownFormatter {\n fn load_all_errors(metadata_dir: &Path) -> Result<ErrorMetadataMap, Box<Error>> {\n     let mut all_errors = BTreeMap::new();\n \n-    for entry in try!(read_dir(metadata_dir)) {\n-        let path = try!(entry).path();\n+    for entry in read_dir(metadata_dir)? {\n+        let path = entry?.path();\n \n         let mut metadata_str = String::new();\n-        try!(File::open(&path).and_then(|mut f| f.read_to_string(&mut metadata_str)));\n+        File::open(&path).and_then(|mut f| f.read_to_string(&mut metadata_str))?;\n \n-        let some_errors: ErrorMetadataMap = try!(json::decode(&metadata_str));\n+        let some_errors: ErrorMetadataMap = json::decode(&metadata_str)?;\n \n         for (err_code, info) in some_errors {\n             all_errors.insert(err_code, info);\n@@ -162,26 +162,26 @@ fn load_all_errors(metadata_dir: &Path) -> Result<ErrorMetadataMap, Box<Error>>\n /// Output an HTML page for the errors in `err_map` to `output_path`.\n fn render_error_page<T: Formatter>(err_map: &ErrorMetadataMap, output_path: &Path,\n                                    formatter: T) -> Result<(), Box<Error>> {\n-    let mut output_file = try!(File::create(output_path));\n+    let mut output_file = File::create(output_path)?;\n \n-    try!(formatter.header(&mut output_file));\n-    try!(formatter.title(&mut output_file));\n+    formatter.header(&mut output_file)?;\n+    formatter.title(&mut output_file)?;\n \n     for (err_code, info) in err_map {\n-        try!(formatter.error_code_block(&mut output_file, info, err_code));\n+        formatter.error_code_block(&mut output_file, info, err_code)?;\n     }\n \n     formatter.footer(&mut output_file)\n }\n \n fn main_with_result(format: OutputFormat, dst: &Path) -> Result<(), Box<Error>> {\n-    let build_arch = try!(env::var(\"CFG_BUILD\"));\n+    let build_arch = env::var(\"CFG_BUILD\")?;\n     let metadata_dir = get_metadata_dir(&build_arch);\n-    let err_map = try!(load_all_errors(&metadata_dir));\n+    let err_map = load_all_errors(&metadata_dir)?;\n     match format {\n         OutputFormat::Unknown(s)  => panic!(\"Unknown output format: {}\", s),\n-        OutputFormat::HTML(h)     => try!(render_error_page(&err_map, dst, h)),\n-        OutputFormat::Markdown(m) => try!(render_error_page(&err_map, dst, m)),\n+        OutputFormat::HTML(h)     => render_error_page(&err_map, dst, h)?,\n+        OutputFormat::Markdown(m) => render_error_page(&err_map, dst, m)?,\n     }\n     Ok(())\n }"}, {"sha": "f9dc8ffa4c4484e36e3eb6f77af368f29c2fc49c", "filename": "src/tools/rustbook/build.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftools%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftools%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fbuild.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -41,7 +41,7 @@ fn write_toc(book: &Book, current_page: &BookItem, out: &mut Write) -> io::Resul\n                   current_page: &BookItem,\n                   out: &mut Write) -> io::Result<()> {\n         for (i, item) in items.iter().enumerate() {\n-            try!(walk_item(item, &format!(\"{}{}.\", section, i + 1)[..], current_page, out));\n+            walk_item(item, &format!(\"{}{}.\", section, i + 1)[..], current_page, out)?;\n         }\n         Ok(())\n     }\n@@ -55,32 +55,32 @@ fn write_toc(book: &Book, current_page: &BookItem, out: &mut Write) -> io::Resul\n             \"\"\n         };\n \n-        try!(writeln!(out, \"<li><a {} href='{}'><b>{}</b> {}</a>\",\n+        writeln!(out, \"<li><a {} href='{}'><b>{}</b> {}</a>\",\n                       class_string,\n                       current_page.path_to_root.join(&item.path).with_extension(\"html\").display(),\n                       section,\n-                      item.title));\n+                      item.title)?;\n         if !item.children.is_empty() {\n-            try!(writeln!(out, \"<ul class='section'>\"));\n+            writeln!(out, \"<ul class='section'>\")?;\n             let _ = walk_items(&item.children[..], section, current_page, out);\n-            try!(writeln!(out, \"</ul>\"));\n+            writeln!(out, \"</ul>\")?;\n         }\n-        try!(writeln!(out, \"</li>\"));\n+        writeln!(out, \"</li>\")?;\n \n         Ok(())\n     }\n \n-    try!(writeln!(out, \"<div id='toc' class='mobile-hidden'>\"));\n-    try!(writeln!(out, \"<ul class='chapter'>\"));\n-    try!(walk_items(&book.chapters[..], \"\", &current_page, out));\n-    try!(writeln!(out, \"</ul>\"));\n-    try!(writeln!(out, \"</div>\"));\n+    writeln!(out, \"<div id='toc' class='mobile-hidden'>\")?;\n+    writeln!(out, \"<ul class='chapter'>\")?;\n+    walk_items(&book.chapters[..], \"\", &current_page, out)?;\n+    writeln!(out, \"</ul>\")?;\n+    writeln!(out, \"</div>\")?;\n \n     Ok(())\n }\n \n fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n-    let tmp = try!(TempDir::new(\"rustbook\"));\n+    let tmp = TempDir::new(\"rustbook\")?;\n \n     for (_section, item) in book.iter() {\n         let out_path = match item.path.parent() {\n@@ -97,45 +97,45 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n         // preprocess the markdown, rerouting markdown references to html\n         // references\n         let mut markdown_data = String::new();\n-        try!(File::open(&src.join(&item.path)).and_then(|mut f| {\n+        File::open(&src.join(&item.path)).and_then(|mut f| {\n             f.read_to_string(&mut markdown_data)\n-        }));\n+        })?;\n         let preprocessed_path = tmp.path().join(item.path.file_name().unwrap());\n         {\n             let urls = markdown_data.replace(\".md)\", \".html)\");\n-            try!(File::create(&preprocessed_path).and_then(|mut f| {\n+            File::create(&preprocessed_path).and_then(|mut f| {\n                 f.write_all(urls.as_bytes())\n-            }));\n+            })?;\n         }\n \n         // write the prelude to a temporary HTML file for rustdoc inclusion\n         let prelude = tmp.path().join(\"prelude.html\");\n         {\n-            let mut buffer = BufWriter::new(try!(File::create(&prelude)));\n-            try!(writeln!(&mut buffer, r#\"\n+            let mut buffer = BufWriter::new(File::create(&prelude)?);\n+            writeln!(&mut buffer, r#\"\n                 <div id=\"nav\">\n                     <button id=\"toggle-nav\">\n                         <span class=\"sr-only\">Toggle navigation</span>\n                         <span class=\"bar\"></span>\n                         <span class=\"bar\"></span>\n                         <span class=\"bar\"></span>\n                     </button>\n-                </div>\"#));\n+                </div>\"#)?;\n             let _ = write_toc(book, &item, &mut buffer);\n-            try!(writeln!(&mut buffer, \"<div id='page-wrapper'>\"));\n-            try!(writeln!(&mut buffer, \"<div id='page'>\"));\n+            writeln!(&mut buffer, \"<div id='page-wrapper'>\")?;\n+            writeln!(&mut buffer, \"<div id='page'>\")?;\n         }\n \n         // write the postlude to a temporary HTML file for rustdoc inclusion\n         let postlude = tmp.path().join(\"postlude.html\");\n         {\n-            let mut buffer = BufWriter::new(try!(File::create(&postlude)));\n-            try!(writeln!(&mut buffer, \"<script src='rustbook.js'></script>\"));\n-            try!(writeln!(&mut buffer, \"<script src='playpen.js'></script>\"));\n-            try!(writeln!(&mut buffer, \"</div></div>\"));\n+            let mut buffer = BufWriter::new(File::create(&postlude)?);\n+            writeln!(&mut buffer, \"<script src='rustbook.js'></script>\")?;\n+            writeln!(&mut buffer, \"<script src='playpen.js'></script>\")?;\n+            writeln!(&mut buffer, \"</div></div>\")?;\n         }\n \n-        try!(fs::create_dir_all(&out_path));\n+        fs::create_dir_all(&out_path)?;\n \n         let rustdoc_args: &[String] = &[\n             \"\".to_string(),\n@@ -156,12 +156,12 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n     }\n \n     // create index.html from the root README\n-    try!(fs::copy(&tgt.join(\"README.html\"), &tgt.join(\"index.html\")));\n+    fs::copy(&tgt.join(\"README.html\"), &tgt.join(\"index.html\"))?;\n \n     // Copy js for playpen\n-    let mut playpen = try!(File::create(tgt.join(\"playpen.js\")));\n+    let mut playpen = File::create(tgt.join(\"playpen.js\"))?;\n     let js = include_bytes!(\"../../librustdoc/html/static/playpen.js\");\n-    try!(playpen.write_all(js));\n+    playpen.write_all(js)?;\n     Ok(())\n }\n \n@@ -189,24 +189,24 @@ impl Subcommand for Build {\n \n         // `_book` directory may already exist from previous runs. Check and\n         // delete it if it exists.\n-        for entry in try!(fs::read_dir(&cwd)) {\n-            let path = try!(entry).path();\n-            if path == tgt { try!(fs::remove_dir_all(&tgt)) }\n+        for entry in fs::read_dir(&cwd)? {\n+            let path = entry?.path();\n+            if path == tgt { fs::remove_dir_all(&tgt)? }\n         }\n-        try!(fs::create_dir(&tgt));\n+        fs::create_dir(&tgt)?;\n \n         // Copy static files\n         let css = include_bytes!(\"static/rustbook.css\");\n         let js = include_bytes!(\"static/rustbook.js\");\n \n-        let mut css_file = try!(File::create(tgt.join(\"rustbook.css\")));\n-        try!(css_file.write_all(css));\n+        let mut css_file = File::create(tgt.join(\"rustbook.css\"))?;\n+        css_file.write_all(css)?;\n \n-        let mut js_file = try!(File::create(tgt.join(\"rustbook.js\")));\n-        try!(js_file.write_all(js));\n+        let mut js_file = File::create(tgt.join(\"rustbook.js\"))?;\n+        js_file.write_all(js)?;\n \n \n-        let mut summary = try!(File::open(&src.join(\"SUMMARY.md\")));\n+        let mut summary = File::open(&src.join(\"SUMMARY.md\"))?;\n         match book::parse_summary(&mut summary, &src) {\n             Ok(book) => {\n                 // execute rustdoc on the whole book"}, {"sha": "002c46a7af48db021a0ad5776467bcb23a93c31d", "filename": "src/tools/rustbook/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftools%2Frustbook%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f02309e4b0ea05ee905205278fb6d131341c41f/src%2Ftools%2Frustbook%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Ftest.rs?ref=0f02309e4b0ea05ee905205278fb6d131341c41f", "patch": "@@ -38,7 +38,7 @@ impl Subcommand for Test {\n         let cwd = env::current_dir().unwrap();\n         let src = cwd.clone();\n \n-        let mut summary = try!(File::open(&src.join(\"SUMMARY.md\")));\n+        let mut summary = File::open(&src.join(\"SUMMARY.md\"))?;\n         match book::parse_summary(&mut summary, &src) {\n             Ok(book) => {\n                 for (_, item) in book.iter() {"}]}