{"sha": "566bcf2225634ee4d4698247fe89364440eb534c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NmJjZjIyMjU2MzRlZTRkNDY5ODI0N2ZlODkzNjQ0NDBlYjUzNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-15T21:54:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-15T21:54:49Z"}, "message": "auto merge of #4969 : nickdesaulniers/rust/issue3869, r=brson\n\nIssue #3869\r\nreview? @nikomatsakis \r\n\r\nConvert all uses of vec::slice to vec::view Issue #3869\r\nRename const_view to const_slice\r\nRenamed mut_view to mut_slice\r\nFix windows build error.  `buf` is borrowed by the call to\r\n`as_mut_buf()` and so we must invoke `slice()` outside of that\r\ncall.", "tree": {"sha": "75b488c9d3568c5732c43655d461eded9697e272", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75b488c9d3568c5732c43655d461eded9697e272"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/566bcf2225634ee4d4698247fe89364440eb534c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/566bcf2225634ee4d4698247fe89364440eb534c", "html_url": "https://github.com/rust-lang/rust/commit/566bcf2225634ee4d4698247fe89364440eb534c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/566bcf2225634ee4d4698247fe89364440eb534c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0528329a4fb7765917bda30e9e1805627801d36a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0528329a4fb7765917bda30e9e1805627801d36a", "html_url": "https://github.com/rust-lang/rust/commit/0528329a4fb7765917bda30e9e1805627801d36a"}, {"sha": "91af52784aa1febcd424b9057221298c1f793094", "url": "https://api.github.com/repos/rust-lang/rust/commits/91af52784aa1febcd424b9057221298c1f793094", "html_url": "https://github.com/rust-lang/rust/commit/91af52784aa1febcd424b9057221298c1f793094"}], "stats": {"total": 254, "additions": 130, "deletions": 124}, "files": [{"sha": "3213a11cbb51c0e2aeda3c275d2148c808051ee7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -570,7 +570,8 @@ fn make_run_args(config: config, _props: TestProps, testfile: &Path) ->\n         };\n \n     let args = toolargs + ~[make_exe_name(config, testfile).to_str()];\n-    return ProcArgs {prog: args[0], args: vec::slice(args, 1, args.len())};\n+    return ProcArgs {prog: args[0],\n+                     args: vec::slice(args, 1, args.len()).to_vec()};\n }\n \n fn split_maybe_args(argstr: Option<~str>) -> ~[~str] {"}, {"sha": "eb5f871d053966aede73b3ac7d9b9b4f93b35e83", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -1553,7 +1553,7 @@ pub fn cmd_list(c: &Cargo) {\n     sync(c);\n \n     if vec::len(c.opts.free) >= 3u {\n-        let v = vec::view(c.opts.free, 2u, vec::len(c.opts.free));\n+        let v = vec::slice(c.opts.free, 2u, vec::len(c.opts.free));\n         for vec::each(v) |name| {\n             if !valid_pkg_name(*name) {\n                 error(fmt!(\"'%s' is an invalid source name\", *name));"}, {"sha": "6739c5b852e1d13860a71c689d3c5c211006ecee", "filename": "src/libcore/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -246,7 +246,7 @@ impl<T: Reader> ReaderUtil for T {\n             // over-read by reading 1-byte per char needed\n             nbread = if ncreq > nbreq { ncreq } else { nbreq };\n             if nbread > 0 {\n-                bytes = vec::slice(bytes, offset, bytes.len());\n+                bytes = vec::slice(bytes, offset, bytes.len()).to_vec();\n             }\n         }\n         chars\n@@ -531,7 +531,7 @@ impl Reader for BytesReader {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         let count = uint::min(len, self.bytes.len() - self.pos);\n \n-        let view = vec::view(self.bytes, self.pos, self.bytes.len());\n+        let view = vec::slice(self.bytes, self.pos, self.bytes.len());\n         vec::bytes::copy_memory(bytes, view, count);\n \n         self.pos += count;\n@@ -1008,7 +1008,7 @@ impl Writer for BytesWriter {\n             unsafe { vec::raw::set_len(&mut bytes, count); }\n \n             {\n-                let view = vec::mut_view(bytes, self.pos, count);\n+                let view = vec::mut_slice(bytes, self.pos, count);\n                 vec::bytes::copy_memory(view, v, v_len);\n             }\n "}, {"sha": "56ac5e66c406700b830f857643aa0bc2b34584cf", "filename": "src/libcore/os.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -108,21 +108,24 @@ pub mod win32 {\n             let mut res = None;\n             let mut done = false;\n             while !done {\n-                let mut buf = vec::from_elem(n as uint, 0u16);\n+                let mut k: DWORD = 0;\n+                let buf = vec::cast_to_mut(vec::from_elem(n as uint, 0u16));\n                 do vec::as_mut_buf(buf) |b, _sz| {\n-                    let k : DWORD = f(b, TMPBUF_SZ as DWORD);\n+                    k = f(b, TMPBUF_SZ as DWORD);\n                     if k == (0 as DWORD) {\n                         done = true;\n                     } else if (k == n &&\n                                libc::GetLastError() ==\n                                libc::ERROR_INSUFFICIENT_BUFFER as DWORD) {\n                         n *= (2 as DWORD);\n                     } else {\n-                        let sub = vec::slice(buf, 0u, k as uint);\n-                        res = option::Some(str::from_utf16(sub));\n                         done = true;\n                     }\n                 }\n+                if k != 0 && done {\n+                    let sub = vec::slice(buf, 0u, k as uint);\n+                    res = option::Some(str::from_utf16(sub));\n+                }\n             }\n             return res;\n         }"}, {"sha": "43ab77287a63926e3bb4736e69a52d72a169350c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 59, "deletions": 65, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -220,21 +220,21 @@ pub pure fn head<T: Copy>(v: &[const T]) -> T { v[0] }\n \n /// Returns a vector containing all but the first element of a slice\n pub pure fn tail<T: Copy>(v: &[const T]) -> ~[T] {\n-    return slice(v, 1u, len(v));\n+    slice(v, 1u, len(v)).to_vec()\n }\n \n /**\n  * Returns a vector containing all but the first `n` \\\n  * elements of a slice\n  */\n pub pure fn tailn<T: Copy>(v: &[const T], n: uint) -> ~[T] {\n-    slice(v, n, len(v))\n+    slice(v, n, len(v)).to_vec()\n }\n \n /// Returns a vector containing all but the last element of a slice\n pub pure fn init<T: Copy>(v: &[const T]) -> ~[T] {\n     assert len(v) != 0u;\n-    slice(v, 0u, len(v) - 1u)\n+    slice(v, 0u, len(v) - 1u).to_vec()\n }\n \n /// Returns the last element of the slice `v`, failing if the slice is empty.\n@@ -252,20 +252,9 @@ pub pure fn last_opt<T: Copy>(v: &[const T]) -> Option<T> {\n     Some(v[len(v) - 1u])\n }\n \n-/// Returns a copy of the elements from [`start`..`end`) from `v`.\n-pub pure fn slice<T: Copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n-    assert (start <= end);\n-    assert (end <= len(v));\n-    let mut result = ~[];\n-    unsafe {\n-        for uint::range(start, end) |i| { result.push(v[i]) }\n-    }\n-    result\n-}\n-\n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn view<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n+pub pure fn slice<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n@@ -279,7 +268,9 @@ pub pure fn view<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn mut_view<T>(v: &r/[mut T], start: uint, end: uint) -> &r/[mut T] {\n+pub pure fn mut_slice<T>(v: &r/[mut T], start: uint,\n+                         end: uint) -> &r/[mut T] {\n+\n     assert (start <= end);\n     assert (end <= len(v));\n     do as_mut_buf(v) |p, _len| {\n@@ -293,7 +284,7 @@ pub pure fn mut_view<T>(v: &r/[mut T], start: uint, end: uint) -> &r/[mut T] {\n \n /// Return a slice that points into another slice.\n #[inline(always)]\n-pub pure fn const_view<T>(v: &r/[const T], start: uint,\n+pub pure fn const_slice<T>(v: &r/[const T], start: uint,\n                       end: uint) -> &r/[const T] {\n     assert (start <= end);\n     assert (end <= len(v));\n@@ -319,12 +310,12 @@ pub fn split<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n         match position_between(v, start, ln, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, start, i));\n+                result.push(slice(v, start, i).to_vec());\n                 start = i + 1u;\n             }\n         }\n     }\n-    result.push(slice(v, start, ln));\n+    result.push(slice(v, start, ln).to_vec());\n     result\n }\n \n@@ -343,14 +334,14 @@ pub fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n         match position_between(v, start, ln, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, start, i));\n+                result.push(slice(v, start, i).to_vec());\n                 // Make sure to skip the separator.\n                 start = i + 1u;\n                 count -= 1u;\n             }\n         }\n     }\n-    result.push(slice(v, start, ln));\n+    result.push(slice(v, start, ln).to_vec());\n     result\n }\n \n@@ -368,12 +359,12 @@ pub fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n         match rposition_between(v, 0, end, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, i + 1, end));\n+                result.push(slice(v, i + 1, end).to_vec());\n                 end = i;\n             }\n         }\n     }\n-    result.push(slice(v, 0u, end));\n+    result.push(slice(v, 0u, end).to_vec());\n     reverse(result);\n     return result;\n }\n@@ -393,14 +384,14 @@ pub fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n         match rposition_between(v, 0u, end, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, i + 1u, end));\n+                result.push(slice(v, i + 1u, end).to_vec());\n                 // Make sure to skip the separator.\n                 end = i;\n                 count -= 1u;\n             }\n         }\n     }\n-    result.push(slice(v, 0u, end));\n+    result.push(slice(v, 0u, end).to_vec());\n     reverse(result);\n     result\n }\n@@ -478,15 +469,15 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         // popped. For the moment it unsafely exists at both the head and last\n         // positions\n         {\n-            let first_slice = view(*v, 0, 1);\n-            let last_slice = view(*v, next_ln, ln);\n+            let first_slice = slice(*v, 0, 1);\n+            let last_slice = slice(*v, next_ln, ln);\n             raw::copy_memory(::cast::transmute(last_slice), first_slice, 1);\n         }\n \n         // Memcopy everything to the left one element\n         {\n-            let init_slice = view(*v, 0, next_ln);\n-            let tail_slice = view(*v, 1, ln);\n+            let init_slice = slice(*v, 0, next_ln);\n+            let tail_slice = slice(*v, 1, ln);\n             raw::copy_memory(::cast::transmute(init_slice),\n                              tail_slice,\n                              next_ln);\n@@ -1464,9 +1455,9 @@ pure fn each_permutation<T: Copy>(v: &[T], put: fn(ts: &[T]) -> bool) {\n         let mut i = 0u;\n         while i < ln {\n             let elt = v[i];\n-            let mut rest = slice(v, 0u, i);\n+            let mut rest = slice(v, 0u, i).to_vec();\n             unsafe {\n-                rest.push_all(const_view(v, i+1u, ln));\n+                rest.push_all(const_slice(v, i+1u, ln));\n                 for each_permutation(rest) |permutation| {\n                     if !put(append(~[elt], permutation)) {\n                         return;\n@@ -1485,7 +1476,7 @@ pub pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n         let len = vec::len(xx);\n         if ii+nn <= len {\n             unsafe {\n-                ww.push(vec::slice(xx, ii, ii+nn));\n+                ww.push(slice(xx, ii, ii+nn).to_vec());\n             }\n         }\n     }\n@@ -1689,7 +1680,7 @@ impl<T: Copy> CopyableVector<T> for &[const T] {\n     /// Returns a copy of the elements from [`start`..`end`) from `v`.\n     #[inline]\n     pure fn slice(&self, start: uint, end: uint) -> ~[T] {\n-        slice(*self, start, end)\n+        slice(*self, start, end).to_vec()\n     }\n \n     /// Returns all but the first element of a vector\n@@ -1713,7 +1704,7 @@ impl<T> ImmutableVector<T> for &[T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n     pure fn view(&self, start: uint, end: uint) -> &self/[T] {\n-        view(*self, start, end)\n+        slice(*self, start, end)\n     }\n \n     /// Reduce a vector from right to left\n@@ -2566,42 +2557,45 @@ mod tests {\n \n     #[test]\n     fn test_slice() {\n-        // Test on-stack -> on-stack slice.\n-        let mut v = slice(~[1, 2, 3], 1u, 3u);\n-        assert (len(v) == 2u);\n-        assert (v[0] == 2);\n-        assert (v[1] == 3);\n-\n-        // Test on-heap -> on-stack slice.\n-        v = slice(~[1, 2, 3, 4, 5], 0u, 3u);\n-        assert (len(v) == 3u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 2);\n-        assert (v[2] == 3);\n-\n-        // Test on-heap -> on-heap slice.\n-        v = slice(~[1, 2, 3, 4, 5, 6], 1u, 6u);\n-        assert (len(v) == 5u);\n-        assert (v[0] == 2);\n-        assert (v[1] == 3);\n-        assert (v[2] == 4);\n-        assert (v[3] == 5);\n-        assert (v[4] == 6);\n+        // Test fixed length vector.\n+        let vec_fixed = [1, 2, 3, 4];\n+        let v_a = slice(vec_fixed, 1u, len(vec_fixed)).to_vec();\n+        assert (len(v_a) == 3u);\n+        assert (v_a[0] == 2);\n+        assert (v_a[1] == 3);\n+        assert (v_a[2] == 4);\n+\n+        // Test on stack.\n+        let vec_stack = &[1, 2, 3];\n+        let v_b = slice(vec_stack, 1u, 3u).to_vec();\n+        assert (len(v_b) == 2u);\n+        assert (v_b[0] == 2);\n+        assert (v_b[1] == 3);\n+\n+        // Test on managed heap.\n+        let vec_managed = @[1, 2, 3, 4, 5];\n+        let v_c = slice(vec_managed, 0u, 3u).to_vec();\n+        assert (len(v_c) == 3u);\n+        assert (v_c[0] == 1);\n+        assert (v_c[1] == 2);\n+        assert (v_c[2] == 3);\n+\n+        // Test on exchange heap.\n+        let vec_unique = ~[1, 2, 3, 4, 5, 6];\n+        let v_d = slice(vec_unique, 1u, 6u).to_vec();\n+        assert (len(v_d) == 5u);\n+        assert (v_d[0] == 2);\n+        assert (v_d[1] == 3);\n+        assert (v_d[2] == 4);\n+        assert (v_d[3] == 5);\n+        assert (v_d[4] == 6);\n     }\n \n     #[test]\n     fn test_pop() {\n-        // Test on-stack pop.\n-        let mut v = ~[1, 2, 3];\n-        let mut e = v.pop();\n-        assert (len(v) == 2u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 2);\n-        assert (e == 3);\n-\n         // Test on-heap pop.\n-        v = ~[1, 2, 3, 4, 5];\n-        e = v.pop();\n+        let mut v = ~[1, 2, 3, 4, 5];\n+        let e = v.pop();\n         assert (len(v) == 4u);\n         assert (v[0] == 1);\n         assert (v[1] == 2);"}, {"sha": "1bcd67bd67b537935e27d0674a308186abc2dcc4", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -157,7 +157,7 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     let mut path = ~[];\n     for uint::range(start_idx, len1 - 1) |_i| { path.push(~\"..\"); };\n \n-    path.push_all(vec::view(split2, start_idx, len2 - 1));\n+    path.push_all(vec::slice(split2, start_idx, len2 - 1));\n \n     if !path.is_empty() {\n         return Path(\"\").push_many(path);"}, {"sha": "644cf3af0bd5419d5a7e229011463734378dd415", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -64,7 +64,7 @@ fn lookup_hash(d: ebml::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n     let belt = tag_index_buckets_bucket_elt;\n     for reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n-        if eq_fn(vec::view(*elt.data, elt.start + 4u, elt.end)) {\n+        if eq_fn(vec::slice(*elt.data, elt.start + 4u, elt.end)) {\n             return Some(reader::doc_at(d.data, pos).doc);\n         }\n     };\n@@ -75,7 +75,8 @@ pub type GetCrateDataCb = &fn(ast::crate_num) -> cmd;\n \n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n-        return io::u64_from_be_bytes(vec::view(bytes, 0u, 4u), 0u, 4u) as int\n+        return io::u64_from_be_bytes(\n+            vec::slice(bytes, 0u, 4u), 0u, 4u) as int\n             == item_id;\n     }\n     lookup_hash(items,"}, {"sha": "e2a2573e0416593c4b3963867f5e62418a9895a5", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -1147,7 +1147,7 @@ fn encode_crate_deps(ecx: @encode_ctxt,\n         }\n \n         // mut -> immutable hack for vec::map\n-        return vec::slice(deps, 0u, vec::len(deps));\n+        return vec::slice(deps, 0u, vec::len(deps)).to_vec();\n     }\n \n     // We're just going to write a list of crate 'name-hash-version's, with\n@@ -1307,7 +1307,7 @@ pub fn encode_metadata(parms: encode_parms, crate: &crate) -> ~[u8] {\n     //   vec::from_slice(metadata_encoding_version) +\n \n     (do str::as_bytes(&~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n-        vec::slice(*bytes, 0, 8)\n+        vec::slice(*bytes, 0, 8).to_vec()\n     }) + flate::deflate_bytes(wr.bytes.check_out(|buf| buf))\n }\n "}, {"sha": "8da6ddda4b3195d2ffde6aa7045aeb70df08f0dc", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -493,8 +493,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n         fail!();\n     }\n \n-    let crate_part = vec::view(buf, 0u, colon_idx);\n-    let def_part = vec::view(buf, colon_idx + 1u, len);\n+    let crate_part = vec::slice(buf, 0u, colon_idx);\n+    let def_part = vec::slice(buf, colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as int,"}, {"sha": "8864e2e0a0828cc7801162488cb6f8cb268c7b62", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -372,9 +372,10 @@ pub fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n         match br.pats[col].node {\n             ast::pat_ident(_, path, Some(inner)) => {\n                 let pats = vec::append(\n-                    vec::slice(br.pats, 0u, col),\n+                    vec::slice(br.pats, 0u, col).to_vec(),\n                     vec::append(~[inner],\n-                                vec::view(br.pats, col + 1u, br.pats.len())));\n+                                vec::slice(br.pats, col + 1u,\n+                                           br.pats.len())));\n \n                 let binding_info =\n                     br.data.bindings_map.get(&path_to_ident(path));\n@@ -416,8 +417,8 @@ pub fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n             Some(sub) => {\n                 let pats =\n                     vec::append(\n-                        vec::append(sub, vec::view(br.pats, 0u, col)),\n-                        vec::view(br.pats, col + 1u, br.pats.len()));\n+                        vec::append(sub, vec::slice(br.pats, 0u, col)),\n+                        vec::slice(br.pats, col + 1u, br.pats.len()));\n \n                 let self = br.pats[col];\n                 match self.node {\n@@ -1242,7 +1243,7 @@ pub fn compile_submatch(bcx: block,\n         match data.arm.guard {\n             Some(guard_expr) => {\n                 bcx = compile_guard(bcx, guard_expr, m[0].data,\n-                                    vec::view(m, 1, m.len()),\n+                                    vec::slice(m, 1, m.len()),\n                                     vals, chk);\n             }\n             _ => ()\n@@ -1261,8 +1262,8 @@ pub fn compile_submatch(bcx: block,\n         }\n     };\n \n-    let vals_left = vec::append(vec::slice(vals, 0u, col),\n-                                vec::view(vals, col + 1u, vals.len()));\n+    let vals_left = vec::append(vec::slice(vals, 0u, col).to_vec(),\n+                                vec::slice(vals, col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n     for vec::each(m) |br| {"}, {"sha": "606a318523b4766e20bcc28edc980bc3b81cd1a4", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -484,8 +484,8 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n             });\n         for cleanup_pos.each |i| {\n             scope_info.cleanups =\n-                vec::append(vec::slice(scope_info.cleanups, 0u, *i),\n-                            vec::view(scope_info.cleanups,\n+                vec::append(vec::slice(scope_info.cleanups, 0u, *i).to_vec(),\n+                            vec::slice(scope_info.cleanups,\n                                       *i + 1u,\n                                       scope_info.cleanups.len()));\n             scope_clean_changed(scope_info);"}, {"sha": "bc4ec8c07c29165685d0764520d425afeb80c1d2", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -561,7 +561,7 @@ pub fn combine_impl_and_methods_origins(bcx: block,\n     let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n     let {bounds: r_m_bounds, _} = ty::lookup_item_type(tcx, mth_did);\n     let n_r_m_tps = r_m_bounds.len(); // rcvr + method tps\n-    let m_boundss = vec::view(*r_m_bounds, n_r_m_tps - n_m_tps, n_r_m_tps);\n+    let m_boundss = vec::slice(*r_m_bounds, n_r_m_tps - n_m_tps, n_r_m_tps);\n \n     // Flatten out to find the number of vtables the method expects.\n     let m_vtables = ty::count_traits_and_supertraits(tcx, m_boundss);"}, {"sha": "dead9ca58fc87762c80b7bfba17f31e2800d1665", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -351,7 +351,7 @@ fn run_line(repl: &mut Repl, in: io::Reader, out: io::Writer, line: ~str)\n \n             if !cmd.is_empty() {\n                 let args = if len > 1 {\n-                    vec::slice(split, 1, len)\n+                    vec::slice(split, 1, len).to_vec()\n                 } else { ~[] };\n \n                 match run_cmd(repl, in, out, cmd, args) {"}, {"sha": "23a4769775c007f580456c37e0e8e90eb8e5d789", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -216,8 +216,9 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         pure fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = uint::min(a.data.len(), n);\n-            return (BigUint::from_slice(vec::view(a.data, mid, a.data.len())),\n-                    BigUint::from_slice(vec::view(a.data, 0, mid)));\n+            return (BigUint::from_slice(vec::slice(a.data, mid,\n+                                                   a.data.len())),\n+                    BigUint::from_slice(vec::slice(a.data, 0, mid)));\n         }\n \n         pure fn sub_sign(a: BigUint, b: BigUint) -> (int, BigUint) {\n@@ -301,7 +302,7 @@ pub impl BigUint {\n         let mut power: BigUint  = One::one();\n         loop {\n             let start = uint::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(vec::view(buf, start, end), radix) {\n+            match uint::parse_bytes(vec::slice(buf, start, end), radix) {\n                 Some(d) => n += BigUint::from_uint(d) * power,\n                 None    => return None\n             }\n@@ -380,7 +381,7 @@ pub impl BigUint {\n                 return (Zero::zero(), Zero::zero(), copy *a);\n             }\n \n-            let an = vec::view(a.data, a.data.len() - n, a.data.len());\n+            let an = vec::slice(a.data, a.data.len() - n, a.data.len());\n             let bn = b.data.last();\n             let mut d = ~[];\n             let mut carry = 0;\n@@ -487,7 +488,7 @@ pub impl BigUint {\n         if n_unit == 0 { return self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n-            vec::view(self.data, n_unit, self.data.len())\n+            vec::slice(self.data, n_unit, self.data.len())\n         );\n     }\n \n@@ -770,7 +771,7 @@ pub impl BigInt {\n             sign  = Minus;\n             start = 1;\n         }\n-        return BigUint::parse_bytes(vec::view(buf, start, buf.len()), radix)\n+        return BigUint::parse_bytes(vec::slice(buf, start, buf.len()), radix)\n             .map(|bu| BigInt::from_biguint(sign, *bu));\n     }\n \n@@ -885,7 +886,7 @@ mod biguint_tests {\n         let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n             .map(|v| BigUint::from_slice(*v));\n         for data.eachi |i, ni| {\n-            for vec::view(data, i, data.len()).eachi |j0, nj| {\n+            for vec::slice(data, i, data.len()).eachi |j0, nj| {\n                 let j = j0 + i;\n                 if i == j {\n                     assert ni.cmp(nj) == 0;\n@@ -1298,7 +1299,7 @@ mod bigint_tests {\n         nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n \n         for nums.eachi |i, ni| {\n-            for vec::view(nums, i, nums.len()).eachi |j0, nj| {\n+            for vec::slice(nums, i, nums.len()).eachi |j0, nj| {\n                 let j = i + j0;\n                 if i == j {\n                     assert ni.cmp(nj) == 0;"}, {"sha": "84df1785503dcac42fde4959f8d94a1f31da1c1f", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -177,10 +177,12 @@ pub mod reader {\n         }\n     }\n \n-    pub fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start,\n-                                                        d.end) }\n+    pub fn doc_data(d: Doc) -> ~[u8] {\n+        vec::slice::<u8>(*d.data, d.start, d.end).to_vec()\n+    }\n+\n     pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n-        f(vec::view(*d.data, d.start, d.end))\n+        f(vec::slice(*d.data, d.start, d.end))\n     }\n \n     pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }"}, {"sha": "563bc1c203ae41832b0b47c3e89455f867b4c907", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -971,7 +971,8 @@ impl io::Writer for TcpSocketBuf {\n             let w_result = write_common_impl(socket_data_ptr,\n                                             vec::slice(data,\n                                                        0,\n-                                                       vec::len(data)));\n+                                                       vec::len(data)\n+                                                      ).to_vec());\n             if w_result.is_err() {\n                 let err_data = w_result.get_err();\n                 log(debug,"}, {"sha": "3450205aa9569d6ddb3adb55a1ab45ade19aa93e", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -195,12 +195,12 @@ pub fn tim_sort<T: Copy Ord>(array: &mut [T]) {\n     let mut idx = 0;\n     let mut remaining = size;\n     loop {\n-        let arr = vec::mut_view(array, idx, size);\n+        let arr = vec::mut_slice(array, idx, size);\n         let mut run_len: uint = count_run_ascending(arr);\n \n         if run_len < min_run {\n             let force = if remaining <= min_run {remaining} else {min_run};\n-            let slice = vec::mut_view(arr, 0, force);\n+            let slice = vec::mut_slice(arr, 0, force);\n             binarysort(slice, run_len);\n             run_len = force;\n         }\n@@ -431,12 +431,12 @@ impl<T: Copy Ord> MergeState<T> {\n                 arr[n+1].len = arr[n+2].len;\n             }\n \n-            let slice = vec::mut_view(array, b1, b1+l1);\n+            let slice = vec::mut_slice(array, b1, b1+l1);\n             let k = gallop_right(&const array[b2], slice, 0);\n             b1 += k;\n             l1 -= k;\n             if l1 != 0 {\n-                let slice = vec::mut_view(array, b2, b2+l2);\n+                let slice = vec::mut_slice(array, b2, b2+l2);\n                 let l2 = gallop_left(\n                     &const array[b1+l1-1],slice,l2-1);\n                 if l2 > 0 {\n@@ -455,7 +455,8 @@ impl<T: Copy Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n \n-        let mut tmp = vec::slice(array, base1, base1+len1);\n+        let tmp = vec::cast_to_mut(\n+            vec::slice(array, base1, base1+len1).to_vec());\n \n         let mut c1 = 0;\n         let mut c2 = base2;\n@@ -509,7 +510,7 @@ impl<T: Copy Ord> MergeState<T> {\n             loop {\n                 assert len1 > 1 && len2 != 0;\n \n-                let tmp_view = vec::const_view(tmp, c1, c1+len1);\n+                let tmp_view = vec::const_slice(tmp, c1, c1+len1);\n                 count1 = gallop_right(&const array[c2], tmp_view, 0);\n                 if count1 != 0 {\n                     copy_vec(array, dest, tmp, c1, count1);\n@@ -520,7 +521,7 @@ impl<T: Copy Ord> MergeState<T> {\n                 dest += 1; c2 += 1; len2 -= 1;\n                 if len2 == 0 { break_outer = true; break; }\n \n-                let tmp_view = vec::const_view(array, c2, c2+len2);\n+                let tmp_view = vec::const_slice(array, c2, c2+len2);\n                 count2 = gallop_left(&const tmp[c1], tmp_view, 0);\n                 if count2 != 0 {\n                     copy_vec(array, dest, array, c2, count2);\n@@ -558,7 +559,8 @@ impl<T: Copy Ord> MergeState<T> {\n                 base2: uint, len2: uint) {\n         assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n \n-        let mut tmp = vec::slice(array, base2, base2+len2);\n+        let tmp = vec::cast_to_mut(\n+            vec::slice(array, base2, base2+len2).to_vec());\n \n         let mut c1 = base1 + len1 - 1;\n         let mut c2 = len2 - 1;\n@@ -614,7 +616,7 @@ impl<T: Copy Ord> MergeState<T> {\n             loop {\n                 assert len2 > 1 && len1 != 0;\n \n-                let tmp_view = vec::mut_view(array, base1, base1+len1);\n+                let tmp_view = vec::mut_slice(array, base1, base1+len1);\n                 count1 = len1 - gallop_right(\n                     &const tmp[c2], tmp_view, len1-1);\n \n@@ -630,7 +632,7 @@ impl<T: Copy Ord> MergeState<T> {\n \n                 let count2;\n                 {\n-                    let tmp_view = vec::mut_view(tmp, 0, len2);\n+                    let tmp_view = vec::mut_slice(tmp, 0, len2);\n                     count2 = len2 - gallop_left(&const array[c1],\n                                                 tmp_view,\n                                                 len2-1);\n@@ -710,7 +712,7 @@ fn copy_vec<T: Copy>(dest: &mut [T], s1: uint,\n                     from: &[const T], s2: uint, len: uint) {\n     assert s1+len <= dest.len() && s2+len <= from.len();\n \n-    let slice = vec::slice(from, s2, s2+len);\n+    let slice = vec::slice(from, s2, s2+len).to_vec();\n     for slice.eachi |i, v| {\n         dest[s1+i] = *v;\n     }\n@@ -1087,7 +1089,7 @@ mod big_tests {\n             isSorted(arr);\n \n             let mut arr = if n > 4 {\n-                let part = vec::view(arr, 0, 4);\n+                let part = vec::slice(arr, 0, 4);\n                 multiplyVec(part, n)\n             } else { arr };\n             tim_sort(arr); // ~sort\n@@ -1159,7 +1161,7 @@ mod big_tests {\n             isSorted(arr);\n \n             let mut arr = if n > 4 {\n-                let part = vec::view(arr, 0, 4);\n+                let part = vec::slice(arr, 0, 4);\n                 multiplyVec(part, n)\n             } else { arr };\n             tim_sort(arr); // ~sort"}, {"sha": "ad0998d503a3642dd94733c05fe2736c17327c97", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -231,7 +231,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     let mut elided = false;\n     let mut display_lines = /* FIXME (#2543) */ copy lines.lines;\n     if vec::len(display_lines) > max_lines {\n-        display_lines = vec::slice(display_lines, 0u, max_lines);\n+        display_lines = vec::slice(display_lines, 0u, max_lines).to_vec();\n         elided = true;\n     }\n     // Print the offending lines"}, {"sha": "bd8757d51b74300168964852de6e7915dead7613", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -24,7 +24,7 @@ macro_rules! bench (\n \n fn main() {\n     let argv = os::args();\n-    let tests = vec::view(argv, 1, argv.len());\n+    let tests = vec::slice(argv, 1, argv.len());\n \n     bench!(shift_push);\n     bench!(read_line);"}, {"sha": "78ae31570b335d555ba4e30ac793de131a915162", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -77,7 +77,7 @@ fn find(mm: HashMap<~[u8], uint>, key: ~str) -> uint {\n \n // given a map, increment the counter for a key\n fn update_freq(mm: HashMap<~[u8], uint>, key: &[u8]) {\n-    let key = vec::slice(key, 0, key.len());\n+    let key = vec::slice(key, 0, key.len()).to_vec();\n     mm.update(key, 1, |v,v1| { v+v1 });\n }\n \n@@ -90,11 +90,11 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n \n    let len = vec::len(bb);\n    while ii < len - (nn - 1u) {\n-      it(vec::view(bb, ii, ii+nn));\n+      it(vec::slice(bb, ii, ii+nn));\n       ii += 1u;\n    }\n \n-   return vec::slice(bb, len - (nn - 1u), len);\n+   return vec::slice(bb, len - (nn - 1u), len).to_vec();\n }\n \n fn make_sequence_processor(sz: uint, from_parent: pipes::Port<~[u8]>,"}, {"sha": "06e652cc7cd558946d868538f75765f3cd1974cb", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/566bcf2225634ee4d4698247fe89364440eb534c/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/566bcf2225634ee4d4698247fe89364440eb534c/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=566bcf2225634ee4d4698247fe89364440eb534c", "patch": "@@ -10,8 +10,8 @@\n \n fn vec_peek<T>(v: &r/[T]) -> &r/[T] {\n // This doesn't work, and should.\n-//    v.view(1, 5)\n-    vec::view(v, 1, 5)\n+//    v.slice(1, 5)\n+    vec::slice(v, 1, 5)\n }\n \n pub fn main() {}"}]}