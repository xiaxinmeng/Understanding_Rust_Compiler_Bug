{"sha": "b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYjE5ZWM5MmUyMzNiN2Y5MTYxN2U0Y2MyMTMwZTcwZDZlN2E1ZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-12T11:10:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-12T11:10:37Z"}, "message": "Auto merge of #42897 - Mark-Simulacrum:pretty-print-refactor, r=jseyfried\n\nRefactor pretty printing slightly\n\nThis doesn't introduce any functional changes (that I'm aware of). The primary intention here is to clean up the code a little. Each commit is intended to stand alone, reviewing commit-by-commit may be easiest.", "tree": {"sha": "0472e7d9331814166b4e260196600884d861f60b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0472e7d9331814166b4e260196600884d861f60b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd", "html_url": "https://github.com/rust-lang/rust/commit/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bba5ad3098e3f20ab3c506e5a421df5da010df9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bba5ad3098e3f20ab3c506e5a421df5da010df9", "html_url": "https://github.com/rust-lang/rust/commit/8bba5ad3098e3f20ab3c506e5a421df5da010df9"}, {"sha": "40f03a1e0d6702add1922f82d716d5b2c23a59f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/40f03a1e0d6702add1922f82d716d5b2c23a59f0", "html_url": "https://github.com/rust-lang/rust/commit/40f03a1e0d6702add1922f82d716d5b2c23a59f0"}], "stats": {"total": 1220, "additions": 596, "deletions": 624}, "files": [{"sha": "beaf65b77d81f6a821cf92c63f71345cdb2a9f4f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 202, "deletions": 205, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd", "patch": "@@ -15,10 +15,9 @@ use syntax::ast;\n use syntax::codemap::{CodeMap, Spanned};\n use syntax::parse::ParseSess;\n use syntax::parse::lexer::comments;\n-use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n-use syntax::print::pp::{Breaks, eof};\n+use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n-use syntax::print::pprust::{self as ast_pp, PrintState};\n+use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::{self, BytePos};\n@@ -28,6 +27,8 @@ use hir::{PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier, Ra\n \n use std::cell::Cell;\n use std::io::{self, Write, Read};\n+use std::iter::Peekable;\n+use std::vec;\n \n pub enum AnnNode<'a> {\n     NodeName(&'a ast::Name),\n@@ -78,8 +79,8 @@ pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a CodeMap>,\n     comments: Option<Vec<comments::Comment>>,\n-    literals: Option<Vec<comments::Literal>>,\n-    cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral,\n+    literals: Peekable<vec::IntoIter<comments::Literal>>,\n+    cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n     ann: &'a (PpAnn + 'a),\n }\n@@ -97,12 +98,16 @@ impl<'a> PrintState<'a> for State<'a> {\n         &mut self.comments\n     }\n \n-    fn cur_cmnt_and_lit(&mut self) -> &mut ast_pp::CurrentCommentAndLiteral {\n-        &mut self.cur_cmnt_and_lit\n+    fn cur_cmnt(&mut self) -> &mut usize {\n+        &mut self.cur_cmnt\n     }\n \n-    fn literals(&self) -> &Option<Vec<comments::Literal>> {\n-        &self.literals\n+    fn cur_lit(&mut self) -> Option<&comments::Literal> {\n+        self.literals.peek()\n+    }\n+\n+    fn bump_lit(&mut self) -> Option<comments::Literal> {\n+        self.literals.next()\n     }\n }\n \n@@ -132,7 +137,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n \n     s.print_mod(&krate.module, &krate.attrs)?;\n     s.print_remaining_comments()?;\n-    eof(&mut s.s)\n+    s.s.eof()\n }\n \n impl<'a> State<'a> {\n@@ -170,11 +175,8 @@ impl<'a> State<'a> {\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n             comments: comments.clone(),\n-            literals: literals.clone(),\n-            cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral {\n-                cur_cmnt: 0,\n-                cur_lit: 0,\n-            },\n+            literals: literals.unwrap_or_default().into_iter().peekable(),\n+            cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n         }\n@@ -190,24 +192,21 @@ pub fn to_string<F>(ann: &PpAnn, f: F) -> String\n             s: pp::mk_printer(Box::new(&mut wr), default_columns),\n             cm: None,\n             comments: None,\n-            literals: None,\n-            cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral {\n-                cur_cmnt: 0,\n-                cur_lit: 0,\n-            },\n+            literals: vec![].into_iter().peekable(),\n+            cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann,\n         };\n         f(&mut printer).unwrap();\n-        eof(&mut printer.s).unwrap();\n+        printer.s.eof().unwrap();\n     }\n     String::from_utf8(wr).unwrap()\n }\n \n pub fn visibility_qualified(vis: &hir::Visibility, w: &str) -> String {\n     to_string(NO_ANN, |s| {\n         s.print_visibility(vis)?;\n-        word(&mut s.s, w)\n+        s.s.word(w)\n     })\n }\n \n@@ -226,15 +225,15 @@ fn needs_parentheses(expr: &hir::Expr) -> bool {\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes.push(pp::Breaks::Consistent);\n-        pp::cbox(&mut self.s, u)\n+        self.s.cbox(u)\n     }\n \n     pub fn nbsp(&mut self) -> io::Result<()> {\n-        word(&mut self.s, \" \")\n+        self.s.word(\" \")\n     }\n \n     pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n-        word(&mut self.s, w)?;\n+        self.s.word(w)?;\n         self.nbsp()\n     }\n \n@@ -251,7 +250,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn bopen(&mut self) -> io::Result<()> {\n-        word(&mut self.s, \"{\")?;\n+        self.s.word(\"{\")?;\n         self.end() // close the head-box\n     }\n \n@@ -265,7 +264,7 @@ impl<'a> State<'a> {\n                              -> io::Result<()> {\n         self.maybe_print_comment(span.hi)?;\n         self.break_offset_if_not_bol(1, -(indented as isize))?;\n-        word(&mut self.s, \"}\")?;\n+        self.s.word(\"}\")?;\n         if close_box {\n             self.end()?; // close the outer-box\n         }\n@@ -283,19 +282,19 @@ impl<'a> State<'a> {\n     }\n     pub fn space_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n         }\n         Ok(())\n     }\n     pub fn break_offset_if_not_bol(&mut self, n: usize, off: isize) -> io::Result<()> {\n         if !self.is_bol() {\n-            break_offset(&mut self.s, n, off)\n+            self.s.break_offset(n, off)\n         } else {\n             if off != 0 && self.s.last_token().is_hardbreak_tok() {\n                 // We do something pretty sketchy here: tuck the nonzero\n                 // offset-adjustment we were going to deposit along with the\n                 // break into the previous hardbreak.\n-                self.s.replace_last_token(pp::hardbreak_tok_offset(off));\n+                self.s.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n             }\n             Ok(())\n         }\n@@ -304,11 +303,11 @@ impl<'a> State<'a> {\n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n     pub fn synth_comment(&mut self, text: String) -> io::Result<()> {\n-        word(&mut self.s, \"/*\")?;\n-        space(&mut self.s)?;\n-        word(&mut self.s, &text[..])?;\n-        space(&mut self.s)?;\n-        word(&mut self.s, \"*/\")\n+        self.s.word(\"/*\")?;\n+        self.s.space()?;\n+        self.s.word(&text[..])?;\n+        self.s.space()?;\n+        self.s.word(\"*/\")\n     }\n \n \n@@ -329,7 +328,7 @@ impl<'a> State<'a> {\n             op(self, elt)?;\n             i += 1;\n             if i < len {\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n                 self.maybe_print_trailing_comment(get_span(elt), Some(get_span(&elts[i]).hi))?;\n                 self.space_if_not_bol()?;\n             }\n@@ -373,31 +372,31 @@ impl<'a> State<'a> {\n         self.ibox(0)?;\n         match ty.node {\n             hir::TySlice(ref ty) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_type(&ty)?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             hir::TyPtr(ref mt) => {\n-                word(&mut self.s, \"*\")?;\n+                self.s.word(\"*\")?;\n                 match mt.mutbl {\n                     hir::MutMutable => self.word_nbsp(\"mut\")?,\n                     hir::MutImmutable => self.word_nbsp(\"const\")?,\n                 }\n                 self.print_type(&mt.ty)?;\n             }\n             hir::TyRptr(ref lifetime, ref mt) => {\n-                word(&mut self.s, \"&\")?;\n+                self.s.word(\"&\")?;\n                 self.print_opt_lifetime(lifetime)?;\n                 self.print_mt(mt)?;\n             }\n             hir::TyNever => {\n-                word(&mut self.s, \"!\")?;\n+                self.s.word(\"!\")?;\n             },\n             hir::TyTup(ref elts) => {\n                 self.popen()?;\n                 self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&ty))?;\n                 if elts.len() == 1 {\n-                    word(&mut self.s, \",\")?;\n+                    self.s.word(\",\")?;\n                 }\n                 self.pclose()?;\n             }\n@@ -436,22 +435,22 @@ impl<'a> State<'a> {\n                 self.print_bounds(\"impl \", &bounds[..])?;\n             }\n             hir::TyArray(ref ty, v) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_type(&ty)?;\n-                word(&mut self.s, \"; \")?;\n+                self.s.word(\"; \")?;\n                 self.ann.nested(self, Nested::Body(v))?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             hir::TyTypeof(e) => {\n-                word(&mut self.s, \"typeof(\")?;\n+                self.s.word(\"typeof(\")?;\n                 self.ann.nested(self, Nested::Body(e))?;\n-                word(&mut self.s, \")\")?;\n+                self.s.word(\")\")?;\n             }\n             hir::TyInfer => {\n-                word(&mut self.s, \"_\")?;\n+                self.s.word(\"_\")?;\n             }\n             hir::TyErr => {\n-                word(&mut self.s, \"?\")?;\n+                self.s.word(\"?\")?;\n             }\n         }\n         self.end()\n@@ -474,7 +473,7 @@ impl<'a> State<'a> {\n                               arg_names,\n                               None)?;\n                 self.end()?; // end head-ibox\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemStatic(ref t, m) => {\n@@ -485,7 +484,7 @@ impl<'a> State<'a> {\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&t)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the head-ibox\n                 self.end() // end the outer cbox\n             }\n@@ -498,17 +497,17 @@ impl<'a> State<'a> {\n                               default: Option<hir::BodyId>,\n                               vis: &hir::Visibility)\n                               -> io::Result<()> {\n-        word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n+        self.s.word(&visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n         self.print_name(name)?;\n         self.word_space(\":\")?;\n         self.print_type(ty)?;\n         if let Some(expr) = default {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"=\")?;\n             self.ann.nested(self, Nested::Body(expr))?;\n         }\n-        word(&mut self.s, \";\")\n+        self.s.word(\";\")\n     }\n \n     fn print_associated_type(&mut self,\n@@ -522,11 +521,11 @@ impl<'a> State<'a> {\n             self.print_bounds(\":\", bounds)?;\n         }\n         if let Some(ty) = ty {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"=\")?;\n             self.print_type(ty)?;\n         }\n-        word(&mut self.s, \";\")\n+        self.s.word(\";\")\n     }\n \n     /// Pretty-print an item\n@@ -545,12 +544,12 @@ impl<'a> State<'a> {\n                     } else {\n                         self.print_name(p)?;\n                     }\n-                    space(&mut self.s)?;\n-                    word(&mut self.s, \"as\")?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n+                    self.s.word(\"as\")?;\n+                    self.s.space()?;\n                 }\n                 self.print_name(item.name)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n@@ -561,14 +560,14 @@ impl<'a> State<'a> {\n                 match kind {\n                     hir::UseKind::Single => {\n                         if path.segments.last().unwrap().name != item.name {\n-                            space(&mut self.s)?;\n+                            self.s.space()?;\n                             self.word_space(\"as\")?;\n                             self.print_name(item.name)?;\n                         }\n-                        word(&mut self.s, \";\")?;\n+                        self.s.word(\";\")?;\n                     }\n-                    hir::UseKind::Glob => word(&mut self.s, \"::*;\")?,\n-                    hir::UseKind::ListStem => word(&mut self.s, \"::{};\")?\n+                    hir::UseKind::Glob => self.s.word(\"::*;\")?,\n+                    hir::UseKind::ListStem => self.s.word(\"::{};\")?\n                 }\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n@@ -581,25 +580,25 @@ impl<'a> State<'a> {\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n                 self.ann.nested(self, Nested::Body(expr))?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n             hir::ItemConst(ref ty, expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n                 self.ann.nested(self, Nested::Body(expr))?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n             hir::ItemFn(ref decl, unsafety, constness, abi, ref typarams, body) => {\n@@ -613,7 +612,7 @@ impl<'a> State<'a> {\n                               &item.vis,\n                               &[],\n                               Some(body))?;\n-                word(&mut self.s, \" \")?;\n+                self.s.word(\" \")?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n                 self.ann.nested(self, Nested::Body(body))?;\n@@ -635,7 +634,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemGlobalAsm(ref ga) => {\n                 self.head(&visibility_qualified(&item.vis, \"global asm\"))?;\n-                word(&mut self.s, &ga.asm.as_str())?;\n+                self.s.word(&ga.asm.as_str())?;\n                 self.end()?\n             }\n             hir::ItemTy(ref ty, ref params) => {\n@@ -647,10 +646,10 @@ impl<'a> State<'a> {\n                 self.end()?; // end the inner ibox\n \n                 self.print_where_clause(&params.where_clause)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(&ty)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n             hir::ItemEnum(ref enum_definition, ref params) => {\n@@ -670,7 +669,7 @@ impl<'a> State<'a> {\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n                 self.print_trait_ref(trait_ref)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"for\")?;\n                 self.word_space(\"..\")?;\n                 self.bopen()?;\n@@ -691,20 +690,20 @@ impl<'a> State<'a> {\n \n                 if generics.is_parameterized() {\n                     self.print_generics(generics)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n \n                 match polarity {\n                     hir::ImplPolarity::Negative => {\n-                        word(&mut self.s, \"!\")?;\n+                        self.s.word(\"!\")?;\n                     }\n                     _ => {}\n                 }\n \n                 match opt_trait {\n                     &Some(ref t) => {\n                         self.print_trait_ref(t)?;\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.word_space(\"for\")?;\n                     }\n                     &None => {}\n@@ -713,7 +712,7 @@ impl<'a> State<'a> {\n                 self.print_type(&ty)?;\n                 self.print_where_clause(&generics.where_clause)?;\n \n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.bopen()?;\n                 self.print_inner_attributes(&item.attrs)?;\n                 for impl_item in impl_items {\n@@ -731,7 +730,7 @@ impl<'a> State<'a> {\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n                     if let TraitTyParamBound(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n@@ -740,7 +739,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_bounds(\":\", &real_bounds[..])?;\n                 self.print_where_clause(&generics.where_clause)?;\n-                word(&mut self.s, \" \")?;\n+                self.s.word(\" \")?;\n                 self.bopen()?;\n                 for trait_item in trait_items {\n                     self.ann.nested(self, Nested::TraitItem(trait_item.id))?;\n@@ -757,7 +756,7 @@ impl<'a> State<'a> {\n \n     fn print_formal_lifetime_list(&mut self, lifetimes: &[hir::LifetimeDef]) -> io::Result<()> {\n         if !lifetimes.is_empty() {\n-            word(&mut self.s, \"for<\")?;\n+            self.s.word(\"for<\")?;\n             let mut comma = false;\n             for lifetime_def in lifetimes {\n                 if comma {\n@@ -766,7 +765,7 @@ impl<'a> State<'a> {\n                 self.print_lifetime_def(lifetime_def)?;\n                 comma = true;\n             }\n-            word(&mut self.s, \">\")?;\n+            self.s.word(\">\")?;\n         }\n         Ok(())\n     }\n@@ -787,7 +786,7 @@ impl<'a> State<'a> {\n         self.print_name(name)?;\n         self.print_generics(generics)?;\n         self.print_where_clause(&generics.where_clause)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_variants(&enum_definition.variants, span)\n     }\n \n@@ -802,7 +801,7 @@ impl<'a> State<'a> {\n             self.print_outer_attributes(&v.node.attrs)?;\n             self.ibox(indent_unit)?;\n             self.print_variant(v)?;\n-            word(&mut self.s, \",\")?;\n+            self.s.word(\",\")?;\n             self.end()?;\n             self.maybe_print_trailing_comment(v.span, None)?;\n         }\n@@ -814,7 +813,7 @@ impl<'a> State<'a> {\n             hir::Public => self.word_nbsp(\"pub\"),\n             hir::Visibility::Crate => self.word_nbsp(\"pub(crate)\"),\n             hir::Visibility::Restricted { ref path, .. } => {\n-                word(&mut self.s, \"pub(\")?;\n+                self.s.word(\"pub(\")?;\n                 self.print_path(path, false)?;\n                 self.word_nbsp(\")\")\n             }\n@@ -852,7 +851,7 @@ impl<'a> State<'a> {\n             }\n             self.print_where_clause(&generics.where_clause)?;\n             if print_finalizer {\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n             }\n             self.end()?;\n             self.end() // close the outer-box\n@@ -870,7 +869,7 @@ impl<'a> State<'a> {\n                 self.print_name(field.name)?;\n                 self.word_nbsp(\":\")?;\n                 self.print_type(&field.ty)?;\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n             }\n \n             self.bclose(span)\n@@ -882,7 +881,7 @@ impl<'a> State<'a> {\n         let generics = hir::Generics::empty();\n         self.print_struct(&v.node.data, &generics, v.node.name, v.span, false)?;\n         if let Some(d) = v.node.disr_expr {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"=\")?;\n             self.ann.nested(self, Nested::Body(d))?;\n         }\n@@ -917,7 +916,7 @@ impl<'a> State<'a> {\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref arg_names)) => {\n                 self.print_method_sig(ti.name, sig, &hir::Inherited, arg_names, None)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n                 self.head(\"\")?;\n@@ -975,11 +974,11 @@ impl<'a> State<'a> {\n             hir::StmtSemi(ref expr, _) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr(&expr)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n             }\n         }\n         if stmt_ends_with_semi(&st.node) {\n-            word(&mut self.s, \";\")?;\n+            self.s.word(\";\")?;\n         }\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n@@ -1047,17 +1046,17 @@ impl<'a> State<'a> {\n                     hir::ExprIf(ref i, ref then, ref e) => {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n-                        word(&mut self.s, \" else if \")?;\n+                        self.s.word(\" else if \")?;\n                         self.print_expr(&i)?;\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.print_expr(&then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n                     hir::ExprBlock(ref b) => {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n-                        word(&mut self.s, \" else \")?;\n+                        self.s.word(\" else \")?;\n                         self.print_block(&b)\n                     }\n                     // BLEAH, constraints would be great here\n@@ -1077,7 +1076,7 @@ impl<'a> State<'a> {\n                     -> io::Result<()> {\n         self.head(\"if\")?;\n         self.print_expr(test)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_expr(blk)?;\n         self.print_else(elseopt)\n     }\n@@ -1090,10 +1089,10 @@ impl<'a> State<'a> {\n                         -> io::Result<()> {\n         self.head(\"if let\")?;\n         self.print_pat(pat)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"=\")?;\n         self.print_expr(expr)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n     }\n@@ -1119,19 +1118,19 @@ impl<'a> State<'a> {\n \n     fn print_expr_vec(&mut self, exprs: &[hir::Expr]) -> io::Result<()> {\n         self.ibox(indent_unit)?;\n-        word(&mut self.s, \"[\")?;\n+        self.s.word(\"[\")?;\n         self.commasep_exprs(Inconsistent, exprs)?;\n-        word(&mut self.s, \"]\")?;\n+        self.s.word(\"]\")?;\n         self.end()\n     }\n \n     fn print_expr_repeat(&mut self, element: &hir::Expr, count: hir::BodyId) -> io::Result<()> {\n         self.ibox(indent_unit)?;\n-        word(&mut self.s, \"[\")?;\n+        self.s.word(\"[\")?;\n         self.print_expr(element)?;\n         self.word_space(\";\")?;\n         self.ann.nested(self, Nested::Body(count))?;\n-        word(&mut self.s, \"]\")?;\n+        self.s.word(\"]\")?;\n         self.end()\n     }\n \n@@ -1141,7 +1140,7 @@ impl<'a> State<'a> {\n                          wth: &Option<P<hir::Expr>>)\n                          -> io::Result<()> {\n         self.print_qpath(qpath, true)?;\n-        word(&mut self.s, \"{\")?;\n+        self.s.word(\"{\")?;\n         self.commasep_cmnt(Consistent,\n                            &fields[..],\n                            |s, field| {\n@@ -1158,26 +1157,26 @@ impl<'a> State<'a> {\n             Some(ref expr) => {\n                 self.ibox(indent_unit)?;\n                 if !fields.is_empty() {\n-                    word(&mut self.s, \",\")?;\n-                    space(&mut self.s)?;\n+                    self.s.word(\",\")?;\n+                    self.s.space()?;\n                 }\n-                word(&mut self.s, \"..\")?;\n+                self.s.word(\"..\")?;\n                 self.print_expr(&expr)?;\n                 self.end()?;\n             }\n             _ => if !fields.is_empty() {\n-                word(&mut self.s, \",\")?\n+                self.s.word(\",\")?\n             },\n         }\n-        word(&mut self.s, \"}\")?;\n+        self.s.word(\"}\")?;\n         Ok(())\n     }\n \n     fn print_expr_tup(&mut self, exprs: &[hir::Expr]) -> io::Result<()> {\n         self.popen()?;\n         self.commasep_exprs(Inconsistent, exprs)?;\n         if exprs.len() == 1 {\n-            word(&mut self.s, \",\")?;\n+            self.s.word(\",\")?;\n         }\n         self.pclose()\n     }\n@@ -1193,7 +1192,7 @@ impl<'a> State<'a> {\n                               -> io::Result<()> {\n         let base_args = &args[1..];\n         self.print_expr(&args[0])?;\n-        word(&mut self.s, \".\")?;\n+        self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n         if !segment.parameters.lifetimes().is_empty() ||\n                 !segment.parameters.types().is_empty() ||\n@@ -1209,21 +1208,21 @@ impl<'a> State<'a> {\n                          rhs: &hir::Expr)\n                          -> io::Result<()> {\n         self.print_expr(lhs)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(op.node.as_str())?;\n         self.print_expr(rhs)\n     }\n \n     fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr) -> io::Result<()> {\n-        word(&mut self.s, op.as_str())?;\n+        self.s.word(op.as_str())?;\n         self.print_expr_maybe_paren(expr)\n     }\n \n     fn print_expr_addr_of(&mut self,\n                           mutability: hir::Mutability,\n                           expr: &hir::Expr)\n                           -> io::Result<()> {\n-        word(&mut self.s, \"&\")?;\n+        self.s.word(\"&\")?;\n         self.print_mutability(mutability)?;\n         self.print_expr_maybe_paren(expr)\n     }\n@@ -1270,7 +1269,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprCast(ref expr, ref ty) => {\n                 self.print_expr(&expr)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(&ty)?;\n             }\n@@ -1289,7 +1288,7 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr(&test)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n             hir::ExprLoop(ref blk, opt_sp_name, _) => {\n@@ -1298,15 +1297,15 @@ impl<'a> State<'a> {\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n             hir::ExprMatch(ref expr, ref arms, _) => {\n                 self.cbox(indent_unit)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n                 self.print_expr(&expr)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.bopen()?;\n                 for arm in arms {\n                     self.print_arm(arm)?;\n@@ -1317,7 +1316,7 @@ impl<'a> State<'a> {\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_closure_args(&decl, body)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n \n                 // this is a bare expression\n                 self.ann.nested(self, Nested::Body(body))?;\n@@ -1337,68 +1336,68 @@ impl<'a> State<'a> {\n             }\n             hir::ExprAssign(ref lhs, ref rhs) => {\n                 self.print_expr(&lhs)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(&rhs)?;\n             }\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 self.print_expr(&lhs)?;\n-                space(&mut self.s)?;\n-                word(&mut self.s, op.node.as_str())?;\n+                self.s.space()?;\n+                self.s.word(op.node.as_str())?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(&rhs)?;\n             }\n             hir::ExprField(ref expr, name) => {\n                 self.print_expr(&expr)?;\n-                word(&mut self.s, \".\")?;\n+                self.s.word(\".\")?;\n                 self.print_name(name.node)?;\n             }\n             hir::ExprTupField(ref expr, id) => {\n                 self.print_expr(&expr)?;\n-                word(&mut self.s, \".\")?;\n+                self.s.word(\".\")?;\n                 self.print_usize(id.node)?;\n             }\n             hir::ExprIndex(ref expr, ref index) => {\n                 self.print_expr(&expr)?;\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_expr(&index)?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             hir::ExprPath(ref qpath) => {\n                 self.print_qpath(qpath, true)?\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n-                word(&mut self.s, \"break\")?;\n-                space(&mut self.s)?;\n+                self.s.word(\"break\")?;\n+                self.s.space()?;\n                 if let Some(label_ident) = label.ident {\n                     self.print_name(label_ident.node.name)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr(expr)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n             }\n             hir::ExprAgain(label) => {\n-                word(&mut self.s, \"continue\")?;\n-                space(&mut self.s)?;\n+                self.s.word(\"continue\")?;\n+                self.s.space()?;\n                 if let Some(label_ident) = label.ident {\n                     self.print_name(label_ident.node.name)?;\n-                    space(&mut self.s)?\n+                    self.s.space()?\n                 }\n             }\n             hir::ExprRet(ref result) => {\n-                word(&mut self.s, \"return\")?;\n+                self.s.word(\"return\")?;\n                 match *result {\n                     Some(ref expr) => {\n-                        word(&mut self.s, \" \")?;\n+                        self.s.word(\" \")?;\n                         self.print_expr(&expr)?;\n                     }\n                     _ => (),\n                 }\n             }\n             hir::ExprInlineAsm(ref a, ref outputs, ref inputs) => {\n-                word(&mut self.s, \"asm!\")?;\n+                self.s.word(\"asm!\")?;\n                 self.popen()?;\n                 self.print_string(&a.asm.as_str(), a.asm_str_style)?;\n                 self.word_space(\":\")?;\n@@ -1420,7 +1419,7 @@ impl<'a> State<'a> {\n                     out_idx += 1;\n                     Ok(())\n                 })?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\":\")?;\n \n                 let mut in_idx = 0;\n@@ -1432,7 +1431,7 @@ impl<'a> State<'a> {\n                     in_idx += 1;\n                     Ok(())\n                 })?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\":\")?;\n \n                 self.commasep(Inconsistent, &a.clobbers, |s, co| {\n@@ -1452,7 +1451,7 @@ impl<'a> State<'a> {\n                 }\n \n                 if !options.is_empty() {\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\":\")?;\n                     self.commasep(Inconsistent, &options, |s, &co| {\n                         s.print_string(co, ast::StrStyle::Cooked)?;\n@@ -1501,17 +1500,17 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n-        word(&mut self.s, &i.to_string())\n+        self.s.word(&i.to_string())\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        word(&mut self.s, &name.as_str())?;\n+        self.s.word(&name.as_str())?;\n         self.ann.post(self, NodeName(&name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) -> io::Result<()> {\n         self.print_local_decl(loc)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"in\")?;\n         self.print_expr(coll)\n     }\n@@ -1524,7 +1523,7 @@ impl<'a> State<'a> {\n \n         for (i, segment) in path.segments.iter().enumerate() {\n             if i > 0 {\n-                word(&mut self.s, \"::\")?\n+                self.s.word(\"::\")?\n             }\n             if segment.name != keywords::CrateRoot.name() &&\n                segment.name != keywords::DollarCrate.name() {\n@@ -1545,14 +1544,14 @@ impl<'a> State<'a> {\n                 self.print_path(path, colons_before_params)\n             }\n             hir::QPath::Resolved(Some(ref qself), ref path) => {\n-                word(&mut self.s, \"<\")?;\n+                self.s.word(\"<\")?;\n                 self.print_type(qself)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"as\")?;\n \n                 for (i, segment) in path.segments[..path.segments.len() - 1].iter().enumerate() {\n                     if i > 0 {\n-                        word(&mut self.s, \"::\")?\n+                        self.s.word(\"::\")?\n                     }\n                     if segment.name != keywords::CrateRoot.name() &&\n                        segment.name != keywords::DollarCrate.name() {\n@@ -1561,17 +1560,17 @@ impl<'a> State<'a> {\n                     }\n                 }\n \n-                word(&mut self.s, \">\")?;\n-                word(&mut self.s, \"::\")?;\n+                self.s.word(\">\")?;\n+                self.s.word(\"::\")?;\n                 let item_segment = path.segments.last().unwrap();\n                 self.print_name(item_segment.name)?;\n                 self.print_path_parameters(&item_segment.parameters, colons_before_params)\n             }\n             hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n-                word(&mut self.s, \"<\")?;\n+                self.s.word(\"<\")?;\n                 self.print_type(qself)?;\n-                word(&mut self.s, \">\")?;\n-                word(&mut self.s, \"::\")?;\n+                self.s.word(\">\")?;\n+                self.s.word(\"::\")?;\n                 self.print_name(item_segment.name)?;\n                 self.print_path_parameters(&item_segment.parameters, colons_before_params)\n             }\n@@ -1589,7 +1588,7 @@ impl<'a> State<'a> {\n                 let start_or_comma = |this: &mut Self| {\n                     if empty.get() {\n                         empty.set(false);\n-                        word(&mut this.s, start)\n+                        this.s.word(start)\n                     } else {\n                         this.word_space(\",\")\n                     }\n@@ -1611,26 +1610,26 @@ impl<'a> State<'a> {\n                 // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n                 if data.infer_types && false {\n                     start_or_comma(self)?;\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                 }\n \n                 for binding in data.bindings.iter() {\n                     start_or_comma(self)?;\n                     self.print_name(binding.name)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"=\")?;\n                     self.print_type(&binding.ty)?;\n                 }\n \n                 if !empty.get() {\n-                    word(&mut self.s, \">\")?\n+                    self.s.word(\">\")?\n                 }\n             }\n \n             hir::ParenthesizedParameters(ref data) => {\n-                word(&mut self.s, \"(\")?;\n+                self.s.word(\"(\")?;\n                 self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&ty))?;\n-                word(&mut self.s, \")\")?;\n+                self.s.word(\")\")?;\n \n                 if let Some(ref ty) = data.output {\n                     self.space_if_not_bol()?;\n@@ -1649,7 +1648,7 @@ impl<'a> State<'a> {\n         // Pat isn't normalized, but the beauty of it\n         // is that it doesn't matter\n         match pat.node {\n-            PatKind::Wild => word(&mut self.s, \"_\")?,\n+            PatKind::Wild => self.s.word(\"_\")?,\n             PatKind::Binding(binding_mode, _, ref path1, ref sub) => {\n                 match binding_mode {\n                     hir::BindByRef(mutbl) => {\n@@ -1663,7 +1662,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_name(path1.node)?;\n                 if let Some(ref p) = *sub {\n-                    word(&mut self.s, \"@\")?;\n+                    self.s.word(\"@\")?;\n                     self.print_pat(&p)?;\n                 }\n             }\n@@ -1675,9 +1674,9 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\")?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if ddpos != elts.len() {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n                     }\n                 } else {\n@@ -1708,10 +1707,10 @@ impl<'a> State<'a> {\n                     if !fields.is_empty() {\n                         self.word_space(\",\")?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                 }\n-                space(&mut self.s)?;\n-                word(&mut self.s, \"}\")?;\n+                self.s.space()?;\n+                self.s.word(\"}\")?;\n             }\n             PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen()?;\n@@ -1720,42 +1719,42 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\")?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if ddpos != elts.len() {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n                     }\n                 } else {\n                     self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n                     if elts.len() == 1 {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                     }\n                 }\n                 self.pclose()?;\n             }\n             PatKind::Box(ref inner) => {\n-                word(&mut self.s, \"box \")?;\n+                self.s.word(\"box \")?;\n                 self.print_pat(&inner)?;\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                word(&mut self.s, \"&\")?;\n+                self.s.word(\"&\")?;\n                 if mutbl == hir::MutMutable {\n-                    word(&mut self.s, \"mut \")?;\n+                    self.s.word(\"mut \")?;\n                 }\n                 self.print_pat(&inner)?;\n             }\n             PatKind::Lit(ref e) => self.print_expr(&e)?,\n             PatKind::Range(ref begin, ref end, ref end_kind) => {\n                 self.print_expr(&begin)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 match *end_kind {\n-                    RangeEnd::Included => word(&mut self.s, \"...\")?,\n-                    RangeEnd::Excluded => word(&mut self.s, \"..\")?,\n+                    RangeEnd::Included => self.s.word(\"...\")?,\n+                    RangeEnd::Excluded => self.s.word(\"..\")?,\n                 }\n                 self.print_expr(&end)?;\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&p))?;\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() {\n@@ -1764,13 +1763,13 @@ impl<'a> State<'a> {\n                     if p.node != PatKind::Wild {\n                         self.print_pat(&p)?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if !after.is_empty() {\n                         self.word_space(\",\")?;\n                     }\n                 }\n                 self.commasep(Inconsistent, &after[..], |s, p| s.print_pat(&p))?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n         }\n         self.ann.post(self, NodePat(pat))\n@@ -1780,7 +1779,7 @@ impl<'a> State<'a> {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n         if arm.attrs.is_empty() {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n         }\n         self.cbox(indent_unit)?;\n         self.ibox(0)?;\n@@ -1790,16 +1789,16 @@ impl<'a> State<'a> {\n             if first {\n                 first = false;\n             } else {\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"|\")?;\n             }\n             self.print_pat(&p)?;\n         }\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\")?;\n             self.print_expr(&e)?;\n-            space(&mut self.s)?;\n+            self.s.space()?;\n         }\n         self.word_space(\"=>\")?;\n \n@@ -1810,13 +1809,13 @@ impl<'a> State<'a> {\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let hir::UnsafeBlock(hir::UserProvided) = blk.rules {\n-                    word(&mut self.s, \",\")?;\n+                    self.s.word(\",\")?;\n                 }\n             }\n             _ => {\n                 self.end()?; // close the ibox for the pattern\n                 self.print_expr(&arm.body)?;\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n             }\n         }\n         self.end() // close enclosing cbox\n@@ -1848,20 +1847,20 @@ impl<'a> State<'a> {\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(indent_unit)?;\n             if let Some(name) = arg_names.get(i) {\n-                word(&mut s.s, &name.node.as_str())?;\n-                word(&mut s.s, \":\")?;\n-                space(&mut s.s)?;\n+                s.s.word(&name.node.as_str())?;\n+                s.s.word(\":\")?;\n+                s.s.space()?;\n             } else if let Some(body_id) = body_id {\n                 s.ann.nested(s, Nested::BodyArgPat(body_id, i))?;\n-                word(&mut s.s, \":\")?;\n-                space(&mut s.s)?;\n+                s.s.word(\":\")?;\n+                s.s.space()?;\n             }\n             i += 1;\n             s.print_type(ty)?;\n             s.end()\n         })?;\n         if decl.variadic {\n-            word(&mut self.s, \", ...\")?;\n+            self.s.word(\", ...\")?;\n         }\n         self.pclose()?;\n \n@@ -1870,7 +1869,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_closure_args(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) -> io::Result<()> {\n-        word(&mut self.s, \"|\")?;\n+        self.s.word(\"|\")?;\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(indent_unit)?;\n@@ -1879,13 +1878,13 @@ impl<'a> State<'a> {\n             i += 1;\n \n             if ty.node != hir::TyInfer {\n-                word(&mut s.s, \":\")?;\n-                space(&mut s.s)?;\n+                s.s.word(\":\")?;\n+                s.s.space()?;\n                 s.print_type(ty)?;\n             }\n             s.end()\n         })?;\n-        word(&mut self.s, \"|\")?;\n+        self.s.word(\"|\")?;\n \n         if let hir::DefaultReturn(..) = decl.output {\n             return Ok(());\n@@ -1911,7 +1910,7 @@ impl<'a> State<'a> {\n \n     pub fn print_bounds(&mut self, prefix: &str, bounds: &[hir::TyParamBound]) -> io::Result<()> {\n         if !bounds.is_empty() {\n-            word(&mut self.s, prefix)?;\n+            self.s.word(prefix)?;\n             let mut first = true;\n             for bound in bounds {\n                 self.nbsp()?;\n@@ -1926,7 +1925,7 @@ impl<'a> State<'a> {\n                         self.print_poly_trait_ref(tref)\n                     }\n                     TraitTyParamBound(ref tref, TraitBoundModifier::Maybe) => {\n-                        word(&mut self.s, \"?\")?;\n+                        self.s.word(\"?\")?;\n                         self.print_poly_trait_ref(tref)\n                     }\n                     RegionTyParamBound(ref lt) => {\n@@ -1948,7 +1947,7 @@ impl<'a> State<'a> {\n         self.print_lifetime(&lifetime.lifetime)?;\n         let mut sep = \":\";\n         for v in &lifetime.bounds {\n-            word(&mut self.s, sep)?;\n+            self.s.word(sep)?;\n             self.print_lifetime(v)?;\n             sep = \"+\";\n         }\n@@ -1961,7 +1960,7 @@ impl<'a> State<'a> {\n             return Ok(());\n         }\n \n-        word(&mut self.s, \"<\")?;\n+        self.s.word(\"<\")?;\n \n         let mut ints = Vec::new();\n         for i in 0..total {\n@@ -1979,7 +1978,7 @@ impl<'a> State<'a> {\n             }\n         })?;\n \n-        word(&mut self.s, \">\")?;\n+        self.s.word(\">\")?;\n         Ok(())\n     }\n \n@@ -1988,7 +1987,7 @@ impl<'a> State<'a> {\n         self.print_bounds(\":\", &param.bounds)?;\n         match param.default {\n             Some(ref default) => {\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(&default)\n             }\n@@ -2001,7 +2000,7 @@ impl<'a> State<'a> {\n             return Ok(());\n         }\n \n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"where\")?;\n \n         for (i, predicate) in where_clause.predicates.iter().enumerate() {\n@@ -2022,21 +2021,21 @@ impl<'a> State<'a> {\n                                                                                 ref bounds,\n                                                                                 ..}) => {\n                     self.print_lifetime(lifetime)?;\n-                    word(&mut self.s, \":\")?;\n+                    self.s.word(\":\")?;\n \n                     for (i, bound) in bounds.iter().enumerate() {\n                         self.print_lifetime(bound)?;\n \n                         if i != 0 {\n-                            word(&mut self.s, \":\")?;\n+                            self.s.word(\":\")?;\n                         }\n                     }\n                 }\n                 &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ref lhs_ty,\n                                                                         ref rhs_ty,\n                                                                         ..}) => {\n                     self.print_type(lhs_ty)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"=\")?;\n                     self.print_type(rhs_ty)?;\n                 }\n@@ -2087,7 +2086,7 @@ impl<'a> State<'a> {\n                        -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n-            word(&mut self.s, \"for\")?;\n+            self.s.word(\"for\")?;\n             self.print_generics(generics)?;\n         }\n         let generics = hir::Generics {\n@@ -2132,7 +2131,6 @@ impl<'a> State<'a> {\n             if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n                span_line.line == comment_line.line {\n                 self.print_comment(cmnt)?;\n-                self.cur_cmnt_and_lit.cur_cmnt += 1;\n             }\n         }\n         Ok(())\n@@ -2142,13 +2140,12 @@ impl<'a> State<'a> {\n         // If there aren't any remaining comments, then we need to manually\n         // make sure there is a line break at the end.\n         if self.next_comment().is_none() {\n-            hardbreak(&mut self.s)?;\n+            self.s.hardbreak()?;\n         }\n         loop {\n             match self.next_comment() {\n                 Some(ref cmnt) => {\n                     self.print_comment(cmnt)?;\n-                    self.cur_cmnt_and_lit.cur_cmnt += 1;\n                 }\n                 _ => break,\n             }\n@@ -2185,7 +2182,7 @@ impl<'a> State<'a> {\n                                 abi: Abi,\n                                 vis: &hir::Visibility)\n                                 -> io::Result<()> {\n-        word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n+        self.s.word(&visibility_qualified(vis, \"\"))?;\n         self.print_unsafety(unsafety)?;\n \n         match constness {\n@@ -2198,7 +2195,7 @@ impl<'a> State<'a> {\n             self.word_nbsp(&abi.to_string())?;\n         }\n \n-        word(&mut self.s, \"fn\")\n+        self.s.word(\"fn\")\n     }\n \n     pub fn print_unsafety(&mut self, s: hir::Unsafety) -> io::Result<()> {"}, {"sha": "f6be709009177920bb2a58f62593943826036fdb", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd", "patch": "@@ -21,7 +21,6 @@ use std::io;\n use std::mem;\n use std::usize;\n use syntax::ast;\n-use syntax::print::pp;\n use syntax::print::pprust::PrintState;\n use util::nodemap::NodeMap;\n use hir;\n@@ -157,7 +156,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             ps.synth_comment(\n                 format!(\"id {}: {}{}{}{}\", id, entry_str,\n                         gens_str, action_kills_str, scope_kills_str))?;\n-            pp::space(&mut ps.s)?;\n+            ps.s.space()?;\n         }\n         Ok(())\n     }"}, {"sha": "269363fdd2f98e270d3c2a991f4aec2c5d45ad33", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd", "patch": "@@ -30,7 +30,7 @@ use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast::{self, BlockCheckMode};\n use syntax::fold::{self, Folder};\n-use syntax::print::{pp, pprust};\n+use syntax::print::{pprust};\n use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n use syntax::util::small_vector::SmallVector;\n@@ -163,67 +163,65 @@ pub fn parse_pretty(sess: &Session,\n \n impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n-    fn call_with_pp_support<'tcx, A, B, F>(&self,\n+    fn call_with_pp_support<'tcx, A, F>(&self,\n                                            sess: &'tcx Session,\n                                            hir_map: Option<&hir_map::Map<'tcx>>,\n-                                           payload: B,\n                                            f: F)\n                                            -> A\n-        where F: FnOnce(&PrinterSupport, B) -> A\n+        where F: FnOnce(&PrinterSupport) -> A\n     {\n         match *self {\n             PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n                 let annotation = NoAnn {\n                     sess: sess,\n                     hir_map: hir_map.map(|m| m.clone()),\n                 };\n-                f(&annotation, payload)\n+                f(&annotation)\n             }\n \n             PpmIdentified | PpmExpandedIdentified => {\n                 let annotation = IdentifiedAnnotation {\n                     sess: sess,\n                     hir_map: hir_map.map(|m| m.clone()),\n                 };\n-                f(&annotation, payload)\n+                f(&annotation)\n             }\n             PpmExpandedHygiene => {\n                 let annotation = HygieneAnnotation {\n                     sess: sess,\n                 };\n-                f(&annotation, payload)\n+                f(&annotation)\n             }\n             _ => panic!(\"Should use call_with_pp_support_hir\"),\n         }\n     }\n-    fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n+    fn call_with_pp_support_hir<'tcx, A, F>(&self,\n                                                sess: &'tcx Session,\n                                                hir_map: &hir_map::Map<'tcx>,\n                                                analysis: &ty::CrateAnalysis,\n                                                resolutions: &Resolutions,\n                                                arena: &'tcx DroplessArena,\n                                                arenas: &'tcx GlobalArenas<'tcx>,\n                                                id: &str,\n-                                               payload: B,\n                                                f: F)\n                                                -> A\n-        where F: FnOnce(&HirPrinterSupport, B, &hir::Crate) -> A\n+        where F: FnOnce(&HirPrinterSupport, &hir::Crate) -> A\n     {\n         match *self {\n             PpmNormal => {\n                 let annotation = NoAnn {\n                     sess: sess,\n                     hir_map: Some(hir_map.clone()),\n                 };\n-                f(&annotation, payload, hir_map.forest.krate())\n+                f(&annotation, hir_map.forest.krate())\n             }\n \n             PpmIdentified => {\n                 let annotation = IdentifiedAnnotation {\n                     sess: sess,\n                     hir_map: Some(hir_map.clone()),\n                 };\n-                f(&annotation, payload, hir_map.forest.krate())\n+                f(&annotation, hir_map.forest.krate())\n             }\n             PpmTyped => {\n                 abort_on_err(driver::phase_3_run_analysis_passes(sess,\n@@ -240,7 +238,7 @@ impl PpSourceMode {\n                         tables: Cell::new(&empty_tables)\n                     };\n                     let _ignore = tcx.dep_graph.in_ignore();\n-                    f(&annotation, payload, hir_map.forest.krate())\n+                    f(&annotation, hir_map.forest.krate())\n                 }),\n                              sess)\n             }\n@@ -357,24 +355,24 @@ impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n             pprust::NodeName(_) => Ok(()),\n \n             pprust::NodeItem(item) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(item.id.to_string())\n             }\n             pprust::NodeSubItem(id) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(id.to_string())\n             }\n             pprust::NodeBlock(blk) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(format!(\"block {}\", blk.id))\n             }\n             pprust::NodeExpr(expr) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(expr.id.to_string())?;\n                 s.pclose()\n             }\n             pprust::NodePat(pat) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(format!(\"pat {}\", pat.id))\n             }\n         }\n@@ -414,24 +412,24 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n         match node {\n             pprust_hir::NodeName(_) => Ok(()),\n             pprust_hir::NodeItem(item) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(item.id.to_string())\n             }\n             pprust_hir::NodeSubItem(id) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(id.to_string())\n             }\n             pprust_hir::NodeBlock(blk) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(format!(\"block {}\", blk.id))\n             }\n             pprust_hir::NodeExpr(expr) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(expr.id.to_string())?;\n                 s.pclose()\n             }\n             pprust_hir::NodePat(pat) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(format!(\"pat {}\", pat.id))\n             }\n         }\n@@ -456,13 +454,13 @@ impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeIdent(&ast::Ident { name, ctxt }) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n                 s.synth_comment(format!(\"{}{:?}\", name.as_u32(), ctxt))\n             }\n             pprust::NodeName(&name) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(name.as_u32().to_string())\n             }\n             _ => Ok(()),\n@@ -514,10 +512,10 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     fn post(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeExpr(expr) => {\n-                pp::space(&mut s.s)?;\n-                pp::word(&mut s.s, \"as\")?;\n-                pp::space(&mut s.s)?;\n-                pp::word(&mut s.s, &self.tables.get().expr_ty(expr).to_string())?;\n+                s.s.space()?;\n+                s.s.word(\"as\")?;\n+                s.s.space()?;\n+                s.s.word(&self.tables.get().expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),\n@@ -825,15 +823,15 @@ pub fn print_after_parsing(sess: &Session,\n     if let PpmSource(s) = ppm {\n         // Silently ignores an identified node.\n         let out: &mut Write = &mut out;\n-        s.call_with_pp_support(sess, None, box out, |annotation, out| {\n+        s.call_with_pp_support(sess, None, move |annotation| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();\n                 pprust::print_crate(sess.codemap(),\n                                     &sess.parse_sess,\n                                     krate,\n                                     src_name.to_string(),\n                                     &mut rdr,\n-                                    out,\n+                                    box out,\n                                     annotation.pp_ann(),\n                                     false)\n             })\n@@ -883,15 +881,15 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n             (PpmSource(s), _) => {\n                 // Silently ignores an identified node.\n                 let out: &mut Write = &mut out;\n-                s.call_with_pp_support(sess, Some(hir_map), box out, |annotation, out| {\n+                s.call_with_pp_support(sess, Some(hir_map), move |annotation| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n                                         &sess.parse_sess,\n                                         krate,\n                                         src_name.to_string(),\n                                         &mut rdr,\n-                                        out,\n+                                        box out,\n                                         annotation.pp_ann(),\n                                         true)\n                 })\n@@ -906,16 +904,15 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                            arena,\n                                            arenas,\n                                            crate_name,\n-                                           box out,\n-                                           |annotation, out, krate| {\n+                                           move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust_hir::print_crate(sess.codemap(),\n                                             &sess.parse_sess,\n                                             krate,\n                                             src_name.to_string(),\n                                             &mut rdr,\n-                                            out,\n+                                            box out,\n                                             annotation.pp_ann(),\n                                             true)\n                 })\n@@ -930,8 +927,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                            arena,\n                                            arenas,\n                                            crate_name,\n-                                           (out, uii),\n-                                           |annotation, (out, uii), _| {\n+                                           move |annotation, _| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     let hir_map = annotation.hir_map().expect(\"--unpretty missing HIR map\");\n@@ -945,13 +941,13 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     for node_id in uii.all_matching_node_ids(hir_map) {\n                         let node = hir_map.get(node_id);\n                         pp_state.print_node(node)?;\n-                        pp::space(&mut pp_state.s)?;\n+                        pp_state.s.space()?;\n                         let path = annotation.node_path(node_id)\n                             .expect(\"--unpretty missing node paths\");\n                         pp_state.synth_comment(path)?;\n-                        pp::hardbreak(&mut pp_state.s)?;\n+                        pp_state.s.hardbreak()?;\n                     }\n-                    pp::eof(&mut pp_state.s)\n+                    pp_state.s.eof()\n                 })\n             }\n             _ => unreachable!(),"}, {"sha": "74b2ea1df323a178519b6b4a29f81bb6258b3ec2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd", "patch": "@@ -1480,10 +1480,9 @@ impl<'a> Parser<'a> {\n         match ty.node {\n             TyKind::Rptr(ref lifetime, ref mut_ty) => {\n                 let sum_with_parens = pprust::to_string(|s| {\n-                    use print::pp::word;\n                     use print::pprust::PrintState;\n \n-                    word(&mut s.s, \"&\")?;\n+                    s.s.word(\"&\")?;\n                     s.print_opt_lifetime(lifetime)?;\n                     s.print_mutability(mut_ty.mutbl)?;\n                     s.popen()?;\n@@ -2542,14 +2541,13 @@ impl<'a> Parser<'a> {\n                         };\n                         let sugg = pprust::to_string(|s| {\n                             use print::pprust::PrintState;\n-                            use print::pp::word;\n                             s.popen()?;\n                             s.print_expr(&e)?;\n-                            word(&mut s.s, \".\")?;\n+                            s.s.word( \".\")?;\n                             s.print_usize(float.trunc() as usize)?;\n                             s.pclose()?;\n-                            word(&mut s.s, \".\")?;\n-                            word(&mut s.s, fstr.splitn(2, \".\").last().unwrap())\n+                            s.s.word(\".\")?;\n+                            s.s.word(fstr.splitn(2, \".\").last().unwrap())\n                         });\n                         err.span_suggestion(\n                             lo.to(self.prev_span),"}, {"sha": "3ce9e9d07b30cfa198cb43d48f3fba19688e436e", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd", "patch": "@@ -262,7 +262,7 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n }\n \n pub struct Printer<'a> {\n-    pub out: Box<io::Write+'a>,\n+    out: Box<io::Write+'a>,\n     buf_len: usize,\n     /// Width of lines we're constrained to\n     margin: isize,\n@@ -577,75 +577,75 @@ impl<'a> Printer<'a> {\n           }\n         }\n     }\n-}\n \n-// Convenience functions to talk to the printer.\n+    // Convenience functions to talk to the printer.\n \n-/// \"raw box\"\n-pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> io::Result<()> {\n-    p.pretty_print(Token::Begin(BeginToken {\n-        offset: indent as isize,\n-        breaks: b\n-    }))\n-}\n+    /// \"raw box\"\n+    pub fn rbox(&mut self, indent: usize, b: Breaks) -> io::Result<()> {\n+        self.pretty_print(Token::Begin(BeginToken {\n+            offset: indent as isize,\n+            breaks: b\n+        }))\n+    }\n \n-/// Inconsistent breaking box\n-pub fn ibox(p: &mut Printer, indent: usize) -> io::Result<()> {\n-    rbox(p, indent, Breaks::Inconsistent)\n-}\n+    /// Inconsistent breaking box\n+    pub fn ibox(&mut self, indent: usize) -> io::Result<()> {\n+        self.rbox(indent, Breaks::Inconsistent)\n+    }\n \n-/// Consistent breaking box\n-pub fn cbox(p: &mut Printer, indent: usize) -> io::Result<()> {\n-    rbox(p, indent, Breaks::Consistent)\n-}\n+    /// Consistent breaking box\n+    pub fn cbox(&mut self, indent: usize) -> io::Result<()> {\n+        self.rbox(indent, Breaks::Consistent)\n+    }\n \n-pub fn break_offset(p: &mut Printer, n: usize, off: isize) -> io::Result<()> {\n-    p.pretty_print(Token::Break(BreakToken {\n-        offset: off,\n-        blank_space: n as isize\n-    }))\n-}\n+    pub fn break_offset(&mut self, n: usize, off: isize) -> io::Result<()> {\n+        self.pretty_print(Token::Break(BreakToken {\n+            offset: off,\n+            blank_space: n as isize\n+        }))\n+    }\n \n-pub fn end(p: &mut Printer) -> io::Result<()> {\n-    p.pretty_print(Token::End)\n-}\n+    pub fn end(&mut self) -> io::Result<()> {\n+        self.pretty_print(Token::End)\n+    }\n \n-pub fn eof(p: &mut Printer) -> io::Result<()> {\n-    p.pretty_print(Token::Eof)\n-}\n+    pub fn eof(&mut self) -> io::Result<()> {\n+        self.pretty_print(Token::Eof)\n+    }\n \n-pub fn word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(wrd.to_string(), wrd.len() as isize))\n-}\n+    pub fn word(&mut self, wrd: &str) -> io::Result<()> {\n+        self.pretty_print(Token::String(wrd.to_string(), wrd.len() as isize))\n+    }\n \n-pub fn huge_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(wrd.to_string(), SIZE_INFINITY))\n-}\n+    pub fn huge_word(&mut self, wrd: &str) -> io::Result<()> {\n+        self.pretty_print(Token::String(wrd.to_string(), SIZE_INFINITY))\n+    }\n \n-pub fn zero_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(wrd.to_string(), 0))\n-}\n+    pub fn zero_word(&mut self, wrd: &str) -> io::Result<()> {\n+        self.pretty_print(Token::String(wrd.to_string(), 0))\n+    }\n \n-pub fn spaces(p: &mut Printer, n: usize) -> io::Result<()> {\n-    break_offset(p, n, 0)\n-}\n+    fn spaces(&mut self, n: usize) -> io::Result<()> {\n+        self.break_offset(n, 0)\n+    }\n \n-pub fn zerobreak(p: &mut Printer) -> io::Result<()> {\n-    spaces(p, 0)\n-}\n+    pub fn zerobreak(&mut self) -> io::Result<()> {\n+        self.spaces(0)\n+    }\n \n-pub fn space(p: &mut Printer) -> io::Result<()> {\n-    spaces(p, 1)\n-}\n+    pub fn space(&mut self) -> io::Result<()> {\n+        self.spaces(1)\n+    }\n \n-pub fn hardbreak(p: &mut Printer) -> io::Result<()> {\n-    spaces(p, SIZE_INFINITY as usize)\n-}\n+    pub fn hardbreak(&mut self) -> io::Result<()> {\n+        self.spaces(SIZE_INFINITY as usize)\n+    }\n \n-pub fn hardbreak_tok_offset(off: isize) -> Token {\n-    Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n-}\n+    pub fn hardbreak_tok_offset(off: isize) -> Token {\n+        Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n+    }\n \n-pub fn hardbreak_tok() -> Token {\n-    hardbreak_tok_offset(0)\n+    pub fn hardbreak_tok() -> Token {\n+        Self::hardbreak_tok_offset(0)\n+    }\n }"}, {"sha": "b052b2cdbbb5a74fa31c52371b64432abedf513e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 296, "deletions": 314, "changes": 610, "blob_url": "https://github.com/rust-lang/rust/blob/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b2b19ec92e233b7f91617e4cc2130e70d6e7a5fd", "patch": "@@ -21,8 +21,7 @@ use syntax_pos::{self, BytePos};\n use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse::{self, ParseSess};\n-use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n-use print::pp::{Breaks, eof};\n+use print::pp::{self, Breaks};\n use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n@@ -32,7 +31,8 @@ use tokenstream::{self, TokenStream, TokenTree};\n \n use std::ascii;\n use std::io::{self, Write, Read};\n-use std::iter;\n+use std::iter::{self, Peekable};\n+use std::vec;\n \n pub enum AnnNode<'a> {\n     NodeIdent(&'a ast::Ident),\n@@ -54,38 +54,23 @@ pub struct NoAnn;\n \n impl PpAnn for NoAnn {}\n \n-#[derive(Copy, Clone)]\n-pub struct CurrentCommentAndLiteral {\n-    pub cur_cmnt: usize,\n-    pub cur_lit: usize,\n-}\n-\n pub struct State<'a> {\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a CodeMap>,\n     comments: Option<Vec<comments::Comment> >,\n-    literals: Option<Vec<comments::Literal> >,\n-    cur_cmnt_and_lit: CurrentCommentAndLiteral,\n+    literals: Peekable<vec::IntoIter<comments::Literal>>,\n+    cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n     ann: &'a (PpAnn+'a),\n }\n \n-pub fn rust_printer<'a>(writer: Box<Write+'a>) -> State<'a> {\n-    static NO_ANN: NoAnn = NoAnn;\n-    rust_printer_annotated(writer, &NO_ANN)\n-}\n-\n-pub fn rust_printer_annotated<'a>(writer: Box<Write+'a>,\n-                                  ann: &'a PpAnn) -> State<'a> {\n+fn rust_printer<'a>(writer: Box<Write+'a>, ann: &'a PpAnn) -> State<'a> {\n     State {\n         s: pp::mk_printer(writer, DEFAULT_COLUMNS),\n         cm: None,\n         comments: None,\n-        literals: None,\n-        cur_cmnt_and_lit: CurrentCommentAndLiteral {\n-            cur_cmnt: 0,\n-            cur_lit: 0\n-        },\n+        literals: vec![].into_iter().peekable(),\n+        cur_cmnt: 0,\n         boxes: Vec::new(),\n         ann: ann,\n     }\n@@ -128,7 +113,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n \n     s.print_mod(&krate.module, &krate.attrs)?;\n     s.print_remaining_comments()?;\n-    eof(&mut s.s)\n+    s.s.eof()\n }\n \n impl<'a> State<'a> {\n@@ -161,11 +146,8 @@ impl<'a> State<'a> {\n             s: pp::mk_printer(out, DEFAULT_COLUMNS),\n             cm: Some(cm),\n             comments: comments,\n-            literals: literals,\n-            cur_cmnt_and_lit: CurrentCommentAndLiteral {\n-                cur_cmnt: 0,\n-                cur_lit: 0\n-            },\n+            literals: literals.unwrap_or_default().into_iter().peekable(),\n+            cur_cmnt: 0,\n             boxes: Vec::new(),\n             ann: ann,\n         }\n@@ -177,14 +159,15 @@ pub fn to_string<F>(f: F) -> String where\n {\n     let mut wr = Vec::new();\n     {\n-        let mut printer = rust_printer(Box::new(&mut wr));\n+        let ann = NoAnn;\n+        let mut printer = rust_printer(Box::new(&mut wr), &ann);\n         f(&mut printer).unwrap();\n-        eof(&mut printer.s).unwrap();\n+        printer.s.eof().unwrap();\n     }\n     String::from_utf8(wr).unwrap()\n }\n \n-pub fn binop_to_string(op: BinOpToken) -> &'static str {\n+fn binop_to_string(op: BinOpToken) -> &'static str {\n     match op {\n         token::Plus     => \"+\",\n         token::Minus    => \"-\",\n@@ -452,17 +435,18 @@ pub trait PrintState<'a> {\n     fn writer(&mut self) -> &mut pp::Printer<'a>;\n     fn boxes(&mut self) -> &mut Vec<pp::Breaks>;\n     fn comments(&mut self) -> &mut Option<Vec<comments::Comment>>;\n-    fn cur_cmnt_and_lit(&mut self) -> &mut CurrentCommentAndLiteral;\n-    fn literals(&self) -> &Option<Vec<comments::Literal>>;\n+    fn cur_cmnt(&mut self) -> &mut usize;\n+    fn cur_lit(&mut self) -> Option<&comments::Literal>;\n+    fn bump_lit(&mut self) -> Option<comments::Literal>;\n \n     fn word_space(&mut self, w: &str) -> io::Result<()> {\n-        word(self.writer(), w)?;\n-        space(self.writer())\n+        self.writer().word(w)?;\n+        self.writer().space()\n     }\n \n-    fn popen(&mut self) -> io::Result<()> { word(self.writer(), \"(\") }\n+    fn popen(&mut self) -> io::Result<()> { self.writer().word(\"(\") }\n \n-    fn pclose(&mut self) -> io::Result<()> { word(self.writer(), \")\") }\n+    fn pclose(&mut self) -> io::Result<()> { self.writer().word(\")\") }\n \n     fn is_begin(&mut self) -> bool {\n         match self.writer().last_token() {\n@@ -485,25 +469,25 @@ pub trait PrintState<'a> {\n \n     fn hardbreak_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() {\n-            hardbreak(self.writer())?\n+            self.writer().hardbreak()?\n         }\n         Ok(())\n     }\n \n     // \"raw box\"\n     fn rbox(&mut self, u: usize, b: pp::Breaks) -> io::Result<()> {\n         self.boxes().push(b);\n-        pp::rbox(self.writer(), u, b)\n+        self.writer().rbox(u, b)\n     }\n \n     fn ibox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes().push(pp::Breaks::Inconsistent);\n-        pp::ibox(self.writer(), u)\n+        self.writer().ibox(u)\n     }\n \n     fn end(&mut self) -> io::Result<()> {\n         self.boxes().pop().unwrap();\n-        pp::end(self.writer())\n+        self.writer().end()\n     }\n \n     fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> io::Result<()>\n@@ -519,31 +503,24 @@ pub trait PrintState<'a> {\n     }\n \n     fn next_lit(&mut self, pos: BytePos) -> Option<comments::Literal> {\n-        let mut cur_lit = self.cur_cmnt_and_lit().cur_lit;\n+        while let Some(ltrl) = self.cur_lit().cloned() {\n+            if ltrl.pos > pos { break; }\n \n-        let mut result = None;\n-\n-        if let Some(ref lits) = *self.literals() {\n-            while cur_lit < lits.len() {\n-                let ltrl = (*lits)[cur_lit].clone();\n-                if ltrl.pos > pos { break; }\n-                cur_lit += 1;\n-                if ltrl.pos == pos {\n-                    result = Some(ltrl);\n-                    break;\n-                }\n+            // we don't need the value here since we're forced to clone cur_lit\n+            // due to lack of NLL.\n+            self.bump_lit();\n+            if ltrl.pos == pos {\n+                return Some(ltrl);\n             }\n         }\n \n-        self.cur_cmnt_and_lit().cur_lit = cur_lit;\n-        result\n+        None\n     }\n \n     fn maybe_print_comment(&mut self, pos: BytePos) -> io::Result<()> {\n         while let Some(ref cmnt) = self.next_comment() {\n             if cmnt.pos < pos {\n                 self.print_comment(cmnt)?;\n-                self.cur_cmnt_and_lit().cur_cmnt += 1;\n             } else {\n                 break\n             }\n@@ -553,39 +530,39 @@ pub trait PrintState<'a> {\n \n     fn print_comment(&mut self,\n                      cmnt: &comments::Comment) -> io::Result<()> {\n-        match cmnt.style {\n+        let r = match cmnt.style {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1);\n-                zerobreak(self.writer())?;\n-                word(self.writer(), &cmnt.lines[0])?;\n-                zerobreak(self.writer())\n+                self.writer().zerobreak()?;\n+                self.writer().word(&cmnt.lines[0])?;\n+                self.writer().zerobreak()\n             }\n             comments::Isolated => {\n                 self.hardbreak_if_not_bol()?;\n                 for line in &cmnt.lines {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n-                        word(self.writer(), &line[..])?;\n+                        self.writer().word(&line[..])?;\n                     }\n-                    hardbreak(self.writer())?;\n+                    self.writer().hardbreak()?;\n                 }\n                 Ok(())\n             }\n             comments::Trailing => {\n                 if !self.is_bol() {\n-                    word(self.writer(), \" \")?;\n+                    self.writer().word(\" \")?;\n                 }\n                 if cmnt.lines.len() == 1 {\n-                    word(self.writer(), &cmnt.lines[0])?;\n-                    hardbreak(self.writer())\n+                    self.writer().word(&cmnt.lines[0])?;\n+                    self.writer().hardbreak()\n                 } else {\n                     self.ibox(0)?;\n                     for line in &cmnt.lines {\n                         if !line.is_empty() {\n-                            word(self.writer(), &line[..])?;\n+                            self.writer().word(&line[..])?;\n                         }\n-                        hardbreak(self.writer())?;\n+                        self.writer().hardbreak()?;\n                     }\n                     self.end()\n                 }\n@@ -597,15 +574,22 @@ pub trait PrintState<'a> {\n                     _ => false\n                 };\n                 if is_semi || self.is_begin() || self.is_end() {\n-                    hardbreak(self.writer())?;\n+                    self.writer().hardbreak()?;\n                 }\n-                hardbreak(self.writer())\n+                self.writer().hardbreak()\n             }\n+        };\n+        match r {\n+            Ok(()) => {\n+                *self.cur_cmnt() = *self.cur_cmnt() + 1;\n+                Ok(())\n+            }\n+            Err(e) => Err(e),\n         }\n     }\n \n     fn next_comment(&mut self) -> Option<comments::Comment> {\n-        let cur_cmnt = self.cur_cmnt_and_lit().cur_cmnt;\n+        let cur_cmnt = *self.cur_cmnt();\n         match *self.comments() {\n             Some(ref cmnts) => {\n                 if cur_cmnt < cmnts.len() {\n@@ -620,54 +604,50 @@ pub trait PrintState<'a> {\n \n     fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n         self.maybe_print_comment(lit.span.lo)?;\n-        if let Some(ref ltrl) = self.next_lit(lit.span.lo) {\n-            return word(self.writer(), &(*ltrl).lit);\n+        if let Some(ltrl) = self.next_lit(lit.span.lo) {\n+            return self.writer().word(&ltrl.lit);\n         }\n         match lit.node {\n             ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n             ast::LitKind::Byte(byte) => {\n                 let mut res = String::from(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n                 res.push('\\'');\n-                word(self.writer(), &res[..])\n+                self.writer().word(&res[..])\n             }\n             ast::LitKind::Char(ch) => {\n                 let mut res = String::from(\"'\");\n                 res.extend(ch.escape_default());\n                 res.push('\\'');\n-                word(self.writer(), &res[..])\n+                self.writer().word(&res[..])\n             }\n             ast::LitKind::Int(i, t) => {\n                 match t {\n                     ast::LitIntType::Signed(st) => {\n-                        word(self.writer(), &st.val_to_string(i as i128))\n+                        self.writer().word(&st.val_to_string(i as i128))\n                     }\n                     ast::LitIntType::Unsigned(ut) => {\n-                        word(self.writer(), &ut.val_to_string(i))\n+                        self.writer().word(&ut.val_to_string(i))\n                     }\n                     ast::LitIntType::Unsuffixed => {\n-                        word(self.writer(), &format!(\"{}\", i))\n+                        self.writer().word(&format!(\"{}\", i))\n                     }\n                 }\n             }\n             ast::LitKind::Float(ref f, t) => {\n-                word(self.writer(),\n-                     &format!(\n-                         \"{}{}\",\n-                         &f,\n-                         t.ty_to_string()))\n+                self.writer().word(&format!(\"{}{}\", &f, t.ty_to_string()))\n             }\n-            ast::LitKind::FloatUnsuffixed(ref f) => word(self.writer(), &f.as_str()),\n+            ast::LitKind::FloatUnsuffixed(ref f) => self.writer().word(&f.as_str()),\n             ast::LitKind::Bool(val) => {\n-                if val { word(self.writer(), \"true\") } else { word(self.writer(), \"false\") }\n+                if val { self.writer().word(\"true\") } else { self.writer().word(\"false\") }\n             }\n             ast::LitKind::ByteStr(ref v) => {\n                 let mut escaped: String = String::new();\n                 for &ch in v.iter() {\n                     escaped.extend(ascii::escape_default(ch)\n                                          .map(|c| c as char));\n                 }\n-                word(self.writer(), &format!(\"b\\\"{}\\\"\", escaped))\n+                self.writer().word(&format!(\"b\\\"{}\\\"\", escaped))\n             }\n         }\n     }\n@@ -684,7 +664,7 @@ pub trait PrintState<'a> {\n                          string=st))\n             }\n         };\n-        word(self.writer(), &st[..])\n+        self.writer().word(&st[..])\n     }\n \n     fn print_inner_attributes(&mut self,\n@@ -745,29 +725,29 @@ pub trait PrintState<'a> {\n         }\n         self.maybe_print_comment(attr.span.lo)?;\n         if attr.is_sugared_doc {\n-            word(self.writer(), &attr.value_str().unwrap().as_str())?;\n-            hardbreak(self.writer())\n+            self.writer().word(&attr.value_str().unwrap().as_str())?;\n+            self.writer().hardbreak()\n         } else {\n             match attr.style {\n-                ast::AttrStyle::Inner => word(self.writer(), \"#![\")?,\n-                ast::AttrStyle::Outer => word(self.writer(), \"#[\")?,\n+                ast::AttrStyle::Inner => self.writer().word(\"#![\")?,\n+                ast::AttrStyle::Outer => self.writer().word(\"#[\")?,\n             }\n             if let Some(mi) = attr.meta() {\n                 self.print_meta_item(&mi)?\n             } else {\n                 for (i, segment) in attr.path.segments.iter().enumerate() {\n                     if i > 0 {\n-                        word(self.writer(), \"::\")?\n+                        self.writer().word(\"::\")?\n                     }\n                     if segment.identifier.name != keywords::CrateRoot.name() &&\n                        segment.identifier.name != keywords::DollarCrate.name() {\n-                        word(self.writer(), &segment.identifier.name.as_str())?;\n+                        self.writer().word(&segment.identifier.name.as_str())?;\n                     }\n                 }\n-                space(self.writer())?;\n+                self.writer().space()?;\n                 self.print_tts(attr.tokens.clone())?;\n             }\n-            word(self.writer(), \"]\")\n+            self.writer().word(\"]\")\n         }\n     }\n \n@@ -786,15 +766,15 @@ pub trait PrintState<'a> {\n         self.ibox(INDENT_UNIT)?;\n         match item.node {\n             ast::MetaItemKind::Word => {\n-                word(self.writer(), &item.name.as_str())?;\n+                self.writer().word(&item.name.as_str())?;\n             }\n             ast::MetaItemKind::NameValue(ref value) => {\n                 self.word_space(&item.name.as_str())?;\n                 self.word_space(\"=\")?;\n                 self.print_literal(value)?;\n             }\n             ast::MetaItemKind::List(ref items) => {\n-                word(self.writer(), &item.name.as_str())?;\n+                self.writer().word(&item.name.as_str())?;\n                 self.popen()?;\n                 self.commasep(Consistent,\n                               &items[..],\n@@ -815,20 +795,20 @@ pub trait PrintState<'a> {\n     fn print_tt(&mut self, tt: tokenstream::TokenTree) -> io::Result<()> {\n         match tt {\n             TokenTree::Token(_, ref tk) => {\n-                word(self.writer(), &token_to_string(tk))?;\n+                self.writer().word(&token_to_string(tk))?;\n                 match *tk {\n                     parse::token::DocComment(..) => {\n-                        hardbreak(self.writer())\n+                        self.writer().hardbreak()\n                     }\n                     _ => Ok(())\n                 }\n             }\n             TokenTree::Delimited(_, ref delimed) => {\n-                word(self.writer(), &token_to_string(&delimed.open_token()))?;\n-                space(self.writer())?;\n+                self.writer().word(&token_to_string(&delimed.open_token()))?;\n+                self.writer().space()?;\n                 self.print_tts(delimed.stream())?;\n-                space(self.writer())?;\n-                word(self.writer(), &token_to_string(&delimed.close_token()))\n+                self.writer().space()?;\n+                self.writer().word(&token_to_string(&delimed.close_token()))\n             },\n         }\n     }\n@@ -837,19 +817,19 @@ pub trait PrintState<'a> {\n         self.ibox(0)?;\n         for (i, tt) in tts.into_trees().enumerate() {\n             if i != 0 {\n-                space(self.writer())?;\n+                self.writer().space()?;\n             }\n             self.print_tt(tt)?;\n         }\n         self.end()\n     }\n \n     fn space_if_not_bol(&mut self) -> io::Result<()> {\n-        if !self.is_bol() { space(self.writer())?; }\n+        if !self.is_bol() { self.writer().space()?; }\n         Ok(())\n     }\n \n-    fn nbsp(&mut self) -> io::Result<()> { word(self.writer(), \" \") }\n+    fn nbsp(&mut self) -> io::Result<()> { self.writer().word(\" \") }\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n@@ -865,23 +845,27 @@ impl<'a> PrintState<'a> for State<'a> {\n         &mut self.comments\n     }\n \n-    fn cur_cmnt_and_lit(&mut self) -> &mut CurrentCommentAndLiteral {\n-        &mut self.cur_cmnt_and_lit\n+    fn cur_cmnt(&mut self) -> &mut usize {\n+        &mut self.cur_cmnt\n+    }\n+\n+    fn cur_lit(&mut self) -> Option<&comments::Literal> {\n+        self.literals.peek()\n     }\n \n-    fn literals(&self) -> &Option<Vec<comments::Literal>> {\n-        &self.literals\n+    fn bump_lit(&mut self) -> Option<comments::Literal> {\n+        self.literals.next()\n     }\n }\n \n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes.push(pp::Breaks::Consistent);\n-        pp::cbox(&mut self.s, u)\n+        self.s.cbox(u)\n     }\n \n     pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n-        word(&mut self.s, w)?;\n+        self.s.word(w)?;\n         self.nbsp()\n     }\n \n@@ -898,7 +882,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn bopen(&mut self) -> io::Result<()> {\n-        word(&mut self.s, \"{\")?;\n+        self.s.word(\"{\")?;\n         self.end() // close the head-box\n     }\n \n@@ -910,7 +894,7 @@ impl<'a> State<'a> {\n                              indented: usize, close_box: bool) -> io::Result<()> {\n         self.maybe_print_comment(span.hi)?;\n         self.break_offset_if_not_bol(1, -(indented as isize))?;\n-        word(&mut self.s, \"}\")?;\n+        self.s.word(\"}\")?;\n         if close_box {\n             self.end()?; // close the outer-box\n         }\n@@ -930,13 +914,13 @@ impl<'a> State<'a> {\n     pub fn break_offset_if_not_bol(&mut self, n: usize,\n                                    off: isize) -> io::Result<()> {\n         if !self.is_bol() {\n-            break_offset(&mut self.s, n, off)\n+            self.s.break_offset(n, off)\n         } else {\n             if off != 0 && self.s.last_token().is_hardbreak_tok() {\n                 // We do something pretty sketchy here: tuck the nonzero\n                 // offset-adjustment we were going to deposit along with the\n                 // break into the previous hardbreak.\n-                self.s.replace_last_token(pp::hardbreak_tok_offset(off));\n+                self.s.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n             }\n             Ok(())\n         }\n@@ -945,11 +929,11 @@ impl<'a> State<'a> {\n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n     pub fn synth_comment(&mut self, text: String) -> io::Result<()> {\n-        word(&mut self.s, \"/*\")?;\n-        space(&mut self.s)?;\n-        word(&mut self.s, &text[..])?;\n-        space(&mut self.s)?;\n-        word(&mut self.s, \"*/\")\n+        self.s.word(\"/*\")?;\n+        self.s.space()?;\n+        self.s.word(&text[..])?;\n+        self.s.space()?;\n+        self.s.word(\"*/\")\n     }\n \n \n@@ -970,7 +954,7 @@ impl<'a> State<'a> {\n             op(self, elt)?;\n             i += 1;\n             if i < len {\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n                 self.maybe_print_trailing_comment(get_span(elt),\n                                                   Some(get_span(&elts[i]).hi))?;\n                 self.space_if_not_bol()?;\n@@ -1016,32 +1000,32 @@ impl<'a> State<'a> {\n         self.ibox(0)?;\n         match ty.node {\n             ast::TyKind::Slice(ref ty) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_type(ty)?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             ast::TyKind::Ptr(ref mt) => {\n-                word(&mut self.s, \"*\")?;\n+                self.s.word(\"*\")?;\n                 match mt.mutbl {\n                     ast::Mutability::Mutable => self.word_nbsp(\"mut\")?,\n                     ast::Mutability::Immutable => self.word_nbsp(\"const\")?,\n                 }\n                 self.print_type(&mt.ty)?;\n             }\n             ast::TyKind::Rptr(ref lifetime, ref mt) => {\n-                word(&mut self.s, \"&\")?;\n+                self.s.word(\"&\")?;\n                 self.print_opt_lifetime(lifetime)?;\n                 self.print_mt(mt)?;\n             }\n             ast::TyKind::Never => {\n-                word(&mut self.s, \"!\")?;\n+                self.s.word(\"!\")?;\n             },\n             ast::TyKind::Tup(ref elts) => {\n                 self.popen()?;\n                 self.commasep(Inconsistent, &elts[..],\n                               |s, ty| s.print_type(ty))?;\n                 if elts.len() == 1 {\n-                    word(&mut self.s, \",\")?;\n+                    self.s.word(\",\")?;\n                 }\n                 self.pclose()?;\n             }\n@@ -1079,25 +1063,25 @@ impl<'a> State<'a> {\n                 self.print_bounds(\"impl \", &bounds[..])?;\n             }\n             ast::TyKind::Array(ref ty, ref v) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_type(ty)?;\n-                word(&mut self.s, \"; \")?;\n+                self.s.word(\"; \")?;\n                 self.print_expr(v)?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             ast::TyKind::Typeof(ref e) => {\n-                word(&mut self.s, \"typeof(\")?;\n+                self.s.word(\"typeof(\")?;\n                 self.print_expr(e)?;\n-                word(&mut self.s, \")\")?;\n+                self.s.word(\")\")?;\n             }\n             ast::TyKind::Infer => {\n-                word(&mut self.s, \"_\")?;\n+                self.s.word(\"_\")?;\n             }\n             ast::TyKind::Err => {\n-                word(&mut self.s, \"?\")?;\n+                self.s.word(\"?\")?;\n             }\n             ast::TyKind::ImplicitSelf => {\n-                word(&mut self.s, \"Self\")?;\n+                self.s.word(\"Self\")?;\n             }\n             ast::TyKind::Mac(ref m) => {\n                 self.print_mac(m, token::Paren)?;\n@@ -1119,7 +1103,7 @@ impl<'a> State<'a> {\n                               Abi::Rust, Some(item.ident),\n                               generics, &item.vis)?;\n                 self.end()?; // end head-ibox\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end() // end the outer fn box\n             }\n             ast::ForeignItemKind::Static(ref t, m) => {\n@@ -1130,7 +1114,7 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(t)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the head-ibox\n                 self.end() // end the outer cbox\n             }\n@@ -1144,17 +1128,17 @@ impl<'a> State<'a> {\n                               vis: &ast::Visibility)\n                               -> io::Result<()>\n     {\n-        word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n+        self.s.word(&visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n         self.print_ident(ident)?;\n         self.word_space(\":\")?;\n         self.print_type(ty)?;\n         if let Some(expr) = default {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"=\")?;\n             self.print_expr(expr)?;\n         }\n-        word(&mut self.s, \";\")\n+        self.s.word(\";\")\n     }\n \n     fn print_associated_type(&mut self,\n@@ -1168,11 +1152,11 @@ impl<'a> State<'a> {\n             self.print_bounds(\":\", bounds)?;\n         }\n         if let Some(ty) = ty {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"=\")?;\n             self.print_type(ty)?;\n         }\n-        word(&mut self.s, \";\")\n+        self.s.word(\";\")\n     }\n \n     /// Pretty-print an item\n@@ -1191,19 +1175,19 @@ impl<'a> State<'a> {\n                     } else {\n                         self.print_name(p)?;\n                     }\n-                    space(&mut self.s)?;\n-                    word(&mut self.s, \"as\")?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n+                    self.s.word(\"as\")?;\n+                    self.s.space()?;\n                 }\n                 self.print_ident(item.ident)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n             ast::ItemKind::Use(ref vp) => {\n                 self.head(&visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_view_path(vp)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n@@ -1215,25 +1199,25 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(ty)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n                 self.print_expr(expr)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n             ast::ItemKind::Const(ref ty, ref expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(ty)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n                 self.print_expr(expr)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n             ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n@@ -1247,7 +1231,7 @@ impl<'a> State<'a> {\n                     typarams,\n                     &item.vis\n                 )?;\n-                word(&mut self.s, \" \")?;\n+                self.s.word(\" \")?;\n                 self.print_block_with_attrs(body, &item.attrs)?;\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n@@ -1267,7 +1251,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::GlobalAsm(ref ga) => {\n                 self.head(&visibility_qualified(&item.vis, \"global_asm!\"))?;\n-                word(&mut self.s, &ga.asm.as_str())?;\n+                self.s.word(&ga.asm.as_str())?;\n                 self.end()?;\n             }\n             ast::ItemKind::Ty(ref ty, ref params) => {\n@@ -1279,10 +1263,10 @@ impl<'a> State<'a> {\n                 self.end()?; // end the inner ibox\n \n                 self.print_where_clause(&params.where_clause)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(ty)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n             ast::ItemKind::Enum(ref enum_definition, ref params) => {\n@@ -1308,7 +1292,7 @@ impl<'a> State<'a> {\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n                 self.print_trait_ref(trait_ref)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"for\")?;\n                 self.word_space(\"..\")?;\n                 self.bopen()?;\n@@ -1329,23 +1313,23 @@ impl<'a> State<'a> {\n \n                 if generics.is_parameterized() {\n                     self.print_generics(generics)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n \n                 if polarity == ast::ImplPolarity::Negative {\n-                    word(&mut self.s, \"!\")?;\n+                    self.s.word(\"!\")?;\n                 }\n \n                 if let Some(ref t) = *opt_trait {\n                     self.print_trait_ref(t)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"for\")?;\n                 }\n \n                 self.print_type(ty)?;\n                 self.print_where_clause(&generics.where_clause)?;\n \n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.bopen()?;\n                 self.print_inner_attributes(&item.attrs)?;\n                 for impl_item in impl_items {\n@@ -1363,7 +1347,7 @@ impl<'a> State<'a> {\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n                     if let TraitTyParamBound(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n@@ -1372,7 +1356,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_bounds(\":\", &real_bounds[..])?;\n                 self.print_where_clause(&generics.where_clause)?;\n-                word(&mut self.s, \" \")?;\n+                self.s.word(\" \")?;\n                 self.bopen()?;\n                 for trait_item in trait_items {\n                     self.print_trait_item(trait_item)?;\n@@ -1381,23 +1365,23 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::Mac(codemap::Spanned { ref node, .. }) => {\n                 self.print_path(&node.path, false, 0, false)?;\n-                word(&mut self.s, \"! \")?;\n+                self.s.word(\"! \")?;\n                 self.print_ident(item.ident)?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n                 self.print_tts(node.stream())?;\n                 self.pclose()?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?;\n             }\n             ast::ItemKind::MacroDef(ref tts) => {\n-                word(&mut self.s, \"macro_rules! \")?;\n+                self.s.word(\"macro_rules! \")?;\n                 self.print_ident(item.ident)?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n                 self.print_tts(tts.stream())?;\n                 self.pclose()?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?;\n             }\n         }\n@@ -1410,7 +1394,7 @@ impl<'a> State<'a> {\n \n     fn print_formal_lifetime_list(&mut self, lifetimes: &[ast::LifetimeDef]) -> io::Result<()> {\n         if !lifetimes.is_empty() {\n-            word(&mut self.s, \"for<\")?;\n+            self.s.word(\"for<\")?;\n             let mut comma = false;\n             for lifetime_def in lifetimes {\n                 if comma {\n@@ -1420,7 +1404,7 @@ impl<'a> State<'a> {\n                 self.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds)?;\n                 comma = true;\n             }\n-            word(&mut self.s, \">\")?;\n+            self.s.word(\">\")?;\n         }\n         Ok(())\n     }\n@@ -1438,7 +1422,7 @@ impl<'a> State<'a> {\n         self.print_ident(ident)?;\n         self.print_generics(generics)?;\n         self.print_where_clause(&generics.where_clause)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_variants(&enum_definition.variants, span)\n     }\n \n@@ -1452,7 +1436,7 @@ impl<'a> State<'a> {\n             self.print_outer_attributes(&v.node.attrs)?;\n             self.ibox(INDENT_UNIT)?;\n             self.print_variant(v)?;\n-            word(&mut self.s, \",\")?;\n+            self.s.word(\",\")?;\n             self.end()?;\n             self.maybe_print_trailing_comment(v.span, None)?;\n         }\n@@ -1506,7 +1490,7 @@ impl<'a> State<'a> {\n             }\n             self.print_where_clause(&generics.where_clause)?;\n             if print_finalizer {\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n             }\n             self.end()?;\n             self.end() // close the outer-box\n@@ -1524,7 +1508,7 @@ impl<'a> State<'a> {\n                 self.print_ident(field.ident.unwrap())?;\n                 self.word_nbsp(\":\")?;\n                 self.print_type(&field.ty)?;\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n             }\n \n             self.bclose(span)\n@@ -1537,7 +1521,7 @@ impl<'a> State<'a> {\n         self.print_struct(&v.node.data, &generics, v.node.name, v.span, false)?;\n         match v.node.disr_expr {\n             Some(ref d) => {\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(d)\n             }\n@@ -1580,7 +1564,7 @@ impl<'a> State<'a> {\n                     self.nbsp()?;\n                     self.print_block_with_attrs(body, &ti.attrs)?;\n                 } else {\n-                    word(&mut self.s, \";\")?;\n+                    self.s.word(\";\")?;\n                 }\n             }\n             ast::TraitItemKind::Type(ref bounds, ref default) => {\n@@ -1590,12 +1574,12 @@ impl<'a> State<'a> {\n             ast::TraitItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemKind::Mac:\n                 self.print_path(&node.path, false, 0, false)?;\n-                word(&mut self.s, \"! \")?;\n+                self.s.word(\"! \")?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n                 self.print_tts(node.stream())?;\n                 self.pclose()?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?\n             }\n         }\n@@ -1624,12 +1608,12 @@ impl<'a> State<'a> {\n             ast::ImplItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemKind::Mac:\n                 self.print_path(&node.path, false, 0, false)?;\n-                word(&mut self.s, \"! \")?;\n+                self.s.word(\"! \")?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n                 self.print_tts(node.stream())?;\n                 self.pclose()?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?\n             }\n         }\n@@ -1653,21 +1637,21 @@ impl<'a> State<'a> {\n                     self.word_space(\"=\")?;\n                     self.print_expr(init)?;\n                 }\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?;\n             }\n             ast::StmtKind::Item(ref item) => self.print_item(item)?,\n             ast::StmtKind::Expr(ref expr) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr_outer_attr_style(expr, false)?;\n                 if parse::classify::expr_requires_semi_to_be_stmt(expr) {\n-                    word(&mut self.s, \";\")?;\n+                    self.s.word(\";\")?;\n                 }\n             }\n             ast::StmtKind::Semi(ref expr) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr_outer_attr_style(expr, false)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n             }\n             ast::StmtKind::Mac(ref mac) => {\n                 let (ref mac, style, ref attrs) = **mac;\n@@ -1679,7 +1663,7 @@ impl<'a> State<'a> {\n                 };\n                 self.print_mac(mac, delim)?;\n                 if style == ast::MacStmtStyle::Semicolon {\n-                    word(&mut self.s, \";\")?;\n+                    self.s.word(\";\")?;\n                 }\n             }\n         }\n@@ -1750,30 +1734,30 @@ impl<'a> State<'a> {\n                     ast::ExprKind::If(ref i, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n-                        word(&mut self.s, \" else if \")?;\n+                        self.s.word(\" else if \")?;\n                         self.print_expr(i)?;\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"another else-if-let\"\n                     ast::ExprKind::IfLet(ref pat, ref expr, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n-                        word(&mut self.s, \" else if let \")?;\n+                        self.s.word(\" else if let \")?;\n                         self.print_pat(pat)?;\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.word_space(\"=\")?;\n                         self.print_expr(expr)?;\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n                     ast::ExprKind::Block(ref b) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n-                        word(&mut self.s, \" else \")?;\n+                        self.s.word(\" else \")?;\n                         self.print_block(b)\n                     }\n                     // BLEAH, constraints would be great here\n@@ -1790,7 +1774,7 @@ impl<'a> State<'a> {\n                     elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         self.head(\"if\")?;\n         self.print_expr(test)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n     }\n@@ -1799,21 +1783,21 @@ impl<'a> State<'a> {\n                         elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         self.head(\"if let\")?;\n         self.print_pat(pat)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"=\")?;\n         self.print_expr(expr)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n     }\n \n     pub fn print_mac(&mut self, m: &ast::Mac, delim: token::DelimToken)\n                      -> io::Result<()> {\n         self.print_path(&m.node.path, false, 0, false)?;\n-        word(&mut self.s, \"!\")?;\n+        self.s.word(\"!\")?;\n         match delim {\n             token::Paren => self.popen()?,\n-            token::Bracket => word(&mut self.s, \"[\")?,\n+            token::Bracket => self.s.word(\"[\")?,\n             token::Brace => {\n                 self.head(\"\")?;\n                 self.bopen()?;\n@@ -1823,7 +1807,7 @@ impl<'a> State<'a> {\n         self.print_tts(m.node.stream())?;\n         match delim {\n             token::Paren => self.pclose(),\n-            token::Bracket => word(&mut self.s, \"]\"),\n+            token::Bracket => self.s.word(\"]\"),\n             token::Brace => self.bclose(m.span),\n             token::NoDelim => Ok(()),\n         }\n@@ -1863,18 +1847,18 @@ impl<'a> State<'a> {\n                            place: &ast::Expr,\n                            expr: &ast::Expr) -> io::Result<()> {\n         self.print_expr_maybe_paren(place)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"<-\")?;\n         self.print_expr_maybe_paren(expr)\n     }\n \n     fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>],\n                       attrs: &[Attribute]) -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n-        word(&mut self.s, \"[\")?;\n+        self.s.word(\"[\")?;\n         self.print_inner_attributes_inline(attrs)?;\n         self.commasep_exprs(Inconsistent, &exprs[..])?;\n-        word(&mut self.s, \"]\")?;\n+        self.s.word(\"]\")?;\n         self.end()\n     }\n \n@@ -1883,12 +1867,12 @@ impl<'a> State<'a> {\n                          count: &ast::Expr,\n                          attrs: &[Attribute]) -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n-        word(&mut self.s, \"[\")?;\n+        self.s.word(\"[\")?;\n         self.print_inner_attributes_inline(attrs)?;\n         self.print_expr(element)?;\n         self.word_space(\";\")?;\n         self.print_expr(count)?;\n-        word(&mut self.s, \"]\")?;\n+        self.s.word(\"]\")?;\n         self.end()\n     }\n \n@@ -1898,7 +1882,7 @@ impl<'a> State<'a> {\n                          wth: &Option<P<ast::Expr>>,\n                          attrs: &[Attribute]) -> io::Result<()> {\n         self.print_path(path, true, 0, false)?;\n-        word(&mut self.s, \"{\")?;\n+        self.s.word(\"{\")?;\n         self.print_inner_attributes_inline(attrs)?;\n         self.commasep_cmnt(\n             Consistent,\n@@ -1917,18 +1901,18 @@ impl<'a> State<'a> {\n             Some(ref expr) => {\n                 self.ibox(INDENT_UNIT)?;\n                 if !fields.is_empty() {\n-                    word(&mut self.s, \",\")?;\n-                    space(&mut self.s)?;\n+                    self.s.word(\",\")?;\n+                    self.s.space()?;\n                 }\n-                word(&mut self.s, \"..\")?;\n+                self.s.word(\"..\")?;\n                 self.print_expr(expr)?;\n                 self.end()?;\n             }\n             _ => if !fields.is_empty() {\n-                word(&mut self.s, \",\")?\n+                self.s.word(\",\")?\n             }\n         }\n-        word(&mut self.s, \"}\")?;\n+        self.s.word(\"}\")?;\n         Ok(())\n     }\n \n@@ -1938,7 +1922,7 @@ impl<'a> State<'a> {\n         self.print_inner_attributes_inline(attrs)?;\n         self.commasep_exprs(Inconsistent, &exprs[..])?;\n         if exprs.len() == 1 {\n-            word(&mut self.s, \",\")?;\n+            self.s.word(\",\")?;\n         }\n         self.pclose()\n     }\n@@ -1955,7 +1939,7 @@ impl<'a> State<'a> {\n                               args: &[P<ast::Expr>]) -> io::Result<()> {\n         let base_args = &args[1..];\n         self.print_expr(&args[0])?;\n-        word(&mut self.s, \".\")?;\n+        self.s.word(\".\")?;\n         self.print_ident(segment.identifier)?;\n         if let Some(ref parameters) = segment.parameters {\n             self.print_path_parameters(parameters, true)?;\n@@ -1972,7 +1956,7 @@ impl<'a> State<'a> {\n         } else {\n             self.print_expr(lhs)?;\n         }\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(op.node.to_string())?;\n         if self.check_expr_bin_needs_paren(rhs, op) {\n             self.print_expr_maybe_paren(rhs)\n@@ -1984,14 +1968,14 @@ impl<'a> State<'a> {\n     fn print_expr_unary(&mut self,\n                         op: ast::UnOp,\n                         expr: &ast::Expr) -> io::Result<()> {\n-        word(&mut self.s, ast::UnOp::to_string(op))?;\n+        self.s.word(ast::UnOp::to_string(op))?;\n         self.print_expr_maybe_paren(expr)\n     }\n \n     fn print_expr_addr_of(&mut self,\n                           mutability: ast::Mutability,\n                           expr: &ast::Expr) -> io::Result<()> {\n-        word(&mut self.s, \"&\")?;\n+        self.s.word(\"&\")?;\n         self.print_mutability(mutability)?;\n         self.print_expr_maybe_paren(expr)\n     }\n@@ -2058,7 +2042,7 @@ impl<'a> State<'a> {\n                 } else {\n                     self.print_expr_maybe_paren(expr)?;\n                 }\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(ty)?;\n             }\n@@ -2080,7 +2064,7 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr(test)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n@@ -2090,10 +2074,10 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"while let\")?;\n                 self.print_pat(pat)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(expr)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n@@ -2103,10 +2087,10 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"for\")?;\n                 self.print_pat(pat)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"in\")?;\n                 self.print_expr(iter)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::Loop(ref blk, opt_ident) => {\n@@ -2115,15 +2099,15 @@ impl<'a> State<'a> {\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::Match(ref expr, ref arms) => {\n                 self.cbox(INDENT_UNIT)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n                 self.print_expr(expr)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.bopen()?;\n                 self.print_inner_attributes_no_trailing_hardbreak(attrs)?;\n                 for arm in arms {\n@@ -2135,7 +2119,7 @@ impl<'a> State<'a> {\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_fn_block_args(decl)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_expr(body)?;\n                 self.end()?; // need to close a box\n \n@@ -2153,41 +2137,41 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.print_expr(lhs)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(rhs)?;\n             }\n             ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 self.print_expr(lhs)?;\n-                space(&mut self.s)?;\n-                word(&mut self.s, op.node.to_string())?;\n+                self.s.space()?;\n+                self.s.word(op.node.to_string())?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(rhs)?;\n             }\n             ast::ExprKind::Field(ref expr, id) => {\n                 self.print_expr(expr)?;\n-                word(&mut self.s, \".\")?;\n+                self.s.word(\".\")?;\n                 self.print_ident(id.node)?;\n             }\n             ast::ExprKind::TupField(ref expr, id) => {\n                 self.print_expr(expr)?;\n-                word(&mut self.s, \".\")?;\n+                self.s.word(\".\")?;\n                 self.print_usize(id.node)?;\n             }\n             ast::ExprKind::Index(ref expr, ref index) => {\n                 self.print_expr(expr)?;\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_expr(index)?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             ast::ExprKind::Range(ref start, ref end, limits) => {\n                 if let Some(ref e) = *start {\n                     self.print_expr(e)?;\n                 }\n                 if limits == ast::RangeLimits::HalfOpen {\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                 } else {\n-                    word(&mut self.s, \"...\")?;\n+                    self.s.word(\"...\")?;\n                 }\n                 if let Some(ref e) = *end {\n                     self.print_expr(e)?;\n@@ -2200,34 +2184,34 @@ impl<'a> State<'a> {\n                 self.print_qpath(path, qself, true)?\n             }\n             ast::ExprKind::Break(opt_ident, ref opt_expr) => {\n-                word(&mut self.s, \"break\")?;\n-                space(&mut self.s)?;\n+                self.s.word(\"break\")?;\n+                self.s.space()?;\n                 if let Some(ident) = opt_ident {\n                     self.print_ident(ident.node)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr(expr)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n             }\n             ast::ExprKind::Continue(opt_ident) => {\n-                word(&mut self.s, \"continue\")?;\n-                space(&mut self.s)?;\n+                self.s.word(\"continue\")?;\n+                self.s.space()?;\n                 if let Some(ident) = opt_ident {\n                     self.print_ident(ident.node)?;\n-                    space(&mut self.s)?\n+                    self.s.space()?\n                 }\n             }\n             ast::ExprKind::Ret(ref result) => {\n-                word(&mut self.s, \"return\")?;\n+                self.s.word(\"return\")?;\n                 if let Some(ref expr) = *result {\n-                    word(&mut self.s, \" \")?;\n+                    self.s.word(\" \")?;\n                     self.print_expr(expr)?;\n                 }\n             }\n             ast::ExprKind::InlineAsm(ref a) => {\n-                word(&mut self.s, \"asm!\")?;\n+                self.s.word(\"asm!\")?;\n                 self.popen()?;\n                 self.print_string(&a.asm.as_str(), a.asm_str_style)?;\n                 self.word_space(\":\")?;\n@@ -2247,7 +2231,7 @@ impl<'a> State<'a> {\n                     s.pclose()?;\n                     Ok(())\n                 })?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\":\")?;\n \n                 self.commasep(Inconsistent, &a.inputs, |s, &(co, ref o)| {\n@@ -2257,7 +2241,7 @@ impl<'a> State<'a> {\n                     s.pclose()?;\n                     Ok(())\n                 })?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\":\")?;\n \n                 self.commasep(Inconsistent, &a.clobbers,\n@@ -2278,7 +2262,7 @@ impl<'a> State<'a> {\n                 }\n \n                 if !options.is_empty() {\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\":\")?;\n                     self.commasep(Inconsistent, &options,\n                                   |s, &co| {\n@@ -2298,11 +2282,11 @@ impl<'a> State<'a> {\n             },\n             ast::ExprKind::Try(ref e) => {\n                 self.print_expr(e)?;\n-                word(&mut self.s, \"?\")?\n+                self.s.word(\"?\")?\n             }\n             ast::ExprKind::Catch(ref blk) => {\n                 self.head(\"do catch\")?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?\n             }\n         }\n@@ -2320,23 +2304,23 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n-        word(&mut self.s, &ident.name.as_str())?;\n+        self.s.word(&ident.name.as_str())?;\n         self.ann.post(self, NodeIdent(&ident))\n     }\n \n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n-        word(&mut self.s, &i.to_string())\n+        self.s.word(&i.to_string())\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        word(&mut self.s, &name.as_str())?;\n+        self.s.word(&name.as_str())?;\n         self.ann.post(self, NodeName(&name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &ast::Local,\n                           coll: &ast::Expr) -> io::Result<()> {\n         self.print_local_decl(loc)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"in\")?;\n         self.print_expr(coll)\n     }\n@@ -2356,7 +2340,7 @@ impl<'a> State<'a> {\n         }\n         for (i, segment) in segments.enumerate() {\n             if i > 0 {\n-                word(&mut self.s, \"::\")?\n+                self.s.word(\"::\")?\n             }\n             self.print_path_segment(segment, colons_before_params)?;\n         }\n@@ -2385,16 +2369,16 @@ impl<'a> State<'a> {\n                    colons_before_params: bool)\n                    -> io::Result<()>\n     {\n-        word(&mut self.s, \"<\")?;\n+        self.s.word(\"<\")?;\n         self.print_type(&qself.ty)?;\n         if qself.position > 0 {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"as\")?;\n             let depth = path.segments.len() - qself.position;\n             self.print_path(path, false, depth, false)?;\n         }\n-        word(&mut self.s, \">\")?;\n-        word(&mut self.s, \"::\")?;\n+        self.s.word(\">\")?;\n+        self.s.word(\"::\")?;\n         let item_segment = path.segments.last().unwrap();\n         self.print_ident(item_segment.identifier)?;\n         match item_segment.parameters {\n@@ -2409,12 +2393,12 @@ impl<'a> State<'a> {\n                              -> io::Result<()>\n     {\n         if colons_before_params {\n-            word(&mut self.s, \"::\")?\n+            self.s.word(\"::\")?\n         }\n \n         match *parameters {\n             ast::PathParameters::AngleBracketed(ref data) => {\n-                word(&mut self.s, \"<\")?;\n+                self.s.word(\"<\")?;\n \n                 let mut comma = false;\n                 for lifetime in &data.lifetimes {\n@@ -2441,22 +2425,22 @@ impl<'a> State<'a> {\n                         self.word_space(\",\")?\n                     }\n                     self.print_ident(binding.ident)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"=\")?;\n                     self.print_type(&binding.ty)?;\n                     comma = true;\n                 }\n \n-                word(&mut self.s, \">\")?\n+                self.s.word(\">\")?\n             }\n \n             ast::PathParameters::Parenthesized(ref data) => {\n-                word(&mut self.s, \"(\")?;\n+                self.s.word(\"(\")?;\n                 self.commasep(\n                     Inconsistent,\n                     &data.inputs,\n                     |s, ty| s.print_type(ty))?;\n-                word(&mut self.s, \")\")?;\n+                self.s.word(\")\")?;\n \n                 if let Some(ref ty) = data.output {\n                     self.space_if_not_bol()?;\n@@ -2475,7 +2459,7 @@ impl<'a> State<'a> {\n         /* Pat isn't normalized, but the beauty of it\n          is that it doesn't matter */\n         match pat.node {\n-            PatKind::Wild => word(&mut self.s, \"_\")?,\n+            PatKind::Wild => self.s.word(\"_\")?,\n             PatKind::Ident(binding_mode, ref path1, ref sub) => {\n                 match binding_mode {\n                     ast::BindingMode::ByRef(mutbl) => {\n@@ -2489,7 +2473,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_ident(path1.node)?;\n                 if let Some(ref p) = *sub {\n-                    word(&mut self.s, \"@\")?;\n+                    self.s.word(\"@\")?;\n                     self.print_pat(p)?;\n                 }\n             }\n@@ -2501,9 +2485,9 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\")?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if ddpos != elts.len() {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p))?;\n                     }\n                 } else {\n@@ -2535,10 +2519,10 @@ impl<'a> State<'a> {\n                     |f| f.node.pat.span)?;\n                 if etc {\n                     if !fields.is_empty() { self.word_space(\",\")?; }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                 }\n-                space(&mut self.s)?;\n-                word(&mut self.s, \"}\")?;\n+                self.s.space()?;\n+                self.s.word(\"}\")?;\n             }\n             PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen()?;\n@@ -2547,42 +2531,42 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\")?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if ddpos != elts.len() {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p))?;\n                     }\n                 } else {\n                     self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p))?;\n                     if elts.len() == 1 {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                     }\n                 }\n                 self.pclose()?;\n             }\n             PatKind::Box(ref inner) => {\n-                word(&mut self.s, \"box \")?;\n+                self.s.word(\"box \")?;\n                 self.print_pat(inner)?;\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                word(&mut self.s, \"&\")?;\n+                self.s.word(\"&\")?;\n                 if mutbl == ast::Mutability::Mutable {\n-                    word(&mut self.s, \"mut \")?;\n+                    self.s.word(\"mut \")?;\n                 }\n                 self.print_pat(inner)?;\n             }\n             PatKind::Lit(ref e) => self.print_expr(&**e)?,\n             PatKind::Range(ref begin, ref end, ref end_kind) => {\n                 self.print_expr(begin)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 match *end_kind {\n-                    RangeEnd::Included => word(&mut self.s, \"...\")?,\n-                    RangeEnd::Excluded => word(&mut self.s, \"..\")?,\n+                    RangeEnd::Included => self.s.word(\"...\")?,\n+                    RangeEnd::Excluded => self.s.word(\"..\")?,\n                 }\n                 self.print_expr(end)?;\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.commasep(Inconsistent,\n                                    &before[..],\n                                    |s, p| s.print_pat(p))?;\n@@ -2591,13 +2575,13 @@ impl<'a> State<'a> {\n                     if p.node != PatKind::Wild {\n                         self.print_pat(p)?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if !after.is_empty() { self.word_space(\",\")?; }\n                 }\n                 self.commasep(Inconsistent,\n                                    &after[..],\n                                    |s, p| s.print_pat(p))?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             PatKind::Mac(ref m) => self.print_mac(m, token::Paren)?,\n         }\n@@ -2608,7 +2592,7 @@ impl<'a> State<'a> {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n         if arm.attrs.is_empty() {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n         }\n         self.cbox(INDENT_UNIT)?;\n         self.ibox(0)?;\n@@ -2619,16 +2603,16 @@ impl<'a> State<'a> {\n             if first {\n                 first = false;\n             } else {\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"|\")?;\n             }\n             self.print_pat(p)?;\n         }\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\")?;\n             self.print_expr(e)?;\n-            space(&mut self.s)?;\n+            self.s.space()?;\n         }\n         self.word_space(\"=>\")?;\n \n@@ -2639,13 +2623,13 @@ impl<'a> State<'a> {\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n-                    word(&mut self.s, \",\")?;\n+                    self.s.word(\",\")?;\n                 }\n             }\n             _ => {\n                 self.end()?; // close the ibox for the pattern\n                 self.print_expr(&arm.body)?;\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n             }\n         }\n         self.end() // close enclosing cbox\n@@ -2655,17 +2639,17 @@ impl<'a> State<'a> {\n         match explicit_self.node {\n             SelfKind::Value(m) => {\n                 self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")\n+                self.s.word(\"self\")\n             }\n             SelfKind::Region(ref lt, m) => {\n-                word(&mut self.s, \"&\")?;\n+                self.s.word(\"&\")?;\n                 self.print_opt_lifetime(lt)?;\n                 self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")\n+                self.s.word(\"self\")\n             }\n             SelfKind::Explicit(ref typ, m) => {\n                 self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")?;\n+                self.s.word(\"self\")?;\n                 self.word_space(\":\")?;\n                 self.print_type(typ)\n             }\n@@ -2696,7 +2680,7 @@ impl<'a> State<'a> {\n         self.popen()?;\n         self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false))?;\n         if decl.variadic {\n-            word(&mut self.s, \", ...\")?;\n+            self.s.word(\", ...\")?;\n         }\n         self.pclose()?;\n \n@@ -2707,9 +2691,9 @@ impl<'a> State<'a> {\n             &mut self,\n             decl: &ast::FnDecl)\n             -> io::Result<()> {\n-        word(&mut self.s, \"|\")?;\n+        self.s.word(\"|\")?;\n         self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, true))?;\n-        word(&mut self.s, \"|\")?;\n+        self.s.word(\"|\")?;\n \n         if let ast::FunctionRetTy::Default(..) = decl.output {\n             return Ok(());\n@@ -2739,7 +2723,7 @@ impl<'a> State<'a> {\n                         bounds: &[ast::TyParamBound])\n                         -> io::Result<()> {\n         if !bounds.is_empty() {\n-            word(&mut self.s, prefix)?;\n+            self.s.word(prefix)?;\n             let mut first = true;\n             for bound in bounds {\n                 self.nbsp()?;\n@@ -2754,7 +2738,7 @@ impl<'a> State<'a> {\n                         self.print_poly_trait_ref(tref)\n                     }\n                     TraitTyParamBound(ref tref, TraitBoundModifier::Maybe) => {\n-                        word(&mut self.s, \"?\")?;\n+                        self.s.word(\"?\")?;\n                         self.print_poly_trait_ref(tref)\n                     }\n                     RegionTyParamBound(ref lt) => {\n@@ -2782,10 +2766,10 @@ impl<'a> State<'a> {\n     {\n         self.print_lifetime(lifetime)?;\n         if !bounds.is_empty() {\n-            word(&mut self.s, \": \")?;\n+            self.s.word(\": \")?;\n             for (i, bound) in bounds.iter().enumerate() {\n                 if i != 0 {\n-                    word(&mut self.s, \" + \")?;\n+                    self.s.word(\" + \")?;\n                 }\n                 self.print_lifetime(bound)?;\n             }\n@@ -2802,7 +2786,7 @@ impl<'a> State<'a> {\n             return Ok(());\n         }\n \n-        word(&mut self.s, \"<\")?;\n+        self.s.word(\"<\")?;\n \n         let mut ints = Vec::new();\n         for i in 0..total {\n@@ -2821,7 +2805,7 @@ impl<'a> State<'a> {\n             }\n         })?;\n \n-        word(&mut self.s, \">\")?;\n+        self.s.word(\">\")?;\n         Ok(())\n     }\n \n@@ -2831,7 +2815,7 @@ impl<'a> State<'a> {\n         self.print_bounds(\":\", &param.bounds)?;\n         match param.default {\n             Some(ref default) => {\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(default)\n             }\n@@ -2845,7 +2829,7 @@ impl<'a> State<'a> {\n             return Ok(())\n         }\n \n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"where\")?;\n \n         for (i, predicate) in where_clause.predicates.iter().enumerate() {\n@@ -2871,7 +2855,7 @@ impl<'a> State<'a> {\n                                                                        ref rhs_ty,\n                                                                        ..}) => {\n                     self.print_type(lhs_ty)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"=\")?;\n                     self.print_type(rhs_ty)?;\n                 }\n@@ -2888,7 +2872,7 @@ impl<'a> State<'a> {\n \n                 if path.segments.last().unwrap().identifier.name !=\n                         ident.name {\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"as\")?;\n                     self.print_ident(ident)?;\n                 }\n@@ -2898,26 +2882,26 @@ impl<'a> State<'a> {\n \n             ast::ViewPathGlob(ref path) => {\n                 self.print_path(path, false, 0, true)?;\n-                word(&mut self.s, \"::*\")\n+                self.s.word(\"::*\")\n             }\n \n             ast::ViewPathList(ref path, ref idents) => {\n                 if path.segments.is_empty() {\n-                    word(&mut self.s, \"{\")?;\n+                    self.s.word(\"{\")?;\n                 } else {\n                     self.print_path(path, false, 0, true)?;\n-                    word(&mut self.s, \"::{\")?;\n+                    self.s.word(\"::{\")?;\n                 }\n                 self.commasep(Inconsistent, &idents[..], |s, w| {\n                     s.print_ident(w.node.name)?;\n                     if let Some(ident) = w.node.rename {\n-                        space(&mut s.s)?;\n+                        s.s.space()?;\n                         s.word_space(\"as\")?;\n                         s.print_ident(ident)?;\n                     }\n                     Ok(())\n                 })?;\n-                word(&mut self.s, \"}\")\n+                self.s.word(\"}\")\n             }\n         }\n     }\n@@ -2950,8 +2934,8 @@ impl<'a> State<'a> {\n                     };\n                     if !invalid {\n                         self.print_pat(&input.pat)?;\n-                        word(&mut self.s, \":\")?;\n-                        space(&mut self.s)?;\n+                        self.s.word(\":\")?;\n+                        self.s.space()?;\n                     }\n                     self.print_type(&input.ty)?;\n                 }\n@@ -2990,7 +2974,7 @@ impl<'a> State<'a> {\n                        -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n-            word(&mut self.s, \"for\")?;\n+            self.s.word(\"for\")?;\n             self.print_generics(generics)?;\n         }\n         let generics = ast::Generics {\n@@ -3026,7 +3010,6 @@ impl<'a> State<'a> {\n             let next = next_pos.unwrap_or(cmnt.pos + BytePos(1));\n             if span.hi < cmnt.pos && cmnt.pos < next && span_line.line == comment_line.line {\n                 self.print_comment(cmnt)?;\n-                self.cur_cmnt_and_lit.cur_cmnt += 1;\n             }\n         }\n         Ok(())\n@@ -3036,11 +3019,10 @@ impl<'a> State<'a> {\n         // If there aren't any remaining comments, then we need to manually\n         // make sure there is a line break at the end.\n         if self.next_comment().is_none() {\n-            hardbreak(&mut self.s)?;\n+            self.s.hardbreak()?;\n         }\n         while let Some(ref cmnt) = self.next_comment() {\n             self.print_comment(cmnt)?;\n-            self.cur_cmnt_and_lit.cur_cmnt += 1;\n         }\n         Ok(())\n     }\n@@ -3074,7 +3056,7 @@ impl<'a> State<'a> {\n                                 constness: ast::Constness,\n                                 abi: Abi,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n-        word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n+        self.s.word(&visibility_qualified(vis, \"\"))?;\n \n         match constness {\n             ast::Constness::NotConst => {}\n@@ -3088,7 +3070,7 @@ impl<'a> State<'a> {\n             self.word_nbsp(&abi.to_string())?;\n         }\n \n-        word(&mut self.s, \"fn\")\n+        self.s.word(\"fn\")\n     }\n \n     pub fn print_unsafety(&mut self, s: ast::Unsafety) -> io::Result<()> {"}]}