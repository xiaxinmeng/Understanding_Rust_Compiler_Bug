{"sha": "53728ff751df4c271d4ea565b6871057a3504fc5", "node_id": "C_kwDOAAsO6NoAKDUzNzI4ZmY3NTFkZjRjMjcxZDRlYTU2NWI2ODcxMDU3YTM1MDRmYzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-20T10:40:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-20T10:40:09Z"}, "message": "Auto merge of #103185 - chenyukang:yukang/fix-span-next-point, r=davidtwco\n\nFix the bug of next_point in source_map\n\nThere is a bug in `next_point`, the new span won't move to next position when be called in the first time.\n\nFor this reason, our current code is working like this:\n1. When we really want to move to the next position, we called two times of `next_point`\n2. Some code which use `next_point` actually done the same thing with `shrink_to_hi`\n\nThis fix make sure when `next_point` is called, span will move with the width at least 1, and also work correctly in the scenario of multiple bytes.\n\nRef: https://github.com/rust-lang/rust/pull/103140#discussion_r997710998\n\nr? `@davidtwco`", "tree": {"sha": "554ce71e5e7e9b3f2f951f23fb017c36339d7d94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/554ce71e5e7e9b3f2f951f23fb017c36339d7d94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53728ff751df4c271d4ea565b6871057a3504fc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53728ff751df4c271d4ea565b6871057a3504fc5", "html_url": "https://github.com/rust-lang/rust/commit/53728ff751df4c271d4ea565b6871057a3504fc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53728ff751df4c271d4ea565b6871057a3504fc5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b3b731b55a588dd34a75bbb87fdaaec2e3f5707", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3b731b55a588dd34a75bbb87fdaaec2e3f5707", "html_url": "https://github.com/rust-lang/rust/commit/4b3b731b55a588dd34a75bbb87fdaaec2e3f5707"}, {"sha": "eb8aa9759dc99b604145f94e5296b7add60e0a48", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb8aa9759dc99b604145f94e5296b7add60e0a48", "html_url": "https://github.com/rust-lang/rust/commit/eb8aa9759dc99b604145f94e5296b7add60e0a48"}], "stats": {"total": 91, "additions": 71, "deletions": 20}, "files": [{"sha": "15e9a8db3c602490e02f88c619d9ae2ce46c56c5", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=53728ff751df4c271d4ea565b6871057a3504fc5", "patch": "@@ -937,13 +937,12 @@ pub fn ensure_complete_parse<'a>(\n             kind_name,\n         );\n         err.note(&msg);\n-        let semi_span = this.sess.source_map().next_point(span);\n \n-        let semi_full_span = semi_span.to(this.sess.source_map().next_point(semi_span));\n-        match this.sess.source_map().span_to_snippet(semi_full_span) {\n+        let semi_span = this.sess.source_map().next_point(span);\n+        match this.sess.source_map().span_to_snippet(semi_span) {\n             Ok(ref snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n                 err.span_suggestion(\n-                    semi_span,\n+                    span.shrink_to_hi(),\n                     \"you might be missing a semicolon here\",\n                     \";\",\n                     Applicability::MaybeIncorrect,"}, {"sha": "0aa2b44a0f87aed557c2dc0d42d3d969533a992c", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=53728ff751df4c271d4ea565b6871057a3504fc5", "patch": "@@ -82,7 +82,7 @@ fn emit_frag_parse_err(\n         );\n         if !e.span.is_dummy() {\n             // early end of macro arm (#52866)\n-            e.replace_span_with(parser.sess.source_map().next_point(parser.token.span));\n+            e.replace_span_with(parser.token.span.shrink_to_hi());\n         }\n     }\n     if e.span.is_dummy() {"}, {"sha": "40d85c833a7dd7376925a583e06c8cdbea80d712", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=53728ff751df4c271d4ea565b6871057a3504fc5", "patch": "@@ -1461,7 +1461,7 @@ impl<'a> Parser<'a> {\n         let (prev_sp, sp) = match (&self.token.kind, self.subparser_name) {\n             // Point at the end of the macro call when reaching end of macro arguments.\n             (token::Eof, Some(_)) => {\n-                let sp = self.sess.source_map().next_point(self.prev_token.span);\n+                let sp = self.prev_token.span.shrink_to_hi();\n                 (sp, sp)\n             }\n             // We don't want to point at the following span after DUMMY_SP.\n@@ -2039,7 +2039,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn expected_expression_found(&self) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let (span, msg) = match (&self.token.kind, self.subparser_name) {\n             (&token::Eof, Some(origin)) => {\n-                let sp = self.sess.source_map().next_point(self.prev_token.span);\n+                let sp = self.prev_token.span.shrink_to_hi();\n                 (sp, format!(\"expected expression, found end of {origin}\"))\n             }\n             _ => ("}, {"sha": "afa116ce1bccd1314063eed2ef24384c4058ac48", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=53728ff751df4c271d4ea565b6871057a3504fc5", "patch": "@@ -2172,7 +2172,7 @@ impl<'a> Parser<'a> {\n                     },\n                 ExprKind::Block(_, None) => {\n                     self.sess.emit_err(IfExpressionMissingCondition {\n-                        if_span: self.sess.source_map().next_point(lo),\n+                        if_span: lo.shrink_to_hi(),\n                         block_span: self.sess.source_map().start_point(cond_span),\n                     });\n                     std::mem::replace(&mut cond, this.mk_expr_err(cond_span.shrink_to_hi()))"}, {"sha": "bda301c52e9603061c215e18e8c5cb9df1acb5cc", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=53728ff751df4c271d4ea565b6871057a3504fc5", "patch": "@@ -1601,7 +1601,7 @@ impl<'a> Parser<'a> {\n                     self.sess.emit_err(err);\n                 } else {\n                     if !seen_comma {\n-                        let sp = self.sess.source_map().next_point(previous_span);\n+                        let sp = previous_span.shrink_to_hi();\n                         err.missing_comma = Some(sp);\n                     }\n                     return Err(err.into_diagnostic(&self.sess.span_diagnostic));"}, {"sha": "4fd5bc1d60a47a6f2184bda3be6944a458b4b2a5", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=53728ff751df4c271d4ea565b6871057a3504fc5", "patch": "@@ -1731,7 +1731,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                             for _ in 0..100 {\n                                 // Try to find an assignment\n                                 sp = sm.next_point(sp);\n-                                let snippet = sm.span_to_snippet(sp.to(sm.next_point(sp)));\n+                                let snippet = sm.span_to_snippet(sp);\n                                 match snippet {\n                                     Ok(ref x) if x.as_str() == \"=\" => {\n                                         err.span_suggestion("}, {"sha": "506ce6955d399f62760662a5e3260490bf019cdc", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=53728ff751df4c271d4ea565b6871057a3504fc5", "patch": "@@ -853,28 +853,36 @@ impl SourceMap {\n     }\n \n     /// Returns a new span representing the next character after the end-point of this span.\n+    /// Special cases:\n+    /// - if span is a dummy one, returns the same span\n+    /// - if next_point reached the end of source, return span with lo = hi\n+    /// - respect multi-byte characters\n     pub fn next_point(&self, sp: Span) -> Span {\n         if sp.is_dummy() {\n             return sp;\n         }\n         let start_of_next_point = sp.hi().0;\n \n-        let width = self.find_width_of_character_at_span(sp.shrink_to_hi(), true);\n-        // If the width is 1, then the next span should point to the same `lo` and `hi`. However,\n-        // in the case of a multibyte character, where the width != 1, the next span should\n+        let width = self.find_width_of_character_at_span(sp, true);\n+        if width == 0 {\n+            return Span::new(sp.hi(), sp.hi(), sp.ctxt(), None);\n+        }\n+        // If the width is 1, then the next span should only contain the next char besides current ending.\n+        // However, in the case of a multibyte character, where the width != 1, the next span should\n         // span multiple bytes to include the whole character.\n         let end_of_next_point =\n-            start_of_next_point.checked_add(width - 1).unwrap_or(start_of_next_point);\n+            start_of_next_point.checked_add(width).unwrap_or(start_of_next_point);\n \n-        let end_of_next_point = BytePos(cmp::max(sp.lo().0 + 1, end_of_next_point));\n+        let end_of_next_point = BytePos(cmp::max(start_of_next_point + 1, end_of_next_point));\n         Span::new(BytePos(start_of_next_point), end_of_next_point, sp.ctxt(), None)\n     }\n \n     /// Finds the width of the character, either before or after the end of provided span,\n     /// depending on the `forwards` parameter.\n     fn find_width_of_character_at_span(&self, sp: Span, forwards: bool) -> u32 {\n         let sp = sp.data();\n-        if sp.lo == sp.hi {\n+\n+        if sp.lo == sp.hi && !forwards {\n             debug!(\"find_width_of_character_at_span: early return empty span\");\n             return 1;\n         }\n@@ -908,9 +916,9 @@ impl SourceMap {\n         let source_len = (local_begin.sf.end_pos - local_begin.sf.start_pos).to_usize();\n         debug!(\"find_width_of_character_at_span: source_len=`{:?}`\", source_len);\n         // Ensure indexes are also not malformed.\n-        if start_index > end_index || end_index > source_len {\n+        if start_index > end_index || end_index > source_len - 1 {\n             debug!(\"find_width_of_character_at_span: source indexes are malformed\");\n-            return 1;\n+            return 0;\n         }\n \n         let src = local_begin.sf.external_src.borrow();"}, {"sha": "1fd81018fa05c2f99442867621df3020050f36b4", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53728ff751df4c271d4ea565b6871057a3504fc5/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=53728ff751df4c271d4ea565b6871057a3504fc5", "patch": "@@ -479,3 +479,48 @@ fn path_prefix_remapping_expand_to_absolute() {\n         RealFileName::Remapped { local_path: None, virtual_name: path(\"XYZ/src/main.rs\") }\n     );\n }\n+\n+#[test]\n+fn test_next_point() {\n+    let sm = SourceMap::new(FilePathMapping::empty());\n+    sm.new_source_file(PathBuf::from(\"example.rs\").into(), \"a\u2026b\".to_string());\n+\n+    // Dummy spans don't advance.\n+    let span = DUMMY_SP;\n+    let span = sm.next_point(span);\n+    assert_eq!(span.lo().0, 0);\n+    assert_eq!(span.hi().0, 0);\n+\n+    // Span advance respect multi-byte character\n+    let span = Span::with_root_ctxt(BytePos(0), BytePos(1));\n+    assert_eq!(sm.span_to_snippet(span), Ok(\"a\".to_string()));\n+    let span = sm.next_point(span);\n+    assert_eq!(sm.span_to_snippet(span), Ok(\"\u2026\".to_string()));\n+    assert_eq!(span.lo().0, 1);\n+    assert_eq!(span.hi().0, 4);\n+\n+    // An empty span pointing just before a multi-byte character should\n+    // advance to contain the multi-byte character.\n+    let span = Span::with_root_ctxt(BytePos(1), BytePos(1));\n+    let span = sm.next_point(span);\n+    assert_eq!(span.lo().0, 1);\n+    assert_eq!(span.hi().0, 4);\n+\n+    let span = Span::with_root_ctxt(BytePos(1), BytePos(4));\n+    let span = sm.next_point(span);\n+    assert_eq!(span.lo().0, 4);\n+    assert_eq!(span.hi().0, 5);\n+\n+    // A non-empty span at the last byte should advance to create an empty\n+    // span pointing at the end of the file.\n+    let span = Span::with_root_ctxt(BytePos(4), BytePos(5));\n+    let span = sm.next_point(span);\n+    assert_eq!(span.lo().0, 5);\n+    assert_eq!(span.hi().0, 5);\n+\n+    // Empty span pointing just past the last byte.\n+    let span = Span::with_root_ctxt(BytePos(5), BytePos(5));\n+    let span = sm.next_point(span);\n+    assert_eq!(span.lo().0, 5);\n+    assert_eq!(span.hi().0, 5);\n+}"}, {"sha": "3347342e412b64c788d639e796feeb9a2f443fc9", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53728ff751df4c271d4ea565b6871057a3504fc5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53728ff751df4c271d4ea565b6871057a3504fc5/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=53728ff751df4c271d4ea565b6871057a3504fc5", "patch": "@@ -769,8 +769,7 @@ impl<T: LintContext> DiagnosticExt<T> for rustc_errors::Diagnostic {\n \n     fn suggest_remove_item(&mut self, cx: &T, item: Span, msg: &str, applicability: Applicability) {\n         let mut remove_span = item;\n-        let hi = cx.sess().source_map().next_point(remove_span).hi();\n-        let fmpos = cx.sess().source_map().lookup_byte_offset(hi);\n+        let fmpos = cx.sess().source_map().lookup_byte_offset(remove_span.hi());\n \n         if let Some(ref src) = fmpos.sf.src {\n             let non_whitespace_offset = src[fmpos.pos.to_usize()..].find(|c| c != ' ' && c != '\\t' && c != '\\n');"}]}