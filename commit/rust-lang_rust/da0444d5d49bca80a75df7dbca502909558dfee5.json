{"sha": "da0444d5d49bca80a75df7dbca502909558dfee5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMDQ0NGQ1ZDQ5YmNhODBhNzVkZjdkYmNhNTAyOTA5NTU4ZGZlZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-26T13:07:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-26T13:07:18Z"}, "message": "Auto merge of #30054 - Ms2ger:TypeOrigin, r=eddyb", "tree": {"sha": "5b2fca3c7453df209d5a92d5d10ccbb8111ea06f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b2fca3c7453df209d5a92d5d10ccbb8111ea06f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da0444d5d49bca80a75df7dbca502909558dfee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da0444d5d49bca80a75df7dbca502909558dfee5", "html_url": "https://github.com/rust-lang/rust/commit/da0444d5d49bca80a75df7dbca502909558dfee5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da0444d5d49bca80a75df7dbca502909558dfee5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d88afe4775436d45ec3050ee5c1488e68afe9e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d88afe4775436d45ec3050ee5c1488e68afe9e2", "html_url": "https://github.com/rust-lang/rust/commit/6d88afe4775436d45ec3050ee5c1488e68afe9e2"}, {"sha": "f24077f8cea8622ea94f6b0b3f9dd263dc8b2e94", "url": "https://api.github.com/repos/rust-lang/rust/commits/f24077f8cea8622ea94f6b0b3f9dd263dc8b2e94", "html_url": "https://github.com/rust-lang/rust/commit/f24077f8cea8622ea94f6b0b3f9dd263dc8b2e94"}], "stats": {"total": 165, "additions": 83, "deletions": 82}, "files": [{"sha": "1b118520339e9400a0b0569e47f643f346e8190d", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -78,7 +78,7 @@ use rustc_front::print::pprust;\n \n use middle::def;\n use middle::def_id::DefId;\n-use middle::infer;\n+use middle::infer::{self, TypeOrigin};\n use middle::region;\n use middle::subst;\n use middle::ty::{self, Ty, HasTypeFlags};\n@@ -474,7 +474,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         self.check_and_note_conflicting_crates(terr, trace.origin.span());\n \n         match trace.origin {\n-            infer::MatchExpressionArm(_, arm_span, source) => match source {\n+            TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n                 hir::MatchSource::IfLetDesugar{..} =>\n                     self.tcx.sess.span_note(arm_span, \"`if let` arm with an incompatible type\"),\n                 _ => self.tcx.sess.span_note(arm_span, \"match arm with an incompatible type\"),\n@@ -1602,38 +1602,38 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n-                    infer::Misc(_) => {\n+                    TypeOrigin::Misc(_) => {\n                         \"types are compatible\"\n                     }\n-                    infer::MethodCompatCheck(_) => {\n+                    TypeOrigin::MethodCompatCheck(_) => {\n                         \"method type is compatible with trait\"\n                     }\n-                    infer::ExprAssignable(_) => {\n+                    TypeOrigin::ExprAssignable(_) => {\n                         \"expression is assignable\"\n                     }\n-                    infer::RelateTraitRefs(_) => {\n+                    TypeOrigin::RelateTraitRefs(_) => {\n                         \"traits are compatible\"\n                     }\n-                    infer::RelateSelfType(_) => {\n+                    TypeOrigin::RelateSelfType(_) => {\n                         \"self type matches impl self type\"\n                     }\n-                    infer::RelateOutputImplTypes(_) => {\n+                    TypeOrigin::RelateOutputImplTypes(_) => {\n                         \"trait type parameters matches those \\\n                                  specified on the impl\"\n                     }\n-                    infer::MatchExpressionArm(_, _, _) => {\n+                    TypeOrigin::MatchExpressionArm(_, _, _) => {\n                         \"match arms have compatible types\"\n                     }\n-                    infer::IfExpression(_) => {\n+                    TypeOrigin::IfExpression(_) => {\n                         \"if and else have compatible types\"\n                     }\n-                    infer::IfExpressionWithNoElse(_) => {\n+                    TypeOrigin::IfExpressionWithNoElse(_) => {\n                         \"if may be missing an else clause\"\n                     }\n-                    infer::RangeExpression(_) => {\n+                    TypeOrigin::RangeExpression(_) => {\n                         \"start and end of range have compatible types\"\n                     }\n-                    infer::EquatePredicate(_) => {\n+                    TypeOrigin::EquatePredicate(_) => {\n                         \"equality where clause is satisfied\"\n                     }\n                 };"}, {"sha": "b39ddfe95c83ab0c7c74629bbf6cad28d78b0038", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -13,7 +13,6 @@\n pub use self::LateBoundRegionConversionTime::*;\n pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n-pub use self::TypeOrigin::*;\n pub use self::ValuePairs::*;\n pub use middle::ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n@@ -440,7 +439,7 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     debug!(\"can_mk_subty({:?} <: {:?})\", a, b);\n     cx.probe(|_| {\n         let trace = TypeTrace {\n-            origin: Misc(codemap::DUMMY_SP),\n+            origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n         };\n         cx.sub(true, trace).relate(&a, &b).map(|_| ())\n@@ -950,7 +949,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n-            let origin = EquatePredicate(span);\n+            let origin = TypeOrigin::EquatePredicate(span);\n             let () = try!(mk_eqty(self, false, origin, a, b));\n             self.leak_check(&skol_map, snapshot)\n         })\n@@ -1328,7 +1327,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                    actual: Ty<'tcx>,\n                                    err: &TypeError<'tcx>) {\n         let trace = TypeTrace {\n-            origin: Misc(span),\n+            origin: TypeOrigin::Misc(span),\n             values: Types(ExpectedFound {\n                 expected: expected,\n                 found: actual\n@@ -1342,7 +1341,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                             expected: type_variable::Default<'tcx>,\n                                             actual: type_variable::Default<'tcx>) {\n         let trace = TypeTrace {\n-            origin: Misc(span),\n+            origin: TypeOrigin::Misc(span),\n             values: Types(ExpectedFound {\n                 expected: expected.ty,\n                 found: actual.ty\n@@ -1393,8 +1392,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // generic so we don't have to do anything quite this\n             // terrible.\n             let e = self.tcx.types.err;\n-            let trace = TypeTrace { origin: Misc(codemap::DUMMY_SP),\n-                                    values: Types(expected_found(true, e, e)) };\n+            let trace = TypeTrace {\n+                origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n+                values: Types(expected_found(true, e, e))\n+            };\n             self.equate(true, trace).relate(a, b)\n         }).map(|_| ())\n     }\n@@ -1525,7 +1526,7 @@ impl<'tcx> TypeTrace<'tcx> {\n \n     pub fn dummy(tcx: &ty::ctxt<'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n-            origin: Misc(codemap::DUMMY_SP),\n+            origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n             values: Types(ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n@@ -1543,17 +1544,17 @@ impl<'tcx> fmt::Debug for TypeTrace<'tcx> {\n impl TypeOrigin {\n     pub fn span(&self) -> Span {\n         match *self {\n-            MethodCompatCheck(span) => span,\n-            ExprAssignable(span) => span,\n-            Misc(span) => span,\n-            RelateTraitRefs(span) => span,\n-            RelateSelfType(span) => span,\n-            RelateOutputImplTypes(span) => span,\n-            MatchExpressionArm(match_span, _, _) => match_span,\n-            IfExpression(span) => span,\n-            IfExpressionWithNoElse(span) => span,\n-            RangeExpression(span) => span,\n-            EquatePredicate(span) => span,\n+            TypeOrigin::MethodCompatCheck(span) => span,\n+            TypeOrigin::ExprAssignable(span) => span,\n+            TypeOrigin::Misc(span) => span,\n+            TypeOrigin::RelateTraitRefs(span) => span,\n+            TypeOrigin::RelateSelfType(span) => span,\n+            TypeOrigin::RelateOutputImplTypes(span) => span,\n+            TypeOrigin::MatchExpressionArm(match_span, _, _) => match_span,\n+            TypeOrigin::IfExpression(span) => span,\n+            TypeOrigin::IfExpressionWithNoElse(span) => span,\n+            TypeOrigin::RangeExpression(span) => span,\n+            TypeOrigin::EquatePredicate(span) => span,\n         }\n     }\n }"}, {"sha": "705cb97a898eb2bf2fcdc1ba90c2d23591c271fd", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -21,7 +21,7 @@ use metadata::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, Ty};\n-use middle::infer::{self, InferCtxt};\n+use middle::infer::{self, InferCtxt, TypeOrigin};\n use syntax::codemap::{DUMMY_SP, Span};\n \n #[derive(Copy, Clone)]\n@@ -70,7 +70,7 @@ fn overlap(selcx: &mut SelectionContext,\n     // Do `a` and `b` unify? If not, no overlap.\n     if let Err(_) = infer::mk_eq_trait_refs(selcx.infcx(),\n                                             true,\n-                                            infer::Misc(DUMMY_SP),\n+                                            TypeOrigin::Misc(DUMMY_SP),\n                                             a_trait_ref,\n                                             b_trait_ref) {\n         return false;"}, {"sha": "8fbfd513c78d6c1a70ef89b3a3d2ed8bb29445a6", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -21,7 +21,7 @@ use super::VtableClosureData;\n use super::VtableImplData;\n use super::util;\n \n-use middle::infer;\n+use middle::infer::{self, TypeOrigin};\n use middle::subst::Subst;\n use middle::ty::{self, ToPredicate, RegionEscape, HasTypeFlags, ToPolyTraitRef, Ty};\n use middle::ty::fold::{TypeFoldable, TypeFolder};\n@@ -138,7 +138,7 @@ fn project_and_unify_type<'cx,'tcx>(\n            obligations);\n \n     let infcx = selcx.infcx();\n-    let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+    let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n     match infer::mk_eqty(infcx, true, origin, normalized_ty, obligation.predicate.ty) {\n         Ok(()) => Ok(Some(obligations)),\n         Err(err) => Err(MismatchedProjectionTypes { err: err }),\n@@ -183,7 +183,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n \n             debug!(\"consider_unification_despite_ambiguity: ret_type={:?}\",\n                    ret_type);\n-            let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+            let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n             let obligation_ty = obligation.predicate.ty;\n             match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n                 Ok(()) => { }\n@@ -645,7 +645,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n                 let same_name = data.item_name() == obligation.predicate.item_name;\n \n                 let is_match = same_name && infcx.probe(|_| {\n-                    let origin = infer::Misc(obligation.cause.span);\n+                    let origin = TypeOrigin::Misc(obligation.cause.span);\n                     let data_poly_trait_ref =\n                         data.to_poly_trait_ref();\n                     let obligation_poly_trait_ref =\n@@ -901,7 +901,7 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n     assert_eq!(projection.projection_ty.item_name,\n                obligation.predicate.item_name);\n \n-    let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+    let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n     match infcx.eq_trait_refs(false,\n                               origin,\n                               obligation.predicate.trait_ref.clone(),"}, {"sha": "e73f0cafb0449fb84005f96497963a488f90f737", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -38,7 +38,7 @@ use super::util;\n \n use middle::def_id::DefId;\n use middle::infer;\n-use middle::infer::{InferCtxt, TypeFreshener};\n+use middle::infer::{InferCtxt, TypeFreshener, TypeOrigin};\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPredicate, RegionEscape, ToPolyTraitRef, Ty, HasTypeFlags};\n use middle::ty::fast_reject;\n@@ -1155,7 +1155,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n-        let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+        let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n         match self.infcx.sub_poly_trait_refs(false,\n                                              origin,\n                                              trait_bound.clone(),\n@@ -2444,7 +2444,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                expected_trait_ref: ty::PolyTraitRef<'tcx>)\n                                -> Result<(), SelectionError<'tcx>>\n     {\n-        let origin = infer::RelateOutputImplTypes(obligation_cause.span);\n+        let origin = TypeOrigin::RelateOutputImplTypes(obligation_cause.span);\n \n         let obligation_trait_ref = obligation_trait_ref.clone();\n         match self.infcx.sub_poly_trait_refs(false,\n@@ -2483,7 +2483,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 };\n \n                 let new_trait = tcx.mk_trait(data_a.principal.clone(), bounds);\n-                let origin = infer::Misc(obligation.cause.span);\n+                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, new_trait, target).is_err() {\n                     return Err(Unimplemented);\n                 }\n@@ -2548,7 +2548,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n-                let origin = infer::Misc(obligation.cause.span);\n+                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, a, b).is_err() {\n                     return Err(Unimplemented);\n                 }\n@@ -2606,7 +2606,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     new_substs.types.get_mut_slice(TypeSpace)[i] = param_b;\n                 }\n                 let new_struct = tcx.mk_struct(def, tcx.mk_substs(new_substs));\n-                let origin = infer::Misc(obligation.cause.span);\n+                let origin = TypeOrigin::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n                     return Err(Unimplemented);\n                 }\n@@ -2694,7 +2694,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                impl_trait_ref,\n                skol_obligation_trait_ref);\n \n-        let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+        let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n         if let Err(e) = self.infcx.eq_trait_refs(false,\n                                                  origin,\n                                                  impl_trait_ref.value.clone(),\n@@ -2763,7 +2763,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation,\n                poly_trait_ref);\n \n-        let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+        let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n         match self.infcx.sub_poly_trait_refs(false,\n                                              origin,\n                                              poly_trait_ref,"}, {"sha": "aa439e102ebac332ecc35a974c20395c239d9806", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -25,7 +25,7 @@ use rustc_typeck::middle::subst;\n use rustc_typeck::middle::subst::Subst;\n use rustc_typeck::middle::ty::{self, Ty, RegionEscape};\n use rustc_typeck::middle::ty::relate::TypeRelation;\n-use rustc_typeck::middle::infer;\n+use rustc_typeck::middle::infer::{self, TypeOrigin};\n use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;\n use rustc_typeck::middle::infer::sub::Sub;\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n+        match infer::mk_subty(self.infcx, true, TypeOrigin::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\", e),\n         }"}, {"sha": "5ffe34d61bf7d72243f3d9a70997cd3e0d779fa4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::def;\n-use middle::infer;\n+use middle::infer::{self, TypeOrigin};\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n use middle::privacy::{AllPublic, LastMod};\n@@ -509,12 +509,12 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 /* if-let construct without an else block */\n                 hir::MatchSource::IfLetDesugar { contains_else_clause }\n                 if !contains_else_clause => (\n-                    infer::IfExpressionWithNoElse(expr.span),\n+                    TypeOrigin::IfExpressionWithNoElse(expr.span),\n                     bty,\n                     result_ty,\n                 ),\n                 _ => (\n-                    infer::MatchExpressionArm(expr.span, arm.body.span, match_src),\n+                    TypeOrigin::MatchExpressionArm(expr.span, arm.body.span, match_src),\n                     result_ty,\n                     bty,\n                 ),"}, {"sha": "85f0aa3bbd3c3c7fcad4020eadc89c38ed54aef6", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -62,7 +62,7 @@\n \n use check::{autoderef, FnCtxt, UnresolvedTypeAction};\n \n-use middle::infer::{self, Coercion};\n+use middle::infer::{self, Coercion, TypeOrigin};\n use middle::traits::{self, ObligationCause};\n use middle::traits::{predicate_for_trait_def, report_selection_error};\n use middle::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n@@ -444,7 +444,7 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.infcx().commit_if_ok(|_| {\n             let coerce = Coerce {\n                 fcx: fcx,\n-                origin: infer::ExprAssignable(expr.span),\n+                origin: TypeOrigin::ExprAssignable(expr.span),\n                 unsizing_obligations: RefCell::new(vec![])\n             };\n             let adjustment = try!(coerce.coerce(expr, a, b));"}, {"sha": "d28a673f748c07c46157d74a253d9d386a908b5a", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::free_region::FreeRegionMap;\n-use middle::infer;\n+use middle::infer::{self, TypeOrigin};\n use middle::traits;\n use middle::ty::{self};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace};\n@@ -282,7 +282,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n     let err = infcx.commit_if_ok(|snapshot| {\n-        let origin = infer::MethodCompatCheck(impl_m_span);\n+        let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n         let (impl_sig, _) =\n             infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n@@ -448,7 +448,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n \n     let err = infcx.commit_if_ok(|_| {\n-        let origin = infer::Misc(impl_c_span);\n+        let origin = TypeOrigin::Misc(impl_c_span);\n \n         // There is no \"body\" here, so just pass dummy id.\n         let impl_ty ="}, {"sha": "63dac49b384a7aa23d865bf4494ed2114363cd76", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -11,7 +11,7 @@\n \n use check::{coercion, FnCtxt};\n use middle::ty::{self, Ty};\n-use middle::infer;\n+use middle::infer::{self, TypeOrigin};\n \n use std::result::Result::{Err, Ok};\n use syntax::codemap::Span;\n@@ -35,7 +35,7 @@ pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::error::TypeError<'tcx>),\n {\n     // n.b.: order of actual, expected is reversed\n-    match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n+    match infer::mk_subty(fcx.infcx(), b_is_expected, TypeOrigin::Misc(sp),\n                           ty_b, ty_a) {\n       Ok(()) => { /* ok */ }\n       Err(ref err) => {\n@@ -46,7 +46,7 @@ pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-    match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n+    match infer::mk_eqty(fcx.infcx(), false, TypeOrigin::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => { fcx.report_mismatched_types(sp, expected, actual, err); }\n     }"}, {"sha": "b2462a3612ca4821b2530507eea02d236fbaf449", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -19,7 +19,7 @@ use middle::ty::{self, NoPreference, PreferMutLvalue, Ty};\n use middle::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use middle::ty::fold::TypeFoldable;\n use middle::infer;\n-use middle::infer::InferCtxt;\n+use middle::infer::{InferCtxt, TypeOrigin};\n use syntax::codemap::Span;\n use rustc_front::hir;\n \n@@ -367,7 +367,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                        self_ty: Ty<'tcx>,\n                        method_self_ty: Ty<'tcx>)\n     {\n-        match self.fcx.mk_subty(false, infer::Misc(self.span), self_ty, method_self_ty) {\n+        match self.fcx.mk_subty(false, TypeOrigin::Misc(self.span), self_ty, method_self_ty) {\n             Ok(_) => {}\n             Err(_) => {\n                 self.tcx().sess.span_bug("}, {"sha": "59790d7226556c43b553ac249a5dec96aa03c3ca", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -23,7 +23,7 @@ use middle::ty::{self, NoPreference, RegionEscape, Ty, ToPolyTraitRef, TraitRef}\n use middle::ty::HasTypeFlags;\n use middle::ty::fold::TypeFoldable;\n use middle::infer;\n-use middle::infer::InferCtxt;\n+use middle::infer::{InferCtxt, TypeOrigin};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n use rustc_front::hir;\n@@ -1136,7 +1136,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     // MISCELLANY\n \n     fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::UnitResult<'tcx> {\n-        self.infcx().sub_types(false, infer::Misc(DUMMY_SP), sub, sup)\n+        self.infcx().sub_types(false, TypeOrigin::Misc(DUMMY_SP), sub, sup)\n     }\n \n     fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {"}, {"sha": "c375eb19a373352f314f9f393d5d8c3e70cff8f8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -88,7 +88,7 @@ use middle::astconv_util::prohibit_type_params;\n use middle::def;\n use middle::def_id::DefId;\n use middle::infer;\n-use middle::infer::type_variable;\n+use middle::infer::{TypeOrigin, type_variable};\n use middle::pat_util::{self, pat_id_map};\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n@@ -1610,7 +1610,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn mk_subty(&self,\n                     a_is_expected: bool,\n-                    origin: infer::TypeOrigin,\n+                    origin: TypeOrigin,\n                     sub: Ty<'tcx>,\n                     sup: Ty<'tcx>)\n                     -> Result<(), TypeError<'tcx>> {\n@@ -1619,7 +1619,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn mk_eqty(&self,\n                    a_is_expected: bool,\n-                   origin: infer::TypeOrigin,\n+                   origin: TypeOrigin,\n                    sub: Ty<'tcx>,\n                    sup: Ty<'tcx>)\n                    -> Result<(), TypeError<'tcx>> {\n@@ -1897,7 +1897,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 if let Some(default) = default_map.get(ty) {\n                                     let default = default.clone();\n                                     match infer::mk_eqty(self.infcx(), false,\n-                                                         infer::Misc(default.origin_span),\n+                                                         TypeOrigin::Misc(default.origin_span),\n                                                          ty, default.ty) {\n                                         Ok(()) => {}\n                                         Err(_) => {\n@@ -1990,7 +1990,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(default) = default_map.get(ty) {\n                             let default = default.clone();\n                             match infer::mk_eqty(self.infcx(), false,\n-                                                 infer::Misc(default.origin_span),\n+                                                 TypeOrigin::Misc(default.origin_span),\n                                                  ty, default.ty) {\n                                 Ok(()) => {}\n                                 Err(_) => {\n@@ -2784,7 +2784,7 @@ fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 // return type (likely containing type variables if the function\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n-                let origin = infer::Misc(call_span);\n+                let origin = TypeOrigin::Misc(call_span);\n                 let ures = fcx.infcx().sub_types(false, origin, formal_ret_ty, ret_ty);\n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n@@ -2898,14 +2898,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 check_expr_with_expectation(fcx, &**else_expr, expected);\n                 let else_ty = fcx.expr_ty(&**else_expr);\n                 infer::common_supertype(fcx.infcx(),\n-                                        infer::IfExpression(sp),\n+                                        TypeOrigin::IfExpression(sp),\n                                         true,\n                                         then_ty,\n                                         else_ty)\n             }\n             None => {\n                 infer::common_supertype(fcx.infcx(),\n-                                        infer::IfExpressionWithNoElse(sp),\n+                                        TypeOrigin::IfExpressionWithNoElse(sp),\n                                         false,\n                                         then_ty,\n                                         fcx.tcx().mk_nil())\n@@ -3405,7 +3405,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             ty::FnConverging(result_type) => {\n                 match *expr_opt {\n                     None =>\n-                        if let Err(_) = fcx.mk_eqty(false, infer::Misc(expr.span),\n+                        if let Err(_) = fcx.mk_eqty(false, TypeOrigin::Misc(expr.span),\n                                                     result_type, fcx.tcx().mk_nil()) {\n                             span_err!(tcx.sess, expr.span, E0069,\n                                 \"`return;` in a function whose return type is \\\n@@ -3689,7 +3689,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n               }\n               (Some(t_start), Some(t_end)) => {\n                   Some(infer::common_supertype(fcx.infcx(),\n-                                               infer::RangeExpression(expr.span),\n+                                               TypeOrigin::RangeExpression(expr.span),\n                                                true,\n                                                t_start,\n                                                t_end))\n@@ -4585,7 +4585,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                    impl_scheme.generics.regions.len(subst::TypeSpace));\n \n         let impl_ty = fcx.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n-        if fcx.mk_subty(false, infer::Misc(span), self_ty, impl_ty).is_err() {\n+        if fcx.mk_subty(false, TypeOrigin::Misc(span), self_ty, impl_ty).is_err() {\n             fcx.tcx().sess.span_bug(span,\n             &format!(\n                 \"instantiate_path: (UFCS) {:?} was a subtype of {:?} but now is not?\","}, {"sha": "549824d22a4ae1264965676f8b6ac4fbbabf1a5f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -93,7 +93,7 @@ use middle::region::CodeExtent;\n use middle::subst::Substs;\n use middle::traits;\n use middle::ty::{self, RegionEscape, ReScope, Ty, MethodCall, HasTypeFlags};\n-use middle::infer::{self, GenericKind, InferCtxt, SubregionOrigin, VerifyBound};\n+use middle::infer::{self, GenericKind, InferCtxt, SubregionOrigin, TypeOrigin, VerifyBound};\n use middle::pat_util;\n use middle::ty::adjustment;\n use middle::ty::wf::ImpliedBound;\n@@ -1868,7 +1868,7 @@ fn declared_projection_bounds_from_trait<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n                        outlives);\n \n                 // check whether this predicate applies to our current projection\n-                match infer::mk_eqty(infcx, false, infer::Misc(span), ty, outlives.0) {\n+                match infer::mk_eqty(infcx, false, TypeOrigin::Misc(span), ty, outlives.0) {\n                     Ok(()) => { Ok(outlives.1) }\n                     Err(_) => { Err(()) }\n                 }"}, {"sha": "4c81c807ebd3859800cc5cab5345ae652ec9995b", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -33,7 +33,7 @@ use middle::ty::TyProjection;\n use middle::ty::util::CopyImplementationError;\n use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n-use middle::infer::{self, InferCtxt, new_infer_ctxt};\n+use middle::infer::{self, InferCtxt, TypeOrigin, new_infer_ctxt};\n use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::codemap::Span;\n@@ -406,7 +406,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                         return;\n                     }\n \n-                    let origin = infer::Misc(span);\n+                    let origin = TypeOrigin::Misc(span);\n                     let fields = &def_a.struct_variant().fields;\n                     let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n                         let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));"}, {"sha": "3d28a912179ae7005efacd80d437c19df9b3fe8b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da0444d5d49bca80a75df7dbca502909558dfee5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=da0444d5d49bca80a75df7dbca502909558dfee5", "patch": "@@ -106,7 +106,7 @@ pub use rustc::util;\n \n use front::map as hir_map;\n use middle::def;\n-use middle::infer;\n+use middle::infer::{self, TypeOrigin};\n use middle::subst;\n use middle::ty::{self, Ty, HasTypeFlags};\n use session::config;\n@@ -200,10 +200,10 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n     let result = match maybe_infcx {\n         None => {\n             let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n-            infer::mk_eqty(&infcx, t1_is_expected, infer::Misc(span), t1, t2)\n+            infer::mk_eqty(&infcx, t1_is_expected, TypeOrigin::Misc(span), t1, t2)\n         }\n         Some(infcx) => {\n-            infer::mk_eqty(infcx, t1_is_expected, infer::Misc(span), t1, t2)\n+            infer::mk_eqty(infcx, t1_is_expected, TypeOrigin::Misc(span), t1, t2)\n         }\n     };\n "}]}