{"sha": "7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjYmQ0YjIwZWU4NTdjZjM4M2VmMWMwZDhiMzQ3MjdhNDMzMjMxYTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-28T00:41:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-10T00:43:59Z"}, "message": "Remove @ast::Region and replace with @ast::Lifetime.\nModify pretty-printer to emit lifetimes and fix a few minor\nparser bugs that this uncovered.", "tree": {"sha": "519693f796860294ff1953ff468b5a5c4aa7d462", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/519693f796860294ff1953ff468b5a5c4aa7d462"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "html_url": "https://github.com/rust-lang/rust/commit/7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98ce99d500b13c79fd8e74e807167d8a59caf0e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/98ce99d500b13c79fd8e74e807167d8a59caf0e7", "html_url": "https://github.com/rust-lang/rust/commit/98ce99d500b13c79fd8e74e807167d8a59caf0e7"}], "stats": {"total": 440, "additions": 195, "deletions": 245}, "files": [{"sha": "a96ed9b8fa6da7d42ddf93740acf9a51ba918dd8", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -31,6 +31,7 @@ use std::oldmap::HashMap;\n use syntax::ast_map;\n use syntax::codemap::span;\n use syntax::print::pprust;\n+use syntax::parse::token::special_idents;\n use syntax::{ast, visit};\n \n pub type parent = Option<ast::node_id>;\n@@ -546,29 +547,20 @@ pub impl DetermineRpCtxt {\n     // with &self type, &self is also bound.  We detect those last two\n     // cases via flags (anon_implies_rp and self_implies_rp) that are\n     // true when the anon or self region implies RP.\n-    fn region_is_relevant(&self, r: @ast::region) -> bool {\n-        match r.node {\n-            ast::re_static => false,\n-            ast::re_anon => self.anon_implies_rp,\n-            ast::re_self => self.self_implies_rp,\n-            ast::re_named(_) => false\n-        }\n-    }\n-\n-    // For named types like Foo, if there is no explicit region\n-    // parameter, then we will add the anonymous region, so there is\n-    // a dependency if the anonymous region implies rp.\n-    //\n-    // If the region is explicitly specified, then we follows the\n-    // normal rules.\n-    fn opt_region_is_relevant(&self,\n-                              opt_r: Option<@ast::region>)\n-                           -> bool {\n-        debug!(\"opt_region_is_relevant: %? (anon_implies_rp=%b)\",\n-               opt_r, self.anon_implies_rp);\n-        match opt_r {\n-          None => self.anon_implies_rp,\n-          Some(r) => self.region_is_relevant(r)\n+    fn region_is_relevant(&self, r: Option<@ast::Lifetime>) -> bool {\n+        match r {\n+            None => {\n+                self.anon_implies_rp\n+            }\n+            Some(ref l) if l.ident == special_idents::static => {\n+                false\n+            }\n+            Some(ref l) if l.ident == special_idents::self_ => {\n+                self.self_implies_rp\n+            }\n+            Some(_) => {\n+                false\n+            }\n         }\n     }\n \n@@ -672,8 +664,8 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n             debug!(\"referenced fn type: %s\",\n                    pprust::ty_to_str(ty, sess.intr()));\n             match f.region {\n-                Some(r) => {\n-                    if cx.region_is_relevant(r) {\n+                Some(_) => {\n+                    if cx.region_is_relevant(f.region) {\n                         cx.add_rp(cx.item_id,\n                                   cx.add_variance(rv_contravariant))\n                     }\n@@ -699,7 +691,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n         match cx.def_map.find(&id) {\n           Some(ast::def_ty(did)) | Some(ast::def_struct(did)) => {\n             if did.crate == ast::local_crate {\n-                if cx.opt_region_is_relevant(path.rp) {\n+                if cx.region_is_relevant(path.rp) {\n                     cx.add_dep(did.node);\n                 }\n             } else {\n@@ -709,7 +701,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n                   Some(variance) => {\n                     debug!(\"reference to external, rp'd type %s\",\n                            pprust::ty_to_str(ty, sess.intr()));\n-                    if cx.opt_region_is_relevant(path.rp) {\n+                    if cx.region_is_relevant(path.rp) {\n                         cx.add_rp(cx.item_id, cx.add_variance(variance))\n                     }\n                   }"}, {"sha": "8152200bf0476edf1dc3f1322e2a6df0744adf88", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -65,7 +65,8 @@ use core::result;\n use core::vec;\n use syntax::ast;\n use syntax::codemap::span;\n-use syntax::print::pprust::{region_to_str, path_to_str};\n+use syntax::print::pprust::{lifetime_to_str, path_to_str};\n+use syntax::parse::token::special_idents;\n use util::common::indenter;\n \n pub trait AstConv {\n@@ -79,21 +80,16 @@ pub trait AstConv {\n pub fn get_region_reporting_err(\n     tcx: ty::ctxt,\n     span: span,\n-    a_r: Option<@ast::region>,\n+    a_r: Option<@ast::Lifetime>,\n     res: Result<ty::Region, RegionError>) -> ty::Region\n {\n     match res {\n         result::Ok(r) => r,\n         result::Err(ref e) => {\n             let descr = match a_r {\n                 None => ~\"anonymous lifetime\",\n-                Some(a) if a.node == ast::re_anon => {\n-                    ~\"anonymous lifetime\"\n-                }\n-                Some(a) => {\n-                    fmt!(\"lifetime %s\",\n-                         region_to_str(a, tcx.sess.intr()))\n-                }\n+                Some(a) => fmt!(\"lifetime %s\",\n+                                lifetime_to_str(a, tcx.sess.intr()))\n             };\n             tcx.sess.span_err(\n                 span,\n@@ -105,19 +101,28 @@ pub fn get_region_reporting_err(\n }\n \n pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + Durable>(\n-        self: &AC,\n-        rscope: &RS,\n-        span: span,\n-        a_r: @ast::region)\n-     -> ty::Region {\n-    let res = match a_r.node {\n-        ast::re_static => Ok(ty::re_static),\n-        ast::re_anon => rscope.anon_region(span),\n-        ast::re_self => rscope.self_region(span),\n-        ast::re_named(id) => rscope.named_region(span, id)\n+    self: &AC,\n+    rscope: &RS,\n+    default_span: span,\n+    opt_lifetime: Option<@ast::Lifetime>) -> ty::Region\n+{\n+    let (span, res) = match opt_lifetime {\n+        None => {\n+            (default_span, rscope.anon_region(default_span))\n+        }\n+        Some(ref lifetime) if lifetime.ident == special_idents::static => {\n+            (lifetime.span, Ok(ty::re_static))\n+        }\n+        Some(ref lifetime) if lifetime.ident == special_idents::self_ => {\n+            (lifetime.span, rscope.self_region(lifetime.span))\n+        }\n+        Some(ref lifetime) => {\n+            (lifetime.span, rscope.named_region(lifetime.span,\n+                                                lifetime.ident))\n+        }\n     };\n \n-    get_region_reporting_err(self.tcx(), span, Some(a_r), res)\n+    get_region_reporting_err(self.tcx(), span, opt_lifetime, res)\n }\n \n pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n@@ -156,8 +161,8 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         let r = get_region_reporting_err(self.tcx(), path.span, None, res);\n         Some(r)\n       }\n-      (Some(_), Some(r)) => {\n-        Some(ast_region_to_region(self, rscope, path.span, r))\n+      (Some(_), Some(_)) => {\n+        Some(ast_region_to_region(self, rscope, path.span, path.rp))\n       }\n     };\n \n@@ -504,7 +509,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n         sigil: ast::Sigil,\n         purity: ast::purity,\n         onceness: ast::Onceness,\n-        opt_region: Option<@ast::region>,\n+        opt_lifetime: Option<@ast::Lifetime>,\n         decl: &ast::fn_decl,\n         expected_tys: Option<ty::FnSig>,\n         span: span)\n@@ -514,9 +519,9 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n \n     // resolve the function bound region in the original region\n     // scope `rscope`, not the scope of the function parameters\n-    let bound_region = match opt_region {\n-        Some(region) => {\n-            ast_region_to_region(self, rscope, span, region)\n+    let bound_region = match opt_lifetime {\n+        Some(_) => {\n+            ast_region_to_region(self, rscope, span, opt_lifetime)\n         }\n         None => {\n             match sigil {\n@@ -526,9 +531,8 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + Durable>(\n                     ty::re_static\n                 }\n                 ast::BorrowedSigil => {\n-                    // &fn() defaults to an anonymous region:\n-                    let r_result = rscope.anon_region(span);\n-                    get_region_reporting_err(self.tcx(), span, None, r_result)\n+                    // &fn() defaults as normal for an omitted lifetime:\n+                    ast_region_to_region(self, rscope, span, opt_lifetime)\n                 }\n             }\n         }"}, {"sha": "0798e2b7afe6e207e923e1a9876169f83e0d83c2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -2950,19 +2950,19 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n     // determine the region bound, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n     let self_r = match pth.rp {\n-      Some(r) => {\n+      Some(_) => { // user supplied a lifetime parameter...\n         match tpt.region_param {\n-          None => {\n+          None => { // ...but the type is not lifetime parameterized!\n             fcx.ccx.tcx.sess.span_err\n                 (span, ~\"this item is not region-parameterized\");\n             None\n           }\n-          Some(_) => {\n-            Some(ast_region_to_region(fcx, fcx, span, r))\n+          Some(_) => { // ...and the type is lifetime parameterized, ok.\n+            Some(ast_region_to_region(fcx, fcx, span, pth.rp))\n           }\n         }\n       }\n-      None => {\n+      None => { // no lifetime parameter supplied, insert default\n         fcx.region_var_if_parameterized(\n             tpt.region_param, span, region_lb)\n       }"}, {"sha": "3782208eb851ce97ae7001194a6a10228c01a69d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -116,7 +116,7 @@ pub struct path {\n     span: span,\n     global: bool,\n     idents: ~[ident],\n-    rp: Option<@region>,\n+    rp: Option<@Lifetime>,\n     types: ~[@Ty],\n }\n \n@@ -374,10 +374,10 @@ impl ToStr for Sigil {\n #[deriving_eq]\n pub enum vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n-    vstore_fixed(Option<uint>),   // [1,2,3,4]\n-    vstore_uniq,                  // ~[1,2,3,4]\n-    vstore_box,                   // @[1,2,3,4]\n-    vstore_slice(@region)         // &[1,2,3,4](foo)?\n+    vstore_fixed(Option<uint>),     // [1,2,3,4]\n+    vstore_uniq,                    // ~[1,2,3,4]\n+    vstore_box,                     // @[1,2,3,4]\n+    vstore_slice(Option<@Lifetime>) // &'foo? [1,2,3,4]\n }\n \n #[auto_encode]\n@@ -857,24 +857,6 @@ pub enum prim_ty {\n     ty_bool,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving_eq]\n-pub struct region {\n-    id: node_id,\n-    node: region_,\n-}\n-\n-#[auto_encode]\n-#[auto_decode]\n-#[deriving_eq]\n-pub enum region_ {\n-    re_anon,\n-    re_static,\n-    re_self,\n-    re_named(ident)\n-}\n-\n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]\n@@ -903,7 +885,7 @@ impl to_bytes::IterBytes for Onceness {\n #[deriving_eq]\n pub struct TyClosure {\n     sigil: Sigil,\n-    region: Option<@region>,\n+    region: Option<@Lifetime>,\n     purity: purity,\n     onceness: Onceness,\n     decl: fn_decl\n@@ -929,7 +911,7 @@ pub enum ty_ {\n     ty_vec(mt),\n     ty_fixed_length_vec(mt, uint),\n     ty_ptr(mt),\n-    ty_rptr(@region, mt),\n+    ty_rptr(Option<@Lifetime>, mt),\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n     ty_tup(~[@Ty]),"}, {"sha": "ecb5be6cc3c61a9f1babdcaca0d58f6cd780faeb", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -594,10 +594,7 @@ fn mk_ser_method(\n     let ty_s = @ast::Ty {\n         id: cx.next_id(),\n         node: ast::ty_rptr(\n-            @ast::region {\n-                id: cx.next_id(),\n-                node: ast::re_anon,\n-            },\n+            None,\n             ast::mt {\n                 ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n                 mutbl: ast::m_imm\n@@ -658,10 +655,7 @@ fn mk_deser_method(\n     let ty_d = @ast::Ty {\n         id: cx.next_id(),\n         node: ast::ty_rptr(\n-            @ast::region {\n-                id: cx.next_id(),\n-                node: ast::re_anon,\n-            },\n+            None,\n             ast::mt {\n                 ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n                 mutbl: ast::m_imm"}, {"sha": "efea962a0892d67189b630e7bfb00909dc251392", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -19,7 +19,7 @@ use ast::{enum_variant_kind, expr, expr_match, ident, impure_fn, item, item_};\n use ast::{item_enum, item_impl, item_struct, Generics};\n use ast::{m_imm, meta_item, method};\n use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n-use ast::{re_anon, stmt, struct_def, struct_variant_kind};\n+use ast::{stmt, struct_def, struct_variant_kind};\n use ast::{sty_by_ref, sty_region, tuple_variant_kind, ty_nil, TyParam};\n use ast::{TyParamBound, ty_path, ty_rptr, unnamed_field, variant};\n use ext::base::ext_ctxt;\n@@ -147,9 +147,8 @@ fn create_eq_method(cx: ext_ctxt,\n                                                      span,\n                                                      type_ident,\n                                                      generics);\n-    let arg_region = @ast::region { id: cx.next_id(), node: re_anon };\n     let arg_type = ty_rptr(\n-        arg_region,\n+        None,\n         ast::mt { ty: arg_path_type, mutbl: m_imm }\n     );\n     let arg_type = @ast::Ty {"}, {"sha": "97ff175da07fec0c99faf0a5006b334f4e517abf", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -52,6 +52,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteRecordType,\n     ObsoleteRecordPattern,\n     ObsoleteAssertion,\n+    ObsoletePostFnTySigil,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -160,6 +161,11 @@ pub impl Parser {\n                 \"assertion\",\n                 \"use `fail_unless!()` instead\"\n             ),\n+            ObsoletePostFnTySigil => (\n+                \"fn sigil in postfix position\",\n+                \"Rather than `fn@`, `fn~`, or `fn&`, \\\n+                 write `@fn`, `~fn`, and `&fn` respectively\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "adcaa006247fa3e3e2b826ea91d1918e4b2553d5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 74, "deletions": 91, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -14,7 +14,7 @@ use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil, RustAbi};\n use ast::{CallSugar, NoSugar, DoSugar, ForSugar};\n use ast::{TyBareFn, TyClosure};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n-use ast::{provided, public, pure_fn, purity, re_static};\n+use ast::{provided, public, pure_fn, purity};\n use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n use ast::{blk_check_mode, box, by_copy, by_ref, by_val};\n@@ -40,9 +40,9 @@ use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local, m_const};\n use ast::{m_imm, m_mutbl, mac_, mac_invoc_tt, matcher, match_nonterminal};\n use ast::{match_seq, match_tok, method, mode, module_ns, mt, mul, mutability};\n use ast::{named_field, neg, node_id, noreturn, not, pat, pat_box, pat_enum};\n-use ast::{pat_ident, pat_lit, pat_range, pat_region, pat_struct, pat_tup};\n-use ast::{pat_uniq, pat_wild, path, private};\n-use ast::{re_self, re_anon, re_named, region, rem, required};\n+use ast::{pat_ident, pat_lit, pat_range, pat_region, pat_struct};\n+use ast::{pat_tup, pat_uniq, pat_wild, path, private};\n+use ast::{rem, required};\n use ast::{ret_style, return_val, self_ty, shl, shr, stmt, stmt_decl};\n use ast::{stmt_expr, stmt_semi, stmt_mac, struct_def, struct_field};\n use ast::{struct_immutable, struct_mutable, struct_variant_kind, subtract};\n@@ -76,7 +76,7 @@ use parse::obsolete::{ObsoleteUnsafeBlock, ObsoleteImplSyntax};\n use parse::obsolete::{ObsoleteTraitBoundSeparator, ObsoleteMutOwnedPointer};\n use parse::obsolete::{ObsoleteMutVector, ObsoleteTraitImplVisibility};\n use parse::obsolete::{ObsoleteRecordType, ObsoleteRecordPattern};\n-use parse::obsolete::{ObsoleteAssertion};\n+use parse::obsolete::{ObsoleteAssertion, ObsoletePostFnTySigil};\n use parse::prec::{as_prec, token_to_binop};\n use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, special_idents};\n@@ -363,12 +363,13 @@ pub impl Parser {\n         });\n     }\n \n-    fn parse_ty_closure(&self, pre_sigil: Option<ast::Sigil>,\n-                        pre_region_name: Option<ident>) -> ty_\n+    fn parse_ty_closure(&self,\n+                        sigil: ast::Sigil,\n+                        region: Option<@ast::Lifetime>) -> ty_\n     {\n         /*\n \n-        (&|~|@) [r/] [pure|unsafe] [once] fn <'lt> (S) -> T\n+        (&|~|@) ['r] [pure|unsafe] [once] fn <'lt> (S) -> T\n         ^~~~~~^ ^~~^ ^~~~~~~~~~~~^ ^~~~~^    ^~~~^ ^~^    ^\n            |     |     |             |         |    |     |\n            |     |     |             |         |    |   Return type\n@@ -388,13 +389,10 @@ pub impl Parser {\n         let onceness = parse_onceness(self);\n         self.expect_keyword(&~\"fn\");\n \n-        let sigil = match pre_sigil { None => BorrowedSigil, Some(p) => p };\n-\n-        let region = if pre_region_name.is_some() {\n-            Some(self.region_from_name(pre_region_name))\n-        } else {\n-            None\n-        };\n+        if self.parse_fn_ty_sigil().is_some() {\n+            self.obsolete(*self.span,\n+                          ObsoletePostFnTySigil);\n+        }\n \n         return ty_closure(@TyClosure {\n             sigil: sigil,\n@@ -432,7 +430,7 @@ pub impl Parser {\n         */\n         if self.eat(&token::LT) {\n             let _lifetimes = self.parse_lifetimes();\n-            self.expect(&token::GT);\n+            self.expect_gt();\n         }\n         let inputs = self.parse_unspanned_seq(\n             &token::LPAREN,\n@@ -575,38 +573,6 @@ pub impl Parser {\n         }\n     }\n \n-    fn region_from_name(&self, s: Option<ident>) -> @region {\n-        let r = match s {\n-            Some(id) if id == special_idents::static => ast::re_static,\n-            Some(id) if id == special_idents::self_ => re_self,\n-            Some(id) => re_named(id),\n-            None => re_anon\n-        };\n-\n-        @ast::region { id: self.get_id(), node: r }\n-    }\n-\n-    // Parses something like \"&x\"\n-    fn parse_region(&self) -> @region {\n-        self.expect(&token::BINOP(token::AND));\n-\n-        match *self.token {\n-          token::IDENT(sid, _) => {\n-            self.bump();\n-            self.region_from_name(Some(sid))\n-          }\n-          _ => {\n-            self.region_from_name(None)\n-          }\n-        }\n-    }\n-\n-    fn region_from_lifetime(&self, l: &ast::Lifetime) -> @region {\n-        // eventually `ast::region` should go away in favor of\n-        // `ast::Lifetime`.  For now we convert between them.\n-        self.region_from_name(Some(l.ident))\n-    }\n-\n     fn parse_ty(&self, colons_before_params: bool) -> @Ty {\n         maybe_whole!(self, nt_ty);\n \n@@ -681,7 +647,8 @@ pub impl Parser {\n         } else if self.eat_keyword(&~\"extern\") {\n             self.parse_ty_bare_fn()\n         } else if self.token_is_closure_keyword(&copy *self.token) {\n-            self.parse_ty_closure(None, None)\n+            // self.warn(fmt!(\"Old-school closure keyword\"));\n+            self.parse_ty_closure(ast::BorrowedSigil, None)\n         } else if *self.token == token::MOD_SEP\n             || is_ident_or_path(&*self.token) {\n             let path = self.parse_path_with_tps(colons_before_params);\n@@ -701,20 +668,20 @@ pub impl Parser {\n     {\n         // @'foo fn() or @foo/fn() or @fn() are parsed directly as fn types:\n         match *self.token {\n-            token::LIFETIME(rname) => {\n+            token::LIFETIME(*) => {\n+                let lifetime = @self.parse_lifetime();\n                 self.bump();\n-                return self.parse_ty_closure(Some(sigil), Some(rname));\n+                return self.parse_ty_closure(sigil, Some(lifetime));\n             }\n \n-            token::IDENT(rname, _) => {\n+            token::IDENT(*) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n                     self.token_is_closure_keyword(&self.look_ahead(2u))\n                 {\n-                    self.bump();\n-                    self.bump();\n-                    return self.parse_ty_closure(Some(sigil), Some(rname));\n+                    let lifetime = @self.parse_lifetime();\n+                    return self.parse_ty_closure(sigil, Some(lifetime));\n                 } else if self.token_is_closure_keyword(&copy *self.token) {\n-                    return self.parse_ty_closure(Some(sigil), None);\n+                    return self.parse_ty_closure(sigil, None);\n                 }\n             }\n             _ => {}\n@@ -735,31 +702,14 @@ pub impl Parser {\n \n     fn parse_borrowed_pointee(&self) -> ty_ {\n         // look for `&'lt` or `&foo/` and interpret `foo` as the region name:\n-        let rname = match *self.token {\n-            token::LIFETIME(sid) => {\n-                self.bump();\n-                Some(sid)\n-            }\n-\n-            token::IDENT(sid, _) => {\n-                if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n-                    self.bump(); self.bump();\n-                    Some(sid)\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            _ => { None }\n-        };\n+        let opt_lifetime = self.parse_opt_lifetime();\n \n         if self.token_is_closure_keyword(&copy *self.token) {\n-            return self.parse_ty_closure(Some(BorrowedSigil), rname);\n+            return self.parse_ty_closure(BorrowedSigil, opt_lifetime);\n         }\n \n-        let r = self.region_from_name(rname);\n         let mt = self.parse_mt();\n-        return ty_rptr(r, mt);\n+        return ty_rptr(opt_lifetime, mt);\n     }\n \n     fn parse_arg_mode(&self) -> mode {\n@@ -939,19 +889,27 @@ pub impl Parser {\n             return path;\n         }\n \n-        // Parse the region parameter, if any, which will\n+        // Parse the (obsolete) trailing region parameter, if any, which will\n         // be written \"foo/&x\"\n         let rp_slash = {\n-            // Hack: avoid parsing vstores like /@ and /~.  This is painful\n-            // because the notation for region bounds and the notation for\n-            // vstores is... um... the same.  I guess that's my fault.  This\n-            // is still not ideal as for &str we end up parsing more than we\n-            // ought to and have to sort it out later.\n             if *self.token == token::BINOP(token::SLASH)\n-                && self.look_ahead(1u) == token::BINOP(token::AND) {\n-\n-                self.expect(&token::BINOP(token::SLASH));\n-                Some(self.parse_region())\n+                && self.look_ahead(1u) == token::BINOP(token::AND)\n+            {\n+                self.bump(); self.bump();\n+                match *self.token {\n+                    token::IDENT(sid, _) => {\n+                        let span = copy self.span;\n+                        self.bump();\n+                        Some(@ast::Lifetime {\n+                            id: self.get_id(),\n+                            span: *span,\n+                            ident: sid\n+                        })\n+                    }\n+                    _ => {\n+                        self.fatal(fmt!(\"Expected a lifetime name\"));\n+                    }\n+                }\n             } else {\n                 None\n             }\n@@ -967,7 +925,7 @@ pub impl Parser {\n                 if v.len() == 0 {\n                     None\n                 } else if v.len() == 1 {\n-                    Some(self.region_from_lifetime(v.get(0)))\n+                    Some(@*v.get(0))\n                 } else {\n                     self.fatal(fmt!(\"Expected at most one \\\n                                      lifetime name (for now)\"));\n@@ -981,16 +939,26 @@ pub impl Parser {\n                      .. copy *path }\n     }\n \n-    fn parse_opt_lifetime(&self) -> Option<ast::Lifetime> {\n+    fn parse_opt_lifetime(&self) -> Option<@ast::Lifetime> {\n         /*!\n          *\n          * Parses 0 or 1 lifetime.\n          */\n \n         match *self.token {\n-            token::LIFETIME(_) => {\n-                Some(self.parse_lifetime())\n+            token::LIFETIME(*) => {\n+                Some(@self.parse_lifetime())\n+            }\n+\n+            // Also accept the (obsolete) syntax `foo/`\n+            token::IDENT(*) => {\n+                if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n+                    Some(@self.parse_lifetime())\n+                } else {\n+                    None\n+                }\n             }\n+\n             _ => {\n                 None\n             }\n@@ -1005,13 +973,27 @@ pub impl Parser {\n \n         match *self.token {\n             token::LIFETIME(i) => {\n+                let span = copy self.span;\n+                self.bump();\n+                return ast::Lifetime {\n+                    id: self.get_id(),\n+                    span: *span,\n+                    ident: i\n+                };\n+            }\n+\n+            // Also accept the (obsolete) syntax `foo/`\n+            token::IDENT(i, _) => {\n+                let span = copy self.span;\n                 self.bump();\n+                self.expect(&token::BINOP(token::SLASH));\n                 return ast::Lifetime {\n                     id: self.get_id(),\n-                    span: *self.span,\n+                    span: *span,\n                     ident: i\n                 };\n             }\n+\n             _ => {\n                 self.fatal(fmt!(\"Expected a lifetime name\"));\n             }\n@@ -1041,6 +1023,7 @@ pub impl Parser {\n             match *self.token {\n                 token::COMMA => { self.bump();}\n                 token::GT => { return res; }\n+                token::BINOP(token::SHR) => { return res; }\n                 _ => {\n                     self.fatal(~\"expected `,` or `>` after lifetime name\");\n                 }"}, {"sha": "3744b7a8f6c0382b9ca7a7279db895685264751b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -146,8 +146,8 @@ pub fn expr_to_str(e: @ast::expr, intr: @ident_interner) -> ~str {\n     to_str(e, print_expr, intr)\n }\n \n-pub fn region_to_str(e: @ast::region, intr: @ident_interner) -> ~str {\n-    to_str(e, |s, e| print_region(s, ~\"&\", e, ~\"\"), intr)\n+pub fn lifetime_to_str(e: &ast::Lifetime, intr: @ident_interner) -> ~str {\n+    to_str(e, print_lifetime, intr)\n }\n \n pub fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n@@ -355,23 +355,11 @@ pub fn print_foreign_mod(s: @ps, nmod: ast::foreign_mod,\n     for nmod.items.each |item| { print_foreign_item(s, *item); }\n }\n \n-pub fn print_region(s: @ps, prefix: ~str, region: @ast::region, sep: ~str) {\n-    word(s.s, prefix);\n-    match region.node {\n-        ast::re_anon => {\n-            return;\n-        }\n-        ast::re_static => {\n-            word_space(s, ~\"static\")\n-        }\n-        ast::re_self => {\n-            word_space(s, ~\"self\")\n-        }\n-        ast::re_named(name) => {\n-            print_ident(s, name);\n-        }\n+pub fn print_opt_lifetime(s: @ps, lifetime: Option<@ast::Lifetime>) {\n+    for lifetime.each |l| {\n+        print_lifetime(s, *l);\n+        nbsp(s);\n     }\n-    word(s.s, sep);\n }\n \n pub fn print_type(s: @ps, &&ty: @ast::Ty) {\n@@ -397,8 +385,9 @@ pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n         word(s.s, ~\"]\");\n       }\n       ast::ty_ptr(mt) => { word(s.s, ~\"*\"); print_mt(s, mt); }\n-      ast::ty_rptr(region, mt) => {\n-          print_region(s, ~\"&\", region, ~\"/\");\n+      ast::ty_rptr(lifetime, mt) => {\n+          word(s.s, ~\"&\");\n+          print_opt_lifetime(s, lifetime);\n           print_mt(s, mt);\n       }\n       ast::ty_tup(elts) => {\n@@ -1048,7 +1037,10 @@ pub fn print_vstore(s: @ps, t: ast::vstore) {\n         ast::vstore_fixed(None) => word(s.s, ~\"_\"),\n         ast::vstore_uniq => word(s.s, ~\"~\"),\n         ast::vstore_box => word(s.s, ~\"@\"),\n-        ast::vstore_slice(r) => print_region(s, ~\"&\", r, ~\"/\")\n+        ast::vstore_slice(r) => {\n+            word(s.s, ~\"&\");\n+            print_opt_lifetime(s, r);\n+        }\n     }\n }\n \n@@ -1501,17 +1493,18 @@ pub fn print_path(s: @ps, &&path: @ast::path, colons_before_params: bool) {\n     if path.rp.is_some() || !path.types.is_empty() {\n         if colons_before_params { word(s.s, ~\"::\"); }\n \n-        match path.rp {\n-          None => { /* ok */ }\n-          Some(r) => {\n-            word(s.s, ~\"/\");\n-            print_region(s, ~\"&\", r, ~\"\");\n-          }\n-        }\n-\n-        if !path.types.is_empty() {\n+        if path.rp.is_some() || !path.types.is_empty() {\n             word(s.s, ~\"<\");\n+\n+            for path.rp.each |r| {\n+                print_lifetime(s, *r);\n+                if !path.types.is_empty() {\n+                    word_space(s, ~\",\");\n+                }\n+            }\n+\n             commasep(s, inconsistent, path.types, print_type);\n+\n             word(s.s, ~\">\");\n         }\n     }\n@@ -1749,7 +1742,7 @@ pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n     }\n }\n \n-pub fn print_lifetime(s: @ps, lifetime: &ast::Lifetime) {\n+pub fn print_lifetime(s: @ps, &&lifetime: &ast::Lifetime) {\n     word(s.s, ~\"'\");\n     print_ident(s, lifetime.ident);\n }\n@@ -1908,7 +1901,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n pub fn print_ty_fn(s: @ps,\n                    opt_abi: Option<ast::Abi>,\n                    opt_sigil: Option<ast::Sigil>,\n-                   opt_region: Option<@ast::region>,\n+                   opt_region: Option<@ast::Lifetime>,\n                    purity: ast::purity,\n                    onceness: ast::Onceness,\n                    decl: &ast::fn_decl, id: Option<ast::ident>,\n@@ -1921,7 +1914,7 @@ pub fn print_ty_fn(s: @ps,\n     print_self_ty_if_static(s, opt_self_ty);\n     print_opt_abi(s, opt_abi);\n     print_opt_sigil(s, opt_sigil);\n-    for opt_region.each |r| { print_region(s, ~\"\", *r, ~\"/\"); }\n+    print_opt_lifetime(s, opt_region);\n     print_purity(s, purity);\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");"}, {"sha": "40d5a44124177029380626bab681bf271b6f255c", "filename": "src/test/compile-fail/prim-with-args.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprim-with-args.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -23,17 +23,17 @@ let x: u64<int>; //~ ERROR type parameters are not allowed on this type\n let x: float<int>; //~ ERROR type parameters are not allowed on this type\n let x: char<int>; //~ ERROR type parameters are not allowed on this type\n \n-let x: int/&; //~ ERROR region parameters are not allowed on this type\n-let x: i8/&; //~ ERROR region parameters are not allowed on this type\n-let x: i16/&; //~ ERROR region parameters are not allowed on this type\n-let x: i32/&; //~ ERROR region parameters are not allowed on this type\n-let x: i64/&; //~ ERROR region parameters are not allowed on this type\n-let x: uint/&; //~ ERROR region parameters are not allowed on this type\n-let x: u8/&; //~ ERROR region parameters are not allowed on this type\n-let x: u16/&; //~ ERROR region parameters are not allowed on this type\n-let x: u32/&; //~ ERROR region parameters are not allowed on this type\n-let x: u64/&; //~ ERROR region parameters are not allowed on this type\n-let x: float/&; //~ ERROR region parameters are not allowed on this type\n-let x: char/&; //~ ERROR region parameters are not allowed on this type\n+let x: int<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: i8<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: i16<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: i32<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: i64<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: uint<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: u8<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: u16<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: u32<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: u64<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: float<'static>; //~ ERROR region parameters are not allowed on this type\n+let x: char<'static>; //~ ERROR region parameters are not allowed on this type\n \n }"}, {"sha": "2ba27e888cbe03419b16098ff2bf78bd2cc4d6a3", "filename": "src/test/compile-fail/regions-in-consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-consts.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const c_x: &'blk int = &22; //~ ERROR Illegal lifetime &blk: only 'static is allowed here\n+const c_x: &'blk int = &22; //~ ERROR Illegal lifetime 'blk: only 'static is allowed here\n const c_y: &int = &22; //~ ERROR Illegal anonymous lifetime: only 'static is allowed here\n const c_z: &'static int = &22;\n "}, {"sha": "0adfaccdc017420fcfb91f4676bcf9744ee5c6ab", "filename": "src/test/compile-fail/regions-in-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -10,15 +10,15 @@\n \n enum yes0<'lt> {\n     // This will eventually be legal (and in fact the only way):\n-    X3(&'lt uint) //~ ERROR Illegal lifetime &lt: only 'self is allowed allowed as part of a type declaration\n+    X3(&'lt uint) //~ ERROR Illegal lifetime 'lt: only 'self is allowed allowed as part of a type declaration\n }\n \n enum yes1 {\n     X4(&'self uint)\n }\n \n enum yes2 {\n-    X5(&'foo uint) //~ ERROR Illegal lifetime &foo: only 'self is allowed allowed as part of a type declaration\n+    X5(&'foo uint) //~ ERROR Illegal lifetime 'foo: only 'self is allowed allowed as part of a type declaration\n }\n \n fn main() {}"}, {"sha": "b425a40114a3d038aa6859d1eb9643d6c3dfa1d1", "filename": "src/test/compile-fail/regions-in-structs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -17,7 +17,7 @@ struct yes1<'self> {\n }\n \n struct yes2<'self> {\n-  x: &'foo uint, //~ ERROR Illegal lifetime &foo: only 'self is allowed allowed as part of a type declaration\n+  x: &'foo uint, //~ ERROR Illegal lifetime 'foo: only 'self is allowed allowed as part of a type declaration\n }\n \n fn main() {}"}, {"sha": "a0ecb08a08957af514886b00a4a234d7dc21590e", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -13,19 +13,16 @@ struct direct<'self> {\n }\n \n struct indirect1 {\n+    // Here the lifetime parameter of direct is bound by the fn()\n     g: @fn(direct)\n }\n \n-struct indirect2 {\n-    g: @fn(direct/&)\n-}\n-\n-struct indirect3 {\n+struct indirect2<'self> {\n+    // But here it is set to 'self\n     g: @fn(direct<'self>)\n }\n \n fn take_direct(p: direct) -> direct { p } //~ ERROR mismatched types\n fn take_indirect1(p: indirect1) -> indirect1 { p }\n-fn take_indirect2(p: indirect2) -> indirect2 { p }\n-fn take_indirect3(p: indirect3) -> indirect3 { p } //~ ERROR mismatched types\n+fn take_indirect2(p: indirect2) -> indirect2 { p } //~ ERROR mismatched types\n fn main() {}"}, {"sha": "fe37d8990985dfa278126808b4273203bc052ac6", "filename": "src/test/compile-fail/regions-infer-region-in-fn-but-not-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cbd4b20ee857cf383ef1c0d8b34727a433231a9/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs?ref=7cbd4b20ee857cf383ef1c0d8b34727a433231a9", "patch": "@@ -13,7 +13,7 @@\n // contains region pointers\n enum foo = ~fn(x: &int);\n \n-fn take_foo(x: foo/&) {} //~ ERROR no region bound is allowed on `foo`\n+fn take_foo(x: foo<'static>) {} //~ ERROR no region bound is allowed on `foo`\n \n fn main() {\n }"}]}