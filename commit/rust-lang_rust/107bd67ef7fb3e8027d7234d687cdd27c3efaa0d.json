{"sha": "107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwN2JkNjdlZjdmYjNlODAyN2Q3MjM0ZDY4N2NkZDI3YzNlZmFhMGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-02T19:23:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-02T19:23:14Z"}, "message": "Auto merge of #42189 - nikomatsakis:chalk-trait-env-param-env, r=eddyb\n\nquerify layout and move param env out of the infcx\n\nThe main goal of this PR is to move the parameter environment *out* of the inference context. This is because the inference environment will soon be changing over the course of inference --- for example, when we enter into a `for<'a> fn(...)` type, we will push a new environment with an increasing universe index, rather than skolemizing the `'a` references. Similarly, each obligation will soon be able to have a distinct parameter environment, and therefore the `Obligation` struct is extended to carry a `ParamEnv<'tcx>`. (I debated about putting it into the cause; seems plausible, but also weird.)\n\nAlong the way, I also reworked how layout works, moving the layout cache into a proper query along the lines of needs-drop and friends.\n\nFinally, tweaks the inference context API. It seemed to be accumulating parameters at an alarming rate. The main way to e.g. make a subtype or equality relationship is to do the following:\n\n    infcx.at(cause, param_env).sub(a, b)\n    infcx.at(cause, param_env).eq(a, b)\n\nIn both cases, `a` is considered the \"expected\" type (this used to be specified by a boolean). I tried hard to preserve the existing notion of what was \"expected\", although in some cases I'm not convinced it was being set on purpose one way or the other. This is why in some cases you will see me do `sup(b, a)`, which is otherwise equivalent to `sub(a, b)`, but sets the \"expected type\" differently.\n\nr? @eddyb\ncc @arielb1", "tree": {"sha": "b0ed47b3c7df37b85c7a74fb2b320bcfea4de972", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0ed47b3c7df37b85c7a74fb2b320bcfea4de972"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "html_url": "https://github.com/rust-lang/rust/commit/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7798c3d179c7c18736fc0465e7ba6618c575a34", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7798c3d179c7c18736fc0465e7ba6618c575a34", "html_url": "https://github.com/rust-lang/rust/commit/d7798c3d179c7c18736fc0465e7ba6618c575a34"}, {"sha": "84047db2ade806b802f36d522ea82bd5d3cbb242", "url": "https://api.github.com/repos/rust-lang/rust/commits/84047db2ade806b802f36d522ea82bd5d3cbb242", "html_url": "https://github.com/rust-lang/rust/commit/84047db2ade806b802f36d522ea82bd5d3cbb242"}], "stats": {"total": 2609, "additions": 1571, "deletions": 1038}, "files": [{"sha": "c38b3745f4c72e78c51443a311ad790f5ddda75e", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -112,6 +112,7 @@ pub enum DepNode<D: Clone + Debug> {\n     IsSized(D),\n     IsFreeze(D),\n     NeedsDrop(D),\n+    Layout(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -241,6 +242,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             IsSized(ref d) => op(d).map(IsSized),\n             IsFreeze(ref d) => op(d).map(IsFreeze),\n             NeedsDrop(ref d) => op(d).map(NeedsDrop),\n+            Layout(ref d) => op(d).map(Layout),\n             Hir(ref d) => op(d).map(Hir),\n             HirBody(ref d) => op(d).map(HirBody),\n             MetaData(ref d) => op(d).map(MetaData),"}, {"sha": "756e0b5f9fb6a00cf47c84f26830e8a72ccf9f83", "filename": "src/librustc/infer/at.rs", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -0,0 +1,310 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A nice interface for working with the infcx.  The basic idea is to\n+//! do `infcx.at(cause, param_env)`, which sets the \"cause\" of the\n+//! operation as well as the surrounding parameter environment.  Then\n+//! you can do something like `.sub(a, b)` or `.eq(a, b)` to create a\n+//! subtype or equality relationship respectively. The first argument\n+//! is always the \"expected\" output from the POV of diagnostics.\n+//!\n+//! Examples:\n+//!\n+//!     infcx.at(cause, param_env).sub(a, b)\n+//!     // requires that `a <: b`, with `a` considered the \"expected\" type\n+//!\n+//!     infcx.at(cause, param_env).sup(a, b)\n+//!     // requires that `b <: a`, with `a` considered the \"expected\" type\n+//!\n+//!     infcx.at(cause, param_env).eq(a, b)\n+//!     // requires that `a == b`, with `a` considered the \"expected\" type\n+//!\n+//! For finer-grained control, you can also do use `trace`:\n+//!\n+//!     infcx.at(...).trace(a, b).sub(&c, &d)\n+//!\n+//! This will set `a` and `b` as the \"root\" values for\n+//! error-reporting, but actually operate on `c` and `d`. This is\n+//! sometimes useful when the types of `c` and `d` are not traceable\n+//! things. (That system should probably be refactored.)\n+\n+use super::*;\n+\n+use ty::relate::{Relate, TypeRelation};\n+\n+pub struct At<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    cause: &'a ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+pub struct Trace<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    at: At<'a, 'gcx, 'tcx>,\n+    a_is_expected: bool,\n+    trace: TypeTrace<'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    pub fn at(&'a self,\n+              cause: &'a ObligationCause<'tcx>,\n+              param_env: ty::ParamEnv<'tcx>)\n+              -> At<'a, 'gcx, 'tcx>\n+    {\n+        At { infcx: self, cause, param_env }\n+    }\n+}\n+\n+pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n+    fn to_trace(cause: &ObligationCause<'tcx>,\n+                a_is_expected: bool,\n+                a: Self,\n+                b: Self)\n+                -> TypeTrace<'tcx>;\n+}\n+\n+impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n+    /// Hacky routine for equating two impl headers in coherence.\n+    pub fn eq_impl_headers(self,\n+                           expected: &ty::ImplHeader<'tcx>,\n+                           actual: &ty::ImplHeader<'tcx>)\n+                           -> InferResult<'tcx, ()>\n+    {\n+        debug!(\"eq_impl_header({:?} = {:?})\", expected, actual);\n+        match (expected.trait_ref, actual.trait_ref) {\n+            (Some(a_ref), Some(b_ref)) =>\n+                self.eq(a_ref, b_ref),\n+            (None, None) =>\n+                self.eq(expected.self_ty, actual.self_ty),\n+            _ =>\n+                bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+        }\n+    }\n+\n+    /// Make `a <: b` where `a` may or may not be expected\n+    pub fn sub_exp<T>(self,\n+                      a_is_expected: bool,\n+                      a: T,\n+                      b: T)\n+                      -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace_exp(a_is_expected, a, b).sub(&a, &b)\n+    }\n+\n+    /// Make `actual <: expected`. For example, if type-checking a\n+    /// call like `foo(x)`, where `foo: fn(i32)`, you might have\n+    /// `sup(i32, x)`, since the \"expected\" type is the type that\n+    /// appears in the signature.\n+    pub fn sup<T>(self,\n+                  expected: T,\n+                  actual: T)\n+                  -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.sub_exp(false, actual, expected)\n+    }\n+\n+    /// Make `expected <: actual`\n+    pub fn sub<T>(self,\n+                  expected: T,\n+                  actual: T)\n+                  -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.sub_exp(true, expected, actual)\n+    }\n+\n+    /// Make `expected <: actual`\n+    pub fn eq_exp<T>(self,\n+                     a_is_expected: bool,\n+                     a: T,\n+                     b: T)\n+                     -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace_exp(a_is_expected, a, b).eq(&a, &b)\n+    }\n+\n+    /// Make `expected <: actual`\n+    pub fn eq<T>(self,\n+                 expected: T,\n+                 actual: T)\n+                 -> InferResult<'tcx, ()>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace(expected, actual).eq(&expected, &actual)\n+    }\n+\n+    /// Compute the least-upper-bound, or mutual supertype, of two\n+    /// values. The order of the arguments doesn't matter, but since\n+    /// this can result in an error (e.g., if asked to compute LUB of\n+    /// u32 and i32), it is meaningful to call one of them the\n+    /// \"expected type\".\n+    pub fn lub<T>(self,\n+                  expected: T,\n+                  actual: T)\n+                  -> InferResult<'tcx, T>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace(expected, actual).lub(&expected, &actual)\n+    }\n+\n+    /// Compute the greatest-lower-bound, or mutual subtype, of two\n+    /// values. As with `lub` order doesn't matter, except for error\n+    /// cases.\n+    pub fn glb<T>(self,\n+                  expected: T,\n+                  actual: T)\n+                  -> InferResult<'tcx, T>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace(expected, actual).glb(&expected, &actual)\n+    }\n+\n+    /// Sets the \"trace\" values that will be used for\n+    /// error-repporting, but doesn't actually perform any operation\n+    /// yet (this is useful when you want to set the trace using\n+    /// distinct values from those you wish to operate upon).\n+    pub fn trace<T>(self,\n+                    expected: T,\n+                    actual: T)\n+                    -> Trace<'a, 'gcx, 'tcx>\n+        where T: ToTrace<'tcx>\n+    {\n+        self.trace_exp(true, expected, actual)\n+    }\n+\n+    /// Like `trace`, but the expected value is determined by the\n+    /// boolean argument (if true, then the first argument `a` is the\n+    /// \"expected\" value).\n+    pub fn trace_exp<T>(self,\n+                        a_is_expected: bool,\n+                        a: T,\n+                        b: T)\n+                        -> Trace<'a, 'gcx, 'tcx>\n+        where T: ToTrace<'tcx>\n+    {\n+        let trace = ToTrace::to_trace(self.cause, a_is_expected, a, b);\n+        Trace { at: self, trace: trace, a_is_expected }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> Trace<'a, 'gcx, 'tcx> {\n+    /// Make `a <: b` where `a` may or may not be expected (if\n+    /// `a_is_expected` is true, then `a` is expected).\n+    /// Make `expected <: actual`\n+    pub fn sub<T>(self,\n+                  a: &T,\n+                  b: &T)\n+                  -> InferResult<'tcx, ()>\n+        where T: Relate<'tcx>\n+    {\n+        debug!(\"sub({:?} <: {:?})\", a, b);\n+        let Trace { at, trace, a_is_expected } = self;\n+        at.infcx.commit_if_ok(|_| {\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            fields.sub(a_is_expected)\n+                  .relate(a, b)\n+                  .map(move |_| InferOk { value: (), obligations: fields.obligations })\n+        })\n+    }\n+\n+    /// Make `a == b`; the expectation is set by the call to\n+    /// `trace()`.\n+    pub fn eq<T>(self,\n+                 a: &T,\n+                 b: &T)\n+                 -> InferResult<'tcx, ()>\n+        where T: Relate<'tcx>\n+    {\n+        debug!(\"eq({:?} == {:?})\", a, b);\n+        let Trace { at, trace, a_is_expected } = self;\n+        at.infcx.commit_if_ok(|_| {\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            fields.equate(a_is_expected)\n+                  .relate(a, b)\n+                  .map(move |_| InferOk { value: (), obligations: fields.obligations })\n+        })\n+    }\n+\n+    pub fn lub<T>(self,\n+                  a: &T,\n+                  b: &T)\n+                  -> InferResult<'tcx, T>\n+        where T: Relate<'tcx>\n+    {\n+        debug!(\"lub({:?} \\\\/ {:?})\", a, b);\n+        let Trace { at, trace, a_is_expected } = self;\n+        at.infcx.commit_if_ok(|_| {\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            fields.lub(a_is_expected)\n+                  .relate(a, b)\n+                  .map(move |t| InferOk { value: t, obligations: fields.obligations })\n+        })\n+    }\n+\n+    pub fn glb<T>(self,\n+                  a: &T,\n+                  b: &T)\n+                  -> InferResult<'tcx, T>\n+        where T: Relate<'tcx>\n+    {\n+        debug!(\"glb({:?} /\\\\ {:?})\", a, b);\n+        let Trace { at, trace, a_is_expected } = self;\n+        at.infcx.commit_if_ok(|_| {\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            fields.glb(a_is_expected)\n+                  .relate(a, b)\n+                  .map(move |t| InferOk { value: t, obligations: fields.obligations })\n+        })\n+    }\n+}\n+\n+impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n+    fn to_trace(cause: &ObligationCause<'tcx>,\n+                a_is_expected: bool,\n+                a: Self,\n+                b: Self)\n+                -> TypeTrace<'tcx>\n+    {\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: Types(ExpectedFound::new(a_is_expected, a, b))\n+        }\n+    }\n+}\n+\n+impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n+    fn to_trace(cause: &ObligationCause<'tcx>,\n+                a_is_expected: bool,\n+                a: Self,\n+                b: Self)\n+                -> TypeTrace<'tcx>\n+    {\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: TraitRefs(ExpectedFound::new(a_is_expected, a, b))\n+        }\n+    }\n+}\n+\n+impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n+    fn to_trace(cause: &ObligationCause<'tcx>,\n+                a_is_expected: bool,\n+                a: Self,\n+                b: Self)\n+                -> TypeTrace<'tcx>\n+    {\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b))\n+        }\n+    }\n+}"}, {"sha": "14920b8b668ec56fb0f26141dec9a5c3707e05e4", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -55,6 +55,7 @@ pub struct CombineFields<'infcx, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n     pub infcx: &'infcx InferCtxt<'infcx, 'gcx, 'tcx>,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n@@ -215,6 +216,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n \n         if needs_wf {\n             self.obligations.push(Obligation::new(self.trace.cause.clone(),\n+                                                  self.param_env,\n                                                   ty::Predicate::WellFormed(b_ty)));\n         }\n "}, {"sha": "f5869b8a20fab7881529092b132d00fbf5a5d26a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 79, "deletions": 216, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -31,7 +31,7 @@ use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::relate::{Relate, RelateResult, TypeRelation};\n+use ty::relate::RelateResult;\n use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{Cell, RefCell, Ref, RefMut};\n@@ -49,6 +49,7 @@ use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n+pub mod at;\n mod combine;\n mod equate;\n pub mod error_reporting;\n@@ -161,8 +162,6 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // For region variables.\n     region_vars: RegionVarBindings<'a, 'gcx, 'tcx>,\n \n-    pub param_env: ty::ParamEnv<'gcx>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n@@ -174,11 +173,6 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // avoid reporting the same error twice.\n     pub reported_trait_errors: RefCell<FxHashSet<traits::TraitErrorKey<'tcx>>>,\n \n-    // Sadly, the behavior of projection varies a bit depending on the\n-    // stage of compilation. The specifics are given in the\n-    // documentation for `Reveal`.\n-    projection_mode: Reveal,\n-\n     // When an error occurs, we want to avoid reporting \"derived\"\n     // errors that are due to this original failure. Normally, we\n     // handle this with the `err_count_on_creation` count, which\n@@ -405,55 +399,39 @@ impl fmt::Display for FixupError {\n pub trait InferEnv<'a, 'tcx> {\n     fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParamEnv<'tcx>>);\n+                    Option<ty::TypeckTables<'tcx>>);\n }\n \n impl<'a, 'tcx> InferEnv<'a, 'tcx> for () {\n     fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParamEnv<'tcx>>) {\n-        (None, None, None)\n-    }\n-}\n-\n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::ParamEnv<'tcx> {\n-    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParamEnv<'tcx>>) {\n-        (None, None, Some(self))\n+                    Option<ty::TypeckTables<'tcx>>) {\n+        (None, None)\n     }\n }\n \n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for (&'a ty::TypeckTables<'tcx>, ty::ParamEnv<'tcx>) {\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for &'a ty::TypeckTables<'tcx> {\n     fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParamEnv<'tcx>>) {\n-        (Some(self.0), None, Some(self.1))\n+                    Option<ty::TypeckTables<'tcx>>) {\n+        (Some(self), None)\n     }\n }\n \n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for (ty::TypeckTables<'tcx>, ty::ParamEnv<'tcx>) {\n+impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::TypeckTables<'tcx> {\n     fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParamEnv<'tcx>>) {\n-        (None, Some(self.0), Some(self.1))\n+                    Option<ty::TypeckTables<'tcx>>) {\n+        (None, Some(self))\n     }\n }\n \n impl<'a, 'tcx> InferEnv<'a, 'tcx> for hir::BodyId {\n     fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>,\n-                    Option<ty::ParamEnv<'tcx>>) {\n+                    Option<ty::TypeckTables<'tcx>>) {\n         let def_id = tcx.hir.body_owner_def_id(self);\n-        (Some(tcx.typeck_tables_of(def_id)),\n-         None,\n-         Some(tcx.param_env(def_id)))\n+        (Some(tcx.typeck_tables_of(def_id)), None)\n     }\n }\n \n@@ -465,23 +443,16 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     arena: DroplessArena,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n     tables: Option<&'a ty::TypeckTables<'gcx>>,\n-    param_env: Option<ty::ParamEnv<'gcx>>,\n-    projection_mode: Reveal,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n-    pub fn infer_ctxt<E: InferEnv<'a, 'gcx>>(self,\n-                                             env: E,\n-                                             projection_mode: Reveal)\n-                                             -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n-        let (tables, fresh_tables, param_env) = env.to_parts(self);\n+    pub fn infer_ctxt<E: InferEnv<'a, 'gcx>>(self, env: E) -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+        let (tables, fresh_tables) = env.to_parts(self);\n         InferCtxtBuilder {\n             global_tcx: self,\n             arena: DroplessArena::new(),\n             fresh_tables: fresh_tables.map(RefCell::new),\n             tables: tables,\n-            param_env: param_env,\n-            projection_mode: projection_mode,\n         }\n     }\n \n@@ -490,20 +461,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n     /// If any inference functionality is used, ICEs will occur.\n     pub fn borrowck_fake_infer_ctxt(self, body: hir::BodyId)\n                                     -> InferCtxt<'a, 'gcx, 'gcx> {\n-        let (tables, _, param_env) = body.to_parts(self);\n+        let (tables, _) = body.to_parts(self);\n         InferCtxt {\n             tcx: self,\n             tables: InferTables::Interned(tables.unwrap()),\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(self),\n-            param_env: param_env.unwrap(),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             reported_trait_errors: RefCell::new(FxHashSet()),\n-            projection_mode: Reveal::UserFacing,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n             in_snapshot: Cell::new(false),\n@@ -520,13 +489,10 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             ref arena,\n             ref fresh_tables,\n             tables,\n-            ref mut param_env,\n-            projection_mode,\n         } = *self;\n         let tables = tables.map(InferTables::Interned).unwrap_or_else(|| {\n             fresh_tables.as_ref().map_or(InferTables::Missing, InferTables::InProgress)\n         });\n-        let param_env = param_env.take().unwrap_or_else(|| ty::ParamEnv::empty());\n         global_tcx.enter_local(arena, |tcx| f(InferCtxt {\n             tcx: tcx,\n             tables: tables,\n@@ -535,11 +501,9 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(tcx),\n-            param_env: param_env,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             reported_trait_errors: RefCell::new(FxHashSet()),\n-            projection_mode: projection_mode,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n             in_snapshot: Cell::new(false),\n@@ -577,17 +541,21 @@ pub struct CombinedSnapshot<'a, 'tcx:'a> {\n /// Helper trait for shortening the lifetimes inside a\n /// value for post-type-checking normalization.\n pub trait TransNormalize<'gcx>: TypeFoldable<'gcx> {\n-    fn trans_normalize<'a, 'tcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self;\n+    fn trans_normalize<'a, 'tcx>(&self,\n+                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                 param_env: ty::ParamEnv<'tcx>)\n+                                 -> Self;\n }\n \n macro_rules! items { ($($item:item)+) => ($($item)+) }\n macro_rules! impl_trans_normalize {\n     ($lt_gcx:tt, $($ty:ty),+) => {\n         items!($(impl<$lt_gcx> TransNormalize<$lt_gcx> for $ty {\n             fn trans_normalize<'a, 'tcx>(&self,\n-                                         infcx: &InferCtxt<'a, $lt_gcx, 'tcx>)\n+                                         infcx: &InferCtxt<'a, $lt_gcx, 'tcx>,\n+                                         param_env: ty::ParamEnv<'tcx>)\n                                          -> Self {\n-                infcx.normalize_projections_in(self)\n+                infcx.normalize_projections_in(param_env, self)\n             }\n         })+);\n     }\n@@ -604,13 +572,16 @@ impl_trans_normalize!('gcx,\n );\n \n impl<'gcx> TransNormalize<'gcx> for LvalueTy<'gcx> {\n-    fn trans_normalize<'a, 'tcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn trans_normalize<'a, 'tcx>(&self,\n+                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                 param_env: ty::ParamEnv<'tcx>)\n+                                 -> Self {\n         match *self {\n-            LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.trans_normalize(infcx) },\n+            LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.trans_normalize(infcx, param_env) },\n             LvalueTy::Downcast { adt_def, substs, variant_index } => {\n                 LvalueTy::Downcast {\n                     adt_def: adt_def,\n-                    substs: substs.trans_normalize(infcx),\n+                    substs: substs.trans_normalize(infcx, param_env),\n                     variant_index: variant_index\n                 }\n             }\n@@ -632,22 +603,30 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         self.normalize_associated_type(&value)\n     }\n \n+    /// Fully normalizes any associated types in `value`, using an\n+    /// empty environment and `Reveal::All` mode (therefore, suitable\n+    /// only for monomorphized code during trans, basically).\n     pub fn normalize_associated_type<T>(self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n         debug!(\"normalize_associated_type(t={:?})\", value);\n \n+        let param_env = ty::ParamEnv::empty(Reveal::All);\n         let value = self.erase_regions(value);\n \n         if !value.has_projection_types() {\n             return value;\n         }\n \n-        self.infer_ctxt((), Reveal::All).enter(|infcx| {\n-            value.trans_normalize(&infcx)\n+        self.infer_ctxt(()).enter(|infcx| {\n+            value.trans_normalize(&infcx, param_env)\n         })\n     }\n \n+    /// Does a best-effort to normalize any associated types in\n+    /// `value`; this includes revealing specializable types, so this\n+    /// should be not be used during type-checking, but only during\n+    /// optimization and code generation.\n     pub fn normalize_associated_type_in_env<T>(\n         self, value: &T, env: ty::ParamEnv<'tcx>\n     ) -> T\n@@ -661,20 +640,20 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(env, Reveal::All).enter(|infcx| {\n-            value.trans_normalize(&infcx)\n+        self.infer_ctxt(()).enter(|infcx| {\n+            value.trans_normalize(&infcx, env.reveal_all())\n        })\n     }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn normalize_projections_in<T>(&self, value: &T) -> T::Lifted\n+    fn normalize_projections_in<T>(&self, param_env: ty::ParamEnv<'tcx>, value: &T) -> T::Lifted\n         where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n     {\n         let mut selcx = traits::SelectionContext::new(self);\n         let cause = traits::ObligationCause::dummy();\n         let traits::Normalized { value: result, obligations } =\n-            traits::normalize(&mut selcx, cause, value);\n+            traits::normalize(&mut selcx, param_env, cause, value);\n \n         debug!(\"normalize_projections_in: result={:?} obligations={:?}\",\n                 result, obligations);\n@@ -728,10 +707,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn projection_mode(&self) -> Reveal {\n-        self.projection_mode\n-    }\n-\n     pub fn is_in_snapshot(&self) -> bool {\n         self.in_snapshot.get()\n     }\n@@ -817,52 +792,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         return variables;\n     }\n \n-    fn combine_fields(&'a self, trace: TypeTrace<'tcx>)\n+    fn combine_fields(&'a self, trace: TypeTrace<'tcx>, param_env: ty::ParamEnv<'tcx>)\n                       -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             infcx: self,\n             trace: trace,\n             cause: None,\n+            param_env,\n             obligations: PredicateObligations::new(),\n         }\n     }\n \n-    pub fn equate<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> InferResult<'tcx, T>\n-        where T: Relate<'tcx>\n-    {\n-        let mut fields = self.combine_fields(trace);\n-        let result = fields.equate(a_is_expected).relate(a, b);\n-        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n-    }\n-\n-    pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> InferResult<'tcx, T>\n-        where T: Relate<'tcx>\n-    {\n-        let mut fields = self.combine_fields(trace);\n-        let result = fields.sub(a_is_expected).relate(a, b);\n-        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n-    }\n-\n-    pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> InferResult<'tcx, T>\n-        where T: Relate<'tcx>\n-    {\n-        let mut fields = self.combine_fields(trace);\n-        let result = fields.lub(a_is_expected).relate(a, b);\n-        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n-    }\n-\n-    pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n-        -> InferResult<'tcx, T>\n-        where T: Relate<'tcx>\n-    {\n-        let mut fields = self.combine_fields(trace);\n-        let result = fields.glb(a_is_expected).relate(a, b);\n-        result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n-    }\n-\n     // Clear the \"currently in a snapshot\" flag, invoke the closure,\n     // then restore the flag to its original value. This flag is a\n     // debugging measure designed to detect cases where we start a\n@@ -1022,94 +962,35 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.add_given(sub, sup);\n     }\n \n-    pub fn sub_types(&self,\n-                     a_is_expected: bool,\n-                     cause: &ObligationCause<'tcx>,\n-                     a: Ty<'tcx>,\n-                     b: Ty<'tcx>)\n-        -> InferResult<'tcx, ()>\n-    {\n-        debug!(\"sub_types({:?} <: {:?})\", a, b);\n-        self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(cause, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n-        })\n-    }\n-\n-    pub fn can_sub_types(&self,\n-                         a: Ty<'tcx>,\n-                         b: Ty<'tcx>)\n-                         -> UnitResult<'tcx>\n+    pub fn can_sub<T>(&self,\n+                      param_env: ty::ParamEnv<'tcx>,\n+                      a: T,\n+                      b: T)\n+                      -> UnitResult<'tcx>\n+        where T: at::ToTrace<'tcx>\n     {\n+        let origin = &ObligationCause::dummy();\n         self.probe(|_| {\n-            let origin = &ObligationCause::dummy();\n-            let trace = TypeTrace::types(origin, true, a, b);\n-            self.sub(true, trace, &a, &b).map(|InferOk { obligations: _, .. }| {\n+            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n                 // Ignore obligations, since we are unrolling\n                 // everything anyway.\n             })\n         })\n     }\n \n-    pub fn eq_types(&self,\n-                    a_is_expected: bool,\n-                    cause: &ObligationCause<'tcx>,\n-                    a: Ty<'tcx>,\n-                    b: Ty<'tcx>)\n-        -> InferResult<'tcx, ()>\n+    pub fn can_eq<T>(&self,\n+                      param_env: ty::ParamEnv<'tcx>,\n+                      a: T,\n+                      b: T)\n+                      -> UnitResult<'tcx>\n+        where T: at::ToTrace<'tcx>\n     {\n-        self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(cause, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n-        })\n-    }\n-\n-    pub fn eq_trait_refs(&self,\n-                          a_is_expected: bool,\n-                          cause: &ObligationCause<'tcx>,\n-                          a: ty::TraitRef<'tcx>,\n-                          b: ty::TraitRef<'tcx>)\n-        -> InferResult<'tcx, ()>\n-    {\n-        debug!(\"eq_trait_refs({:?} = {:?})\", a, b);\n-        self.commit_if_ok(|_| {\n-            let trace = TypeTrace {\n-                cause: cause.clone(),\n-                values: TraitRefs(ExpectedFound::new(a_is_expected, a, b))\n-            };\n-            self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n-        })\n-    }\n-\n-    pub fn eq_impl_headers(&self,\n-                           a_is_expected: bool,\n-                           cause: &ObligationCause<'tcx>,\n-                           a: &ty::ImplHeader<'tcx>,\n-                           b: &ty::ImplHeader<'tcx>)\n-                           -> InferResult<'tcx, ()>\n-    {\n-        debug!(\"eq_impl_header({:?} = {:?})\", a, b);\n-        match (a.trait_ref, b.trait_ref) {\n-            (Some(a_ref), Some(b_ref)) => self.eq_trait_refs(a_is_expected, cause, a_ref, b_ref),\n-            (None, None) => self.eq_types(a_is_expected, cause, a.self_ty, b.self_ty),\n-            _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n-        }\n-    }\n-\n-    pub fn sub_poly_trait_refs(&self,\n-                               a_is_expected: bool,\n-                               cause: ObligationCause<'tcx>,\n-                               a: ty::PolyTraitRef<'tcx>,\n-                               b: ty::PolyTraitRef<'tcx>)\n-        -> InferResult<'tcx, ()>\n-    {\n-        debug!(\"sub_poly_trait_refs({:?} <: {:?})\", a, b);\n-        self.commit_if_ok(|_| {\n-            let trace = TypeTrace {\n-                cause: cause,\n-                values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b))\n-            };\n-            self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n+        let origin = &ObligationCause::dummy();\n+        self.probe(|_| {\n+            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n+                // Ignore obligations, since we are unrolling\n+                // everything anyway.\n+            })\n         })\n     }\n \n@@ -1123,14 +1004,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn equality_predicate(&self,\n                               cause: &ObligationCause<'tcx>,\n+                              param_env: ty::ParamEnv<'tcx>,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n         self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let cause_span = cause.span;\n-            let eqty_ok = self.eq_types(false, cause, a, b)?;\n+            let eqty_ok = self.at(cause, param_env).eq(b, a)?;\n             self.leak_check(false, cause_span, &skol_map, snapshot)?;\n             self.pop_skolemized(skol_map, snapshot);\n             Ok(eqty_ok.unit())\n@@ -1139,6 +1021,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn subtype_predicate(&self,\n                              cause: &ObligationCause<'tcx>,\n+                             param_env: ty::ParamEnv<'tcx>,\n                              predicate: &ty::PolySubtypePredicate<'tcx>)\n         -> Option<InferResult<'tcx, ()>>\n     {\n@@ -1167,7 +1050,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n \n             let cause_span = cause.span;\n-            let ok = self.sub_types(a_is_expected, cause, a, b)?;\n+            let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n             self.leak_check(false, cause_span, &skol_map, snapshot)?;\n             self.pop_skolemized(skol_map, snapshot);\n             Ok(ok.unit())\n@@ -1569,6 +1452,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// details.\n     pub fn match_poly_projection_predicate(&self,\n                                            cause: ObligationCause<'tcx>,\n+                                           param_env: ty::ParamEnv<'tcx>,\n                                            match_a: ty::PolyProjectionPredicate<'tcx>,\n                                            match_b: ty::TraitRef<'tcx>)\n                                            -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n@@ -1581,7 +1465,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref, p.ty));\n-        let mut combine = self.combine_fields(trace);\n+        let mut combine = self.combine_fields(trace, param_env);\n         let result = combine.higher_ranked_match(span, &match_pair, &match_b, true)?;\n         Ok(InferOk { value: result, obligations: combine.obligations })\n     }\n@@ -1600,27 +1484,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.verify_generic_bound(origin, kind, a, bound);\n     }\n \n-    pub fn can_equate<T>(&self, a: &T, b: &T) -> UnitResult<'tcx>\n-        where T: Relate<'tcx> + fmt::Debug\n-    {\n-        debug!(\"can_equate({:?}, {:?})\", a, b);\n-        self.probe(|_| {\n-            // Gin up a dummy trace, since this won't be committed\n-            // anyhow. We should make this typetrace stuff more\n-            // generic so we don't have to do anything quite this\n-            // terrible.\n-            let trace = TypeTrace::dummy(self.tcx);\n-            self.equate(true, trace, a, b).map(|InferOk { obligations: _, .. }| {\n-                // We can intentionally ignore obligations here, since\n-                // this is part of a simple test for general\n-                // \"equatability\". However, it's not entirely clear\n-                // that we *ought* to be, perhaps a better thing would\n-                // be to use a mini-fulfillment context or something\n-                // like that.\n-            })\n-        })\n-    }\n-\n     pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         let ty = self.node_type(id);\n         self.resolve_type_vars_or_error(&ty)\n@@ -1631,17 +1494,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.resolve_type_vars_or_error(&ty)\n     }\n \n-    pub fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+    pub fn type_moves_by_default(&self,\n+                                 param_env: ty::ParamEnv<'tcx>,\n+                                 ty: Ty<'tcx>,\n+                                 span: Span)\n+                                 -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n-        if let Some(ty) = self.tcx.lift_to_global(&ty) {\n+        if let Some((param_env, ty)) = self.tcx.lift_to_global(&(param_env, ty)) {\n             // Even if the type may have no inference variables, during\n             // type-checking closure types are in local tables only.\n             let local_closures = match self.tables {\n                 InferTables::InProgress(_) => ty.has_closure_types(),\n                 _ => false\n             };\n             if !local_closures {\n-                return ty.moves_by_default(self.tcx.global_tcx(), self.param_env(), span);\n+                return ty.moves_by_default(self.tcx.global_tcx(), param_env, span);\n             }\n         }\n \n@@ -1651,17 +1518,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n-        !traits::type_known_to_meet_bound(self, ty, copy_def_id, span)\n+        !traits::type_known_to_meet_bound(self, param_env, ty, copy_def_id, span)\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n         self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n     }\n \n-    pub fn param_env(&self) -> ty::ParamEnv<'gcx> {\n-        self.param_env\n-    }\n-\n     pub fn closure_kind(&self,\n                         def_id: DefId)\n                         -> Option<ty::ClosureKind>"}, {"sha": "405699968135243e5cb4ab974837fe07150e817f", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -96,6 +96,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                 self.fields.obligations.push(\n                     Obligation::new(\n                         self.fields.trace.cause.clone(),\n+                        self.fields.param_env,\n                         ty::Predicate::Subtype(\n                             ty::Binder(ty::SubtypePredicate {\n                                 a_is_expected: self.a_is_expected,"}, {"sha": "2216103636fb6c7821bfbb8b0fda714b129d02be", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -47,7 +47,7 @@\n #![cfg_attr(stage0, feature(staged_api))]\n #![cfg_attr(stage0, feature(loop_break_value))]\n \n-#![recursion_limit=\"192\"]\n+#![recursion_limit=\"256\"]\n \n extern crate arena;\n extern crate core;"}, {"sha": "7ab534605c2514193fd884c13c462c2640ee4ca9", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -242,6 +242,7 @@ impl OverloadedCallType {\n pub struct ExprUseVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n     delegate: &'a mut Delegate<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n // If the TYPER results in an error, it's because the type check\n@@ -266,24 +267,28 @@ macro_rules! return_if_err {\n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n                region_maps: &'a RegionMaps,\n-               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n+               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+               param_env: ty::ParamEnv<'tcx>)\n                -> Self\n     {\n         ExprUseVisitor::with_options(delegate,\n                                      infcx,\n+                                     param_env,\n                                      region_maps,\n                                      mc::MemCategorizationOptions::default())\n     }\n \n     pub fn with_options(delegate: &'a mut (Delegate<'tcx>+'a),\n                         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                        param_env: ty::ParamEnv<'tcx>,\n                         region_maps: &'a RegionMaps,\n                         options: mc::MemCategorizationOptions)\n                -> Self\n     {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::with_options(infcx, region_maps, options),\n-            delegate: delegate\n+            delegate,\n+            param_env,\n         }\n     }\n \n@@ -318,7 +323,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n                consume_id, cmt);\n \n-        let mode = copy_or_move(self.mc.infcx, &cmt, DirectRefMove);\n+        let mode = copy_or_move(self.mc.infcx, self.param_env, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -797,7 +802,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 PatKind::Binding(hir::BindByRef(..), ..) =>\n                     mode.lub(BorrowingMatch),\n                 PatKind::Binding(hir::BindByValue(..), ..) => {\n-                    match copy_or_move(self.mc.infcx, &cmt_pat, PatBindingMove) {\n+                    match copy_or_move(self.mc.infcx, self.param_env, &cmt_pat, PatBindingMove) {\n                         Copy => mode.lub(CopyingMatch),\n                         Move(..) => mode.lub(MovingMatch),\n                     }\n@@ -813,10 +818,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n         debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n \n-        let tcx = &self.tcx();\n-        let mc = &self.mc;\n+        let tcx = self.tcx();\n         let infcx = self.mc.infcx;\n-        let delegate = &mut self.delegate;\n+        let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n@@ -840,7 +844,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     hir::BindByValue(..) => {\n-                        let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n+                        let mode = copy_or_move(infcx, param_env, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n@@ -899,7 +903,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                                                    freevar.def));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n-                        let mode = copy_or_move(self.mc.infcx, &cmt_var, CaptureMove);\n+                        let mode = copy_or_move(self.mc.infcx,\n+                                                self.param_env,\n+                                                &cmt_var,\n+                                                CaptureMove);\n                         self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n@@ -929,11 +936,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n }\n \n fn copy_or_move<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                param_env: ty::ParamEnv<'tcx>,\n                                 cmt: &mc::cmt<'tcx>,\n                                 move_reason: MoveReason)\n                                 -> ConsumeMode\n {\n-    if infcx.type_moves_by_default(cmt.ty, cmt.span) {\n+    if infcx.type_moves_by_default(param_env, cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "57815b7f0b690b68cc85a0b3aaffb28cdec53fce", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -10,8 +10,6 @@\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use infer::InferCtxt;\n-use traits::Reveal;\n use ty::{self, Ty, TyCtxt};\n use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n \n@@ -31,8 +29,10 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n-struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>\n+struct ExprVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'tcx ty::TypeckTables<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n /// If the type is `Option<T>`, it will return `T`, otherwise\n@@ -64,18 +64,18 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty\n }\n \n-impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.infcx.tcx.type_of(def_id).sty {\n+        let intrinsic = match self.tcx.type_of(def_id).sty {\n             ty::TyFnDef(.., bfty) => bfty.abi() == RustIntrinsic,\n             _ => return false\n         };\n-        intrinsic && self.infcx.tcx.item_name(def_id) == \"transmute\"\n+        intrinsic && self.tcx.item_name(def_id) == \"transmute\"\n     }\n \n-    fn check_transmute(&self, span: Span, from: Ty<'gcx>, to: Ty<'gcx>) {\n-        let sk_from = SizeSkeleton::compute(from, self.infcx);\n-        let sk_to = SizeSkeleton::compute(to, self.infcx);\n+    fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>) {\n+        let sk_from = SizeSkeleton::compute(from, self.tcx, self.param_env);\n+        let sk_to = SizeSkeleton::compute(to, self.tcx, self.param_env);\n \n         // Check for same size using the skeletons.\n         if let (Ok(sk_from), Ok(sk_to)) = (sk_from, sk_to) {\n@@ -85,11 +85,11 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n \n             // Special-case transmutting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n-            let from = unpack_option_like(self.infcx.tcx.global_tcx(), from);\n+            let from = unpack_option_like(self.tcx.global_tcx(), from);\n             match (&from.sty, sk_to) {\n                 (&ty::TyFnDef(..), SizeSkeleton::Known(size_to))\n-                        if size_to == Pointer.size(self.infcx) => {\n-                    struct_span_err!(self.infcx.tcx.sess, span, E0591,\n+                        if size_to == Pointer.size(self.tcx) => {\n+                    struct_span_err!(self.tcx.sess, span, E0591,\n                                      \"`{}` is zero-sized and can't be transmuted to `{}`\",\n                                      from, to)\n                         .span_note(span, \"cast with `as` to a pointer instead\")\n@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n         }\n \n         // Try to display a sensible error with as much information as possible.\n-        let skeleton_string = |ty: Ty<'gcx>, sk| {\n+        let skeleton_string = |ty: Ty<'tcx>, sk| {\n             match sk {\n                 Ok(SizeSkeleton::Known(size)) => {\n                     format!(\"{} bits\", size.bits())\n@@ -120,7 +120,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        struct_span_err!(self.infcx.tcx.sess, span, E0512,\n+        struct_span_err!(self.tcx.sess, span, E0512,\n                   \"transmute called with differently sized types: \\\n                    {} ({}) to {} ({})\",\n                   from, skeleton_string(from, sk_from),\n@@ -139,32 +139,30 @@ impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        let owner_def_id = self.tcx.hir.body_owner_def_id(body_id);\n         let body = self.tcx.hir.body(body_id);\n-        self.tcx.infer_ctxt(body_id, Reveal::All).enter(|infcx| {\n-            let mut visitor = ExprVisitor {\n-                infcx: &infcx\n-            };\n-            visitor.visit_body(body);\n-        });\n+        let param_env = self.tcx.param_env(owner_def_id);\n+        let tables = self.tcx.typeck_tables_of(owner_def_id);\n+        ExprVisitor { tcx: self.tcx, param_env, tables }.visit_body(body);\n         self.visit_body(body);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for ExprVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = if let hir::ExprPath(ref qpath) = expr.node {\n-            self.infcx.tables.borrow().qpath_def(qpath, expr.id)\n+            self.tables.qpath_def(qpath, expr.id)\n         } else {\n             Def::Err\n         };\n         match def {\n             Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                let typ = self.infcx.tables.borrow().node_id_to_type(expr.id);\n-                let typ = self.infcx.tcx.lift_to_global(&typ).unwrap();\n+                let typ = self.tables.node_id_to_type(expr.id);\n+                let typ = self.tcx.lift_to_global(&typ).unwrap();\n                 match typ.sty {\n                     ty::TyFnDef(.., sig) if sig.abi() == RustIntrinsic => {\n                         let from = sig.inputs().skip_binder()[0];"}, {"sha": "54fe3a42b6179050550ecd71b3899ec80d1652dc", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -10,10 +10,11 @@\n \n //! See `README.md` for high-level documentation\n \n-use super::{SelectionContext, Obligation, ObligationCause};\n-\n use hir::def_id::{DefId, LOCAL_CRATE};\n+use syntax_pos::DUMMY_SP;\n+use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause, Reveal};\n use ty::{self, Ty, TyCtxt};\n+use ty::subst::Subst;\n \n use infer::{InferCtxt, InferOk};\n \n@@ -37,6 +38,28 @@ pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     overlap(selcx, impl1_def_id, impl2_def_id)\n }\n \n+fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+                                       param_env: ty::ParamEnv<'tcx>,\n+                                       impl_def_id: DefId)\n+                                       -> ty::ImplHeader<'tcx>\n+{\n+    let tcx = selcx.tcx();\n+    let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+\n+    let header = ty::ImplHeader {\n+        impl_def_id: impl_def_id,\n+        self_ty: tcx.type_of(impl_def_id),\n+        trait_ref: tcx.impl_trait_ref(impl_def_id),\n+        predicates: tcx.predicates_of(impl_def_id).predicates\n+    }.subst(tcx, impl_substs);\n+\n+    let Normalized { value: mut header, obligations } =\n+        traits::normalize(selcx, param_env, ObligationCause::dummy(), &header);\n+\n+    header.predicates.extend(obligations.into_iter().map(|o| o.predicate));\n+    header\n+}\n+\n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n@@ -48,18 +71,22 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n            a_def_id,\n            b_def_id);\n \n-    let a_impl_header = ty::ImplHeader::with_fresh_ty_vars(selcx, a_def_id);\n-    let b_impl_header = ty::ImplHeader::with_fresh_ty_vars(selcx, b_def_id);\n+    // For the purposes of this check, we don't bring any skolemized\n+    // types into scope; instead, we replace the generic types with\n+    // fresh type variables, and hence we do our evaluations in an\n+    // empty environment.\n+    let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+\n+    let a_impl_header = with_fresh_ty_vars(selcx, param_env, a_def_id);\n+    let b_impl_header = with_fresh_ty_vars(selcx, param_env, b_def_id);\n \n     debug!(\"overlap: a_impl_header={:?}\", a_impl_header);\n     debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    let obligations = match selcx.infcx().eq_impl_headers(true,\n-                                        &ObligationCause::dummy(),\n-                                        &a_impl_header,\n-                                        &b_impl_header) {\n-        Ok(InferOk { obligations, .. }) => {\n+    let obligations = match selcx.infcx().at(&ObligationCause::dummy(), param_env)\n+                                         .eq_impl_headers(&a_impl_header, &b_impl_header) {\n+        Ok(InferOk { obligations, value: () }) => {\n             obligations\n         }\n         Err(_) => return None\n@@ -75,6 +102,7 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n                      .chain(&b_impl_header.predicates)\n                      .map(|p| infcx.resolve_type_vars_if_possible(p))\n                      .map(|p| Obligation { cause: ObligationCause::dummy(),\n+                                           param_env: param_env,\n                                            recursion_depth: 0,\n                                            predicate: p })\n                      .chain(obligations)"}, {"sha": "049d5e488c946f0e0d3312c25083f2a33ebb5d5e", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -179,14 +179,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     data);\n                 let normalized = super::normalize_projection_type(\n                     &mut selcx,\n+                    obligation.param_env,\n                     data.projection_ty,\n                     obligation.cause.clone(),\n                     0\n                 );\n-                if let Err(error) = self.eq_types(\n-                    false, &obligation.cause,\n-                    data.ty, normalized.value\n-                ) {\n+                if let Err(error) = self.at(&obligation.cause, obligation.param_env)\n+                                        .eq(normalized.value, data.ty) {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound {\n                         expected: normalized.value,\n                         found: data.ty,\n@@ -251,7 +250,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        -> Option<DefId>\n     {\n         let tcx = self.tcx;\n-\n+        let param_env = obligation.param_env;\n         let trait_ref = tcx.erase_late_bound_regions(&trait_ref);\n         let trait_self_ty = trait_ref.self_ty();\n \n@@ -268,7 +267,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                 let impl_self_ty = impl_trait_ref.self_ty();\n \n-                if let Ok(..) = self.can_equate(&trait_self_ty, &impl_self_ty) {\n+                if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n                     self_match_impls.push(def_id);\n \n                     if trait_ref.substs.types().skip(1)\n@@ -578,7 +577,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         // Try to report a help message\n                         if !trait_ref.has_infer_types() &&\n-                            self.predicate_can_apply(trait_ref) {\n+                            self.predicate_can_apply(obligation.param_env, trait_ref) {\n                             // If a where-clause may be useful, remind the\n                             // user that they can add it.\n                             //\n@@ -607,7 +606,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::Equate(ref predicate) => {\n                         let predicate = self.resolve_type_vars_if_possible(predicate);\n                         let err = self.equality_predicate(&obligation.cause,\n-                                                            &predicate).err().unwrap();\n+                                                          obligation.param_env,\n+                                                          &predicate).err().unwrap();\n                         struct_span_err!(self.tcx.sess, span, E0278,\n                             \"the requirement `{}` is not satisfied (`{}`)\",\n                             predicate, err)\n@@ -936,7 +936,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns whether the trait predicate may apply for *some* assignment\n     /// to the type parameters.\n-    fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n+    fn predicate_can_apply(&self,\n+                           param_env: ty::ParamEnv<'tcx>,\n+                           pred: ty::PolyTraitRef<'tcx>)\n+                           -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n@@ -967,12 +970,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             let cleaned_pred = super::project::normalize(\n                 &mut selcx,\n+                param_env,\n                 ObligationCause::dummy(),\n                 &cleaned_pred\n             ).value;\n \n             let obligation = Obligation::new(\n                 ObligationCause::dummy(),\n+                param_env,\n                 cleaned_pred.to_predicate()\n             );\n "}, {"sha": "c2fe04534375f1c6500c119499fbb16b791f4fce", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -113,6 +113,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// `projection_ty` again.\n     pub fn normalize_projection_type(&mut self,\n                                      infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                     param_env: ty::ParamEnv<'tcx>,\n                                      projection_ty: ty::ProjectionTy<'tcx>,\n                                      cause: ObligationCause<'tcx>)\n                                      -> Ty<'tcx>\n@@ -125,7 +126,11 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         // FIXME(#20304) -- cache\n \n         let mut selcx = SelectionContext::new(infcx);\n-        let normalized = project::normalize_projection_type(&mut selcx, projection_ty, cause, 0);\n+        let normalized = project::normalize_projection_type(&mut selcx,\n+                                                            param_env,\n+                                                            projection_ty,\n+                                                            cause,\n+                                                            0);\n \n         for obligation in normalized.obligations {\n             self.register_predicate_obligation(infcx, obligation);\n@@ -136,8 +141,12 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         normalized.value\n     }\n \n+    /// Requires that `ty` must implement the trait with `def_id` in\n+    /// the given environment. This trait must not have any type\n+    /// parameters (except for `Self`).\n     pub fn register_bound(&mut self,\n                           infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                          param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>,\n                           def_id: DefId,\n                           cause: ObligationCause<'tcx>)\n@@ -149,6 +158,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         self.register_predicate_obligation(infcx, Obligation {\n             cause: cause,\n             recursion_depth: 0,\n+            param_env,\n             predicate: trait_ref.to_predicate()\n         });\n     }\n@@ -410,7 +420,9 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::Equate(ref binder) => {\n-            match selcx.infcx().equality_predicate(&obligation.cause, binder) {\n+            match selcx.infcx().equality_predicate(&obligation.cause,\n+                                                   obligation.param_env,\n+                                                   binder) {\n                 Ok(InferOk { obligations, value: () }) => {\n                     Ok(Some(obligations))\n                 },\n@@ -498,7 +510,9 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::WellFormed(ty) => {\n-            match ty::wf::obligations(selcx.infcx(), obligation.cause.body_id,\n+            match ty::wf::obligations(selcx.infcx(),\n+                                      obligation.param_env,\n+                                      obligation.cause.body_id,\n                                       ty, obligation.cause.span) {\n                 None => {\n                     pending_obligation.stalled_on = vec![ty];\n@@ -509,7 +523,9 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::Subtype(ref subtype) => {\n-            match selcx.infcx().subtype_predicate(&obligation.cause, subtype) {\n+            match selcx.infcx().subtype_predicate(&obligation.cause,\n+                                                  obligation.param_env,\n+                                                  subtype) {\n                 None => {\n                     // none means that both are unresolved\n                     pending_obligation.stalled_on = vec![subtype.skip_binder().a,"}, {"sha": "c51974e6e670021a3f390f3739c1516b4538f148", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -68,6 +68,7 @@ mod util;\n #[derive(Clone, PartialEq, Eq)]\n pub struct Obligation<'tcx, T> {\n     pub cause: ObligationCause<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n     pub recursion_depth: usize,\n     pub predicate: T,\n }\n@@ -359,10 +360,11 @@ pub struct VtableFnPointerData<'tcx, N> {\n \n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n+                                     param_env: ty::ParamEnv<'tcx>,\n                                      generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> PredicateObligations<'tcx>\n {\n-    util::predicates_for_generics(cause, 0, generic_bounds)\n+    util::predicates_for_generics(cause, 0, param_env, generic_bounds)\n }\n \n /// Determines whether the type `ty` is known to meet `bound` and\n@@ -371,6 +373,7 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                param_env: ty::ParamEnv<'tcx>,\n                                                 ty: Ty<'tcx>,\n                                                 def_id: DefId,\n                                                 span: Span)\n@@ -385,6 +388,7 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         substs: infcx.tcx.mk_substs_trait(ty, &[]),\n     };\n     let obligation = Obligation {\n+        param_env,\n         cause: ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n         recursion_depth: 0,\n         predicate: trait_ref.to_predicate(),\n@@ -408,7 +412,7 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         // anyhow).\n         let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n \n-        fulfill_cx.register_bound(infcx, ty, def_id, cause);\n+        fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n \n         // Note: we only assume something is `Copy` if we can\n         // *definitively* show that it implements `Copy`. Otherwise,\n@@ -477,24 +481,27 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n            predicates);\n \n-    let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates));\n+    let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n+                                           unnormalized_env.reveal);\n \n-    tcx.infer_ctxt(elaborated_env, Reveal::UserFacing).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n         let predicates = match fully_normalize(\n-                &infcx, cause,\n-                // You would really want to pass infcx.param_env.caller_bounds here,\n-                // but that is an interned slice, and fully_normalize takes &T and returns T, so\n-                // without further refactoring, a slice can't be used. Luckily, we still have the\n-                // predicate vector from which we created the ParamEnv in infcx, so we\n-                // can pass that instead. It's roundabout and a bit brittle, but this code path\n-                // ought to be refactored anyway, and until then it saves us from having to copy.\n-                &predicates,\n+            &infcx,\n+            cause,\n+            elaborated_env,\n+            // You would really want to pass infcx.param_env.caller_bounds here,\n+            // but that is an interned slice, and fully_normalize takes &T and returns T, so\n+            // without further refactoring, a slice can't be used. Luckily, we still have the\n+            // predicate vector from which we created the ParamEnv in infcx, so we\n+            // can pass that instead. It's roundabout and a bit brittle, but this code path\n+            // ought to be refactored anyway, and until then it saves us from having to copy.\n+            &predicates,\n         ) {\n             Ok(predicates) => predicates,\n             Err(errors) => {\n                 infcx.report_fulfillment_errors(&errors);\n                 // An unnormalized env is better than nothing.\n-                return infcx.param_env;\n+                return elaborated_env;\n             }\n         };\n \n@@ -516,24 +523,25 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // all things considered.\n                 tcx.sess.span_err(span, &fixup_err.to_string());\n                 // An unnormalized env is better than nothing.\n-                return infcx.param_env;\n+                return elaborated_env;\n             }\n         };\n \n         let predicates = match tcx.lift_to_global(&predicates) {\n             Some(predicates) => predicates,\n-            None => return infcx.param_env\n+            None => return elaborated_env,\n         };\n \n         debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n-            predicates);\n+               predicates);\n \n-        ty::ParamEnv::new(tcx.intern_predicates(&predicates))\n+        ty::ParamEnv::new(tcx.intern_predicates(&predicates), unnormalized_env.reveal)\n     })\n }\n \n pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                           cause: ObligationCause<'tcx>,\n+                                          param_env: ty::ParamEnv<'tcx>,\n                                           value: &T)\n                                           -> Result<T, Vec<FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx>\n@@ -557,7 +565,7 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     let mut fulfill_cx = FulfillmentContext::new();\n \n     let Normalized { value: normalized_value, obligations } =\n-        project::normalize(selcx, cause, value);\n+        project::normalize(selcx, param_env, cause, value);\n     debug!(\"fully_normalize: normalized_value={:?} obligations={:?}\",\n            normalized_value,\n            obligations);\n@@ -579,28 +587,29 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     Ok(resolved_value)\n }\n \n-/// Normalizes the predicates and checks whether they hold.  If this\n-/// returns false, then either normalize encountered an error or one\n-/// of the predicates did not hold. Used when creating vtables to\n-/// check for unsatisfiable methods.\n+/// Normalizes the predicates and checks whether they hold in an empty\n+/// environment. If this returns false, then either normalize\n+/// encountered an error or one of the predicates did not hold. Used\n+/// when creating vtables to check for unsatisfiable methods.\n pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                predicates: Vec<ty::Predicate<'tcx>>)\n                                                -> bool\n {\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n+        let param_env = ty::ParamEnv::empty(Reveal::All);\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = FulfillmentContext::new();\n         let cause = ObligationCause::dummy();\n         let Normalized { value: predicates, obligations } =\n-            normalize(&mut selcx, cause.clone(), &predicates);\n+            normalize(&mut selcx, param_env, cause.clone(), &predicates);\n         for obligation in obligations {\n             fulfill_cx.register_predicate_obligation(&infcx, obligation);\n         }\n         for predicate in predicates {\n-            let obligation = Obligation::new(cause.clone(), predicate);\n+            let obligation = Obligation::new(cause.clone(), param_env, predicate);\n             fulfill_cx.register_predicate_obligation(&infcx, obligation);\n         }\n \n@@ -662,30 +671,33 @@ pub fn get_vtable_methods<'a, 'tcx>(\n \n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n-               trait_ref: O)\n+               param_env: ty::ParamEnv<'tcx>,\n+               predicate: O)\n                -> Obligation<'tcx, O>\n     {\n-        Obligation { cause: cause,\n-                     recursion_depth: 0,\n-                     predicate: trait_ref }\n+        Obligation { cause, param_env, recursion_depth: 0, predicate }\n     }\n \n     fn with_depth(cause: ObligationCause<'tcx>,\n                   recursion_depth: usize,\n-                  trait_ref: O)\n+                  param_env: ty::ParamEnv<'tcx>,\n+                  predicate: O)\n                   -> Obligation<'tcx, O>\n     {\n-        Obligation { cause: cause,\n-                     recursion_depth: recursion_depth,\n-                     predicate: trait_ref }\n+        Obligation { cause, param_env, recursion_depth, predicate }\n     }\n \n-    pub fn misc(span: Span, body_id: ast::NodeId, trait_ref: O) -> Obligation<'tcx, O> {\n-        Obligation::new(ObligationCause::misc(span, body_id), trait_ref)\n+    pub fn misc(span: Span,\n+                body_id: ast::NodeId,\n+                param_env: ty::ParamEnv<'tcx>,\n+                trait_ref: O)\n+                -> Obligation<'tcx, O> {\n+        Obligation::new(ObligationCause::misc(span, body_id), param_env, trait_ref)\n     }\n \n     pub fn with<P>(&self, value: P) -> Obligation<'tcx,P> {\n         Obligation { cause: self.cause.clone(),\n+                     param_env: self.param_env,\n                      recursion_depth: self.recursion_depth,\n                      predicate: value }\n     }"}, {"sha": "787452121d375c841f51665ea8b23706ded59789", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -36,7 +36,7 @@ use util::common::FN_OUTPUT_NAME;\n \n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum Reveal {\n     /// At type-checking time, we refuse to project any associated\n     /// type that is marked `default`. Non-`default` (\"final\") types\n@@ -168,7 +168,8 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n \n     let Normalized { value: normalized_ty, mut obligations } =\n         match opt_normalize_projection_type(selcx,\n-                                            obligation.predicate.projection_ty.clone(),\n+                                            obligation.param_env,\n+                                            obligation.predicate.projection_ty,\n                                             obligation.cause.clone(),\n                                             obligation.recursion_depth) {\n             Some(n) => n,\n@@ -180,7 +181,8 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n            obligations);\n \n     let infcx = selcx.infcx();\n-    match infcx.eq_types(true, &obligation.cause, normalized_ty, obligation.predicate.ty) {\n+    match infcx.at(&obligation.cause, obligation.param_env)\n+               .eq(normalized_ty, obligation.predicate.ty) {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             Ok(Some(obligations))\n@@ -194,17 +196,19 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n /// combines the normalized result and any additional obligations that\n /// were incurred as result.\n pub fn normalize<'a, 'b, 'gcx, 'tcx, T>(selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+                                        param_env: ty::ParamEnv<'tcx>,\n                                         cause: ObligationCause<'tcx>,\n                                         value: &T)\n                                         -> Normalized<'tcx, T>\n     where T : TypeFoldable<'tcx>\n {\n-    normalize_with_depth(selcx, cause, 0, value)\n+    normalize_with_depth(selcx, param_env, cause, 0, value)\n }\n \n /// As `normalize`, but with a custom depth.\n pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize,\n     value: &T)\n@@ -213,7 +217,7 @@ pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n     where T : TypeFoldable<'tcx>\n {\n     debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n-    let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n+    let mut normalizer = AssociatedTypeNormalizer::new(selcx, param_env, cause, depth);\n     let result = normalizer.fold(value);\n     debug!(\"normalize_with_depth: depth={} result={:?} with {} obligations\",\n            depth, result, normalizer.obligations.len());\n@@ -227,19 +231,22 @@ pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n \n struct AssociatedTypeNormalizer<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     cause: ObligationCause<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n     depth: usize,\n }\n \n impl<'a, 'b, 'gcx, 'tcx> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n     fn new(selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+           param_env: ty::ParamEnv<'tcx>,\n            cause: ObligationCause<'tcx>,\n            depth: usize)\n            -> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx>\n     {\n         AssociatedTypeNormalizer {\n             selcx: selcx,\n+            param_env: param_env,\n             cause: cause,\n             obligations: vec![],\n             depth: depth,\n@@ -278,12 +285,14 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n         match ty.sty {\n             ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in trans.\n-                if self.selcx.projection_mode() == Reveal::All {\n-                    let generic_ty = self.tcx().type_of(def_id);\n-                    let concrete_ty = generic_ty.subst(self.tcx(), substs);\n-                    self.fold_ty(concrete_ty)\n-                } else {\n-                    ty\n+                match self.param_env.reveal {\n+                    Reveal::UserFacing => ty,\n+\n+                    Reveal::All => {\n+                        let generic_ty = self.tcx().type_of(def_id);\n+                        let concrete_ty = generic_ty.subst(self.tcx(), substs);\n+                        self.fold_ty(concrete_ty)\n+                    }\n                 }\n             }\n \n@@ -303,6 +312,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n \n                 let Normalized { value: normalized_ty, obligations } =\n                     normalize_projection_type(self.selcx,\n+                                              self.param_env,\n                                               data.clone(),\n                                               self.cause.clone(),\n                                               self.depth);\n@@ -342,12 +352,13 @@ impl<'tcx,T> Normalized<'tcx,T> {\n /// obligation `<T as Trait>::Item == $X` for later.\n pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize)\n     -> NormalizedTy<'tcx>\n {\n-    opt_normalize_projection_type(selcx, projection_ty.clone(), cause.clone(), depth)\n+    opt_normalize_projection_type(selcx, param_env, projection_ty.clone(), cause.clone(), depth)\n         .unwrap_or_else(move || {\n             // if we bottom out in ambiguity, create a type variable\n             // and a deferred predicate to resolve this when more type\n@@ -364,7 +375,7 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 ty: ty_var\n             });\n             let obligation = Obligation::with_depth(\n-                cause, depth + 1, projection.to_predicate());\n+                cause, depth + 1, param_env, projection.to_predicate());\n             Normalized {\n                 value: ty_var,\n                 obligations: vec![obligation]\n@@ -378,6 +389,7 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n /// which indicates that there are unbound type variables.\n fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize)\n@@ -447,6 +459,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n             let obligation = Obligation::with_depth(cause.clone(),\n                                                     recursion_limit,\n+                                                    param_env,\n                                                     projection_ty);\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n@@ -462,11 +475,11 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n         Err(ProjectionCacheEntry::Error) => {\n             debug!(\"opt_normalize_projection_type: \\\n                     found error\");\n-            return Some(normalize_to_error(selcx, projection_ty, cause, depth));\n+            return Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth));\n         }\n     }\n \n-    let obligation = Obligation::with_depth(cause.clone(), depth, projection_ty.clone());\n+    let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n     match project_type(selcx, &obligation) {\n         Ok(ProjectedTy::Progress(Progress { ty: projected_ty,\n                                             mut obligations,\n@@ -487,7 +500,10 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                    cacheable);\n \n             let result = if projected_ty.has_projection_types() {\n-                let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth+1);\n+                let mut normalizer = AssociatedTypeNormalizer::new(selcx,\n+                                                                   param_env,\n+                                                                   cause,\n+                                                                   depth+1);\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n                 debug!(\"opt_normalize_projection_type: \\\n@@ -538,7 +554,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n \n             infcx.projection_cache.borrow_mut()\n                                   .error(projection_ty);\n-            Some(normalize_to_error(selcx, projection_ty, cause, depth))\n+            Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth))\n         }\n     }\n }\n@@ -563,6 +579,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n /// one case where this arose.)\n fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                      param_env: ty::ParamEnv<'tcx>,\n                                       projection_ty: ty::ProjectionTy<'tcx>,\n                                       cause: ObligationCause<'tcx>,\n                                       depth: usize)\n@@ -571,6 +588,7 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let trait_ref = projection_ty.trait_ref.to_poly_trait_ref();\n     let trait_obligation = Obligation { cause: cause,\n                                         recursion_depth: depth,\n+                                        param_env,\n                                         predicate: trait_ref.to_predicate() };\n     let tcx = selcx.infcx().tcx;\n     let def_id = tcx.associated_items(projection_ty.trait_ref.def_id).find(|i|\n@@ -744,13 +762,12 @@ fn assemble_candidates_from_param_env<'cx, 'gcx, 'tcx>(\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n     debug!(\"assemble_candidates_from_param_env(..)\");\n-    let env_predicates = selcx.param_env().caller_bounds.iter().cloned();\n     assemble_candidates_from_predicates(selcx,\n                                         obligation,\n                                         obligation_trait_ref,\n                                         candidate_set,\n                                         ProjectionTyCandidate::ParamEnv,\n-                                        env_predicates);\n+                                        obligation.param_env.caller_bounds.iter().cloned());\n }\n \n /// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n@@ -805,7 +822,7 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n     env_predicates: I)\n-    where I: Iterator<Item=ty::Predicate<'tcx>>\n+    where I: IntoIterator<Item=ty::Predicate<'tcx>>\n {\n     debug!(\"assemble_candidates_from_predicates(obligation={:?})\",\n            obligation);\n@@ -823,15 +840,13 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                         data.to_poly_trait_ref();\n                     let obligation_poly_trait_ref =\n                         obligation_trait_ref.to_poly_trait_ref();\n-                    infcx.sub_poly_trait_refs(false,\n-                                              obligation.cause.clone(),\n-                                              data_poly_trait_ref,\n-                                              obligation_poly_trait_ref)\n-                        .map(|InferOk { obligations: _, value: () }| {\n-                            // FIXME(#32730) -- do we need to take obligations\n-                            // into account in any way? At the moment, no.\n-                        })\n-                        .is_ok()\n+                    infcx.at(&obligation.cause, obligation.param_env)\n+                         .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+                         .map(|InferOk { obligations: _, value: () }| {\n+                             // FIXME(#32730) -- do we need to take obligations\n+                             // into account in any way? At the moment, no.\n+                         })\n+                         .is_ok()\n                 });\n \n                 debug!(\"assemble_candidates_from_predicates: candidate={:?} \\\n@@ -934,7 +949,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 // get a result which isn't correct for all monomorphizations.\n                 let new_candidate = if !is_default {\n                     Some(ProjectionTyCandidate::Select)\n-                } else if selcx.projection_mode() == Reveal::All {\n+                } else if obligation.param_env.reveal == Reveal::All {\n                     assert!(!poly_trait_ref.needs_infer());\n                     if !poly_trait_ref.needs_subst() {\n                         Some(ProjectionTyCandidate::Select)\n@@ -1092,10 +1107,9 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n             let data_poly_trait_ref = data.to_poly_trait_ref();\n             let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n             selcx.infcx().probe(|_| {\n-                selcx.infcx().sub_poly_trait_refs(false,\n-                                                  obligation.cause.clone(),\n-                                                  data_poly_trait_ref,\n-                                                  obligation_poly_trait_ref).is_ok()\n+                selcx.infcx().at(&obligation.cause, obligation.param_env)\n+                             .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+                             .is_ok()\n             })\n         });\n \n@@ -1141,6 +1155,7 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n         value: closure_type,\n         obligations\n     } = normalize_with_depth(selcx,\n+                             obligation.param_env,\n                              obligation.cause.clone(),\n                              obligation.recursion_depth+1,\n                              &closure_type);\n@@ -1201,8 +1216,9 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n {\n     let infcx = selcx.infcx();\n     let cause = obligation.cause.clone();\n+    let param_env = obligation.param_env;\n     let trait_ref = obligation.predicate.trait_ref;\n-    match infcx.match_poly_projection_predicate(cause, poly_projection, trait_ref) {\n+    match infcx.match_poly_projection_predicate(cause, param_env, poly_projection, trait_ref) {\n         Ok(InferOk { value: ty_match, obligations }) => {\n             Progress {\n                 ty: ty_match.value,\n@@ -1231,6 +1247,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n \n     let tcx = selcx.tcx();\n+    let param_env = obligation.param_env;\n     let assoc_ty = assoc_ty_def(selcx, impl_def_id, obligation.predicate.item_name(tcx));\n \n     let ty = if !assoc_ty.item.defaultness.has_value() {\n@@ -1245,7 +1262,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     } else {\n         tcx.type_of(assoc_ty.item.def_id)\n     };\n-    let substs = translate_substs(selcx.infcx(), impl_def_id, substs, assoc_ty.node);\n+    let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n     Progress {\n         ty: ty.subst(tcx, substs),\n         obligations: nested,"}, {"sha": "998201ad8d9ffd685b56dc98d4c91b7e9ed3e295", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 86, "deletions": 67, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -21,7 +21,6 @@ use super::{PredicateObligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{ObjectCastObligation, Obligation};\n-use super::Reveal;\n use super::TraitNotObjectSafe;\n use super::Selection;\n use super::SelectionResult;\n@@ -315,18 +314,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn param_env(&self) -> ty::ParamEnv<'gcx> {\n-        self.infcx.param_env()\n-    }\n-\n     pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn projection_mode(&self) -> Reveal {\n-        self.infcx.projection_mode()\n-    }\n-\n     /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n     /// context's self.\n     fn in_snapshot<R, F>(&mut self, f: F) -> R\n@@ -540,7 +531,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::Predicate::Equate(ref p) => {\n                 // does this code ever run?\n-                match self.infcx.equality_predicate(&obligation.cause, p) {\n+                match self.infcx.equality_predicate(&obligation.cause, obligation.param_env, p) {\n                     Ok(InferOk { obligations, .. }) => {\n                         self.inferred_obligations.extend(obligations);\n                         EvaluatedToOk\n@@ -551,7 +542,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::Predicate::Subtype(ref p) => {\n                 // does this code ever run?\n-                match self.infcx.subtype_predicate(&obligation.cause, p) {\n+                match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { obligations, .. })) => {\n                         self.inferred_obligations.extend(obligations);\n                         EvaluatedToOk\n@@ -562,7 +553,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::Predicate::WellFormed(ty) => {\n-                match ty::wf::obligations(self.infcx, obligation.cause.body_id,\n+                match ty::wf::obligations(self.infcx,\n+                                          obligation.param_env,\n+                                          obligation.cause.body_id,\n                                           ty, obligation.cause.span) {\n                     Some(obligations) =>\n                         self.evaluate_predicates_recursively(previous_stack, obligations.iter()),\n@@ -628,7 +621,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let stack = self.push_stack(previous_stack, obligation);\n         let fresh_trait_ref = stack.fresh_trait_ref;\n-        if let Some(result) = self.check_evaluation_cache(fresh_trait_ref) {\n+        if let Some(result) = self.check_evaluation_cache(obligation.param_env, fresh_trait_ref) {\n             debug!(\"CACHE HIT: EVAL({:?})={:?}\",\n                    fresh_trait_ref,\n                    result);\n@@ -640,7 +633,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"CACHE MISS: EVAL({:?})={:?}\",\n                fresh_trait_ref,\n                result);\n-        self.insert_evaluation_cache(fresh_trait_ref, result);\n+        self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, result);\n \n         result\n     }\n@@ -751,10 +744,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn check_evaluation_cache(&self, trait_ref: ty::PolyTraitRef<'tcx>)\n+    fn check_evaluation_cache(&self,\n+                              param_env: ty::ParamEnv<'tcx>,\n+                              trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Option<EvaluationResult>\n     {\n-        if self.can_use_global_caches() {\n+        if self.can_use_global_caches(param_env) {\n             let cache = self.tcx().evaluation_cache.hashmap.borrow();\n             if let Some(cached) = cache.get(&trait_ref) {\n                 return Some(cached.clone());\n@@ -764,6 +759,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn insert_evaluation_cache(&mut self,\n+                               param_env: ty::ParamEnv<'tcx>,\n                                trait_ref: ty::PolyTraitRef<'tcx>,\n                                result: EvaluationResult)\n     {\n@@ -778,7 +774,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        if self.can_use_global_caches() {\n+        if self.can_use_global_caches(param_env) {\n             let mut cache = self.tcx().evaluation_cache.hashmap.borrow_mut();\n             if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n                 cache.insert(trait_ref, result);\n@@ -819,7 +815,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                stack);\n         assert!(!stack.obligation.predicate.has_escaping_regions());\n \n-        if let Some(c) = self.check_candidate_cache(&cache_fresh_trait_pred) {\n+        if let Some(c) = self.check_candidate_cache(stack.obligation.param_env,\n+                                                    &cache_fresh_trait_pred) {\n             debug!(\"CACHE HIT: SELECT({:?})={:?}\",\n                    cache_fresh_trait_pred,\n                    c);\n@@ -832,7 +829,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n             debug!(\"CACHE MISS: SELECT({:?})={:?}\",\n                    cache_fresh_trait_pred, candidate);\n-            self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n+            self.insert_candidate_cache(stack.obligation.param_env,\n+                                        cache_fresh_trait_pred,\n+                                        candidate.clone());\n         }\n \n         candidate\n@@ -995,15 +994,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// Returns true if the global caches can be used.\n     /// Do note that if the type itself is not in the\n     /// global tcx, the local caches will be used.\n-    fn can_use_global_caches(&self) -> bool {\n+    fn can_use_global_caches(&self, param_env: ty::ParamEnv<'tcx>) -> bool {\n         // If there are any where-clauses in scope, then we always use\n         // a cache local to this particular scope. Otherwise, we\n         // switch to a global cache. We used to try and draw\n         // finer-grained distinctions, but that led to a serious of\n         // annoying and weird bugs like #22019 and #18290. This simple\n         // rule seems to be pretty clearly safe and also still retains\n         // a very high hit rate (~95% when compiling rustc).\n-        if !self.param_env().caller_bounds.is_empty() {\n+        if !param_env.caller_bounds.is_empty() {\n             return false;\n         }\n \n@@ -1023,11 +1022,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn check_candidate_cache(&mut self,\n+                             param_env: ty::ParamEnv<'tcx>,\n                              cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n                              -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>>\n     {\n         let trait_ref = &cache_fresh_trait_pred.0.trait_ref;\n-        if self.can_use_global_caches() {\n+        if self.can_use_global_caches(param_env) {\n             let cache = self.tcx().selection_cache.hashmap.borrow();\n             if let Some(cached) = cache.get(&trait_ref) {\n                 return Some(cached.clone());\n@@ -1037,11 +1037,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn insert_candidate_cache(&mut self,\n+                              param_env: ty::ParamEnv<'tcx>,\n                               cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n                               candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n     {\n         let trait_ref = cache_fresh_trait_pred.0.trait_ref;\n-        if self.can_use_global_caches() {\n+        if self.can_use_global_caches(param_env) {\n             let mut cache = self.tcx().selection_cache.hashmap.borrow_mut();\n             if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n                 if let Some(candidate) = self.tcx().lift_to_global(&candidate) {\n@@ -1099,6 +1100,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         let TraitObligationStack { obligation, .. } = *stack;\n         let ref obligation = Obligation {\n+            param_env: obligation.param_env,\n             cause: obligation.cause.clone(),\n             recursion_depth: obligation.recursion_depth,\n             predicate: self.infcx().resolve_type_vars_if_possible(&obligation.predicate)\n@@ -1269,11 +1271,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         -> bool\n     {\n         assert!(!skol_trait_ref.has_escaping_regions());\n-        let cause = obligation.cause.clone();\n-        match self.infcx.sub_poly_trait_refs(false,\n-                                             cause,\n-                                             trait_bound.clone(),\n-                                             ty::Binder(skol_trait_ref.clone())) {\n+        match self.infcx.at(&obligation.cause, obligation.param_env)\n+                        .sup(ty::Binder(skol_trait_ref), trait_bound) {\n             Ok(InferOk { obligations, .. }) => {\n                 self.inferred_obligations.extend(obligations);\n             }\n@@ -1296,9 +1295,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                stack.obligation);\n \n         let all_bounds =\n-            self.param_env().caller_bounds\n-                            .iter()\n-                            .filter_map(|o| o.to_opt_poly_trait_ref());\n+            stack.obligation.param_env.caller_bounds\n+                                      .iter()\n+                                      .filter_map(|o| o.to_opt_poly_trait_ref());\n \n         // micro-optimization: filter out predicates relating to different\n         // traits.\n@@ -1953,6 +1952,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn collect_predicates_for_types(&mut self,\n+                                    param_env: ty::ParamEnv<'tcx>,\n                                     cause: ObligationCause<'tcx>,\n                                     recursion_depth: usize,\n                                     trait_def_id: DefId,\n@@ -1981,16 +1981,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     this.infcx().skolemize_late_bound_regions(&ty, snapshot);\n                 let Normalized { value: normalized_ty, mut obligations } =\n                     project::normalize_with_depth(this,\n+                                                  param_env,\n                                                   cause.clone(),\n                                                   recursion_depth,\n                                                   &skol_ty);\n                 let skol_obligation =\n-                    this.tcx().predicate_for_trait_def(\n-                                                  cause.clone(),\n-                                                  trait_def_id,\n-                                                  recursion_depth,\n-                                                  normalized_ty,\n-                                                  &[]);\n+                    this.tcx().predicate_for_trait_def(param_env,\n+                                                       cause.clone(),\n+                                                       trait_def_id,\n+                                                       recursion_depth,\n+                                                       normalized_ty,\n+                                                       &[]);\n                 obligations.push(skol_obligation);\n                 this.infcx().plug_leaks(skol_map, snapshot, obligations)\n             })\n@@ -2131,7 +2132,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             };\n \n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-            self.collect_predicates_for_types(cause,\n+            self.collect_predicates_for_types(obligation.param_env,\n+                                              cause,\n                                               obligation.recursion_depth+1,\n                                               trait_def,\n                                               nested)\n@@ -2175,6 +2177,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let cause = obligation.derived_cause(BuiltinDerivedObligation);\n         let mut obligations = self.collect_predicates_for_types(\n+            obligation.param_env,\n             cause,\n             obligation.recursion_depth+1,\n             trait_def_id,\n@@ -2187,6 +2190,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.impl_or_trait_obligations(cause,\n                                            obligation.recursion_depth + 1,\n+                                           obligation.param_env,\n                                            trait_def_id,\n                                            &trait_ref.substs,\n                                            skol_map,\n@@ -2220,9 +2224,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                   snapshot);\n             debug!(\"confirm_impl_candidate substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n-            this.vtable_impl(impl_def_id, substs, cause,\n+            this.vtable_impl(impl_def_id,\n+                             substs,\n+                             cause,\n                              obligation.recursion_depth + 1,\n-                             skol_map, snapshot)\n+                             obligation.param_env,\n+                             skol_map,\n+                             snapshot)\n         })\n     }\n \n@@ -2231,6 +2239,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                    mut substs: Normalized<'tcx, &'tcx Substs<'tcx>>,\n                    cause: ObligationCause<'tcx>,\n                    recursion_depth: usize,\n+                   param_env: ty::ParamEnv<'tcx>,\n                    skol_map: infer::SkolemizationMap<'tcx>,\n                    snapshot: &infer::CombinedSnapshot)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n@@ -2244,6 +2253,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let mut impl_obligations =\n             self.impl_or_trait_obligations(cause,\n                                            recursion_depth,\n+                                           param_env,\n                                            impl_def_id,\n                                            &substs.value,\n                                            skol_map,\n@@ -2345,6 +2355,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .map_bound(|(trait_ref, _)| trait_ref);\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                     obligation.param_env,\n                                      obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)?;\n         Ok(VtableFnPointerData { fn_ty: self_ty, nested: vec![] })\n@@ -2374,12 +2385,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                obligations);\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                     obligation.param_env,\n                                      obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)?;\n \n         obligations.push(Obligation::new(\n-                obligation.cause.clone(),\n-                ty::Predicate::ClosureKind(closure_def_id, kind)));\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+            ty::Predicate::ClosureKind(closure_def_id, kind)));\n \n         Ok(VtableClosureData {\n             closure_def_id: closure_def_id,\n@@ -2415,15 +2428,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// report an error to the user.\n     fn confirm_poly_trait_refs(&mut self,\n                                obligation_cause: ObligationCause<'tcx>,\n+                               obligation_param_env: ty::ParamEnv<'tcx>,\n                                obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n                                expected_trait_ref: ty::PolyTraitRef<'tcx>)\n                                -> Result<(), SelectionError<'tcx>>\n     {\n         let obligation_trait_ref = obligation_trait_ref.clone();\n-        self.infcx.sub_poly_trait_refs(false,\n-                                       obligation_cause.clone(),\n-                                       expected_trait_ref.clone(),\n-                                       obligation_trait_ref.clone())\n+        self.infcx\n+            .at(&obligation_cause, obligation_param_env)\n+            .sup(obligation_trait_ref, expected_trait_ref)\n             .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n@@ -2458,8 +2471,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let new_trait = tcx.mk_dynamic(\n                     ty::Binder(tcx.mk_existential_predicates(iter)), r_b);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.eq_types(false, &obligation.cause, new_trait, target)\n-                    .map_err(|_| Unimplemented)?;\n+                    self.infcx.at(&obligation.cause, obligation.param_env)\n+                              .eq(target, new_trait)\n+                              .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n                 // Register one obligation for 'a: 'b.\n@@ -2469,6 +2483,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let outlives = ty::OutlivesPredicate(r_a, r_b);\n                 nested.push(Obligation::with_depth(cause,\n                                                    obligation.recursion_depth + 1,\n+                                                   obligation.param_env,\n                                                    ty::Binder(outlives).to_predicate()));\n             }\n \n@@ -2488,6 +2503,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let mut push = |predicate| {\n                     nested.push(Obligation::with_depth(cause.clone(),\n                                                        obligation.recursion_depth + 1,\n+                                                       obligation.param_env,\n                                                        predicate));\n                 };\n \n@@ -2517,8 +2533,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n                 let InferOk { obligations, .. } =\n-                    self.infcx.eq_types(false, &obligation.cause, a, b)\n-                    .map_err(|_| Unimplemented)?;\n+                    self.infcx.at(&obligation.cause, obligation.param_env)\n+                              .eq(b, a)\n+                              .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n             }\n \n@@ -2580,12 +2597,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 });\n                 let new_struct = tcx.mk_adt(def, tcx.mk_substs(params));\n                 let InferOk { obligations, .. } =\n-                    self.infcx.eq_types(false, &obligation.cause, new_struct, target)\n-                    .map_err(|_| Unimplemented)?;\n+                    self.infcx.at(&obligation.cause, obligation.param_env)\n+                              .eq(target, new_struct)\n+                              .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n+                    obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n                     obligation.recursion_depth + 1,\n@@ -2655,6 +2674,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let impl_trait_ref =\n             project::normalize_with_depth(self,\n+                                          obligation.param_env,\n                                           obligation.cause.clone(),\n                                           obligation.recursion_depth + 1,\n                                           &impl_trait_ref);\n@@ -2667,14 +2687,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                skol_obligation_trait_ref);\n \n         let InferOk { obligations, .. } =\n-            self.infcx.eq_trait_refs(false,\n-                                     &obligation.cause,\n-                                     impl_trait_ref.value.clone(),\n-                                     skol_obligation_trait_ref)\n-            .map_err(|e| {\n-                debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n-                ()\n-            })?;\n+            self.infcx.at(&obligation.cause, obligation.param_env)\n+                      .eq(skol_obligation_trait_ref, impl_trait_ref.value)\n+                      .map_err(|e| {\n+                          debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n+                          ()\n+                      })?;\n         self.inferred_obligations.extend(obligations);\n \n         if let Err(e) = self.infcx.leak_check(false,\n@@ -2740,12 +2758,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                obligation,\n                poly_trait_ref);\n \n-        self.infcx.sub_poly_trait_refs(false,\n-                                       obligation.cause.clone(),\n-                                       poly_trait_ref,\n-                                       obligation.predicate.to_poly_trait_ref())\n-            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n-            .map_err(|_| ())\n+        self.infcx.at(&obligation.cause, obligation.param_env)\n+                  .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n+                  .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n+                  .map_err(|_| ())\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -2809,6 +2825,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // A closure signature can contain associated types which\n         // must be normalized.\n         normalize_with_depth(self,\n+                             obligation.param_env,\n                              obligation.cause.clone(),\n                              obligation.recursion_depth+1,\n                              &trait_ref)\n@@ -2821,6 +2838,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn impl_or_trait_obligations(&mut self,\n                                  cause: ObligationCause<'tcx>,\n                                  recursion_depth: usize,\n+                                 param_env: ty::ParamEnv<'tcx>,\n                                  def_id: DefId, // of impl or trait\n                                  substs: &Substs<'tcx>, // for impl or trait\n                                  skol_map: infer::SkolemizationMap<'tcx>,\n@@ -2847,12 +2865,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let predicates = tcx.predicates_of(def_id);\n         assert_eq!(predicates.parent, None);\n         let predicates = predicates.predicates.iter().flat_map(|predicate| {\n-            let predicate = normalize_with_depth(self, cause.clone(), recursion_depth,\n+            let predicate = normalize_with_depth(self, param_env, cause.clone(), recursion_depth,\n                                                  &predicate.subst(tcx, substs));\n             predicate.obligations.into_iter().chain(\n                 Some(Obligation {\n                     cause: cause.clone(),\n                     recursion_depth: recursion_depth,\n+                    param_env,\n                     predicate: predicate.value\n                 }))\n         }).collect();"}, {"sha": "689f06a359730056625988161a583642fe1eef36", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -41,6 +41,7 @@ pub struct OverlapError {\n /// Given a subst for the requested impl, translate it to a subst\n /// appropriate for the actual item definition (whether it be in that impl,\n /// a parent impl, or the trait).\n+///\n /// When we have selected one impl, but are actually using item definitions from\n /// a parent impl providing a default, we need a way to translate between the\n /// type parameters of the two impls. Here the `source_impl` is the one we've\n@@ -73,6 +74,7 @@ pub struct OverlapError {\n /// *fulfillment* to relate the two impls, requiring that all projections are\n /// resolved.\n pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                        param_env: ty::ParamEnv<'tcx>,\n                                         source_impl: DefId,\n                                         source_substs: &'tcx Substs<'tcx>,\n                                         target_node: specialization_graph::Node)\n@@ -91,10 +93,11 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                 return source_substs;\n             }\n \n-            fulfill_implication(infcx, source_trait_ref, target_impl).unwrap_or_else(|_| {\n-                bug!(\"When translating substitutions for specialization, the expected \\\n-                      specializaiton failed to hold\")\n-            })\n+            fulfill_implication(infcx, param_env, source_trait_ref, target_impl)\n+                .unwrap_or_else(|_| {\n+                    bug!(\"When translating substitutions for specialization, the expected \\\n+                          specializaiton failed to hold\")\n+                })\n         }\n         specialization_graph::Node::Trait(..) => source_trait_ref.substs,\n     };\n@@ -122,9 +125,10 @@ pub fn find_associated_item<'a, 'tcx>(\n     let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n     match ancestors.defs(tcx, item.name, item.kind).next() {\n         Some(node_item) => {\n-            let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n+            let substs = tcx.infer_ctxt(()).enter(|infcx| {\n+                let param_env = ty::ParamEnv::empty(Reveal::All);\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n-                let substs = translate_substs(&infcx, impl_data.impl_def_id,\n+                let substs = translate_substs(&infcx, param_env, impl_data.impl_def_id,\n                                               substs, node_item.node);\n                 let substs = infcx.tcx.erase_regions(&substs);\n                 tcx.lift(&substs).unwrap_or_else(|| {\n@@ -184,19 +188,22 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n-    let result = tcx.infer_ctxt(penv, Reveal::UserFacing).enter(|infcx| {\n+    let result = tcx.infer_ctxt(()).enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds.\n         let impl1_trait_ref =\n-            match traits::fully_normalize(&infcx, ObligationCause::dummy(), &impl1_trait_ref) {\n+            match traits::fully_normalize(&infcx,\n+                                          ObligationCause::dummy(),\n+                                          penv,\n+                                          &impl1_trait_ref) {\n                 Ok(impl1_trait_ref) => impl1_trait_ref,\n                 Err(err) => {\n                     bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n                 }\n             };\n \n         // Attempt to prove that impl2 applies, given all of the above.\n-        fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()\n+        fulfill_implication(&infcx, penv, impl1_trait_ref, impl2_def_id).is_ok()\n     });\n \n     tcx.specializes_cache.borrow_mut().insert(impl1_def_id, impl2_def_id, result);\n@@ -209,20 +216,20 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// `source_trait_ref` and those whose identity is determined via a where\n /// clause in the impl.\n fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                       param_env: ty::ParamEnv<'tcx>,\n                                        source_trait_ref: ty::TraitRef<'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n     let selcx = &mut SelectionContext::new(&infcx);\n     let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait_ref, mut obligations) = impl_trait_ref_and_oblig(selcx,\n-                                                                   target_impl,\n-                                                                   target_substs);\n+                                                                       param_env,\n+                                                                       target_impl,\n+                                                                       target_substs);\n \n     // do the impls unify? If not, no specialization.\n-    match infcx.eq_trait_refs(true,\n-                              &ObligationCause::dummy(),\n-                              source_trait_ref,\n-                              target_trait_ref) {\n+    match infcx.at(&ObligationCause::dummy(), param_env)\n+               .eq(source_trait_ref, target_trait_ref) {\n         Ok(InferOk { obligations: o, .. }) => {\n             obligations.extend(o);\n         }\n@@ -250,7 +257,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                        source_trait_ref,\n                        target_trait_ref,\n                        errors,\n-                       infcx.param_env.caller_bounds);\n+                       param_env.caller_bounds);\n                 Err(())\n             }\n "}, {"sha": "702c5035a18b721e9708f6fa1ab81afde4b18f09", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -11,7 +11,7 @@\n use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n-use traits::{self, Reveal};\n+use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use std::rc::Rc;\n@@ -109,7 +109,7 @@ impl<'a, 'gcx, 'tcx> Children {\n             let possible_sibling = *slot;\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+            let (le, ge) = tcx.infer_ctxt(()).enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);"}, {"sha": "4abb0cb549db45add7ce5f917660a282bc030f72", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -341,6 +341,7 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n             cause: self.cause.clone(),\n             recursion_depth: self.recursion_depth,\n             predicate: self.predicate.fold_with(folder),\n+            param_env: self.param_env.fold_with(folder),\n         }\n     }\n "}, {"sha": "7ad2ef90f0d49fc2eb8f7eb5654695d8d9c821ef", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -46,12 +46,14 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n             // Do the initial selection for the obligation. This yields the\n             // shallow result we are looking for -- that is, what specific impl.\n-            self.infer_ctxt((), Reveal::All).enter(|infcx| {\n+            self.infer_ctxt(()).enter(|infcx| {\n                 let mut selcx = SelectionContext::new(&infcx);\n \n+                let param_env = ty::ParamEnv::empty(Reveal::All);\n                 let obligation_cause = ObligationCause::misc(span,\n                                                              ast::DUMMY_NODE_ID);\n                 let obligation = Obligation::new(obligation_cause,\n+                                                 param_env,\n                                                  trait_ref.to_poly_trait_predicate());\n \n                 let selection = match selcx.select(&obligation) {"}, {"sha": "c385927811cf7532aac7bcad629670ab58c19340", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -358,6 +358,7 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n /// returning the resulting trait ref and all obligations that arise.\n /// The obligations are closed under normalization.\n pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                                param_env: ty::ParamEnv<'tcx>,\n                                                 impl_def_id: DefId,\n                                                 impl_substs: &Substs<'tcx>)\n                                                 -> (ty::TraitRef<'tcx>,\n@@ -368,14 +369,14 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n     let impl_trait_ref =\n         impl_trait_ref.subst(selcx.tcx(), impl_substs);\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n-        super::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n+        super::normalize(selcx, param_env, ObligationCause::dummy(), &impl_trait_ref);\n \n     let predicates = selcx.tcx().predicates_of(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n-        super::normalize(selcx, ObligationCause::dummy(), &predicates);\n+        super::normalize(selcx, param_env, ObligationCause::dummy(), &predicates);\n     let impl_obligations =\n-        predicates_for_generics(ObligationCause::dummy(), 0, &predicates);\n+        predicates_for_generics(ObligationCause::dummy(), 0, param_env, &predicates);\n \n     let impl_obligations: Vec<_> =\n         impl_obligations.into_iter()\n@@ -389,6 +390,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a,\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n                                      recursion_depth: usize,\n+                                     param_env: ty::ParamEnv<'tcx>,\n                                      generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> Vec<PredicateObligation<'tcx>>\n {\n@@ -398,37 +400,41 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n     generic_bounds.predicates.iter().map(|predicate| {\n         Obligation { cause: cause.clone(),\n                      recursion_depth: recursion_depth,\n+                     param_env: param_env,\n                      predicate: predicate.clone() }\n     }).collect()\n }\n \n pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n     recursion_depth: usize)\n     -> PredicateObligation<'tcx>\n {\n     Obligation {\n         cause: cause,\n+        param_env: param_env,\n         recursion_depth: recursion_depth,\n         predicate: trait_ref.to_predicate(),\n     }\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn predicate_for_trait_def(self,\n-        cause: ObligationCause<'tcx>,\n-        trait_def_id: DefId,\n-        recursion_depth: usize,\n-        param_ty: Ty<'tcx>,\n-        ty_params: &[Ty<'tcx>])\n+                                   param_env: ty::ParamEnv<'tcx>,\n+                                   cause: ObligationCause<'tcx>,\n+                                   trait_def_id: DefId,\n+                                   recursion_depth: usize,\n+                                   param_ty: Ty<'tcx>,\n+                                   ty_params: &[Ty<'tcx>])\n         -> PredicateObligation<'tcx>\n     {\n         let trait_ref = ty::TraitRef {\n             def_id: trait_def_id,\n             substs: self.mk_substs_trait(param_ty, ty_params)\n         };\n-        predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n+        predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n     }\n \n     /// Cast a trait reference into a reference to one of its super"}, {"sha": "c83f73bff6949ba0d14dec923c232896ec1d6c63", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -519,9 +519,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n-    /// Cache for layouts computed from types.\n-    pub layout_cache: RefCell<FxHashMap<Ty<'tcx>, &'tcx Layout>>,\n-\n     /// Used to prevent layout from recursing too deeply.\n     pub layout_depth: Cell<usize>,\n \n@@ -718,7 +715,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n-            layout_cache: RefCell::new(FxHashMap()),\n             layout_interner: RefCell::new(FxHashSet()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n@@ -765,6 +761,18 @@ pub trait Lift<'tcx> {\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n+    type Lifted = ty::ParamEnv<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<ty::ParamEnv<'tcx>> {\n+        self.caller_bounds.lift_to_tcx(tcx).and_then(|caller_bounds| {\n+            Some(ty::ParamEnv {\n+                reveal: self.reveal,\n+                caller_bounds,\n+            })\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n@@ -851,6 +859,25 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Predicate<'a>> {\n+    type Lifted = &'tcx Slice<Predicate<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+        -> Option<&'tcx Slice<Predicate<'tcx>>> {\n+        if self.is_empty() {\n+            return Some(Slice::empty());\n+        }\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n pub mod tls {\n     use super::{CtxtInterners, GlobalCtxt, TyCtxt};\n "}, {"sha": "12af56d5c3dfa5ee862b0732b58959fae4a868d2", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 345, "deletions": 114, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -12,12 +12,10 @@ pub use self::Integer::*;\n pub use self::Layout::*;\n pub use self::Primitive::*;\n \n-use infer::InferCtxt;\n-use session::Session;\n-use traits;\n+use session::{self, DataTypeKind, Session};\n use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions, ReprFlags};\n \n-use syntax::ast::{FloatTy, IntTy, UintTy};\n+use syntax::ast::{self, FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n \n@@ -212,6 +210,12 @@ impl<'a> HasDataLayout for &'a TargetDataLayout {\n     }\n }\n \n+impl<'a, 'tcx> HasDataLayout for TyCtxt<'a, 'tcx, 'tcx> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.data_layout\n+    }\n+}\n+\n /// Endianness of the target, which must match cfg(target-endian).\n #[derive(Copy, Clone)]\n pub enum Endian {\n@@ -457,8 +461,12 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    fn repr_discr(tcx: TyCtxt, ty: Ty, repr: &ReprOptions, min: i64, max: i64)\n-                      -> (Integer, bool) {\n+    fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            ty: Ty<'tcx>,\n+                            repr: &ReprOptions,\n+                            min: i64,\n+                            max: i64)\n+                            -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n         // are any negative values, the only valid unsigned representation is u64\n@@ -583,10 +591,13 @@ enum StructKind {\n     EnumVariant,\n }\n \n-impl<'a, 'gcx, 'tcx> Struct {\n-    fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n-                  repr: &ReprOptions, kind: StructKind,\n-                  scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n+impl<'a, 'tcx> Struct {\n+    fn new(dl: &TargetDataLayout,\n+           fields: &Vec<&'a Layout>,\n+           repr: &ReprOptions,\n+           kind: StructKind,\n+           scapegoat: Ty<'tcx>)\n+           -> Result<Struct, LayoutError<'tcx>> {\n         if repr.packed() && repr.align > 0 {\n             bug!(\"Struct cannot be packed and aligned\");\n         }\n@@ -723,8 +734,8 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n     /// Determine whether a structure would be zero-sized, given its fields.\n     fn would_be_zero_sized<I>(dl: &TargetDataLayout, fields: I)\n-                              -> Result<bool, LayoutError<'gcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n+                              -> Result<bool, LayoutError<'tcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n         for field in fields {\n             let field = field?;\n             if field.is_unsized() || field.size(dl).bytes() > 0 {\n@@ -764,11 +775,11 @@ impl<'a, 'gcx, 'tcx> Struct {\n     /// The tuple is `(path, source_path)`,\n     /// where `path` is in memory order and `source_path` in source order.\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n-    fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                               ty: Ty<'gcx>)\n-                               -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'gcx>> {\n-        let tcx = infcx.tcx.global_tcx();\n-        match (ty.layout(infcx)?, &ty.sty) {\n+    fn non_zero_field_in_type(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              param_env: ty::ParamEnv<'tcx>,\n+                              ty: Ty<'tcx>)\n+                              -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'tcx>> {\n+        match (ty.layout(tcx, param_env)?, &ty.sty) {\n             (&Scalar { non_zero: true, .. }, _) |\n             (&CEnum { non_zero: true, .. }, _) => Ok(Some((vec![], vec![]))),\n             (&FatPointer { non_zero: true, .. }, _) => {\n@@ -779,7 +790,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             (&Univariant { non_zero: true, .. }, &ty::TyAdt(def, substs)) => {\n                 let fields = &def.struct_variant().fields;\n                 assert_eq!(fields.len(), 1);\n-                match *fields[0].ty(tcx, substs).layout(infcx)? {\n+                match *fields[0].ty(tcx, substs).layout(tcx, param_env)? {\n                     // FIXME(eddyb) also allow floating-point types here.\n                     Scalar { value: Int(_), non_zero: false } |\n                     Scalar { value: Pointer, non_zero: false } => {\n@@ -796,37 +807,49 @@ impl<'a, 'gcx, 'tcx> Struct {\n             // Perhaps one of the fields of this struct is non-zero\n             // let's recurse and find out\n             (&Univariant { ref variant, .. }, &ty::TyAdt(def, substs)) if def.is_struct() => {\n-                Struct::non_zero_field_paths(infcx, def.struct_variant().fields\n-                                                      .iter().map(|field| {\n-                    field.ty(tcx, substs)\n-                }),\n-                Some(&variant.memory_index[..]))\n+                Struct::non_zero_field_paths(\n+                    tcx,\n+                    param_env,\n+                    def.struct_variant().fields.iter().map(|field| {\n+                        field.ty(tcx, substs)\n+                    }),\n+                    Some(&variant.memory_index[..]))\n             }\n \n             // Perhaps one of the upvars of this closure is non-zero\n             (&Univariant { ref variant, .. }, &ty::TyClosure(def, substs)) => {\n                 let upvar_tys = substs.upvar_tys(def, tcx);\n-                Struct::non_zero_field_paths(infcx, upvar_tys,\n+                Struct::non_zero_field_paths(\n+                    tcx,\n+                    param_env,\n+                    upvar_tys,\n                     Some(&variant.memory_index[..]))\n             }\n             // Can we use one of the fields in this tuple?\n             (&Univariant { ref variant, .. }, &ty::TyTuple(tys, _)) => {\n-                Struct::non_zero_field_paths(infcx, tys.iter().cloned(),\n+                Struct::non_zero_field_paths(\n+                    tcx,\n+                    param_env,\n+                    tys.iter().cloned(),\n                     Some(&variant.memory_index[..]))\n             }\n \n             // Is this a fixed-size array of something non-zero\n             // with at least one element?\n             (_, &ty::TyArray(ety, d)) if d > 0 => {\n-                Struct::non_zero_field_paths(infcx, Some(ety).into_iter(), None)\n+                Struct::non_zero_field_paths(\n+                    tcx,\n+                    param_env,\n+                    Some(ety).into_iter(),\n+                    None)\n             }\n \n             (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n-                let normalized = infcx.normalize_projections(ty);\n+                let normalized = tcx.normalize_associated_type_in_env(&ty, param_env);\n                 if ty == normalized {\n                     return Ok(None);\n                 }\n-                return Struct::non_zero_field_in_type(infcx, normalized);\n+                return Struct::non_zero_field_in_type(tcx, param_env, normalized);\n             }\n \n             // Anything else is not a non-zero type.\n@@ -838,13 +861,15 @@ impl<'a, 'gcx, 'tcx> Struct {\n     /// the given set of fields and recursing through aggregates.\n     /// Returns Some((path, source_path)) on success.\n     /// `path` is translated to memory order. `source_path` is not.\n-    fn non_zero_field_paths<I>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                  fields: I,\n-                                  permutation: Option<&[u32]>)\n-                                  -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'gcx>>\n-    where I: Iterator<Item=Ty<'gcx>> {\n+    fn non_zero_field_paths<I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               param_env: ty::ParamEnv<'tcx>,\n+                               fields: I,\n+                               permutation: Option<&[u32]>)\n+                               -> Result<Option<(FieldPath, FieldPath)>, LayoutError<'tcx>>\n+    where I: Iterator<Item=Ty<'tcx>> {\n         for (i, ty) in fields.enumerate() {\n-            if let Some((mut path, mut source_path)) = Struct::non_zero_field_in_type(infcx, ty)? {\n+            let r = Struct::non_zero_field_in_type(tcx, param_env, ty)?;\n+            if let Some((mut path, mut source_path)) = r {\n                 source_path.push(i as u32);\n                 let index = if let Some(p) = permutation {\n                     p[i] as usize\n@@ -881,7 +906,7 @@ pub struct Union {\n     pub packed: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> Union {\n+impl<'a, 'tcx> Union {\n     fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n         let align = if packed { dl.i8_align } else { dl.aggregate_align };\n         Union {\n@@ -895,9 +920,9 @@ impl<'a, 'gcx, 'tcx> Union {\n     /// Extend the Struct with more fields.\n     fn extend<I>(&mut self, dl: &TargetDataLayout,\n                  fields: I,\n-                 scapegoat: Ty<'gcx>)\n-                 -> Result<(), LayoutError<'gcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n+                 scapegoat: Ty<'tcx>)\n+                 -> Result<(), LayoutError<'tcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n         for (index, field) in fields.enumerate() {\n             let field = field?;\n             if field.is_unsized() {\n@@ -1067,19 +1092,19 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Layout {\n-    pub fn compute_uncached(ty: Ty<'gcx>,\n-                            infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                            -> Result<&'gcx Layout, LayoutError<'gcx>> {\n-        let tcx = infcx.tcx.global_tcx();\n+impl<'a, 'tcx> Layout {\n+    pub fn compute_uncached(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            param_env: ty::ParamEnv<'tcx>,\n+                            ty: Ty<'tcx>)\n+                            -> Result<&'tcx Layout, LayoutError<'tcx>> {\n         let success = |layout| Ok(tcx.intern_layout(layout));\n         let dl = &tcx.data_layout;\n         assert!(!ty.has_infer_types());\n \n-        let ptr_layout = |pointee: Ty<'gcx>| {\n+        let ptr_layout = |pointee: Ty<'tcx>| {\n             let non_zero = !ty.is_unsafe_ptr();\n-            let pointee = infcx.normalize_projections(pointee);\n-            if pointee.is_sized(tcx, infcx.param_env, DUMMY_SP) {\n+            let pointee = tcx.normalize_associated_type_in_env(&pointee, param_env);\n+            if pointee.is_sized(tcx, param_env, DUMMY_SP) {\n                 Ok(Scalar { value: Pointer, non_zero: non_zero })\n             } else {\n                 let unsized_part = tcx.struct_tail(pointee);\n@@ -1132,7 +1157,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // Arrays and slices.\n             ty::TyArray(element, count) => {\n-                let element = element.layout(infcx)?;\n+                let element = element.layout(tcx, param_env)?;\n                 let element_size = element.size(dl);\n                 // FIXME(eddyb) Don't use host `usize` for array lengths.\n                 let usize_count: usize = count;\n@@ -1149,7 +1174,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 }\n             }\n             ty::TySlice(element) => {\n-                let element = element.layout(infcx)?;\n+                let element = element.layout(tcx, param_env)?;\n                 Array {\n                     sized: false,\n                     align: element.align(dl),\n@@ -1187,7 +1212,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyClosure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n                 let st = Struct::new(dl,\n-                    &tys.map(|ty| ty.layout(infcx))\n+                    &tys.map(|ty| ty.layout(tcx, param_env))\n                       .collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     StructKind::AlwaysSizedUnivariant, ty)?;\n@@ -1198,7 +1223,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // FIXME(camlorn): if we ever allow unsized tuples, this needs to be checked.\n                 // See the univariant case below to learn how.\n                 let st = Struct::new(dl,\n-                    &tys.iter().map(|ty| ty.layout(infcx))\n+                    &tys.iter().map(|ty| ty.layout(tcx, param_env))\n                       .collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n@@ -1207,7 +1232,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n                 let element = ty.simd_type(tcx);\n-                match *element.layout(infcx)? {\n+                match *element.layout(tcx, param_env)? {\n                     Scalar { value, .. } => {\n                         return success(Vector {\n                             element: value,\n@@ -1278,7 +1303,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     };\n \n                     let fields = def.variants[0].fields.iter().map(|field| {\n-                        field.ty(tcx, substs).layout(infcx)\n+                        field.ty(tcx, substs).layout(tcx, param_env)\n                     }).collect::<Result<Vec<_>, _>>()?;\n                     let layout = if def.is_union() {\n                         let mut un = Union::new(dl, def.repr.packed());\n@@ -1312,20 +1337,21 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     // Nullable pointer optimization\n                     for discr in 0..2 {\n                         let other_fields = variants[1 - discr].iter().map(|ty| {\n-                            ty.layout(infcx)\n+                            ty.layout(tcx, param_env)\n                         });\n                         if !Struct::would_be_zero_sized(dl, other_fields)? {\n                             continue;\n                         }\n-                        let paths = Struct::non_zero_field_paths(infcx,\n-                            variants[discr].iter().cloned(),\n-                            None)?;\n+                        let paths = Struct::non_zero_field_paths(tcx,\n+                                                                 param_env,\n+                                                                 variants[discr].iter().cloned(),\n+                                                                 None)?;\n                         let (mut path, mut path_source) = if let Some(p) = paths { p }\n                           else { continue };\n \n                         // FIXME(eddyb) should take advantage of a newtype.\n                         if path == &[0] && variants[discr].len() == 1 {\n-                            let value = match *variants[discr][0].layout(infcx)? {\n+                            let value = match *variants[discr][0].layout(tcx, param_env)? {\n                                 Scalar { value, .. } => value,\n                                 CEnum { discr, .. } => Int(discr),\n                                 _ => bug!(\"Layout::compute: `{}`'s non-zero \\\n@@ -1339,7 +1365,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         }\n \n                         let st = Struct::new(dl,\n-                            &variants[discr].iter().map(|ty| ty.layout(infcx))\n+                            &variants[discr].iter().map(|ty| ty.layout(tcx, param_env))\n                               .collect::<Result<Vec<_>, _>>()?,\n                             &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n \n@@ -1377,7 +1403,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let discr = Scalar { value: Int(min_ity), non_zero: false };\n                 let mut variants = variants.into_iter().map(|fields| {\n                     let mut fields = fields.into_iter().map(|field| {\n-                        field.layout(infcx)\n+                        field.layout(tcx, param_env)\n                     }).collect::<Result<Vec<_>, _>>()?;\n                     fields.insert(0, &discr);\n                     let st = Struct::new(dl,\n@@ -1470,11 +1496,11 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // Types with no meaningful known layout.\n             ty::TyProjection(_) | ty::TyAnon(..) => {\n-                let normalized = infcx.normalize_projections(ty);\n+                let normalized = tcx.normalize_associated_type_in_env(&ty, param_env);\n                 if ty == normalized {\n                     return Err(LayoutError::Unknown(ty));\n                 }\n-                return normalized.layout(infcx);\n+                return normalized.layout(tcx, param_env);\n             }\n             ty::TyParam(_) => {\n                 return Err(LayoutError::Unknown(ty));\n@@ -1664,6 +1690,225 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n         }\n     }\n+\n+    /// This is invoked by the `layout_raw` query to record the final\n+    /// layout of each type.\n+    #[inline]\n+    pub fn record_layout_for_printing(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      ty: Ty<'tcx>,\n+                                      param_env: ty::ParamEnv<'tcx>,\n+                                      layout: &Layout) {\n+        // If we are running with `-Zprint-type-sizes`, record layouts for\n+        // dumping later. Ignore layouts that are done with non-empty\n+        // environments or non-monomorphic layouts, as the user only wants\n+        // to see the stuff resulting from the final trans session.\n+        if\n+            !tcx.sess.opts.debugging_opts.print_type_sizes ||\n+            ty.has_param_types() ||\n+            ty.has_self_ty() ||\n+            !param_env.caller_bounds.is_empty()\n+        {\n+            return;\n+        }\n+\n+        Self::record_layout_for_printing_outlined(tcx, ty, param_env, layout)\n+    }\n+\n+    fn record_layout_for_printing_outlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                           ty: Ty<'tcx>,\n+                                           param_env: ty::ParamEnv<'tcx>,\n+                                           layout: &Layout) {\n+        // (delay format until we actually need it)\n+        let record = |kind, opt_discr_size, variants| {\n+            let type_desc = format!(\"{:?}\", ty);\n+            let overall_size = layout.size(tcx);\n+            let align = layout.align(tcx);\n+            tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n+                                                              type_desc,\n+                                                              align,\n+                                                              overall_size,\n+                                                              opt_discr_size,\n+                                                              variants);\n+        };\n+\n+        let (adt_def, substs) = match ty.sty {\n+            ty::TyAdt(ref adt_def, substs) => {\n+                debug!(\"print-type-size t: `{:?}` process adt\", ty);\n+                (adt_def, substs)\n+            }\n+\n+            ty::TyClosure(..) => {\n+                debug!(\"print-type-size t: `{:?}` record closure\", ty);\n+                record(DataTypeKind::Closure, None, vec![]);\n+                return;\n+            }\n+\n+            _ => {\n+                debug!(\"print-type-size t: `{:?}` skip non-nominal\", ty);\n+                return;\n+            }\n+        };\n+\n+        let adt_kind = adt_def.adt_kind();\n+\n+        let build_field_info = |(field_name, field_ty): (ast::Name, Ty<'tcx>), offset: &Size| {\n+            let layout = field_ty.layout(tcx, param_env);\n+            match layout {\n+                Err(_) => bug!(\"no layout found for field {} type: `{:?}`\", field_name, field_ty),\n+                Ok(field_layout) => {\n+                    session::FieldInfo {\n+                        name: field_name.to_string(),\n+                        offset: offset.bytes(),\n+                        size: field_layout.size(tcx).bytes(),\n+                        align: field_layout.align(tcx).abi(),\n+                    }\n+                }\n+            }\n+        };\n+\n+        let build_primitive_info = |name: ast::Name, value: &Primitive| {\n+            session::VariantInfo {\n+                name: Some(name.to_string()),\n+                kind: session::SizeKind::Exact,\n+                align: value.align(tcx).abi(),\n+                size: value.size(tcx).bytes(),\n+                fields: vec![],\n+            }\n+        };\n+\n+        enum Fields<'a> {\n+            WithDiscrim(&'a Struct),\n+            NoDiscrim(&'a Struct),\n+        }\n+\n+        let build_variant_info = |n: Option<ast::Name>,\n+                                  flds: &[(ast::Name, Ty<'tcx>)],\n+                                  layout: Fields| {\n+            let (s, field_offsets) = match layout {\n+                Fields::WithDiscrim(s) => (s, &s.offsets[1..]),\n+                Fields::NoDiscrim(s) => (s, &s.offsets[0..]),\n+            };\n+            let field_info: Vec<_> =\n+                flds.iter()\n+                    .zip(field_offsets.iter())\n+                    .map(|(&field_name_ty, offset)| build_field_info(field_name_ty, offset))\n+                    .collect();\n+\n+            session::VariantInfo {\n+                name: n.map(|n|n.to_string()),\n+                kind: if s.sized {\n+                    session::SizeKind::Exact\n+                } else {\n+                    session::SizeKind::Min\n+                },\n+                align: s.align.abi(),\n+                size: s.min_size.bytes(),\n+                fields: field_info,\n+            }\n+        };\n+\n+        match *layout {\n+            Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n+                                                   nndiscr,\n+                                                   discrfield: _,\n+                                                   discrfield_source: _ } => {\n+                debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n+                       ty, nndiscr, variant_layout);\n+                let variant_def = &adt_def.variants[nndiscr as usize];\n+                let fields: Vec<_> =\n+                    variant_def.fields.iter()\n+                                      .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n+                                      .collect();\n+                record(adt_kind.into(),\n+                       None,\n+                       vec![build_variant_info(Some(variant_def.name),\n+                                               &fields,\n+                                               Fields::NoDiscrim(variant_layout))]);\n+            }\n+            Layout::RawNullablePointer { nndiscr, value } => {\n+                debug!(\"print-type-size t: `{:?}` adt raw nullable nndiscr {} is {:?}\",\n+                       ty, nndiscr, value);\n+                let variant_def = &adt_def.variants[nndiscr as usize];\n+                record(adt_kind.into(), None,\n+                       vec![build_primitive_info(variant_def.name, &value)]);\n+            }\n+            Layout::Univariant { variant: ref variant_layout, non_zero: _ } => {\n+                let variant_names = || {\n+                    adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n+                };\n+                debug!(\"print-type-size t: `{:?}` adt univariant {:?} variants: {:?}\",\n+                       ty, variant_layout, variant_names());\n+                assert!(adt_def.variants.len() <= 1,\n+                        \"univariant with variants {:?}\", variant_names());\n+                if adt_def.variants.len() == 1 {\n+                    let variant_def = &adt_def.variants[0];\n+                    let fields: Vec<_> =\n+                        variant_def.fields.iter()\n+                                          .map(|f| (f.name, f.ty(tcx, substs)))\n+                                          .collect();\n+                    record(adt_kind.into(),\n+                           None,\n+                           vec![build_variant_info(Some(variant_def.name),\n+                                                   &fields,\n+                                                   Fields::NoDiscrim(variant_layout))]);\n+                } else {\n+                    // (This case arises for *empty* enums; so give it\n+                    // zero variants.)\n+                    record(adt_kind.into(), None, vec![]);\n+                }\n+            }\n+\n+            Layout::General { ref variants, discr, .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt general variants def {} layouts {} {:?}\",\n+                       ty, adt_def.variants.len(), variants.len(), variants);\n+                let variant_infos: Vec<_> =\n+                    adt_def.variants.iter()\n+                                    .zip(variants.iter())\n+                                    .map(|(variant_def, variant_layout)| {\n+                                        let fields: Vec<_> =\n+                                            variant_def.fields\n+                                                       .iter()\n+                                                       .map(|f| (f.name, f.ty(tcx, substs)))\n+                                                       .collect();\n+                                        build_variant_info(Some(variant_def.name),\n+                                                           &fields,\n+                                                           Fields::WithDiscrim(variant_layout))\n+                                    })\n+                                    .collect();\n+                record(adt_kind.into(), Some(discr.size()), variant_infos);\n+            }\n+\n+            Layout::UntaggedUnion { ref variants } => {\n+                debug!(\"print-type-size t: `{:?}` adt union variants {:?}\",\n+                       ty, variants);\n+                // layout does not currently store info about each\n+                // variant...\n+                record(adt_kind.into(), None, Vec::new());\n+            }\n+\n+            Layout::CEnum { discr, .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt c-like enum\", ty);\n+                let variant_infos: Vec<_> =\n+                    adt_def.variants.iter()\n+                                    .map(|variant_def| {\n+                                        build_primitive_info(variant_def.name,\n+                                                             &Primitive::Int(discr))\n+                                    })\n+                                    .collect();\n+                record(adt_kind.into(), Some(discr.size()), variant_infos);\n+            }\n+\n+            // other cases provide little interesting (i.e. adjustable\n+            // via representation tweaks) size info beyond total size.\n+            Layout::Scalar { .. } |\n+            Layout::Vector { .. } |\n+            Layout::Array { .. } |\n+            Layout::FatPointer { .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt other\", ty);\n+                record(adt_kind.into(), None, Vec::new())\n+            }\n+        }\n+    }\n }\n \n /// Type size \"skeleton\", i.e. the only information determining a type's size.\n@@ -1686,21 +1931,22 @@ pub enum SizeSkeleton<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n-    pub fn compute(ty: Ty<'gcx>, infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                   -> Result<SizeSkeleton<'gcx>, LayoutError<'gcx>> {\n-        let tcx = infcx.tcx.global_tcx();\n+impl<'a, 'tcx> SizeSkeleton<'tcx> {\n+    pub fn compute(ty: Ty<'tcx>,\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                   param_env: ty::ParamEnv<'tcx>)\n+                   -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n         assert!(!ty.has_infer_types());\n \n         // First try computing a static layout.\n-        let err = match ty.layout(infcx) {\n+        let err = match ty.layout(tcx, param_env) {\n             Ok(layout) => {\n                 return Ok(SizeSkeleton::Known(layout.size(tcx)));\n             }\n             Err(err) => err\n         };\n \n-        let ptr_skeleton = |pointee: Ty<'gcx>| {\n+        let ptr_skeleton = |pointee: Ty<'tcx>| {\n             let non_zero = !ty.is_unsafe_ptr();\n             let tail = tcx.struct_tail(pointee);\n             match tail.sty {\n@@ -1737,7 +1983,7 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                 // Get a zero-sized variant or a pointer newtype.\n                 let zero_or_ptr_variant = |i: usize| {\n                     let fields = def.variants[i].fields.iter().map(|field| {\n-                        SizeSkeleton::compute(field.ty(tcx, substs), infcx)\n+                        SizeSkeleton::compute(field.ty(tcx, substs), tcx, param_env)\n                     });\n                     let mut ptr = None;\n                     for field in fields {\n@@ -1788,11 +2034,11 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n             }\n \n             ty::TyProjection(_) | ty::TyAnon(..) => {\n-                let normalized = infcx.normalize_projections(ty);\n+                let normalized = tcx.normalize_associated_type_in_env(&ty, param_env);\n                 if ty == normalized {\n                     Err(err)\n                 } else {\n-                    SizeSkeleton::compute(normalized, infcx)\n+                    SizeSkeleton::compute(normalized, tcx, param_env)\n                 }\n             }\n \n@@ -1826,71 +2072,53 @@ impl<'tcx> Deref for TyLayout<'tcx> {\n     }\n }\n \n-pub trait HasTyCtxt<'tcx>: HasDataLayout {\n+pub trait LayoutTyper<'tcx>: HasDataLayout {\n+    type TyLayout;\n+\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout;\n+    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx>;\n }\n \n-impl<'a, 'gcx, 'tcx> HasDataLayout for TyCtxt<'a, 'gcx, 'tcx> {\n-    fn data_layout(&self) -> &TargetDataLayout {\n-        &self.data_layout\n-    }\n+/// Combines a tcx with the parameter environment so that you can\n+/// compute layout operations.\n+#[derive(Copy, Clone)]\n+pub struct LayoutCx<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n-        self.global_tcx()\n+impl<'a, 'tcx> LayoutCx<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, param_env: ty::ParamEnv<'tcx>) -> Self {\n+        LayoutCx { tcx, param_env }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasDataLayout for &'a InferCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> HasDataLayout for LayoutCx<'a, 'tcx> {\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for &'a InferCtxt<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n-        self.tcx.global_tcx()\n-    }\n-}\n-\n-pub trait LayoutTyper<'tcx>: HasTyCtxt<'tcx> {\n-    type TyLayout;\n-\n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout;\n-    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx>;\n-}\n+impl<'a, 'tcx> LayoutTyper<'tcx> for LayoutCx<'a, 'tcx> {\n+    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n-impl<'a, 'gcx, 'tcx> LayoutTyper<'gcx> for &'a InferCtxt<'a, 'gcx, 'tcx> {\n-    type TyLayout = Result<TyLayout<'gcx>, LayoutError<'gcx>>;\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n \n-    fn layout_of(self, ty: Ty<'gcx>) -> Self::TyLayout {\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         let ty = self.normalize_projections(ty);\n \n         Ok(TyLayout {\n             ty: ty,\n-            layout: ty.layout(self)?,\n+            layout: ty.layout(self.tcx, self.param_env)?,\n             variant_index: None\n         })\n     }\n \n-    fn normalize_projections(self, ty: Ty<'gcx>) -> Ty<'gcx> {\n-        if !ty.has_projection_types() {\n-            return ty;\n-        }\n-\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let cause = traits::ObligationCause::dummy();\n-        let traits::Normalized { value: result, obligations } =\n-            traits::normalize(&mut selcx, cause, &ty);\n-\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(self, obligation);\n-        }\n-\n-        self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n+    fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.tcx.normalize_associated_type_in_env(&ty, self.param_env)\n     }\n }\n \n@@ -1943,7 +2171,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         }\n     }\n \n-    pub fn field_type<C: HasTyCtxt<'tcx>>(&self, cx: C, i: usize) -> Ty<'tcx> {\n+    pub fn field_type<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> Ty<'tcx> {\n         let tcx = cx.tcx();\n \n         let ptr_field_type = |pointee: Ty<'tcx>| {\n@@ -2014,7 +2242,10 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         }\n     }\n \n-    pub fn field<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> C::TyLayout {\n+    pub fn field<C: LayoutTyper<'tcx>>(&self,\n+                                       cx: C,\n+                                       i: usize)\n+                                       -> C::TyLayout {\n         cx.layout_of(cx.normalize_projections(self.field_type(cx, i)))\n     }\n }"}, {"sha": "b5adcc8ed757d108435d8523d53af5ec62da60aa", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -20,6 +20,7 @@ use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use ty::layout::{Layout, LayoutError};\n use ty::item_path;\n use ty::steal::Steal;\n use ty::subst::Substs;\n@@ -293,6 +294,12 @@ impl<'tcx> QueryDescription for queries::needs_drop_raw<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::layout_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing layout of `{}`\", env.value)\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"computing the supertraits of `{}`\",\n@@ -906,6 +913,12 @@ define_maps! { <'tcx>\n     [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n     [] is_object_safe: ObjectSafety(DefId) -> bool,\n \n+    // Get the ParameterEnvironment for a given item; this environment\n+    // will be in \"user-facing\" mode, meaning that it is suitabe for\n+    // type-checking etc, and it does not normalize specializable\n+    // associated types. This is almost always what you want,\n+    // unless you are doing MIR optimizations, in which case you\n+    // might want to use `reveal_all()` method to change modes.\n     [] param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n \n     // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n@@ -914,6 +927,8 @@ define_maps! { <'tcx>\n     [] is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                                  -> Result<&'tcx Layout, LayoutError<'tcx>>,\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -981,3 +996,9 @@ fn needs_drop_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<De\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n     DepNode::NeedsDrop(def_id)\n }\n+\n+fn layout_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n+        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n+    DepNode::Layout(def_id)\n+}"}, {"sha": "8c991be0d12d4942c309618bdfd41b45a8dacde9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -158,29 +158,6 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n-    pub fn with_fresh_ty_vars(selcx: &mut traits::SelectionContext<'a, 'gcx, 'tcx>,\n-                              impl_def_id: DefId)\n-                              -> ImplHeader<'tcx>\n-    {\n-        let tcx = selcx.tcx();\n-        let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-\n-        let header = ImplHeader {\n-            impl_def_id: impl_def_id,\n-            self_ty: tcx.type_of(impl_def_id),\n-            trait_ref: tcx.impl_trait_ref(impl_def_id),\n-            predicates: tcx.predicates_of(impl_def_id).predicates\n-        }.subst(tcx, impl_substs);\n-\n-        let traits::Normalized { value: mut header, obligations } =\n-            traits::normalize(selcx, traits::ObligationCause::dummy(), &header);\n-\n-        header.predicates.extend(obligations.into_iter().map(|o| o.predicate));\n-        header\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct AssociatedItem {\n     pub def_id: DefId,\n@@ -1191,6 +1168,11 @@ pub struct ParamEnv<'tcx> {\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations, and elaborated and normalized.\n     pub caller_bounds: &'tcx Slice<ty::Predicate<'tcx>>,\n+\n+    /// Typically, this is `Reveal::UserFacing`, but during trans we\n+    /// want `Reveal::All` -- note that this is always paired with an\n+    /// empty environment. To get that, use `ParamEnv::reveal()`.\n+    pub reveal: traits::Reveal,\n }\n \n impl<'tcx> ParamEnv<'tcx> {\n@@ -1218,7 +1200,7 @@ impl<'tcx> ParamEnv<'tcx> {\n             }\n         } else {\n             ParamEnvAnd {\n-                param_env: ParamEnv::empty(),\n+                param_env: ParamEnv::empty(self.reveal),\n                 value: value,\n             }\n         }\n@@ -2467,8 +2449,8 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n \n /// See `ParamEnv` struct def'n for details.\n fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   def_id: DefId)\n-                                   -> ParamEnv<'tcx> {\n+                       def_id: DefId)\n+                       -> ParamEnv<'tcx> {\n     // Compute the bounds on Self and the type parameters.\n \n     let bounds = tcx.predicates_of(def_id).instantiate_identity(tcx);\n@@ -2486,7 +2468,8 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // are any errors at that point, so after type checking you can be\n     // sure that this will succeed without errors anyway.\n \n-    let unnormalized_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates));\n+    let unnormalized_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n+                                             traits::Reveal::UserFacing);\n \n     let body_id = tcx.hir.as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n         tcx.hir.maybe_body_owned_by(id).map_or(id, |body| body.node_id)"}, {"sha": "1e2689243903e3a7c2f81f186d78ea4b2f09f0d9", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -466,6 +466,20 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::ParamEnv {\n+            reveal: self.reveal,\n+            caller_bounds: self.caller_bounds.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        let &ty::ParamEnv { reveal: _, ref caller_bounds } = self;\n+        caller_bounds.super_visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n@@ -771,6 +785,17 @@ impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::Predicate<'tcx>> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        folder.tcx().intern_predicates(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|p| p.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {"}, {"sha": "ec4ca54d6f5eddedb7c9f3ca1299d2bb269b7be5", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 77, "deletions": 38, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -12,7 +12,6 @@\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::map::DefPathData;\n-use infer::InferCtxt;\n use ich::{StableHashingContext, NodeIdHashingMode};\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -150,29 +149,42 @@ pub enum Representability {\n impl<'tcx> ty::ParamEnv<'tcx> {\n     /// Construct a trait environment suitable for contexts where\n     /// there are no where clauses in scope.\n-    pub fn empty() -> Self {\n-        Self::new(ty::Slice::empty())\n+    pub fn empty(reveal: Reveal) -> Self {\n+        Self::new(ty::Slice::empty(), reveal)\n     }\n \n     /// Construct a trait environment with the given set of predicates.\n-    pub fn new(caller_bounds: &'tcx ty::Slice<ty::Predicate<'tcx>>) -> Self {\n-        ty::ParamEnv { caller_bounds }\n+    pub fn new(caller_bounds: &'tcx ty::Slice<ty::Predicate<'tcx>>,\n+               reveal: Reveal)\n+               -> Self {\n+        ty::ParamEnv { caller_bounds, reveal }\n     }\n \n-    pub fn can_type_implement_copy<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    /// Returns a new parameter environment with the same clauses, but\n+    /// which \"reveals\" the true results of projections in all cases\n+    /// (even for associated types that are specializable).  This is\n+    /// the desired behavior during trans and certain other special\n+    /// contexts; normally though we want to use `Reveal::UserFacing`,\n+    /// which is the default.\n+    pub fn reveal_all(self) -> Self {\n+        ty::ParamEnv { reveal: Reveal::All, ..self }\n+    }\n+\n+    pub fn can_type_implement_copy<'a>(self,\n+                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        self_type: Ty<'tcx>, span: Span)\n-                                       -> Result<(), CopyImplementationError> {\n+                                       -> Result<(), CopyImplementationError<'tcx>> {\n         // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt(self.clone(), Reveal::UserFacing).enter(|infcx| {\n+        tcx.infer_ctxt(()).enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n                 ty::TyAdt(adt, substs) => (adt, substs),\n                 _ => return Err(CopyImplementationError::NotAnAdt),\n             };\n \n             let field_implements_copy = |field: &ty::FieldDef| {\n                 let cause = traits::ObligationCause::dummy();\n-                match traits::fully_normalize(&infcx, cause, &field.ty(tcx, substs)) {\n-                    Ok(ty) => !infcx.type_moves_by_default(ty, span),\n+                match traits::fully_normalize(&infcx, cause, self, &field.ty(tcx, substs)) {\n+                    Ok(ty) => !infcx.type_moves_by_default(self, ty, span),\n                     Err(..) => false,\n                 }\n             };\n@@ -779,32 +791,27 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         tcx.needs_drop_raw(param_env.and(self))\n     }\n \n+    /// Computes the layout of a type. Note that this implicitly\n+    /// executes in \"reveal all\" mode.\n     #[inline]\n-    pub fn layout<'lcx>(&'tcx self, infcx: &InferCtxt<'a, 'tcx, 'lcx>)\n+    pub fn layout<'lcx>(&'tcx self,\n+                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        param_env: ty::ParamEnv<'tcx>)\n                         -> Result<&'tcx Layout, LayoutError<'tcx>> {\n-        let tcx = infcx.tcx.global_tcx();\n-        let can_cache = !self.has_param_types() && !self.has_self_ty();\n-        if can_cache {\n-            if let Some(&cached) = tcx.layout_cache.borrow().get(&self) {\n-                return Ok(cached);\n-            }\n+        let ty = tcx.erase_regions(&self);\n+        let layout = tcx.layout_raw(param_env.reveal_all().and(ty));\n+\n+        // NB: This recording is normally disabled; when enabled, it\n+        // can however trigger recursive invocations of `layout()`.\n+        // Therefore, we execute it *after* the main query has\n+        // completed, to avoid problems around recursive structures\n+        // and the like. (Admitedly, I wasn't able to reproduce a problem\n+        // here, but it seems like the right thing to do. -nmatsakis)\n+        if let Ok(l) = layout {\n+            Layout::record_layout_for_printing(tcx, ty, param_env, l);\n         }\n \n-        let rec_limit = tcx.sess.recursion_limit.get();\n-        let depth = tcx.layout_depth.get();\n-        if depth > rec_limit {\n-            tcx.sess.fatal(\n-                &format!(\"overflow representing the type `{}`\", self));\n-        }\n-\n-        tcx.layout_depth.set(depth+1);\n-        let layout = Layout::compute_uncached(self, infcx);\n-        tcx.layout_depth.set(depth);\n-        let layout = layout?;\n-        if can_cache {\n-            tcx.layout_cache.borrow_mut().insert(self, layout);\n-        }\n-        Ok(layout)\n+        layout\n     }\n \n \n@@ -970,8 +977,12 @@ fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-    tcx.infer_ctxt(param_env, Reveal::UserFacing)\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx, ty, trait_def_id, DUMMY_SP))\n+    tcx.infer_ctxt(())\n+       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n+                                                       param_env,\n+                                                       ty,\n+                                                       trait_def_id,\n+                                                       DUMMY_SP))\n }\n \n fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -980,8 +991,12 @@ fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n-    tcx.infer_ctxt(param_env, Reveal::UserFacing)\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx, ty, trait_def_id, DUMMY_SP))\n+    tcx.infer_ctxt(())\n+       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n+                                                       param_env,\n+                                                       ty,\n+                                                       trait_def_id,\n+                                                       DUMMY_SP))\n }\n \n fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -990,8 +1005,12 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n-    tcx.infer_ctxt(param_env, Reveal::UserFacing)\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx, ty, trait_def_id, DUMMY_SP))\n+    tcx.infer_ctxt(())\n+       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n+                                                       param_env,\n+                                                       ty,\n+                                                       trait_def_id,\n+                                                       DUMMY_SP))\n }\n \n fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1062,13 +1081,33 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+                        -> Result<&'tcx Layout, LayoutError<'tcx>>\n+{\n+    let (param_env, ty) = query.into_parts();\n+\n+    let rec_limit = tcx.sess.recursion_limit.get();\n+    let depth = tcx.layout_depth.get();\n+    if depth > rec_limit {\n+        tcx.sess.fatal(\n+            &format!(\"overflow representing the type `{}`\", ty));\n+    }\n+\n+    tcx.layout_depth.set(depth+1);\n+    let layout = Layout::compute_uncached(tcx, param_env, ty);\n+    tcx.layout_depth.set(depth);\n+\n+    layout\n+}\n \n pub fn provide(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         is_copy_raw,\n         is_sized_raw,\n         is_freeze_raw,\n         needs_drop_raw,\n+        layout_raw,\n         ..*providers\n     };\n }"}, {"sha": "aa2c9802e54737bff9bf52eb372ee1740f704129", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -26,12 +26,14 @@ use middle::lang_items;\n /// make any progress at all. This is to prevent \"livelock\" where we\n /// say \"$0 is WF if $0 is WF\".\n pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                   param_env: ty::ParamEnv<'tcx>,\n                                    body_id: ast::NodeId,\n                                    ty: Ty<'tcx>,\n                                    span: Span)\n                                    -> Option<Vec<traits::PredicateObligation<'tcx>>>\n {\n     let mut wf = WfPredicates { infcx: infcx,\n+                                param_env: param_env,\n                                 body_id: body_id,\n                                 span: span,\n                                 out: vec![] };\n@@ -50,23 +52,25 @@ pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n /// if `Bar: Eq`.\n pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                         param_env: ty::ParamEnv<'tcx>,\n                                          body_id: ast::NodeId,\n                                          trait_ref: &ty::TraitRef<'tcx>,\n                                          span: Span)\n                                          -> Vec<traits::PredicateObligation<'tcx>>\n {\n-    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span, out: vec![] };\n+    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n     wf.compute_trait_ref(trait_ref);\n     wf.normalize()\n }\n \n pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             param_env: ty::ParamEnv<'tcx>,\n                                              body_id: ast::NodeId,\n                                              predicate: &ty::Predicate<'tcx>,\n                                              span: Span)\n                                              -> Vec<traits::PredicateObligation<'tcx>>\n {\n-    let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span, out: vec![] };\n+    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n \n     // (*) ok to skip binders, because wf code is prepared for it\n     match *predicate {\n@@ -126,6 +130,7 @@ pub enum ImpliedBound<'tcx> {\n /// the `ImpliedBound` type for more details.\n pub fn implied_bounds<'a, 'gcx, 'tcx>(\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body_id: ast::NodeId,\n     ty: Ty<'tcx>,\n     span: Span)\n@@ -148,7 +153,7 @@ pub fn implied_bounds<'a, 'gcx, 'tcx>(\n         // than the ultimate set. (Note: normally there won't be\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n-        let obligations = obligations(infcx, body_id, ty, span).unwrap_or(vec![]);\n+        let obligations = obligations(infcx, param_env, body_id, ty, span).unwrap_or(vec![]);\n \n         // From the full set of obligations, just filter down to the\n         // region relationships.\n@@ -231,6 +236,7 @@ fn implied_bounds_from_components<'tcx>(sub_region: ty::Region<'tcx>,\n \n struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     body_id: ast::NodeId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n@@ -244,11 +250,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn normalize(&mut self) -> Vec<traits::PredicateObligation<'tcx>> {\n         let cause = self.cause(traits::MiscObligation);\n         let infcx = &mut self.infcx;\n+        let param_env = self.param_env;\n         self.out.iter()\n                 .inspect(|pred| assert!(!pred.has_escaping_regions()))\n                 .flat_map(|pred| {\n                     let mut selcx = traits::SelectionContext::new(infcx);\n-                    let pred = traits::normalize(&mut selcx, cause.clone(), pred);\n+                    let pred = traits::normalize(&mut selcx, param_env, cause.clone(), pred);\n                     once(pred.value).chain(pred.obligations)\n                 })\n                 .collect()\n@@ -261,10 +268,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         self.out.extend(obligations);\n \n         let cause = self.cause(traits::MiscObligation);\n+        let param_env = self.param_env;\n         self.out.extend(\n             trait_ref.substs.types()\n                             .filter(|ty| !ty.has_escaping_regions())\n                             .map(|ty| traits::Obligation::new(cause.clone(),\n+                                                              param_env,\n                                                               ty::Predicate::WellFormed(ty))));\n     }\n \n@@ -280,7 +289,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         if !data.has_escaping_regions() {\n             let predicate = data.trait_ref.to_predicate();\n             let cause = self.cause(traits::ProjectionWf(data));\n-            self.out.push(traits::Obligation::new(cause, predicate));\n+            self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n     }\n \n@@ -291,7 +300,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n                 substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n             };\n-            self.out.push(traits::Obligation::new(cause, trait_ref.to_predicate()));\n+            self.out.push(traits::Obligation::new(cause, self.param_env, trait_ref.to_predicate()));\n         }\n     }\n \n@@ -301,6 +310,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     /// in which case we are not able to simplify at all.\n     fn compute(&mut self, ty0: Ty<'tcx>) -> bool {\n         let mut subtys = ty0.walk();\n+        let param_env = self.param_env;\n         while let Some(ty) = subtys.next() {\n             match ty.sty {\n                 ty::TyBool |\n@@ -350,6 +360,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                         self.out.push(\n                             traits::Obligation::new(\n                                 cause,\n+                                param_env,\n                                 ty::Predicate::TypeOutlives(\n                                     ty::Binder(\n                                         ty::OutlivesPredicate(mt.ty, r)))));\n@@ -389,12 +400,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // checking those\n \n                     let cause = self.cause(traits::MiscObligation);\n-\n                     let component_traits =\n                         data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n                     self.out.extend(\n                         component_traits.map(|did| traits::Obligation::new(\n                             cause.clone(),\n+                            param_env,\n                             ty::Predicate::ObjectSafe(did)\n                         ))\n                     );\n@@ -422,7 +433,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n                         let cause = self.cause(traits::MiscObligation);\n                         self.out.push( // ...not the type we started from, so we made progress.\n-                            traits::Obligation::new(cause, ty::Predicate::WellFormed(ty)));\n+                            traits::Obligation::new(cause,\n+                                                    self.param_env,\n+                                                    ty::Predicate::WellFormed(ty)));\n                     } else {\n                         // Yes, resolved, proceed with the\n                         // result. Should never return false because\n@@ -448,7 +461,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         let cause = self.cause(traits::ItemObligation(def_id));\n         predicates.predicates\n                   .into_iter()\n-                  .map(|pred| traits::Obligation::new(cause.clone(), pred))\n+                  .map(|pred| traits::Obligation::new(cause.clone(),\n+                                                      self.param_env,\n+                                                      pred))\n                   .filter(|pred| !pred.has_escaping_regions())\n                   .collect()\n     }\n@@ -497,7 +512,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n             for implicit_bound in implicit_bounds {\n                 let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n                 let outlives = ty::Binder(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n-                self.out.push(traits::Obligation::new(cause, outlives.to_predicate()));\n+                self.out.push(traits::Obligation::new(cause,\n+                                                      self.param_env,\n+                                                      outlives.to_predicate()));\n             }\n         }\n     }"}, {"sha": "122a37ee32aeab1b9c3ed0db03770170ac498a5e", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -90,7 +90,7 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n     move_data: &'a move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n-    param_env: &'a ty::ParamEnv<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n@@ -191,15 +191,17 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      body: &hir::Body) {\n     debug!(\"check_loans(body id={})\", body.value.id);\n \n+    let def_id = bccx.tcx.hir.body_owner_def_id(body.id());\n     let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body.id());\n+    let param_env = bccx.tcx.param_env(def_id);\n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n         dfcx_loans: dfcx_loans,\n         move_data: move_data,\n         all_loans: all_loans,\n-        param_env: &infcx.param_env\n+        param_env,\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, &bccx.region_maps, &infcx).consume_body(body);\n+    euv::ExprUseVisitor::new(&mut clcx, &bccx.region_maps, &infcx, param_env).consume_body(body);\n }\n \n #[derive(PartialEq)]"}, {"sha": "85a09969ac81c68cd950cd15ac9de31566b3bd11", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -38,9 +38,10 @@ mod move_error;\n \n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     body: hir::BodyId)\n-                                    -> (Vec<Loan<'tcx>>,\n-                                        move_data::MoveData<'tcx>) {\n+                                    -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>) {\n+    let def_id = bccx.tcx.hir.body_owner_def_id(body);\n     let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body);\n+    let param_env = bccx.tcx.param_env(def_id);\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         infcx: &infcx,\n@@ -51,7 +52,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let body = glcx.bccx.tcx.hir.body(body);\n-    euv::ExprUseVisitor::new(&mut glcx, &bccx.region_maps, &infcx).consume_body(body);\n+    euv::ExprUseVisitor::new(&mut glcx, &bccx.region_maps, &infcx, param_env).consume_body(body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;"}, {"sha": "539f1ff3730ee3a162281e67fcb467d3e08d1278", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                      lp: &LoanPath<'tcx>,\n                                      the_move: &move_data::Move,\n                                      moved_lp: &LoanPath<'tcx>,\n-                                     _param_env: &ty::ParamEnv<'tcx>) {\n+                                     _param_env: ty::ParamEnv<'tcx>) {\n         let (verb, verb_participle) = match use_kind {\n             MovedInUse => (\"use\", \"used\"),\n             MovedInCapture => (\"capture\", \"captured\"),"}, {"sha": "dd26a3e611f8809545a9b938d061401a0a4a794d", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -20,7 +20,6 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::middle::region::RegionMaps;\n use rustc::session::Session;\n-use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::lint;\n use rustc_errors::{Diagnostic, Level, DiagnosticBuilder};\n@@ -518,11 +517,11 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n ///\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n-    cx.tcx.infer_ctxt((cx.tables, cx.param_env), Reveal::UserFacing).enter(|infcx| {\n+    cx.tcx.infer_ctxt(cx.tables).enter(|infcx| {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };\n-        ExprUseVisitor::new(&mut checker, cx.region_maps, &infcx).walk_expr(guard);\n+        ExprUseVisitor::new(&mut checker, cx.region_maps, &infcx, cx.param_env).walk_expr(guard);\n     });\n }\n "}, {"sha": "3d07ffc2bc77aefda074e589a1267e478de2b3c7", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -483,9 +483,11 @@ fn resolve_trait_associated_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n-    tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n+        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                                 param_env,\n                                                  trait_ref.to_poly_trait_predicate());\n         let selection = match selcx.select(&obligation) {\n             Ok(Some(vtable)) => vtable,"}, {"sha": "2b74d0a812b4a90f8fcf11558054e3e88c5a8cee", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -46,6 +46,7 @@ use rustc::hir;\n struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n     region_maps: &'a mut RegionMaps,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n struct RH<'a> {\n@@ -153,9 +154,13 @@ fn test_env<F>(source_string: &str,\n                              index,\n                              \"test_crate\",\n                              |tcx| {\n-        tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+        tcx.infer_ctxt(()).enter(|infcx| {\n             let mut region_maps = RegionMaps::new();\n-            body(Env { infcx: &infcx, region_maps: &mut region_maps });\n+            body(Env {\n+                infcx: &infcx,\n+                region_maps: &mut region_maps,\n+                param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n+            });\n             let free_regions = FreeRegionMap::new();\n             let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n             infcx.resolve_regions_and_report_errors(def_id, &region_maps, &free_regions);\n@@ -250,14 +255,14 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match self.infcx.sub_types(true, &ObligationCause::dummy(), a, b) {\n+        match self.infcx.at(&ObligationCause::dummy(), self.param_env).sub(a, b) {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\", e),\n         }\n     }\n \n     pub fn is_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        self.infcx.can_sub_types(a, b).is_ok()\n+        self.infcx.can_sub(self.param_env, a, b).is_ok()\n     }\n \n     pub fn assert_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n@@ -354,30 +359,23 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n                                   self.tcx().types.isize)\n     }\n \n-    pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n-        infer::TypeTrace::dummy(self.tcx())\n-    }\n-\n-    pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n-        let trace = self.dummy_type_trace();\n-        self.infcx.sub(true, trace, &t1, &t2)\n+    pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, ()> {\n+        self.infcx.at(&ObligationCause::dummy(), self.param_env).sub(t1, t2)\n     }\n \n     pub fn lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n-        let trace = self.dummy_type_trace();\n-        self.infcx.lub(true, trace, &t1, &t2)\n+        self.infcx.at(&ObligationCause::dummy(), self.param_env).lub(t1, t2)\n     }\n \n     pub fn glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n-        let trace = self.dummy_type_trace();\n-        self.infcx.glb(true, trace, &t1, &t2)\n+        self.infcx.at(&ObligationCause::dummy(), self.param_env).glb(t1, t2)\n     }\n \n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n         match self.sub(t1, t2) {\n-            Ok(InferOk { obligations, .. }) => {\n+            Ok(InferOk { obligations, value: () }) => {\n                 // None of these tests should require nested obligations:\n                 assert!(obligations.is_empty());\n             }"}, {"sha": "3a4729e64548a732d74aa73f5be1d9c138ea598c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -488,7 +488,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n         if def.has_dtor(cx.tcx) {\n             return;\n         }\n-        let param_env = ty::ParamEnv::empty();\n+        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         if !ty.moves_by_default(cx.tcx, param_env, item.span) {\n             return;\n         }\n@@ -951,12 +951,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     let trait_ref = ty::TraitRef::from_method(tcx, trait_def_id, callee_substs);\n                     let trait_ref = ty::Binder(trait_ref);\n                     let span = tcx.hir.span(expr_id);\n+                    let param_env = tcx.param_env(method.def_id);\n                     let obligation =\n                         traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n+                                                param_env,\n                                                 trait_ref.to_poly_trait_predicate());\n \n-                    let param_env = tcx.param_env(method.def_id);\n-                    tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n+                    tcx.infer_ctxt(()).enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n                             // The method comes from a `T: Trait` bound."}, {"sha": "3019165bfbf9a9343b424a861e485d8b481f6ad7", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -14,7 +14,6 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{Layout, Primitive};\n-use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n use rustc_const_eval::ConstContext;\n use util::nodemap::FxHashSet;\n@@ -724,12 +723,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n-                let t = cx.tcx.type_of(cx.tcx.hir.local_def_id(it.id));\n-                let layout = cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-                    let ty = cx.tcx.erase_regions(&t);\n-                    ty.layout(&infcx).unwrap_or_else(|e| {\n-                        bug!(\"failed to get layout for `{}`: {}\", t, e)\n-                    })\n+                let item_def_id = cx.tcx.hir.local_def_id(it.id);\n+                let t = cx.tcx.type_of(item_def_id);\n+                let param_env = cx.tcx.param_env(item_def_id).reveal_all();\n+                let ty = cx.tcx.erase_regions(&t);\n+                let layout = ty.layout(cx.tcx, param_env).unwrap_or_else(|e| {\n+                    bug!(\"failed to get layout for `{}`: {}\", t, e)\n                 });\n \n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {"}, {"sha": "08a5cb37e5788a4b545fac5048e77444c0349e7c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -18,7 +18,6 @@ use rustc::middle::region::CodeExtent;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n-use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n@@ -84,7 +83,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n     };\n \n     let src = MirSource::from_node(tcx, id);\n-    tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n+    tcx.infer_ctxt(body_id).enter(|infcx| {\n         let cx = Cx::new(&infcx, src);\n         let mut mir = if cx.tables().tainted_by_errors {\n             build::construct_error(cx, body_id)\n@@ -172,8 +171,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let span = tcx.hir.span(ctor_id);\n     if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        let pe = tcx.param_env(tcx.hir.local_def_id(ctor_id));\n-        tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n+        tcx.infer_ctxt(()).enter(|infcx| {\n             let (mut mir, src) =\n                 shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n "}, {"sha": "5b7b52a72b0ab4c625c19b24d863def31b7c2b73", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -35,6 +35,7 @@ use std::rc::Rc;\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n     pub region_maps: Rc<RegionMaps>,\n \n     /// This is `Constness::Const` if we are compiling a `static`,\n@@ -64,6 +65,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let src_id = src.item_id();\n         let src_def_id = tcx.hir.local_def_id(src_id);\n \n+        let param_env = tcx.param_env(src_def_id);\n         let region_maps = tcx.region_maps(src_def_id);\n \n         let attrs = tcx.hir.attrs(src_id);\n@@ -80,7 +82,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n \n-        Cx { tcx, infcx, region_maps, constness, src, check_overflow }\n+        Cx { tcx, infcx, param_env, region_maps, constness, src, check_overflow }\n     }\n }\n \n@@ -169,12 +171,12 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n-        let ty = self.tcx.lift_to_global(&ty).unwrap_or_else(|| {\n-            bug!(\"MIR: Cx::needs_drop({}) got \\\n+        let (ty, param_env) = self.tcx.lift_to_global(&(ty, self.param_env)).unwrap_or_else(|| {\n+            bug!(\"MIR: Cx::needs_drop({:?}, {:?}) got \\\n                   type with inference types/regions\",\n-                 ty);\n+                 ty, self.param_env);\n         });\n-        ty.needs_drop(self.tcx.global_tcx(), self.infcx.param_env)\n+        ty.needs_drop(self.tcx.global_tcx(), param_env)\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "0ac35a5fdd4722bd625317bfba4afe3e03643731", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -18,7 +18,6 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::*;\n-use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Subst,Substs};\n \n@@ -545,12 +544,11 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n     }\n }\n \n-fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, param_env: ty::ParamEnv<'tcx>,\n+fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>) -> Option<u64> {\n-    tcx.infer_ctxt(param_env, traits::Reveal::All).enter(|infcx| {\n-        ty.layout(&infcx).ok().map(|layout| {\n-            layout.size(&tcx.data_layout).bytes()\n-        })\n+    ty.layout(tcx, param_env).ok().map(|layout| {\n+        layout.size(&tcx.data_layout).bytes()\n     })\n }\n "}, {"sha": "ef88e813a50c60bf54691ab28010fe720bbb7f20", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -998,10 +998,13 @@ impl MirPass for QualifyAndPromoteConstants {\n         // Statics must be Sync.\n         if mode == Mode::Static {\n             let ty = mir.return_ty;\n-            tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+            tcx.infer_ctxt(()).enter(|infcx| {\n+                let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                fulfillment_cx.register_bound(&infcx, ty,\n+                fulfillment_cx.register_bound(&infcx,\n+                                              param_env,\n+                                              ty,\n                                               tcx.require_lang_item(lang_items::SyncTraitLangItem),\n                                               cause);\n                 if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {"}, {"sha": "da8e3b5a42ba9e5dac82cb9e4ae59ac16be42e7b", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -12,7 +12,7 @@\n #![allow(unreachable_code)]\n \n use rustc::infer::{self, InferCtxt, InferOk};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt, TypeVariants};\n use rustc::middle::const_val::ConstVal;\n@@ -320,19 +320,24 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'gcx>,\n     fulfillment_cx: traits::FulfillmentContext<'tcx>,\n     last_span: Span,\n     body_id: ast::NodeId,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, body_id: ast::NodeId) -> Self {\n+    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+           body_id: ast::NodeId,\n+           param_env: ty::ParamEnv<'gcx>)\n+           -> Self {\n         TypeChecker {\n             infcx: infcx,\n             fulfillment_cx: traits::FulfillmentContext::new(),\n             last_span: DUMMY_SP,\n-            body_id: body_id,\n+            body_id,\n+            param_env,\n             reported_errors: FxHashSet(),\n         }\n     }\n@@ -348,18 +353,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         infer_ok.value\n     }\n \n-    fn sub_types(&mut self, sup: Ty<'tcx>, sub: Ty<'tcx>)\n+    fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>)\n                  -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.sub_types(false, &self.misc(self.last_span), sup, sub)\n-            .map(|ok| self.register_infer_ok_obligations(ok))\n+        self.infcx.at(&self.misc(self.last_span), self.param_env)\n+                  .sup(sup, sub)\n+                  .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n     fn eq_types(&mut self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n-        self.infcx.eq_types(false, &self.misc(span), a, b)\n-            .map(|ok| self.register_infer_ok_obligations(ok))\n+        self.infcx.at(&self.misc(span), self.param_env)\n+                  .eq(b, a)\n+                  .map(|ok| self.register_infer_ok_obligations(ok))\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -665,7 +672,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         let span = local_decl.source_info.span;\n         let ty = local_decl.ty;\n-        if !ty.is_sized(self.tcx().global_tcx(), self.infcx.param_env(), span) {\n+        if !ty.is_sized(self.tcx().global_tcx(), self.param_env, span) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough\n@@ -706,7 +713,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let mut selcx = traits::SelectionContext::new(self.infcx);\n         let cause = traits::ObligationCause::misc(self.last_span, ast::CRATE_NODE_ID);\n         let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, cause, value);\n+            traits::normalize(&mut selcx, self.param_env, cause, value);\n \n         debug!(\"normalize: value={:?} obligations={:?}\",\n                value,\n@@ -752,8 +759,8 @@ impl MirPass for TypeckMir {\n             return;\n         }\n         let param_env = tcx.param_env(def_id);\n-        tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n-            let mut checker = TypeChecker::new(&infcx, item_id);\n+        tcx.infer_ctxt(()).enter(|infcx| {\n+            let mut checker = TypeChecker::new(&infcx, item_id, param_env);\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);\n                 verifier.visit_mir(mir);"}, {"sha": "65a9334bbae19512dbf8892ee2df3da9673274a7", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -138,11 +138,11 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             self.check_const_eval(&body.value);\n         }\n \n-        let outer_penv = self.tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n-            let param_env = infcx.param_env.clone();\n+        let outer_penv = self.tcx.infer_ctxt(body_id).enter(|infcx| {\n+            let param_env = self.tcx.param_env(item_def_id);\n             let outer_penv = mem::replace(&mut self.param_env, param_env);\n             let region_maps = &self.tcx.region_maps(item_def_id);\n-            euv::ExprUseVisitor::new(self, region_maps, &infcx).consume_body(body);\n+            euv::ExprUseVisitor::new(self, region_maps, &infcx, param_env).consume_body(body);\n             outer_penv\n         });\n \n@@ -468,7 +468,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         in_fn: false,\n         promotable: false,\n         mut_rvalue_borrows: NodeSet(),\n-        param_env: ty::ParamEnv::empty(),\n+        param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n     }.as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "88c30cd86659920184abaa67789e2f1a9283669e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 193, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -44,7 +44,7 @@ use rustc::middle::cstore::LinkMeta;\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use rustc::session::config::{self, NoDebugInfo};\n-use rustc::session::{self, DataTypeKind, Session};\n+use rustc::session::Session;\n use rustc_incremental::IncrementalHashesMap;\n use abi;\n use mir::lvalue::LvalueRef;\n@@ -80,7 +80,6 @@ use std::i32;\n use syntax_pos::Span;\n use syntax::attr;\n use rustc::hir;\n-use rustc::ty::layout::{self, Layout};\n use syntax::ast;\n \n use mir::lvalue::Alignment;\n@@ -1287,10 +1286,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             &exported_symbols);\n     });\n \n-    if tcx.sess.opts.debugging_opts.print_type_sizes {\n-        gather_type_sizes(tcx);\n-    }\n-\n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n         create_imps(sess, &llvm_modules);\n@@ -1322,193 +1317,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let layout_cache = tcx.layout_cache.borrow();\n-    for (ty, layout) in layout_cache.iter() {\n-\n-        // (delay format until we actually need it)\n-        let record = |kind, opt_discr_size, variants| {\n-            let type_desc = format!(\"{:?}\", ty);\n-            let overall_size = layout.size(tcx);\n-            let align = layout.align(tcx);\n-            tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n-                                                              type_desc,\n-                                                              align,\n-                                                              overall_size,\n-                                                              opt_discr_size,\n-                                                              variants);\n-        };\n-\n-        let (adt_def, substs) = match ty.sty {\n-            ty::TyAdt(ref adt_def, substs) => {\n-                debug!(\"print-type-size t: `{:?}` process adt\", ty);\n-                (adt_def, substs)\n-            }\n-\n-            ty::TyClosure(..) => {\n-                debug!(\"print-type-size t: `{:?}` record closure\", ty);\n-                record(DataTypeKind::Closure, None, vec![]);\n-                continue;\n-            }\n-\n-            _ => {\n-                debug!(\"print-type-size t: `{:?}` skip non-nominal\", ty);\n-                continue;\n-            }\n-        };\n-\n-        let adt_kind = adt_def.adt_kind();\n-\n-        let build_field_info = |(field_name, field_ty): (ast::Name, Ty), offset: &layout::Size| {\n-            match layout_cache.get(&field_ty) {\n-                None => bug!(\"no layout found for field {} type: `{:?}`\", field_name, field_ty),\n-                Some(field_layout) => {\n-                    session::FieldInfo {\n-                        name: field_name.to_string(),\n-                        offset: offset.bytes(),\n-                        size: field_layout.size(tcx).bytes(),\n-                        align: field_layout.align(tcx).abi(),\n-                    }\n-                }\n-            }\n-        };\n-\n-        let build_primitive_info = |name: ast::Name, value: &layout::Primitive| {\n-            session::VariantInfo {\n-                name: Some(name.to_string()),\n-                kind: session::SizeKind::Exact,\n-                align: value.align(tcx).abi(),\n-                size: value.size(tcx).bytes(),\n-                fields: vec![],\n-            }\n-        };\n-\n-        enum Fields<'a> {\n-            WithDiscrim(&'a layout::Struct),\n-            NoDiscrim(&'a layout::Struct),\n-        }\n-\n-        let build_variant_info = |n: Option<ast::Name>, flds: &[(ast::Name, Ty)], layout: Fields| {\n-            let (s, field_offsets) = match layout {\n-                Fields::WithDiscrim(s) => (s, &s.offsets[1..]),\n-                Fields::NoDiscrim(s) => (s, &s.offsets[0..]),\n-            };\n-            let field_info: Vec<_> = flds.iter()\n-                .zip(field_offsets.iter())\n-                .map(|(&field_name_ty, offset)| build_field_info(field_name_ty, offset))\n-                .collect();\n-\n-            session::VariantInfo {\n-                name: n.map(|n|n.to_string()),\n-                kind: if s.sized {\n-                    session::SizeKind::Exact\n-                } else {\n-                    session::SizeKind::Min\n-                },\n-                align: s.align.abi(),\n-                size: s.min_size.bytes(),\n-                fields: field_info,\n-            }\n-        };\n-\n-        match **layout {\n-            Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n-                                                   nndiscr,\n-                                                   discrfield: _,\n-                                                   discrfield_source: _ } => {\n-                debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n-                       ty, nndiscr, variant_layout);\n-                let variant_def = &adt_def.variants[nndiscr as usize];\n-                let fields: Vec<_> = variant_def.fields.iter()\n-                    .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n-                    .collect();\n-                record(adt_kind.into(),\n-                       None,\n-                       vec![build_variant_info(Some(variant_def.name),\n-                                               &fields,\n-                                               Fields::NoDiscrim(variant_layout))]);\n-            }\n-            Layout::RawNullablePointer { nndiscr, value } => {\n-                debug!(\"print-type-size t: `{:?}` adt raw nullable nndiscr {} is {:?}\",\n-                       ty, nndiscr, value);\n-                let variant_def = &adt_def.variants[nndiscr as usize];\n-                record(adt_kind.into(), None,\n-                       vec![build_primitive_info(variant_def.name, &value)]);\n-            }\n-            Layout::Univariant { variant: ref variant_layout, non_zero: _ } => {\n-                let variant_names = || {\n-                    adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n-                };\n-                debug!(\"print-type-size t: `{:?}` adt univariant {:?} variants: {:?}\",\n-                       ty, variant_layout, variant_names());\n-                assert!(adt_def.variants.len() <= 1,\n-                        \"univariant with variants {:?}\", variant_names());\n-                if adt_def.variants.len() == 1 {\n-                    let variant_def = &adt_def.variants[0];\n-                    let fields: Vec<_> = variant_def.fields.iter()\n-                        .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n-                        .collect();\n-                    record(adt_kind.into(),\n-                           None,\n-                           vec![build_variant_info(Some(variant_def.name),\n-                                                   &fields,\n-                                                   Fields::NoDiscrim(variant_layout))]);\n-                } else {\n-                    // (This case arises for *empty* enums; so give it\n-                    // zero variants.)\n-                    record(adt_kind.into(), None, vec![]);\n-                }\n-            }\n-\n-            Layout::General { ref variants, discr, .. } => {\n-                debug!(\"print-type-size t: `{:?}` adt general variants def {} layouts {} {:?}\",\n-                       ty, adt_def.variants.len(), variants.len(), variants);\n-                let variant_infos: Vec<_> = adt_def.variants.iter()\n-                    .zip(variants.iter())\n-                    .map(|(variant_def, variant_layout)| {\n-                        let fields: Vec<_> = variant_def.fields.iter()\n-                            .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n-                            .collect();\n-                        build_variant_info(Some(variant_def.name),\n-                                           &fields,\n-                                           Fields::WithDiscrim(variant_layout))\n-                    })\n-                    .collect();\n-                record(adt_kind.into(), Some(discr.size()), variant_infos);\n-            }\n-\n-            Layout::UntaggedUnion { ref variants } => {\n-                debug!(\"print-type-size t: `{:?}` adt union variants {:?}\",\n-                       ty, variants);\n-                // layout does not currently store info about each\n-                // variant...\n-                record(adt_kind.into(), None, Vec::new());\n-            }\n-\n-            Layout::CEnum { discr, .. } => {\n-                debug!(\"print-type-size t: `{:?}` adt c-like enum\", ty);\n-                let variant_infos: Vec<_> = adt_def.variants.iter()\n-                    .map(|variant_def| {\n-                        build_primitive_info(variant_def.name,\n-                                             &layout::Primitive::Int(discr))\n-                    })\n-                    .collect();\n-                record(adt_kind.into(), Some(discr.size()), variant_infos);\n-            }\n-\n-            // other cases provide little interesting (i.e. adjustable\n-            // via representation tweaks) size info beyond total size.\n-            Layout::Scalar { .. } |\n-            Layout::Vector { .. } |\n-            Layout::Array { .. } |\n-            Layout::FatPointer { .. } => {\n-                debug!(\"print-type-size t: `{:?}` adt other\", ty);\n-                record(adt_kind.into(), None, Vec::new())\n-            }\n-        }\n-    }\n-}\n-\n #[inline(never)] // give this a place in the profiler\n fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_items: I)\n     where I: Iterator<Item=&'a TransItem<'tcx>>"}, {"sha": "6266452419ed9b035a32ab66603f8e5a118c2ccd", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -23,11 +23,11 @@ use monomorphize::Instance;\n use partitioning::CodegenUnit;\n use type_::Type;\n use rustc_data_structures::base_n;\n-use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{LayoutTyper, TyLayout};\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::{LayoutCx, LayoutError, LayoutTyper, TyLayout};\n use rustc::util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use std::ffi::{CStr, CString};\n@@ -320,15 +320,15 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     }\n \n     pub fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        ty.needs_drop(self.tcx, ty::ParamEnv::empty())\n+        ty.needs_drop(self.tcx, ty::ParamEnv::empty(traits::Reveal::All))\n     }\n \n     pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, ty::ParamEnv::empty(), DUMMY_SP)\n+        ty.is_sized(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n     }\n \n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx, ty::ParamEnv::empty(), DUMMY_SP)\n+        ty.is_freeze(self.tcx, ty::ParamEnv::empty(traits::Reveal::All), DUMMY_SP)\n     }\n \n     pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n@@ -709,41 +709,27 @@ impl<'a, 'tcx> ty::layout::HasDataLayout for &'a SharedCrateContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-}\n-\n impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CrateContext<'a, 'tcx> {\n     fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n         &self.shared.tcx.data_layout\n     }\n }\n \n-impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CrateContext<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n-        self.shared.tcx\n-    }\n-}\n-\n impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n-    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        if let Some(&layout) = self.tcx().layout_cache.borrow().get(&ty) {\n-            return TyLayout { ty: ty, layout: layout, variant_index: None };\n-        }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n \n-        self.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n-            infcx.layout_of(ty).unwrap_or_else(|e| {\n-                match e {\n-                    ty::layout::LayoutError::SizeOverflow(_) =>\n-                        self.sess().fatal(&e.to_string()),\n-                    _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n+        LayoutCx::new(self.tcx, param_env)\n+            .layout_of(ty)\n+            .unwrap_or_else(|e| match e {\n+                LayoutError::SizeOverflow(_) => self.sess().fatal(&e.to_string()),\n+                _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n             })\n-        })\n     }\n \n     fn normalize_projections(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -754,6 +740,10 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n     type TyLayout = TyLayout<'tcx>;\n \n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.shared.tcx\n+    }\n+\n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.shared.layout_of(ty)\n     }"}, {"sha": "367f0398fa838848a1a1902a5a2131f4d6f8f868", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -46,15 +46,13 @@ pub fn needs_drop_glue<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'tcx>\n         ty::TyAdt(def, _) if def.is_box() => {\n             let typ = t.boxed_ty();\n             if !scx.type_needs_drop(typ) && scx.type_is_sized(typ) {\n-                scx.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n-                    let layout = t.layout(&infcx).unwrap();\n-                    if layout.size(scx).bytes() == 0 {\n-                        // `Box<ZeroSizeType>` does not allocate.\n-                        false\n-                    } else {\n-                        true\n-                    }\n-                })\n+                let layout = t.layout(scx.tcx(), ty::ParamEnv::empty(traits::Reveal::All)).unwrap();\n+                if layout.size(scx).bytes() == 0 {\n+                    // `Box<ZeroSizeType>` does not allocate.\n+                    false\n+                } else {\n+                    true\n+                }\n             } else {\n                 true\n             }"}, {"sha": "6aac9dc42ee02bda67e747fb6738600259fc4116", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -118,13 +118,16 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n         let mut selcx = traits::SelectionContext::new(self.fcx);\n-        let obligation = traits::Obligation::new(cause.clone(), trait_ref.to_predicate());\n+        let obligation = traits::Obligation::new(cause.clone(),\n+                                                 self.fcx.param_env,\n+                                                 trait_ref.to_predicate());\n         if !selcx.evaluate_obligation(&obligation) {\n             debug!(\"overloaded_deref_ty: cannot match obligation\");\n             return None;\n         }\n \n         let normalized = traits::normalize_projection_type(&mut selcx,\n+                                                           self.fcx.param_env,\n                                                            ty::ProjectionTy::from_ref_and_name(\n                                                                tcx,\n                                                                trait_ref,"}, {"sha": "91aeade65aa4c2b57a5ffd1f7d263845c769cc69", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -555,6 +555,6 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn type_is_known_to_be_sized(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n-        traits::type_known_to_meet_bound(self, ty, lang_item, span)\n+        traits::type_known_to_meet_bound(self, self.param_env, ty, lang_item, span)\n     }\n }"}, {"sha": "f041db43e16d757c1e80bddceea92e1cba623fbb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -81,9 +81,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let fn_sig = self.liberate_late_bound_regions(expr_def_id, &sig);\n         let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n-                                                            body.value.id, &fn_sig);\n+                                                            body.value.id,\n+                                                            self.param_env,\n+                                                            &fn_sig);\n \n-        check_fn(self, fn_sig, decl, expr.id, body);\n+        check_fn(self, self.param_env, fn_sig, decl, expr.id, body);\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table."}, {"sha": "30ac7b4bfb9be8d14a4c069e48c6b81184598324", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -64,7 +64,7 @@ use check::{Diverges, FnCtxt};\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::{Coercion, InferResult, InferOk, TypeTrace};\n+use rustc::infer::{Coercion, InferResult, InferOk};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n@@ -135,11 +135,13 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n-            let trace = TypeTrace::types(&self.cause, false, a, b);\n             if self.use_lub {\n-                self.lub(false, trace, &a, &b)\n+                self.at(&self.cause, self.fcx.param_env)\n+                    .lub(b, a)\n             } else {\n-                self.sub(false, trace, &a, &b)\n+                self.at(&self.cause, self.fcx.param_env)\n+                    .sup(b, a)\n+                    .map(|InferOk { value: (), obligations }| InferOk { value: a, obligations })\n             }\n         })\n     }\n@@ -511,9 +513,12 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n         let cause = ObligationCause::misc(self.cause.span, self.body_id);\n-        queue.push_back(self.tcx\n-            .predicate_for_trait_def(cause, coerce_unsized_did, 0,\n-                                     coerce_source, &[coerce_target]));\n+        queue.push_back(self.tcx.predicate_for_trait_def(self.fcx.param_env,\n+                                                         cause,\n+                                                         coerce_unsized_did,\n+                                                         0,\n+                                                         coerce_source,\n+                                                         &[coerce_target]));\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n@@ -768,20 +773,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return Ok(prev_ty);\n         }\n \n-        let trace = TypeTrace::types(cause, true, prev_ty, new_ty);\n-\n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n         match (&prev_ty.sty, &new_ty.sty) {\n             (&ty::TyFnDef(a_def_id, a_substs, a_fty), &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n                 // The signature must always match.\n-                let fty = self.lub(true, trace.clone(), &a_fty, &b_fty)\n+                let fty = self.at(cause, self.param_env)\n+                              .trace(prev_ty, new_ty)\n+                              .lub(&a_fty, &b_fty)\n                               .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n                 if a_def_id == b_def_id {\n                     // Same function, maybe the parameters match.\n                     let substs = self.commit_if_ok(|_| {\n-                        self.lub(true, trace.clone(), &a_substs, &b_substs)\n+                        self.at(cause, self.param_env)\n+                            .trace(prev_ty, new_ty)\n+                            .lub(&a_substs, &b_substs)\n                             .map(|ok| self.register_infer_ok_obligations(ok))\n                     });\n \n@@ -850,7 +857,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if !noop {\n                 return self.commit_if_ok(|_| {\n-                    self.lub(true, trace.clone(), &prev_ty, &new_ty)\n+                    self.at(cause, self.param_env)\n+                        .lub(prev_ty, new_ty)\n                         .map(|ok| self.register_infer_ok_obligations(ok))\n                 });\n             }\n@@ -863,7 +871,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Err(e)\n                 } else {\n                     self.commit_if_ok(|_| {\n-                        self.lub(true, trace, &prev_ty, &new_ty)\n+                        self.at(cause, self.param_env)\n+                            .lub(prev_ty, new_ty)\n                             .map(|ok| self.register_infer_ok_obligations(ok))\n                     })\n                 }\n@@ -1106,7 +1115,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n             // Another example is `break` with no argument expression.\n             assert!(expression_ty.is_nil());\n             assert!(expression_ty.is_nil(), \"if let hack without unit type\");\n-            fcx.eq_types(label_expression_as_expected, cause, expression_ty, self.merged_ty())\n+            fcx.at(cause, fcx.param_env)\n+               .eq_exp(label_expression_as_expected, expression_ty, self.merged_ty())\n                .map(|infer_ok| {\n                    fcx.register_infer_ok_obligations(infer_ok);\n                    expression_ty"}, {"sha": "7633be24477c65b48a73f8b0c30b95855d16c5c4", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -212,18 +212,19 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n     let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n-    let param_env = ty::ParamEnv::new(tcx.intern_predicates(&hybrid_preds.predicates));\n+    let param_env = ty::ParamEnv::new(tcx.intern_predicates(&hybrid_preds.predicates),\n+                                      Reveal::UserFacing);\n     let param_env = traits::normalize_param_env_or_error(tcx,\n                                                          impl_m.def_id,\n                                                          param_env,\n                                                          normalize_cause.clone());\n \n-    tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n         let inh = Inherited::new(infcx, impl_m.def_id);\n         let infcx = &inh.infcx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\",\n-               infcx.param_env.caller_bounds);\n+               param_env.caller_bounds);\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n@@ -233,10 +234,10 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                        &ty::Binder(impl_m_own_bounds.predicates));\n         for predicate in impl_m_own_bounds {\n             let traits::Normalized { value: predicate, obligations } =\n-                traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n+                traits::normalize(&mut selcx, param_env, normalize_cause.clone(), &predicate);\n \n             inh.register_predicates(obligations);\n-            inh.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n+            inh.register_predicate(traits::Obligation::new(cause.clone(), param_env, predicate));\n         }\n \n         // We now need to check that the signature of the impl method is\n@@ -269,6 +270,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n                                               impl_m_node_id,\n+                                              param_env,\n                                               &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n@@ -281,12 +283,14 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let trait_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n                                               impl_m_node_id,\n+                                              param_env,\n                                               &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder(trait_sig));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n-        let sub_result = infcx.sub_types(false, &cause, impl_fty, trait_fty)\n+        let sub_result = infcx.at(&cause, param_env)\n+                              .sup(trait_fty, impl_fty)\n                               .map(|InferOk { obligations, .. }| {\n                                   inh.register_predicates(obligations);\n                               });\n@@ -297,6 +301,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    trait_fty);\n \n             let (impl_err_span, trait_err_span) = extract_spans_for_error_reporting(&infcx,\n+                                                                                    param_env,\n                                                                                     &terr,\n                                                                                     &cause,\n                                                                                     impl_m,\n@@ -344,11 +349,10 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // pass around temporarily.\n             let region_maps = RegionMaps::new();\n             let mut free_regions = FreeRegionMap::new();\n-            free_regions.relate_free_regions_from_predicates(\n-                &infcx.param_env.caller_bounds);\n+            free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n             infcx.resolve_regions_and_report_errors(impl_m.def_id, &region_maps, &free_regions);\n         } else {\n-            let fcx = FnCtxt::new(&inh, impl_m_node_id);\n+            let fcx = FnCtxt::new(&inh, param_env, impl_m_node_id);\n             fcx.regionck_item(impl_m_node_id, impl_m_span, &[]);\n         }\n \n@@ -399,6 +403,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n+                                                     param_env: ty::ParamEnv<'tcx>,\n                                                      terr: &TypeError,\n                                                      cause: &ObligationCause<'tcx>,\n                                                      impl_m: &ty::AssociatedItem,\n@@ -456,21 +461,23 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n                 impl_iter.zip(trait_iter)\n                          .zip(impl_m_iter)\n                          .zip(trait_m_iter)\n-                         .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n-                             match infcx.sub_types(true, &cause, trait_arg_ty, impl_arg_ty) {\n+                         .filter_map(|(((&impl_arg_ty, &trait_arg_ty), impl_arg), trait_arg)| {\n+                             match infcx.at(&cause, param_env).sub(trait_arg_ty, impl_arg_ty) {\n                                  Ok(_) => None,\n                                  Err(_) => Some((impl_arg.span, Some(trait_arg.span))),\n                              }\n                          })\n                          .next()\n                          .unwrap_or_else(|| {\n-                             if infcx.sub_types(false, &cause, impl_sig.output(),\n-                                                trait_sig.output())\n-                                     .is_err() {\n-                                         (impl_m_output.span(), Some(trait_m_output.span()))\n-                                     } else {\n-                                         (cause.span, tcx.hir.span_if_local(trait_m.def_id))\n-                                     }\n+                             if\n+                                 infcx.at(&cause, param_env)\n+                                      .sup(trait_sig.output(), impl_sig.output())\n+                                      .is_err()\n+                             {\n+                                 (impl_m_output.span(), Some(trait_m_output.span()))\n+                             } else {\n+                                 (cause.span, tcx.hir.span_if_local(trait_m.def_id))\n+                             }\n                          })\n             } else {\n                 (cause.span, tcx.hir.span_if_local(trait_m.def_id))\n@@ -713,7 +720,8 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_trait_ref: ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n+        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let inh = Inherited::new(infcx, impl_c.def_id);\n         let infcx = &inh.infcx;\n \n@@ -736,18 +744,21 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // There is no \"body\" here, so just pass dummy id.\n         let impl_ty = inh.normalize_associated_types_in(impl_c_span,\n                                                         impl_c_node_id,\n+                                                        param_env,\n                                                         &impl_ty);\n \n         debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n \n         let trait_ty = inh.normalize_associated_types_in(impl_c_span,\n                                                          impl_c_node_id,\n+                                                         param_env,\n                                                          &trait_ty);\n \n         debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-        let err = infcx.sub_types(false, &cause, impl_ty, trait_ty)\n-            .map(|ok| inh.register_infer_ok_obligations(ok));\n+        let err = infcx.at(&cause, param_env)\n+                       .sup(trait_ty, impl_ty)\n+                       .map(|ok| inh.register_infer_ok_obligations(ok));\n \n         if let Err(terr) = err {\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n@@ -794,7 +805,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             return;\n         }\n \n-        let fcx = FnCtxt::new(&inh, impl_c_node_id);\n+        let fcx = FnCtxt::new(&inh, param_env, impl_c_node_id);\n         fcx.regionck_item(impl_c_node_id, impl_c_span, &[]);\n     });\n }"}, {"sha": "40d53b5e97991e283e2aa18895d3e72082dde339", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -26,8 +26,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n     // they don't.\n     pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-        let cause = self.misc(sp);\n-        match self.sub_types(false, &cause, actual, expected) {\n+        let cause = &self.misc(sp);\n+        match self.at(cause, self.param_env).sup(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             },\n@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                      cause: &ObligationCause<'tcx>,\n                                      expected: Ty<'tcx>,\n                                      actual: Ty<'tcx>) -> Option<DiagnosticBuilder<'tcx>> {\n-        match self.eq_types(false, cause, actual, expected) {\n+        match self.at(cause, self.param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None"}, {"sha": "bff9289de505585b3279e0475c4fb328d06f7f8e", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::{self, InferOk};\n use rustc::middle::region::{self, RegionMaps};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, ObligationCause, Reveal};\n+use rustc::traits::{self, ObligationCause};\n use util::common::ErrorReported;\n use util::nodemap::FxHashSet;\n \n@@ -79,8 +79,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n     // check that the impl type can be made to match the trait type.\n \n-    let impl_param_env = tcx.param_env(self_type_did);\n-    tcx.infer_ctxt(impl_param_env, Reveal::UserFacing).enter(|ref infcx| {\n+    tcx.infer_ctxt(()).enter(|ref infcx| {\n+        let impl_param_env = tcx.param_env(self_type_did);\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n@@ -92,7 +92,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);\n-        match infcx.eq_types(true, cause, named_type, fresh_impl_self_ty) {\n+        match infcx.at(cause, impl_param_env).eq(named_type, fresh_impl_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfillment_cx.register_predicate_obligations(infcx, obligations);\n             }"}, {"sha": "c8815f3df5aa25ecda4a4772b287a9b1eec84c21", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {\n-        match self.sub_types(false, &self.misc(self.span), self_ty, method_self_ty) {\n+        match self.at(&self.misc(self.span), self.param_env).sup(method_self_ty, self_ty) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             }"}, {"sha": "73c1215f275fbd8612ba0dbdab7ce4b47cc7be49", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -205,7 +205,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Construct an obligation\n         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n         let obligation =\n-            traits::Obligation::misc(span, self.body_id, poly_trait_ref.to_predicate());\n+            traits::Obligation::misc(span,\n+                                     self.body_id,\n+                                     self.param_env,\n+                                     poly_trait_ref.to_predicate());\n \n         // Now we want to know if this can be matched\n         let mut selcx = traits::SelectionContext::new(self);\n@@ -262,14 +265,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!bounds.has_escaping_regions());\n \n         let cause = traits::ObligationCause::misc(span, self.body_id);\n-        obligations.extend(traits::predicates_for_generics(cause.clone(), &bounds));\n+        obligations.extend(traits::predicates_for_generics(cause.clone(),\n+                                                           self.param_env,\n+                                                           &bounds));\n \n         // Also add an obligation for the method type being well-formed.\n         let method_ty = tcx.mk_fn_ptr(ty::Binder(fn_sig));\n         debug!(\"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n                method_ty,\n                obligation);\n-        obligations.push(traits::Obligation::new(cause, ty::Predicate::WellFormed(method_ty)));\n+        obligations.push(traits::Obligation::new(cause,\n+                                                 self.param_env,\n+                                                 ty::Predicate::WellFormed(method_ty)));\n \n         let callee = MethodCallee {\n             def_id: def_id,"}, {"sha": "2518a1739f73e69a85cdee096002de109a09fd01", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -540,7 +540,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n             let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n             let traits::Normalized { value: xform_self_ty, obligations } =\n-                traits::normalize(selcx, cause, &xform_self_ty);\n+                traits::normalize(selcx, self.param_env, cause, &xform_self_ty);\n             debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n                    xform_self_ty);\n \n@@ -679,7 +679,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     let output = fty.output().subst(self.tcx, substs);\n                     let (output, _) = self.replace_late_bound_regions_with_fresh_var(\n                         self.span, infer::FnCall, &output);\n-                    self.can_sub_types(output, expected).is_ok()\n+                    self.can_sub(self.param_env, output, expected).is_ok()\n                 })\n             }\n             _ => false,\n@@ -751,7 +751,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n             let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n             let traits::Normalized { value: xform_self_ty, obligations } =\n-                traits::normalize(selcx, cause, &xform_self_ty);\n+                traits::normalize(selcx, self.param_env, cause, &xform_self_ty);\n \n             debug!(\"xform_self_ty={:?}\", xform_self_ty);\n \n@@ -885,7 +885,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                        substs,\n                        bound);\n \n-                if self.can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n+                if self.can_eq(self.param_env, step.self_ty, bound.self_ty()).is_ok() {\n                     let xform_self_ty = self.xform_self_ty(&item, bound.self_ty(), bound.substs);\n \n                     debug!(\"assemble_projection_candidates: bound={:?} xform_self_ty={:?}\",\n@@ -1143,10 +1143,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         self.probe(|_| {\n             // First check that the self type can be related.\n-            let sub_obligations = match self.sub_types(false,\n-                                                       &ObligationCause::dummy(),\n-                                                       self_ty,\n-                                                       probe.xform_self_ty) {\n+            let sub_obligations = match self.at(&ObligationCause::dummy(), self.param_env)\n+                                            .sup(probe.xform_self_ty, self_ty) {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n                 Err(_) => {\n                     debug!(\"--> cannot relate self-types\");\n@@ -1182,10 +1180,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let impl_bounds = self.tcx.predicates_of(impl_def_id);\n             let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n             let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n-                traits::normalize(selcx, cause.clone(), &impl_bounds);\n+                traits::normalize(selcx, self.param_env, cause.clone(), &impl_bounds);\n \n             // Convert the bounds into obligations.\n-            let obligations = traits::predicates_for_generics(cause.clone(), &impl_bounds);\n+            let obligations = traits::predicates_for_generics(cause.clone(),\n+                                                              self.param_env,\n+                                                              &impl_bounds);\n             debug!(\"impl_obligations={:?}\", obligations);\n \n             // Evaluate those obligations to see if they might possibly hold."}, {"sha": "c496053a1543bea4420ed4049d883c55ac93f0b6", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -57,7 +57,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                         let obligation =\n-                            Obligation::misc(span, self.body_id, poly_trait_ref.to_predicate());\n+                            Obligation::misc(span,\n+                                             self.body_id,\n+                                             self.param_env,\n+                                             poly_trait_ref.to_predicate());\n                         SelectionContext::new(self).evaluate_obligation(&obligation)\n                     })\n                 })"}, {"sha": "ccaf9b84a45abd55e28cfdd003165357f63b5132", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -93,7 +93,7 @@ use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region::CodeExtent;\n use rustc::ty::subst::{Kind, Subst, Substs};\n-use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n+use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n@@ -450,6 +450,14 @@ impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     body_id: ast::NodeId,\n \n+    /// The parameter environment used for proving trait obligations\n+    /// in this function. This can change when we descend into\n+    /// closures (as they bring new things into scope), hence it is\n+    /// not part of `Inherited` (as of the time of this writing,\n+    /// closures do not yet change the environment, but they will\n+    /// eventually).\n+    param_env: ty::ParamEnv<'tcx>,\n+\n     // Number of errors that had been reported when we started\n     // checking this function. On exit, if we find that *more* errors\n     // have been reported, we will skip regionck and other work that\n@@ -528,9 +536,8 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n         let tables = ty::TypeckTables::empty();\n-        let param_env = tcx.param_env(def_id);\n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt((tables, param_env), Reveal::UserFacing),\n+            infcx: tcx.infer_ctxt(tables),\n             def_id,\n         }\n     }\n@@ -590,16 +597,18 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     fn normalize_associated_types_in<T>(&self,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n+                                        param_env: ty::ParamEnv<'tcx>,\n                                         value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        let ok = self.normalize_associated_types_in_as_infer_ok(span, body_id, value);\n+        let ok = self.normalize_associated_types_in_as_infer_ok(span, body_id, param_env, value);\n         self.register_infer_ok_obligations(ok)\n     }\n \n     fn normalize_associated_types_in_as_infer_ok<T>(&self,\n                                                     span: Span,\n                                                     body_id: ast::NodeId,\n+                                                    param_env: ty::ParamEnv<'tcx>,\n                                                     value: &T)\n                                                     -> InferOk<'tcx, T>\n         where T : TypeFoldable<'tcx>\n@@ -608,7 +617,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let mut selcx = traits::SelectionContext::new(self);\n         let cause = ObligationCause::misc(span, body_id);\n         let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, cause, value);\n+            traits::normalize(&mut selcx, param_env, cause, value);\n         debug!(\"normalize_associated_types_in: result={:?} predicates={:?}\",\n             value,\n             obligations);\n@@ -797,6 +806,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let body = tcx.hir.body(body_id);\n \n     Inherited::build(tcx, def_id).enter(|inh| {\n+        let param_env = tcx.param_env(def_id);\n         let fcx = if let Some(decl) = fn_decl {\n             let fn_sig = tcx.type_of(def_id).fn_sig();\n \n@@ -806,11 +816,14 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let fn_sig =\n                 inh.liberate_late_bound_regions(def_id, &fn_sig);\n             let fn_sig =\n-                inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n+                inh.normalize_associated_types_in(body.value.span,\n+                                                  body_id.node_id,\n+                                                  param_env,\n+                                                  &fn_sig);\n \n-            check_fn(&inh, fn_sig, decl, id, body)\n+            check_fn(&inh, param_env, fn_sig, decl, id, body)\n         } else {\n-            let fcx = FnCtxt::new(&inh, body.value.id);\n+            let fcx = FnCtxt::new(&inh, param_env, body.value.id);\n             let expected_type = tcx.type_of(def_id);\n             let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n@@ -919,6 +932,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n /// * ...\n /// * inherited: other fields inherited from the enclosing fn (if any)\n fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n+                            param_env: ty::ParamEnv<'tcx>,\n                             fn_sig: ty::FnSig<'tcx>,\n                             decl: &'gcx hir::FnDecl,\n                             fn_id: ast::NodeId,\n@@ -927,11 +941,11 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n {\n     let mut fn_sig = fn_sig.clone();\n \n-    debug!(\"check_fn(sig={:?}, fn_id={})\", fn_sig, fn_id);\n+    debug!(\"check_fn(sig={:?}, fn_id={}, param_env={:?})\", fn_sig, fn_id, param_env);\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, body.value.id);\n+    let mut fcx = FnCtxt::new(inherited, param_env, body.value.id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n \n     let ret_ty = fn_sig.output();\n@@ -1633,10 +1647,12 @@ enum TupleArgumentsFlag {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(inh: &'a Inherited<'a, 'gcx, 'tcx>,\n+               param_env: ty::ParamEnv<'tcx>,\n                body_id: ast::NodeId)\n                -> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n             body_id: body_id,\n+            param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n@@ -1870,7 +1886,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Require that the predicate holds for the concrete type.\n                     let cause = traits::ObligationCause::new(span, self.body_id,\n                                                              traits::ReturnType);\n-                    self.register_predicate(traits::Obligation::new(cause, predicate));\n+                    self.register_predicate(traits::Obligation::new(cause,\n+                                                                    self.param_env,\n+                                                                    predicate));\n                 }\n \n                 ty_var\n@@ -1883,15 +1901,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        let ok = self.normalize_associated_types_in_as_infer_ok(span, value);\n-        self.register_infer_ok_obligations(ok)\n+        self.inh.normalize_associated_types_in(span, self.body_id, self.param_env, value)\n     }\n \n     fn normalize_associated_types_in_as_infer_ok<T>(&self, span: Span, value: &T)\n                                                     -> InferOk<'tcx, T>\n         where T : TypeFoldable<'tcx>\n     {\n-        self.inh.normalize_associated_types_in_as_infer_ok(span, self.body_id, value)\n+        self.inh.normalize_associated_types_in_as_infer_ok(span,\n+                                                           self.body_id,\n+                                                           self.param_env,\n+                                                           value)\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n@@ -1929,7 +1949,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           cause: traits::ObligationCause<'tcx>)\n     {\n         self.fulfillment_cx.borrow_mut()\n-            .register_bound(self, ty, def_id, cause);\n+                           .register_bound(self, self.param_env, ty, def_id, cause);\n     }\n \n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n@@ -1970,7 +1990,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         // WF obligations never themselves fail, so no real need to give a detailed cause:\n         let cause = traits::ObligationCause::new(span, self.body_id, code);\n-        self.register_predicate(traits::Obligation::new(cause, ty::Predicate::WellFormed(ty)));\n+        self.register_predicate(traits::Obligation::new(cause,\n+                                                        self.param_env,\n+                                                        ty::Predicate::WellFormed(ty)));\n     }\n \n     pub fn register_old_wf_obligation(&self,\n@@ -2023,7 +2045,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"add_obligations_for_parameters(predicates={:?})\",\n                predicates);\n \n-        for obligation in traits::predicates_for_generics(cause, predicates) {\n+        for obligation in traits::predicates_for_generics(cause, self.param_env, predicates) {\n             self.register_predicate(obligation);\n         }\n     }\n@@ -2704,7 +2726,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.sub_types(false, &origin, formal_ret, ret_ty);\n+                let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n \n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n@@ -4199,7 +4221,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => return,\n         };\n         let last_expr_ty = self.expr_ty(last_expr);\n-        if self.can_sub_types(last_expr_ty, expected_ty).is_err() {\n+        if self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err() {\n             return;\n         }\n         let original_span = original_sp(last_stmt.span, blk.span);\n@@ -4459,7 +4481,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let ty = self.tcx.type_of(impl_def_id);\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n-            match self.sub_types(false, &self.misc(span), self_ty, impl_ty) {\n+            match self.at(&self.misc(span), self.param_env).sup(impl_ty, self_ty) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {\n                     span_bug!(span,"}, {"sha": "4d69b37b113cfbf2bfaf36b49e00f583d15d23ea", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -238,9 +238,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             lhs_ty);\n \n                         if let TypeVariants::TyRef(_, ref ty_mut) = lhs_ty.sty {\n-                            if !self.infcx.type_moves_by_default(ty_mut.ty, lhs_expr.span) &&\n-                                self.lookup_op_method(ty_mut.ty, &[rhs_ty],\n-                                                      Op::Binary(op, is_assign)).is_ok() {\n+                            if {\n+                                !self.infcx.type_moves_by_default(self.param_env,\n+                                                                  ty_mut.ty,\n+                                                                  lhs_expr.span) &&\n+                                    self.lookup_op_method(ty_mut.ty,\n+                                                          &[rhs_ty],\n+                                                          Op::Binary(op, is_assign))\n+                                        .is_ok()\n+                            } {\n                                 err.note(\n                                     &format!(\n                                         \"this is a reference to a type that `{}` can be applied \\"}, {"sha": "00b044a9beff78418c469c027c73d7bd1d714e73", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -386,7 +386,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={:?})\", ty);\n-            let implied_bounds = ty::wf::implied_bounds(self, body_id, ty, span);\n+            let implied_bounds =\n+                ty::wf::implied_bounds(self, self.fcx.param_env, body_id, ty, span);\n \n             // Record any relations between free regions that we observe into the free-region-map.\n             self.free_region_map.relate_free_regions_from_implied_bounds(&implied_bounds);\n@@ -1660,7 +1661,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n                     // check whether this predicate applies to our current projection\n                     let cause = self.fcx.misc(span);\n-                    match self.eq_types(false, &cause, ty, outlives.0) {\n+                    match self.at(&cause, self.fcx.param_env).eq(outlives.0, ty) {\n                         Ok(ok) => {\n                             self.register_infer_ok_obligations(ok);\n                             Ok(outlives.1)"}, {"sha": "25f5418bea9c5ab8c13e616185625dba0380680a", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -166,9 +166,11 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         {\n             let body_owner_def_id = self.fcx.tcx.hir.body_owner_def_id(body.id());\n             let region_maps = &self.fcx.tcx.region_maps(body_owner_def_id);\n+            let param_env = self.fcx.param_env;\n             let mut euv =\n                 euv::ExprUseVisitor::with_options(self,\n                                                   self.fcx,\n+                                                  param_env,\n                                                   region_maps,\n                                                   mc::MemCategorizationOptions {\n                                                       during_closure_kind_inference: true"}, {"sha": "26f708e934562ba704458f0c361e4dd7d81eda8f", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -37,7 +37,8 @@ struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n     code: ObligationCauseCode<'gcx>,\n     id: ast::NodeId,\n-    span: Span\n+    span: Span,\n+    param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n@@ -48,8 +49,9 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         let code = self.code.clone();\n         let id = self.id;\n         let span = self.span;\n+        let param_env = self.param_env;\n         self.inherited.enter(|inh| {\n-            let fcx = FnCtxt::new(&inh, id);\n+            let fcx = FnCtxt::new(&inh, param_env, id);\n             let wf_tys = f(&fcx, &mut CheckTypeWellFormedVisitor {\n                 tcx: fcx.tcx.global_tcx(),\n                 code: code\n@@ -206,11 +208,13 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n     fn for_id<'tcx>(&self, id: ast::NodeId, span: Span)\n                     -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+        let def_id = self.tcx.hir.local_def_id(id);\n         CheckWfFcxBuilder {\n-            inherited: Inherited::build(self.tcx, self.tcx.hir.local_def_id(id)),\n+            inherited: Inherited::build(self.tcx, def_id),\n             code: self.code.clone(),\n             id: id,\n-            span: span\n+            span: span,\n+            param_env: self.tcx.param_env(def_id),\n         }\n     }\n \n@@ -374,6 +378,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                             ast_trait_ref.path.span, &trait_ref);\n                     let obligations =\n                         ty::wf::trait_obligations(fcx,\n+                                                  fcx.param_env,\n                                                   fcx.body_id,\n                                                   &trait_ref,\n                                                   ast_trait_ref.path.span);\n@@ -405,6 +410,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             predicates.predicates\n                       .iter()\n                       .flat_map(|p| ty::wf::predicate_obligations(fcx,\n+                                                                  fcx.param_env,\n                                                                   fcx.body_id,\n                                                                   p,\n                                                                   span));"}, {"sha": "377b7b069d3312ec4a71b9c3b269a78d58a07c2e", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region::RegionMaps;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n \n-use rustc::traits::{self, ObligationCause, Reveal};\n+use rustc::traits::{self, ObligationCause};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::TypeFoldable;\n use rustc::ty::adjustment::CoerceUnsizedInfo;\n@@ -208,7 +208,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n+    tcx.infer_ctxt(()).enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_node_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,\n@@ -308,7 +308,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         // we may have to evaluate constraint\n                         // expressions in the course of execution.)\n                         // See e.g. #41936.\n-                        if let Ok(ok) = infcx.eq_types(false, &cause, b, a) {\n+                        if let Ok(ok) = infcx.at(&cause, param_env).eq(a, b) {\n                             if ok.obligations.is_empty() {\n                                 return None;\n                             }\n@@ -376,7 +376,12 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_node_id);\n-        let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n+        let predicate = tcx.predicate_for_trait_def(param_env,\n+                                                    cause,\n+                                                    trait_def_id,\n+                                                    0,\n+                                                    source,\n+                                                    &[target]);\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n         // Check that all transitive obligations are satisfied.\n@@ -387,8 +392,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Finally, resolve all regions.\n         let region_maps = RegionMaps::new();\n         let mut free_regions = FreeRegionMap::new();\n-        free_regions.relate_free_regions_from_predicates(&infcx.param_env\n-            .caller_bounds);\n+        free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n         infcx.resolve_regions_and_report_errors(impl_did, &region_maps, &free_regions);\n \n         CoerceUnsizedInfo {"}, {"sha": "afeb85a7a065698f68593887929e818a86630413", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -11,7 +11,7 @@\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::traits::{self, Reveal};\n+use rustc::traits;\n use rustc::ty::{self, TyCtxt};\n \n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+                self.tcx.infer_ctxt(()).enter(|infcx| {\n                     if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n                     }"}, {"sha": "06cb9f948c9b3927efde87894b801dba3fc6358f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -155,9 +155,10 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n-    tcx.infer_ctxt((), Reveal::UserFacing).enter(|ref infcx| {\n+    tcx.infer_ctxt(()).enter(|ref infcx| {\n+        let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let mut fulfill_cx = FulfillmentContext::new();\n-        match infcx.eq_types(false, &cause, expected, actual) {\n+        match infcx.at(&cause, param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfill_cx.register_predicate_obligations(infcx, obligations);\n             }"}, {"sha": "2591d7bcbaef4e2cc73e50bc17ff70ae97d4f000", "filename": "src/test/ui/issue-26548.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Ftest%2Fui%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Ftest%2Fui%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-26548.rs?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "previous_filename": "src/test/compile-fail/issue-26548.rs"}, {"sha": "c27ad7680a5700696d21499d346dd8da95f5de72", "filename": "src/test/ui/issue-26548.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Ftest%2Fui%2Fissue-26548.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/107bd67ef7fb3e8027d7234d687cdd27c3efaa0d/src%2Ftest%2Fui%2Fissue-26548.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-26548.stderr?ref=107bd67ef7fb3e8027d7234d687cdd27c3efaa0d", "patch": "@@ -0,0 +1,9 @@\n+error[E0391]: unsupported cyclic reference between types/traits detected\n+  |\n+note: the cycle begins when computing layout of `S`...\n+note: ...which then requires computing layout of `std::option::Option<<S as Mirror>::It>`...\n+note: ...which then requires computing layout of `<S as Mirror>::It`...\n+  = note: ...which then again requires computing layout of `S`, completing the cycle.\n+\n+error: aborting due to previous error(s)\n+"}]}