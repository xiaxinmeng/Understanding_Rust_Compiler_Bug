{"sha": "81eb15210a0c43820b146cd9ae6fd2062e1b2922", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZWIxNTIxMGEwYzQzODIwYjE0NmNkOWFlNmZkMjA2MmUxYjI5MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-04T23:05:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-04T23:05:05Z"}, "message": "Auto merge of #61527 - pietroalbini:rollup-vhxyqlk, r=pietroalbini\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #61069 (Make MIR drop terminators borrow the dropped location)\n - #61453 (Remove unneeded feature attr from atomic integers doctests)\n - #61488 (Fix NLL typeck ICEs)\n - #61500 (Fix regression 61475)\n - #61523 (Hide gen_future API from documentation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7c0f6790211f9ac4432493b877532e1cbb345db1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c0f6790211f9ac4432493b877532e1cbb345db1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81eb15210a0c43820b146cd9ae6fd2062e1b2922", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81eb15210a0c43820b146cd9ae6fd2062e1b2922", "html_url": "https://github.com/rust-lang/rust/commit/81eb15210a0c43820b146cd9ae6fd2062e1b2922", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81eb15210a0c43820b146cd9ae6fd2062e1b2922/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d8f59f4b1473217c2de7e02330b5aaae70a1668", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8f59f4b1473217c2de7e02330b5aaae70a1668", "html_url": "https://github.com/rust-lang/rust/commit/5d8f59f4b1473217c2de7e02330b5aaae70a1668"}, {"sha": "e83dcebe4fe53fa7826d87b0814751a5c726ba35", "url": "https://api.github.com/repos/rust-lang/rust/commits/e83dcebe4fe53fa7826d87b0814751a5c726ba35", "html_url": "https://github.com/rust-lang/rust/commit/e83dcebe4fe53fa7826d87b0814751a5c726ba35"}], "stats": {"total": 296, "additions": 274, "deletions": 22}, "files": [{"sha": "8dfb19fa032960bf9b7cefdc3210875013918ca0", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -1899,7 +1899,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     \"i8\", \"../../../std/primitive.i8.html\",\n-    \"#![feature(integer_atomics)]\\n\\n\",\n+    \"\",\n     atomic_min, atomic_max,\n     1,\n     \"AtomicI8::new(0)\",\n@@ -1915,7 +1915,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     \"u8\", \"../../../std/primitive.u8.html\",\n-    \"#![feature(integer_atomics)]\\n\\n\",\n+    \"\",\n     atomic_umin, atomic_umax,\n     1,\n     \"AtomicU8::new(0)\",\n@@ -1931,7 +1931,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     \"i16\", \"../../../std/primitive.i16.html\",\n-    \"#![feature(integer_atomics)]\\n\\n\",\n+    \"\",\n     atomic_min, atomic_max,\n     2,\n     \"AtomicI16::new(0)\",\n@@ -1947,7 +1947,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     \"u16\", \"../../../std/primitive.u16.html\",\n-    \"#![feature(integer_atomics)]\\n\\n\",\n+    \"\",\n     atomic_umin, atomic_umax,\n     2,\n     \"AtomicU16::new(0)\",\n@@ -1963,7 +1963,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     \"i32\", \"../../../std/primitive.i32.html\",\n-    \"#![feature(integer_atomics)]\\n\\n\",\n+    \"\",\n     atomic_min, atomic_max,\n     4,\n     \"AtomicI32::new(0)\",\n@@ -1979,7 +1979,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     \"u32\", \"../../../std/primitive.u32.html\",\n-    \"#![feature(integer_atomics)]\\n\\n\",\n+    \"\",\n     atomic_umin, atomic_umax,\n     4,\n     \"AtomicU32::new(0)\",\n@@ -1995,7 +1995,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     \"i64\", \"../../../std/primitive.i64.html\",\n-    \"#![feature(integer_atomics)]\\n\\n\",\n+    \"\",\n     atomic_min, atomic_max,\n     8,\n     \"AtomicI64::new(0)\",\n@@ -2011,7 +2011,7 @@ atomic_int! {\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     \"u64\", \"../../../std/primitive.u64.html\",\n-    \"#![feature(integer_atomics)]\\n\\n\",\n+    \"\",\n     atomic_umin, atomic_umax,\n     8,\n     \"AtomicU64::new(0)\","}, {"sha": "ae4bfcaa90373920757386fd310b806a63815398", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -115,13 +115,17 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n     /// A hacky variant of `canonicalize_query` that does not\n     /// canonicalize `'static`. Unfortunately, the existing leak\n-    /// check treaks `'static` differently in some cases (see also\n+    /// check treats `'static` differently in some cases (see also\n     /// #33684), so if we are performing an operation that may need to\n     /// prove \"leak-check\" related things, we leave `'static`\n     /// alone.\n+    ///\n+    /// `'static` is also special cased when winnowing candidates when\n+    /// selecting implementation candidates, so we also have to leave `'static`\n+    /// alone for queries that do selection.\n     //\n-    // FIXME(#48536): once we have universes, we can remove this and just use\n-    // `canonicalize_query`.\n+    // FIXME(#48536): once the above issues are resolved, we can remove this\n+    // and just use `canonicalize_query`.\n     pub fn canonicalize_hr_query_hack<V>(\n         &self,\n         value: &V,"}, {"sha": "0b20ec884fc4d8f484bab7aa3345b277ecd36af2", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -145,7 +145,9 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                 let gcx = self.infcx.tcx.global_tcx();\n \n                 let mut orig_values = OriginalQueryValues::default();\n-                let c_data = self.infcx.canonicalize_query(\n+                // HACK(matthewjasper) `'static` is special-cased in selection,\n+                // so we cannot canonicalize it.\n+                let c_data = self.infcx.canonicalize_hr_query_hack(\n                     &self.param_env.and(*data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);"}, {"sha": "361353f8df4c8f864962b69b514421a57b7ea1e7", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -334,6 +334,13 @@ impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n \n             match outlives_bound {\n                 OutlivesBound::RegionSubRegion(r1, r2) => {\n+                    // `where Type:` is lowered to `where Type: 'empty` so that\n+                    // we check `Type` is well formed, but there's no use for\n+                    // this bound here.\n+                    if let ty::ReEmpty = r1 {\n+                        return;\n+                    }\n+\n                     // The bound says that `r1 <= r2`; we store `r2: r1`.\n                     let r1 = self.universal_regions.to_region_vid(r1);\n                     let r2 = self.universal_regions.to_region_vid(r2);"}, {"sha": "55ec46566a487997748fa17e4aba50e6941a67c6", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -56,9 +56,20 @@ impl<'a, 'tcx> BitDenotation<'tcx> for HaveBeenBorrowedLocals<'a, 'tcx> {\n     fn terminator_effect(&self,\n                          sets: &mut BlockSets<'_, Local>,\n                          loc: Location) {\n+        let terminator = self.mir[loc.block].terminator();\n         BorrowedLocalsVisitor {\n             sets,\n-        }.visit_terminator(self.mir[loc.block].terminator(), loc);\n+        }.visit_terminator(terminator, loc);\n+        match &terminator.kind {\n+            // Drop terminators borrows the location\n+            TerminatorKind::Drop { location, .. } |\n+            TerminatorKind::DropAndReplace { location, .. } => {\n+                if let Some(local) = find_local(location) {\n+                    sets.gen(local);\n+                }\n+            }\n+            _ => (),\n+        }\n     }\n \n     fn propagate_call_return("}, {"sha": "0406549ff07910d079c8dd9d49cd77c772d30a1c", "filename": "src/libstd/future.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -16,12 +16,14 @@ pub use core::future::*;\n ///\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n+#[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n pub fn from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T::Return> {\n     GenFuture(x)\n }\n \n /// A wrapper around generators used to implement `Future` for `async`/`await` code.\n+#[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n struct GenFuture<T: Generator<Yield = ()>>(T);\n@@ -30,6 +32,7 @@ struct GenFuture<T: Generator<Yield = ()>>(T);\n // self-referential borrows in the underlying generator.\n impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n \n+#[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     type Output = T::Return;\n@@ -57,6 +60,7 @@ impl Drop for SetOnDrop {\n     }\n }\n \n+#[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Sets the thread-local task context used by async/await futures.\n pub fn set_task_context<F, R>(cx: &mut Context<'_>, f: F) -> R\n@@ -74,6 +78,7 @@ where\n     f()\n }\n \n+#[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Retrieves the thread-local task context used by async/await futures.\n ///\n@@ -105,6 +110,7 @@ where\n     unsafe { f(cx_ptr.as_mut()) }\n }\n \n+#[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Polls a future in the current thread-local task waker.\n pub fn poll_with_tls_context<F>(f: Pin<&mut F>) -> Poll<F::Output>"}, {"sha": "dafa4d5c3eccac77c22963d99995867620af4023", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -628,10 +628,10 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 Err(if self.prev_token_kind == PrevTokenKind::DocComment {\n-                        self.span_fatal_err(self.prev_span, Error::UselessDocComment)\n-                    } else {\n-                        self.expected_ident_found()\n-                    })\n+                    self.span_fatal_err(self.prev_span, Error::UselessDocComment)\n+                } else {\n+                    self.expected_ident_found()\n+                })\n             }\n         }\n     }\n@@ -1657,8 +1657,8 @@ impl<'a> Parser<'a> {\n             path = self.parse_path(PathStyle::Type)?;\n             path_span = path_lo.to(self.prev_span);\n         } else {\n-            path = ast::Path { segments: Vec::new(), span: DUMMY_SP };\n             path_span = self.span.to(self.span);\n+            path = ast::Path { segments: Vec::new(), span: path_span };\n         }\n \n         // See doc comment for `unmatched_angle_bracket_count`.\n@@ -2844,7 +2844,11 @@ impl<'a> Parser<'a> {\n             // want to keep their span info to improve diagnostics in these cases in a later stage.\n             (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n             (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n-            (true, Some(AssocOp::Add)) => { // `{ 42 } + 42\n+            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475)\n+            (true, Some(AssocOp::Add)) // `{ 42 } + 42\n+            // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n+            // `if x { a } else { b } && if y { c } else { d }`\n+            if !self.look_ahead(1, |t| t.is_reserved_ident()) => {\n                 // These cases are ambiguous and can't be identified in the parser alone\n                 let sp = self.sess.source_map().start_point(self.span);\n                 self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n@@ -5298,7 +5302,7 @@ impl<'a> Parser<'a> {\n         let mut where_clause = WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n-            span: DUMMY_SP,\n+            span: self.prev_span.to(self.prev_span),\n         };\n \n         if !self.eat_keyword(kw::Where) {"}, {"sha": "23bd73325472e4ec7284486aaf9a7e40bff7da33", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_libstd.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -1,5 +1,3 @@\n-#![feature(integer_atomics)]\n-\n // compile-pass\n \n use std::cell::UnsafeCell;"}, {"sha": "680449c9ef3e6599bef9ce69c3694ac3669f7f02", "filename": "src/test/ui/issues/issue-61475.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Ftest%2Fui%2Fissues%2Fissue-61475.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Ftest%2Fui%2Fissues%2Fissue-61475.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61475.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+#![allow(dead_code)]\n+\n+enum E {\n+    A, B\n+}\n+\n+fn main() {\n+    match &&E::A {\n+        &&E::A => {\n+        }\n+        &&E::B => {\n+        }\n+    };\n+}"}, {"sha": "75431d40ce54221952f857a018b23207a49c44cb", "filename": "src/test/ui/nll/empty-type-predicate.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -0,0 +1,11 @@\n+// Regression test for #61315\n+//\n+// `dyn T:` is lowered to `dyn T: ReEmpty` - check that we don't ICE in NLL for\n+// the unexpected region.\n+\n+// compile-pass\n+\n+trait T {}\n+fn f() where dyn T: {}\n+\n+fn main() {}"}, {"sha": "1164e9ef2d62feb77d2805cad013ac7db251de82", "filename": "src/test/ui/nll/issue-61311-normalize.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Ftest%2Fui%2Fnll%2Fissue-61311-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Ftest%2Fui%2Fnll%2Fissue-61311-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-61311-normalize.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -0,0 +1,34 @@\n+// Regression test for #61311\n+// We would ICE after failing to normalize `Self::Proj` in the `impl` below.\n+\n+// compile-pass\n+\n+pub struct Unit;\n+trait Obj {}\n+\n+trait Bound {}\n+impl Bound for Unit {}\n+\n+pub trait HasProj {\n+    type Proj;\n+}\n+\n+impl<T> HasProj for T {\n+    type Proj = Unit;\n+}\n+\n+trait HasProjFn {\n+    type Proj;\n+    fn the_fn(_: Self::Proj);\n+}\n+\n+impl HasProjFn for Unit\n+where\n+    Box<dyn Obj + 'static>: HasProj,\n+    <Box<dyn Obj + 'static> as HasProj>::Proj: Bound,\n+{\n+    type Proj = Unit;\n+    fn the_fn(_: Self::Proj) {}\n+}\n+\n+fn main() {}"}, {"sha": "a36ccd36113b586c9e577f973ee3e96b4ae9e9fe", "filename": "src/test/ui/nll/issue-61320-normalize.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Ftest%2Fui%2Fnll%2Fissue-61320-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81eb15210a0c43820b146cd9ae6fd2062e1b2922/src%2Ftest%2Fui%2Fnll%2Fissue-61320-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-61320-normalize.rs?ref=81eb15210a0c43820b146cd9ae6fd2062e1b2922", "patch": "@@ -0,0 +1,160 @@\n+// Regression test for #61320\n+// This is the same issue as #61311, just a larger test case.\n+\n+// compile-pass\n+\n+pub struct AndThen<A, B, F>\n+where\n+    A: Future,\n+    B: IntoFuture,\n+{\n+    state: (A, B::Future, F),\n+}\n+\n+pub struct FutureResult<T, E> {\n+    inner: Option<Result<T, E>>,\n+}\n+\n+impl<T, E> Future for FutureResult<T, E> {\n+    type Item = T;\n+    type Error = E;\n+\n+    fn poll(&mut self) -> Poll<T, E> {\n+        unimplemented!()\n+    }\n+}\n+\n+pub type Poll<T, E> = Result<T, E>;\n+\n+impl<A, B, F> Future for AndThen<A, B, F>\n+where\n+    A: Future,\n+    B: IntoFuture<Error = A::Error>,\n+    F: FnOnce(A::Item) -> B,\n+{\n+    type Item = B::Item;\n+    type Error = B::Error;\n+\n+    fn poll(&mut self) -> Poll<B::Item, B::Error> {\n+        unimplemented!()\n+    }\n+}\n+\n+pub trait Future {\n+    type Item;\n+\n+    type Error;\n+\n+    fn poll(&mut self) -> Poll<Self::Item, Self::Error>;\n+\n+    fn and_then<F, B>(self, f: F) -> AndThen<Self, B, F>\n+    where\n+        F: FnOnce(Self::Item) -> B,\n+        B: IntoFuture<Error = Self::Error>,\n+        Self: Sized,\n+    {\n+        unimplemented!()\n+    }\n+}\n+\n+pub trait IntoFuture {\n+    /// The future that this type can be converted into.\n+    type Future: Future<Item = Self::Item, Error = Self::Error>;\n+\n+    /// The item that the future may resolve with.\n+    type Item;\n+    /// The error that the future may resolve with.\n+    type Error;\n+\n+    /// Consumes this object and produces a future.\n+    fn into_future(self) -> Self::Future;\n+}\n+\n+impl<F: Future> IntoFuture for F {\n+    type Future = F;\n+    type Item = F::Item;\n+    type Error = F::Error;\n+\n+    fn into_future(self) -> F {\n+        self\n+    }\n+}\n+\n+impl<F: ?Sized + Future> Future for ::std::boxed::Box<F> {\n+    type Item = F::Item;\n+    type Error = F::Error;\n+\n+    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {\n+        (**self).poll()\n+    }\n+}\n+\n+impl<T, E> IntoFuture for Result<T, E> {\n+    type Future = FutureResult<T, E>;\n+    type Item = T;\n+    type Error = E;\n+\n+    fn into_future(self) -> FutureResult<T, E> {\n+        unimplemented!()\n+    }\n+}\n+\n+struct Request<T>(T);\n+\n+trait RequestContext {}\n+impl<T> RequestContext for T {}\n+struct NoContext;\n+impl AsRef<NoContext> for NoContext {\n+    fn as_ref(&self) -> &Self {\n+        &NoContext\n+    }\n+}\n+\n+type BoxedError = Box<dyn std::error::Error + Send + Sync>;\n+type DefaultFuture<T, E> = Box<dyn Future<Item = T, Error = E> + Send>;\n+\n+trait Guard: Sized {\n+    type Result: IntoFuture<Item = Self, Error = BoxedError>;\n+    fn from_request(request: &Request<()>) -> Self::Result;\n+}\n+\n+trait FromRequest: Sized {\n+    type Context;\n+    type Future: Future<Item = Self, Error = BoxedError> + Send;\n+    fn from_request(request: Request<()>) -> Self::Future;\n+}\n+\n+struct MyGuard;\n+impl Guard for MyGuard {\n+    type Result = Result<Self, BoxedError>;\n+    fn from_request(_request: &Request<()>) -> Self::Result {\n+        Ok(MyGuard)\n+    }\n+}\n+\n+struct Generic<I> {\n+    _inner: I,\n+}\n+\n+impl<I> FromRequest for Generic<I>\n+where\n+    MyGuard: Guard,\n+    <MyGuard as Guard>::Result: IntoFuture<Item = MyGuard, Error = BoxedError>,\n+    <<MyGuard as Guard>::Result as IntoFuture>::Future: Send,\n+    I: FromRequest<Context = NoContext>,\n+{\n+    type Future = DefaultFuture<Self, BoxedError>;\n+    type Context = NoContext;\n+    fn from_request(headers: Request<()>) -> DefaultFuture<Self, BoxedError> {\n+        let _future = <MyGuard as Guard>::from_request(&headers)\n+            .into_future()\n+            .and_then(move |_| {\n+                <I as FromRequest>::from_request(headers)\n+                    .into_future()\n+                    .and_then(move |fld_inner| Ok(Generic { _inner: fld_inner }).into_future())\n+            });\n+        panic!();\n+    }\n+}\n+\n+fn main() {}"}]}