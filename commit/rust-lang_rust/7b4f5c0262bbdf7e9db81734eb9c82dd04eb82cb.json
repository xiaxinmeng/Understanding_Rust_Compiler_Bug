{"sha": "7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiNGY1YzAyNjJiYmRmN2U5ZGI4MTczNGViOWM4MmRkMDRlYjgyY2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-16T20:28:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-16T20:28:23Z"}, "message": "Merge #9304\n\n9304: internal: cleanup tests r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "c96519e0107b3f844ba4e7d3dc988ef6c3735886", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c96519e0107b3f844ba4e7d3dc988ef6c3735886"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgyl7nCRBK7hj4Ov3rIwAAOloIACWVp/wfwapWaIkTNzWSBU8b\nZY9xUtn8uTgsTTMea64zzRfr5zlMxU4nrWUqENLLLEQq7e1SWL17izHHJVVhSf1m\nZqKvqsORZiMad+WAcO6N5AuKwcFojssEW4gtYrMFAEke6QFn5vX/vtAJjY/p5Wnn\nHi91TfNjrlbJQKCC27db0A3Rh9Q5YKnKMjR2shlgjtmQX1Isx6NK+MYJ9y3nI6f8\n48mATepsWTNIVUVSqjjZaqqWb0JMV4C0vBnHfOQRiK+xiweo0z2sZPfrHkPXStt7\nYBAwEL4TcbUWhrHkbc5ynhlVUtx28nT69trk4V+IYFA1lMo3iUf/+z2IBp1zT3Y=\n=2izp\n-----END PGP SIGNATURE-----\n", "payload": "tree c96519e0107b3f844ba4e7d3dc988ef6c3735886\nparent d6b8af44829521a9f925c4d87599efa3fef38edc\nparent 35772256f8ff3c52e469fc2bd388ad80ff8d79c7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623875303 +0000\ncommitter GitHub <noreply@github.com> 1623875303 +0000\n\nMerge #9304\n\n9304: internal: cleanup tests r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb", "html_url": "https://github.com/rust-lang/rust/commit/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6b8af44829521a9f925c4d87599efa3fef38edc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b8af44829521a9f925c4d87599efa3fef38edc", "html_url": "https://github.com/rust-lang/rust/commit/d6b8af44829521a9f925c4d87599efa3fef38edc"}, {"sha": "35772256f8ff3c52e469fc2bd388ad80ff8d79c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/35772256f8ff3c52e469fc2bd388ad80ff8d79c7", "html_url": "https://github.com/rust-lang/rust/commit/35772256f8ff3c52e469fc2bd388ad80ff8d79c7"}], "stats": {"total": 371, "additions": 212, "deletions": 159}, "files": [{"sha": "e0ad41fb96e726045c26c8dac2bddb1c0d961c64", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 8, "deletions": 39, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb", "patch": "@@ -418,48 +418,17 @@ fn issue_2705() {\n fn issue_2683_chars_impl() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- minicore: iterator\n+pub struct Chars<'a> {}\n+impl<'a> Iterator for Chars<'a> {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> {}\n+}\n+\n fn test() {\n-    let chars: std::str::Chars<'_>;\n+    let chars: Chars<'_>;\n     (chars.next(), chars.nth(1));\n } //^ (Option<char>, Option<char>)\n-\n-//- /std.rs crate:std\n-#[prelude_import]\n-use self::prelude::rust_2018::*;\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::iter::Iterator;\n-        pub use crate::option::Option;\n-    }\n-}\n-\n-pub mod iter {\n-    pub use self::traits::Iterator;\n-    pub mod traits {\n-        pub use self::iterator::Iterator;\n-\n-        pub mod iterator {\n-            pub trait Iterator {\n-                type Item;\n-                fn next(&mut self) -> Option<Self::Item>;\n-                fn nth(&mut self, n: usize) -> Option<Self::Item> {}\n-            }\n-        }\n-    }\n-}\n-\n-pub mod option {\n-    pub enum Option<T> {}\n-}\n-\n-pub mod str {\n-    pub struct Chars<'a> {}\n-    impl<'a> Iterator for Chars<'a> {\n-        type Item = char;\n-        fn next(&mut self) -> Option<char> {}\n-    }\n-}\n \"#,\n     );\n }"}, {"sha": "22e0bfc49e3a586919df4a3c54cd9df696c6c4c4", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb", "patch": "@@ -1492,7 +1492,7 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n fn impl_trait_assoc_binding_projection_bug() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- minicore: iterator\n pub trait Language {\n     type Kind;\n }\n@@ -1512,20 +1512,6 @@ fn api_walkthrough() {\n         node.clone();\n     }            //^ {unknown}\n }\n-\n-//- /std.rs crate:std\n-#[prelude_import] use iter::*;\n-mod iter {\n-    trait IntoIterator {\n-        type Item;\n-    }\n-    trait Iterator {\n-        type Item;\n-    }\n-    impl<T: Iterator> IntoIterator for T {\n-        type Item = <T as Iterator>::Item;\n-    }\n-}\n \"#,\n     );\n }"}, {"sha": "cd0f6dba98b745c6983c9ad34ffe56832c0471ae", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb", "patch": "@@ -278,8 +278,6 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: ExtendedVariant) -> Op\n \n #[cfg(test)]\n mod tests {\n-    use ide_db::helpers::FamousDefs;\n-\n     use crate::tests::{\n         check_assist, check_assist_not_applicable, check_assist_target, check_assist_unresolved,\n     };\n@@ -716,7 +714,10 @@ fn main() {\n \n     #[test]\n     fn fill_match_arms_tuple_of_enum_partial_with_wildcards() {\n-        let ra_fixture = r#\"\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+//- minicore: option\n fn main() {\n     let a = Some(1);\n     let b = Some(());\n@@ -725,10 +726,7 @@ fn main() {\n         (None, Some(_)) => {}\n     }\n }\n-\"#;\n-        check_assist(\n-            fill_match_arms,\n-            &format!(\"//- /main.rs crate:main deps:core{}{}\", ra_fixture, FamousDefs::FIXTURE),\n+\"#,\n             r#\"\n fn main() {\n     let a = Some(1);\n@@ -746,17 +744,17 @@ fn main() {\n     #[test]\n     fn fill_match_arms_partial_with_deep_pattern() {\n         // Fixme: cannot handle deep patterns\n-        let ra_fixture = r#\"\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+//- minicore: option\n fn main() {\n     match $0Some(true) {\n         Some(true) => {}\n         None => {}\n     }\n }\n-\"#;\n-        check_assist_not_applicable(\n-            fill_match_arms,\n-            &format!(\"//- /main.rs crate:main deps:core{}{}\", ra_fixture, FamousDefs::FIXTURE),\n+\"#,\n         );\n     }\n \n@@ -1007,17 +1005,15 @@ fn foo(a: A) {\n     #[test]\n     fn option_order() {\n         cov_mark::check!(option_order);\n-        let before = r#\"\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+//- minicore: option\n fn foo(opt: Option<i32>) {\n     match opt$0 {\n     }\n }\n-\"#;\n-        let before = &format!(\"//- /main.rs crate:main deps:core{}{}\", before, FamousDefs::FIXTURE);\n-\n-        check_assist(\n-            fill_match_arms,\n-            before,\n+\"#,\n             r#\"\n fn foo(opt: Option<i32>) {\n     match opt {"}, {"sha": "4e10fdb854d1c891493b1d1e00a5e31b54898c0c", "filename": "crates/ide_assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb", "patch": "@@ -182,23 +182,17 @@ impl std::ops::Deref for B {\n         );\n     }\n \n-    fn check_not_applicable(ra_fixture: &str) {\n-        let fixture = format!(\n-            \"//- /main.rs crate:main deps:core,std\\n{}\\n{}\",\n-            ra_fixture,\n-            FamousDefs::FIXTURE\n-        );\n-        check_assist_not_applicable(generate_deref, &fixture)\n-    }\n-\n     #[test]\n     fn test_generate_record_deref_not_applicable_if_already_impl() {\n         cov_mark::check!(test_add_record_deref_impl_already_exists);\n-        check_not_applicable(\n-            r#\"struct A { }\n+        check_assist_not_applicable(\n+            generate_deref,\n+            r#\"\n+//- minicore: deref\n+struct A { }\n struct B { $0a: A }\n \n-impl std::ops::Deref for B {\n+impl core::ops::Deref for B {\n     type Target = A;\n \n     fn deref(&self) -> &Self::Target {\n@@ -211,11 +205,14 @@ impl std::ops::Deref for B {\n     #[test]\n     fn test_generate_field_deref_not_applicable_if_already_impl() {\n         cov_mark::check!(test_add_field_deref_impl_already_exists);\n-        check_not_applicable(\n-            r#\"struct A { }\n+        check_assist_not_applicable(\n+            generate_deref,\n+            r#\"\n+//- minicore: deref\n+struct A { }\n struct B($0A)\n \n-impl std::ops::Deref for B {\n+impl core::ops::Deref for B {\n     type Target = A;\n \n     fn deref(&self) -> &Self::Target {"}, {"sha": "8e571723dc54f98cd6fb9c7195c4abecab6cc82c", "filename": "crates/ide_assists/src/handlers/replace_for_loop_with_for_each.rs", "status": "modified", "additions": 114, "deletions": 71, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs?ref=7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb", "patch": "@@ -85,38 +85,48 @@ fn is_ref_and_impls_iter_method(\n     let krate = scope.module()?.krate();\n     let traits_in_scope = scope.traits_in_scope();\n     let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n-    let has_wanted_method = typ.iterate_method_candidates(\n-        sema.db,\n-        krate,\n-        &traits_in_scope,\n-        Some(&wanted_method),\n-        |_, func| {\n-            if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n-                return Some(());\n-            }\n-            None\n-        },\n-    );\n-    has_wanted_method.and(Some((expr_behind_ref, wanted_method)))\n+\n+    let has_wanted_method = typ\n+        .iterate_method_candidates(\n+            sema.db,\n+            krate,\n+            &traits_in_scope,\n+            Some(&wanted_method),\n+            |_, func| {\n+                if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n+                    return Some(());\n+                }\n+                None\n+            },\n+        )\n+        .is_some();\n+    if !has_wanted_method {\n+        return None;\n+    }\n+\n+    Some((expr_behind_ref, wanted_method))\n }\n \n /// Whether iterable implements core::Iterator\n fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n-    let it_typ = if let Some(i) = sema.type_of_expr(iterable) {\n-        i\n-    } else {\n-        return false;\n+    let it_typ = match sema.type_of_expr(iterable) {\n+        Some(it) => it,\n+        None => return false,\n     };\n-    let module = if let Some(m) = sema.scope(iterable.syntax()).module() {\n-        m\n-    } else {\n-        return false;\n+\n+    let module = match sema.scope(iterable.syntax()).module() {\n+        Some(it) => it,\n+        None => return false,\n     };\n+\n     let krate = module.krate();\n-    if let Some(iter_trait) = FamousDefs(sema, Some(krate)).core_iter_Iterator() {\n-        return it_typ.impls_trait(sema.db, iter_trait, &[]);\n+    match FamousDefs(sema, Some(krate)).core_iter_Iterator() {\n+        Some(iter_trait) => {\n+            cov_mark::hit!(test_already_impls_iterator);\n+            it_typ.impls_trait(sema.db, iter_trait, &[])\n+        }\n+        None => false,\n     }\n-    false\n }\n \n #[cfg(test)]\n@@ -125,33 +135,6 @@ mod tests {\n \n     use super::*;\n \n-    const EMPTY_ITER_FIXTURE: &'static str = r\"\n-//- /lib.rs deps:core crate:empty_iter\n-pub struct EmptyIter;\n-impl Iterator for EmptyIter {\n-    type Item = usize;\n-    fn next(&mut self) -> Option<Self::Item> { None }\n-}\n-\n-pub struct Empty;\n-impl Empty {\n-    pub fn iter(&self) -> EmptyIter { EmptyIter }\n-    pub fn iter_mut(&self) -> EmptyIter { EmptyIter }\n-}\n-\n-pub struct NoIterMethod;\n-\";\n-\n-    fn check_assist_with_fixtures(before: &str, after: &str) {\n-        let before = &format!(\n-            \"//- /main.rs crate:main deps:core,empty_iter{}{}{}\",\n-            before,\n-            FamousDefs::FIXTURE,\n-            EMPTY_ITER_FIXTURE\n-        );\n-        check_assist(replace_for_loop_with_for_each, before, after);\n-    }\n-\n     #[test]\n     fn test_not_for() {\n         check_assist_not_applicable(\n@@ -201,20 +184,44 @@ fn main() {\n \n     #[test]\n     fn test_for_borrowed() {\n-        check_assist_with_fixtures(\n+        check_assist(\n+            replace_for_loop_with_for_each,\n             r\"\n-use empty_iter::*;\n+//- minicore: iterator\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Iter { Iter }\n+    fn iter_mut(&mut self) -> Iter { Iter }\n+}\n+\n fn main() {\n-    let x = Empty;\n+    let x = S;\n     for $0v in &x {\n         let a = v * 2;\n     }\n }\n \",\n             r\"\n-use empty_iter::*;\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Iter { Iter }\n+    fn iter_mut(&mut self) -> Iter { Iter }\n+}\n+\n fn main() {\n-    let x = Empty;\n+    let x = S;\n     x.iter().for_each(|v| {\n         let a = v * 2;\n     });\n@@ -225,9 +232,10 @@ fn main() {\n \n     #[test]\n     fn test_for_borrowed_no_iter_method() {\n-        check_assist_with_fixtures(\n+        check_assist(\n+            replace_for_loop_with_for_each,\n             r\"\n-use empty_iter::*;\n+struct NoIterMethod;\n fn main() {\n     let x = NoIterMethod;\n     for $0v in &x {\n@@ -236,7 +244,7 @@ fn main() {\n }\n \",\n             r\"\n-use empty_iter::*;\n+struct NoIterMethod;\n fn main() {\n     let x = NoIterMethod;\n     (&x).into_iter().for_each(|v| {\n@@ -249,20 +257,44 @@ fn main() {\n \n     #[test]\n     fn test_for_borrowed_mut() {\n-        check_assist_with_fixtures(\n+        check_assist(\n+            replace_for_loop_with_for_each,\n             r\"\n-use empty_iter::*;\n+//- minicore: iterator\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Iter { Iter }\n+    fn iter_mut(&mut self) -> Iter { Iter }\n+}\n+\n fn main() {\n-    let x = Empty;\n+    let x = S;\n     for $0v in &mut x {\n         let a = v * 2;\n     }\n }\n \",\n             r\"\n-use empty_iter::*;\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Iter { Iter }\n+    fn iter_mut(&mut self) -> Iter { Iter }\n+}\n+\n fn main() {\n-    let x = Empty;\n+    let x = S;\n     x.iter_mut().for_each(|v| {\n         let a = v * 2;\n     });\n@@ -296,21 +328,32 @@ fn main() {\n \n     #[test]\n     fn test_already_impls_iterator() {\n-        check_assist_with_fixtures(\n+        cov_mark::check!(test_already_impls_iterator);\n+        check_assist(\n+            replace_for_loop_with_for_each,\n             r#\"\n-use empty_iter::*;\n+//- minicore: iterator\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n fn main() {\n-    let x = Empty;\n-    for$0 a in x.iter().take(1) {\n+    for$0 a in Iter.take(1) {\n         println!(\"{}\", a);\n     }\n }\n \"#,\n             r#\"\n-use empty_iter::*;\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n fn main() {\n-    let x = Empty;\n-    x.iter().take(1).for_each(|a| {\n+    Iter.take(1).for_each(|a| {\n         println!(\"{}\", a);\n     });\n }"}, {"sha": "2f0da7fe53e6074dfe2bfd70e4ff00382502c2ef", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=7b4f5c0262bbdf7e9db81734eb9c82dd04eb82cb", "patch": "@@ -20,6 +20,7 @@\n //!     future: pin\n //!     option:\n //!     result:\n+//!     iterator: option\n \n pub mod marker {\n     // region:sized\n@@ -206,9 +207,70 @@ pub mod task {\n }\n // endregion:future\n \n+// region:iterator\n+pub mod iter {\n+    mod adapters {\n+        pub struct Take<I> {\n+            iter: I,\n+            n: usize,\n+        }\n+\n+        impl<I> Iterator for Take<I>\n+        where\n+            I: Iterator,\n+        {\n+            type Item = <I as Iterator>::Item;\n+\n+            fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+                loop {}\n+            }\n+        }\n+    }\n+    pub use self::adapters::Take;\n+\n+    mod traits {\n+        mod iterator {\n+            use super::super::Take;\n+\n+            pub trait Iterator {\n+                type Item;\n+                #[lang = \"next\"]\n+                fn next(&mut self) -> Option<Self::Item>;\n+                fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+                    loop {}\n+                }\n+                fn take(self, n: usize) -> crate::iter::Take<Self> {\n+                    loop {}\n+                }\n+            }\n+        }\n+        pub use self::iterator::Iterator;\n+\n+        mod collect {\n+            pub trait IntoIterator {\n+                type Item;\n+                type IntoIter: Iterator<Item = Self::Item>;\n+                #[lang = \"into_iter\"]\n+                fn into_iter(self) -> Self::IntoIter;\n+            }\n+            impl<I: Iterator> IntoIterator for I {\n+                type Item = I::Item;\n+                type IntoIter = I;\n+                fn into_iter(self) -> I {\n+                    self\n+                }\n+            }\n+        }\n+        pub use self::collect::IntoIterator;\n+    }\n+    pub use self::traits::{IntoIterator, Iterator};\n+}\n+// endregion:iterator\n+\n pub mod prelude {\n     pub mod v1 {\n         pub use crate::{\n+            iter::{IntoIterator, Iterator},     // :iterator\n             marker::Sized,                      // :sized\n             ops::{Fn, FnMut, FnOnce},           // :fn\n             option::Option::{self, None, Some}, // :option"}]}