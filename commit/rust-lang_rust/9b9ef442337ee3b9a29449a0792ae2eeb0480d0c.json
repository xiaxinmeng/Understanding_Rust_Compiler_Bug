{"sha": "9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliOWVmNDQyMzM3ZWUzYjlhMjk0NDlhMDc5MmFlMmVlYjA0ODBkMGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-06-11T19:14:38Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-13T20:53:34Z"}, "message": "libsyntax: Allow `+` to separate trait bounds from objects.\n\nRFC #27.\n\nAfter a snapshot, the old syntax will be removed.\n\nThis can break some code that looked like `foo as &Trait:Send`. Now you\nwill need to write `foo as (&Trait+Send)`.\n\nCloses #12778.\n\n[breaking-change]", "tree": {"sha": "0be19c2428e4bb08c91346b0c74366e2e9b0a510", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0be19c2428e4bb08c91346b0c74366e2e9b0a510"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "html_url": "https://github.com/rust-lang/rust/commit/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03ec8e5cc91b3b6b6ab98ef70aa63a0965c5f6c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/03ec8e5cc91b3b6b6ab98ef70aa63a0965c5f6c1", "html_url": "https://github.com/rust-lang/rust/commit/03ec8e5cc91b3b6b6ab98ef70aa63a0965c5f6c1"}], "stats": {"total": 277, "additions": 176, "deletions": 101}, "files": [{"sha": "f380004fb081e7cccf564928794eed18c9396812", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -724,6 +724,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                  .collect();\n                 ty::mk_tup(tcx, flds)\n             }\n+            ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n             ast::TyBareFn(ref bf) => {\n                 if bf.decl.variadic && bf.abi != abi::C {\n                     tcx.sess.span_err(ast_ty.span,"}, {"sha": "4d396ed4f6e5cccfaa7ecc6fd5ddf9b68394a2e5", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -1140,6 +1140,7 @@ impl<'a> Rebuilder<'a> {\n                     }\n                     ast::TyTup(new_tys)\n                 }\n+                ast::TyParen(ref typ) => ast::TyParen(build_to(*typ, to)),\n                 ref other => other.clone()\n             };\n             box(GC) ast::Ty { id: from.id, node: new_node, span: from.span }"}, {"sha": "7e68be09f1d56041d365163db73c5e3a3b8fc6e7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -60,7 +60,7 @@ impl<T: Clean<U>, U> Clean<VecPerParamSpace<U>> for VecPerParamSpace<T> {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<U> for Gc<T> {\n+impl<T: 'static + Clean<U>, U> Clean<U> for Gc<T> {\n     fn clean(&self) -> U {\n         (**self).clean()\n     }\n@@ -1198,6 +1198,7 @@ impl Clean<Type> for ast::Ty {\n             TyClosure(ref c, region) => Closure(box c.clean(), region.clean()),\n             TyProc(ref c) => Proc(box c.clean()),\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean()),\n+            TyParen(ref ty) => ty.clean(),\n             TyBot => Bottom,\n             ref x => fail!(\"Unimplemented type {:?}\", x),\n         }"}, {"sha": "b8e08dab722eaa292bccfbfae387277e4b3e913c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -784,6 +784,8 @@ pub enum Ty_ {\n     TyUnboxedFn(Gc<UnboxedFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<OwnedSlice<TyParamBound>>, NodeId), // for #7264; see above\n+    // No-op; kept solely so that we can pretty-print faithfully\n+    TyParen(P<Ty>),\n     TyTypeof(Gc<Expr>),\n     // TyInfer means the type should be inferred instead of it having been\n     // specified. This can appear anywhere in a type."}, {"sha": "8e0a2218ea369f7f8b12d960fb977ff6ef8b98cc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -737,6 +737,7 @@ pub fn get_inner_tys(ty: P<Ty>) -> Vec<P<Ty>> {\n         | ast::TyUniq(ty)\n         | ast::TyFixedLengthVec(ty, _) => vec!(ty),\n         ast::TyTup(ref tys) => tys.clone(),\n+        ast::TyParen(ty) => get_inner_tys(ty),\n         _ => Vec::new()\n     }\n }"}, {"sha": "d61a79e4e80be3e0a298c208640430866c5a192b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -192,6 +192,7 @@ pub trait Folder {\n                 })\n             }\n             TyTup(ref tys) => TyTup(tys.iter().map(|&ty| self.fold_ty(ty)).collect()),\n+            TyParen(ref ty) => TyParen(self.fold_ty(*ty)),\n             TyPath(ref path, ref bounds, id) => {\n                 let id = self.new_id(id);\n                 TyPath(self.fold_path(path),"}, {"sha": "e1a45e5643d2597ca9c01d889ee16ff7df091c4e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 86, "deletions": 51, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -51,7 +51,7 @@ use ast::{TokenTree, TraitMethod, TraitRef, TTDelim, TTSeq, TTTok};\n use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot, TyBox};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n-use ast::{TyNil, TyParam, TyParamBound, TyPath, TyPtr, TyRptr};\n+use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyRptr};\n use ast::{TyTup, TyU32, TyUnboxedFn, TyUniq, TyVec, UnUniq};\n use ast::{UnboxedFnTy, UnboxedFnTyParamBound, UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n@@ -105,7 +105,7 @@ pub enum PathParsingMode {\n     /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n     LifetimeAndTypesWithColons,\n     /// A path with a lifetime and type parameters with bounds before the last\n-    /// set of type parameters only; e.g. `foo::bar<'a>::Baz:X+Y<T>` This\n+    /// set of type parameters only; e.g. `foo::bar<'a>::Baz+X+Y<T>` This\n     /// form does not use extra double colons.\n     LifetimeAndTypesAndBounds,\n }\n@@ -1015,7 +1015,14 @@ impl<'a> Parser<'a> {\n         };\n \n         let (inputs, variadic) = self.parse_fn_args(false, false);\n-        let (_, bounds) = self.parse_optional_ty_param_bounds(false);\n+        let bounds = {\n+            if self.eat(&token::COLON) {\n+                let (_, bounds) = self.parse_ty_param_bounds(false);\n+                Some(bounds)\n+            } else {\n+                None\n+            }\n+        };\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         let decl = P(FnDecl {\n             inputs: inputs,\n@@ -1083,7 +1090,14 @@ impl<'a> Parser<'a> {\n             (is_unboxed, inputs)\n         };\n \n-        let (region, bounds) = self.parse_optional_ty_param_bounds(true);\n+        let (region, bounds) = {\n+            if self.eat(&token::COLON) {\n+                let (region, bounds) = self.parse_ty_param_bounds(true);\n+                (region, Some(bounds))\n+            } else {\n+                (None, None)\n+            }\n+        };\n \n         let (return_style, output) = self.parse_ret_ty();\n         let decl = P(FnDecl {\n@@ -1227,7 +1241,7 @@ impl<'a> Parser<'a> {\n     // parse a possibly mutable type\n     pub fn parse_mt(&mut self) -> MutTy {\n         let mutbl = self.parse_mutability();\n-        let t = self.parse_ty(false);\n+        let t = self.parse_ty(true);\n         MutTy { ty: t, mutbl: mutbl }\n     }\n \n@@ -1238,7 +1252,7 @@ impl<'a> Parser<'a> {\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = self.parse_ty(true);\n         let hi = ty.span.hi;\n         ast::TypeField {\n             ident: id,\n@@ -1261,7 +1275,7 @@ impl<'a> Parser<'a> {\n                     })\n                 )\n             } else {\n-                (Return, self.parse_ty(false))\n+                (Return, self.parse_ty(true))\n             }\n         } else {\n             let pos = self.span.lo;\n@@ -1276,10 +1290,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    // parse a type.\n-    // Useless second parameter for compatibility with quasiquote macros.\n-    // Bleh!\n-    pub fn parse_ty(&mut self, _: bool) -> P<Ty> {\n+    /// Parse a type.\n+    ///\n+    /// The second parameter specifies whether the `+` binary operator is\n+    /// allowed in the type grammar.\n+    pub fn parse_ty(&mut self, plus_allowed: bool) -> P<Ty> {\n         maybe_whole!(no_clone self, NtTy);\n \n         let lo = self.span.lo;\n@@ -1293,12 +1308,12 @@ impl<'a> Parser<'a> {\n                 // (t) is a parenthesized ty\n                 // (t,) is the type of a tuple with only one field,\n                 // of type t\n-                let mut ts = vec!(self.parse_ty(false));\n+                let mut ts = vec!(self.parse_ty(true));\n                 let mut one_tuple = false;\n                 while self.token == token::COMMA {\n                     self.bump();\n                     if self.token != token::RPAREN {\n-                        ts.push(self.parse_ty(false));\n+                        ts.push(self.parse_ty(true));\n                     }\n                     else {\n                         one_tuple = true;\n@@ -1307,17 +1322,17 @@ impl<'a> Parser<'a> {\n \n                 if ts.len() == 1 && !one_tuple {\n                     self.expect(&token::RPAREN);\n-                    return *ts.get(0)\n+                    TyParen(*ts.get(0))\n+                } else {\n+                    let t = TyTup(ts);\n+                    self.expect(&token::RPAREN);\n+                    t\n                 }\n-\n-                let t = TyTup(ts);\n-                self.expect(&token::RPAREN);\n-                t\n             }\n         } else if self.token == token::AT {\n             // MANAGED POINTER\n             self.bump();\n-            TyBox(self.parse_ty(false))\n+            TyBox(self.parse_ty(plus_allowed))\n         } else if self.token == token::TILDE {\n             // OWNED POINTER\n             self.bump();\n@@ -1326,15 +1341,15 @@ impl<'a> Parser<'a> {\n                     self.obsolete(self.last_span, ObsoleteOwnedVector),\n                 _ => self.obsolete(self.last_span, ObsoleteOwnedType),\n             };\n-            TyUniq(self.parse_ty(false))\n+            TyUniq(self.parse_ty(true))\n         } else if self.token == token::BINOP(token::STAR) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n             TyPtr(self.parse_mt())\n         } else if self.token == token::LBRACKET {\n             // VECTOR\n             self.expect(&token::LBRACKET);\n-            let t = self.parse_ty(false);\n+            let t = self.parse_ty(true);\n \n             // Parse the `, ..e` in `[ int, ..e ]`\n             // where `e` is a const expression\n@@ -1377,10 +1392,15 @@ impl<'a> Parser<'a> {\n         } else if self.token == token::MOD_SEP\n             || is_ident_or_path(&self.token) {\n             // NAMED TYPE\n+            let mode = if plus_allowed {\n+                LifetimeAndTypesAndBounds\n+            } else {\n+                LifetimeAndTypesWithoutColons\n+            };\n             let PathAndBounds {\n                 path,\n                 bounds\n-            } = self.parse_path(LifetimeAndTypesAndBounds);\n+            } = self.parse_path(mode);\n             TyPath(path, bounds, ast::DUMMY_NODE_ID)\n         } else if self.eat(&token::UNDERSCORE) {\n             // TYPE TO BE INFERRED\n@@ -1438,7 +1458,7 @@ impl<'a> Parser<'a> {\n                                    special_idents::invalid)\n         };\n \n-        let t = self.parse_ty(false);\n+        let t = self.parse_ty(true);\n \n         Arg {\n             ty: t,\n@@ -1456,7 +1476,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_fn_block_arg(&mut self) -> Arg {\n         let pat = self.parse_pat();\n         let t = if self.eat(&token::COLON) {\n-            self.parse_ty(false)\n+            self.parse_ty(true)\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n@@ -1611,9 +1631,19 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        // Next, parse a colon and bounded type parameters, if applicable.\n+        // Next, parse a plus and bounded type parameters, if applicable.\n+        //\n+        // NOTE(stage0, pcwalton): Remove `token::COLON` after a snapshot.\n         let bounds = if mode == LifetimeAndTypesAndBounds {\n-            let (_, bounds) = self.parse_optional_ty_param_bounds(false);\n+            let bounds = {\n+                if self.eat(&token::BINOP(token::PLUS)) ||\n+                        self.eat(&token::COLON) {\n+                    let (_, bounds) = self.parse_ty_param_bounds(false);\n+                    Some(bounds)\n+                } else {\n+                    None\n+                }\n+            };\n             bounds\n         } else {\n             None\n@@ -2438,7 +2468,7 @@ impl<'a> Parser<'a> {\n             }\n             None => {\n                 if as_prec > min_prec && self.eat_keyword(keywords::As) {\n-                    let rhs = self.parse_ty(true);\n+                    let rhs = self.parse_ty(false);\n                     let _as = self.mk_expr(lhs.span.lo,\n                                            rhs.span.hi,\n                                            ExprCast(lhs, rhs));\n@@ -3067,7 +3097,9 @@ impl<'a> Parser<'a> {\n             node: TyInfer,\n             span: mk_sp(lo, lo),\n         });\n-        if self.eat(&token::COLON) { ty = self.parse_ty(false); }\n+        if self.eat(&token::COLON) {\n+            ty = self.parse_ty(true);\n+        }\n         let init = self.parse_initializer();\n         box(GC) ast::Local {\n             ty: ty,\n@@ -3095,7 +3127,7 @@ impl<'a> Parser<'a> {\n         }\n         let name = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = self.parse_ty(true);\n         spanned(lo, self.last_span.hi, ast::StructField_ {\n             kind: NamedField(name, pr),\n             id: ast::DUMMY_NODE_ID,\n@@ -3427,7 +3459,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    // matches optbounds = ( ( : ( boundseq )? )? )\n+    // matches bounds    = ( boundseq )?\n     // where   boundseq  = ( bound + boundseq ) | bound\n     // and     bound     = 'static | ty\n     // Returns \"None\" if there's no colon (e.g. \"T\");\n@@ -3439,13 +3471,9 @@ impl<'a> Parser<'a> {\n     // AST doesn't support arbitrary lifetimes in bounds on type parameters. In\n     // the future, this flag should be removed, and the return value of this\n     // function should be Option<~[TyParamBound]>\n-    fn parse_optional_ty_param_bounds(&mut self, allow_any_lifetime: bool)\n-        -> (Option<ast::Lifetime>, Option<OwnedSlice<TyParamBound>>)\n-    {\n-        if !self.eat(&token::COLON) {\n-            return (None, None);\n-        }\n-\n+    fn parse_ty_param_bounds(&mut self, allow_any_lifetime: bool)\n+                             -> (Option<ast::Lifetime>,\n+                                 OwnedSlice<TyParamBound>) {\n         let mut ret_lifetime = None;\n         let mut result = vec!();\n         loop {\n@@ -3489,21 +3517,28 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return (ret_lifetime, Some(OwnedSlice::from_vec(result)));\n+        return (ret_lifetime, OwnedSlice::from_vec(result));\n     }\n \n     // matches typaram = type? IDENT optbounds ( EQ ty )?\n     fn parse_ty_param(&mut self) -> TyParam {\n         let sized = self.parse_sized();\n         let span = self.span;\n         let ident = self.parse_ident();\n-        let (_, opt_bounds) = self.parse_optional_ty_param_bounds(false);\n+        let opt_bounds = {\n+            if self.eat(&token::COLON) {\n+                let (_, bounds) = self.parse_ty_param_bounds(false);\n+                Some(bounds)\n+            } else {\n+                None\n+            }\n+        };\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n         let bounds = opt_bounds.unwrap_or_default();\n \n         let default = if self.token == token::EQ {\n             self.bump();\n-            Some(self.parse_ty(false))\n+            Some(self.parse_ty(true))\n         }\n         else { None };\n \n@@ -3548,7 +3583,7 @@ impl<'a> Parser<'a> {\n             Some(token::COMMA),\n             |p| {\n                 p.forbid_lifetime();\n-                p.parse_ty(false)\n+                p.parse_ty(true)\n             }\n         );\n         (lifetimes, result.into_vec())\n@@ -3804,7 +3839,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n         let output = if self.eat(&token::RARROW) {\n-            self.parse_ty(false)\n+            self.parse_ty(true)\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n@@ -3830,7 +3865,7 @@ impl<'a> Parser<'a> {\n                                      |p| p.parse_fn_block_arg());\n \n         let output = if self.eat(&token::RARROW) {\n-            self.parse_ty(false)\n+            self.parse_ty(true)\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n@@ -3942,7 +3977,7 @@ impl<'a> Parser<'a> {\n         let could_be_trait = self.token != token::LPAREN;\n \n         // Parse the trait.\n-        let mut ty = self.parse_ty(false);\n+        let mut ty = self.parse_ty(true);\n \n         // Parse traits, if necessary.\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n@@ -3965,7 +4000,7 @@ impl<'a> Parser<'a> {\n                 }\n             };\n \n-            ty = self.parse_ty(false);\n+            ty = self.parse_ty(true);\n             opt_trait_ref\n         } else {\n             None\n@@ -4008,7 +4043,7 @@ impl<'a> Parser<'a> {\n         let generics = self.parse_generics();\n \n         let super_struct = if self.eat(&token::COLON) {\n-            let ty = self.parse_ty(false);\n+            let ty = self.parse_ty(true);\n             match ty.node {\n                 TyPath(_, None, _) => {\n                     Some(ty)\n@@ -4051,7 +4086,7 @@ impl<'a> Parser<'a> {\n                 let struct_field_ = ast::StructField_ {\n                     kind: UnnamedField(p.parse_visibility()),\n                     id: ast::DUMMY_NODE_ID,\n-                    ty: p.parse_ty(false),\n+                    ty: p.parse_ty(true),\n                     attrs: attrs,\n                 };\n                 spanned(lo, p.span.hi, struct_field_)\n@@ -4205,7 +4240,7 @@ impl<'a> Parser<'a> {\n         let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = self.parse_ty(true);\n         self.expect(&token::EQ);\n         let e = self.parse_expr();\n         self.commit_expr_expecting(e, token::SEMI);\n@@ -4386,7 +4421,7 @@ impl<'a> Parser<'a> {\n \n         let ident = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = self.parse_ty(true);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n         box(GC) ast::ForeignItem {\n@@ -4514,7 +4549,7 @@ impl<'a> Parser<'a> {\n         let ident = self.parse_ident();\n         let tps = self.parse_generics();\n         self.expect(&token::EQ);\n-        let ty = self.parse_ty(false);\n+        let ty = self.parse_ty(true);\n         self.expect(&token::SEMI);\n         (ident, ItemTy(ty, tps), None)\n     }\n@@ -4562,7 +4597,7 @@ impl<'a> Parser<'a> {\n                     &token::LPAREN,\n                     &token::RPAREN,\n                     seq_sep_trailing_disallowed(token::COMMA),\n-                    |p| p.parse_ty(false)\n+                    |p| p.parse_ty(true)\n                 );\n                 for ty in arg_tys.move_iter() {\n                     args.push(ast::VariantArg {"}, {"sha": "63acdb1a6ca758d576e585cc630d9d932cf1aaa3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -495,6 +495,11 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.pclose());\n             }\n+            ast::TyParen(ref typ) => {\n+                try!(self.popen());\n+                try!(self.print_type(&**typ));\n+                try!(self.pclose());\n+            }\n             ast::TyBareFn(f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n@@ -1673,7 +1678,7 @@ impl<'a> State<'a> {\n \n         match *opt_bounds {\n             None => Ok(()),\n-            Some(ref bounds) => self.print_bounds(&None, bounds, true),\n+            Some(ref bounds) => self.print_bounds(&None, bounds, true, true),\n         }\n     }\n \n@@ -1932,9 +1937,16 @@ impl<'a> State<'a> {\n     pub fn print_bounds(&mut self,\n                         region: &Option<ast::Lifetime>,\n                         bounds: &OwnedSlice<ast::TyParamBound>,\n-                        print_colon_anyway: bool) -> IoResult<()> {\n+                        print_colon_anyway: bool,\n+                        print_plus_before_bounds: bool)\n+                        -> IoResult<()> {\n+        let separator = if print_plus_before_bounds {\n+            \"+\"\n+        } else {\n+            \":\"\n+        };\n         if !bounds.is_empty() || region.is_some() {\n-            try!(word(&mut self.s, \":\"));\n+            try!(word(&mut self.s, separator));\n             let mut first = true;\n             match *region {\n                 Some(ref lt) => {\n@@ -1976,7 +1988,7 @@ impl<'a> State<'a> {\n             }\n             Ok(())\n         } else if print_colon_anyway {\n-            word(&mut self.s, \":\")\n+            word(&mut self.s, separator)\n         } else {\n             Ok(())\n         }\n@@ -2011,7 +2023,10 @@ impl<'a> State<'a> {\n                             try!(s.word_space(\"type\"));\n                         }\n                         try!(s.print_ident(param.ident));\n-                        try!(s.print_bounds(&None, &param.bounds, false));\n+                        try!(s.print_bounds(&None,\n+                                            &param.bounds,\n+                                            false,\n+                                            false));\n                         match param.default {\n                             Some(ref default) => {\n                                 try!(space(&mut s.s));\n@@ -2214,7 +2229,7 @@ impl<'a> State<'a> {\n         }\n \n         opt_bounds.as_ref().map(|bounds| {\n-            self.print_bounds(opt_region, bounds, true)\n+            self.print_bounds(opt_region, bounds, true, false)\n         });\n \n         try!(self.maybe_print_comment(decl.output.span.lo));"}, {"sha": "6f0fc217533fc5070b25007d2bad6cfaa9aa9175", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -336,7 +336,7 @@ pub fn skip_ty<E, V: Visitor<E>>(_: &mut V, _: &Ty, _: E) {\n \n pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     match typ.node {\n-        TyUniq(ty) | TyVec(ty) | TyBox(ty) => {\n+        TyUniq(ty) | TyVec(ty) | TyBox(ty) | TyParen(ty) => {\n             visitor.visit_ty(&*ty, env)\n         }\n         TyPtr(ref mutable_type) => {"}, {"sha": "1592ffb6c6790b976f02901f91088a28717f3f88", "filename": "src/test/auxiliary/plugin_crate_outlive_expansion_phase.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -27,7 +27,7 @@ impl Drop for Foo {\n \n #[plugin_registrar]\n pub fn registrar(_: &mut Registry) {\n-    local_data_key!(foo: Box<Any:Send>);\n-    foo.replace(Some(box Foo { foo: 10 } as Box<Any:Send>));\n+    local_data_key!(foo: Box<Any+Send>);\n+    foo.replace(Some(box Foo { foo: 10 } as Box<Any+Send>));\n }\n "}, {"sha": "3028db00f5871801fdcd0c06cc12e91ebafa522d", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -31,7 +31,7 @@ struct A {\n }\n \n fn main() {\n-    let a = A {v: box B{v: None} as Box<Foo:Send>};\n+    let a = A {v: box B{v: None} as Box<Foo+Send>};\n     //~^ ERROR cannot pack type `~B`, which does not fulfill `Send`\n     let v = Rc::new(RefCell::new(a));\n     let w = v.clone();"}, {"sha": "651ea6abf08ccf4df8874f58b593815f014b5818", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -45,15 +45,15 @@ fn test<'a,T,U:Copy>(_: &'a int) {\n \n     // borrowed object types are generally ok\n     assert_copy::<&'a Dummy>();\n-    assert_copy::<&'a Dummy:Copy>();\n-    assert_copy::<&'static Dummy:Copy>();\n+    assert_copy::<&'a Dummy+Copy>();\n+    assert_copy::<&'static Dummy+Copy>();\n \n     // owned object types are not ok\n     assert_copy::<Box<Dummy>>(); //~ ERROR does not fulfill\n-    assert_copy::<Box<Dummy:Copy>>(); //~ ERROR does not fulfill\n+    assert_copy::<Box<Dummy+Copy>>(); //~ ERROR does not fulfill\n \n     // mutable object types are not ok\n-    assert_copy::<&'a mut Dummy:Copy>();  //~ ERROR does not fulfill\n+    assert_copy::<&'a mut Dummy+Copy>();  //~ ERROR does not fulfill\n \n     // closures are like an `&mut` object\n     assert_copy::<||>(); //~ ERROR does not fulfill"}, {"sha": "0414e64f1b7bf0dbc870da2506032d131178d332", "filename": "src/test/compile-fail/kindck-send.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -39,17 +39,17 @@ fn test<'a,T,U:Send>(_: &'a int) {\n     // careful with object types, who knows what they close over...\n     assert_send::<&'static Dummy>(); //~ ERROR does not fulfill `Send`\n     assert_send::<&'a Dummy>(); //~ ERROR does not fulfill `Send`\n-    assert_send::<&'a Dummy:Send>(); //~ ERROR does not fulfill `Send`\n-    assert_send::<Box<Dummy:>>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<Box<Dummy+>>(); //~ ERROR does not fulfill `Send`\n \n     // ...unless they are properly bounded\n-    assert_send::<&'static Dummy:Send>();\n-    assert_send::<Box<Dummy:Send>>();\n+    assert_send::<&'static Dummy+Send>();\n+    assert_send::<Box<Dummy+Send>>();\n \n     // but closure and object types can have lifetime bounds which make\n     // them not ok (FIXME #5121)\n     // assert_send::<proc:'a()>(); // ERROR does not fulfill `Send`\n-    // assert_send::<Box<Dummy:'a>>(); // ERROR does not fulfill `Send`\n+    // assert_send::<Box<Dummy+'a>>(); // ERROR does not fulfill `Send`\n \n     // unsafe ptrs are ok unless they point at unsendable things\n     assert_send::<*int>();"}, {"sha": "3737025da6c121274315238753fc22dc1c5e5afa", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -12,14 +12,14 @@\n trait Foo {\n }\n \n-fn a(_x: Box<Foo:Send>) {\n+fn a(_x: Box<Foo+Send>) {\n }\n \n-fn c(x: Box<Foo:Share+Send>) {\n+fn c(x: Box<Foo+Share+Send>) {\n     a(x);\n }\n \n-fn d(x: Box<Foo:>) {\n+fn d(x: Box<Foo+>) {\n     a(x); //~ ERROR found no bounds\n }\n "}, {"sha": "d548098ebe13ed8dadb9a9a48b7e4ac1303a0932", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -13,17 +13,17 @@\n \n trait Foo {}\n \n-fn a(_x: Box<Foo:Send>) {\n+fn a(_x: Box<Foo+Send>) {\n }\n \n-fn b(_x: &'static Foo) { // should be same as &'static Foo:'static\n+fn b(_x: &'static Foo) { // should be same as &'static Foo+'static\n }\n \n-fn c(x: Box<Foo:Share>) {\n+fn c(x: Box<Foo+Share>) {\n     a(x); //~ ERROR expected bounds `Send`\n }\n \n-fn d(x: &'static Foo:Share) {\n+fn d(x: &'static Foo+Share) {\n     b(x); //~ ERROR expected bounds `'static`\n }\n "}, {"sha": "c56eabbb3b4aae5468e9c6f9a9718079c28228ae", "filename": "src/test/run-fail/fail-macro-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -12,5 +12,5 @@\n \n \n fn main() {\n-    fail!(box 413 as Box<::std::any::Any:Send>);\n+    fail!(box 413 as Box<::std::any::Any+Send>);\n }"}, {"sha": "4fa695de5228dd89d7954ca8a77d95a97058d4da", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -33,7 +33,7 @@ fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>:> {\n     box Invoker {\n         a: a,\n         b: b,\n-    } as Box<Invokable<A>>:\n+    } as (Box<Invokable<A>>+)\n }\n \n pub fn main() {"}, {"sha": "0760f13200c8fcd813d6822da432249fc61c9735", "filename": "src/test/run-pass/as-precedence.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Fas-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Fas-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fas-precedence.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    assert_eq!(3 as uint * 3, 9);\n+    assert_eq!(3 as (uint) * 3, 9);\n+    assert_eq!(3 as (uint) / 3, 1);\n+    assert_eq!(3 as uint + 3, 6);\n+    assert_eq!(3 as (uint) + 3, 6);\n+}\n+"}, {"sha": "23607e16795edba637dce9a9a5de02de8200a3af", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -41,7 +41,7 @@ fn main() {\n     let (tx, rx) = channel();\n     let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n     spawn(proc() {\n-        set_logger(box MyWriter(w) as Box<Logger:Send>);\n+        set_logger(box MyWriter(w) as Box<Logger+Send>);\n         debug!(\"debug\");\n         info!(\"info\");\n     });"}, {"sha": "3d642be082c0ab3f25a857c50fa7f541f41b8aeb", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -33,11 +33,11 @@ impl<A:Clone> Invokable<A> for Invoker<A> {\n     }\n }\n \n-fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>:> {\n+fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>+> {\n     box Invoker {\n         a: a,\n         b: b,\n-    } as Box<Invokable<A>>:\n+    } as (Box<Invokable<A>>+)\n }\n \n pub fn main() {"}, {"sha": "d1bb0db511b8fea838959f520a59f1b03bff0611", "filename": "src/test/run-pass/trait-bounds-basic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -12,21 +12,21 @@\n trait Foo {\n }\n \n-fn a(_x: Box<Foo:>) {\n+fn a(_x: Box<Foo+>) {\n }\n \n-fn b(_x: Box<Foo:Send>) {\n+fn b(_x: Box<Foo+Send>) {\n }\n \n-fn c(x: Box<Foo:Share+Send>) {\n+fn c(x: Box<Foo+Share+Send>) {\n     a(x);\n }\n \n-fn d(x: Box<Foo:Send>) {\n+fn d(x: Box<Foo+Send>) {\n     b(x);\n }\n \n-fn e(x: Box<Foo>) { // sugar for Box<Foo:Owned>\n+fn e(x: Box<Foo>) { // sugar for Box<Foo+Owned>\n     a(x);\n }\n "}, {"sha": "18a0e5d471c4a91fa3134034c6334ab324fee4d6", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -71,10 +71,10 @@ pub fn main() {\n         swim_speed: 998,\n         name: \"alec_guinness\".to_string(),\n     };\n-    let arc = Arc::new(vec!(box catte  as Box<Pet:Share+Send>,\n-                            box dogge1 as Box<Pet:Share+Send>,\n-                            box fishe  as Box<Pet:Share+Send>,\n-                            box dogge2 as Box<Pet:Share+Send>));\n+    let arc = Arc::new(vec!(box catte  as Box<Pet+Share+Send>,\n+                            box dogge1 as Box<Pet+Share+Send>,\n+                            box fishe  as Box<Pet+Share+Send>,\n+                            box dogge2 as Box<Pet+Share+Send>));\n     let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n     task::spawn(proc() { check_legs(arc1); tx1.send(()); });\n@@ -89,21 +89,21 @@ pub fn main() {\n     rx3.recv();\n }\n \n-fn check_legs(arc: Arc<Vec<Box<Pet:Share+Send>>>) {\n+fn check_legs(arc: Arc<Vec<Box<Pet+Share+Send>>>) {\n     let mut legs = 0;\n     for pet in arc.iter() {\n         legs += pet.num_legs();\n     }\n     assert!(legs == 12);\n }\n-fn check_names(arc: Arc<Vec<Box<Pet:Share+Send>>>) {\n+fn check_names(arc: Arc<Vec<Box<Pet+Share+Send>>>) {\n     for pet in arc.iter() {\n         pet.name(|name| {\n             assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n         })\n     }\n }\n-fn check_pedigree(arc: Arc<Vec<Box<Pet:Share+Send>>>) {\n+fn check_pedigree(arc: Arc<Vec<Box<Pet+Share+Send>>>) {\n     for pet in arc.iter() {\n         assert!(pet.of_good_pedigree());\n     }"}, {"sha": "0f99998b7a6edc2eeed8de5de0c55ceb7273a07d", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -20,7 +20,7 @@ struct Tree(@RefCell<TreeR>);\n struct TreeR {\n     left: Option<Tree>,\n     right: Option<Tree>,\n-    val: Box<to_str:Send>\n+    val: Box<to_str+Send>\n }\n \n trait to_str {\n@@ -57,10 +57,10 @@ fn foo<T:to_str>(x: T) -> String { x.to_str_() }\n pub fn main() {\n     let t1 = Tree(@RefCell::new(TreeR{left: None,\n                                       right: None,\n-                                      val: box 1 as Box<to_str:Send>}));\n+                                      val: box 1 as Box<to_str+Send>}));\n     let t2 = Tree(@RefCell::new(TreeR{left: Some(t1),\n                                       right: Some(t1),\n-                                      val: box 2 as Box<to_str:Send>}));\n+                                      val: box 2 as Box<to_str+Send>}));\n     let expected =\n         \"[2, some([1, none, none]), some([1, none, none])]\".to_string();\n     assert!(t2.to_str_() == expected);"}, {"sha": "d8df5d5600c902d98ccc995c1d0645e1c1e27bd5", "filename": "src/test/run-pass/trait-contravariant-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Ftrait-contravariant-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b9ef442337ee3b9a29449a0792ae2eeb0480d0c/src%2Ftest%2Frun-pass%2Ftrait-contravariant-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-contravariant-self.rs?ref=9b9ef442337ee3b9a29449a0792ae2eeb0480d0c", "patch": "@@ -10,8 +10,8 @@\n \n // This is an interesting test case. We have a trait (Bar) that is\n // implemented for a `Box<Foo>` object (note: no bounds). And then we\n-// have a `Box<Foo:Send>` object. The impl for `Box<Foo>` is applicable\n-// to `Box<Foo:Send>` because:\n+// have a `Box<Foo+Send>` object. The impl for `Box<Foo>` is applicable\n+// to `Box<Foo+Send>` because:\n //\n // 1. The trait Bar is contravariant w/r/t Self because `Self` appears\n //    only in argument position.\n@@ -30,7 +30,7 @@ impl Bar for Box<Foo> { fn dummy(&self) { } }\n fn wants_bar<B:Bar>(b: &B) { }\n \n fn main() {\n-    let x: Box<Foo:Send> = (box SFoo);\n+    let x: Box<Foo+Send> = (box SFoo);\n     wants_bar(&x);\n }\n "}]}