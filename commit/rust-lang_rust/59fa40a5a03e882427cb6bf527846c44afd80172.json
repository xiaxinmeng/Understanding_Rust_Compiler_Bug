{"sha": "59fa40a5a03e882427cb6bf527846c44afd80172", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZmE0MGE1YTAzZTg4MjQyN2NiNmJmNTI3ODQ2YzQ0YWZkODAxNzI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-09T12:36:48Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-17T16:38:23Z"}, "message": "Filter out fields that should not be seen\n\nThis was previously done by giving those fields the type tyerr. This was\na hack.", "tree": {"sha": "f653943bc51e4b87949a6fc4687a0ff9edaed6f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f653943bc51e4b87949a6fc4687a0ff9edaed6f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59fa40a5a03e882427cb6bf527846c44afd80172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59fa40a5a03e882427cb6bf527846c44afd80172", "html_url": "https://github.com/rust-lang/rust/commit/59fa40a5a03e882427cb6bf527846c44afd80172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59fa40a5a03e882427cb6bf527846c44afd80172/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70b3872a128b6e73b94345355008f56faa2bef74", "url": "https://api.github.com/repos/rust-lang/rust/commits/70b3872a128b6e73b94345355008f56faa2bef74", "html_url": "https://github.com/rust-lang/rust/commit/70b3872a128b6e73b94345355008f56faa2bef74"}], "stats": {"total": 161, "additions": 113, "deletions": 48}, "files": [{"sha": "f8c2e7a4ae39b4440b67f40bd9c6829e84dca341", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 113, "deletions": 48, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/59fa40a5a03e882427cb6bf527846c44afd80172/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59fa40a5a03e882427cb6bf527846c44afd80172/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=59fa40a5a03e882427cb6bf527846c44afd80172", "patch": "@@ -242,7 +242,7 @@ use rustc_hir::{HirId, RangeEnd};\n use rustc_middle::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n use rustc_middle::mir::Field;\n use rustc_middle::ty::layout::IntegerExt;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeFoldable, VariantDef};\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n@@ -591,7 +591,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    // Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n+    /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n     crate fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind {\n             ty::Adt(def, ..) => {\n@@ -600,15 +600,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             _ => false,\n         }\n     }\n-\n-    // Returns whether the given variant is from another crate and has its fields declared\n-    // `#[non_exhaustive]`.\n-    fn is_foreign_non_exhaustive_variant(&self, ty: Ty<'tcx>, variant: &VariantDef) -> bool {\n-        match ty.kind {\n-            ty::Adt(def, ..) => variant.is_field_list_non_exhaustive() && !def.did.is_local(),\n-            _ => false,\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -876,7 +867,7 @@ impl<'tcx> Constructor<'tcx> {\n         ty: Ty<'tcx>,\n         fields: Fields<'p, 'tcx>,\n     ) -> Pat<'tcx> {\n-        let mut subpatterns = fields.into_iter().cloned();\n+        let mut subpatterns = fields.all_patterns();\n \n         let pat = match self {\n             Single | Variant(_) => match ty.kind {\n@@ -945,12 +936,45 @@ impl<'tcx> Constructor<'tcx> {\n     }\n }\n \n+#[derive(Debug, Copy, Clone)]\n+enum FilteredField<'p, 'tcx> {\n+    Kept(&'p Pat<'tcx>),\n+    Hidden(Ty<'tcx>),\n+}\n+\n+impl<'p, 'tcx> FilteredField<'p, 'tcx> {\n+    fn kept(self) -> Option<&'p Pat<'tcx>> {\n+        match self {\n+            FilteredField::Kept(p) => Some(p),\n+            FilteredField::Hidden(_) => None,\n+        }\n+    }\n+\n+    fn to_pattern(self) -> Pat<'tcx> {\n+        match self {\n+            FilteredField::Kept(p) => p.clone(),\n+            FilteredField::Hidden(ty) => Pat::wildcard_from_ty(ty),\n+        }\n+    }\n+}\n+\n /// A value can be decomposed into a constructor applied to some fields. This struct represents\n /// those fields, generalized to allow patterns in each field. See also `Constructor`.\n+///\n+/// If a private or `non_exhaustive` field is uninhabited, the code mustn't observe that it is\n+/// uninhabited. For that, we filter these fields out of the matrix. This is subtle because we\n+/// still need to have those fields back when going to/from a `Pat`. Mot of this is handled\n+/// automatically in `Fields`, but when constructing or deconstructing fields you need to use the\n+/// correct method. As a rule, when going to/from the matrix, use the filtered field list; when\n+/// going to/from `Pat`, use the full field list.\n+/// This filtering is uncommon in practice, because uninhabited fields are rarely used.\n #[derive(Debug, Clone)]\n enum Fields<'p, 'tcx> {\n+    /// Lists of patterns that don't contain any filtered fields.\n     Slice(&'p [Pat<'tcx>]),\n     Vec(SmallVec<[&'p Pat<'tcx>; 2]>),\n+    /// Patterns where some of the fields need to be hidden.\n+    Filtered(SmallVec<[FilteredField<'p, 'tcx>; 2]>),\n }\n \n impl<'p, 'tcx> Fields<'p, 'tcx> {\n@@ -964,7 +988,9 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         Fields::Slice(std::slice::from_ref(pat))\n     }\n \n-    fn from_vec(pats: SmallVec<[&'p Pat<'tcx>; 2]>) -> Self {\n+    /// Construct a new `Fields` from the given patterns. You must be sure those patterns can't\n+    /// contain fields that need to be filtered out. When in doubt, prefer `replace_fields`.\n+    fn from_vec_unfiltered(pats: SmallVec<[&'p Pat<'tcx>; 2]>) -> Self {\n         Fields::Vec(pats)\n     }\n \n@@ -999,26 +1025,40 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         Fields::from_single_pattern(wildcard_from_ty(substs.type_at(0)))\n                     } else {\n                         let variant = &adt.variants[constructor.variant_index_for_adt(cx, adt)];\n-                        let is_non_exhaustive = cx.is_foreign_non_exhaustive_variant(ty, variant);\n-                        Fields::wildcards_from_tys(\n-                            cx,\n-                            variant.fields.iter().map(|field| {\n-                                let ty = field.ty(cx.tcx, substs);\n-                                let is_visible = adt.is_enum()\n-                                    || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                                let is_inhabited = !cx.is_uninhabited(ty);\n-                                // Treat all uninhabited non-visible fields as `TyErr`. They can't\n-                                // appear in any other pattern from this match (because they are\n-                                // private), so their type does not matter - but we don't want\n-                                // to know they are uninhabited.\n-                                // Also treat all uninhabited types in non-exhaustive variants as\n-                                // `TyErr`.\n-                                let allowed_to_inspect =\n-                                    is_inhabited || (is_visible && !is_non_exhaustive);\n-\n-                                if allowed_to_inspect { ty } else { cx.tcx.types.err }\n-                            }),\n-                        )\n+                        // Whether we must not match the fields of this variant exhaustively.\n+                        let is_non_exhaustive =\n+                            variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n+                        let field_tys = variant.fields.iter().map(|field| field.ty(cx.tcx, substs));\n+                        // In the following cases, we don't need to filter out any fields. This is\n+                        // the vast majority of real cases, since uninhabited fields are uncommon.\n+                        let has_no_hidden_fields = (adt.is_enum() && !is_non_exhaustive)\n+                            || !field_tys.clone().any(|ty| cx.is_uninhabited(ty));\n+\n+                        if has_no_hidden_fields {\n+                            Fields::wildcards_from_tys(cx, field_tys)\n+                        } else {\n+                            let fields = variant\n+                                .fields\n+                                .iter()\n+                                .map(|field| {\n+                                    let ty = field.ty(cx.tcx, substs);\n+                                    let is_visible = adt.is_enum()\n+                                        || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                                    let is_uninhabited = cx.is_uninhabited(ty);\n+\n+                                    // In the cases of either a `#[non_exhaustive]` field list\n+                                    // or a non-public field, we hide uninhabited fields in\n+                                    // order not to reveal the uninhabitedness of the whole\n+                                    // variant.\n+                                    if is_uninhabited && (!is_visible || is_non_exhaustive) {\n+                                        FilteredField::Hidden(ty)\n+                                    } else {\n+                                        FilteredField::Kept(wildcard_from_ty(ty))\n+                                    }\n+                                })\n+                                .collect();\n+                            Fields::Filtered(fields)\n+                        }\n                     }\n                 }\n                 _ => Fields::empty(),\n@@ -1038,29 +1078,30 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         match self {\n             Fields::Slice(pats) => pats.len(),\n             Fields::Vec(pats) => pats.len(),\n+            Fields::Filtered(fields) => fields.iter().filter(|p| p.kept().is_some()).count(),\n         }\n     }\n \n-    fn into_iter(self) -> impl Iterator<Item = &'p Pat<'tcx>> {\n-        let pats: SmallVec<_> = match self {\n-            Fields::Slice(pats) => pats.iter().collect(),\n-            Fields::Vec(pats) => pats,\n+    /// Returns the complete list of patterns, including hidden fields.\n+    fn all_patterns(self) -> impl Iterator<Item = Pat<'tcx>> {\n+        let pats: SmallVec<[_; 2]> = match self {\n+            Fields::Slice(pats) => pats.iter().cloned().collect(),\n+            Fields::Vec(pats) => pats.into_iter().cloned().collect(),\n+            Fields::Filtered(fields) => {\n+                // We don't skip any fields here.\n+                fields.into_iter().map(|p| p.to_pattern()).collect()\n+            }\n         };\n         pats.into_iter()\n     }\n \n     /// Overrides some of the fields with the provided patterns.\n     fn replace_with_fieldpats(\n         &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n         new_pats: impl IntoIterator<Item = &'p FieldPat<'tcx>>,\n-        is_non_exhaustive: bool,\n     ) -> Self {\n         self.replace_fields_indexed(\n-            new_pats\n-                .into_iter()\n-                .map(|pat| (pat.field.index(), &pat.pattern))\n-                .filter(|(_, pat)| !(is_non_exhaustive && cx.is_uninhabited(pat.ty))),\n+            new_pats.into_iter().map(|pat| (pat.field.index(), &pat.pattern)),\n         )\n     }\n \n@@ -1080,6 +1121,13 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                     pats[i] = pat\n                 }\n             }\n+            Fields::Filtered(fields) => {\n+                for (i, pat) in new_pats {\n+                    if let FilteredField::Kept(p) = &mut fields[i] {\n+                        *p = pat\n+                    }\n+                }\n+            }\n             Fields::Slice(_) => unreachable!(),\n         }\n         fields\n@@ -1093,7 +1141,21 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         pats: impl IntoIterator<Item = Pat<'tcx>>,\n     ) -> Self {\n         let pats: &[_] = cx.pattern_arena.alloc_from_iter(pats);\n-        Fields::Slice(pats)\n+\n+        match self {\n+            Fields::Filtered(fields) => {\n+                let mut pats = pats.iter();\n+                let mut fields = fields.clone();\n+                for f in &mut fields {\n+                    if let FilteredField::Kept(p) = f {\n+                        // We take one input pattern for each `Kept` field, in order.\n+                        *p = pats.next().unwrap();\n+                    }\n+                }\n+                Fields::Filtered(fields)\n+            }\n+            _ => Fields::Slice(pats),\n+        }\n     }\n \n     fn push_on_patstack(self, stack: &[&'p Pat<'tcx>]) -> PatStack<'p, 'tcx> {\n@@ -1103,6 +1165,10 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 pats.extend_from_slice(stack);\n                 pats\n             }\n+            Fields::Filtered(fields) => {\n+                // We skip hidden fields here\n+                fields.into_iter().filter_map(|p| p.kept()).chain(stack.iter().copied()).collect()\n+            }\n         };\n         PatStack::from_vec(pats)\n     }\n@@ -2411,12 +2477,11 @@ fn specialize_one_pattern<'p, 'tcx>(\n             if constructor != &Variant(variant.def_id) {\n                 return None;\n             }\n-            let is_non_exhaustive = cx.is_foreign_non_exhaustive_variant(pat.ty, variant);\n-            Some(ctor_wild_subpatterns.replace_with_fieldpats(cx, subpatterns, is_non_exhaustive))\n+            Some(ctor_wild_subpatterns.replace_with_fieldpats(subpatterns))\n         }\n \n         PatKind::Leaf { ref subpatterns } => {\n-            Some(ctor_wild_subpatterns.replace_with_fieldpats(cx, subpatterns, false))\n+            Some(ctor_wild_subpatterns.replace_with_fieldpats(subpatterns))\n         }\n \n         PatKind::Deref { ref subpattern } => Some(Fields::from_single_pattern(subpattern)),\n@@ -2485,7 +2550,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n                     Some(&*cx.pattern_arena.alloc(pattern))\n                 })\n                 .collect::<Option<_>>()?;\n-            Some(Fields::from_vec(pats))\n+            Some(Fields::from_vec_unfiltered(pats))\n         }\n \n         PatKind::Constant { .. } | PatKind::Range { .. } => {"}]}