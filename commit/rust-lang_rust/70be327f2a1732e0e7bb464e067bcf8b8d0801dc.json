{"sha": "70be327f2a1732e0e7bb464e067bcf8b8d0801dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwYmUzMjdmMmExNzMyZTBlN2JiNDY0ZTA2N2JjZjhiOGQwODAxZGM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-01-24T21:10:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-24T21:10:01Z"}, "message": "Rollup merge of #81279 - bugadani:iter, r=davidtwco\n\nSmall refactor in typeck\n\n - `check_impl_items_against_trait` only queries and walks through associated items once\n - extracted function that reports errors\n - don't check specialization validity when trait item does not match\n - small additional cleanups", "tree": {"sha": "33befe417d225692f369e0e54a5c18955cc6eb70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33befe417d225692f369e0e54a5c18955cc6eb70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70be327f2a1732e0e7bb464e067bcf8b8d0801dc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgDeIpCRBK7hj4Ov3rIwAAdHIIAGKI5kEWuWX3Mc1sFLRIqpzP\nCRIrKCvtEPHyP3dufn9f440KyvaCzpN1gVHKUFf0DL5cVWkuKfy8iWeYjPQOgtHp\nSFCc4D1/FfsLEUf+7msfmmsm01ndJolskBQ8J4DQP8V4XsBP6QLxq+/0ZFaPU1xz\nzFKLmE3hGn35JragU/kYbMUrUzuSFgCGrDmAuXsuFKVJAnQ+z4z2iINqBBD5a/Xn\nFcVa4iywKIGuF35CWFZnZZq0PiyUhIIP6h2wMN7Nf8w0i3Mzz0qwmIXO3yOdj0Ew\no1IXOUylT4DkF+QWy1oNMtxJe7pK5re73KwxtPG/SqO/j6GEP5OlYwi81WTVBz0=\n=+N23\n-----END PGP SIGNATURE-----\n", "payload": "tree 33befe417d225692f369e0e54a5c18955cc6eb70\nparent 504d6de52dfeab6086239180a92ff0bb5df2bb19\nparent f29b32983d1e885b0e141b6aac2cae281ff39a22\nauthor Jonas Schievink <jonasschievink@gmail.com> 1611522601 +0100\ncommitter GitHub <noreply@github.com> 1611522601 +0100\n\nRollup merge of #81279 - bugadani:iter, r=davidtwco\n\nSmall refactor in typeck\n\n - `check_impl_items_against_trait` only queries and walks through associated items once\n - extracted function that reports errors\n - don't check specialization validity when trait item does not match\n - small additional cleanups\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70be327f2a1732e0e7bb464e067bcf8b8d0801dc", "html_url": "https://github.com/rust-lang/rust/commit/70be327f2a1732e0e7bb464e067bcf8b8d0801dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70be327f2a1732e0e7bb464e067bcf8b8d0801dc/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "504d6de52dfeab6086239180a92ff0bb5df2bb19", "url": "https://api.github.com/repos/rust-lang/rust/commits/504d6de52dfeab6086239180a92ff0bb5df2bb19", "html_url": "https://github.com/rust-lang/rust/commit/504d6de52dfeab6086239180a92ff0bb5df2bb19"}, {"sha": "f29b32983d1e885b0e141b6aac2cae281ff39a22", "url": "https://api.github.com/repos/rust-lang/rust/commits/f29b32983d1e885b0e141b6aac2cae281ff39a22", "html_url": "https://github.com/rust-lang/rust/commit/f29b32983d1e885b0e141b6aac2cae281ff39a22"}], "stats": {"total": 242, "additions": 129, "deletions": 113}, "files": [{"sha": "47361092a5c50a83dbe48008f73a375b5a9129b0", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 129, "deletions": 113, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/70be327f2a1732e0e7bb464e067bcf8b8d0801dc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70be327f2a1732e0e7bb464e067bcf8b8d0801dc/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=70be327f2a1732e0e7bb464e067bcf8b8d0801dc", "patch": "@@ -846,21 +846,13 @@ pub(super) fn check_specialization_validity<'tcx>(\n         Ok(ancestors) => ancestors,\n         Err(_) => return,\n     };\n-    let mut ancestor_impls = ancestors\n-        .skip(1)\n-        .filter_map(|parent| {\n-            if parent.is_from_trait() {\n-                None\n-            } else {\n-                Some((parent, parent.item(tcx, trait_item.ident, kind, trait_def.def_id)))\n-            }\n-        })\n-        .peekable();\n-\n-    if ancestor_impls.peek().is_none() {\n-        // No parent, nothing to specialize.\n-        return;\n-    }\n+    let mut ancestor_impls = ancestors.skip(1).filter_map(|parent| {\n+        if parent.is_from_trait() {\n+            None\n+        } else {\n+            Some((parent, parent.item(tcx, trait_item.ident, kind, trait_def.def_id)))\n+        }\n+    });\n \n     let opt_result = ancestor_impls.find_map(|(parent_impl, parent_item)| {\n         match parent_item {\n@@ -902,8 +894,6 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n-    let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n-\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n     // isn't populated for such impls.\n@@ -931,111 +921,75 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n \n     // Locate trait definition and items\n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n-\n-    let impl_items = || impl_item_refs.iter().map(|iiref| tcx.hir().impl_item(iiref.id));\n+    let impl_items = impl_item_refs.iter().map(|iiref| tcx.hir().impl_item(iiref.id));\n+    let associated_items = tcx.associated_items(impl_trait_ref.def_id);\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n-    for impl_item in impl_items() {\n-        let namespace = impl_item.kind.namespace();\n+    for impl_item in impl_items {\n         let ty_impl_item = tcx.associated_item(tcx.hir().local_def_id(impl_item.hir_id));\n-        let ty_trait_item = tcx\n-            .associated_items(impl_trait_ref.def_id)\n-            .find_by_name_and_namespace(tcx, ty_impl_item.ident, namespace, impl_trait_ref.def_id)\n-            .or_else(|| {\n-                // Not compatible, but needed for the error message\n-                tcx.associated_items(impl_trait_ref.def_id)\n-                    .filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id)\n-                    .next()\n-            });\n-\n-        // Check that impl definition matches trait definition\n-        if let Some(ty_trait_item) = ty_trait_item {\n+\n+        let mut items =\n+            associated_items.filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id);\n+\n+        let (compatible_kind, ty_trait_item) = if let Some(ty_trait_item) = items.next() {\n+            let is_compatible = |ty: &&ty::AssocItem| match (ty.kind, &impl_item.kind) {\n+                (ty::AssocKind::Const, hir::ImplItemKind::Const(..)) => true,\n+                (ty::AssocKind::Fn, hir::ImplItemKind::Fn(..)) => true,\n+                (ty::AssocKind::Type, hir::ImplItemKind::TyAlias(..)) => true,\n+                _ => false,\n+            };\n+\n+            // If we don't have a compatible item, we'll use the first one whose name matches\n+            // to report an error.\n+            let mut compatible_kind = is_compatible(&ty_trait_item);\n+            let mut trait_item = ty_trait_item;\n+\n+            if !compatible_kind {\n+                if let Some(ty_trait_item) = items.find(is_compatible) {\n+                    compatible_kind = true;\n+                    trait_item = ty_trait_item;\n+                }\n+            }\n+\n+            (compatible_kind, trait_item)\n+        } else {\n+            continue;\n+        };\n+\n+        if compatible_kind {\n             match impl_item.kind {\n                 hir::ImplItemKind::Const(..) => {\n                     // Find associated const definition.\n-                    if ty_trait_item.kind == ty::AssocKind::Const {\n-                        compare_const_impl(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0323,\n-                            \"item `{}` is an associated const, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        // We can only get the spans from local trait definition\n-                        // Same for E0324 and E0325\n-                        if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n+                    compare_const_impl(\n+                        tcx,\n+                        &ty_impl_item,\n+                        impl_item.span,\n+                        &ty_trait_item,\n+                        impl_trait_ref,\n+                    );\n                 }\n                 hir::ImplItemKind::Fn(..) => {\n                     let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    if ty_trait_item.kind == ty::AssocKind::Fn {\n-                        compare_impl_method(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                            opt_trait_span,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0324,\n-                            \"item `{}` is an associated method, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        if let Some(trait_span) = opt_trait_span {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n+                    compare_impl_method(\n+                        tcx,\n+                        &ty_impl_item,\n+                        impl_item.span,\n+                        &ty_trait_item,\n+                        impl_trait_ref,\n+                        opt_trait_span,\n+                    );\n                 }\n                 hir::ImplItemKind::TyAlias(_) => {\n                     let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    if ty_trait_item.kind == ty::AssocKind::Type {\n-                        compare_ty_impl(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                            opt_trait_span,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0325,\n-                            \"item `{}` is an associated type, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        if let Some(trait_span) = opt_trait_span {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n+                    compare_ty_impl(\n+                        tcx,\n+                        &ty_impl_item,\n+                        impl_item.span,\n+                        &ty_trait_item,\n+                        impl_trait_ref,\n+                        opt_trait_span,\n+                    );\n                 }\n             }\n \n@@ -1046,12 +1000,22 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n                 impl_id.to_def_id(),\n                 impl_item,\n             );\n+        } else {\n+            report_mismatch_error(\n+                tcx,\n+                ty_trait_item.def_id,\n+                impl_trait_ref,\n+                impl_item,\n+                &ty_impl_item,\n+            );\n         }\n     }\n \n-    // Check for missing items from trait\n-    let mut missing_items = Vec::new();\n     if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id.to_def_id()) {\n+        let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n+\n+        // Check for missing items from trait\n+        let mut missing_items = Vec::new();\n         for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n             let is_implemented = ancestors\n                 .leaf_def(tcx, trait_item.ident, trait_item.kind)\n@@ -1064,11 +1028,63 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n                 }\n             }\n         }\n+\n+        if !missing_items.is_empty() {\n+            missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n+        }\n     }\n+}\n+\n+#[inline(never)]\n+#[cold]\n+fn report_mismatch_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_item_def_id: DefId,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    impl_item: &hir::ImplItem<'_>,\n+    ty_impl_item: &ty::AssocItem,\n+) {\n+    let mut err = match impl_item.kind {\n+        hir::ImplItemKind::Const(..) => {\n+            // Find associated const definition.\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0323,\n+                \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n+                ty_impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+\n+        hir::ImplItemKind::Fn(..) => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0324,\n+                \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n+                ty_impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n \n-    if !missing_items.is_empty() {\n-        missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n+        hir::ImplItemKind::TyAlias(_) => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0325,\n+                \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n+                ty_impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+    };\n+\n+    err.span_label(impl_item.span, \"does not match trait\");\n+    if let Some(trait_span) = tcx.hir().span_if_local(trait_item_def_id) {\n+        err.span_label(trait_span, \"item in trait\");\n     }\n+    err.emit();\n }\n \n /// Checks whether a type can be represented in memory. In particular, it"}]}