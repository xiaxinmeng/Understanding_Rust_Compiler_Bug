{"sha": "6c2d875261e10105dcfcbd9be84d05a730edd235", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMmQ4NzUyNjFlMTAxMDVkY2ZjYmQ5YmU4NGQwNWE3MzBlZGQyMzU=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-02T06:02:57Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-27T15:28:35Z"}, "message": "Make &Slice a thin pointer", "tree": {"sha": "490055facae889ab36bd2025ef326eae63767333", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/490055facae889ab36bd2025ef326eae63767333"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c2d875261e10105dcfcbd9be84d05a730edd235", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2d875261e10105dcfcbd9be84d05a730edd235", "html_url": "https://github.com/rust-lang/rust/commit/6c2d875261e10105dcfcbd9be84d05a730edd235", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c2d875261e10105dcfcbd9be84d05a730edd235/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a52b01bc67068fbd30206db53f2a3461f65e629e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a52b01bc67068fbd30206db53f2a3461f65e629e", "html_url": "https://github.com/rust-lang/rust/commit/a52b01bc67068fbd30206db53f2a3461f65e629e"}], "stats": {"total": 182, "additions": 134, "deletions": 48}, "files": [{"sha": "b6a81596d06cc7ea1997757b83f669e023ab9236", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6c2d875261e10105dcfcbd9be84d05a730edd235/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2d875261e10105dcfcbd9be84d05a730edd235/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=6c2d875261e10105dcfcbd9be84d05a730edd235", "patch": "@@ -314,17 +314,15 @@ impl DroplessArena {\n         false\n     }\n \n-    fn align_for<T>(&self) {\n-        let align = mem::align_of::<T>();\n+    fn align(&self, align: usize) {\n         let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n         self.ptr.set(final_address as *mut u8);\n         assert!(self.ptr <= self.end);\n     }\n \n     #[inline(never)]\n     #[cold]\n-    fn grow<T>(&self, n: usize) {\n-        let needed_bytes = n * mem::size_of::<T>();\n+    fn grow(&self, needed_bytes: usize) {\n         unsafe {\n             let mut chunks = self.chunks.borrow_mut();\n             let (chunk, mut new_capacity);\n@@ -356,25 +354,38 @@ impl DroplessArena {\n     }\n \n     #[inline]\n-    pub fn alloc<T>(&self, object: T) -> &mut T {\n+    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n         unsafe {\n-            assert!(!mem::needs_drop::<T>());\n-            assert!(mem::size_of::<T>() != 0);\n+            assert!(bytes != 0);\n+\n+            self.align(align);\n \n-            self.align_for::<T>();\n-            let future_end = intrinsics::arith_offset(self.ptr.get(), mem::size_of::<T>() as isize);\n+            let future_end = intrinsics::arith_offset(self.ptr.get(), bytes as isize);\n             if (future_end as *mut u8) >= self.end.get() {\n-                self.grow::<T>(1)\n+                self.grow(bytes);\n             }\n \n             let ptr = self.ptr.get();\n             // Set the pointer past ourselves\n             self.ptr.set(\n-                intrinsics::arith_offset(self.ptr.get(), mem::size_of::<T>() as isize) as *mut u8,\n+                intrinsics::arith_offset(self.ptr.get(), bytes as isize) as *mut u8,\n             );\n+            slice::from_raw_parts_mut(ptr, bytes)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc<T>(&self, object: T) -> &mut T {\n+        assert!(!mem::needs_drop::<T>());\n+\n+        let mem = self.alloc_raw(\n+            mem::size_of::<T>(),\n+            mem::align_of::<T>()) as *mut _ as *mut T;\n+\n+        unsafe {\n             // Write into uninitialized memory.\n-            ptr::write(ptr as *mut T, object);\n-            &mut *(ptr as *mut T)\n+            ptr::write(mem, object);\n+            &mut *mem\n         }\n     }\n \n@@ -393,21 +404,13 @@ impl DroplessArena {\n         assert!(!mem::needs_drop::<T>());\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n-        self.align_for::<T>();\n \n-        let future_end = unsafe {\n-            intrinsics::arith_offset(self.ptr.get(), (slice.len() * mem::size_of::<T>()) as isize)\n-        };\n-        if (future_end as *mut u8) >= self.end.get() {\n-            self.grow::<T>(slice.len());\n-        }\n+        let mem = self.alloc_raw(\n+            slice.len() * mem::size_of::<T>(),\n+            mem::align_of::<T>()) as *mut _ as *mut T;\n \n         unsafe {\n-            let arena_slice = slice::from_raw_parts_mut(self.ptr.get() as *mut T, slice.len());\n-            self.ptr.set(intrinsics::arith_offset(\n-                self.ptr.get(),\n-                (slice.len() * mem::size_of::<T>()) as isize,\n-            ) as *mut u8);\n+            let arena_slice = slice::from_raw_parts_mut(mem, slice.len());\n             arena_slice.copy_from_slice(slice);\n             arena_slice\n         }\n@@ -464,6 +467,12 @@ impl SyncDroplessArena {\n         self.lock.lock().in_arena(ptr)\n     }\n \n+    #[inline(always)]\n+    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n+        // Extend the lifetime of the result since it's limited to the lock guard\n+        unsafe { &mut *(self.lock.lock().alloc_raw(bytes, align) as *mut [u8]) }\n+    }\n+\n     #[inline(always)]\n     pub fn alloc<T>(&self, object: T) -> &mut T {\n         // Extend the lifetime of the result since it's limited to the lock guard"}, {"sha": "e8402487c7dd8ce28c85aca675bd1c9a316b999f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c2d875261e10105dcfcbd9be84d05a730edd235/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2d875261e10105dcfcbd9be84d05a730edd235/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6c2d875261e10105dcfcbd9be84d05a730edd235", "patch": "@@ -54,6 +54,7 @@\n #![feature(macro_vis_matcher)]\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]\n+#![feature(extern_types)]\n #![feature(non_exhaustive)]\n #![feature(proc_macro_internals)]\n #![feature(quote)]"}, {"sha": "3580926d8ad239f54f4679d027aaa893fab506e8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6c2d875261e10105dcfcbd9be84d05a730edd235/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2d875261e10105dcfcbd9be84d05a730edd235/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6c2d875261e10105dcfcbd9be84d05a730edd235", "patch": "@@ -2056,9 +2056,8 @@ for Interned<'tcx, Slice<Goal<'tcx>>> {\n \n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n-                                            $alloc_method:ident,\n+                                            $alloc_method:expr,\n                                             $alloc_to_key:expr,\n-                                            $alloc_to_ret:expr,\n                                             $keep_in_local_tcx:expr) -> $ty:ty) => {\n         impl<'a, 'gcx, $lt_tcx> TyCtxt<'a, 'gcx, $lt_tcx> {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n@@ -2081,7 +2080,7 @@ macro_rules! intern_method {\n                              v);\n                     }\n \n-                    let i = ($alloc_to_ret)(self.interners.arena.$alloc_method(v));\n+                    let i = $alloc_method(&self.interners.arena, v);\n                     interner.insert(Interned(i));\n                     i\n                 } else {\n@@ -2094,7 +2093,9 @@ macro_rules! intern_method {\n                     let v = unsafe {\n                         mem::transmute(v)\n                     };\n-                    let i = ($alloc_to_ret)(self.global_interners.arena.$alloc_method(v));\n+                    let i: &$lt_tcx $ty = $alloc_method(&self.global_interners.arena, v);\n+                    // Cast to 'gcx\n+                    let i = unsafe { mem::transmute(i) };\n                     interner.insert(Interned(i));\n                     i\n                 }\n@@ -2121,8 +2122,10 @@ macro_rules! direct_interners {\n \n         intern_method!(\n             $lt_tcx,\n-            $name: $method($ty, alloc, |x| x, |x| x, $keep_in_local_tcx) -> $ty\n-        );)+\n+            $name: $method($ty,\n+                           |a: &$lt_tcx SyncDroplessArena, v| -> &$lt_tcx $ty { a.alloc(v) },\n+                           |x| x,\n+                           $keep_in_local_tcx) -> $ty);)+\n     }\n }\n \n@@ -2137,10 +2140,11 @@ direct_interners!('tcx,\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ident)),+) => (\n-        $(intern_method!('tcx, $field: $method(&[$ty<'tcx>], alloc_slice, Deref::deref,\n-                                               |xs: &[$ty]| -> &Slice<$ty> {\n-            unsafe { mem::transmute(xs) }\n-        }, |xs: &[$ty]| xs.iter().any(keep_local)) -> Slice<$ty<'tcx>>);)+\n+        $(intern_method!( 'tcx, $field: $method(\n+            &[$ty<'tcx>],\n+            |a, v| Slice::from_arena(a, v),\n+            Deref::deref,\n+            |xs: &[$ty]| xs.iter().any(keep_local)) -> Slice<$ty<'tcx>>);)+\n     )\n }\n \n@@ -2162,9 +2166,8 @@ intern_method! {\n     'tcx,\n     canonical_var_infos: _intern_canonical_var_infos(\n         &[CanonicalVarInfo],\n-        alloc_slice,\n+        |a, v| Slice::from_arena(a, v),\n         Deref::deref,\n-        |xs: &[CanonicalVarInfo]| -> &Slice<CanonicalVarInfo> { unsafe { mem::transmute(xs) } },\n         |_xs: &[CanonicalVarInfo]| -> bool { false }\n     ) -> Slice<CanonicalVarInfo>\n }"}, {"sha": "a4ca0c417015152b5c5ef55d547da18fe895d010", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 83, "deletions": 10, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6c2d875261e10105dcfcbd9be84d05a730edd235/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2d875261e10105dcfcbd9be84d05a730edd235/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6c2d875261e10105dcfcbd9be84d05a730edd235", "patch": "@@ -36,12 +36,14 @@ use ty::util::{IntTypeExt, Discr};\n use ty::walk::TypeWalker;\n use util::captures::Captures;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use arena::SyncDroplessArena;\n \n use serialize::{self, Encodable, Encoder};\n use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n+use std::marker::PhantomData;\n use std::ops::Deref;\n use rustc_data_structures::sync::Lrc;\n use std::slice;\n@@ -582,54 +584,120 @@ impl <'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for Ty<'tcx> {\n     }\n }\n \n+extern {\n+    /// A dummy type used to force Slice to by unsized without requiring fat pointers\n+    type OpaqueSliceContents;\n+}\n+\n /// A wrapper for slices with the additional invariant\n /// that the slice is interned and no other slice with\n /// the same contents can exist in the same context.\n /// This means we can use pointer + length for both\n /// equality comparisons and hashing.\n-#[derive(Debug, RustcEncodable)]\n-pub struct Slice<T>([T]);\n+pub struct Slice<T>(PhantomData<T>, OpaqueSliceContents);\n+\n+impl<T> Slice<T> {\n+    /// Returns the offset of the array\n+    #[inline(always)]\n+    fn offset() -> usize {\n+        // Align up the size of the len (usize) field\n+        let align = mem::align_of::<T>();\n+        let align_mask = align - 1;\n+        let offset = mem::size_of::<usize>();\n+        (offset + align_mask) & !align_mask\n+    }\n+}\n+\n+impl<T: Copy> Slice<T> {\n+    #[inline]\n+    fn from_arena<'tcx>(arena: &'tcx SyncDroplessArena, slice: &[T]) -> &'tcx Slice<T> {\n+        assert!(!mem::needs_drop::<T>());\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(slice.len() != 0);\n+\n+        let offset = Slice::<T>::offset();\n+        let size = offset + slice.len() * mem::size_of::<T>();\n+\n+        let mem: *mut u8 = arena.alloc_raw(\n+            size,\n+            cmp::max(mem::align_of::<T>(), mem::align_of::<usize>())).as_mut_ptr();\n+\n+        unsafe {\n+            // Write the length\n+            *(mem as *mut usize) = slice.len();\n+\n+            // Write the elements\n+            let arena_slice = slice::from_raw_parts_mut(\n+                mem.offset(offset as isize) as *mut T,\n+                slice.len());\n+            arena_slice.copy_from_slice(slice);\n+\n+            &*(mem as *const Slice<T>)\n+        }\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for Slice<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n+\n+impl<T: Encodable> Encodable for Slice<T> {\n+    #[inline]\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n \n impl<T> Ord for Slice<T> where T: Ord {\n     fn cmp(&self, other: &Slice<T>) -> Ordering {\n         if self == other { Ordering::Equal } else {\n-            <[T] as Ord>::cmp(&self.0, &other.0)\n+            <[T] as Ord>::cmp(&**self, &**other)\n         }\n     }\n }\n \n impl<T> PartialOrd for Slice<T> where T: PartialOrd {\n     fn partial_cmp(&self, other: &Slice<T>) -> Option<Ordering> {\n         if self == other { Some(Ordering::Equal) } else {\n-            <[T] as PartialOrd>::partial_cmp(&self.0, &other.0)\n+            <[T] as PartialOrd>::partial_cmp(&**self, &**other)\n         }\n     }\n }\n \n-impl<T> PartialEq for Slice<T> {\n+impl<T: PartialEq> PartialEq for Slice<T> {\n     #[inline]\n     fn eq(&self, other: &Slice<T>) -> bool {\n-        (&self.0 as *const [T]) == (&other.0 as *const [T])\n+        (self as *const _) == (other as *const _)\n     }\n }\n-impl<T> Eq for Slice<T> {}\n+impl<T: Eq> Eq for Slice<T> {}\n \n impl<T> Hash for Slice<T> {\n+    #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self.as_ptr(), self.len()).hash(s)\n+        (self as *const Slice<T>).hash(s)\n     }\n }\n \n impl<T> Deref for Slice<T> {\n     type Target = [T];\n+    #[inline(always)]\n     fn deref(&self) -> &[T] {\n-        &self.0\n+        unsafe {\n+            let raw = self as *const _ as *const u8;\n+            let len = *(raw as *const usize);\n+            let slice = raw.offset(Slice::<T>::offset() as isize);\n+            slice::from_raw_parts(slice as *const T, len)\n+        }\n     }\n }\n \n impl<'a, T> IntoIterator for &'a Slice<T> {\n     type Item = &'a T;\n     type IntoIter = <&'a [T] as IntoIterator>::IntoIter;\n+    #[inline(always)]\n     fn into_iter(self) -> Self::IntoIter {\n         self[..].iter()\n     }\n@@ -638,9 +706,14 @@ impl<'a, T> IntoIterator for &'a Slice<T> {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<Ty<'tcx>> {}\n \n impl<T> Slice<T> {\n+    #[inline(always)]\n     pub fn empty<'a>() -> &'a Slice<T> {\n+        #[repr(align(64), C)]\n+        struct EmptySlice([u8; 64]);\n+        static EMPTY_SLICE: EmptySlice = EmptySlice([0; 64]);\n+        assert!(mem::align_of::<T>() <= 64);\n         unsafe {\n-            mem::transmute(slice::from_raw_parts(0x1 as *const T, 0))\n+            &*(&EMPTY_SLICE as *const _ as *const Slice<T>)\n         }\n     }\n }"}, {"sha": "54b7a3821caadb183f42e0657a5f722327354d47", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c2d875261e10105dcfcbd9be84d05a730edd235/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c2d875261e10105dcfcbd9be84d05a730edd235/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=6c2d875261e10105dcfcbd9be84d05a730edd235", "patch": "@@ -48,7 +48,7 @@ fn main() {\n //         _2 = move _3;\n //         StorageDead(_3);\n //         StorageLive(_4);\n-//         UserAssertTy(Canonical { variables: Slice([]), value: std::option::Option<std::boxed::Box<u32>> }, _4);\n+//         UserAssertTy(Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> }, _4);\n //         _4 = std::option::Option<std::boxed::Box<u32>>::None;\n //         StorageLive(_5);\n //         StorageLive(_6);"}]}