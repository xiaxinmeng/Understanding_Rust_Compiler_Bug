{"sha": "80ff0f74b0c4a8d384160af81a1b21f53622d8af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZmYwZjc0YjBjNGE4ZDM4NDE2MGFmODFhMWIyMWY1MzYyMmQ4YWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-10-23T03:01:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-11-20T05:07:41Z"}, "message": "std: Add a new wasm32-unknown-unknown target\n\nThis commit adds a new target to the compiler: wasm32-unknown-unknown. This\ntarget is a reimagining of what it looks like to generate WebAssembly code from\nRust. Instead of using Emscripten which can bring with it a weighty runtime this\ninstead is a target which uses only the LLVM backend for WebAssembly and a\n\"custom linker\" for now which will hopefully one day be direct calls to lld.\n\nNotable features of this target include:\n\n* There is zero runtime footprint. The target assumes nothing exists other than\n  the wasm32 instruction set.\n* There is zero toolchain footprint beyond adding the target. No custom linker\n  is needed, rustc contains everything.\n* Very small wasm modules can be generated directly from Rust code using this\n  target.\n* Most of the standard library is stubbed out to return an error, but anything\n  related to allocation works (aka `HashMap`, `Vec`, etc).\n* Naturally, any `#[no_std]` crate should be 100% compatible with this new\n  target.\n\nThis target is currently somewhat janky due to how linking works. The \"linking\"\nis currently unconditional whole program LTO (aka LLVM is being used as a\nlinker). Naturally that means compiling programs is pretty slow! Eventually\nthough this target should have a linker.\n\nThis target is also intended to be quite experimental. I'm hoping that this can\nact as a catalyst for further experimentation in Rust with WebAssembly. Breaking\nchanges are very likely to land to this target, so it's not recommended to rely\non it in any critical capacity yet. We'll let you know when it's \"production\nready\".\n\n---\n\nCurrently testing-wise this target is looking pretty good but isn't complete.\nI've got almost the entire `run-pass` test suite working with this target (lots\nof tests ignored, but many passing as well). The `core` test suite is still\ngetting LLVM bugs fixed to get that working and will take some time. Relatively\nsimple programs all seem to work though!\n\n---\n\nIt's worth nothing that you may not immediately see the \"smallest possible wasm\nmodule\" for the input you feed to rustc. For various reasons it's very difficult\nto get rid of the final \"bloat\" in vanilla rustc (again, a real linker should\nfix all this). For now what you'll have to do is:\n\n    cargo install --git https://github.com/alexcrichton/wasm-gc\n    wasm-gc foo.wasm bar.wasm\n\nAnd then `bar.wasm` should be the smallest we can get it!\n\n---\n\nIn any case for now I'd love feedback on this, particularly on the various\nintegration points if you've got better ideas of how to approach them!", "tree": {"sha": "0f9bd959bf437c8da2497433fd936d285f912e61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f9bd959bf437c8da2497433fd936d285f912e61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80ff0f74b0c4a8d384160af81a1b21f53622d8af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80ff0f74b0c4a8d384160af81a1b21f53622d8af", "html_url": "https://github.com/rust-lang/rust/commit/80ff0f74b0c4a8d384160af81a1b21f53622d8af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80ff0f74b0c4a8d384160af81a1b21f53622d8af/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "481b42b50745d433c5bcfd90e7a03a4b9110a677", "url": "https://api.github.com/repos/rust-lang/rust/commits/481b42b50745d433c5bcfd90e7a03a4b9110a677", "html_url": "https://github.com/rust-lang/rust/commit/481b42b50745d433c5bcfd90e7a03a4b9110a677"}], "stats": {"total": 4084, "additions": 3644, "deletions": 440}, "files": [{"sha": "0a1188e83eae673234ed1e27df9e3fd61d7ea986", "filename": ".gitmodules", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -42,3 +42,9 @@\n [submodule \"src/tools/miri\"]\n \tpath = src/tools/miri\n \turl = https://github.com/solson/miri.git\n+[submodule \"src/dlmalloc\"]\n+\tpath = src/dlmalloc\n+\turl = https://github.com/alexcrichton/dlmalloc-rs.git\n+[submodule \"src/binaryen\"]\n+\tpath = src/binaryen\n+\turl = https://github.com/alexcrichton/binaryen.git"}, {"sha": "276980699a2f4dca456214835df13e21e340363d", "filename": "src/Cargo.lock", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -50,6 +50,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n  \"core 0.0.0\",\n+ \"dlmalloc 0.0.0\",\n  \"libc 0.0.0\",\n ]\n \n@@ -372,9 +373,6 @@ version = \"0.1.0\"\n [[package]]\n name = \"core\"\n version = \"0.0.0\"\n-dependencies = [\n- \"rand 0.3.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"core-foundation\"\n@@ -509,6 +507,14 @@ name = \"diff\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"dlmalloc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc 0.0.0\",\n+ \"core 0.0.0\",\n+]\n+\n [[package]]\n name = \"docopt\"\n version = \"0.8.1\"\n@@ -1608,6 +1614,15 @@ dependencies = [\n  \"syntax 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_binaryen\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cc 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc_borrowck\"\n version = \"0.0.0\"\n@@ -1880,6 +1895,7 @@ dependencies = [\n  \"rustc_allocator 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_back 0.0.0\",\n+ \"rustc_binaryen 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\","}, {"sha": "1c9bf65aa0e371b84755a8ddd6e79497fac57171", "filename": "src/binaryen", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbinaryen?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1 @@\n+Subproject commit 1c9bf65aa0e371b84755a8ddd6e79497fac57171"}, {"sha": "4d69b19c7310f20370613e88a11fa087630cd43e", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -1211,7 +1211,8 @@ impl Step for Crate {\n                     // ends up messing with various mtime calculations and such.\n                     if !name.contains(\"jemalloc\") &&\n                        *name != *\"build_helper\" &&\n-                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) {\n+                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) &&\n+                       name != \"dlmalloc\" {\n                         cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n                     }\n                     for dep in build.crates[&name].deps.iter() {"}, {"sha": "9f7e3de9dc051e81b812551e0650776d66007d11", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -672,6 +672,9 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n              spath.ends_with(\".s\")) {\n             return false\n         }\n+        if spath.contains(\"test/emscripten\") || spath.contains(\"test\\\\emscripten\") {\n+            return false\n+        }\n \n         let full_path = Path::new(dir).join(path);\n         if exclude_dirs.iter().any(|excl| full_path == Path::new(excl)) {\n@@ -736,6 +739,7 @@ impl Step for Src {\n         // (essentially libstd and all of its path dependencies)\n         let std_src_dirs = [\n             \"src/build_helper\",\n+            \"src/dlmalloc\",\n             \"src/liballoc\",\n             \"src/liballoc_jemalloc\",\n             \"src/liballoc_system\",\n@@ -754,6 +758,7 @@ impl Step for Src {\n             \"src/libunwind\",\n             \"src/rustc/compiler_builtins_shim\",\n             \"src/rustc/libc_shim\",\n+            \"src/rustc/dlmalloc_shim\",\n             \"src/libtest\",\n             \"src/libterm\",\n             \"src/jemalloc\","}, {"sha": "d3812c3accaee7ad23068ed4fc089cc05c7a538f", "filename": "src/dlmalloc", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdlmalloc?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1 @@\n+Subproject commit d3812c3accaee7ad23068ed4fc089cc05c7a538f"}, {"sha": "b595cc1205336be5a39bef052e56edb4fef9d99b", "filename": "src/etc/wasm32-shim.js", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a small \"shim\" program which is used when wasm32 unit tests are run\n+// in this repository. This program is intended to be run in node.js and will\n+// load a wasm module into memory, instantiate it with a set of imports, and\n+// then run it.\n+//\n+// There's a bunch of helper functions defined here in `imports.env`, but note\n+// that most of them aren't actually needed to execute most programs. Many of\n+// these are just intended for completeness or debugging. Hopefully over time\n+// nothing here is needed for completeness.\n+\n+const fs = require('fs');\n+const process = require('process');\n+const buffer = fs.readFileSync(process.argv[2]);\n+\n+Error.stackTraceLimit = 20;\n+\n+let m = new WebAssembly.Module(buffer);\n+\n+let memory = null;\n+\n+function copystr(a, b) {\n+  if (memory === null) {\n+    return null\n+  }\n+  let view = new Uint8Array(memory.buffer).slice(a, a + b);\n+  return String.fromCharCode.apply(null, view);\n+}\n+\n+let imports = {};\n+imports.env = {\n+  // These are generated by LLVM itself for various intrinsic calls. Hopefully\n+  // one day this is not necessary and something will automatically do this.\n+  fmod: function(x, y) { return x % y; },\n+  exp2: function(x) { return Math.pow(2, x); },\n+  exp2f: function(x) { return Math.pow(2, x); },\n+  ldexp: function(x, y) { return x * Math.pow(2, y); },\n+  ldexpf: function(x, y) { return x * Math.pow(2, y); },\n+  log10: function(x) { return Math.log10(x); },\n+  log10f: function(x) { return Math.log10(x); },\n+\n+  // These are called in src/libstd/sys/wasm/stdio.rs and are used when\n+  // debugging is enabled.\n+  rust_wasm_write_stdout: function(a, b) {\n+    let s = copystr(a, b);\n+    if (s !== null) {\n+      process.stdout.write(s);\n+    }\n+  },\n+  rust_wasm_write_stderr: function(a, b) {\n+    let s = copystr(a, b);\n+    if (s !== null) {\n+      process.stderr.write(s);\n+    }\n+  },\n+\n+  // These are called in src/libstd/sys/wasm/args.rs and are used when\n+  // debugging is enabled.\n+  rust_wasm_args_count: function() {\n+    if (memory === null)\n+      return 0;\n+    return process.argv.length - 2;\n+  },\n+  rust_wasm_args_arg_size: function(i) {\n+    return process.argv[i + 2].length;\n+  },\n+  rust_wasm_args_arg_fill: function(idx, ptr) {\n+    let arg = process.argv[idx + 2];\n+    let view = new Uint8Array(memory.buffer);\n+    for (var i = 0; i < arg.length; i++) {\n+      view[ptr + i] = arg.charCodeAt(i);\n+    }\n+  },\n+\n+  // These are called in src/libstd/sys/wasm/os.rs and are used when\n+  // debugging is enabled.\n+  rust_wasm_getenv_len: function(a, b) {\n+    let key = copystr(a, b);\n+    if (key === null) {\n+      return -1;\n+    }\n+    if (!(key in process.env)) {\n+      return -1;\n+    }\n+    return process.env[key].length;\n+  },\n+  rust_wasm_getenv_data: function(a, b, ptr) {\n+    let key = copystr(a, b);\n+    let value = process.env[key];\n+    let view = new Uint8Array(memory.buffer);\n+    for (var i = 0; i < value.length; i++) {\n+      view[ptr + i] = value.charCodeAt(i);\n+    }\n+  },\n+};\n+\n+let module_imports = WebAssembly.Module.imports(m);\n+\n+for (var i = 0; i < module_imports.length; i++) {\n+  let imp = module_imports[i];\n+  if (imp.module != 'env') {\n+    continue\n+  }\n+  if (imp.name == 'memory' && imp.kind == 'memory') {\n+    memory = new WebAssembly.Memory({initial: 20});\n+    imports.env.memory = memory;\n+  }\n+}\n+\n+let instance = new WebAssembly.Instance(m, imports);"}, {"sha": "a41a04d7cd4f6a0142ec9fcbd060c11b072462be", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     let host = env::var(\"HOST\").expect(\"HOST was not set\");\n     if target.contains(\"rumprun\") || target.contains(\"bitrig\") || target.contains(\"openbsd\") ||\n        target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") ||\n-       target.contains(\"redox\") {\n+       target.contains(\"redox\") || target.contains(\"wasm32\") {\n         println!(\"cargo:rustc-cfg=dummy_jemalloc\");\n         return;\n     }"}, {"sha": "f9a57f7d97a74ea914602769708754e84958d9b4", "filename": "src/liballoc_system/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fliballoc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fliballoc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2FCargo.toml?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -13,3 +13,7 @@ doc = false\n alloc = { path = \"../liballoc\" }\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n+\n+# See comments in the source for what this dependency is\n+[target.'cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))'.dependencies]\n+dlmalloc = { path = \"../rustc/dlmalloc_shim\" }"}, {"sha": "05cacf6e8819544b36b65ca8247e4119bab26c73", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -34,12 +34,14 @@\n               target_arch = \"powerpc64\",\n               target_arch = \"asmjs\",\n               target_arch = \"wasm32\")))]\n+#[allow(dead_code)]\n const MIN_ALIGN: usize = 8;\n #[cfg(all(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\",\n               target_arch = \"mips64\",\n               target_arch = \"s390x\",\n               target_arch = \"sparc64\")))]\n+#[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n extern crate alloc;\n@@ -458,3 +460,91 @@ mod platform {\n         }\n     }\n }\n+\n+// This is an implementation of a global allocator on the wasm32 platform when\n+// emscripten is not in use. In that situation there's no actual runtime for us\n+// to lean on for allocation, so instead we provide our own!\n+//\n+// The wasm32 instruction set has two instructions for getting the current\n+// amount of memory and growing the amount of memory. These instructions are the\n+// foundation on which we're able to build an allocator, so we do so! Note that\n+// the instructions are also pretty \"global\" and this is the \"global\" allocator\n+// after all!\n+//\n+// The current allocator here is the `dlmalloc` crate which we've got included\n+// in the rust-lang/rust repository as a submodule. The crate is a port of\n+// dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n+// for now which is currently technically required (can't link with C yet).\n+//\n+// The crate itself provides a global allocator which on wasm has no\n+// synchronization as there are no threads!\n+#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+mod platform {\n+    extern crate dlmalloc;\n+\n+    use alloc::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n+    use System;\n+    use self::dlmalloc::GlobalDlmalloc;\n+\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    unsafe impl<'a> Alloc for &'a System {\n+        #[inline]\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+            GlobalDlmalloc.alloc(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn alloc_zeroed(&mut self, layout: Layout)\n+            -> Result<*mut u8, AllocErr>\n+        {\n+            GlobalDlmalloc.alloc_zeroed(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+            GlobalDlmalloc.dealloc(ptr, layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn realloc(&mut self,\n+                          ptr: *mut u8,\n+                          old_layout: Layout,\n+                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n+            GlobalDlmalloc.realloc(ptr, old_layout, new_layout)\n+        }\n+\n+        #[inline]\n+        fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n+            GlobalDlmalloc.usable_size(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n+            GlobalDlmalloc.alloc_excess(layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn realloc_excess(&mut self,\n+                                 ptr: *mut u8,\n+                                 layout: Layout,\n+                                 new_layout: Layout) -> Result<Excess, AllocErr> {\n+            GlobalDlmalloc.realloc_excess(ptr, layout, new_layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn grow_in_place(&mut self,\n+                                ptr: *mut u8,\n+                                layout: Layout,\n+                                new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+            GlobalDlmalloc.grow_in_place(ptr, layout, new_layout)\n+        }\n+\n+        #[inline]\n+        unsafe fn shrink_in_place(&mut self,\n+                                  ptr: *mut u8,\n+                                  layout: Layout,\n+                                  new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+            GlobalDlmalloc.shrink_in_place(ptr, layout, new_layout)\n+        }\n+    }\n+}"}, {"sha": "5af63aa970f2c7cb50a720298b73dbc875e5b4c9", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -9,9 +9,6 @@ path = \"lib.rs\"\n test = false\n bench = false\n \n-[dev-dependencies]\n-rand = \"0.3\"\n-\n [[test]]\n name = \"coretests\"\n path = \"../libcore/tests/lib.rs\""}, {"sha": "edf7f44e5925cbe4fa5c7cd9108b0d8f352b18cd", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -27,7 +27,6 @@\n #![feature(iter_rfind)]\n #![feature(iter_rfold)]\n #![feature(nonzero)]\n-#![feature(rand)]\n #![feature(raw)]\n #![feature(refcell_replace_swap)]\n #![feature(sip_hash_13)]\n@@ -48,7 +47,6 @@\n \n extern crate core;\n extern crate test;\n-extern crate rand;\n \n mod any;\n mod array;"}, {"sha": "ef0178815f98b27dbd9d3829fa35118bd60ecb69", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 1, "deletions": 84, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -9,9 +9,7 @@\n // except according to those terms.\n \n use std::prelude::v1::*;\n-use std::{str, mem, i16, f32, f64, fmt};\n-use rand::{self, Rand, XorShiftRng};\n-use rand::distributions::{IndependentSample, Range};\n+use std::{str, i16, f32, f64, fmt};\n \n use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n use core::num::flt2dec::{MAX_SIG_DIGITS, round_up, Part, Formatted, Sign};\n@@ -463,87 +461,6 @@ pub fn more_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]\n                       exp: 0, inclusive: false} => b\"99999999999999999\", 17);\n }\n \n-fn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V) -> (usize, usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n-              V: FnMut(usize) -> Decoded {\n-    assert!(k <= 1024);\n-\n-    let mut npassed = 0; // f(x) = Some(g(x))\n-    let mut nignored = 0; // f(x) = None\n-\n-    for i in 0..n {\n-        if (i & 0xfffff) == 0 {\n-            println!(\"in progress, {:x}/{:x} (ignored={} passed={} failed={})\",\n-                     i, n, nignored, npassed, i - nignored - npassed);\n-        }\n-\n-        let decoded = v(i);\n-        let mut buf1 = [0; 1024];\n-        if let Some((len1, e1)) = f(&decoded, &mut buf1[..k]) {\n-            let mut buf2 = [0; 1024];\n-            let (len2, e2) = g(&decoded, &mut buf2[..k]);\n-            if e1 == e2 && &buf1[..len1] == &buf2[..len2] {\n-                npassed += 1;\n-            } else {\n-                println!(\"equivalence test failed, {:x}/{:x}: {:?} f(i)={}e{} g(i)={}e{}\",\n-                         i, n, decoded, str::from_utf8(&buf1[..len1]).unwrap(), e1,\n-                                        str::from_utf8(&buf2[..len2]).unwrap(), e2);\n-            }\n-        } else {\n-            nignored += 1;\n-        }\n-    }\n-    println!(\"{}({}): done, ignored={} passed={} failed={}\",\n-             func, k, nignored, npassed, n - nignored - npassed);\n-    assert!(nignored + npassed == n,\n-            \"{}({}): {} out of {} values returns an incorrect value!\",\n-            func, k, n - nignored - npassed, n);\n-    (npassed, nignored)\n-}\n-\n-pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n-    let mut rng: XorShiftRng = Rand::rand(&mut rand::thread_rng());\n-    let f32_range = Range::new(0x0000_0001u32, 0x7f80_0000);\n-    iterate(\"f32_random_equivalence_test\", k, n, f, g, |_| {\n-        let i: u32 = f32_range.ind_sample(&mut rng);\n-        let x: f32 = unsafe {mem::transmute(i)};\n-        decode_finite(x)\n-    });\n-}\n-\n-pub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n-    let mut rng: XorShiftRng = Rand::rand(&mut rand::thread_rng());\n-    let f64_range = Range::new(0x0000_0000_0000_0001u64, 0x7ff0_0000_0000_0000);\n-    iterate(\"f64_random_equivalence_test\", k, n, f, g, |_| {\n-        let i: u64 = f64_range.ind_sample(&mut rng);\n-        let x: f64 = unsafe {mem::transmute(i)};\n-        decode_finite(x)\n-    });\n-}\n-\n-pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\n-        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n-              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n-    // we have only 2^23 * (2^8 - 1) - 1 = 2,139,095,039 positive finite f32 values,\n-    // so why not simply testing all of them?\n-    //\n-    // this is of course very stressful (and thus should be behind an `#[ignore]` attribute),\n-    // but with `-C opt-level=3 -C lto` this only takes about an hour or so.\n-\n-    // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e. all finite ranges\n-    let (npassed, nignored) = iterate(\"f32_exhaustive_equivalence_test\",\n-                                      k, 0x7f7f_ffff, f, g, |i: usize| {\n-        let x: f32 = unsafe {mem::transmute(i as u32 + 1)};\n-        decode_finite(x)\n-    });\n-    assert_eq!((npassed, nignored), (2121451881, 17643158));\n-}\n-\n fn to_string_with_parts<F>(mut f: F) -> String\n         where F: for<'a> FnMut(&'a mut [u8], &'a mut [Part<'a>]) -> Formatted<'a> {\n     let mut buf = [0; 1024];"}, {"sha": "286b39d8cf3b3ba8d9c684d07f0d3fe662b62780", "filename": "src/libcore/tests/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::i16;\n use super::super::*;\n use core::num::flt2dec::strategy::grisu::*;\n \n@@ -46,35 +45,6 @@ fn shortest_sanity_test() {\n     more_shortest_sanity_test(format_shortest);\n }\n \n-#[test]\n-fn shortest_random_equivalence_test() {\n-    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n-    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n-    f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n-}\n-\n-#[test] #[ignore] // it is too expensive\n-fn shortest_f32_exhaustive_equivalence_test() {\n-    // it is hard to directly test the optimality of the output, but we can at least test if\n-    // two different algorithms agree to each other.\n-    //\n-    // this reports the progress and the number of f32 values returned `None`.\n-    // with `--nocapture` (and plenty of time and appropriate rustc flags), this should print:\n-    // `done, ignored=17643158 passed=2121451881 failed=0`.\n-\n-    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n-    f32_exhaustive_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS);\n-}\n-\n-#[test] #[ignore] // it is too expensive\n-fn shortest_f64_hard_random_equivalence_test() {\n-    // this again probably has to use appropriate rustc flags.\n-\n-    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n-    f64_random_equivalence_test(format_shortest_opt, fallback,\n-                                         MAX_SIG_DIGITS, 100_000_000);\n-}\n-\n #[test]\n fn exact_sanity_test() {\n     // See comments in dragon.rs's exact_sanity_test for why this test is\n@@ -85,24 +55,6 @@ fn exact_sanity_test() {\n     f32_exact_sanity_test(format_exact);\n }\n \n-#[test]\n-fn exact_f32_random_equivalence_test() {\n-    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n-    for k in 1..21 {\n-        f32_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n-                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n-    }\n-}\n-\n-#[test]\n-fn exact_f64_random_equivalence_test() {\n-    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n-    for k in 1..21 {\n-        f64_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n-                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n-    }\n-}\n-\n #[test]\n fn test_to_shortest_str() {\n     to_shortest_str_test(format_shortest);"}, {"sha": "60e4e6d2ff3281794d4d1422cc80e2626e9343e8", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::cmp::Ordering::{Equal, Greater, Less};\n-use core::slice::heapsort;\n use core::result::Result::{Ok, Err};\n-use rand::{Rng, XorShiftRng};\n \n #[test]\n fn test_binary_search() {\n@@ -290,68 +287,3 @@ fn test_rotate() {\n         assert_eq!(a[(i+k)%N], i);\n     }\n }\n-\n-#[test]\n-fn sort_unstable() {\n-    let mut v = [0; 600];\n-    let mut tmp = [0; 600];\n-    let mut rng = XorShiftRng::new_unseeded();\n-\n-    for len in (2..25).chain(500..510) {\n-        let v = &mut v[0..len];\n-        let tmp = &mut tmp[0..len];\n-\n-        for &modulus in &[5, 10, 100, 1000] {\n-            for _ in 0..100 {\n-                for i in 0..len {\n-                    v[i] = rng.gen::<i32>() % modulus;\n-                }\n-\n-                // Sort in default order.\n-                tmp.copy_from_slice(v);\n-                tmp.sort_unstable();\n-                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Sort in ascending order.\n-                tmp.copy_from_slice(v);\n-                tmp.sort_unstable_by(|a, b| a.cmp(b));\n-                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Sort in descending order.\n-                tmp.copy_from_slice(v);\n-                tmp.sort_unstable_by(|a, b| b.cmp(a));\n-                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n-\n-                // Test heapsort using `<` operator.\n-                tmp.copy_from_slice(v);\n-                heapsort(tmp, |a, b| a < b);\n-                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n-\n-                // Test heapsort using `>` operator.\n-                tmp.copy_from_slice(v);\n-                heapsort(tmp, |a, b| a > b);\n-                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n-            }\n-        }\n-    }\n-\n-    // Sort using a completely random comparison function.\n-    // This will reorder the elements *somehow*, but won't panic.\n-    for i in 0..v.len() {\n-        v[i] = i as i32;\n-    }\n-    v.sort_unstable_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n-    v.sort_unstable();\n-    for i in 0..v.len() {\n-        assert_eq!(v[i], i as i32);\n-    }\n-\n-    // Should not panic.\n-    [0i32; 0].sort_unstable();\n-    [(); 10].sort_unstable();\n-    [(); 100].sort_unstable();\n-\n-    let mut v = [0xDEADBEEFu64];\n-    v.sort_unstable();\n-    assert!(v == [0xDEADBEEF]);\n-}"}, {"sha": "29a9e1aadaf3c94b8e911c5afac3b045db9efffc", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -20,13 +20,13 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n #![deny(warnings)]\n-\n-#![feature(staged_api)]\n-\n #![panic_runtime]\n+#![allow(unused_features)]\n+\n+#![feature(core_intrinsics)]\n+#![feature(libc)]\n #![feature(panic_runtime)]\n-#![cfg_attr(unix, feature(libc))]\n-#![cfg_attr(any(target_os = \"redox\", windows), feature(core_intrinsics))]\n+#![feature(staged_api)]\n \n // Rust's \"try\" function, but if we're aborting on panics we just call the\n // function as there's nothing else we need to do here.\n@@ -59,7 +59,9 @@ pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n         libc::abort();\n     }\n \n-    #[cfg(any(target_os = \"redox\", windows))]\n+    #[cfg(any(target_os = \"redox\",\n+              windows,\n+              all(target_arch = \"wasm32\", not(target_os = \"emscripten\"))))]\n     unsafe fn abort() -> ! {\n         core::intrinsics::abort();\n     }\n@@ -92,7 +94,6 @@ pub unsafe extern fn __rust_start_panic(_data: usize, _vtable: usize) -> u32 {\n // binaries, but it should never be called as we don't link in an unwinding\n // runtime at all.\n pub mod personalities {\n-\n     #[no_mangle]\n     #[cfg(not(all(target_os = \"windows\",\n                   target_env = \"gnu\","}, {"sha": "6b8da7a51ceb8c2f2696f9ac1950b515a6969d87", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -34,9 +34,7 @@\n #![feature(core_intrinsics)]\n #![feature(lang_items)]\n #![feature(libc)]\n-#![cfg_attr(not(any(target_env = \"msvc\",\n-                    all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))),\n-            feature(panic_unwind))]\n+#![feature(panic_unwind)]\n #![feature(raw)]\n #![feature(staged_api)]\n #![feature(unwind_attributes)]\n@@ -80,6 +78,10 @@ mod imp;\n #[path = \"emcc.rs\"]\n mod imp;\n \n+#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+#[path = \"wasm32.rs\"]\n+mod imp;\n+\n mod dwarf;\n mod windows;\n "}, {"sha": "8aed61b3c385a954b07e116c71859ab7d66cc621", "filename": "src/libpanic_unwind/wasm32.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibpanic_unwind%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibpanic_unwind%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwasm32.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unwinding for wasm32\n+//!\n+//! Right now we don't support this, so this is just stubs\n+\n+use alloc::boxed::Box;\n+use core::any::Any;\n+use core::intrinsics;\n+\n+pub fn payload() -> *mut u8 {\n+    0 as *mut u8\n+}\n+\n+pub unsafe fn cleanup(_ptr: *mut u8) -> Box<Any + Send> {\n+    intrinsics::abort()\n+}\n+\n+pub unsafe fn panic(_data: Box<Any + Send>) -> u32 {\n+    intrinsics::abort()\n+}"}, {"sha": "9f957cd780829a6f61cfbd6fec0a6bd3b2afb2ea", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -432,7 +432,7 @@ impl Session {\n             self.opts.debugging_opts.borrowck_mir\n     }\n     pub fn lto(&self) -> bool {\n-        self.opts.cg.lto\n+        self.opts.cg.lto || self.target.target.options.requires_lto\n     }\n     /// Returns the panic strategy for this compile session. If the user explicitly selected one\n     /// using '-C panic', use that, otherwise use the panic strategy defined by the target."}, {"sha": "824b5531047607c8f263787f5033629882d8f76a", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -84,6 +84,7 @@ macro_rules! linker_flavor {\n \n linker_flavor! {\n     (Em, \"em\"),\n+    (Binaryen, \"binaryen\"),\n     (Gcc, \"gcc\"),\n     (Ld, \"ld\"),\n     (Msvc, \"msvc\"),"}, {"sha": "7599a60ba5ada27f5d527e0449ed28b7251d31da", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -218,6 +218,7 @@ supported_targets! {\n \n     (\"asmjs-unknown-emscripten\", asmjs_unknown_emscripten),\n     (\"wasm32-unknown-emscripten\", wasm32_unknown_emscripten),\n+    (\"wasm32-unknown-unknown\", wasm32_unknown_unknown),\n     (\"wasm32-experimental-emscripten\", wasm32_experimental_emscripten),\n \n     (\"thumbv6m-none-eabi\", thumbv6m_none_eabi),\n@@ -303,6 +304,8 @@ pub struct TargetOptions {\n     pub features: String,\n     /// Whether dynamic linking is available on this target. Defaults to false.\n     pub dynamic_linking: bool,\n+    /// If dynamic linking is available, whether only cdylibs are supported.\n+    pub only_cdylib: bool,\n     /// Whether executables are available on this target. iOS, for example, only allows static\n     /// libraries. Defaults to false.\n     pub executables: bool,\n@@ -439,6 +442,17 @@ pub struct TargetOptions {\n     /// Whether to generate trap instructions in places where optimization would\n     /// otherwise produce control flow that falls through into unrelated memory.\n     pub trap_unreachable: bool,\n+\n+    /// This target requires everything to be compiled with LTO to emit a final\n+    /// executable, aka there is no native linker for this target.\n+    pub requires_lto: bool,\n+\n+    /// This target has no support for threads.\n+    pub singlethread: bool,\n+\n+    /// Whether library functions call lowering/optimization is disabled in LLVM\n+    /// for this target unconditionally.\n+    pub no_builtins: bool,\n }\n \n impl Default for TargetOptions {\n@@ -454,6 +468,7 @@ impl Default for TargetOptions {\n             cpu: \"generic\".to_string(),\n             features: \"\".to_string(),\n             dynamic_linking: false,\n+            only_cdylib: false,\n             executables: false,\n             relocation_model: \"pic\".to_string(),\n             code_model: \"default\".to_string(),\n@@ -503,6 +518,9 @@ impl Default for TargetOptions {\n             min_global_align: None,\n             default_codegen_units: None,\n             trap_unreachable: true,\n+            requires_lto: false,\n+            singlethread: false,\n+            no_builtins: false,\n         }\n     }\n }\n@@ -702,6 +720,7 @@ impl Target {\n         key!(cpu);\n         key!(features);\n         key!(dynamic_linking, bool);\n+        key!(only_cdylib, bool);\n         key!(executables, bool);\n         key!(relocation_model);\n         key!(code_model);\n@@ -745,6 +764,9 @@ impl Target {\n         key!(min_global_align, Option<u64>);\n         key!(default_codegen_units, Option<u64>);\n         key!(trap_unreachable, bool);\n+        key!(requires_lto, bool);\n+        key!(singlethread, bool);\n+        key!(no_builtins, bool);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -896,6 +918,7 @@ impl ToJson for Target {\n         target_option_val!(cpu);\n         target_option_val!(features);\n         target_option_val!(dynamic_linking);\n+        target_option_val!(only_cdylib);\n         target_option_val!(executables);\n         target_option_val!(relocation_model);\n         target_option_val!(code_model);\n@@ -939,6 +962,9 @@ impl ToJson for Target {\n         target_option_val!(min_global_align);\n         target_option_val!(default_codegen_units);\n         target_option_val!(trap_unreachable);\n+        target_option_val!(requires_lto);\n+        target_option_val!(singlethread);\n+        target_option_val!(no_builtins);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()"}, {"sha": "7e1011ab8af96a2bd47b721b2fbf4f0c3f629498", "filename": "src/librustc_back/target/wasm32_unknown_unknown.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_unknown.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The wasm32-unknown-unknown target is currently a highly experimental version\n+// of a wasm-based target which does *not* use the Emscripten toolchain. Instead\n+// this is a pretty flavorful (aka hacked up) target right now. The definition\n+// and semantics of this target are likely to change and so this shouldn't be\n+// relied on just yet.\n+//\n+// In general everyone is currently waiting on a linker for wasm code. In the\n+// meantime we have no means of actually making use of the traditional separate\n+// compilation model. At a high level this means that assembling Rust programs\n+// into a WebAssembly program looks like:\n+//\n+//  1. All intermediate artifacts are LLVM bytecode. We'll be using LLVM as\n+//     a linker later on.\n+//  2. For the final artifact we emit one giant assembly file (WebAssembly\n+//     doesn't have an object file format). To do this we force LTO to be turned\n+//     on (`requires_lto` below) to ensure all Rust code is in one module. Any\n+//     \"linked\" C library is basically just ignored.\n+//  3. Using LLVM we emit a `foo.s` file (assembly) with some... what I can only\n+//     describe as arcane syntax. From there we need to actually change this\n+//     into a wasm module. For this step we use the `binaryen` project. This\n+//     project is mostly intended as a WebAssembly code generator, but for now\n+//     we're just using its LLVM-assembly-to-wasm-module conversion utilities.\n+//\n+// And voila, out comes a web assembly module! There's some various tweaks here\n+// and there, but that's the high level at least. Note that this will be\n+// rethought from the ground up once a linker (lld) is available, so this is all\n+// temporary and should improve in the future.\n+\n+use LinkerFlavor;\n+use super::{Target, TargetOptions, PanicStrategy};\n+\n+pub fn target() -> Result<Target, String> {\n+    let opts = TargetOptions {\n+        linker: \"not-used\".to_string(),\n+\n+        // we allow dynamic linking, but only cdylibs. Basically we allow a\n+        // final library artifact that exports some symbols (a wasm module) but\n+        // we don't allow intermediate `dylib` crate types\n+        dynamic_linking: true,\n+        only_cdylib: true,\n+\n+        // This means we'll just embed a `start` function in the wasm module\n+        executables: true,\n+\n+        // relatively self-explanatory!\n+        exe_suffix: \".wasm\".to_string(),\n+        dll_prefix: \"\".to_string(),\n+        dll_suffix: \".wasm\".to_string(),\n+        linker_is_gnu: false,\n+\n+        // We're storing bitcode for now in all the rlibs\n+        obj_is_bitcode: true,\n+\n+        // A bit of a lie, but \"eh\"\n+        max_atomic_width: Some(32),\n+\n+        // Unwinding doesn't work right now, so the whole target unconditionally\n+        // defaults to panic=abort. Note that this is guaranteed to change in\n+        // the future once unwinding is implemented. Don't rely on this.\n+        panic_strategy: PanicStrategy::Abort,\n+\n+        // There's no linker yet so we're forced to use LLVM as a linker. This\n+        // means that we must always enable LTO for final artifacts.\n+        requires_lto: true,\n+\n+        // Wasm doesn't have atomics yet, so tell LLVM that we're in a single\n+        // threaded model which will legalize atomics to normal operations.\n+        singlethread: true,\n+\n+        // Because we're always enabling LTO we can't enable builtin lowering as\n+        // otherwise we'll lower the definition of the `memcpy` function to\n+        // memcpy itself. Note that this is specifically because we're\n+        // performing LTO with compiler-builtins.\n+        no_builtins: true,\n+\n+        .. Default::default()\n+    };\n+    Ok(Target {\n+        llvm_target: \"wasm32-unknown-unknown\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        // This is basically guaranteed to change in the future, don't rely on\n+        // this. Use `not(target_os = \"emscripten\")` for now.\n+        target_os: \"unknown\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-n32:64-S128\".to_string(),\n+        arch: \"wasm32\".to_string(),\n+        // A bit of a lie, but it gets the job done\n+        linker_flavor: LinkerFlavor::Binaryen,\n+        options: opts,\n+    })\n+}"}, {"sha": "d1095a7819d4aa3729486c5f6d3ed639dfa0ca6c", "filename": "src/librustc_binaryen/BinaryenWrapper.cpp", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_binaryen%2FBinaryenWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_binaryen%2FBinaryenWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_binaryen%2FBinaryenWrapper.cpp?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a small C API inserted on top of the Binaryen C++ API which we use\n+// from Rust. Once we have a real linker for we'll be able to remove all this,\n+// and otherwise this is just all on a \"as we need it\" basis for now.\n+\n+#include <stdint.h>\n+#include <string>\n+#include <stdlib.h>\n+\n+#include \"s2wasm.h\"\n+#include \"wasm-binary.h\"\n+#include \"wasm-linker.h\"\n+\n+using namespace wasm;\n+\n+struct BinaryenRustModule {\n+  BufferWithRandomAccess buffer;\n+};\n+\n+struct BinaryenRustModuleOptions {\n+  uint64_t globalBase;\n+  bool debug;\n+  uint64_t stackAllocation;\n+  uint64_t initialMem;\n+  uint64_t maxMem;\n+  bool importMemory;\n+  bool ignoreUnknownSymbols;\n+  bool debugInfo;\n+  std::string startFunction;\n+\n+  BinaryenRustModuleOptions() :\n+    globalBase(0),\n+    debug(false),\n+    stackAllocation(0),\n+    initialMem(0),\n+    maxMem(0),\n+    importMemory(false),\n+    ignoreUnknownSymbols(false),\n+    debugInfo(false),\n+    startFunction(\"\")\n+  {}\n+\n+};\n+\n+extern \"C\" BinaryenRustModuleOptions*\n+BinaryenRustModuleOptionsCreate() {\n+  return new BinaryenRustModuleOptions;\n+}\n+\n+extern \"C\" void\n+BinaryenRustModuleOptionsFree(BinaryenRustModuleOptions *options) {\n+  delete options;\n+}\n+\n+extern \"C\" void\n+BinaryenRustModuleOptionsSetDebugInfo(BinaryenRustModuleOptions *options,\n+                                      bool debugInfo) {\n+  options->debugInfo = debugInfo;\n+}\n+\n+extern \"C\" void\n+BinaryenRustModuleOptionsSetStart(BinaryenRustModuleOptions *options,\n+                                  char *start) {\n+  options->startFunction = start;\n+}\n+\n+extern \"C\" void\n+BinaryenRustModuleOptionsSetStackAllocation(BinaryenRustModuleOptions *options,\n+                                            uint64_t stack) {\n+  options->stackAllocation = stack;\n+}\n+\n+extern \"C\" void\n+BinaryenRustModuleOptionsSetImportMemory(BinaryenRustModuleOptions *options,\n+                                         bool import) {\n+  options->importMemory = import;\n+}\n+\n+extern \"C\" BinaryenRustModule*\n+BinaryenRustModuleCreate(const BinaryenRustModuleOptions *options,\n+                         const char *assembly) {\n+  Linker linker(\n+      options->globalBase,\n+      options->stackAllocation,\n+      options->initialMem,\n+      options->maxMem,\n+      options->importMemory,\n+      options->ignoreUnknownSymbols,\n+      options->startFunction,\n+      options->debug);\n+\n+  S2WasmBuilder mainbuilder(assembly, options->debug);\n+  linker.linkObject(mainbuilder);\n+  linker.layout();\n+\n+  auto ret = make_unique<BinaryenRustModule>();\n+  {\n+    WasmBinaryWriter writer(&linker.getOutput().wasm, ret->buffer, options->debug);\n+    writer.setNamesSection(options->debugInfo);\n+    // FIXME: support source maps?\n+    // writer.setSourceMap(sourceMapStream.get(), sourceMapUrl);\n+\n+    // FIXME: support symbol maps?\n+    // writer.setSymbolMap(symbolMap);\n+    writer.write();\n+  }\n+  return ret.release();\n+}\n+\n+extern \"C\" const uint8_t*\n+BinaryenRustModulePtr(const BinaryenRustModule *M) {\n+  return M->buffer.data();\n+}\n+\n+extern \"C\" size_t\n+BinaryenRustModuleLen(const BinaryenRustModule *M) {\n+  return M->buffer.size();\n+}\n+\n+extern \"C\" void\n+BinaryenRustModuleFree(BinaryenRustModule *M) {\n+  delete M;\n+}"}, {"sha": "9573c89471404d7877437cee350fa27b3cf97830", "filename": "src/librustc_binaryen/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_binaryen%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_binaryen%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_binaryen%2FCargo.toml?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,16 @@\n+# Wondering what this crate is? Take a look at the `lib.rs`!\n+\n+[package]\n+name = \"rustc_binaryen\"\n+version = \"0.0.0\"\n+authors = [\"The Rust Project Developers\"]\n+\n+[lib]\n+path = \"lib.rs\"\n+\n+[dependencies]\n+libc = \"0.2\"\n+\n+[build-dependencies]\n+cmake = \"0.1\"\n+cc = \"1.0\""}, {"sha": "f23ff3cee555bba7c48cb6d6b5eee3b857b680da", "filename": "src/librustc_binaryen/build.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_binaryen%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_binaryen%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_binaryen%2Fbuild.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate cc;\n+extern crate cmake;\n+\n+use std::env;\n+\n+use cmake::Config;\n+\n+fn main() {\n+    let target = env::var(\"TARGET\").unwrap();\n+\n+    // Bring in `__emutls_get_address` which is apparently needed for now\n+    if target.contains(\"pc-windows-gnu\") {\n+        println!(\"cargo:rustc-link-lib=gcc_eh\");\n+        println!(\"cargo:rustc-link-lib=pthread\");\n+    }\n+\n+    Config::new(\"../binaryen\")\n+        .define(\"BUILD_STATIC_LIB\", \"ON\")\n+        .build_target(\"binaryen\")\n+        .build();\n+\n+    // I couldn't figure out how to link just one of these, so link everything.\n+    println!(\"cargo:rustc-link-lib=static=asmjs\");\n+    println!(\"cargo:rustc-link-lib=static=binaryen\");\n+    println!(\"cargo:rustc-link-lib=static=cfg\");\n+    println!(\"cargo:rustc-link-lib=static=emscripten-optimizer\");\n+    println!(\"cargo:rustc-link-lib=static=ir\");\n+    println!(\"cargo:rustc-link-lib=static=passes\");\n+    println!(\"cargo:rustc-link-lib=static=support\");\n+    println!(\"cargo:rustc-link-lib=static=wasm\");\n+\n+    let out_dir = env::var(\"OUT_DIR\").unwrap();\n+    println!(\"cargo:rustc-link-search=native={}/build/lib\", out_dir);\n+\n+    // Add in our own little shim along with some extra files that weren't\n+    // included in the main build.\n+    let mut cfg = cc::Build::new();\n+    cfg.file(\"BinaryenWrapper.cpp\")\n+        .file(\"../binaryen/src/wasm-linker.cpp\")\n+        .file(\"../binaryen/src/wasm-emscripten.cpp\")\n+        .include(\"../binaryen/src\")\n+        .cpp_link_stdlib(None)\n+        .warnings(false)\n+        .cpp(true);\n+\n+    if !target.contains(\"msvc\") {\n+        cfg.flag(\"-std=c++11\");\n+    }\n+    cfg.compile(\"binaryen_wrapper\");\n+}"}, {"sha": "6c7feb6a7a9d36200cb1bf65d0c3c69a730e9679", "filename": "src/librustc_binaryen/lib.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_binaryen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_binaryen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_binaryen%2Flib.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,150 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Rustc bindings to the binaryen project.\n+//!\n+//! This crate is a small shim around the binaryen project which provides us the\n+//! ability to take LLVM's output and generate a wasm module. Specifically this\n+//! only supports one operation, creating a module from LLVM's assembly format\n+//! and then serializing that module to a wasm module.\n+\n+extern crate libc;\n+\n+use std::slice;\n+use std::ffi::{CString, CStr};\n+\n+/// In-memory representation of a serialized wasm module.\n+pub struct Module {\n+    ptr: *mut BinaryenRustModule,\n+}\n+\n+impl Module {\n+    /// Creates a new wasm module from the LLVM-assembly provided (in a C string\n+    /// format).\n+    ///\n+    /// The actual module creation can be tweaked through the various options in\n+    /// `ModuleOptions` as well. Any errors are just returned as a bland string.\n+    pub fn new(assembly: &CStr, opts: &ModuleOptions) -> Result<Module, String> {\n+        unsafe {\n+            let ptr = BinaryenRustModuleCreate(opts.ptr, assembly.as_ptr());\n+            if ptr.is_null() {\n+                Err(format!(\"failed to create binaryen module\"))\n+            } else {\n+                Ok(Module { ptr })\n+            }\n+        }\n+    }\n+\n+    /// Returns the data of the serialized wasm module. This is a `foo.wasm`\n+    /// file contents.\n+    pub fn data(&self) -> &[u8] {\n+        unsafe {\n+            let ptr = BinaryenRustModulePtr(self.ptr);\n+            let len = BinaryenRustModuleLen(self.ptr);\n+            slice::from_raw_parts(ptr, len)\n+        }\n+    }\n+}\n+\n+impl Drop for Module {\n+    fn drop(&mut self) {\n+        unsafe {\n+            BinaryenRustModuleFree(self.ptr);\n+        }\n+    }\n+}\n+\n+pub struct ModuleOptions {\n+    ptr: *mut BinaryenRustModuleOptions,\n+}\n+\n+impl ModuleOptions {\n+    pub fn new() -> ModuleOptions {\n+        unsafe {\n+            let ptr = BinaryenRustModuleOptionsCreate();\n+            ModuleOptions { ptr }\n+        }\n+    }\n+\n+    /// Turns on or off debug info.\n+    ///\n+    /// From what I can tell this just creates a \"names\" section of the wasm\n+    /// module which contains a table of the original function names.\n+    pub fn debuginfo(&mut self, debug: bool) -> &mut Self {\n+        unsafe {\n+            BinaryenRustModuleOptionsSetDebugInfo(self.ptr, debug);\n+        }\n+        self\n+    }\n+\n+    /// Configures a `start` function for the module, to be executed when it's\n+    /// loaded.\n+    pub fn start(&mut self, func: &str) -> &mut Self {\n+        let func = CString::new(func).unwrap();\n+        unsafe {\n+            BinaryenRustModuleOptionsSetStart(self.ptr, func.as_ptr());\n+        }\n+        self\n+    }\n+\n+    /// Configures how much stack is initially allocated for the module. 1MB is\n+    /// probably good enough for now.\n+    pub fn stack(&mut self, amt: u64) -> &mut Self {\n+        unsafe {\n+            BinaryenRustModuleOptionsSetStackAllocation(self.ptr, amt);\n+        }\n+        self\n+    }\n+\n+    /// Flags whether the initial memory should be imported or exported. So far\n+    /// we export it by default.\n+    pub fn import_memory(&mut self, import: bool) -> &mut Self {\n+        unsafe {\n+            BinaryenRustModuleOptionsSetImportMemory(self.ptr, import);\n+        }\n+        self\n+    }\n+}\n+\n+impl Drop for ModuleOptions {\n+    fn drop(&mut self) {\n+        unsafe {\n+            BinaryenRustModuleOptionsFree(self.ptr);\n+        }\n+    }\n+}\n+\n+enum BinaryenRustModule {}\n+enum BinaryenRustModuleOptions {}\n+\n+extern {\n+    fn BinaryenRustModuleCreate(opts: *const BinaryenRustModuleOptions,\n+                                assembly: *const libc::c_char)\n+        -> *mut BinaryenRustModule;\n+    fn BinaryenRustModulePtr(module: *const BinaryenRustModule) -> *const u8;\n+    fn BinaryenRustModuleLen(module: *const BinaryenRustModule) -> usize;\n+    fn BinaryenRustModuleFree(module: *mut BinaryenRustModule);\n+\n+    fn BinaryenRustModuleOptionsCreate()\n+        -> *mut BinaryenRustModuleOptions;\n+    fn BinaryenRustModuleOptionsSetDebugInfo(module: *mut BinaryenRustModuleOptions,\n+                                             debuginfo: bool);\n+    fn BinaryenRustModuleOptionsSetStart(module: *mut BinaryenRustModuleOptions,\n+                                         start: *const libc::c_char);\n+    fn BinaryenRustModuleOptionsSetStackAllocation(\n+        module: *mut BinaryenRustModuleOptions,\n+        stack: u64,\n+    );\n+    fn BinaryenRustModuleOptionsSetImportMemory(\n+        module: *mut BinaryenRustModuleOptions,\n+        import: bool,\n+    );\n+    fn BinaryenRustModuleOptionsFree(module: *mut BinaryenRustModuleOptions);\n+}"}, {"sha": "cff584c16802eb9785488d600003e77a0b70b75e", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -1606,7 +1606,8 @@ extern \"C\" {\n                                        PositionIndependentExecutable: bool,\n                                        FunctionSections: bool,\n                                        DataSections: bool,\n-                                       TrapUnreachable: bool)\n+                                       TrapUnreachable: bool,\n+                                       Singlethread: bool)\n                                        -> TargetMachineRef;\n     pub fn LLVMRustDisposeTargetMachine(T: TargetMachineRef);\n     pub fn LLVMRustAddAnalysisPasses(T: TargetMachineRef, PM: PassManagerRef, M: ModuleRef);"}, {"sha": "96102cad3ef5e1f57c5d50695d1c6ca347f58b1c", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -11,16 +11,17 @@ test = false\n \n [dependencies]\n bitflags = \"1.0\"\n-num_cpus = \"1.0\"\n flate2 = \"0.2\"\n jobserver = \"0.1.5\"\n log = \"0.3\"\n+num_cpus = \"1.0\"\n owning_ref = \"0.3.3\"\n-rustc-demangle = \"0.1.4\"\n rustc = { path = \"../librustc\" }\n+rustc-demangle = \"0.1.4\"\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_back = { path = \"../librustc_back\" }\n+rustc_binaryen = { path = \"../librustc_binaryen\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "89f182d178b9401a2d351f65acb78e112a5c4cfe", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -27,7 +27,7 @@ use rustc::util::common::time;\n use rustc::util::fs::fix_windows_verbatim_for_gcc;\n use rustc::hir::def_id::CrateNum;\n use rustc_back::tempdir::TempDir;\n-use rustc_back::{PanicStrategy, RelroLevel};\n+use rustc_back::{PanicStrategy, RelroLevel, LinkerFlavor};\n use context::get_reloc_model;\n use llvm;\n \n@@ -245,12 +245,12 @@ pub fn each_linked_rlib(sess: &Session,\n /// It's unusual for a crate to not participate in LTO. Typically only\n /// compiler-specific and unstable crates have a reason to not participate in\n /// LTO.\n-pub fn ignored_for_lto(info: &CrateInfo, cnum: CrateNum) -> bool {\n-    // `#![no_builtins]` crates don't participate in LTO because the state\n-    // of builtins gets messed up (our crate isn't tagged with no builtins).\n-    // Similarly `#![compiler_builtins]` doesn't participate because we want\n-    // those builtins!\n-    info.is_no_builtins.contains(&cnum) || info.compiler_builtins == Some(cnum)\n+pub fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum) -> bool {\n+    // If our target enables builtin function lowering in LLVM then the\n+    // crates providing these functions don't participate in LTO (e.g.\n+    // no_builtins or compiler builtins crates).\n+    !sess.target.target.options.no_builtins &&\n+        (info.is_no_builtins.contains(&cnum) || info.compiler_builtins == Some(cnum))\n }\n \n fn link_binary_output(sess: &Session,\n@@ -488,7 +488,7 @@ fn link_staticlib(sess: &Session,\n         });\n         ab.add_rlib(path,\n                     &name.as_str(),\n-                    sess.lto() && !ignored_for_lto(&trans.crate_info, cnum),\n+                    sess.lto() && !ignored_for_lto(sess, &trans.crate_info, cnum),\n                     skip_object_files).unwrap();\n \n         all_native_libs.extend(trans.crate_info.native_libraries[&cnum].iter().cloned());\n@@ -548,6 +548,11 @@ fn link_natively(sess: &Session,\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n     let flavor = sess.linker_flavor();\n \n+    // The \"binaryen linker\" is massively special, so skip everything below.\n+    if flavor == LinkerFlavor::Binaryen {\n+        return link_binaryen(sess, crate_type, out_filename, trans, tmpdir);\n+    }\n+\n     // The invocations of cc share some flags across platforms\n     let (pname, mut cmd, envs) = get_linker(sess);\n     // This will set PATH on windows\n@@ -1176,7 +1181,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n \n-        if (!sess.lto() || ignored_for_lto(&trans.crate_info, cnum)) &&\n+        if (!sess.lto() || ignored_for_lto(sess, &trans.crate_info, cnum)) &&\n            crate_type != config::CrateTypeDylib &&\n            !skip_native {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n@@ -1229,8 +1234,10 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                 // file, then we don't need the object file as it's part of the\n                 // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n                 // though, so we let that object file slide.\n-                let skip_because_lto = sess.lto() && is_rust_object &&\n-                                        !trans.crate_info.is_no_builtins.contains(&cnum);\n+                let skip_because_lto = sess.lto() &&\n+                    is_rust_object &&\n+                    (sess.target.target.options.no_builtins ||\n+                     !trans.crate_info.is_no_builtins.contains(&cnum));\n \n                 if skip_because_cfg_say_so || skip_because_lto {\n                     archive.remove_file(&f);\n@@ -1345,3 +1352,30 @@ fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n         None => true,\n     }\n }\n+\n+/// For now \"linking with binaryen\" is just \"move the one module we generated in\n+/// the backend to the final output\"\n+///\n+/// That is, all the heavy lifting happens during the `back::write` phase. Here\n+/// we just clean up after that.\n+///\n+/// Note that this is super temporary and \"will not survive the night\", this is\n+/// guaranteed to get removed as soon as a linker for wasm exists. This should\n+/// not be used for anything other than wasm.\n+fn link_binaryen(sess: &Session,\n+                 _crate_type: config::CrateType,\n+                 out_filename: &Path,\n+                 trans: &CrateTranslation,\n+                 _tmpdir: &Path) {\n+    assert!(trans.allocator_module.is_none());\n+    assert_eq!(trans.modules.len(), 1);\n+\n+    let object = trans.modules[0].object.as_ref().expect(\"object must exist\");\n+    let res = fs::hard_link(object, out_filename)\n+        .or_else(|_| fs::copy(object, out_filename).map(|_| ()));\n+    if let Err(e) = res {\n+        sess.fatal(&format!(\"failed to create `{}`: {}\",\n+                            out_filename.display(),\n+                            e));\n+    }\n+}"}, {"sha": "aa29c3cc120584477a47f45f1cb1c56f70d086be", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -77,6 +77,9 @@ impl LinkerInfo {\n                     is_ld: true,\n                 }) as Box<Linker>\n             }\n+            LinkerFlavor::Binaryen => {\n+                panic!(\"can't instantiate binaryen linker\")\n+            }\n         }\n     }\n }"}, {"sha": "fa6fe2e9e93ef78a1436d1fd0ee2399b2233b629", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -21,6 +21,7 @@ use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n use rustc::util::nodemap::FxHashMap;\n use rustc_allocator::ALLOCATOR_METHODS;\n+use rustc_back::LinkerFlavor;\n use syntax::attr;\n \n pub type ExportedSymbols = FxHashMap<\n@@ -154,12 +155,26 @@ pub fn provide_extern(providers: &mut Providers) {\n         let special_runtime_crate =\n             tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n \n+        // Dealing with compiler-builtins and wasm right now is super janky.\n+        // There's no linker! As a result we need all of the compiler-builtins\n+        // exported symbols to make their way through all the way to the end of\n+        // compilation. We want to make sure that LLVM doesn't remove them as\n+        // well because we may or may not need them in the final output\n+        // artifact. For now just force them to always get exported at the C\n+        // layer, and we'll worry about gc'ing them later.\n+        let compiler_builtins_and_binaryen =\n+            tcx.is_compiler_builtins(cnum) &&\n+            tcx.sess.linker_flavor() == LinkerFlavor::Binaryen;\n+\n         let mut crate_exports: Vec<_> = tcx\n             .exported_symbol_ids(cnum)\n             .iter()\n             .map(|&def_id| {\n                 let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                let export_level = if special_runtime_crate {\n+                let export_level = if compiler_builtins_and_binaryen &&\n+                                      tcx.contains_extern_indicator(def_id) {\n+                    SymbolExportLevel::C\n+                } else if special_runtime_crate {\n                     // We can probably do better here by just ensuring that\n                     // it has hidden visibility rather than public\n                     // visibility, as this is primarily here to ensure it's"}, {"sha": "da67940abcb776973862a2c1a71896be0c68b5cc", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 90, "deletions": 11, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -22,6 +22,7 @@ use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Pas\n                              AllPasses, Sanitizer};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n+use rustc_back::LinkerFlavor;\n use time_graph::{self, TimeGraph, Timeline};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n@@ -47,7 +48,7 @@ use std::any::Any;\n use std::ffi::{CString, CStr};\n use std::fs::{self, File};\n use std::io;\n-use std::io::Write;\n+use std::io::{Read, Write};\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::str;\n@@ -186,6 +187,8 @@ pub fn target_machine_factory(sess: &Session)\n         }\n     };\n \n+    let singlethread = sess.target.target.options.singlethread;\n+\n     let triple = &sess.target.target.llvm_target;\n \n     let triple = CString::new(triple.as_bytes()).unwrap();\n@@ -210,6 +213,7 @@ pub fn target_machine_factory(sess: &Session)\n                 ffunction_sections,\n                 fdata_sections,\n                 trap_unreachable,\n+                singlethread,\n             )\n         };\n \n@@ -287,7 +291,7 @@ impl ModuleConfig {\n     fn set_flags(&mut self, sess: &Session, no_builtins: bool) {\n         self.no_verify = sess.no_verify();\n         self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n-        self.no_builtins = no_builtins;\n+        self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n         self.time_passes = sess.time_passes();\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n         self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode;\n@@ -330,6 +334,9 @@ pub struct CodegenContext {\n     pub tm_factory: Arc<Fn() -> Result<TargetMachineRef, String> + Send + Sync>,\n     pub msvc_imps_needed: bool,\n     pub target_pointer_width: String,\n+    binaryen_linker: bool,\n+    debuginfo: config::DebugInfoLevel,\n+    wasm_import_memory: bool,\n \n     // Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n@@ -625,14 +632,21 @@ unsafe fn codegen(cgcx: &CodegenContext,\n         f(cpm)\n     }\n \n+    // If we're going to generate wasm code from the assembly that llvm\n+    // generates then we'll be transitively affecting a ton of options below.\n+    // This only happens on the wasm target now.\n+    let asm2wasm = cgcx.binaryen_linker &&\n+        !cgcx.crate_types.contains(&config::CrateTypeRlib) &&\n+        mtrans.kind == ModuleKind::Regular;\n+\n     // Change what we write and cleanup based on whether obj files are\n     // just llvm bitcode. In that case write bitcode, and possibly\n     // delete the bitcode if it wasn't requested. Don't generate the\n     // machine code, instead copy the .o file from the .bc\n-    let write_bc = config.emit_bc || config.obj_is_bitcode;\n-    let rm_bc = !config.emit_bc && config.obj_is_bitcode;\n-    let write_obj = config.emit_obj && !config.obj_is_bitcode;\n-    let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n+    let write_bc = config.emit_bc || (config.obj_is_bitcode && !asm2wasm);\n+    let rm_bc = !config.emit_bc && config.obj_is_bitcode && !asm2wasm;\n+    let write_obj = config.emit_obj && !config.obj_is_bitcode && !asm2wasm;\n+    let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode && !asm2wasm;\n \n     let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n     let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n@@ -711,7 +725,7 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             timeline.record(\"ir\");\n         }\n \n-        if config.emit_asm {\n+        if config.emit_asm || (asm2wasm && config.emit_obj) {\n             let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n             // We can't use the same module for asm and binary output, because that triggers\n@@ -732,7 +746,15 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             timeline.record(\"asm\");\n         }\n \n-        if write_obj {\n+        if asm2wasm && config.emit_obj {\n+            let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+            binaryen_assemble(cgcx, diag_handler, &assembly, &obj_out);\n+            timeline.record(\"binaryen\");\n+\n+            if !config.emit_asm {\n+                drop(fs::remove_file(&assembly));\n+            }\n+        } else if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n                                   llvm::FileType::ObjectFile)\n@@ -764,6 +786,44 @@ unsafe fn codegen(cgcx: &CodegenContext,\n                                    &cgcx.output_filenames))\n }\n \n+/// Translates the LLVM-generated `assembly` on the filesystem into a wasm\n+/// module using binaryen, placing the output at `object`.\n+///\n+/// In this case the \"object\" is actually a full and complete wasm module. We\n+/// won't actually be doing anything else to the output for now. This is all\n+/// pretty janky and will get removed as soon as a linker for wasm exists.\n+fn binaryen_assemble(cgcx: &CodegenContext,\n+                     handler: &Handler,\n+                     assembly: &Path,\n+                     object: &Path) {\n+    use rustc_binaryen::{Module, ModuleOptions};\n+\n+    let input = File::open(&assembly).and_then(|mut f| {\n+        let mut contents = Vec::new();\n+        f.read_to_end(&mut contents)?;\n+        Ok(CString::new(contents)?)\n+    });\n+    let mut options = ModuleOptions::new();\n+    if cgcx.debuginfo != config::NoDebugInfo {\n+        options.debuginfo(true);\n+    }\n+    if cgcx.crate_types.contains(&config::CrateTypeExecutable) {\n+        options.start(\"main\");\n+    }\n+    options.stack(1024 * 1024);\n+    options.import_memory(cgcx.wasm_import_memory);\n+    let assembled = input.and_then(|input| {\n+        Module::new(&input, &options)\n+            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))\n+    });\n+    let err = assembled.and_then(|binary| {\n+        File::create(&object).and_then(|mut f| f.write_all(binary.data()))\n+    });\n+    if let Err(e) = err {\n+        handler.err(&format!(\"failed to run binaryen assembler: {}\", e));\n+    }\n+}\n+\n pub struct CompiledModules {\n     pub modules: Vec<CompiledModule>,\n     pub metadata_module: CompiledModule,\n@@ -1318,17 +1378,33 @@ fn start_executing_work(tcx: TyCtxt,\n \n     let mut each_linked_rlib_for_lto = Vec::new();\n     drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n-        if link::ignored_for_lto(crate_info, cnum) {\n+        if link::ignored_for_lto(sess, crate_info, cnum) {\n             return\n         }\n         each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n     }));\n \n+    let crate_types = sess.crate_types.borrow();\n+    let only_rlib = crate_types.len() == 1 &&\n+        crate_types[0] == config::CrateTypeRlib;\n+\n+    let wasm_import_memory =\n+        attr::contains_name(&tcx.hir.krate().attrs, \"wasm_import_memory\");\n+\n     let cgcx = CodegenContext {\n         crate_types: sess.crate_types.borrow().clone(),\n         each_linked_rlib_for_lto,\n-        lto: sess.lto(),\n-        thinlto: sess.opts.debugging_opts.thinlto,\n+        // If we're only building an rlibc then allow the LTO flag to be passed\n+        // but don't actually do anything, the full LTO will happen later\n+        lto: sess.lto() && !only_rlib,\n+\n+        // Enable ThinLTO if requested, but only if the target we're compiling\n+        // for doesn't require full LTO. Some targets require one LLVM module\n+        // (they effectively don't have a linker) so it's up to us to use LTO to\n+        // link everything together.\n+        thinlto: sess.opts.debugging_opts.thinlto &&\n+            !sess.target.target.options.requires_lto,\n+\n         no_landing_pads: sess.no_landing_pads(),\n         save_temps: sess.opts.cg.save_temps,\n         opts: Arc::new(sess.opts.clone()),\n@@ -1349,6 +1425,9 @@ fn start_executing_work(tcx: TyCtxt,\n         total_cgus,\n         msvc_imps_needed: msvc_imps_needed(tcx),\n         target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n+        binaryen_linker: tcx.sess.linker_flavor() == LinkerFlavor::Binaryen,\n+        debuginfo: tcx.sess.opts.debuginfo,\n+        wasm_import_memory: wasm_import_memory,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen."}, {"sha": "ae25e7d94bffad18eb83fcd2769e0bf14dca75c3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -43,18 +43,19 @@ extern crate flate2;\n extern crate libc;\n extern crate owning_ref;\n #[macro_use] extern crate rustc;\n+extern crate jobserver;\n+extern crate num_cpus;\n extern crate rustc_allocator;\n extern crate rustc_apfloat;\n extern crate rustc_back;\n+extern crate rustc_binaryen;\n+extern crate rustc_const_math;\n extern crate rustc_data_structures;\n+extern crate rustc_demangle;\n extern crate rustc_incremental;\n extern crate rustc_llvm as llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n-extern crate rustc_const_math;\n extern crate rustc_trans_utils;\n-extern crate rustc_demangle;\n-extern crate jobserver;\n-extern crate num_cpus;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "c1e670cc7caf50f457bdee126eddcdca2b8f6b90", "filename": "src/librustc_trans_utils/link.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibrustc_trans_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flink.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -163,15 +163,30 @@ pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n /// Checks if target supports crate_type as output\n pub fn invalid_output_for_target(sess: &Session,\n                                  crate_type: config::CrateType) -> bool {\n-    match (sess.target.target.options.dynamic_linking,\n-           sess.target.target.options.executables, crate_type) {\n-        (false, _, config::CrateTypeCdylib) |\n-        (false, _, config::CrateTypeDylib) |\n-        (false, _, config::CrateTypeProcMacro) => true,\n-        (true, _, config::CrateTypeCdylib) |\n-        (true, _, config::CrateTypeDylib) => sess.crt_static() &&\n-            !sess.target.target.options.crt_static_allows_dylibs,\n-        (_, false, config::CrateTypeExecutable) => true,\n-        _ => false\n+    match crate_type {\n+        config::CrateTypeCdylib |\n+        config::CrateTypeDylib |\n+        config::CrateTypeProcMacro => {\n+            if !sess.target.target.options.dynamic_linking {\n+                return true\n+            }\n+            if sess.crt_static() && !sess.target.target.options.crt_static_allows_dylibs {\n+                return true\n+            }\n+        }\n+        _ => {}\n     }\n+    if sess.target.target.options.only_cdylib {\n+        match crate_type {\n+            config::CrateTypeProcMacro | config::CrateTypeDylib => return true,\n+            _ => {}\n+        }\n+    }\n+    if !sess.target.target.options.executables {\n+        if crate_type == config::CrateTypeExecutable {\n+            return true\n+        }\n+    }\n+\n+    false\n }"}, {"sha": "06f11c8deb458b559c2b43348885bb1f7c30ae07", "filename": "src/libstd/build.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -19,8 +19,12 @@ use build_helper::{run, native_lib_boilerplate, BuildExpectation};\n fn main() {\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n     let host = env::var(\"HOST\").expect(\"HOST was not set\");\n-    if cfg!(feature = \"backtrace\") && !target.contains(\"msvc\") &&\n-        !target.contains(\"emscripten\") && !target.contains(\"fuchsia\") {\n+    if cfg!(feature = \"backtrace\") &&\n+        !target.contains(\"msvc\") &&\n+        !target.contains(\"emscripten\") &&\n+        !target.contains(\"fuchsia\") &&\n+        !target.contains(\"wasm32\")\n+    {\n         let _ = build_libbacktrace(&host, &target);\n     }\n "}, {"sha": "14f0edc369058d2926c504c228ee2e01686cabed", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -26,7 +26,6 @@ use num::FpCategory;\n #[cfg(not(test))]\n use sys::cmath;\n \n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "9d0373404aaa75850131a040c81ae773330e5a34", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -663,3 +663,39 @@ pub mod builtin {\n     #[macro_export]\n     macro_rules! include { ($file:expr) => ({ /* compiler built-in */ }) }\n }\n+\n+/// A macro for defining #[cfg] if-else statements.\n+///\n+/// This is similar to the `if/elif` C preprocessor macro by allowing definition\n+/// of a cascade of `#[cfg]` cases, emitting the implementation which matches\n+/// first.\n+///\n+/// This allows you to conveniently provide a long list #[cfg]'d blocks of code\n+/// without having to rewrite each clause multiple times.\n+macro_rules! cfg_if {\n+    ($(\n+        if #[cfg($($meta:meta),*)] { $($it:item)* }\n+    ) else * else {\n+        $($it2:item)*\n+    }) => {\n+        __cfg_if_items! {\n+            () ;\n+            $( ( ($($meta),*) ($($it)*) ), )*\n+            ( () ($($it2)*) ),\n+        }\n+    }\n+}\n+\n+macro_rules! __cfg_if_items {\n+    (($($not:meta,)*) ; ) => {};\n+    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+        __cfg_if_apply! { cfg(all(not(any($($not),*)), $($m,)*)), $($it)* }\n+        __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n+    }\n+}\n+\n+macro_rules! __cfg_if_apply {\n+    ($m:meta, $($it:item)*) => {\n+        $(#[$m] $it)*\n+    }\n+}"}, {"sha": "27d6433b329bbb3b8c6a6b85fe7d0c9ef969936c", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -46,6 +46,9 @@ mod imp;\n #[path = \"redox/mod.rs\"]\n mod imp;\n \n+#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+#[path = \"wasm/mod.rs\"]\n+mod imp;\n \n // Import essential modules from both platforms when documenting.\n "}, {"sha": "d2a4a7b19d548427711a0068c8ae1214dacf73a3", "filename": "src/libstd/sys/wasm/args.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fargs.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsString;\n+use marker::PhantomData;\n+use mem;\n+use vec;\n+\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n+    // On wasm these should always be null, so there's nothing for us to do here\n+}\n+\n+pub unsafe fn cleanup() {\n+}\n+\n+pub fn args() -> Args {\n+    // When the runtime debugging is enabled we'll link to some extra runtime\n+    // functions to actually implement this. These are for now just implemented\n+    // in a node.js script but they're off by default as they're sort of weird\n+    // in a web-wasm world.\n+    if !super::DEBUG {\n+        return Args {\n+            iter: Vec::new().into_iter(),\n+            _dont_send_or_sync_me: PhantomData,\n+        }\n+    }\n+\n+    // You'll find the definitions of these in `src/etc/wasm32-shim.js`. These\n+    // are just meant for debugging and should not be relied on.\n+    extern {\n+        fn rust_wasm_args_count() -> usize;\n+        fn rust_wasm_args_arg_size(a: usize) -> usize;\n+        fn rust_wasm_args_arg_fill(a: usize, ptr: *mut u8);\n+    }\n+\n+    unsafe {\n+        let cnt = rust_wasm_args_count();\n+        let mut v = Vec::with_capacity(cnt);\n+        for i in 0..cnt {\n+            let n = rust_wasm_args_arg_size(i);\n+            let mut data = vec![0; n];\n+            rust_wasm_args_arg_fill(i, data.as_mut_ptr());\n+            v.push(mem::transmute::<Vec<u8>, OsString>(data));\n+        }\n+        Args {\n+            iter: v.into_iter(),\n+            _dont_send_or_sync_me: PhantomData,\n+        }\n+    }\n+}\n+\n+pub struct Args {\n+    iter: vec::IntoIter<OsString>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Args {\n+    pub fn inner_debug(&self) -> &[OsString] {\n+        self.iter.as_slice()\n+    }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.iter.next_back()\n+    }\n+}"}, {"sha": "9a8c48ff29fc768ad5c790e38d73065b6dc2a557", "filename": "src/libstd/sys/wasm/backtrace.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fbacktrace.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::unsupported;\n+use sys_common::backtrace::Frame;\n+\n+pub struct BacktraceContext;\n+\n+pub fn unwind_backtrace(_frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    unsupported()\n+}\n+\n+pub fn resolve_symname<F>(_frame: Frame,\n+                          _callback: F,\n+                          _: &BacktraceContext) -> io::Result<()>\n+    where F: FnOnce(Option<&str>) -> io::Result<()>\n+{\n+    unsupported()\n+}\n+\n+pub fn foreach_symbol_fileline<F>(_: Frame,\n+                                  _: F,\n+                                  _: &BacktraceContext) -> io::Result<bool>\n+    where F: FnMut(&[u8], u32) -> io::Result<()>\n+{\n+    unsupported()\n+}"}, {"sha": "87ac2091cad41f44a5523370273b24fce39b7029", "filename": "src/libstd/sys/wasm/cmath.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fcmath.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[inline]\n+pub unsafe fn cbrtf(n: f32) -> f32 {\n+    f64::cbrt(n as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn expm1f(n: f32) -> f32 {\n+    f64::exp_m1(n as f64) as f32\n+}\n+\n+#[inline]\n+#[allow(deprecated)]\n+pub unsafe fn fdimf(a: f32, b: f32) -> f32 {\n+    f64::abs_sub(a as f64, b as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn log1pf(n: f32) -> f32 {\n+    f64::ln_1p(n as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn hypotf(x: f32, y: f32) -> f32 {\n+    f64::hypot(x as f64, y as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn acosf(n: f32) -> f32 {\n+    f64::acos(n as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn asinf(n: f32) -> f32 {\n+    f64::asin(n as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn atan2f(n: f32, b: f32) -> f32 {\n+    f64::atan2(n as f64, b as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn atanf(n: f32) -> f32 {\n+    f64::atan(n as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn coshf(n: f32) -> f32 {\n+    f64::cosh(n as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn sinhf(n: f32) -> f32 {\n+    f64::sinh(n as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn tanf(n: f32) -> f32 {\n+    f64::tan(n as f64) as f32\n+}\n+\n+#[inline]\n+pub unsafe fn tanhf(n: f32) -> f32 {\n+    f64::tanh(n as f64) as f32\n+}\n+\n+// Right now all these functions, the f64 version of the functions above, all\n+// shell out to random names. These names aren't actually defined anywhere, per\n+// se, but we need this to compile somehow.\n+//\n+// The idea with this is that when you're using wasm then, for now, we have no\n+// way of providing an implementation of these which delegates to a \"correct\"\n+// implementation. For example most wasm applications probably just want to\n+// delegate to the javascript `Math` object and its related functions, but wasm\n+// doesn't currently have the ability to seamlessly do that (when you\n+// instantiate a module you have to set that up).\n+//\n+// As a result these are just defined here with \"hopefully helpful\" names. The\n+// symbols won't ever be needed or show up unless these functions are called,\n+// and hopefully when they're called the errors are self-explanatory enough to\n+// figure out what's going on.\n+\n+extern {\n+    #[link_name = \"Math_acos\"]\n+    pub fn acos(n: f64) -> f64;\n+    #[link_name = \"Math_asin\"]\n+    pub fn asin(n: f64) -> f64;\n+    #[link_name = \"Math_atan\"]\n+    pub fn atan(n: f64) -> f64;\n+    #[link_name = \"Math_atan2\"]\n+    pub fn atan2(a: f64, b: f64) -> f64;\n+    #[link_name = \"Math_cbrt\"]\n+    pub fn cbrt(n: f64) -> f64;\n+    #[link_name = \"Math_cosh\"]\n+    pub fn cosh(n: f64) -> f64;\n+    #[link_name = \"Math_expm1\"]\n+    pub fn expm1(n: f64) -> f64;\n+    pub fn fdim(a: f64, b: f64) -> f64;\n+    #[link_name = \"Math_log1p\"]\n+    pub fn log1p(n: f64) -> f64;\n+    #[link_name = \"Math_sinh\"]\n+    pub fn sinh(n: f64) -> f64;\n+    #[link_name = \"Math_tan\"]\n+    pub fn tan(n: f64) -> f64;\n+    #[link_name = \"Math_tanh\"]\n+    pub fn tanh(n: f64) -> f64;\n+    #[link_name = \"Math_hypot\"]\n+    pub fn hypot(x: f64, y: f64) -> f64;\n+}"}, {"sha": "afa7afeef5988931f90729460d6d861ce0615255", "filename": "src/libstd/sys/wasm/condvar.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fcondvar.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sys::mutex::Mutex;\n+use time::Duration;\n+\n+pub struct Condvar { }\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar { }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {}\n+\n+    #[inline]\n+    pub unsafe fn notify_one(&self) {\n+    }\n+\n+    #[inline]\n+    pub unsafe fn notify_all(&self) {\n+    }\n+\n+    pub unsafe fn wait(&self, _mutex: &Mutex) {\n+        panic!(\"can't block with web assembly\")\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+        panic!(\"can't block with web assembly\");\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+    }\n+}"}, {"sha": "1422042bd02284a40374ee0d838402c5604b243b", "filename": "src/libstd/sys/wasm/env.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fenv.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod os {\n+    pub const FAMILY: &'static str = \"\";\n+    pub const OS: &'static str = \"\";\n+    pub const DLL_PREFIX: &'static str = \"\";\n+    pub const DLL_SUFFIX: &'static str = \".wasm\";\n+    pub const DLL_EXTENSION: &'static str = \"wasm\";\n+    pub const EXE_SUFFIX: &'static str = \".wasm\";\n+    pub const EXE_EXTENSION: &'static str = \"wasm\";\n+}"}, {"sha": "b3c70a6685a6cf4f662fe38e5a2ad66deb29d3fc", "filename": "src/libstd/sys/wasm/fs.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ffs.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,304 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsString;\n+use fmt;\n+use hash::{Hash, Hasher};\n+use io::{self, SeekFrom};\n+use path::{Path, PathBuf};\n+use sys::time::SystemTime;\n+use sys::{unsupported, Void};\n+\n+pub struct File(Void);\n+\n+pub struct FileAttr(Void);\n+\n+pub struct ReadDir(Void);\n+\n+pub struct DirEntry(Void);\n+\n+#[derive(Clone, Debug)]\n+pub struct OpenOptions { }\n+\n+pub struct FilePermissions(Void);\n+\n+pub struct FileType(Void);\n+\n+#[derive(Debug)]\n+pub struct DirBuilder { }\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 {\n+        match self.0 {}\n+    }\n+\n+    pub fn perm(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        match self.0 {}\n+    }\n+\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileAttr {\n+    fn clone(&self) -> FileAttr {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_readonly(&mut self, _readonly: bool) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FilePermissions {\n+    fn clone(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+}\n+\n+impl PartialEq for FilePermissions {\n+    fn eq(&self, _other: &FilePermissions) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FilePermissions {\n+}\n+\n+impl fmt::Debug for FilePermissions {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_file(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_symlink(&self) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileType {\n+    fn clone(&self) -> FileType {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for FileType {}\n+\n+impl PartialEq for FileType {\n+    fn eq(&self, _other: &FileType) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FileType {\n+}\n+\n+impl Hash for FileType {\n+    fn hash<H: Hasher>(&self, _h: &mut H) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for FileType {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        match self.0 {}\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions { }\n+    }\n+\n+    pub fn read(&mut self, _read: bool) { }\n+    pub fn write(&mut self, _write: bool) { }\n+    pub fn append(&mut self, _append: bool) { }\n+    pub fn truncate(&mut self, _truncate: bool) { }\n+    pub fn create(&mut self, _create: bool) { }\n+    pub fn create_new(&mut self, _create_new: bool) { }\n+}\n+\n+impl File {\n+    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {\n+        unsupported()\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder { }\n+    }\n+\n+    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n+        unsupported()\n+    }\n+}\n+\n+impl fmt::Debug for File {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n+    unsupported()\n+}\n+\n+pub fn unlink(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    match perm.0 {}\n+}\n+\n+pub fn rmdir(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn stat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {\n+    unsupported()\n+}"}, {"sha": "e611d94af30b10ecb957624061b60bfc9bade1cc", "filename": "src/libstd/sys/wasm/memchr.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmemchr.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use sys_common::memchr::fallback::{memchr, memrchr};"}, {"sha": "b838dbafd6f0c368cdef871d3ffb1165ce99c135", "filename": "src/libstd/sys/wasm/mod.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! System bindings for the wasm/web platform\n+//!\n+//! This module contains the facade (aka platform-specific) implementations of\n+//! OS level functionality for wasm. Note that this wasm is *not* the emscripten\n+//! wasm, so we have no runtime here.\n+//!\n+//! This is all super highly experimental and not actually intended for\n+//! wide/production use yet, it's still all in the experimental category. This\n+//! will likely change over time.\n+//!\n+//! Currently all functions here are basically stubs that immediately return\n+//! errors. The hope is that with a portability lint we can turn actually just\n+//! remove all this and just omit parts of the standard library if we're\n+//! compiling for wasm. That way it's a compile time error for something that's\n+//! guaranteed to be a runtime error!\n+\n+use io;\n+use os::raw::c_char;\n+\n+// Right now the wasm backend doesn't even have the ability to print to the\n+// console by default. Wasm can't import anything from JS! (you have to\n+// explicitly provide it).\n+//\n+// Sometimes that's a real bummer, though, so this flag can be set to `true` to\n+// enable calling various shims defined in `src/etc/wasm32-shim.js` which should\n+// help receive debug output and see what's going on. In general this flag\n+// currently controls \"will we call out to our own defined shims in node.js\",\n+// and this flag should always be `false` for release builds.\n+const DEBUG: bool = false;\n+\n+pub mod args;\n+pub mod backtrace;\n+pub mod cmath;\n+pub mod condvar;\n+pub mod env;\n+pub mod fs;\n+pub mod memchr;\n+pub mod mutex;\n+pub mod net;\n+pub mod os;\n+pub mod os_str;\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod rwlock;\n+pub mod stack_overflow;\n+pub mod thread;\n+pub mod thread_local;\n+pub mod time;\n+pub mod stdio;\n+\n+#[cfg(not(test))]\n+pub fn init() {\n+}\n+\n+pub fn unsupported<T>() -> io::Result<T> {\n+    Err(unsupported_err())\n+}\n+\n+pub fn unsupported_err() -> io::Error {\n+    io::Error::new(io::ErrorKind::Other,\n+                   \"operation not supported on wasm yet\")\n+}\n+\n+pub fn decode_error_kind(_code: i32) -> io::ErrorKind {\n+    io::ErrorKind::Other\n+}\n+\n+// This enum is used as the storage for a bunch of types which can't actually\n+// exist.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub enum Void {}\n+\n+pub unsafe fn strlen(mut s: *const c_char) -> usize {\n+    let mut n = 0;\n+    while *s != 0 {\n+        n += 1;\n+        s = s.offset(1);\n+    }\n+    return n\n+}\n+\n+pub unsafe fn abort_internal() -> ! {\n+    ::intrinsics::abort();\n+}\n+\n+// We don't have randomness yet, but I totally used a random number generator to\n+// generate these numbers.\n+//\n+// More seriously though this is just for DOS protection in hash maps. It's ok\n+// if we don't do that on wasm just yet.\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    (1, 2)\n+}"}, {"sha": "4197bdcc8083907778a0870a384efea0faf9f1cf", "filename": "src/libstd/sys/wasm/mutex.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmutex.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+\n+pub struct Mutex {\n+    locked: UnsafeCell<bool>,\n+}\n+\n+unsafe impl Send for Mutex {}\n+unsafe impl Sync for Mutex {} // no threads on wasm\n+\n+impl Mutex {\n+    pub const fn new() -> Mutex {\n+        Mutex { locked: UnsafeCell::new(false) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn init(&mut self) {\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) {\n+        let locked = self.locked.get();\n+        assert!(!*locked, \"cannot recursively acquire mutex\");\n+        *locked = true;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn unlock(&self) {\n+        *self.locked.get() = false;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        let locked = self.locked.get();\n+        if *locked {\n+            false\n+        } else {\n+            *locked = true;\n+            true\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+    }\n+}\n+\n+// All empty stubs because wasm has no threads yet, so lock acquisition always\n+// succeeds.\n+pub struct ReentrantMutex {\n+}\n+\n+impl ReentrantMutex {\n+    pub unsafe fn uninitialized() -> ReentrantMutex {\n+        ReentrantMutex { }\n+    }\n+\n+    pub unsafe fn init(&mut self) {}\n+\n+    pub unsafe fn lock(&self) {}\n+\n+    #[inline]\n+    pub unsafe fn try_lock(&self) -> bool {\n+        true\n+    }\n+\n+    pub unsafe fn unlock(&self) {}\n+\n+    pub unsafe fn destroy(&self) {}\n+}"}, {"sha": "e7476ab37f7c86710a2a7959974b6e104203e41c", "filename": "src/libstd/sys/wasm/net.rs", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fnet.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,337 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+use io;\n+use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr};\n+use time::Duration;\n+use sys::{unsupported, Void};\n+\n+pub struct TcpStream(Void);\n+\n+impl TcpStream {\n+    pub fn connect(_: &SocketAddr) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpStream> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpStream {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct TcpListener(Void);\n+\n+impl TcpListener {\n+    pub fn bind(_: &SocketAddr) -> io::Result<TcpListener> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpListener> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpListener {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct UdpSocket(Void);\n+\n+impl UdpSocket {\n+    pub fn bind(_: &SocketAddr) -> io::Result<UdpSocket> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                         -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                         -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr)\n+                          -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32)\n+                          -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn connect(&self, _: &SocketAddr) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for UdpSocket {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct LookupHost(Void);\n+\n+impl Iterator for LookupHost {\n+    type Item = SocketAddr;\n+    fn next(&mut self) -> Option<SocketAddr> {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n+    unsupported()\n+}\n+\n+#[allow(bad_style)]\n+pub mod netc {\n+    pub const AF_INET: u8 = 0;\n+    pub const AF_INET6: u8 = 1;\n+    pub type sa_family_t = u8;\n+\n+    #[derive(Copy, Clone)]\n+    pub struct in_addr {\n+        pub s_addr: u32,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr_in {\n+        pub sin_family: sa_family_t,\n+        pub sin_port: u16,\n+        pub sin_addr: in_addr,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct in6_addr {\n+        pub s6_addr: [u8; 16],\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr_in6 {\n+        pub sin6_family: sa_family_t,\n+        pub sin6_port: u16,\n+        pub sin6_addr: in6_addr,\n+        pub sin6_flowinfo: u32,\n+        pub sin6_scope_id: u32,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    pub struct sockaddr {\n+    }\n+\n+    pub type socklen_t = usize;\n+}"}, {"sha": "c98030f7ebf532f7bd843f981d6ea48dacfbba90", "filename": "src/libstd/sys/wasm/os.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fos.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,136 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::intrinsics;\n+\n+use error::Error as StdError;\n+use ffi::{OsString, OsStr};\n+use fmt;\n+use io;\n+use mem;\n+use path::{self, PathBuf};\n+use str;\n+use sys::{unsupported, Void};\n+\n+pub fn errno() -> i32 {\n+    0\n+}\n+\n+pub fn error_string(_errno: i32) -> String {\n+    format!(\"operation successful\")\n+}\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn chdir(_: &path::Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub struct SplitPaths<'a>(&'a Void);\n+\n+pub fn split_paths(_unparsed: &OsStr) -> SplitPaths {\n+    panic!(\"unsupported\")\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> {\n+        match *self.0 {}\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n+{\n+    Err(JoinPathsError)\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"not supported on wasm yet\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str {\n+        \"not supported on wasm yet\"\n+    }\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub struct Env(Void);\n+\n+impl Iterator for Env {\n+    type Item = (OsString, OsString);\n+    fn next(&mut self) -> Option<(OsString, OsString)> {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn env() -> Env {\n+    panic!(\"not supported on web assembly\")\n+}\n+\n+pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n+    // If we're debugging the runtime then we actually probe node.js to ask for\n+    // the value of environment variables to help provide inputs to programs.\n+    // The `extern` shims here are defined in `src/etc/wasm32-shim.js` and are\n+    // intended for debugging only, you should not rely on them.\n+    if !super::DEBUG {\n+        return Ok(None)\n+    }\n+\n+    extern {\n+        fn rust_wasm_getenv_len(k: *const u8, kl: usize) -> isize;\n+        fn rust_wasm_getenv_data(k: *const u8, kl: usize, v: *mut u8);\n+    }\n+    unsafe {\n+        let k: &[u8] = mem::transmute(k);\n+        let n = rust_wasm_getenv_len(k.as_ptr(), k.len());\n+        if n == -1 {\n+            return Ok(None)\n+        }\n+        let mut data = vec![0; n as usize];\n+        rust_wasm_getenv_data(k.as_ptr(), k.len(), data.as_mut_ptr());\n+        Ok(Some(mem::transmute(data)))\n+    }\n+}\n+\n+pub fn setenv(_k: &OsStr, _v: &OsStr) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn unsetenv(_n: &OsStr) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    panic!(\"no filesystem on wasm\")\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    None\n+}\n+\n+pub fn exit(_code: i32) -> ! {\n+    unsafe { intrinsics::abort() }\n+}\n+\n+pub fn getpid() -> u32 {\n+    panic!(\"no pids on wasm\")\n+}"}, {"sha": "c5908a7a8dc227a3ad2227311cb010e10f24865d", "filename": "src/libstd/sys/wasm/os_str.rs", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fos_str.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,159 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The underlying OsString/OsStr implementation on Unix systems: just\n+/// a `Vec<u8>`/`[u8]`.\n+\n+use borrow::Cow;\n+use fmt;\n+use str;\n+use mem;\n+use sys_common::{AsInner, IntoInner};\n+use std_unicode::lossy::Utf8Lossy;\n+\n+#[derive(Clone, Hash)]\n+pub struct Buf {\n+    pub inner: Vec<u8>\n+}\n+\n+pub struct Slice {\n+    pub inner: [u8]\n+}\n+\n+impl fmt::Debug for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n+    }\n+}\n+\n+impl fmt::Display for Slice {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&Utf8Lossy::from_bytes(&self.inner), formatter)\n+    }\n+}\n+\n+impl fmt::Debug for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.as_slice(), formatter)\n+    }\n+}\n+\n+impl fmt::Display for Buf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.as_slice(), formatter)\n+    }\n+}\n+\n+impl IntoInner<Vec<u8>> for Buf {\n+    fn into_inner(self) -> Vec<u8> {\n+        self.inner\n+    }\n+}\n+\n+impl AsInner<[u8]> for Buf {\n+    fn as_inner(&self) -> &[u8] {\n+        &self.inner\n+    }\n+}\n+\n+\n+impl Buf {\n+    pub fn from_string(s: String) -> Buf {\n+        Buf { inner: s.into_bytes() }\n+    }\n+\n+    #[inline]\n+    pub fn with_capacity(capacity: usize) -> Buf {\n+        Buf {\n+            inner: Vec::with_capacity(capacity)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.inner.clear()\n+    }\n+\n+    #[inline]\n+    pub fn capacity(&self) -> usize {\n+        self.inner.capacity()\n+    }\n+\n+    #[inline]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.inner.reserve(additional)\n+    }\n+\n+    #[inline]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.inner.reserve_exact(additional)\n+    }\n+\n+    #[inline]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.inner.shrink_to_fit()\n+    }\n+\n+    pub fn as_slice(&self) -> &Slice {\n+        unsafe { mem::transmute(&*self.inner) }\n+    }\n+\n+    pub fn into_string(self) -> Result<String, Buf> {\n+        String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() } )\n+    }\n+\n+    pub fn push_slice(&mut self, s: &Slice) {\n+        self.inner.extend_from_slice(&s.inner)\n+    }\n+\n+    #[inline]\n+    pub fn into_box(self) -> Box<Slice> {\n+        unsafe { mem::transmute(self.inner.into_boxed_slice()) }\n+    }\n+\n+    #[inline]\n+    pub fn from_box(boxed: Box<Slice>) -> Buf {\n+        let inner: Box<[u8]> = unsafe { mem::transmute(boxed) };\n+        Buf { inner: inner.into_vec() }\n+    }\n+}\n+\n+impl Slice {\n+    fn from_u8_slice(s: &[u8]) -> &Slice {\n+        unsafe { mem::transmute(s) }\n+    }\n+\n+    pub fn from_str(s: &str) -> &Slice {\n+        Slice::from_u8_slice(s.as_bytes())\n+    }\n+\n+    pub fn to_str(&self) -> Option<&str> {\n+        str::from_utf8(&self.inner).ok()\n+    }\n+\n+    pub fn to_string_lossy(&self) -> Cow<str> {\n+        String::from_utf8_lossy(&self.inner)\n+    }\n+\n+    pub fn to_owned(&self) -> Buf {\n+        Buf { inner: self.inner.to_vec() }\n+    }\n+\n+    #[inline]\n+    pub fn into_box(&self) -> Box<Slice> {\n+        let boxed: Box<[u8]> = self.inner.into();\n+        unsafe { mem::transmute(boxed) }\n+    }\n+\n+    pub fn empty_box() -> Box<Slice> {\n+        let boxed: Box<[u8]> = Default::default();\n+        unsafe { mem::transmute(boxed) }\n+    }\n+}"}, {"sha": "395b8c1e40e982c0d35e7467dd08aa46bd539ec0", "filename": "src/libstd/sys/wasm/path.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fpath.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use path::Prefix;\n+use ffi::OsStr;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+pub fn parse_prefix(_: &OsStr) -> Option<Prefix> {\n+    None\n+}\n+\n+pub const MAIN_SEP_STR: &'static str = \"/\";\n+pub const MAIN_SEP: char = '/';"}, {"sha": "992e1ac409cfbb401095b117ed75bf27d70a0032", "filename": "src/libstd/sys/wasm/pipe.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fpipe.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::Void;\n+\n+pub struct AnonPipe(Void);\n+\n+impl AnonPipe {\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn read2(p1: AnonPipe,\n+             _v1: &mut Vec<u8>,\n+             _p2: AnonPipe,\n+             _v2: &mut Vec<u8>) -> io::Result<()> {\n+    match p1.0 {}\n+}"}, {"sha": "4febe8a1463825ee48b05c33ac63a1f6508429ed", "filename": "src/libstd/sys/wasm/process.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsStr;\n+use fmt;\n+use io;\n+use sys::fs::File;\n+use sys::pipe::AnonPipe;\n+use sys::{unsupported, Void};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+}\n+\n+impl Command {\n+    pub fn new(_program: &OsStr) -> Command {\n+        Command {}\n+    }\n+\n+    pub fn arg(&mut self, _arg: &OsStr) {\n+    }\n+\n+    pub fn env(&mut self, _key: &OsStr, _val: &OsStr) {\n+    }\n+\n+    pub fn env_remove(&mut self, _key: &OsStr) {\n+    }\n+\n+    pub fn env_clear(&mut self) {\n+    }\n+\n+    pub fn cwd(&mut self, _dir: &OsStr) {\n+    }\n+\n+    pub fn stdin(&mut self, _stdin: Stdio) {\n+    }\n+\n+    pub fn stdout(&mut self, _stdout: Stdio) {\n+    }\n+\n+    pub fn stderr(&mut self, _stderr: Stdio) {\n+    }\n+\n+    pub fn spawn(&mut self, _default: Stdio, _needs_stdin: bool)\n+        -> io::Result<(Process, StdioPipes)> {\n+        unsupported()\n+    }\n+}\n+\n+impl From<AnonPipe> for Stdio {\n+    fn from(pipe: AnonPipe) -> Stdio {\n+        pipe.diverge()\n+    }\n+}\n+\n+impl From<File> for Stdio {\n+    fn from(file: File) -> Stdio {\n+        file.diverge()\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+pub struct ExitStatus(Void);\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for ExitStatus {\n+    fn clone(&self) -> ExitStatus {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for ExitStatus {}\n+\n+impl PartialEq for ExitStatus {\n+    fn eq(&self, _other: &ExitStatus) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for ExitStatus {\n+}\n+\n+impl fmt::Debug for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct Process(Void);\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        match self.0 {}\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        match self.0 {}\n+    }\n+\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        match self.0 {}\n+    }\n+}"}, {"sha": "8b06f54167487dd6cd38955b5b567efa2d24ed10", "filename": "src/libstd/sys/wasm/rwlock.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Frwlock.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+\n+pub struct RWLock {\n+    mode: UnsafeCell<isize>,\n+}\n+\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {} // no threads on wasm\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock {\n+            mode: UnsafeCell::new(0),\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        let mode = self.mode.get();\n+        if *mode >= 0 {\n+            *mode += 1;\n+        } else {\n+            panic!(\"rwlock locked for writing\");\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        let mode = self.mode.get();\n+        if *mode >= 0 {\n+            *mode += 1;\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        let mode = self.mode.get();\n+        if *mode == 0 {\n+            *mode = -1;\n+        } else {\n+            panic!(\"rwlock locked for reading\")\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        let mode = self.mode.get();\n+        if *mode == 0 {\n+            *mode = -1;\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        *self.mode.get() -= 1;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        *self.mode.get() += 1;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+    }\n+}"}, {"sha": "bed274142f1ce12d20fb4b57fad7f40b0e2c49cc", "filename": "src/libstd/sys/wasm/stack_overflow.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Handler;\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        Handler\n+    }\n+}\n+\n+pub unsafe fn init() {\n+}\n+\n+pub unsafe fn cleanup() {\n+}"}, {"sha": "0f75f240251832e5587aac6334afcf6db590916b", "filename": "src/libstd/sys/wasm/stdio.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstdio.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::{Void, unsupported};\n+\n+pub struct Stdin(Void);\n+pub struct Stdout;\n+pub struct Stderr;\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> {\n+        unsupported()\n+    }\n+\n+    pub fn read(&self, _data: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout)\n+    }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        // If runtime debugging is enabled at compile time we'll invoke some\n+        // runtime functions that are defined in our src/etc/wasm32-shim.js\n+        // debugging script. Note that this ffi function call is intended\n+        // *purely* for debugging only and should not be relied upon.\n+        if !super::DEBUG {\n+            return unsupported()\n+        }\n+        extern {\n+            fn rust_wasm_write_stdout(data: *const u8, len: usize);\n+        }\n+        unsafe {\n+            rust_wasm_write_stdout(data.as_ptr(), data.len())\n+        }\n+        Ok(data.len())\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr)\n+    }\n+\n+    pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n+        // See comments in stdout for what's going on here.\n+        if !super::DEBUG {\n+            return unsupported()\n+        }\n+        extern {\n+            fn rust_wasm_write_stderr(data: *const u8, len: usize);\n+        }\n+        unsafe {\n+            rust_wasm_write_stderr(data.as_ptr(), data.len())\n+        }\n+        Ok(data.len())\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        (&*self).write(data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        (&*self).flush()\n+    }\n+}\n+\n+pub const STDIN_BUF_SIZE: usize = 0;\n+\n+pub fn is_ebadf(_err: &io::Error) -> bool {\n+    true\n+}"}, {"sha": "13980e0cc19d1bae2fc8a161467283ec01c3c41e", "filename": "src/libstd/sys/wasm/thread.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::boxed::FnBox;\n+use ffi::CStr;\n+use io;\n+use sys::{unsupported, Void};\n+use time::Duration;\n+\n+pub struct Thread(Void);\n+\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 4096;\n+\n+impl Thread {\n+    pub unsafe fn new<'a>(_stack: usize, _p: Box<FnBox() + 'a>)\n+        -> io::Result<Thread>\n+    {\n+        unsupported()\n+    }\n+\n+    pub fn yield_now() {\n+        // do nothing\n+    }\n+\n+    pub fn set_name(_name: &CStr) {\n+        // nope\n+    }\n+\n+    pub fn sleep(_dur: Duration) {\n+        panic!(\"can't sleep\");\n+    }\n+\n+    pub fn join(self) {\n+        match self.0 {}\n+    }\n+}\n+\n+pub mod guard {\n+    pub unsafe fn current() -> Option<usize> { None }\n+    pub unsafe fn init() -> Option<usize> { None }\n+}"}, {"sha": "442dd3302a0587155f117a9ee7bbfcad7ebbaa26", "filename": "src/libstd/sys/wasm/thread_local.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use boxed::Box;\n+use ptr;\n+\n+pub type Key = usize;\n+\n+struct Allocated {\n+    value: *mut u8,\n+    dtor: Option<unsafe extern fn(*mut u8)>,\n+}\n+\n+#[inline]\n+pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    Box::into_raw(Box::new(Allocated {\n+        value: ptr::null_mut(),\n+        dtor,\n+    })) as usize\n+}\n+\n+#[inline]\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    (*(key as *mut Allocated)).value = value;\n+}\n+\n+#[inline]\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    (*(key as *mut Allocated)).value\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(key: Key) {\n+    let key = Box::from_raw(key as *mut Allocated);\n+    if let Some(f) = key.dtor {\n+        f(key.value);\n+    }\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    false\n+}"}, {"sha": "7907720e4dac631177870a223302ac98505ef4ee", "filename": "src/libstd/sys/wasm/time.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+use time::Duration;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+pub struct Instant;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct SystemTime;\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime;\n+\n+impl Instant {\n+    pub fn now() -> Instant {\n+        panic!(\"not supported on web assembly\");\n+    }\n+\n+    pub fn sub_instant(&self, _other: &Instant) -> Duration {\n+        panic!(\"can't sub yet\");\n+    }\n+\n+    pub fn add_duration(&self, _other: &Duration) -> Instant {\n+        panic!(\"can't add yet\");\n+    }\n+\n+    pub fn sub_duration(&self, _other: &Duration) -> Instant {\n+        panic!(\"can't sub yet\");\n+    }\n+}\n+\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        panic!(\"not supported on web assembly\");\n+    }\n+\n+    pub fn sub_time(&self, _other: &SystemTime)\n+                    -> Result<Duration, Duration> {\n+        panic!()\n+    }\n+\n+    pub fn add_duration(&self, _other: &Duration) -> SystemTime {\n+        panic!()\n+    }\n+\n+    pub fn sub_duration(&self, _other: &Duration) -> SystemTime {\n+        panic!()\n+    }\n+}\n+\n+impl fmt::Debug for SystemTime {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        panic!()\n+    }\n+}"}, {"sha": "14e5697b94e5798a3e5685a6890b5db4525e87c0", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -44,11 +44,15 @@ pub mod thread_local;\n pub mod util;\n pub mod wtf8;\n \n-#[cfg(any(target_os = \"redox\", target_os = \"l4re\"))]\n-pub use sys::net;\n-\n-#[cfg(not(any(target_os = \"redox\", target_os = \"l4re\")))]\n-pub mod net;\n+cfg_if! {\n+    if #[cfg(any(target_os = \"redox\", target_os = \"l4re\"))] {\n+        pub use sys::net;\n+    } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n+        pub use sys::net;\n+    } else {\n+        pub mod net;\n+    }\n+}\n \n #[cfg(feature = \"backtrace\")]\n #[cfg(any(all(unix, not(target_os = \"emscripten\")),"}, {"sha": "f1379b6ec637562178ccfc805eff47bb84c0595d", "filename": "src/libstd/sys_common/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys_common%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibstd%2Fsys_common%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use env;\n use alloc::boxed::FnBox;\n+use env;\n use sync::atomic::{self, Ordering};\n use sys::stack_overflow;\n use sys::thread as imp;\n \n+#[allow(dead_code)]\n pub unsafe fn start_thread(main: *mut u8) {\n     // Next, set up our stack overflow handler which may get triggered if we run\n     // out of stack."}, {"sha": "ebe7853b8abdb921ffd1aa72a412c6a32bda0fbd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -415,6 +415,9 @@ declare_features! (\n \n     // Allow trait methods with arbitrary self types\n     (active, arbitrary_self_types, \"1.23.0\", Some(44874)),\n+\n+    // #![wasm_import_memory] attribute\n+    (active, wasm_import_memory, \"1.22.0\", None),\n );\n \n declare_features! (\n@@ -928,6 +931,11 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                       never be stable\",\n                                      cfg_fn!(rustc_attrs))),\n \n+    (\"wasm_import_memory\", Whitelisted, Gated(Stability::Unstable,\n+                                 \"wasm_import_memory\",\n+                                 \"wasm_import_memory attribute is currently unstable\",\n+                                 cfg_fn!(wasm_import_memory))),\n+\n     // Crate level attributes\n     (\"crate_name\", CrateLevel, Ungated),\n     (\"crate_type\", CrateLevel, Ungated),"}, {"sha": "ef08b877262fc5dc1736eeb97a448c88b95c38aa", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 50, "deletions": 31, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -434,7 +434,8 @@ Test Attributes:\n // Parses command line arguments into test options\n pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let opts = optgroups();\n-    let matches = match opts.parse(&args[1..]) {\n+    let args = args.get(1..).unwrap_or(args);\n+    let matches = match opts.parse(args) {\n         Ok(m) => m,\n         Err(f) => return Some(Err(f.to_string())),\n     };\n@@ -1034,6 +1035,10 @@ fn stdout_isatty() -> bool {\n     // FIXME: Implement isatty on Redox\n     false\n }\n+#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+fn stdout_isatty() -> bool {\n+    false\n+}\n #[cfg(unix)]\n fn stdout_isatty() -> bool {\n     unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n@@ -1132,45 +1137,47 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n             }})\n     };\n \n-    while pending > 0 || !remaining.is_empty() {\n-        while pending < concurrency && !remaining.is_empty() {\n+    if concurrency == 1 {\n+        while !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n-            if concurrency == 1 {\n-                // We are doing one test at a time so we can print the name\n-                // of the test before we run it. Useful for debugging tests\n-                // that hang forever.\n-                callback(TeWait(test.desc.clone(), test.testfn.padding()))?;\n-            }\n-            let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n-            running_tests.insert(test.desc.clone(), timeout);\n+            callback(TeWait(test.desc.clone(), test.testfn.padding()))?;\n             run_test(opts, !opts.run_tests, test, tx.clone());\n-            pending += 1;\n+            let (test, result, stdout) = rx.recv().unwrap();\n+            callback(TeResult(test, result, stdout))?;\n         }\n+    } else {\n+        while pending > 0 || !remaining.is_empty() {\n+            while pending < concurrency && !remaining.is_empty() {\n+                let test = remaining.pop().unwrap();\n+                let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n+                running_tests.insert(test.desc.clone(), timeout);\n+                run_test(opts, !opts.run_tests, test, tx.clone());\n+                pending += 1;\n+            }\n \n-        let mut res;\n-        loop {\n-            if let Some(timeout) = calc_timeout(&running_tests) {\n-                res = rx.recv_timeout(timeout);\n-                for test in get_timed_out_tests(&mut running_tests) {\n-                    callback(TeTimeout(test))?;\n-                }\n-                if res != Err(RecvTimeoutError::Timeout) {\n+            let mut res;\n+            loop {\n+                if let Some(timeout) = calc_timeout(&running_tests) {\n+                    res = rx.recv_timeout(timeout);\n+                    for test in get_timed_out_tests(&mut running_tests) {\n+                        callback(TeTimeout(test))?;\n+                    }\n+                    if res != Err(RecvTimeoutError::Timeout) {\n+                        break;\n+                    }\n+                } else {\n+                    res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n                     break;\n                 }\n-            } else {\n-                res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n-                break;\n             }\n-        }\n \n-        let (desc, result, stdout) = res.unwrap();\n-        running_tests.remove(&desc);\n+            let (desc, result, stdout) = res.unwrap();\n+            running_tests.remove(&desc);\n \n-        if concurrency != 1 {\n             callback(TeWait(desc.clone(), PadNone))?;\n+            callback(TeResult(desc, result, stdout))?;\n+            pending -= 1;\n         }\n-        callback(TeResult(desc, result, stdout))?;\n-        pending -= 1;\n     }\n \n     if opts.bench_benchmarks {\n@@ -1235,6 +1242,11 @@ fn get_concurrency() -> usize {\n         1\n     }\n \n+    #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+    fn num_cpus() -> usize {\n+        1\n+    }\n+\n     #[cfg(any(target_os = \"linux\",\n               target_os = \"macos\",\n               target_os = \"ios\",\n@@ -1393,7 +1405,12 @@ pub fn run_test(opts: &TestOpts,\n \n     let TestDescAndFn {desc, testfn} = test;\n \n-    if force_ignore || desc.ignore {\n+    let ignore_because_panic_abort =\n+        cfg!(target_arch = \"wasm32\") &&\n+        !cfg!(target_os = \"emscripten\") &&\n+        desc.should_panic != ShouldPanic::No;\n+\n+    if force_ignore || desc.ignore || ignore_because_panic_abort {\n         monitor_ch.send((desc, TrIgnored, Vec::new())).unwrap();\n         return;\n     }\n@@ -1445,7 +1462,9 @@ pub fn run_test(opts: &TestOpts,\n         // If the platform is single-threaded we're just going to run\n         // the test synchronously, regardless of the concurrency\n         // level.\n-        let supports_threads = !cfg!(target_os = \"emscripten\");\n+        let supports_threads =\n+            !cfg!(target_os = \"emscripten\") &&\n+            !cfg!(target_arch = \"wasm32\");\n         if supports_threads {\n             let cfg = thread::Builder::new().name(match name {\n                 DynTestName(ref name) => name.clone(),"}, {"sha": "5bb1eb96dcfad2504e19189426cca773eef03dfe", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -20,13 +20,20 @@\n \n #![cfg_attr(not(target_env = \"msvc\"), feature(libc))]\n \n-#[cfg(not(target_env = \"msvc\"))]\n-extern crate libc;\n+#[macro_use]\n+mod macros;\n \n-#[cfg(not(target_env = \"msvc\"))]\n-mod libunwind;\n-#[cfg(not(target_env = \"msvc\"))]\n-pub use libunwind::*;\n+cfg_if! {\n+    if #[cfg(target_env = \"msvc\")] {\n+        // no extra unwinder support needed\n+    } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n+        // no unwinder on the system!\n+    } else {\n+        extern crate libc;\n+        mod libunwind;\n+        pub use libunwind::*;\n+    }\n+}\n \n #[cfg(all(target_env = \"musl\", not(target_arch = \"mips\")))]\n #[link(name = \"unwind\", kind = \"static\", cfg(target_feature = \"crt-static\"))]"}, {"sha": "26376a3733f4fce327c5a83902e115ee4979d1f3", "filename": "src/libunwind/macros.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibunwind%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Flibunwind%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fmacros.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A macro for defining #[cfg] if-else statements.\n+///\n+/// This is similar to the `if/elif` C preprocessor macro by allowing definition\n+/// of a cascade of `#[cfg]` cases, emitting the implementation which matches\n+/// first.\n+///\n+/// This allows you to conveniently provide a long list #[cfg]'d blocks of code\n+/// without having to rewrite each clause multiple times.\n+macro_rules! cfg_if {\n+    ($(\n+        if #[cfg($($meta:meta),*)] { $($it:item)* }\n+    ) else * else {\n+        $($it2:item)*\n+    }) => {\n+        __cfg_if_items! {\n+            () ;\n+            $( ( ($($meta),*) ($($it)*) ), )*\n+            ( () ($($it2)*) ),\n+        }\n+    }\n+}\n+\n+macro_rules! __cfg_if_items {\n+    (($($not:meta,)*) ; ) => {};\n+    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+        __cfg_if_apply! { cfg(all(not(any($($not),*)), $($m,)*)), $($it)* }\n+        __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n+    }\n+}\n+\n+macro_rules! __cfg_if_apply {\n+    ($m:meta, $($it:item)*) => {\n+        $(#[$m] $it)*\n+    }\n+}"}, {"sha": "cf8440c40da1aaa8736f3467b950895abdec649c", "filename": "src/rustc/dlmalloc_shim/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Frustc%2Fdlmalloc_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Frustc%2Fdlmalloc_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdlmalloc_shim%2FCargo.toml?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+name = \"dlmalloc\"\n+version = \"0.0.0\"\n+authors = [\"The Rust Project Developers\"]\n+\n+[lib]\n+path = \"../../dlmalloc/src/lib.rs\"\n+test = false\n+bench = false\n+doc = false\n+\n+[dependencies]\n+core = { path = \"../../libcore\" }\n+alloc = { path = \"../../liballoc\" }"}, {"sha": "d0c042e6451c709043b15242a8d5c5a6d1211c14", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -366,7 +366,9 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     LLVMRustCodeModel RustCM, LLVMRustRelocMode RustReloc,\n     LLVMRustCodeGenOptLevel RustOptLevel, bool UseSoftFloat,\n     bool PositionIndependentExecutable, bool FunctionSections,\n-    bool DataSections, bool TrapUnreachable) {\n+    bool DataSections,\n+    bool TrapUnreachable,\n+    bool Singlethread) {\n \n   auto CM = fromRust(RustCM);\n   auto OptLevel = fromRust(RustOptLevel);\n@@ -406,6 +408,10 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     Options.TrapUnreachable = true;\n   }\n \n+  if (Singlethread) {\n+    Options.ThreadModel = ThreadModel::Single;\n+  }\n+\n   TargetMachine *TM = TheTarget->createTargetMachine(\n       Trip.getTriple(), RealCPU, Feature, Options, RM, CM, OptLevel);\n   return wrap(TM);"}, {"sha": "a010ebb3551d0f7a13c9db60b046a1eb0a841625", "filename": "src/test/compile-fail/feature-gate-wasm_import_memory.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Fcompile-fail%2Ffeature-gate-wasm_import_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Fcompile-fail%2Ffeature-gate-wasm_import_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-wasm_import_memory.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![wasm_import_memory] //~ ERROR: currently unstable\n+\n+fn main() {}\n+"}, {"sha": "3db0644d1ef3c4abc4d8353c5371b6837dc163ec", "filename": "src/test/run-pass-fulldeps/flt2dec.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass-fulldeps%2Fflt2dec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass-fulldeps%2Fflt2dec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fflt2dec.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,163 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+\n+#![feature(rustc_private, flt2dec)]\n+\n+extern crate core;\n+extern crate rand;\n+\n+use std::i16;\n+use std::mem;\n+use std::str;\n+\n+use core::num::flt2dec::MAX_SIG_DIGITS;\n+use core::num::flt2dec::strategy::grisu::format_exact_opt;\n+use core::num::flt2dec::strategy::grisu::format_shortest_opt;\n+use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n+\n+use rand::{Rand, XorShiftRng};\n+use rand::distributions::{IndependentSample, Range};\n+pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n+    match decode(v).1 {\n+        FullDecoded::Finite(decoded) => decoded,\n+        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded)\n+    }\n+}\n+\n+\n+fn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V) -> (usize, usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+              V: FnMut(usize) -> Decoded {\n+    assert!(k <= 1024);\n+\n+    let mut npassed = 0; // f(x) = Some(g(x))\n+    let mut nignored = 0; // f(x) = None\n+\n+    for i in 0..n {\n+        if (i & 0xfffff) == 0 {\n+            println!(\"in progress, {:x}/{:x} (ignored={} passed={} failed={})\",\n+                     i, n, nignored, npassed, i - nignored - npassed);\n+        }\n+\n+        let decoded = v(i);\n+        let mut buf1 = [0; 1024];\n+        if let Some((len1, e1)) = f(&decoded, &mut buf1[..k]) {\n+            let mut buf2 = [0; 1024];\n+            let (len2, e2) = g(&decoded, &mut buf2[..k]);\n+            if e1 == e2 && &buf1[..len1] == &buf2[..len2] {\n+                npassed += 1;\n+            } else {\n+                println!(\"equivalence test failed, {:x}/{:x}: {:?} f(i)={}e{} g(i)={}e{}\",\n+                         i, n, decoded, str::from_utf8(&buf1[..len1]).unwrap(), e1,\n+                                        str::from_utf8(&buf2[..len2]).unwrap(), e2);\n+            }\n+        } else {\n+            nignored += 1;\n+        }\n+    }\n+    println!(\"{}({}): done, ignored={} passed={} failed={}\",\n+             func, k, nignored, npassed, n - nignored - npassed);\n+    assert!(nignored + npassed == n,\n+            \"{}({}): {} out of {} values returns an incorrect value!\",\n+            func, k, n - nignored - npassed, n);\n+    (npassed, nignored)\n+}\n+\n+pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    let mut rng: XorShiftRng = Rand::rand(&mut rand::thread_rng());\n+    let f32_range = Range::new(0x0000_0001u32, 0x7f80_0000);\n+    iterate(\"f32_random_equivalence_test\", k, n, f, g, |_| {\n+        let i: u32 = f32_range.ind_sample(&mut rng);\n+        let x: f32 = unsafe {mem::transmute(i)};\n+        decode_finite(x)\n+    });\n+}\n+\n+pub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    let mut rng: XorShiftRng = Rand::rand(&mut rand::thread_rng());\n+    let f64_range = Range::new(0x0000_0000_0000_0001u64, 0x7ff0_0000_0000_0000);\n+    iterate(\"f64_random_equivalence_test\", k, n, f, g, |_| {\n+        let i: u64 = f64_range.ind_sample(&mut rng);\n+        let x: f64 = unsafe {mem::transmute(i)};\n+        decode_finite(x)\n+    });\n+}\n+\n+pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    // we have only 2^23 * (2^8 - 1) - 1 = 2,139,095,039 positive finite f32 values,\n+    // so why not simply testing all of them?\n+    //\n+    // this is of course very stressful (and thus should be behind an `#[ignore]` attribute),\n+    // but with `-C opt-level=3 -C lto` this only takes about an hour or so.\n+\n+    // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e. all finite ranges\n+    let (npassed, nignored) = iterate(\"f32_exhaustive_equivalence_test\",\n+                                      k, 0x7f7f_ffff, f, g, |i: usize| {\n+        let x: f32 = unsafe {mem::transmute(i as u32 + 1)};\n+        decode_finite(x)\n+    });\n+    assert_eq!((npassed, nignored), (2121451881, 17643158));\n+}\n+\n+#[test]\n+fn shortest_random_equivalence_test() {\n+    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n+    f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n+}\n+\n+#[test] #[ignore] // it is too expensive\n+fn shortest_f32_exhaustive_equivalence_test() {\n+    // it is hard to directly test the optimality of the output, but we can at least test if\n+    // two different algorithms agree to each other.\n+    //\n+    // this reports the progress and the number of f32 values returned `None`.\n+    // with `--nocapture` (and plenty of time and appropriate rustc flags), this should print:\n+    // `done, ignored=17643158 passed=2121451881 failed=0`.\n+\n+    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    f32_exhaustive_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS);\n+}\n+\n+#[test] #[ignore] // it is too expensive\n+fn shortest_f64_hard_random_equivalence_test() {\n+    // this again probably has to use appropriate rustc flags.\n+\n+    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    f64_random_equivalence_test(format_shortest_opt, fallback,\n+                                         MAX_SIG_DIGITS, 100_000_000);\n+}\n+\n+#[test]\n+fn exact_f32_random_equivalence_test() {\n+    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n+    for k in 1..21 {\n+        f32_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n+                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n+    }\n+}\n+\n+#[test]\n+fn exact_f64_random_equivalence_test() {\n+    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n+    for k in 1..21 {\n+        f64_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n+                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n+    }\n+}"}, {"sha": "af8a691aa3ec6468ad254a25cea1c1301759451e", "filename": "src/test/run-pass-fulldeps/sort-unstable.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass-fulldeps%2Fsort-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass-fulldeps%2Fsort-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fsort-unstable.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private, sort_internals)]\n+\n+extern crate core;\n+extern crate rand;\n+\n+use std::cmp::Ordering::{Equal, Greater, Less};\n+use core::slice::heapsort;\n+\n+use rand::{Rng, XorShiftRng};\n+\n+fn main() {\n+    let mut v = [0; 600];\n+    let mut tmp = [0; 600];\n+    let mut rng = XorShiftRng::new_unseeded();\n+\n+    for len in (2..25).chain(500..510) {\n+        let v = &mut v[0..len];\n+        let tmp = &mut tmp[0..len];\n+\n+        for &modulus in &[5, 10, 100, 1000] {\n+            for _ in 0..100 {\n+                for i in 0..len {\n+                    v[i] = rng.gen::<i32>() % modulus;\n+                }\n+\n+                // Sort in default order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable();\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in ascending order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable_by(|a, b| a.cmp(b));\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in descending order.\n+                tmp.copy_from_slice(v);\n+                tmp.sort_unstable_by(|a, b| b.cmp(a));\n+                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n+\n+                // Test heapsort using `<` operator.\n+                tmp.copy_from_slice(v);\n+                heapsort(tmp, |a, b| a < b);\n+                assert!(tmp.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Test heapsort using `>` operator.\n+                tmp.copy_from_slice(v);\n+                heapsort(tmp, |a, b| a > b);\n+                assert!(tmp.windows(2).all(|w| w[0] >= w[1]));\n+            }\n+        }\n+    }\n+\n+    // Sort using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+    v.sort_unstable_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n+    v.sort_unstable();\n+    for i in 0..v.len() {\n+        assert_eq!(v[i], i as i32);\n+    }\n+\n+    // Should not panic.\n+    [0i32; 0].sort_unstable();\n+    [(); 10].sort_unstable();\n+    [(); 100].sort_unstable();\n+\n+    let mut v = [0xDEADBEEFu64];\n+    v.sort_unstable();\n+    assert!(v == [0xDEADBEEF]);\n+}"}, {"sha": "22081678fb9995e3c6ef1d6bb939fd21556fa021", "filename": "src/test/run-pass/allocator/custom.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -15,7 +15,6 @@\n \n extern crate helper;\n \n-use std::env;\n use std::heap::{Heap, Alloc, System, Layout, AllocErr};\n use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n \n@@ -39,8 +38,7 @@ unsafe impl<'a> Alloc for &'a A {\n static GLOBAL: A = A;\n \n fn main() {\n-    env::set_var(\"FOO\", \"bar\");\n-    drop(env::var(\"FOO\"));\n+    println!(\"hello!\");\n \n     let n = HITS.load(Ordering::SeqCst);\n     assert!(n > 0);"}, {"sha": "04d2ef466e73d81823bd145bae5be6ae6818e482", "filename": "src/test/run-pass/allocator/xcrate-use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -17,7 +17,6 @@\n extern crate custom;\n extern crate helper;\n \n-use std::env;\n use std::heap::{Heap, Alloc, System, Layout};\n use std::sync::atomic::{Ordering, ATOMIC_USIZE_INIT};\n "}, {"sha": "155fb5d6c5de920bae4cf80124fbe2dfbf267d70", "filename": "src/test/run-pass/allocator/xcrate-use2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -19,7 +19,6 @@ extern crate custom;\n extern crate custom_as_global;\n extern crate helper;\n \n-use std::env;\n use std::heap::{Heap, Alloc, System, Layout};\n use std::sync::atomic::{Ordering, ATOMIC_USIZE_INIT};\n "}, {"sha": "8c480d7deebd9ce8380d41f29f540716f4349b30", "filename": "src/test/run-pass/anon-extern-mod-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -10,6 +10,7 @@\n \n // aux-build:anon-extern-mod-cross-crate-1.rs\n // pretty-expanded FIXME #23616\n+// ignore-wasm32-bare no libc to test ffi with\n \n extern crate anonexternmod;\n "}, {"sha": "16ca7bce95b595d5d1888399941cc72099269680", "filename": "src/test/run-pass/anon-extern-mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // pretty-expanded FIXME #23616\n+// ignore-wasm32-bare no libc to test ffi with\n \n #![feature(libc)]\n "}, {"sha": "f34a97519e77d745a585d6e5c645c2c685be5f85", "filename": "src/test/run-pass/auxiliary/issue-3012-1.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-3012-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-3012-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-3012-1.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -10,13 +10,10 @@\n \n #![crate_name=\"socketlib\"]\n #![crate_type = \"lib\"]\n-#![feature(libc)]\n \n pub mod socket {\n-    extern crate libc;\n-\n     pub struct socket_handle {\n-        sockfd: libc::c_int,\n+        sockfd: u32,\n     }\n \n     impl Drop for socket_handle {\n@@ -25,7 +22,7 @@ pub mod socket {\n         }\n     }\n \n-    pub fn socket_handle(x: libc::c_int) -> socket_handle {\n+    pub fn socket_handle(x: u32) -> socket_handle {\n         socket_handle {\n             sockfd: x\n         }"}, {"sha": "7e7c5ee4125565111043bca8f7b6fa5cb0ce86db", "filename": "src/test/run-pass/builtin-clone-unwind.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n // Test that builtin implementations of `Clone` cleanup everything\n // in case of unwinding.\n "}, {"sha": "df4989d89ab5e771636e2c2512f9d7e774bc15df", "filename": "src/test/run-pass/c-stack-as-value.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fc-stack-as-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fc-stack-as-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-as-value.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // pretty-expanded FIXME #23616\n+// ignore-wasm32-bare no libc to test ffi with\n \n #![feature(libc)]\n "}, {"sha": "46b3fd1f1e746e0914993a167ddb09dc8ea36196", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+// ignore-wasm32-bare no libc to test with\n \n #![feature(libc, std_misc)]\n "}, {"sha": "5b1677c184c7431d1e10c6e29ffcb80e07a391a5", "filename": "src/test/run-pass/cabi-int-widening.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fcabi-int-widening.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fcabi-int-widening.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcabi-int-widening.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n+\n #[link(name = \"rust_test_helpers\", kind = \"static\")]\n extern {\n     fn rust_int8_to_int32(_: i8) -> i32;"}, {"sha": "849132b8ebfabc68c5365d50b3f1ea78eff77153", "filename": "src/test/run-pass/catch-unwind-bang.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fcatch-unwind-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fcatch-unwind-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcatch-unwind-bang.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n fn worker() -> ! {\n     panic!()\n }"}, {"sha": "1797ad1019c3dc0b644b3051eee5176b0d144785", "filename": "src/test/run-pass/cfg-family.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fcfg-family.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fcfg-family.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg-family.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // pretty-expanded FIXME #23616\n+// ignore-wasm32-bare no target_family\n \n #[cfg(windows)]\n pub fn main() {"}, {"sha": "0b8574e117478d725bf91092de04a85d43d760d5", "filename": "src/test/run-pass/cfg-target-family.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fcfg-target-family.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fcfg-target-family.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg-target-family.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no target_family\n+\n // pretty-expanded FIXME #23616\n \n #[cfg(target_family = \"windows\")]"}, {"sha": "9c87f2ca68203c9bf60ffdd996def1579d1344de", "filename": "src/test/run-pass/check-static-recursion-foreign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fcheck-static-recursion-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fcheck-static-recursion-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcheck-static-recursion-foreign.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -11,6 +11,7 @@\n // Static recursion check shouldn't fail when given a foreign item (#18279)\n \n // aux-build:check_static_recursion_foreign_helper.rs\n+// ignore-wasm32-bare no libc to test ffi with\n \n // pretty-expanded FIXME #23616\n "}, {"sha": "e77fd5f71394ea0fad1bb9d31912cc7fcfabb7e9", "filename": "src/test/run-pass/const-cast.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,21 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(libc)]\n-\n-extern crate libc;\n-\n struct TestStruct {\n-    x: *const libc::c_void\n+    x: *const u8,\n }\n \n unsafe impl Sync for TestStruct {}\n \n extern fn foo() {}\n const x: extern \"C\" fn() = foo;\n-static y: TestStruct = TestStruct { x: x as *const libc::c_void };\n+static y: TestStruct = TestStruct { x: x as *const u8 };\n \n pub fn main() {\n-    assert_eq!(x as *const libc::c_void, y.x);\n+    assert_eq!(x as *const u8, y.x);\n }"}, {"sha": "4cb3dbe027a160dc71c569a3b2290f72f8214272", "filename": "src/test/run-pass/duplicated-external-mods.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fduplicated-external-mods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fduplicated-external-mods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fduplicated-external-mods.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -11,6 +11,7 @@\n // aux-build:anon-extern-mod-cross-crate-1.rs\n // aux-build:anon-extern-mod-cross-crate-1.rs\n // pretty-expanded FIXME #23616\n+// ignore-wasm32-bare no libc to test ffi with\n \n extern crate anonexternmod;\n "}, {"sha": "3310d3a89b92b76dab4f60e22cd9cd54a1f74d41", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n #![feature(generators, generator_trait, untagged_unions)]\n \n use std::cell::{Cell, RefCell};"}, {"sha": "af44a6567e4054962207acaab97e6076927c4f4e", "filename": "src/test/run-pass/env-vars.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fenv-vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fenv-vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-vars.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no env vars\n \n use std::env::*;\n "}, {"sha": "a41ab8da9de1172aa1b188dd931e447213278340", "filename": "src/test/run-pass/extern-call-deep.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n+\n #![feature(libc)]\n \n extern crate libc;"}, {"sha": "ba108955c28d6efc28a7e6f89dce8347d832d4cf", "filename": "src/test/run-pass/extern-call-indirect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-call-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-call-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-indirect.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n+\n #![feature(libc)]\n \n extern crate libc;"}, {"sha": "825b502d954852433c473ba32595ef9de87498fd", "filename": "src/test/run-pass/extern-crosscrate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//aux-build:extern-crosscrate-source.rs\n+// aux-build:extern-crosscrate-source.rs\n+// ignore-wasm32-bare no libc to test ffi with\n \n #![feature(libc)]\n "}, {"sha": "a1aa9b69fadaa5c962063777457ef9d167456e7b", "filename": "src/test/run-pass/extern-pass-TwoU16s.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc for ffi testing\n+\n // Test a foreign function that accepts and returns a struct\n // by value.\n "}, {"sha": "6442f230d30245761e50476bc523bd137bf1baa3", "filename": "src/test/run-pass/extern-pass-TwoU32s.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc for ffi testing\n+\n // Test a foreign function that accepts and returns a struct\n // by value.\n "}, {"sha": "bfb649c3f74ea4aa8c93387467a4386f27ece648", "filename": "src/test/run-pass/extern-pass-TwoU64s.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc for ffi testing\n+\n // Test a foreign function that accepts and returns a struct\n // by value.\n "}, {"sha": "1f90d9c4366773563649be5d7d371265dc9a8969", "filename": "src/test/run-pass/extern-pass-TwoU8s.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc for ffi testing\n+\n // Test a foreign function that accepts and returns a struct\n // by value.\n "}, {"sha": "920e15bf2c1193a9b3afe5fdd5e543d94a09567b", "filename": "src/test/run-pass/extern-pass-char.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc for ffi testing\n+\n // Test a function that takes/returns a u8.\n \n "}, {"sha": "9c184477ad340cf4cf9f0c29396b48a05cc434e1", "filename": "src/test/run-pass/extern-pass-double.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc for ffi testing\n \n #[link(name = \"rust_test_helpers\", kind = \"static\")]\n extern {"}, {"sha": "691bd6295b143b4711452ea2bd16e0204a8fc04c", "filename": "src/test/run-pass/extern-pass-u32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc for ffi testing\n+\n // Test a function that takes/returns a u32.\n \n "}, {"sha": "4b351ed2836cce5c9e8cb4b05c054ce7fe5a0fc5", "filename": "src/test/run-pass/extern-pass-u64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc for ffi testing\n+\n // Test a call to a function that takes/returns a u64.\n \n "}, {"sha": "b9ce3f458868818fcf6f93099ef96f3859148bef", "filename": "src/test/run-pass/extern-return-TwoU16s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU16s.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n \n pub struct TwoU16s {\n     one: u16, two: u16"}, {"sha": "686ff16fe4d6b277bd498977212a30ebeec9e611", "filename": "src/test/run-pass/extern-return-TwoU32s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU32s.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n \n pub struct TwoU32s {\n     one: u32, two: u32"}, {"sha": "e754674fd1ebd71b70b83d4ab9ff1ea8a149d298", "filename": "src/test/run-pass/extern-return-TwoU64s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU64s.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n \n pub struct TwoU64s {\n     one: u64, two: u64"}, {"sha": "68fe3832e90aba8b5b77c8c996a6d5b04a953d4f", "filename": "src/test/run-pass/extern-return-TwoU8s.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-return-TwoU8s.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n \n pub struct TwoU8s {\n     one: u8, two: u8"}, {"sha": "123458ff97e13a8cb954a9d571290045712fcd74", "filename": "src/test/run-pass/extern_fat_drop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern_fat_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fextern_fat_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern_fat_drop.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -14,7 +14,8 @@ extern crate fat_drop;\n \n fn main() {\n     unsafe {\n-        let s: &mut fat_drop::S = std::mem::uninitialized();\n+        let data: &mut [u8] = &mut [0];\n+        let s: &mut fat_drop::S = std::mem::transmute::<&mut [u8], _>(data);\n         std::ptr::drop_in_place(s);\n         assert!(fat_drop::DROPPED);\n     }"}, {"sha": "4ecb9da4eb9c6e01f614b3878cdf1d77dc4b3f50", "filename": "src/test/run-pass/fmt-pointer-trait.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Ffmt-pointer-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Ffmt-pointer-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffmt-pointer-trait.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(libc)]\n-extern crate libc;\n use std::ptr;\n use std::rc::Rc;\n use std::sync::Arc;\n \n fn main() {\n-    let p: *const libc::c_void = ptr::null();\n+    let p: *const u8 = ptr::null();\n     let rc = Rc::new(1usize);\n     let arc = Arc::new(1usize);\n     let b = Box::new(\"hi\");"}, {"sha": "b79e6e98fc056038187e49fe906c725eb034f05a", "filename": "src/test/run-pass/foreign-dupe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-dupe.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // aux-build:foreign_lib.rs\n+// ignore-wasm32-bare no libc to test ffi with\n \n // Check that we can still call duplicated extern (imported) functions\n // which were declared in another crate. See issues #32740 and #32783."}, {"sha": "ab8e4fbedcff7c22436db3c341816a4fd6e9b287", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+// ignore-wasm32-bare no libc to test ffi with\n \n #![feature(std_misc, libc)]\n "}, {"sha": "65efa571a9b4b5990c150ff6861e318abda4996a", "filename": "src/test/run-pass/foreign-fn-with-byval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign-fn-with-byval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign-fn-with-byval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-with-byval.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n \n #[derive(Copy, Clone)]\n pub struct S {"}, {"sha": "5e9e529669a0122a64a61f0888ad988bb5141e71", "filename": "src/test/run-pass/foreign-mod-unused-const.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign-mod-unused-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign-mod-unused-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-mod-unused-const.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,18 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n // pretty-expanded FIXME #23616\n \n-#![feature(libc)]\n-\n-extern crate libc;\n-\n mod foo {\n-    use libc::c_int;\n-\n     extern {\n-        pub static errno: c_int;\n+        pub static errno: u32;\n     }\n }\n "}, {"sha": "b516cdf4416b823093e422a37b77d039cf009819", "filename": "src/test/run-pass/foreign-no-abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-no-abi.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -10,6 +10,7 @@\n \n // ABI is cdecl by default\n \n+// ignore-wasm32-bare no libc to test ffi with\n // pretty-expanded FIXME #23616\n \n #![feature(libc)]"}, {"sha": "d69d6976e4a90e1f5d7c07f6ff941828e8b48319", "filename": "src/test/run-pass/foreign2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fforeign2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign2.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+// ignore-wasm32-bare no libc to test ffi with\n // pretty-expanded FIXME #23616\n \n #![feature(libc)]"}, {"sha": "36e401a54bcddbebd11731d8682ccc9698006a89", "filename": "src/test/run-pass/generator/panic-drops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled as panic=abort by default\n+\n #![feature(generators, generator_trait)]\n \n use std::ops::Generator;"}, {"sha": "0d5bae7876bd3bde4b091c5fee06d84ae1583338", "filename": "src/test/run-pass/generator/panic-safe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-safe.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n #![feature(generators, generator_trait)]\n \n use std::ops::Generator;"}, {"sha": "56511dcd53a6a93a3be76df26682d29f98b86cfb", "filename": "src/test/run-pass/generator/resume-after-return.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fgenerator%2Fresume-after-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fgenerator%2Fresume-after-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fresume-after-return.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n #![feature(generators, generator_trait)]\n \n use std::ops::{GeneratorState, Generator};"}, {"sha": "99edd2550c01b3a68b8ded1fc77fc148715bfd7b", "filename": "src/test/run-pass/intrinsic-alignment.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare seems not important to test here\n \n #![feature(intrinsics, main)]\n "}, {"sha": "d01c3b67895e6d9b861530cc00afa0ce7844c33b", "filename": "src/test/run-pass/invoke-external-foreign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // aux-build:foreign_lib.rs\n+// ignore-wasm32-bare no libc to test ffi with\n \n // The purpose of this test is to check that we can\n // successfully (and safely) invoke external, cdecl"}, {"sha": "00e8aa69a89424a98df0336399cabc7c7ccafeab", "filename": "src/test/run-pass/issue-1251.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-1251.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-1251.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1251.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // pretty-expanded FIXME #23616\n+// ignore-wasm32-bare no libc to test ffi with\n \n #![feature(libc)]\n "}, {"sha": "4620d982c1ea587169a454fb5c809947faec540a", "filename": "src/test/run-pass/issue-12699.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12699.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare can't block the thread\n+\n use std::thread;\n \n fn main() {"}, {"sha": "75a724e55fb113dda8114d7117f74fae3c920ae6", "filename": "src/test/run-pass/issue-13507-2.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-13507-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-13507-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13507-2.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -10,9 +10,6 @@\n \n // aux-build:issue13507.rs\n \n-\n-#![feature(core)]\n-\n extern crate issue13507;\n use issue13507::testtypes;\n "}, {"sha": "e705539bb47721a1fcd9aea259a52d26bc5e4ebe", "filename": "src/test/run-pass/issue-14875.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-14875.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-14875.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14875.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare always compiled as panic=abort right now\n+\n // Check that values are not leaked when a dtor panics (#14875)\n \n use std::panic::{self, UnwindSafe};\n@@ -29,7 +31,6 @@ impl Drop for PanicOnDrop {\n     }\n }\n \n-\n fn main() {\n     let mut set_on_drop = false;\n     {"}, {"sha": "7b7ecc91484ba9d540d9e414ae3207e786fdcea9", "filename": "src/test/run-pass/issue-2214.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n \n #![feature(libc)]\n "}, {"sha": "9a2dbd1c96e310da4ce792f5bd6cb4d1fbf0f5f1", "filename": "src/test/run-pass/issue-25185.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-25185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-25185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25185.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -10,6 +10,7 @@\n \n // aux-build:issue-25185-1.rs\n // aux-build:issue-25185-2.rs\n+// ignore-wasm32-bare no libc for ffi testing\n \n extern crate issue_25185_2;\n "}, {"sha": "a7bee427a813c1bd772f5cf0af52aad5115ea91f", "filename": "src/test/run-pass/issue-28676.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-28676.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-28676.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28676.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -7,7 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-//\n+\n+// ignore-wasm32-bare no libc to test ffi with\n \n #[derive(Copy, Clone)]\n pub struct Quad { a: u64, b: u64, c: u64, d: u64 }"}, {"sha": "3a7e9ba93e190afd8706e0d4a76c3bcb561d09cb", "filename": "src/test/run-pass/issue-29948.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-29948.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-29948.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29948.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n use std::panic;\n \n impl<'a> panic::UnwindSafe for Foo<'a> {}"}, {"sha": "bcf8a9180918ce218ed66955ca57189b0de5a86f", "filename": "src/test/run-pass/issue-3012-2.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-3012-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-3012-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3012-2.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -12,15 +12,11 @@\n \n // pretty-expanded FIXME #23616\n \n-#![allow(unknown_features)]\n-#![feature(box_syntax, libc)]\n-\n extern crate socketlib;\n-extern crate libc;\n \n use socketlib::socket;\n \n pub fn main() {\n-    let fd: libc::c_int = 1 as libc::c_int;\n-    let _sock: Box<_> = box socket::socket_handle(fd);\n+    let fd: u32 = 1 as u32;\n+    let _sock: Box<_> = Box::new(socket::socket_handle(fd));\n }"}, {"sha": "c278dcef9dde73933693d476a5024b580b07a54b", "filename": "src/test/run-pass/issue-3656.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-3656.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-3656.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3656.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -13,6 +13,7 @@\n // the alignment of elements into account.\n \n // pretty-expanded FIXME #23616\n+// ignore-wasm32-bare no libc to test with\n \n #![feature(libc)]\n "}, {"sha": "e9f8d2744a16a7555ea11592b1200a1256d35e35", "filename": "src/test/run-pass/issue-43853.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-43853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-43853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-43853.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n use std::panic;\n \n fn test() {"}, {"sha": "7eb09e055a2927c4b1dd078914da9486c43dd45c", "filename": "src/test/run-pass/issue-4735.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-4735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-4735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4735.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,28 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n // pretty-expanded FIXME #23616\n \n-#![allow(unknown_features)]\n-#![feature(box_syntax, libc)]\n-\n-extern crate libc;\n-\n use std::mem::transmute;\n-use libc::c_void;\n \n-struct NonCopyable(*const c_void);\n+struct NonCopyable(*const u8);\n \n impl Drop for NonCopyable {\n     fn drop(&mut self) {\n         let NonCopyable(p) = *self;\n-        let _v = unsafe { transmute::<*const c_void, Box<isize>>(p) };\n+        let _v = unsafe { transmute::<*const u8, Box<isize>>(p) };\n     }\n }\n \n pub fn main() {\n-    let t = box 0;\n-    let p = unsafe { transmute::<Box<isize>, *const c_void>(t) };\n+    let t = Box::new(0);\n+    let p = unsafe { transmute::<Box<isize>, *const u8>(t) };\n     let _z = NonCopyable(p);\n }"}, {"sha": "2e93279f756f0802d298e1114d959f880efd9707", "filename": "src/test/run-pass/issue-5791.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-5791.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fissue-5791.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5791.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -10,15 +10,11 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(libc)]\n-\n-extern crate libc;\n-\n extern {\n     #[link_name = \"malloc\"]\n-    fn malloc1(len: libc::c_int) -> *const libc::c_void;\n+    fn malloc1(len: i32) -> *const u8;\n     #[link_name = \"malloc\"]\n-    fn malloc2(len: libc::c_int, foo: libc::c_int) -> *const libc::c_void;\n+    fn malloc2(len: i32, foo: i32) -> *const u8;\n }\n \n pub fn main () {}"}, {"sha": "0fc13319b8734a8337bcea6d6f0100e97906f6d5", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -12,8 +12,7 @@\n // for completeness since .rs files linked from .rc files support this\n // notation to specify their module's attributes\n \n-\n-#![feature(custom_attribute, libc)]\n+#![feature(custom_attribute)]\n #![allow(unused_attribute)]\n #![attr1 = \"val\"]\n #![attr2 = \"val\"]\n@@ -159,13 +158,11 @@ mod test_other_forms {\n \n mod test_foreign_items {\n     pub mod rustrt {\n-        extern crate libc;\n-\n         extern {\n             #![attr]\n \n             #[attr]\n-            fn rust_get_test_int() -> libc::intptr_t;\n+            fn rust_get_test_int() -> u32;\n         }\n     }\n }"}, {"sha": "c45a10eac52b1ada65e6bf7a9aa8da75c99c6490", "filename": "src/test/run-pass/iter-step-overflow-debug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fiter-step-overflow-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fiter-step-overflow-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-step-overflow-debug.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n // compile-flags: -C debug_assertions=yes\n \n use std::panic;"}, {"sha": "c640f7cd2804575f1a074e1f5d2022f778038fc6", "filename": "src/test/run-pass/iter-sum-overflow-debug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fiter-sum-overflow-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fiter-sum-overflow-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-sum-overflow-debug.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n // compile-flags: -C debug_assertions=yes\n \n use std::panic;"}, {"sha": "517cd139cf354ca8a70c39b1d72eb2433ee8e749", "filename": "src/test/run-pass/iter-sum-overflow-overflow-checks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fiter-sum-overflow-overflow-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fiter-sum-overflow-overflow-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-sum-overflow-overflow-checks.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n // compile-flags: -C overflow-checks\n \n use std::panic;"}, {"sha": "fcaeda9a5495bfeb929cb5143543fbb3ba62ff78", "filename": "src/test/run-pass/lib-defaults.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Flib-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Flib-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-defaults.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n+\n // compile-flags: -lrust_test_helpers\n \n #[link(name = \"rust_test_helpers\", kind = \"static\")]"}, {"sha": "9641ed282936fafcbb6f178728a2b0a64b58f2d3", "filename": "src/test/run-pass/mir_calls_to_shims.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fmir_calls_to_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fmir_calls_to_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_calls_to_shims.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n #![feature(fn_traits)]\n #![feature(never_type)]\n "}, {"sha": "41cb458c0b8b486c3a7ac664ca70538075d643d2", "filename": "src/test/run-pass/mir_drop_order.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n use std::cell::RefCell;\n use std::panic;\n "}, {"sha": "81c8b75fb9b6a24a2edba87b23ca7a149abc8eb0", "filename": "src/test/run-pass/mir_misc_casts.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fmir_misc_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fmir_misc_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_misc_casts.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,18 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(libc)]\n-\n-extern crate libc;\n-\n fn func(){}\n \n const STR: &'static str = \"hello\";\n const BSTR: &'static [u8; 5] = b\"hello\";\n \n fn from_ptr()\n -> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, *const ()) {\n-    let f = 1_usize as *const libc::FILE;\n+    let f = 1_usize as *const String;\n     let c1 = f as isize;\n     let c2 = f as usize;\n     let c3 = f as i8;\n@@ -35,7 +31,7 @@ fn from_ptr()\n }\n \n fn from_1()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1 as isize;\n     let c2 = 1 as usize;\n     let c3 = 1 as i8;\n@@ -48,12 +44,12 @@ fn from_1()\n     let c10 = 1 as u64;\n     let c11 = 1 as f32;\n     let c12 = 1 as f64;\n-    let c13 = 1 as *const libc::FILE;\n+    let c13 = 1 as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n fn from_1usize()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1_usize as isize;\n     let c2 = 1_usize as usize;\n     let c3 = 1_usize as i8;\n@@ -66,12 +62,12 @@ fn from_1usize()\n     let c10 = 1_usize as u64;\n     let c11 = 1_usize as f32;\n     let c12 = 1_usize as f64;\n-    let c13 = 1_usize as *const libc::FILE;\n+    let c13 = 1_usize as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n fn from_1isize()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1_isize as isize;\n     let c2 = 1_isize as usize;\n     let c3 = 1_isize as i8;\n@@ -84,12 +80,12 @@ fn from_1isize()\n     let c10 = 1_isize as u64;\n     let c11 = 1_isize as f32;\n     let c12 = 1_isize as f64;\n-    let c13 = 1_isize as *const libc::FILE;\n+    let c13 = 1_isize as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n fn from_1u8()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1_u8 as isize;\n     let c2 = 1_u8 as usize;\n     let c3 = 1_u8 as i8;\n@@ -102,12 +98,12 @@ fn from_1u8()\n     let c10 = 1_u8 as u64;\n     let c11 = 1_u8 as f32;\n     let c12 = 1_u8 as f64;\n-    let c13 = 1_u8 as *const libc::FILE;\n+    let c13 = 1_u8 as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n fn from_1i8()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1_i8 as isize;\n     let c2 = 1_i8 as usize;\n     let c3 = 1_i8 as i8;\n@@ -120,12 +116,12 @@ fn from_1i8()\n     let c10 = 1_i8 as u64;\n     let c11 = 1_i8 as f32;\n     let c12 = 1_i8 as f64;\n-    let c13 = 1_i8 as *const libc::FILE;\n+    let c13 = 1_i8 as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n fn from_1u16()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1_u16 as isize;\n     let c2 = 1_u16 as usize;\n     let c3 = 1_u16 as i8;\n@@ -138,12 +134,12 @@ fn from_1u16()\n     let c10 = 1_u16 as u64;\n     let c11 = 1_u16 as f32;\n     let c12 = 1_u16 as f64;\n-    let c13 = 1_u16 as *const libc::FILE;\n+    let c13 = 1_u16 as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n fn from_1i16()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1_i16 as isize;\n     let c2 = 1_i16 as usize;\n     let c3 = 1_i16 as i8;\n@@ -156,12 +152,12 @@ fn from_1i16()\n     let c10 = 1_i16 as u64;\n     let c11 = 1_i16 as f32;\n     let c12 = 1_i16 as f64;\n-    let c13 = 1_i16 as *const libc::FILE;\n+    let c13 = 1_i16 as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n fn from_1u32()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1_u32 as isize;\n     let c2 = 1_u32 as usize;\n     let c3 = 1_u32 as i8;\n@@ -174,12 +170,12 @@ fn from_1u32()\n     let c10 = 1_u32 as u64;\n     let c11 = 1_u32 as f32;\n     let c12 = 1_u32 as f64;\n-    let c13 = 1_u32 as *const libc::FILE;\n+    let c13 = 1_u32 as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n fn from_1i32()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1_i32 as isize;\n     let c2 = 1_i32 as usize;\n     let c3 = 1_i32 as i8;\n@@ -192,12 +188,12 @@ fn from_1i32()\n     let c10 = 1_i32 as u64;\n     let c11 = 1_i32 as f32;\n     let c12 = 1_i32 as f64;\n-    let c13 = 1_i32 as *const libc::FILE;\n+    let c13 = 1_i32 as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n fn from_1u64()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1_u64 as isize;\n     let c2 = 1_u64 as usize;\n     let c3 = 1_u64 as i8;\n@@ -210,12 +206,12 @@ fn from_1u64()\n     let c10 = 1_u64 as u64;\n     let c11 = 1_u64 as f32;\n     let c12 = 1_u64 as f64;\n-    let c13 = 1_u64 as *const libc::FILE;\n+    let c13 = 1_u64 as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n fn from_1i64()\n--> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const libc::FILE) {\n+-> (isize, usize, i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, *const String) {\n     let c1 = 1_i64 as isize;\n     let c2 = 1_i64 as usize;\n     let c3 = 1_i64 as i8;\n@@ -228,7 +224,7 @@ fn from_1i64()\n     let c10 = 1_i64 as u64;\n     let c11 = 1_i64 as f32;\n     let c12 = 1_i64 as f64;\n-    let c13 = 1_i64 as *const libc::FILE;\n+    let c13 = 1_i64 as *const String;\n     (c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13)\n }\n \n@@ -297,9 +293,9 @@ fn other_casts()\n }\n \n pub fn assert_eq_13(l: (isize, usize, i8, i16, i32, i64, u8,\n-                        u16, u32, u64, f32, f64, *const libc::FILE),\n+                        u16, u32, u64, f32, f64, *const String),\n                     r: (isize, usize, i8, i16, i32, i64, u8,\n-                        u16, u32, u64, f32, f64, *const libc::FILE)) -> bool {\n+                        u16, u32, u64, f32, f64, *const String)) -> bool {\n     let (l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13) = l;\n     let (r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13) = r;\n     l1 == r1 && l2 == r2 && l3 == r3 && l4 == r4 && l5 == r5 && l6 == r6 && l7 == r7 &&\n@@ -308,7 +304,7 @@ pub fn assert_eq_13(l: (isize, usize, i8, i16, i32, i64, u8,\n \n \n pub fn main() {\n-    let f = 1_usize as *const libc::FILE;\n+    let f = 1_usize as *const String;\n     let t13 = (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.0, 1.0, f);\n     let t12 = (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1.0, 1.0);\n     assert_eq_13(from_1(), t13);"}, {"sha": "7845c9426e23b2d45d86ddd401d7dd8c070ea3a8", "filename": "src/test/run-pass/mir_trans_calls_variadic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fmir_trans_calls_variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fmir_trans_calls_variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_calls_variadic.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n+\n #[link(name = \"rust_test_helpers\", kind = \"static\")]\n extern {\n     fn rust_interesting_average(_: i64, ...) -> f64;"}, {"sha": "07c76e27284f5b387489d6f25ae65ec62b8d3a3b", "filename": "src/test/run-pass/newtype-struct-with-dtor.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,21 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n // pretty-expanded FIXME #23616\n \n-#![feature(libc)]\n-\n-extern crate libc;\n-use libc::c_int;\n+pub struct Fd(u32);\n \n-pub struct Fd(c_int);\n+fn foo(a: u32) {}\n \n impl Drop for Fd {\n     fn drop(&mut self) {\n         unsafe {\n             let Fd(s) = *self;\n-            libc::close(s);\n+            foo(s);\n         }\n     }\n }"}, {"sha": "9f39146e238d6efe8e1df96957085b139e1ac167", "filename": "src/test/run-pass/paths-containing-nul.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no files or I/O\n+\n use std::fs;\n use std::io;\n "}, {"sha": "1ef804fe8feea89c5c35b965936d7a323e701b79", "filename": "src/test/run-pass/pub-extern-privacy.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n+\n // pretty-expanded FIXME #23616\n \n use std::mem::transmute;"}, {"sha": "d087be6d10cfcea738cc527cbe5335390b780734", "filename": "src/test/run-pass/reachable-unnameable-items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Freachable-unnameable-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Freachable-unnameable-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freachable-unnameable-items.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n // aux-build:reachable-unnameable-items.rs\n \n extern crate reachable_unnameable_items;"}, {"sha": "d051e05b5f9e72c04255f0e5ac7eba87e8b76b78", "filename": "src/test/run-pass/rec-align-u64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u64.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare seems unimportant to test\n+\n // Issue #2303\n \n #![feature(intrinsics)]"}, {"sha": "8f278a315d1af23d82e5101b8aa418577aa55bcc", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -10,10 +10,9 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(libc)]\n+#![feature(allocator_api)]\n \n-extern crate libc;\n-use std::mem;\n+use std::heap::{Alloc, Heap, Layout};\n \n struct arena(());\n \n@@ -32,8 +31,9 @@ struct Ccx {\n \n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n-        mem::transmute(libc::malloc(mem::size_of::<Bcx<'a>>()\n-            as libc::size_t))\n+        let ptr = Heap.alloc(Layout::new::<Bcx>())\n+            .unwrap_or_else(|e| Heap.oom(e));\n+        &*(ptr as *const _)\n     }\n }\n \n@@ -45,7 +45,7 @@ fn g(fcx : &Fcx) {\n     let bcx = Bcx { fcx: fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n-        libc::free(mem::transmute(bcx2));\n+        Heap.dealloc(bcx2 as *const _ as *mut _, Layout::new::<Bcx>());\n     }\n }\n "}, {"sha": "950c2e0c4dfab19ad24a9c2c7ca63d4a82664c56", "filename": "src/test/run-pass/rfc-1014.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Frfc-1014.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Frfc-1014.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1014.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -7,6 +7,9 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n+// ignore-wasm32-bare no libc\n+\n #![feature(libc)]\n \n extern crate libc;"}, {"sha": "c51b33f9c4af62a10cc4302d3300bcf0208fd5a3", "filename": "src/test/run-pass/rfc1717/library-override.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Frfc1717%2Flibrary-override.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Frfc1717%2Flibrary-override.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1717%2Flibrary-override.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n // compile-flags: -lstatic=wronglibrary:rust_test_helpers\n \n #[link(name = \"wronglibrary\", kind = \"dylib\")]"}, {"sha": "b2e5ff62eb86eeaa762d9e4ea89bb5c9bfd65766", "filename": "src/test/run-pass/rfc1857-drop-order.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1857-drop-order.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n #![allow(dead_code, unreachable_code)]\n \n use std::cell::RefCell;"}, {"sha": "73ccd28a3e96364ee5dcefb3da430707d489846a", "filename": "src/test/run-pass/signal-alternate-stack-cleanup.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fsignal-alternate-stack-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fsignal-alternate-stack-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-alternate-stack-cleanup.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -13,6 +13,7 @@\n // triggers this situation by sending signal from atexit handler.\n //\n // ignore-windows\n+// ignore-wasm32-bare no libc\n \n #![feature(libc)]\n extern crate libc;"}, {"sha": "ab6adcbbffe7af6e5f43a08dbc7a279ee323595f", "filename": "src/test/run-pass/static-method-xcrate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -10,7 +10,6 @@\n \n // aux-build:static-methods-crate.rs\n \n-\n extern crate static_methods_crate;\n \n use static_methods_crate::read;"}, {"sha": "2b7fa0166a8ed613edbfe931aa5eda48e151f33d", "filename": "src/test/run-pass/static-mut-foreign.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -12,6 +12,7 @@\n // statics cannot. This ensures that there's some form of error if this is\n // attempted.\n \n+// ignore-wasm32-bare no libc to test ffi with\n \n #![feature(libc)]\n "}, {"sha": "61a2bcb3a9b758e0297094ed3c4ef36af3849a76", "filename": "src/test/run-pass/struct-return.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fstruct-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-return.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -7,7 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-//\n+\n+// ignore-wasm32-bare no libc to test ffi with\n \n #[repr(C)]\n #[derive(Copy, Clone)]"}, {"sha": "7f92707586b286476fcb221317313367d646a3ee", "filename": "src/test/run-pass/supported-cast.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsupported-cast.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,12 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(libc)]\n-\n-extern crate libc;\n-\n pub fn main() {\n-  let f = 1_usize as *const libc::FILE;\n+  let f = 1_usize as *const String;\n   println!(\"{:?}\", f as isize);\n   println!(\"{:?}\", f as usize);\n   println!(\"{:?}\", f as i8);\n@@ -27,7 +23,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1 as isize);\n   println!(\"{:?}\", 1 as usize);\n-  println!(\"{:?}\", 1 as *const libc::FILE);\n+  println!(\"{:?}\", 1 as *const String);\n   println!(\"{:?}\", 1 as i8);\n   println!(\"{:?}\", 1 as i16);\n   println!(\"{:?}\", 1 as i32);\n@@ -41,7 +37,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1_usize as isize);\n   println!(\"{:?}\", 1_usize as usize);\n-  println!(\"{:?}\", 1_usize as *const libc::FILE);\n+  println!(\"{:?}\", 1_usize as *const String);\n   println!(\"{:?}\", 1_usize as i8);\n   println!(\"{:?}\", 1_usize as i16);\n   println!(\"{:?}\", 1_usize as i32);\n@@ -55,7 +51,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1i8 as isize);\n   println!(\"{:?}\", 1i8 as usize);\n-  println!(\"{:?}\", 1i8 as *const libc::FILE);\n+  println!(\"{:?}\", 1i8 as *const String);\n   println!(\"{:?}\", 1i8 as i8);\n   println!(\"{:?}\", 1i8 as i16);\n   println!(\"{:?}\", 1i8 as i32);\n@@ -69,7 +65,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1u8 as isize);\n   println!(\"{:?}\", 1u8 as usize);\n-  println!(\"{:?}\", 1u8 as *const libc::FILE);\n+  println!(\"{:?}\", 1u8 as *const String);\n   println!(\"{:?}\", 1u8 as i8);\n   println!(\"{:?}\", 1u8 as i16);\n   println!(\"{:?}\", 1u8 as i32);\n@@ -83,7 +79,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1i16 as isize);\n   println!(\"{:?}\", 1i16 as usize);\n-  println!(\"{:?}\", 1i16 as *const libc::FILE);\n+  println!(\"{:?}\", 1i16 as *const String);\n   println!(\"{:?}\", 1i16 as i8);\n   println!(\"{:?}\", 1i16 as i16);\n   println!(\"{:?}\", 1i16 as i32);\n@@ -97,7 +93,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1u16 as isize);\n   println!(\"{:?}\", 1u16 as usize);\n-  println!(\"{:?}\", 1u16 as *const libc::FILE);\n+  println!(\"{:?}\", 1u16 as *const String);\n   println!(\"{:?}\", 1u16 as i8);\n   println!(\"{:?}\", 1u16 as i16);\n   println!(\"{:?}\", 1u16 as i32);\n@@ -111,7 +107,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1i32 as isize);\n   println!(\"{:?}\", 1i32 as usize);\n-  println!(\"{:?}\", 1i32 as *const libc::FILE);\n+  println!(\"{:?}\", 1i32 as *const String);\n   println!(\"{:?}\", 1i32 as i8);\n   println!(\"{:?}\", 1i32 as i16);\n   println!(\"{:?}\", 1i32 as i32);\n@@ -125,7 +121,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1u32 as isize);\n   println!(\"{:?}\", 1u32 as usize);\n-  println!(\"{:?}\", 1u32 as *const libc::FILE);\n+  println!(\"{:?}\", 1u32 as *const String);\n   println!(\"{:?}\", 1u32 as i8);\n   println!(\"{:?}\", 1u32 as i16);\n   println!(\"{:?}\", 1u32 as i32);\n@@ -139,7 +135,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1i64 as isize);\n   println!(\"{:?}\", 1i64 as usize);\n-  println!(\"{:?}\", 1i64 as *const libc::FILE);\n+  println!(\"{:?}\", 1i64 as *const String);\n   println!(\"{:?}\", 1i64 as i8);\n   println!(\"{:?}\", 1i64 as i16);\n   println!(\"{:?}\", 1i64 as i32);\n@@ -153,7 +149,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1u64 as isize);\n   println!(\"{:?}\", 1u64 as usize);\n-  println!(\"{:?}\", 1u64 as *const libc::FILE);\n+  println!(\"{:?}\", 1u64 as *const String);\n   println!(\"{:?}\", 1u64 as i8);\n   println!(\"{:?}\", 1u64 as i16);\n   println!(\"{:?}\", 1u64 as i32);\n@@ -167,7 +163,7 @@ pub fn main() {\n \n   println!(\"{:?}\", 1u64 as isize);\n   println!(\"{:?}\", 1u64 as usize);\n-  println!(\"{:?}\", 1u64 as *const libc::FILE);\n+  println!(\"{:?}\", 1u64 as *const String);\n   println!(\"{:?}\", 1u64 as i8);\n   println!(\"{:?}\", 1u64 as i16);\n   println!(\"{:?}\", 1u64 as i32);"}, {"sha": "4dadfdf9c756e90ff12ee60f67b363878af07a58", "filename": "src/test/run-pass/sync-send-in-std.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fsync-send-in-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fsync-send-in-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-in-std.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare networking not available\n+\n #![feature(lookup_host)]\n \n use std::net::lookup_host;"}, {"sha": "884633df66b1b1805c9ce8f75c4840e8bd39ec85", "filename": "src/test/run-pass/test-allow-fail-attr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Ftest-allow-fail-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Ftest-allow-fail-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-allow-fail-attr.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n // compile-flags: --test\n #![feature(allow_fail)]\n "}, {"sha": "360d4952d16aad5b6285cc49aa56f3551536c2e4", "filename": "src/test/run-pass/test-should-fail-good-message.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Ftest-should-fail-good-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Ftest-should-fail-good-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-should-fail-good-message.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare compiled with panic=abort by default\n // compile-flags: --test\n #[test]\n #[should_panic(expected = \"foo\")]"}, {"sha": "dd16bf2e4a38e0e9c622b342fcdf4d440fc5298c", "filename": "src/test/run-pass/union/union-c-interop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n+\n #[derive(Clone, Copy)]\n #[repr(C)]\n struct LARGE_INTEGER_U {"}, {"sha": "2198ead106bb71e6d0dd639614078947b8098e66", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n+\n #[link(name = \"rust_test_helpers\", kind = \"static\")]\n extern {\n     fn rust_interesting_average(_: u64, ...) -> f64;"}, {"sha": "e2e64ddfa3158e7e7bb031226c88ece4679ad835", "filename": "src/test/run-pass/x86stdcall.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fx86stdcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftest%2Frun-pass%2Fx86stdcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fx86stdcall.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-wasm32-bare no libc to test ffi with\n+\n // GetLastError doesn't seem to work with stack switching\n \n #[cfg(windows)]"}, {"sha": "39f41f57d11df3306723bae21031a5c859c69718", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -531,7 +531,7 @@ impl Config {\n             let name = line[prefix.len()+1 ..].split(&[':', ' '][..]).next().unwrap();\n \n             name == \"test\" ||\n-                name == util::get_os(&self.target) ||               // target\n+                util::matches_os(&self.target, name) ||             // target\n                 name == util::get_arch(&self.target) ||             // architecture\n                 name == util::get_pointer_width(&self.target) ||    // pointer width\n                 name == self.stage_id.split('-').next().unwrap() || // stage"}, {"sha": "3e3c56a07962afca00d884a25b6db7ae16d41dbf", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -1271,6 +1271,7 @@ actual:\\n\\\n             let crate_type = if aux_props.no_prefer_dynamic {\n                 None\n             } else if (self.config.target.contains(\"musl\") && !aux_props.force_host) ||\n+                      self.config.target.contains(\"wasm32\") ||\n                       self.config.target.contains(\"emscripten\") {\n                 // We primarily compile all auxiliary libraries as dynamic libraries\n                 // to avoid code size bloat and large binaries as much as possible\n@@ -1431,7 +1432,10 @@ actual:\\n\\\n             }\n         }\n \n-        if !self.props.no_prefer_dynamic {\n+\n+        if self.config.target == \"wasm32-unknown-unknown\" {\n+            // rustc.arg(\"-g\"); // get any backtrace at all on errors\n+        } else if !self.props.no_prefer_dynamic {\n             rustc.args(&[\"-C\", \"prefer-dynamic\"]);\n         }\n \n@@ -1472,6 +1476,10 @@ actual:\\n\\\n             let mut fname = f.file_name().unwrap().to_os_string();\n             fname.push(\".js\");\n             f.set_file_name(&fname);\n+        } else if self.config.target.contains(\"wasm32\") {\n+            let mut fname = f.file_name().unwrap().to_os_string();\n+            fname.push(\".wasm\");\n+            f.set_file_name(&fname);\n         } else if !env::consts::EXE_SUFFIX.is_empty() {\n             let mut fname = f.file_name().unwrap().to_os_string();\n             fname.push(env::consts::EXE_SUFFIX);\n@@ -1494,6 +1502,22 @@ actual:\\n\\\n             }\n         }\n \n+        // If this is otherwise wasm , then run tests under nodejs with our\n+        // shim\n+        if self.config.target.contains(\"wasm32\") {\n+            if let Some(ref p) = self.config.nodejs {\n+                args.push(p.clone());\n+            } else {\n+                self.fatal(\"no NodeJS binary found (--nodejs)\");\n+            }\n+\n+            let src = self.config.src_base\n+                .parent().unwrap() // chop off `run-pass`\n+                .parent().unwrap() // chop off `test`\n+                .parent().unwrap(); // chop off `src`\n+            args.push(src.join(\"src/etc/wasm32-shim.js\").display().to_string());\n+        }\n+\n         let exe_file = self.make_exe_name();\n \n         // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "c00f28eae67afd0e3fbf5b0a25e56a7ccf4399d3", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -51,10 +51,15 @@ const ARCH_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"wasm32\", \"wasm32\"),\n ];\n \n-pub fn get_os(triple: &str) -> &'static str {\n+pub fn matches_os(triple: &str, name: &str) -> bool {\n+    // For the wasm32 bare target we ignore anything also ignored on emscripten\n+    // and then we also recognize `wasm32-bare` as the os for the target\n+    if triple == \"wasm32-unknown-unknown\" {\n+        return name == \"emscripten\" || name == \"wasm32-bare\"\n+    }\n     for &(triple_os, os) in OS_TABLE {\n         if triple.contains(triple_os) {\n-            return os;\n+            return os == name;\n         }\n     }\n     panic!(\"Cannot determine OS from triple\");"}, {"sha": "598620fa29392fc9e31cdf55afb7a2d3df93c7ea", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff0f74b0c4a8d384160af81a1b21f53622d8af/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=80ff0f74b0c4a8d384160af81a1b21f53622d8af", "patch": "@@ -50,6 +50,8 @@ pub mod unstable_book;\n \n fn filter_dirs(path: &Path) -> bool {\n     let skip = [\n+        \"src/binaryen\",\n+        \"src/dlmalloc\",\n         \"src/jemalloc\",\n         \"src/llvm\",\n         \"src/libbacktrace\","}]}