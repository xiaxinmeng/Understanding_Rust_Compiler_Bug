{"sha": "4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMWZjZDRkNWJkNDBjMTZkMTA5ZWFjY2VlNTYwZDcyZmE1YjJiMjE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-17T09:05:45Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-17T09:05:45Z"}, "message": "Merge pull request #184 from Manishearth/identity_op\n\nIdentity op now uses const folding, no longer follows const bindings", "tree": {"sha": "5041384da0bfabdcf32b5324fcb3c5f7cf7c8b7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5041384da0bfabdcf32b5324fcb3c5f7cf7c8b7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21", "html_url": "https://github.com/rust-lang/rust/commit/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65deb956f1f2560ba9fa9148aef5b111bccc02cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/65deb956f1f2560ba9fa9148aef5b111bccc02cc", "html_url": "https://github.com/rust-lang/rust/commit/65deb956f1f2560ba9fa9148aef5b111bccc02cc"}, {"sha": "759b45a46d299f19a10477cc226e70002ac91340", "url": "https://api.github.com/repos/rust-lang/rust/commits/759b45a46d299f19a10477cc226e70002ac91340", "html_url": "https://github.com/rust-lang/rust/commit/759b45a46d299f19a10477cc226e70002ac91340"}], "stats": {"total": 481, "additions": 448, "deletions": 33}, "files": [{"sha": "bb74b3c71d102c6857dd68fc070eda1796200cfd", "filename": "src/consts.rs", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21", "patch": "@@ -0,0 +1,393 @@\n+use rustc::lint::Context;\n+use rustc::middle::const_eval::lookup_const_by_id;\n+use rustc::middle::def::PathResolution;\n+use rustc::middle::def::Def::*;\n+use syntax::ast::*;\n+use syntax::ptr::P;\n+use std::rc::Rc;\n+use std::ops::Deref;\n+use self::ConstantVariant::*;\n+use self::FloatWidth::*;\n+\n+#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n+pub enum FloatWidth {\n+    Fw32,\n+    Fw64,\n+    FwAny\n+}\n+\n+impl From<FloatTy> for FloatWidth {\n+    fn from(ty: FloatTy) -> FloatWidth {\n+        match ty {\n+            TyF32 => Fw32,\n+            TyF64 => Fw64,\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Debug, Clone)]\n+pub struct Constant {\n+    pub constant: ConstantVariant,\n+    pub needed_resolution: bool\n+}\n+\n+impl Constant {\n+    pub fn new(variant: ConstantVariant) -> Constant {\n+        Constant { constant: variant, needed_resolution: false }\n+    }\n+\n+    pub fn new_resolved(variant: ConstantVariant) -> Constant {\n+        Constant { constant: variant, needed_resolution: true }\n+    }\n+\n+    // convert this constant to a f64, if possible\n+    pub fn as_float(&self) -> Option<f64> {\n+        match &self.constant {\n+            &ConstantByte(b) => Some(b as f64),\n+            &ConstantFloat(ref s, _) => s.parse().ok(),\n+            &ConstantInt(i, ty) => Some(if is_negative(ty) {\n+                -(i as f64) } else { i as f64 }),\n+            _ => None\n+        }\n+    }\n+}\n+\n+/// a Lit_-like enum to fold constant `Expr`s into\n+#[derive(PartialEq, Eq, Debug, Clone)]\n+pub enum ConstantVariant {\n+    /// a String \"abc\"\n+    ConstantStr(String, StrStyle),\n+    /// a Binary String b\"abc\"\n+    ConstantBinary(Rc<Vec<u8>>),\n+    /// a single byte b'a'\n+    ConstantByte(u8),\n+    /// a single char 'a'\n+    ConstantChar(char),\n+    /// an integer\n+    ConstantInt(u64, LitIntType),\n+    /// a float with given type\n+    ConstantFloat(String, FloatWidth),\n+    /// true or false\n+    ConstantBool(bool),\n+    /// an array of constants\n+    ConstantVec(Vec<Constant>),\n+    /// also an array, but with only one constant, repeated N times\n+    ConstantRepeat(Box<ConstantVariant>, usize),\n+    /// a tuple of constants\n+    ConstantTuple(Vec<Constant>),\n+}\n+\n+impl ConstantVariant {\n+    /// convert to u64 if possible\n+    ///\n+    /// # panics\n+    ///\n+    /// if the constant could not be converted to u64 losslessly\n+    fn as_u64(&self) -> u64 {\n+        if let &ConstantInt(val, _) = self {\n+            val // TODO we may want to check the sign if any\n+        } else {\n+            panic!(\"Could not convert a {:?} to u64\");\n+        }\n+    }\n+}\n+\n+/// simple constant folding: Insert an expression, get a constant or none.\n+pub fn constant(cx: &Context, e: &Expr) -> Option<Constant> {\n+    match &e.node {\n+        &ExprParen(ref inner) => constant(cx, inner),\n+        &ExprPath(_, _) => fetch_path(cx, e),\n+        &ExprBlock(ref block) => constant_block(cx, block),\n+        &ExprIf(ref cond, ref then, ref otherwise) =>\n+            constant_if(cx, &*cond, &*then, &*otherwise),\n+        &ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n+        &ExprVec(ref vec) => constant_vec(cx, &vec[..]),\n+        &ExprTup(ref tup) => constant_tup(cx, &tup[..]),\n+        &ExprRepeat(ref value, ref number) =>\n+            constant_binop_apply(cx, value, number,|v, n|\n+                Some(ConstantRepeat(Box::new(v), n.as_u64() as usize))),\n+        &ExprUnary(op, ref operand) => constant(cx, operand).and_then(\n+            |o| match op {\n+                UnNot =>\n+                    if let ConstantBool(b) = o.constant {\n+                        Some(Constant{\n+                            needed_resolution: o.needed_resolution,\n+                            constant: ConstantBool(!b),\n+                        })\n+                    } else { None },\n+                UnNeg => constant_negate(o),\n+                UnUniq | UnDeref => Some(o),\n+            }),\n+        &ExprBinary(op, ref left, ref right) =>\n+            constant_binop(cx, op, left, right),\n+        //TODO: add other expressions\n+        _ => None,\n+    }\n+}\n+\n+fn lit_to_constant(lit: &Lit_) -> Constant {\n+    match lit {\n+        &LitStr(ref is, style) =>\n+            Constant::new(ConstantStr(is.to_string(), style)),\n+        &LitBinary(ref blob) => Constant::new(ConstantBinary(blob.clone())),\n+        &LitByte(b) => Constant::new(ConstantByte(b)),\n+        &LitChar(c) => Constant::new(ConstantChar(c)),\n+        &LitInt(value, ty) => Constant::new(ConstantInt(value, ty)),\n+        &LitFloat(ref is, ty) => {\n+            Constant::new(ConstantFloat(is.to_string(), ty.into()))\n+        },\n+        &LitFloatUnsuffixed(ref is) => {\n+            Constant::new(ConstantFloat(is.to_string(), FwAny))\n+        },\n+        &LitBool(b) => Constant::new(ConstantBool(b)),\n+    }\n+}\n+\n+/// create `Some(ConstantVec(..))` of all constants, unless there is any\n+/// non-constant part\n+fn constant_vec<E: Deref<Target=Expr> + Sized>(cx: &Context, vec: &[E]) -> Option<Constant> {\n+    let mut parts = Vec::new();\n+    let mut resolved = false;\n+    for opt_part in vec {\n+        match constant(cx, opt_part) {\n+            Some(p) => {\n+                resolved |= (&p).needed_resolution;\n+                parts.push(p)\n+            },\n+            None => { return None; },\n+        }\n+    }\n+    Some(Constant {\n+        constant: ConstantVec(parts),\n+        needed_resolution: resolved\n+    })\n+}\n+\n+fn constant_tup<E: Deref<Target=Expr> + Sized>(cx: &Context, tup: &[E]) -> Option<Constant> {\n+    let mut parts = Vec::new();\n+    let mut resolved = false;\n+    for opt_part in tup {\n+        match constant(cx, opt_part) {\n+            Some(p) => {\n+                resolved |= (&p).needed_resolution;\n+                parts.push(p)\n+            },\n+            None => { return None; },\n+        }\n+    }\n+    Some(Constant {\n+        constant: ConstantTuple(parts),\n+        needed_resolution: resolved\n+    })\n+}\n+\n+/// lookup a possibly constant expression from a ExprPath\n+fn fetch_path(cx: &Context, e: &Expr) -> Option<Constant> {\n+    if let Some(&PathResolution { base_def: DefConst(id), ..}) =\n+            cx.tcx.def_map.borrow().get(&e.id) {\n+        lookup_const_by_id(cx.tcx, id, None).and_then(\n+            |l| constant(cx, l).map(|c| Constant::new_resolved(c.constant)))\n+    } else { None }\n+}\n+\n+/// A block can only yield a constant if it only has one constant expression\n+fn constant_block(cx: &Context, block: &Block) -> Option<Constant> {\n+    if block.stmts.is_empty() {\n+        block.expr.as_ref().and_then(|b| constant(cx, &*b))\n+    } else { None }\n+}\n+\n+fn constant_if(cx: &Context, cond: &Expr, then: &Block, otherwise:\n+        &Option<P<Expr>>) -> Option<Constant> {\n+    if let Some(Constant{ constant: ConstantBool(b), needed_resolution: res }) =\n+            constant(cx, cond) {\n+        if b {\n+            constant_block(cx, then)\n+        } else {\n+            otherwise.as_ref().and_then(|expr| constant(cx, &*expr))\n+        }.map(|part|\n+            Constant {\n+                constant: part.constant,\n+                needed_resolution: res || part.needed_resolution,\n+            })\n+    } else { None }\n+}\n+\n+fn constant_negate(o: Constant) -> Option<Constant> {\n+    Some(Constant{\n+        needed_resolution: o.needed_resolution,\n+        constant: match o.constant {\n+            ConstantInt(value, ty) =>\n+                ConstantInt(value, match ty {\n+                    SignedIntLit(ity, sign) =>\n+                        SignedIntLit(ity, neg_sign(sign)),\n+                    UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n+                    _ => { return None; },\n+                }),\n+            ConstantFloat(is, ty) =>\n+                ConstantFloat(neg_float_str(is), ty),\n+            _ => { return None; },\n+        }\n+    })\n+}\n+\n+fn neg_sign(s: Sign) -> Sign {\n+    match s {\n+        Sign::Plus => Sign::Minus,\n+        Sign::Minus => Sign::Plus,\n+    }\n+}\n+\n+fn neg_float_str(s: String) -> String {\n+    if s.starts_with('-') {\n+        s[1..].to_owned()\n+    } else {\n+        format!(\"-{}\", &*s)\n+    }\n+}\n+\n+/// is the given LitIntType negative?\n+///\n+/// Examples\n+///\n+/// ```\n+/// assert!(is_negative(UnsuffixedIntLit(Minus)));\n+/// ```\n+pub fn is_negative(ty: LitIntType) -> bool {\n+    match ty {\n+        SignedIntLit(_, sign) | UnsuffixedIntLit(sign) => sign == Minus,\n+        UnsignedIntLit(_) => false,\n+    }\n+}\n+\n+fn unify_int_type(l: LitIntType, r: LitIntType, s: Sign) -> Option<LitIntType> {\n+    match (l, r) {\n+        (SignedIntLit(lty, _), SignedIntLit(rty, _)) => if lty == rty {\n+            Some(SignedIntLit(lty, s)) } else { None },\n+        (UnsignedIntLit(lty), UnsignedIntLit(rty)) =>\n+            if s == Plus && lty == rty {\n+                Some(UnsignedIntLit(lty))\n+            } else { None },\n+        (UnsuffixedIntLit(_), UnsuffixedIntLit(_)) => Some(UnsuffixedIntLit(s)),\n+        (SignedIntLit(lty, _), UnsuffixedIntLit(_)) => Some(SignedIntLit(lty, s)),\n+        (UnsignedIntLit(lty), UnsuffixedIntLit(rs)) => if rs == Plus {\n+            Some(UnsignedIntLit(lty)) } else { None },\n+        (UnsuffixedIntLit(_), SignedIntLit(rty, _)) => Some(SignedIntLit(rty, s)),\n+        (UnsuffixedIntLit(ls), UnsignedIntLit(rty)) => if ls == Plus {\n+            Some(UnsignedIntLit(rty)) } else { None },\n+        _ => None,\n+    }\n+}\n+\n+fn constant_binop(cx: &Context, op: BinOp, left: &Expr, right: &Expr)\n+        -> Option<Constant> {\n+    match op.node {\n+        BiAdd => constant_binop_apply(cx, left, right, |l, r|\n+            match (l, r) {\n+                (ConstantByte(l8), ConstantByte(r8)) =>\n+                    l8.checked_add(r8).map(ConstantByte),\n+                (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n+                    let (ln, rn) = (is_negative(lty), is_negative(rty));\n+                    if ln == rn {\n+                        unify_int_type(lty, rty, if ln { Minus } else { Plus })\n+                            .and_then(|ty| l64.checked_add(r64).map(\n+                                |v| ConstantInt(v, ty)))\n+                    } else {\n+                        if ln {\n+                            add_neg_int(r64, rty, l64, lty)\n+                        } else {\n+                            add_neg_int(l64, lty, r64, rty)\n+                        }\n+                    }\n+                },\n+                // TODO: float\n+                _ => None\n+            }),\n+        BiSub => constant_binop_apply(cx, left, right, |l, r|\n+            match (l, r) {\n+                (ConstantByte(l8), ConstantByte(r8)) => if r8 > l8 {\n+                    None } else { Some(ConstantByte(l8 - r8)) },\n+                (ConstantInt(l64, lty), ConstantInt(r64, rty)) => {\n+                    let (ln, rn) = (is_negative(lty), is_negative(rty));\n+                    match (ln, rn) {\n+                        (false, false) => sub_int(l64, lty, r64, rty, r64 > l64),\n+                        (true, true) => sub_int(l64, lty, r64, rty, l64 > r64),\n+                        (true, false) => unify_int_type(lty, rty, Minus)\n+                            .and_then(|ty| l64.checked_add(r64).map(\n+                                |v| ConstantInt(v, ty))),\n+                        (false, true) => unify_int_type(lty, rty, Plus)\n+                            .and_then(|ty| l64.checked_add(r64).map(\n+                                |v| ConstantInt(v, ty))),\n+                    }\n+                },\n+                _ => None,\n+            }),\n+        //BiMul,\n+        //BiDiv,\n+        //BiRem,\n+        BiAnd => constant_short_circuit(cx, left, right, false),\n+        BiOr => constant_short_circuit(cx, left, right, true),\n+        //BiBitXor,\n+        //BiBitAnd,\n+        //BiBitOr,\n+        //BiShl,\n+        //BiShr,\n+        //BiEq,\n+        //BiLt,\n+        //BiLe,\n+        //BiNe,\n+        //BiGe,\n+        //BiGt,\n+        _ => None,\n+    }\n+}\n+\n+fn add_neg_int(pos: u64, pty: LitIntType, neg: u64, nty: LitIntType) ->\n+        Option<ConstantVariant> {\n+    if neg > pos {\n+        unify_int_type(nty, pty, Minus).map(|ty| ConstantInt(neg - pos, ty))\n+    } else {\n+        unify_int_type(nty, pty, Plus).map(|ty| ConstantInt(pos - neg, ty))\n+    }\n+}\n+\n+fn sub_int(l: u64, lty: LitIntType, r: u64, rty: LitIntType, neg: bool) ->\n+        Option<ConstantVariant> {\n+     unify_int_type(lty, rty, if neg { Minus } else { Plus }).and_then(\n+        |ty| l.checked_sub(r).map(|v| ConstantInt(v, ty)))\n+}\n+\n+fn constant_binop_apply<F>(cx: &Context, left: &Expr, right: &Expr, op: F)\n+        -> Option<Constant>\n+where F: Fn(ConstantVariant, ConstantVariant) -> Option<ConstantVariant> {\n+    if let (Some(Constant { constant: lc, needed_resolution: ln }),\n+            Some(Constant { constant: rc, needed_resolution: rn })) =\n+            (constant(cx, left), constant(cx, right)) {\n+        op(lc, rc).map(|c|\n+            Constant {\n+                needed_resolution: ln || rn,\n+                constant: c,\n+            })\n+    } else { None }\n+}\n+\n+fn constant_short_circuit(cx: &Context, left: &Expr, right: &Expr, b: bool) ->\n+        Option<Constant> {\n+    constant(cx, left).and_then(|left|\n+        if let &ConstantBool(lbool) = &left.constant {\n+            if lbool == b {\n+                Some(left)\n+            } else {\n+                constant(cx, right).and_then(|right|\n+                    if let ConstantBool(_) = right.constant {\n+                        Some(Constant {\n+                            constant: right.constant,\n+                            needed_resolution: left.needed_resolution ||\n+                                               right.needed_resolution,\n+                        })\n+                    } else { None }\n+                )\n+            }\n+        } else { None }\n+    )\n+}"}, {"sha": "a429d42c4cc8913a14e6316761099d2fc52435d6", "filename": "src/identity_op.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21", "patch": "@@ -4,6 +4,8 @@ use rustc::middle::def::*;\n use syntax::ast::*;\n use syntax::codemap::Span;\n \n+use consts::{constant, Constant, is_negative};\n+use consts::ConstantVariant::ConstantInt;\n use utils::{span_lint, snippet};\n \n declare_lint! { pub IDENTITY_OP, Warn,\n@@ -44,35 +46,19 @@ impl LintPass for IdentityOp {\n \n \n fn check(cx: &Context, e: &Expr, m: i8, span: Span, arg: Span) {\n-    if have_lit(cx, e, m) {\n-        span_lint(cx, IDENTITY_OP, span, &format!(\n-            \"the operation is ineffective. Consider reducing it to `{}`\",\n-           snippet(cx, arg, \"..\")));\n-    }\n-}\n-\n-fn have_lit(cx: &Context, e : &Expr, m: i8) -> bool {\n-    match &e.node {\n-        &ExprUnary(UnNeg, ref litexp) => have_lit(cx, litexp, -m),\n-        &ExprLit(ref lit) => {\n-            match (&lit.node, m) {\n-                (&LitInt(0, _), 0) => true,\n-                (&LitInt(1, SignedIntLit(_, Plus)), 1) => true,\n-                (&LitInt(1, UnsuffixedIntLit(Plus)), 1) => true,\n-                (&LitInt(1, SignedIntLit(_, Minus)), -1) => true,\n-                (&LitInt(1, UnsuffixedIntLit(Minus)), -1) => true,\n-                _ => false\n+    if let Some(c) = constant(cx, e) {\n+        if c.needed_resolution { return; } // skip linting w/ lookup for now\n+        if let ConstantInt(v, ty) = c.constant {\n+            if match m {\n+                0 => v == 0,\n+                -1 => is_negative(ty),\n+                1 => !is_negative(ty),\n+                _ => unreachable!(),\n+            } {\n+                span_lint(cx, IDENTITY_OP, span, &format!(\n+                    \"the operation is ineffective. Consider reducing it to `{}`\",\n+                   snippet(cx, arg, \"..\")));\n             }\n-        },\n-        &ExprParen(ref p) => have_lit(cx, p, m),\n-        &ExprPath(_, _) => {\n-            match cx.tcx.def_map.borrow().get(&e.id) {\n-                Some(&PathResolution { base_def: DefConst(id), ..}) =>\n-                        lookup_const_by_id(cx.tcx, id, Option::None)\n-                        .map_or(false, |l| have_lit(cx, l, m)),\n-                _ => false\n-            }\n-        },\n-        _ => false\n+        }\n     }\n }"}, {"sha": "d7a10562df143527bb49566f66bd6f5902d03bc3", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21", "patch": "@@ -16,6 +16,7 @@ use rustc::lint::LintPassObject;\n \n #[macro_use]\n pub mod utils;\n+pub mod consts;\n pub mod types;\n pub mod misc;\n pub mod eq_op;"}, {"sha": "18e683e8a9e853234dc9622601cc9935401af49f", "filename": "tests/compile-fail/identity_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/tests%2Fcompile-fail%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/tests%2Fcompile-fail%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fidentity_op.rs?ref=4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21", "patch": "@@ -11,14 +11,14 @@ fn main() {\n \n     x + 0;        //~ERROR the operation is ineffective\n     0 + x;        //~ERROR the operation is ineffective\n-    x - ZERO;     //~ERROR the operation is ineffective\n+    x - ZERO;     //no error, as we skip lookups (for now)\n     x | (0);      //~ERROR the operation is ineffective\n-    ((ZERO)) | x; //~ERROR the operation is ineffective\n+    ((ZERO)) | x; //no error, as we skip lookups (for now)\n \n     x * 1;        //~ERROR the operation is ineffective\n     1 * x;        //~ERROR the operation is ineffective\n-    x / ONE;      //~ERROR the operation is ineffective\n+    x / ONE;      //no error, as we skip lookups (for now)\n \n-    x & NEG_ONE;  //~ERROR the operation is ineffective\n+    x & NEG_ONE;  //no error, as we skip lookups (for now)\n     -1 & x;       //~ERROR the operation is ineffective\n }"}, {"sha": "ebb25f61b7583ed7a0830c04ad8527ea02efc8aa", "filename": "tests/compile-fail/precedence.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/tests%2Fcompile-fail%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/tests%2Fcompile-fail%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fprecedence.rs?ref=4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21", "patch": "@@ -2,6 +2,7 @@\n #![plugin(clippy)]\n \n #[deny(precedence)]\n+#[allow(identity_op)]\n #[allow(eq_op)]\n fn main() {\n     format!(\"{} vs. {}\", 1 << 2 + 3, (1 << 2) + 3); //~ERROR operator precedence can trip"}, {"sha": "db309952be43bbe7370fde518bc85850a0cc2af8", "filename": "tests/consts.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=4f1fcd4d5bd40c16d109eaccee560d72fa5b2b21", "patch": "@@ -0,0 +1,34 @@\n+#![allow(plugin_as_library)]\n+#![feature(rustc_private)]\n+\n+extern crate clippy;\n+extern crate syntax;\n+extern crate rustc;\n+\n+use clippy::consts::constant;\n+use clippy::consts::ConstantVariant::*;\n+use syntax::ast::*;\n+use syntax::ptr::P;\n+use syntax::codemap::{Spanned, COMMAND_LINE_SP};\n+use std::mem;\n+use rustc::lint::Context;\n+\n+fn ctx() -> &'static Context<'static, 'static> {\n+\tunsafe { \n+\t\tlet x : *const Context<'static, 'static> = std::ptr::null();\n+\t\tmem::transmute(x)\n+\t}\n+}\n+\n+#[test]\n+fn test_lit() {\n+    assert_eq!(Some(ConstantBool(true)), constant(ctx(),\n+        &Expr{ \n+\t\t\tid: 1, \n+\t\t\tnode: ExprLit(P(Spanned{ \n+\t\t\t\tnode: LitBool(true), \n+\t\t\t\tspan: COMMAND_LINE_SP,\n+\t\t\t})), \n+\t\t\tspan: COMMAND_LINE_SP,\n+\t\t}).map(|x| x.constant));\n+}"}]}