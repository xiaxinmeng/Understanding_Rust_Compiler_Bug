{"sha": "bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZmQyOTdmNDkxMGJiZjIzMDVlYzg1OWQ3Y2Y0MmI3ZGNhMjVmNTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-11T22:42:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-11T22:42:39Z"}, "message": "Merge #2727\n\n2727: Qualify paths in 'add impl members' r=flodiebold a=flodiebold\n\nThis makes the 'add impl members' assist qualify paths, so that they should resolve to the same thing as in the definition. To do that, it adds an algorithm that finds a path to refer to any item from any module (if possible), which is actually probably the more important part of this PR :smile: It handles visibility, reexports, renamed crates, prelude etc.; I think the only thing that's missing is support for local items. I'm not sure about the performance, since it takes into account every location where the target item has been `pub use`d, and then recursively goes up the module tree; there's probably potential for optimization by memoizing more, but I think the general shape of the algorithm is necessary to handle every case in Rust's module system.\r\n\r\n~The 'find path' part is actually pretty complete, I think; I'm still working on the assist (hence the failing tests).~\r\n\r\nFixes #1943.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "c6b53cd774e7baacf213e91b295734852a83f40b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6b53cd774e7baacf213e91b295734852a83f40b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeGk9fCRBK7hj4Ov3rIwAAdHIIABaR60KBv05Y5FiRgZJMb5LZ\nLM58SRagAVWH2qNMJecoYQ/nzScmV55HsilGXmSVUflWWZuiH5Kbc8F7U1qJNiRH\n5zUiP50EhsXQEQXsuPaLP4oeqNpHyPflDBRtjgx9TqIxA+OEHQVZix81Io0Mb6lR\nGQnlB8zfNXbvmmEw+KwKW2Waog1kXgpDaSVHmPNmnr1xGppPDpexNncrw/mOqCei\nWBk8MCEMakuHe/3j/+NRcQurQarxRzIAldo8beogHjCZcaHSB1mOQu+w5G0l3QvM\n3IQDjVGoYfp2gQJiwLOXwVvQ6JQjoBQF3iGCVcdlDePIadFrwR+tBawmwW6/mJk=\n=v6bW\n-----END PGP SIGNATURE-----\n", "payload": "tree c6b53cd774e7baacf213e91b295734852a83f40b\nparent e90aa86fbfa716c4028f38d0d22654065011a964\nparent ccb75f7c979b56bc62b61fadd81903e11a7f5d74\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1578782559 +0000\ncommitter GitHub <noreply@github.com> 1578782559 +0000\n\nMerge #2727\n\n2727: Qualify paths in 'add impl members' r=flodiebold a=flodiebold\n\nThis makes the 'add impl members' assist qualify paths, so that they should resolve to the same thing as in the definition. To do that, it adds an algorithm that finds a path to refer to any item from any module (if possible), which is actually probably the more important part of this PR :smile: It handles visibility, reexports, renamed crates, prelude etc.; I think the only thing that's missing is support for local items. I'm not sure about the performance, since it takes into account every location where the target item has been `pub use`d, and then recursively goes up the module tree; there's probably potential for optimization by memoizing more, but I think the general shape of the algorithm is necessary to handle every case in Rust's module system.\r\n\r\n~The 'find path' part is actually pretty complete, I think; I'm still working on the assist (hence the failing tests).~\r\n\r\nFixes #1943.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "html_url": "https://github.com/rust-lang/rust/commit/bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e90aa86fbfa716c4028f38d0d22654065011a964", "url": "https://api.github.com/repos/rust-lang/rust/commits/e90aa86fbfa716c4028f38d0d22654065011a964", "html_url": "https://github.com/rust-lang/rust/commit/e90aa86fbfa716c4028f38d0d22654065011a964"}, {"sha": "ccb75f7c979b56bc62b61fadd81903e11a7f5d74", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccb75f7c979b56bc62b61fadd81903e11a7f5d74", "html_url": "https://github.com/rust-lang/rust/commit/ccb75f7c979b56bc62b61fadd81903e11a7f5d74"}], "stats": {"total": 1080, "additions": 995, "deletions": 85}, "files": [{"sha": "90c505f401b2f614aa24e540e81a85413ef9349d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -872,6 +872,7 @@ dependencies = [\n  \"ra_hir 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n "}, {"sha": "50be8d9bc28222f92f017d5cd518c4469d646e69", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -10,6 +10,7 @@ doctest = false\n [dependencies]\n format-buf = \"1.0.0\"\n join_to_string = \"0.1.3\"\n+rustc-hash = \"1.0\"\n itertools = \"0.8.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }"}, {"sha": "bf1136193d376fde8a4e34172d497e639393c0b7", "filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs", "status": "modified", "additions": 184, "deletions": 67, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -1,12 +1,13 @@\n-use std::collections::HashMap;\n-\n-use hir::{db::HirDatabase, HasSource};\n+use hir::{db::HirDatabase, HasSource, InFile};\n use ra_syntax::{\n     ast::{self, edit, make, AstNode, NameOwner},\n     SmolStr,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n+    Assist, AssistCtx, AssistId,\n+};\n \n #[derive(PartialEq)]\n enum AddMissingImplMembersMode {\n@@ -134,25 +135,23 @@ fn add_missing_impl_members_inner(\n         return None;\n     }\n \n-    let file_id = ctx.frange.file_id;\n     let db = ctx.db;\n+    let file_id = ctx.frange.file_id;\n+    let trait_file_id = trait_.source(db).file_id;\n \n     ctx.add_assist(AssistId(assist_id), label, |edit| {\n         let n_existing_items = impl_item_list.impl_items().count();\n-        let substs = get_syntactic_substs(impl_node).unwrap_or_default();\n-        let generic_def: hir::GenericDef = trait_.into();\n-        let substs_by_param: HashMap<_, _> = generic_def\n-            .params(db)\n-            .into_iter()\n-            // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n-            .skip(1)\n-            .zip(substs.into_iter())\n-            .collect();\n+        let module = hir::SourceAnalyzer::new(\n+            db,\n+            hir::InFile::new(file_id.into(), impl_node.syntax()),\n+            None,\n+        )\n+        .module();\n+        let ast_transform = QualifyPaths::new(db, module)\n+            .or(SubstituteTypeParams::for_trait_impl(db, trait_, impl_node));\n         let items = missing_items\n             .into_iter()\n-            .map(|it| {\n-                substitute_type_params(db, hir::InFile::new(file_id.into(), it), &substs_by_param)\n-            })\n+            .map(|it| ast_transform::apply(&*ast_transform, InFile::new(trait_file_id, it)))\n             .map(|it| match it {\n                 ast::ImplItem::FnDef(def) => ast::ImplItem::FnDef(add_body(def)),\n                 _ => it,\n@@ -177,56 +176,6 @@ fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n     }\n }\n \n-// FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n-// trait ref, and then go from the types in the substs back to the syntax)\n-// FIXME: This should be a general utility (not even just for assists)\n-fn get_syntactic_substs(impl_block: ast::ImplBlock) -> Option<Vec<ast::TypeRef>> {\n-    let target_trait = impl_block.target_trait()?;\n-    let path_type = match target_trait {\n-        ast::TypeRef::PathType(path) => path,\n-        _ => return None,\n-    };\n-    let type_arg_list = path_type.path()?.segment()?.type_arg_list()?;\n-    let mut result = Vec::new();\n-    for type_arg in type_arg_list.type_args() {\n-        let type_arg: ast::TypeArg = type_arg;\n-        result.push(type_arg.type_ref()?);\n-    }\n-    Some(result)\n-}\n-\n-// FIXME: This should be a general utility (not even just for assists)\n-fn substitute_type_params<N: AstNode>(\n-    db: &impl HirDatabase,\n-    node: hir::InFile<N>,\n-    substs: &HashMap<hir::TypeParam, ast::TypeRef>,\n-) -> N {\n-    let type_param_replacements = node\n-        .value\n-        .syntax()\n-        .descendants()\n-        .filter_map(ast::TypeRef::cast)\n-        .filter_map(|n| {\n-            let path = match &n {\n-                ast::TypeRef::PathType(path_type) => path_type.path()?,\n-                _ => return None,\n-            };\n-            let analyzer = hir::SourceAnalyzer::new(db, node.with_value(n.syntax()), None);\n-            let resolution = analyzer.resolve_path(db, &path)?;\n-            match resolution {\n-                hir::PathResolution::TypeParam(tp) => Some((n, substs.get(&tp)?.clone())),\n-                _ => None,\n-            }\n-        })\n-        .collect::<Vec<_>>();\n-\n-    if type_param_replacements.is_empty() {\n-        node.value\n-    } else {\n-        edit::replace_descendants(&node.value, type_param_replacements.into_iter())\n-    }\n-}\n-\n /// Given an `ast::ImplBlock`, resolves the target trait (the one being\n /// implemented) to a `ast::TraitDef`.\n fn resolve_target_trait_def(\n@@ -400,6 +349,174 @@ impl Foo for S {\n         )\n     }\n \n+    #[test]\n+    fn test_qualify_path_1() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+mod foo {\n+    pub struct Bar;\n+    trait Foo { fn foo(&self, bar: Bar); }\n+}\n+struct S;\n+impl foo::Foo for S { <|> }\",\n+            \"\n+mod foo {\n+    pub struct Bar;\n+    trait Foo { fn foo(&self, bar: Bar); }\n+}\n+struct S;\n+impl foo::Foo for S {\n+    <|>fn foo(&self, bar: foo::Bar) { unimplemented!() }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_qualify_path_generic() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+mod foo {\n+    pub struct Bar<T>;\n+    trait Foo { fn foo(&self, bar: Bar<u32>); }\n+}\n+struct S;\n+impl foo::Foo for S { <|> }\",\n+            \"\n+mod foo {\n+    pub struct Bar<T>;\n+    trait Foo { fn foo(&self, bar: Bar<u32>); }\n+}\n+struct S;\n+impl foo::Foo for S {\n+    <|>fn foo(&self, bar: foo::Bar<u32>) { unimplemented!() }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_qualify_path_and_substitute_param() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+mod foo {\n+    pub struct Bar<T>;\n+    trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n+}\n+struct S;\n+impl foo::Foo<u32> for S { <|> }\",\n+            \"\n+mod foo {\n+    pub struct Bar<T>;\n+    trait Foo<T> { fn foo(&self, bar: Bar<T>); }\n+}\n+struct S;\n+impl foo::Foo<u32> for S {\n+    <|>fn foo(&self, bar: foo::Bar<u32>) { unimplemented!() }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_substitute_param_no_qualify() {\n+        // when substituting params, the substituted param should not be qualified!\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+mod foo {\n+    trait Foo<T> { fn foo(&self, bar: T); }\n+    pub struct Param;\n+}\n+struct Param;\n+struct S;\n+impl foo::Foo<Param> for S { <|> }\",\n+            \"\n+mod foo {\n+    trait Foo<T> { fn foo(&self, bar: T); }\n+    pub struct Param;\n+}\n+struct Param;\n+struct S;\n+impl foo::Foo<Param> for S {\n+    <|>fn foo(&self, bar: Param) { unimplemented!() }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_qualify_path_associated_item() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+mod foo {\n+    pub struct Bar<T>;\n+    impl Bar<T> { type Assoc = u32; }\n+    trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n+}\n+struct S;\n+impl foo::Foo for S { <|> }\",\n+            \"\n+mod foo {\n+    pub struct Bar<T>;\n+    impl Bar<T> { type Assoc = u32; }\n+    trait Foo { fn foo(&self, bar: Bar<u32>::Assoc); }\n+}\n+struct S;\n+impl foo::Foo for S {\n+    <|>fn foo(&self, bar: foo::Bar<u32>::Assoc) { unimplemented!() }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_qualify_path_nested() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+mod foo {\n+    pub struct Bar<T>;\n+    pub struct Baz;\n+    trait Foo { fn foo(&self, bar: Bar<Baz>); }\n+}\n+struct S;\n+impl foo::Foo for S { <|> }\",\n+            \"\n+mod foo {\n+    pub struct Bar<T>;\n+    pub struct Baz;\n+    trait Foo { fn foo(&self, bar: Bar<Baz>); }\n+}\n+struct S;\n+impl foo::Foo for S {\n+    <|>fn foo(&self, bar: foo::Bar<foo::Baz>) { unimplemented!() }\n+}\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_qualify_path_fn_trait_notation() {\n+        check_assist(\n+            add_missing_impl_members,\n+            \"\n+mod foo {\n+    pub trait Fn<Args> { type Output; }\n+    trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n+}\n+struct S;\n+impl foo::Foo for S { <|> }\",\n+            \"\n+mod foo {\n+    pub trait Fn<Args> { type Output; }\n+    trait Foo { fn foo(&self, bar: dyn Fn(u32) -> i32); }\n+}\n+struct S;\n+impl foo::Foo for S {\n+    <|>fn foo(&self, bar: dyn Fn(u32) -> i32) { unimplemented!() }\n+}\",\n+        );\n+    }\n+\n     #[test]\n     fn test_empty_trait() {\n         check_assist_not_applicable("}, {"sha": "cbddc50acb66ae4784020349abb0d8f8dea1a05e", "filename": "crates/ra_assists/src/ast_transform.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_transform.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -0,0 +1,179 @@\n+//! `AstTransformer`s are functions that replace nodes in an AST and can be easily combined.\n+use rustc_hash::FxHashMap;\n+\n+use hir::{db::HirDatabase, InFile, PathResolution};\n+use ra_syntax::ast::{self, make, AstNode};\n+\n+pub trait AstTransform<'a> {\n+    fn get_substitution(\n+        &self,\n+        node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode>;\n+\n+    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a>;\n+    fn or<T: AstTransform<'a> + 'a>(self, other: T) -> Box<dyn AstTransform<'a> + 'a>\n+    where\n+        Self: Sized + 'a,\n+    {\n+        self.chain_before(Box::new(other))\n+    }\n+}\n+\n+struct NullTransformer;\n+\n+impl<'a> AstTransform<'a> for NullTransformer {\n+    fn get_substitution(\n+        &self,\n+        _node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode> {\n+        None\n+    }\n+    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n+        other\n+    }\n+}\n+\n+pub struct SubstituteTypeParams<'a, DB: HirDatabase> {\n+    db: &'a DB,\n+    substs: FxHashMap<hir::TypeParam, ast::TypeRef>,\n+    previous: Box<dyn AstTransform<'a> + 'a>,\n+}\n+\n+impl<'a, DB: HirDatabase> SubstituteTypeParams<'a, DB> {\n+    pub fn for_trait_impl(\n+        db: &'a DB,\n+        trait_: hir::Trait,\n+        impl_block: ast::ImplBlock,\n+    ) -> SubstituteTypeParams<'a, DB> {\n+        let substs = get_syntactic_substs(impl_block).unwrap_or_default();\n+        let generic_def: hir::GenericDef = trait_.into();\n+        let substs_by_param: FxHashMap<_, _> = generic_def\n+            .params(db)\n+            .into_iter()\n+            // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n+            .skip(1)\n+            .zip(substs.into_iter())\n+            .collect();\n+        return SubstituteTypeParams {\n+            db,\n+            substs: substs_by_param,\n+            previous: Box::new(NullTransformer),\n+        };\n+\n+        // FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n+        // trait ref, and then go from the types in the substs back to the syntax)\n+        fn get_syntactic_substs(impl_block: ast::ImplBlock) -> Option<Vec<ast::TypeRef>> {\n+            let target_trait = impl_block.target_trait()?;\n+            let path_type = match target_trait {\n+                ast::TypeRef::PathType(path) => path,\n+                _ => return None,\n+            };\n+            let type_arg_list = path_type.path()?.segment()?.type_arg_list()?;\n+            let mut result = Vec::new();\n+            for type_arg in type_arg_list.type_args() {\n+                let type_arg: ast::TypeArg = type_arg;\n+                result.push(type_arg.type_ref()?);\n+            }\n+            Some(result)\n+        }\n+    }\n+    fn get_substitution_inner(\n+        &self,\n+        node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode> {\n+        let type_ref = ast::TypeRef::cast(node.value.clone())?;\n+        let path = match &type_ref {\n+            ast::TypeRef::PathType(path_type) => path_type.path()?,\n+            _ => return None,\n+        };\n+        let analyzer = hir::SourceAnalyzer::new(self.db, node, None);\n+        let resolution = analyzer.resolve_path(self.db, &path)?;\n+        match resolution {\n+            hir::PathResolution::TypeParam(tp) => Some(self.substs.get(&tp)?.syntax().clone()),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl<'a, DB: HirDatabase> AstTransform<'a> for SubstituteTypeParams<'a, DB> {\n+    fn get_substitution(\n+        &self,\n+        node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode> {\n+        self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))\n+    }\n+    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n+        Box::new(SubstituteTypeParams { previous: other, ..self })\n+    }\n+}\n+\n+pub struct QualifyPaths<'a, DB: HirDatabase> {\n+    db: &'a DB,\n+    from: Option<hir::Module>,\n+    previous: Box<dyn AstTransform<'a> + 'a>,\n+}\n+\n+impl<'a, DB: HirDatabase> QualifyPaths<'a, DB> {\n+    pub fn new(db: &'a DB, from: Option<hir::Module>) -> Self {\n+        Self { db, from, previous: Box::new(NullTransformer) }\n+    }\n+\n+    fn get_substitution_inner(\n+        &self,\n+        node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode> {\n+        // FIXME handle value ns?\n+        let from = self.from?;\n+        let p = ast::Path::cast(node.value.clone())?;\n+        if p.segment().and_then(|s| s.param_list()).is_some() {\n+            // don't try to qualify `Fn(Foo) -> Bar` paths, they are in prelude anyway\n+            return None;\n+        }\n+        let analyzer = hir::SourceAnalyzer::new(self.db, node, None);\n+        let resolution = analyzer.resolve_path(self.db, &p)?;\n+        match resolution {\n+            PathResolution::Def(def) => {\n+                let found_path = from.find_use_path(self.db, def)?;\n+                let args = p\n+                    .segment()\n+                    .and_then(|s| s.type_arg_list())\n+                    .map(|arg_list| apply(self, node.with_value(arg_list)));\n+                Some(make::path_with_type_arg_list(path_to_ast(found_path), args).syntax().clone())\n+            }\n+            PathResolution::Local(_)\n+            | PathResolution::TypeParam(_)\n+            | PathResolution::SelfType(_) => None,\n+            PathResolution::Macro(_) => None,\n+            PathResolution::AssocItem(_) => None,\n+        }\n+    }\n+}\n+\n+pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: InFile<N>) -> N {\n+    let syntax = node.value.syntax();\n+    let result = ra_syntax::algo::replace_descendants(syntax, &|element| match element {\n+        ra_syntax::SyntaxElement::Node(n) => {\n+            let replacement = transformer.get_substitution(node.with_value(&n))?;\n+            Some(replacement.into())\n+        }\n+        _ => None,\n+    });\n+    N::cast(result).unwrap()\n+}\n+\n+impl<'a, DB: HirDatabase> AstTransform<'a> for QualifyPaths<'a, DB> {\n+    fn get_substitution(\n+        &self,\n+        node: InFile<&ra_syntax::SyntaxNode>,\n+    ) -> Option<ra_syntax::SyntaxNode> {\n+        self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))\n+    }\n+    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n+        Box::new(QualifyPaths { previous: other, ..self })\n+    }\n+}\n+\n+fn path_to_ast(path: hir::ModPath) -> ast::Path {\n+    let parse = ast::SourceFile::parse(&path.to_string());\n+    parse.tree().syntax().descendants().find_map(ast::Path::cast).unwrap()\n+}"}, {"sha": "712ff6f6a5f84daceb70029fd55e1d77d597fe54", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -11,6 +11,7 @@ mod marks;\n mod doc_tests;\n #[cfg(test)]\n mod test_db;\n+pub mod ast_transform;\n \n use hir::db::HirDatabase;\n use ra_db::FileRange;"}, {"sha": "df9c151e5aaec21d4bfcf48df58d1ec49d74831d", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -227,6 +227,21 @@ impl Module {\n     pub(crate) fn with_module_id(self, module_id: LocalModuleId) -> Module {\n         Module::new(self.krate(), module_id)\n     }\n+\n+    /// Finds a path that can be used to refer to the given item from within\n+    /// this module, if possible.\n+    pub fn find_use_path(\n+        self,\n+        db: &impl DefDatabase,\n+        item: ModuleDef,\n+    ) -> Option<hir_def::path::ModPath> {\n+        // FIXME expose namespace choice\n+        hir_def::find_path::find_path(\n+            db,\n+            hir_def::item_scope::ItemInNs::Types(item.into()),\n+            self.into(),\n+        )\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "c16c17072b7d5bc3664b5fe435dfdd2ae02b7918", "filename": "crates/ra_hir/src/from_id.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_id.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -91,6 +91,22 @@ impl From<ModuleDefId> for ModuleDef {\n     }\n }\n \n+impl From<ModuleDef> for ModuleDefId {\n+    fn from(id: ModuleDef) -> Self {\n+        match id {\n+            ModuleDef::Module(it) => ModuleDefId::ModuleId(it.into()),\n+            ModuleDef::Function(it) => ModuleDefId::FunctionId(it.into()),\n+            ModuleDef::Adt(it) => ModuleDefId::AdtId(it.into()),\n+            ModuleDef::EnumVariant(it) => ModuleDefId::EnumVariantId(it.into()),\n+            ModuleDef::Const(it) => ModuleDefId::ConstId(it.into()),\n+            ModuleDef::Static(it) => ModuleDefId::StaticId(it.into()),\n+            ModuleDef::Trait(it) => ModuleDefId::TraitId(it.into()),\n+            ModuleDef::TypeAlias(it) => ModuleDefId::TypeAliasId(it.into()),\n+            ModuleDef::BuiltinType(it) => ModuleDefId::BuiltinType(it),\n+        }\n+    }\n+}\n+\n impl From<DefWithBody> for DefWithBodyId {\n     fn from(def: DefWithBody) -> Self {\n         match def {"}, {"sha": "a2a9d968cb4c79a9f7c412d957ed4e9c5fc3564e", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -205,6 +205,10 @@ impl SourceAnalyzer {\n         }\n     }\n \n+    pub fn module(&self) -> Option<crate::code_model::Module> {\n+        Some(crate::code_model::Module { id: self.resolver.module()? })\n+    }\n+\n     fn expr_id(&self, expr: &ast::Expr) -> Option<ExprId> {\n         let src = InFile { file_id: self.file_id, value: expr };\n         self.body_source_map.as_ref()?.node_expr(src)"}, {"sha": "f7dc8acb7f37b7c79bd3102c6d4f74a200b09e00", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "added", "additions": 455, "deletions": 0, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -0,0 +1,455 @@\n+//! An algorithm to find a path to refer to a certain item.\n+\n+use crate::{\n+    db::DefDatabase,\n+    item_scope::ItemInNs,\n+    path::{ModPath, PathKind},\n+    visibility::Visibility,\n+    CrateId, ModuleDefId, ModuleId,\n+};\n+use hir_expand::name::Name;\n+\n+const MAX_PATH_LEN: usize = 15;\n+\n+// FIXME: handle local items\n+\n+/// Find a path that can be used to refer to a certain item. This can depend on\n+/// *from where* you're referring to the item, hence the `from` parameter.\n+pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n+    find_path_inner(db, item, from, MAX_PATH_LEN)\n+}\n+\n+fn find_path_inner(\n+    db: &impl DefDatabase,\n+    item: ItemInNs,\n+    from: ModuleId,\n+    max_len: usize,\n+) -> Option<ModPath> {\n+    if max_len == 0 {\n+        return None;\n+    }\n+\n+    // Base cases:\n+\n+    // - if the item is already in scope, return the name under which it is\n+    let def_map = db.crate_def_map(from.krate);\n+    let from_scope: &crate::item_scope::ItemScope = &def_map.modules[from.local_id].scope;\n+    if let Some((name, _)) = from_scope.name_of(item) {\n+        return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+    }\n+\n+    // - if the item is the crate root, return `crate`\n+    if item\n+        == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n+            krate: from.krate,\n+            local_id: def_map.root,\n+        }))\n+    {\n+        return Some(ModPath::from_simple_segments(PathKind::Crate, Vec::new()));\n+    }\n+\n+    // - if the item is the module we're in, use `self`\n+    if item == ItemInNs::Types(from.into()) {\n+        return Some(ModPath::from_simple_segments(PathKind::Super(0), Vec::new()));\n+    }\n+\n+    // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n+    if let Some(parent_id) = def_map.modules[from.local_id].parent {\n+        if item\n+            == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId {\n+                krate: from.krate,\n+                local_id: parent_id,\n+            }))\n+        {\n+            return Some(ModPath::from_simple_segments(PathKind::Super(1), Vec::new()));\n+        }\n+    }\n+\n+    // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n+    for (name, def_id) in &def_map.extern_prelude {\n+        if item == ItemInNs::Types(*def_id) {\n+            return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+        }\n+    }\n+\n+    // - if the item is in the prelude, return the name from there\n+    if let Some(prelude_module) = def_map.prelude {\n+        let prelude_def_map = db.crate_def_map(prelude_module.krate);\n+        let prelude_scope: &crate::item_scope::ItemScope =\n+            &prelude_def_map.modules[prelude_module.local_id].scope;\n+        if let Some((name, vis)) = prelude_scope.name_of(item) {\n+            if vis.is_visible_from(db, from) {\n+                return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+            }\n+        }\n+    }\n+\n+    // Recursive case:\n+    // - if the item is an enum variant, refer to it via the enum\n+    if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n+        if let Some(mut path) = find_path(db, ItemInNs::Types(variant.parent.into()), from) {\n+            let data = db.enum_data(variant.parent);\n+            path.segments.push(data.variants[variant.local_id].name.clone());\n+            return Some(path);\n+        }\n+        // If this doesn't work, it seems we have no way of referring to the\n+        // enum; that's very weird, but there might still be a reexport of the\n+        // variant somewhere\n+    }\n+\n+    // - otherwise, look for modules containing (reexporting) it and import it from one of those\n+    let importable_locations = find_importable_locations(db, item, from);\n+    let mut best_path = None;\n+    let mut best_path_len = max_len;\n+    for (module_id, name) in importable_locations {\n+        let mut path = match find_path_inner(\n+            db,\n+            ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n+            from,\n+            best_path_len - 1,\n+        ) {\n+            None => continue,\n+            Some(path) => path,\n+        };\n+        path.segments.push(name);\n+        if path_len(&path) < best_path_len {\n+            best_path_len = path_len(&path);\n+            best_path = Some(path);\n+        }\n+    }\n+    best_path\n+}\n+\n+fn path_len(path: &ModPath) -> usize {\n+    path.segments.len()\n+        + match path.kind {\n+            PathKind::Plain => 0,\n+            PathKind::Super(i) => i as usize,\n+            PathKind::Crate => 1,\n+            PathKind::Abs => 0,\n+            PathKind::DollarCrate(_) => 1,\n+        }\n+}\n+\n+fn find_importable_locations(\n+    db: &impl DefDatabase,\n+    item: ItemInNs,\n+    from: ModuleId,\n+) -> Vec<(ModuleId, Name)> {\n+    let crate_graph = db.crate_graph();\n+    let mut result = Vec::new();\n+    // We only look in the crate from which we are importing, and the direct\n+    // dependencies. We cannot refer to names from transitive dependencies\n+    // directly (only through reexports in direct dependencies).\n+    for krate in Some(from.krate)\n+        .into_iter()\n+        .chain(crate_graph.dependencies(from.krate).map(|dep| dep.crate_id))\n+    {\n+        result.extend(\n+            importable_locations_in_crate(db, item, krate)\n+                .iter()\n+                .filter(|(_, _, vis)| vis.is_visible_from(db, from))\n+                .map(|(m, n, _)| (*m, n.clone())),\n+        );\n+    }\n+    result\n+}\n+\n+/// Collects all locations from which we might import the item in a particular\n+/// crate. These include the original definition of the item, and any\n+/// non-private `use`s.\n+///\n+/// Note that the crate doesn't need to be the one in which the item is defined;\n+/// it might be re-exported in other crates.\n+fn importable_locations_in_crate(\n+    db: &impl DefDatabase,\n+    item: ItemInNs,\n+    krate: CrateId,\n+) -> Vec<(ModuleId, Name, Visibility)> {\n+    let def_map = db.crate_def_map(krate);\n+    let mut result = Vec::new();\n+    for (local_id, data) in def_map.modules.iter() {\n+        if let Some((name, vis)) = data.scope.name_of(item) {\n+            let is_private = if let Visibility::Module(private_to) = vis {\n+                private_to.local_id == local_id\n+            } else {\n+                false\n+            };\n+            let is_original_def = if let Some(module_def_id) = item.as_module_def_id() {\n+                data.scope.declarations().any(|it| it == module_def_id)\n+            } else {\n+                false\n+            };\n+            if is_private && !is_original_def {\n+                // Ignore private imports. these could be used if we are\n+                // in a submodule of this module, but that's usually not\n+                // what the user wants; and if this module can import\n+                // the item and we're a submodule of it, so can we.\n+                // Also this keeps the cached data smaller.\n+                continue;\n+            }\n+            result.push((ModuleId { krate, local_id }, name.clone(), vis));\n+        }\n+    }\n+    result\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::test_db::TestDB;\n+    use hir_expand::hygiene::Hygiene;\n+    use ra_db::fixture::WithFixture;\n+    use ra_syntax::ast::AstNode;\n+\n+    /// `code` needs to contain a cursor marker; checks that `find_path` for the\n+    /// item the `path` refers to returns that same path when called from the\n+    /// module the cursor is in.\n+    fn check_found_path(code: &str, path: &str) {\n+        let (db, pos) = TestDB::with_position(code);\n+        let module = db.module_for_file(pos.file_id);\n+        let parsed_path_file = ra_syntax::SourceFile::parse(&format!(\"use {};\", path));\n+        let ast_path = parsed_path_file\n+            .syntax_node()\n+            .descendants()\n+            .find_map(ra_syntax::ast::Path::cast)\n+            .unwrap();\n+        let mod_path = ModPath::from_src(ast_path, &Hygiene::new_unhygienic()).unwrap();\n+\n+        let crate_def_map = db.crate_def_map(module.krate);\n+        let resolved = crate_def_map\n+            .resolve_path(\n+                &db,\n+                module.local_id,\n+                &mod_path,\n+                crate::item_scope::BuiltinShadowMode::Module,\n+            )\n+            .0\n+            .take_types()\n+            .unwrap();\n+\n+        let found_path = find_path(&db, ItemInNs::Types(resolved), module);\n+\n+        assert_eq!(found_path, Some(mod_path));\n+    }\n+\n+    #[test]\n+    fn same_module() {\n+        let code = r#\"\n+            //- /main.rs\n+            struct S;\n+            <|>\n+        \"#;\n+        check_found_path(code, \"S\");\n+    }\n+\n+    #[test]\n+    fn enum_variant() {\n+        let code = r#\"\n+            //- /main.rs\n+            enum E { A }\n+            <|>\n+        \"#;\n+        check_found_path(code, \"E::A\");\n+    }\n+\n+    #[test]\n+    fn sub_module() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo {\n+                pub struct S;\n+            }\n+            <|>\n+        \"#;\n+        check_found_path(code, \"foo::S\");\n+    }\n+\n+    #[test]\n+    fn super_module() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo;\n+            //- /foo.rs\n+            mod bar;\n+            struct S;\n+            //- /foo/bar.rs\n+            <|>\n+        \"#;\n+        check_found_path(code, \"super::S\");\n+    }\n+\n+    #[test]\n+    fn self_module() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo;\n+            //- /foo.rs\n+            <|>\n+        \"#;\n+        check_found_path(code, \"self\");\n+    }\n+\n+    #[test]\n+    fn crate_root() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo;\n+            //- /foo.rs\n+            <|>\n+        \"#;\n+        check_found_path(code, \"crate\");\n+    }\n+\n+    #[test]\n+    fn same_crate() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo;\n+            struct S;\n+            //- /foo.rs\n+            <|>\n+        \"#;\n+        check_found_path(code, \"crate::S\");\n+    }\n+\n+    #[test]\n+    fn different_crate() {\n+        let code = r#\"\n+            //- /main.rs crate:main deps:std\n+            <|>\n+            //- /std.rs crate:std\n+            pub struct S;\n+        \"#;\n+        check_found_path(code, \"std::S\");\n+    }\n+\n+    #[test]\n+    fn different_crate_renamed() {\n+        let code = r#\"\n+            //- /main.rs crate:main deps:std\n+            extern crate std as std_renamed;\n+            <|>\n+            //- /std.rs crate:std\n+            pub struct S;\n+        \"#;\n+        check_found_path(code, \"std_renamed::S\");\n+    }\n+\n+    #[test]\n+    fn same_crate_reexport() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod bar {\n+                mod foo { pub(super) struct S; }\n+                pub(crate) use foo::*;\n+            }\n+            <|>\n+        \"#;\n+        check_found_path(code, \"bar::S\");\n+    }\n+\n+    #[test]\n+    fn same_crate_reexport_rename() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod bar {\n+                mod foo { pub(super) struct S; }\n+                pub(crate) use foo::S as U;\n+            }\n+            <|>\n+        \"#;\n+        check_found_path(code, \"bar::U\");\n+    }\n+\n+    #[test]\n+    fn different_crate_reexport() {\n+        let code = r#\"\n+            //- /main.rs crate:main deps:std\n+            <|>\n+            //- /std.rs crate:std deps:core\n+            pub use core::S;\n+            //- /core.rs crate:core\n+            pub struct S;\n+        \"#;\n+        check_found_path(code, \"std::S\");\n+    }\n+\n+    #[test]\n+    fn prelude() {\n+        let code = r#\"\n+            //- /main.rs crate:main deps:std\n+            <|>\n+            //- /std.rs crate:std\n+            pub mod prelude { pub struct S; }\n+            #[prelude_import]\n+            pub use prelude::*;\n+        \"#;\n+        check_found_path(code, \"S\");\n+    }\n+\n+    #[test]\n+    fn enum_variant_from_prelude() {\n+        let code = r#\"\n+            //- /main.rs crate:main deps:std\n+            <|>\n+            //- /std.rs crate:std\n+            pub mod prelude {\n+                pub enum Option<T> { Some(T), None }\n+                pub use Option::*;\n+            }\n+            #[prelude_import]\n+            pub use prelude::*;\n+        \"#;\n+        check_found_path(code, \"None\");\n+        check_found_path(code, \"Some\");\n+    }\n+\n+    #[test]\n+    fn shortest_path() {\n+        let code = r#\"\n+            //- /main.rs\n+            pub mod foo;\n+            pub mod baz;\n+            struct S;\n+            <|>\n+            //- /foo.rs\n+            pub mod bar { pub struct S; }\n+            //- /baz.rs\n+            pub use crate::foo::bar::S;\n+        \"#;\n+        check_found_path(code, \"baz::S\");\n+    }\n+\n+    #[test]\n+    fn discount_private_imports() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo;\n+            pub mod bar { pub struct S; }\n+            use bar::S;\n+            //- /foo.rs\n+            <|>\n+        \"#;\n+        // crate::S would be shorter, but using private imports seems wrong\n+        check_found_path(code, \"crate::bar::S\");\n+    }\n+\n+    #[test]\n+    fn import_cycle() {\n+        let code = r#\"\n+            //- /main.rs\n+            pub mod foo;\n+            pub mod bar;\n+            pub mod baz;\n+            //- /bar.rs\n+            <|>\n+            //- /foo.rs\n+            pub use super::baz;\n+            pub struct S;\n+            //- /baz.rs\n+            pub use super::foo;\n+        \"#;\n+        check_found_path(code, \"crate::foo::S\");\n+    }\n+}"}, {"sha": "d74a1cef2157c74de6b3ba42f0071dda07e7e9e3", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -104,6 +104,15 @@ impl ItemScope {\n         }\n     }\n \n+    pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility)> {\n+        for (name, per_ns) in &self.visible {\n+            if let Some(vis) = item.match_with(*per_ns) {\n+                return Some((name, vis));\n+            }\n+        }\n+        None\n+    }\n+\n     pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n         self.visible.values().filter_map(|def| match def.take_types() {\n             Some(ModuleDefId::TraitId(t)) => Some(t),\n@@ -173,3 +182,33 @@ impl PerNs {\n         }\n     }\n }\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n+pub enum ItemInNs {\n+    Types(ModuleDefId),\n+    Values(ModuleDefId),\n+    Macros(MacroDefId),\n+}\n+\n+impl ItemInNs {\n+    fn match_with(self, per_ns: PerNs) -> Option<Visibility> {\n+        match self {\n+            ItemInNs::Types(def) => {\n+                per_ns.types.filter(|(other_def, _)| *other_def == def).map(|(_, vis)| vis)\n+            }\n+            ItemInNs::Values(def) => {\n+                per_ns.values.filter(|(other_def, _)| *other_def == def).map(|(_, vis)| vis)\n+            }\n+            ItemInNs::Macros(def) => {\n+                per_ns.macros.filter(|(other_def, _)| *other_def == def).map(|(_, vis)| vis)\n+            }\n+        }\n+    }\n+\n+    pub fn as_module_def_id(self) -> Option<ModuleDefId> {\n+        match self {\n+            ItemInNs::Types(id) | ItemInNs::Values(id) => Some(id),\n+            ItemInNs::Macros(_) => None,\n+        }\n+    }\n+}"}, {"sha": "ebc12e891d77d5d637b200eb82cc2f25366dd924", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -37,6 +37,7 @@ pub mod src;\n pub mod child_by_source;\n \n pub mod visibility;\n+pub mod find_path;\n \n #[cfg(test)]\n mod test_db;"}, {"sha": "9f93a54244ddad43ad99d58d58aea2ae84884ed7", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -1,7 +1,11 @@\n //! A desugared representation of paths like `crate::foo` or `<Type as Trait>::bar`.\n mod lower;\n \n-use std::{iter, sync::Arc};\n+use std::{\n+    fmt::{self, Display},\n+    iter,\n+    sync::Arc,\n+};\n \n use hir_expand::{\n     hygiene::Hygiene,\n@@ -248,6 +252,42 @@ impl From<Name> for ModPath {\n     }\n }\n \n+impl Display for ModPath {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut first_segment = true;\n+        let mut add_segment = |s| {\n+            if !first_segment {\n+                f.write_str(\"::\")?;\n+            }\n+            first_segment = false;\n+            f.write_str(s)?;\n+            Ok(())\n+        };\n+        match self.kind {\n+            PathKind::Plain => {}\n+            PathKind::Super(n) => {\n+                if n == 0 {\n+                    add_segment(\"self\")?;\n+                }\n+                for _ in 0..n {\n+                    add_segment(\"super\")?;\n+                }\n+            }\n+            PathKind::Crate => add_segment(\"crate\")?,\n+            PathKind::Abs => add_segment(\"\")?,\n+            PathKind::DollarCrate(_) => add_segment(\"$crate\")?,\n+        }\n+        for segment in &self.segments {\n+            if !first_segment {\n+                f.write_str(\"::\")?;\n+            }\n+            first_segment = false;\n+            write!(f, \"{}\", segment)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n pub use hir_expand::name as __name;\n \n #[macro_export]"}, {"sha": "f7bac580112b31be61c5c92c63e9945ee8cada16", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -128,7 +128,7 @@ impl Resolver {\n         path: &ModPath,\n         shadow: BuiltinShadowMode,\n     ) -> PerNs {\n-        let (item_map, module) = match self.module() {\n+        let (item_map, module) = match self.module_scope() {\n             Some(it) => it,\n             None => return PerNs::none(),\n         };\n@@ -239,7 +239,7 @@ impl Resolver {\n     ) -> Option<Visibility> {\n         match visibility {\n             RawVisibility::Module(_) => {\n-                let (item_map, module) = match self.module() {\n+                let (item_map, module) = match self.module_scope() {\n                     Some(it) => it,\n                     None => return None,\n                 };\n@@ -379,7 +379,7 @@ impl Resolver {\n         db: &impl DefDatabase,\n         path: &ModPath,\n     ) -> Option<MacroDefId> {\n-        let (item_map, module) = self.module()?;\n+        let (item_map, module) = self.module_scope()?;\n         item_map.resolve_path(db, module, &path, BuiltinShadowMode::Other).0.take_macros()\n     }\n \n@@ -403,16 +403,21 @@ impl Resolver {\n         traits\n     }\n \n-    fn module(&self) -> Option<(&CrateDefMap, LocalModuleId)> {\n+    fn module_scope(&self) -> Option<(&CrateDefMap, LocalModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),\n \n             _ => None,\n         })\n     }\n \n+    pub fn module(&self) -> Option<ModuleId> {\n+        let (def_map, local_id) = self.module_scope()?;\n+        Some(ModuleId { krate: def_map.krate, local_id })\n+    }\n+\n     pub fn krate(&self) -> Option<CrateId> {\n-        self.module().map(|t| t.0.krate)\n+        self.module_scope().map(|t| t.0.krate)\n     }\n \n     pub fn where_predicates_in_scope<'a>("}, {"sha": "1568820e9afac8ef54937c80d59d65da8a672f8f", "filename": "crates/ra_hir_def/src/test_db.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -5,6 +5,7 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n+use crate::db::DefDatabase;\n use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath};\n \n #[salsa::database(\n@@ -54,6 +55,18 @@ impl FileLoader for TestDB {\n }\n \n impl TestDB {\n+    pub fn module_for_file(&self, file_id: FileId) -> crate::ModuleId {\n+        for &krate in self.relevant_crates(file_id).iter() {\n+            let crate_def_map = self.crate_def_map(krate);\n+            for (local_id, data) in crate_def_map.modules.iter() {\n+                if data.origin.file_id() == Some(file_id) {\n+                    return crate::ModuleId { krate, local_id };\n+                }\n+            }\n+        }\n+        panic!(\"Can't find module for file\")\n+    }\n+\n     pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<TestDB>> {\n         *self.events.lock().unwrap() = Some(Vec::new());\n         f();"}, {"sha": "51c5f9623c2e11e34ce17ac662e2b427838fdf1d", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -322,3 +322,13 @@ impl InFile<SyntaxNode> {\n         })\n     }\n }\n+\n+impl<N: AstNode> InFile<N> {\n+    pub fn descendants<T: AstNode>(self) -> impl Iterator<Item = InFile<T>> {\n+        self.value.syntax().descendants().filter_map(T::cast).map(move |n| self.with_value(n))\n+    }\n+\n+    pub fn syntax(&self) -> InFile<&SyntaxNode> {\n+        self.with_value(self.value.syntax())\n+    }\n+}"}, {"sha": "0f7b6e875f7dc86ae78514df9df4c9dc0d9ceef6", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -7,8 +7,7 @@ use rustc_hash::FxHashMap;\n \n use ra_syntax::{\n     algo::{find_node_at_offset, replace_descendants},\n-    ast::{self},\n-    AstNode, NodeOrToken, SyntaxKind, SyntaxNode, WalkEvent, T,\n+    ast, AstNode, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode, WalkEvent, T,\n };\n \n pub struct ExpandedMacro {\n@@ -43,7 +42,7 @@ fn expand_macro_recur(\n     let mut expanded: SyntaxNode = db.parse_or_expand(macro_file_id)?;\n \n     let children = expanded.descendants().filter_map(ast::MacroCall::cast);\n-    let mut replaces = FxHashMap::default();\n+    let mut replaces: FxHashMap<SyntaxElement, SyntaxElement> = FxHashMap::default();\n \n     for child in children.into_iter() {\n         let node = hir::InFile::new(macro_file_id, &child);\n@@ -59,7 +58,7 @@ fn expand_macro_recur(\n         }\n     }\n \n-    Some(replace_descendants(&expanded, &replaces))\n+    Some(replace_descendants(&expanded, &|n| replaces.get(n).cloned()))\n }\n \n // FIXME: It would also be cool to share logic here and in the mbe tests,"}, {"sha": "30a479f015fcbd838fb17bb62436dc063de9f697", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -184,17 +184,17 @@ pub fn replace_children(\n /// to create a type-safe abstraction on top of it instead.\n pub fn replace_descendants(\n     parent: &SyntaxNode,\n-    map: &FxHashMap<SyntaxElement, SyntaxElement>,\n+    map: &impl Fn(&SyntaxElement) -> Option<SyntaxElement>,\n ) -> SyntaxNode {\n     //  FIXME: this could be made much faster.\n     let new_children = parent.children_with_tokens().map(|it| go(map, it)).collect::<Vec<_>>();\n     return with_children(parent, new_children);\n \n     fn go(\n-        map: &FxHashMap<SyntaxElement, SyntaxElement>,\n+        map: &impl Fn(&SyntaxElement) -> Option<SyntaxElement>,\n         element: SyntaxElement,\n     ) -> NodeOrToken<rowan::GreenNode, rowan::GreenToken> {\n-        if let Some(replacement) = map.get(&element) {\n+        if let Some(replacement) = map(&element) {\n             return match replacement {\n                 NodeOrToken::Node(it) => NodeOrToken::Node(it.green().clone()),\n                 NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),"}, {"sha": "b736098acc0852616ea43ca1f9cf893ee21ac1f0", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -236,8 +236,8 @@ pub fn replace_descendants<N: AstNode, D: AstNode>(\n ) -> N {\n     let map = replacement_map\n         .map(|(from, to)| (from.syntax().clone().into(), to.syntax().clone().into()))\n-        .collect::<FxHashMap<_, _>>();\n-    let new_syntax = algo::replace_descendants(parent.syntax(), &map);\n+        .collect::<FxHashMap<SyntaxElement, _>>();\n+    let new_syntax = algo::replace_descendants(parent.syntax(), &|n| map.get(n).cloned());\n     N::cast(new_syntax).unwrap()\n }\n \n@@ -292,7 +292,7 @@ impl IndentLevel {\n                 )\n             })\n             .collect();\n-        algo::replace_descendants(&node, &replacements)\n+        algo::replace_descendants(&node, &|n| replacements.get(n).cloned())\n     }\n \n     pub fn decrease_indent<N: AstNode>(self, node: N) -> N {\n@@ -320,7 +320,7 @@ impl IndentLevel {\n                 )\n             })\n             .collect();\n-        algo::replace_descendants(&node, &replacements)\n+        algo::replace_descendants(&node, &|n| replacements.get(n).cloned())\n     }\n }\n "}, {"sha": "9781b748f1db028efed90d73c667d79d9f6c056b", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd297f4910bbf2305ec859d7cf42b7dca25f57/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=bcfd297f4910bbf2305ec859d7cf42b7dca25f57", "patch": "@@ -2,7 +2,7 @@\n //! of smaller pieces.\n use itertools::Itertools;\n \n-use crate::{ast, AstNode, SourceFile};\n+use crate::{algo, ast, AstNode, SourceFile};\n \n pub fn name(text: &str) -> ast::Name {\n     ast_from_text(&format!(\"mod {};\", text))\n@@ -21,6 +21,20 @@ pub fn path_qualified(qual: ast::Path, name_ref: ast::NameRef) -> ast::Path {\n fn path_from_text(text: &str) -> ast::Path {\n     ast_from_text(text)\n }\n+pub fn path_with_type_arg_list(path: ast::Path, args: Option<ast::TypeArgList>) -> ast::Path {\n+    if let Some(args) = args {\n+        let syntax = path.syntax();\n+        // FIXME: remove existing type args\n+        let new_syntax = algo::insert_children(\n+            syntax,\n+            crate::algo::InsertPosition::Last,\n+            &mut Some(args).into_iter().map(|n| n.syntax().clone().into()),\n+        );\n+        ast::Path::cast(new_syntax).unwrap()\n+    } else {\n+        path\n+    }\n+}\n \n pub fn record_field(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordField {\n     return match expr {"}]}