{"sha": "47a11cd5166a605897beb678095d17abc66c136f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YTExY2Q1MTY2YTYwNTg5N2JlYjY3ODA5NWQxN2FiYzY2YzEzNmY=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-06-09T00:20:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-09T00:20:39Z"}, "message": "Format modules defined in cfg_attr (#3604)", "tree": {"sha": "8df1a7591ad29704fe9bbe062e156e6ba14bac72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8df1a7591ad29704fe9bbe062e156e6ba14bac72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47a11cd5166a605897beb678095d17abc66c136f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc/FDXCRBK7hj4Ov3rIwAAdHIIAD6HhfXSQtc+x1qVkj+Btlg/\n29IjvJ/rd8/GHqvwY0ull1PVzk1ODTqCYih6IE6+2CFytwglq/Wgg1K7cAwaALnb\nmILuLycgcdavcTnfEAA//S0/BDWaVRMDa7UYRmNbelaNrBBTzJ3gQShsiYDD20hL\nPBsMA2ga6CWpees71M860a/WDaCGpZ1X1hC83YbaJiF2x5X7RMYZIFvrzVAetzsc\nblcH5Lv6fQ6lKtfea97JZAqj566ZsJrPviFsXenS1znRZzS+9cp/qW3ZONJIddzI\nOFuV0/RAanqjOP4RT1556jgtmv9NCWLxfjOtWQ2FkbjEiYol05Pa8v9mMN6I8Hc=\n=lf+o\n-----END PGP SIGNATURE-----\n", "payload": "tree 8df1a7591ad29704fe9bbe062e156e6ba14bac72\nparent e71bffb0080e53a11078e6279f0bb1e470c452e0\nauthor Seiichi Uchida <seuchida@gmail.com> 1560039639 +0900\ncommitter GitHub <noreply@github.com> 1560039639 +0900\n\nFormat modules defined in cfg_attr (#3604)\n\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47a11cd5166a605897beb678095d17abc66c136f", "html_url": "https://github.com/rust-lang/rust/commit/47a11cd5166a605897beb678095d17abc66c136f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47a11cd5166a605897beb678095d17abc66c136f/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e71bffb0080e53a11078e6279f0bb1e470c452e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e71bffb0080e53a11078e6279f0bb1e470c452e0", "html_url": "https://github.com/rust-lang/rust/commit/e71bffb0080e53a11078e6279f0bb1e470c452e0"}], "stats": {"total": 481, "additions": 415, "deletions": 66}, "files": [{"sha": "8497917ab06cf3e85414b2d84ec8133f74b8fca4", "filename": "src/attr.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -488,3 +488,36 @@ fn attr_prefix(attr: &ast::Attribute) -> &'static str {\n         ast::AttrStyle::Outer => \"#\",\n     }\n }\n+\n+pub(crate) trait MetaVisitor<'ast> {\n+    fn visit_meta_item(&mut self, meta_item: &'ast ast::MetaItem) {\n+        match meta_item.node {\n+            ast::MetaItemKind::Word => self.visit_meta_word(meta_item),\n+            ast::MetaItemKind::List(ref list) => self.visit_meta_list(meta_item, list),\n+            ast::MetaItemKind::NameValue(ref lit) => self.visit_meta_name_value(meta_item, lit),\n+        }\n+    }\n+\n+    fn visit_meta_list(\n+        &mut self,\n+        _meta_item: &'ast ast::MetaItem,\n+        list: &'ast [ast::NestedMetaItem],\n+    ) {\n+        for nm in list {\n+            self.visit_nested_meta_item(nm);\n+        }\n+    }\n+\n+    fn visit_meta_word(&mut self, _meta_item: &'ast ast::MetaItem) {}\n+\n+    fn visit_meta_name_value(&mut self, _meta_item: &'ast ast::MetaItem, _lit: &'ast ast::Lit) {}\n+\n+    fn visit_nested_meta_item(&mut self, nm: &'ast ast::NestedMetaItem) {\n+        match nm {\n+            ast::NestedMetaItem::MetaItem(ref meta_item) => self.visit_meta_item(meta_item),\n+            ast::NestedMetaItem::Literal(ref lit) => self.visit_literal(lit),\n+        }\n+    }\n+\n+    fn visit_literal(&mut self, _lit: &'ast ast::Lit) {}\n+}"}, {"sha": "d431dd2679c3785d163872cbdce4f0d9c3e32580", "filename": "src/formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -105,7 +105,7 @@ fn format_project<T: FormatHandler>(\n     )\n     .visit_crate(&krate)\n     .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n-    for (path, (module, _)) in files {\n+    for (path, module) in files {\n         let should_ignore = !input_is_stdin && ignore_path_set.is_match(&path);\n         if (config.skip_children() && path != main_file) || should_ignore {\n             continue;"}, {"sha": "18b91add17ba2c0e220beb94ce967f00bbbe0c39", "filename": "src/modules.rs", "status": "modified", "additions": 275, "deletions": 65, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -3,19 +3,23 @@ use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n \n use syntax::ast;\n-use syntax::parse::{parser, DirectoryOwnership, ParseSess};\n-use syntax::source_map;\n+use syntax::attr;\n+use syntax::parse::{\n+    new_sub_parser_from_file, parser, token, DirectoryOwnership, PResult, ParseSess,\n+};\n+use syntax::source_map::{self, Span};\n use syntax::symbol::sym;\n use syntax::visit::Visitor;\n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::{self, symbol::Symbol, DUMMY_SP};\n \n+use crate::attr::MetaVisitor;\n use crate::config::FileName;\n use crate::items::is_mod_decl;\n use crate::utils::contains_skip;\n \n mod visitor;\n \n-type FileModMap<'ast> = BTreeMap<FileName, (Cow<'ast, ast::Mod>, String)>;\n+type FileModMap<'ast> = BTreeMap<FileName, Cow<'ast, ast::Mod>>;\n \n /// Maps each module to the corresponding file.\n pub(crate) struct ModResolver<'ast, 'sess> {\n@@ -40,13 +44,16 @@ impl<'a> Directory {\n     }\n }\n \n-enum SubModKind {\n+#[derive(Clone)]\n+enum SubModKind<'a, 'ast> {\n     /// `mod foo;`\n     External(PathBuf, DirectoryOwnership),\n+    /// `mod foo;` with multiple sources.\n+    MultiExternal(Vec<(PathBuf, DirectoryOwnership, Cow<'ast, ast::Mod>)>),\n     /// `#[path = \"...\"] mod foo {}`\n     InternalWithPath(PathBuf),\n     /// `mod foo {}`\n-    Internal,\n+    Internal(&'a ast::Item),\n }\n \n impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n@@ -86,64 +93,48 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             self.visit_mod_from_ast(&krate.module)?;\n         }\n \n-        self.file_map.insert(\n-            root_filename.into(),\n-            (Cow::Borrowed(&krate.module), String::new()),\n-        );\n+        self.file_map\n+            .insert(root_filename.into(), Cow::Borrowed(&krate.module));\n         Ok(self.file_map)\n     }\n \n-    /// Visit macro calls and look for module declarations. Currently only supports `cfg_if` macro.\n-    fn visit_mac(&mut self, item: Cow<'ast, ast::Item>) -> Result<(), String> {\n+    /// Visit `cfg_if` macro and look for module declarations.\n+    fn visit_cfg_if(&mut self, item: Cow<'ast, ast::Item>) -> Result<(), String> {\n         let mut visitor =\n             visitor::CfgIfVisitor::new(self.parse_sess, self.directory.to_syntax_directory());\n         visitor.visit_item(&item);\n         for module_item in visitor.mods() {\n             if let ast::ItemKind::Mod(ref sub_mod) = module_item.item.node {\n-                self.visit_mod_from_mac_inner(&item, Cow::Owned(sub_mod.clone()))?;\n+                self.visit_sub_mod(&item, Cow::Owned(sub_mod.clone()))?;\n             }\n         }\n         Ok(())\n     }\n \n     /// Visit modules defined inside macro calls.\n-    fn visit_mod_from_macro(&mut self, module: Cow<'ast, ast::Mod>) -> Result<(), String> {\n-        for item in &module.items {\n-            if let ast::ItemKind::Mac(..) = item.node {\n-                self.visit_mac(Cow::Owned(item.clone().into_inner()))?;\n+    fn visit_mod_outside_ast(&mut self, module: ast::Mod) -> Result<(), String> {\n+        for item in module.items {\n+            if is_cfg_if(&item) {\n+                self.visit_cfg_if(Cow::Owned(item.into_inner()))?;\n+                continue;\n             }\n \n             if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n-                self.visit_mod_from_mac_inner(item, Cow::Owned(sub_mod.clone()))?;\n+                self.visit_sub_mod(&item, Cow::Owned(sub_mod.clone()))?;\n             }\n         }\n         Ok(())\n     }\n \n-    fn visit_mod_from_mac_inner(\n-        &mut self,\n-        item: &'c ast::Item,\n-        sub_mod: Cow<'ast, ast::Mod>,\n-    ) -> Result<(), String> {\n-        let old_directory = self.directory.clone();\n-        self.visit_sub_mod(item, &sub_mod)?;\n-        self.visit_mod_from_macro(sub_mod)?;\n-        self.directory = old_directory;\n-        Ok(())\n-    }\n-\n     /// Visit modules from AST.\n     fn visit_mod_from_ast(&mut self, module: &'ast ast::Mod) -> Result<(), String> {\n         for item in &module.items {\n-            if let ast::ItemKind::Mac(..) = item.node {\n-                self.visit_mac(Cow::Borrowed(item))?;\n+            if is_cfg_if(item) {\n+                self.visit_cfg_if(Cow::Borrowed(item))?;\n             }\n \n             if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n-                let old_directory = self.directory.clone();\n-                self.visit_sub_mod(item, &Cow::Borrowed(sub_mod))?;\n-                self.visit_mod_from_ast(sub_mod)?;\n-                self.directory = old_directory;\n+                self.visit_sub_mod(item, Cow::Borrowed(sub_mod))?;\n             }\n         }\n         Ok(())\n@@ -152,65 +143,134 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n     fn visit_sub_mod(\n         &mut self,\n         item: &'c ast::Item,\n-        sub_mod: &Cow<'ast, ast::Mod>,\n+        sub_mod: Cow<'ast, ast::Mod>,\n     ) -> Result<(), String> {\n-        match self.peek_sub_mod(item)? {\n-            Some(SubModKind::External(mod_path, directory_ownership)) => {\n-                self.file_map.insert(\n-                    FileName::Real(mod_path.clone()),\n-                    (sub_mod.clone(), item.ident.name.as_str().get().to_owned()),\n-                );\n-                self.directory = Directory {\n-                    path: mod_path.parent().unwrap().to_path_buf(),\n-                    ownership: directory_ownership,\n-                };\n-            }\n-            Some(SubModKind::InternalWithPath(mod_path)) => {\n-                // All `#[path]` files are treated as though they are a `mod.rs` file.\n-                self.directory = Directory {\n-                    path: mod_path,\n-                    ownership: DirectoryOwnership::Owned { relative: None },\n-                };\n-            }\n-            Some(SubModKind::Internal) => self.push_inline_mod_directory(item.ident, &item.attrs),\n-            None => (), // rustfmt::skip\n+        let old_directory = self.directory.clone();\n+        let sub_mod_kind = self.peek_sub_mod(item, &sub_mod)?;\n+        if let Some(sub_mod_kind) = sub_mod_kind {\n+            self.insert_sub_mod(sub_mod_kind.clone(), sub_mod.clone())?;\n+            self.visit_sub_mod_inner(sub_mod, sub_mod_kind)?;\n         }\n+        self.directory = old_directory;\n         Ok(())\n     }\n \n     /// Inspect the given sub-module which we are about to visit and returns its kind.\n-    fn peek_sub_mod(&self, item: &'c ast::Item) -> Result<Option<SubModKind>, String> {\n+    fn peek_sub_mod(\n+        &self,\n+        item: &'c ast::Item,\n+        sub_mod: &Cow<'ast, ast::Mod>,\n+    ) -> Result<Option<SubModKind<'c, 'ast>>, String> {\n         if contains_skip(&item.attrs) {\n             return Ok(None);\n         }\n \n         if is_mod_decl(item) {\n             // mod foo;\n             // Look for an extern file.\n-            let (mod_path, directory_ownership) =\n-                self.find_external_module(item.ident, &item.attrs)?;\n-            Ok(Some(SubModKind::External(mod_path, directory_ownership)))\n+            self.find_external_module(item.ident, &item.attrs, sub_mod)\n+                .map(Some)\n         } else {\n             // An internal module (`mod foo { /* ... */ }`);\n             if let Some(path) = find_path_value(&item.attrs) {\n                 let path = Path::new(&path.as_str()).to_path_buf();\n                 Ok(Some(SubModKind::InternalWithPath(path)))\n             } else {\n-                Ok(Some(SubModKind::Internal))\n+                Ok(Some(SubModKind::Internal(item)))\n             }\n         }\n     }\n \n+    fn insert_sub_mod(\n+        &mut self,\n+        sub_mod_kind: SubModKind<'c, 'ast>,\n+        sub_mod: Cow<'ast, ast::Mod>,\n+    ) -> Result<(), String> {\n+        match sub_mod_kind {\n+            SubModKind::External(mod_path, _) => {\n+                self.file_map.insert(FileName::Real(mod_path), sub_mod);\n+            }\n+            SubModKind::MultiExternal(mods) => {\n+                for (mod_path, _, sub_mod) in mods {\n+                    self.file_map.insert(FileName::Real(mod_path), sub_mod);\n+                }\n+            }\n+            _ => (),\n+        }\n+        Ok(())\n+    }\n+\n+    fn visit_sub_mod_inner(\n+        &mut self,\n+        sub_mod: Cow<'ast, ast::Mod>,\n+        sub_mod_kind: SubModKind<'c, 'ast>,\n+    ) -> Result<(), String> {\n+        match sub_mod_kind {\n+            SubModKind::External(mod_path, directory_ownership) => {\n+                let directory = Directory {\n+                    path: mod_path.parent().unwrap().to_path_buf(),\n+                    ownership: directory_ownership,\n+                };\n+                self.visit_sub_mod_after_directory_update(sub_mod, Some(directory))\n+            }\n+            SubModKind::InternalWithPath(mod_path) => {\n+                // All `#[path]` files are treated as though they are a `mod.rs` file.\n+                let directory = Directory {\n+                    path: mod_path,\n+                    ownership: DirectoryOwnership::Owned { relative: None },\n+                };\n+                self.visit_sub_mod_after_directory_update(sub_mod, Some(directory))\n+            }\n+            SubModKind::Internal(ref item) => {\n+                self.push_inline_mod_directory(item.ident, &item.attrs);\n+                self.visit_sub_mod_after_directory_update(sub_mod, None)\n+            }\n+            SubModKind::MultiExternal(mods) => {\n+                for (mod_path, directory_ownership, sub_mod) in mods {\n+                    let directory = Directory {\n+                        path: mod_path.parent().unwrap().to_path_buf(),\n+                        ownership: directory_ownership,\n+                    };\n+                    self.visit_sub_mod_after_directory_update(sub_mod, Some(directory))?;\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn visit_sub_mod_after_directory_update(\n+        &mut self,\n+        sub_mod: Cow<'ast, ast::Mod>,\n+        directory: Option<Directory>,\n+    ) -> Result<(), String> {\n+        if let Some(directory) = directory {\n+            self.directory = directory;\n+        }\n+        match sub_mod {\n+            Cow::Borrowed(sub_mod) => self.visit_mod_from_ast(sub_mod),\n+            Cow::Owned(sub_mod) => self.visit_mod_outside_ast(sub_mod),\n+        }\n+    }\n+\n     /// Find a file path in the filesystem which corresponds to the given module.\n     fn find_external_module(\n         &self,\n         mod_name: ast::Ident,\n         attrs: &[ast::Attribute],\n-    ) -> Result<(PathBuf, DirectoryOwnership), String> {\n+        sub_mod: &Cow<'ast, ast::Mod>,\n+    ) -> Result<SubModKind<'c, 'ast>, String> {\n         if let Some(path) = parser::Parser::submod_path_from_attr(attrs, &self.directory.path) {\n-            return Ok((path, DirectoryOwnership::Owned { relative: None }));\n+            return Ok(SubModKind::External(\n+                path,\n+                DirectoryOwnership::Owned { relative: None },\n+            ));\n         }\n \n+        // Look for nested path, like `#[cfg_attr(feature = \"foo\", path = \"bar.rs\")]`.\n+        let mut mods_outside_ast = self\n+            .find_mods_ouside_of_ast(attrs, sub_mod)\n+            .unwrap_or(vec![]);\n+\n         let relative = match self.directory.ownership {\n             DirectoryOwnership::Owned { relative } => relative,\n             DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod(_) => None,\n@@ -227,7 +287,15 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                 path,\n                 directory_ownership,\n                 ..\n-            }) => Ok((path, directory_ownership)),\n+            }) => Ok(if mods_outside_ast.is_empty() {\n+                SubModKind::External(path, directory_ownership)\n+            } else {\n+                mods_outside_ast.push((path, directory_ownership, sub_mod.clone()));\n+                SubModKind::MultiExternal(mods_outside_ast)\n+            }),\n+            Err(_) if !mods_outside_ast.is_empty() => {\n+                Ok(SubModKind::MultiExternal(mods_outside_ast))\n+            }\n             Err(_) => Err(format!(\n                 \"Failed to find module {} in {:?} {:?}\",\n                 mod_name, self.directory.path, relative,\n@@ -255,6 +323,89 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             self.directory.path.push(&id.as_str());\n         }\n     }\n+\n+    fn find_mods_ouside_of_ast(\n+        &self,\n+        attrs: &[ast::Attribute],\n+        sub_mod: &Cow<'ast, ast::Mod>,\n+    ) -> Option<Vec<(PathBuf, DirectoryOwnership, Cow<'ast, ast::Mod>)>> {\n+        use std::panic::{catch_unwind, AssertUnwindSafe};\n+        Some(\n+            catch_unwind(AssertUnwindSafe(|| {\n+                self.find_mods_ouside_of_ast_inner(attrs, sub_mod)\n+            }))\n+            .ok()?,\n+        )\n+    }\n+\n+    fn find_mods_ouside_of_ast_inner(\n+        &self,\n+        attrs: &[ast::Attribute],\n+        sub_mod: &Cow<'ast, ast::Mod>,\n+    ) -> Vec<(PathBuf, DirectoryOwnership, Cow<'ast, ast::Mod>)> {\n+        // Filter nested path, like `#[cfg_attr(feature = \"foo\", path = \"bar.rs\")]`.\n+        let mut path_visitor = visitor::PathVisitor::default();\n+        for attr in attrs.iter() {\n+            if let Some(meta) = attr.meta() {\n+                path_visitor.visit_meta_item(&meta)\n+            }\n+        }\n+        let mut result = vec![];\n+        for path in path_visitor.paths() {\n+            let mut actual_path = self.directory.path.clone();\n+            actual_path.push(&path);\n+            if !actual_path.exists() {\n+                continue;\n+            }\n+            let file_name = syntax_pos::FileName::Real(actual_path.clone());\n+            if self\n+                .parse_sess\n+                .source_map()\n+                .get_source_file(&file_name)\n+                .is_some()\n+            {\n+                // If the specfied file is already parsed, then we just use that.\n+                result.push((\n+                    actual_path,\n+                    DirectoryOwnership::Owned { relative: None },\n+                    sub_mod.clone(),\n+                ));\n+                continue;\n+            }\n+            let mut parser = new_sub_parser_from_file(\n+                self.parse_sess,\n+                &actual_path,\n+                self.directory.ownership,\n+                None,\n+                DUMMY_SP,\n+            );\n+            parser.cfg_mods = false;\n+            let lo = parser.span;\n+            // FIXME(topecongiro) Format inner attributes (#3606).\n+            let _mod_attrs = match parse_inner_attributes(&mut parser) {\n+                Ok(attrs) => attrs,\n+                Err(mut e) => {\n+                    e.cancel();\n+                    parser.sess.span_diagnostic.reset_err_count();\n+                    continue;\n+                }\n+            };\n+            let m = match parse_mod_items(&mut parser, lo) {\n+                Ok(m) => m,\n+                Err(mut e) => {\n+                    e.cancel();\n+                    parser.sess.span_diagnostic.reset_err_count();\n+                    continue;\n+                }\n+            };\n+            result.push((\n+                actual_path,\n+                DirectoryOwnership::Owned { relative: None },\n+                Cow::Owned(m),\n+            ))\n+        }\n+        result\n+    }\n }\n \n fn path_value(attr: &ast::Attribute) -> Option<Symbol> {\n@@ -271,3 +422,62 @@ fn path_value(attr: &ast::Attribute) -> Option<Symbol> {\n fn find_path_value(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     attrs.iter().flat_map(path_value).next()\n }\n+\n+// FIXME(topecongiro) Use the method from libsyntax[1] once it become public.\n+//\n+// [1] https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/attr.rs\n+fn parse_inner_attributes<'a>(parser: &mut parser::Parser<'a>) -> PResult<'a, Vec<ast::Attribute>> {\n+    let mut attrs: Vec<ast::Attribute> = vec![];\n+    loop {\n+        match parser.token {\n+            token::Pound => {\n+                // Don't even try to parse if it's not an inner attribute.\n+                if !parser.look_ahead(1, |t| t == &token::Not) {\n+                    break;\n+                }\n+\n+                let attr = parser.parse_attribute(true)?;\n+                assert_eq!(attr.style, ast::AttrStyle::Inner);\n+                attrs.push(attr);\n+            }\n+            token::DocComment(s) => {\n+                // we need to get the position of this token before we bump.\n+                let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, parser.span);\n+                if attr.style == ast::AttrStyle::Inner {\n+                    attrs.push(attr);\n+                    parser.bump();\n+                } else {\n+                    break;\n+                }\n+            }\n+            _ => break,\n+        }\n+    }\n+    Ok(attrs)\n+}\n+\n+fn parse_mod_items<'a>(parser: &mut parser::Parser<'a>, inner_lo: Span) -> PResult<'a, ast::Mod> {\n+    let mut items = vec![];\n+    while let Some(item) = parser.parse_item()? {\n+        items.push(item);\n+    }\n+\n+    let hi = if parser.span.is_dummy() {\n+        inner_lo\n+    } else {\n+        parser.prev_span\n+    };\n+\n+    Ok(ast::Mod {\n+        inner: inner_lo.to(hi),\n+        items,\n+        inline: false,\n+    })\n+}\n+\n+fn is_cfg_if(item: &ast::Item) -> bool {\n+    match item.node {\n+        ast::ItemKind::Mac(..) if item.ident.name == Symbol::intern(\"cfg_if\") => true,\n+        _ => false,\n+    }\n+}"}, {"sha": "4b4b2acd9130a60e2b6b13dad2dfd1130a005451", "filename": "src/modules/visitor.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/src%2Fmodules%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/src%2Fmodules%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules%2Fvisitor.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -5,6 +5,8 @@ use syntax::symbol::kw;\n use syntax::visit::Visitor;\n use syntax_pos::Symbol;\n \n+use crate::attr::MetaVisitor;\n+\n pub(crate) struct ModItem {\n     pub(crate) item: ast::Item,\n }\n@@ -103,3 +105,40 @@ impl<'a, 'ast: 'a> CfgIfVisitor<'a> {\n         Ok(())\n     }\n }\n+\n+/// Extracts `path = \"foo.rs\"` from attributes.\n+#[derive(Default)]\n+pub(crate) struct PathVisitor {\n+    /// A list of path defined in attributes.\n+    paths: Vec<String>,\n+}\n+\n+impl PathVisitor {\n+    pub(crate) fn paths(self) -> Vec<String> {\n+        self.paths\n+    }\n+}\n+\n+impl<'ast> MetaVisitor<'ast> for PathVisitor {\n+    fn visit_meta_name_value(&mut self, meta_item: &'ast ast::MetaItem, lit: &'ast ast::Lit) {\n+        if meta_item.check_name(Symbol::intern(\"path\")) && lit.node.is_str() {\n+            self.paths.push(lit_to_str(lit));\n+        }\n+    }\n+}\n+\n+#[cfg(not(windows))]\n+fn lit_to_str(lit: &ast::Lit) -> String {\n+    match lit.node {\n+        ast::LitKind::Str(symbol, ..) => symbol.to_string(),\n+        _ => unreachable!(),\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn lit_to_str(lit: &ast::Lit) -> String {\n+    match lit.node {\n+        ast::LitKind::Str(symbol, ..) => symbol.as_str().replace(\"/\", \"\\\\\"),\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "96f6f2ce9bae84caade42e5508648d8151e76127", "filename": "src/test/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -28,6 +28,11 @@ const SKIP_FILE_WHITE_LIST: &[&str] = &[\n     // These files and directory are a part of modules defined inside `cfg_if!`.\n     \"cfg_if/mod.rs\",\n     \"cfg_if/detect\",\n+    // These files and directory are a part of modules defined inside `cfg_attr(..)`.\n+    \"cfg_mod/dir\",\n+    \"cfg_mod/bar.rs\",\n+    \"cfg_mod/foo.rs\",\n+    \"cfg_mod/wasm32.rs\",\n ];\n \n struct TestSetting {"}, {"sha": "5b6b5f438370a13caab5aa710d2fb4d3cae7b417", "filename": "tests/source/cfg_mod/bar.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_mod%2Fbar.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,3 @@\n+fn bar( ) -> &str {\n+\"bar\"\n+}"}, {"sha": "0f8c0a3a7ac0f47f59595d9ac0fe23af15e2d66f", "filename": "tests/source/cfg_mod/dir/dir1/dir2/wasm32.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir2%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir2%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir2%2Fwasm32.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,6 @@\n+fn\n+    wasm32\n+    () -> &str\n+{\n+    \"wasm32\"\n+}"}, {"sha": "0f8c0a3a7ac0f47f59595d9ac0fe23af15e2d66f", "filename": "tests/source/cfg_mod/dir/dir1/dir3/wasm32.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir3%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir3%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir3%2Fwasm32.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,6 @@\n+fn\n+    wasm32\n+    () -> &str\n+{\n+    \"wasm32\"\n+}"}, {"sha": "de4ce55ef6ff17bf118fbdd863ddc63619df9ca7", "filename": "tests/source/cfg_mod/foo.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_mod%2Ffoo.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,4 @@\n+fn foo( )\n+         -> &str {\n+    \"foo\"\n+}"}, {"sha": "45ba86f11b3f5e8ed23a51306af22ab42a2d850f", "filename": "tests/source/cfg_mod/mod.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_mod%2Fmod.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,10 @@\n+#[cfg_attr(feature = \"foo\", path = \"foo.rs\")]\n+#[cfg_attr(not(feture = \"foo\"), path = \"bar.rs\")]\n+mod sub_mod;\n+\n+#[cfg_attr(target_arch = \"wasm32\", path = \"dir/dir1/dir2/wasm32.rs\")]\n+#[cfg_attr(not(target_arch = \"wasm32\"), path = \"dir/dir1/dir3/wasm32.rs\")]\n+mod wasm32;\n+\n+#[some_attr(path = \"somewhere.rs\")]\n+mod other;"}, {"sha": "0b5c04d21920271ac05bc7d4fd4c7d4c95b2c37b", "filename": "tests/source/cfg_mod/other.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fother.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fother.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_mod%2Fother.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1 @@\n+fn other() -> &str { \"other\"}"}, {"sha": "3741e53fd4e8ef451c33889ffcb29fb52697af50", "filename": "tests/source/cfg_mod/wasm32.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Fsource%2Fcfg_mod%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_mod%2Fwasm32.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,4 @@\n+fn\n+    wasm32() -> &str {\n+        \"wasm32\"\n+    }"}, {"sha": "20dc5b4a080cafd7492a6ca7fb67e5d7547c8ea1", "filename": "tests/target/cfg_mod/bar.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_mod%2Fbar.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,3 @@\n+fn bar() -> &str {\n+    \"bar\"\n+}"}, {"sha": "ac437e4225aba8eb1a6f8b0da6dc8184aa691c56", "filename": "tests/target/cfg_mod/dir/dir1/dir2/wasm32.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fdir%2Fdir1%2Fdir2%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fdir%2Fdir1%2Fdir2%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_mod%2Fdir%2Fdir1%2Fdir2%2Fwasm32.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,3 @@\n+fn wasm32() -> &str {\n+    \"wasm32\"\n+}"}, {"sha": "ac437e4225aba8eb1a6f8b0da6dc8184aa691c56", "filename": "tests/target/cfg_mod/dir/dir1/dir3/wasm32.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fdir%2Fdir1%2Fdir3%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fdir%2Fdir1%2Fdir3%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_mod%2Fdir%2Fdir1%2Fdir3%2Fwasm32.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,3 @@\n+fn wasm32() -> &str {\n+    \"wasm32\"\n+}"}, {"sha": "053c8e6f3ed0f1f11ecab9d048857ffe8ff6d099", "filename": "tests/target/cfg_mod/foo.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_mod%2Ffoo.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,3 @@\n+fn foo() -> &str {\n+    \"foo\"\n+}"}, {"sha": "45ba86f11b3f5e8ed23a51306af22ab42a2d850f", "filename": "tests/target/cfg_mod/mod.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_mod%2Fmod.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,10 @@\n+#[cfg_attr(feature = \"foo\", path = \"foo.rs\")]\n+#[cfg_attr(not(feture = \"foo\"), path = \"bar.rs\")]\n+mod sub_mod;\n+\n+#[cfg_attr(target_arch = \"wasm32\", path = \"dir/dir1/dir2/wasm32.rs\")]\n+#[cfg_attr(not(target_arch = \"wasm32\"), path = \"dir/dir1/dir3/wasm32.rs\")]\n+mod wasm32;\n+\n+#[some_attr(path = \"somewhere.rs\")]\n+mod other;"}, {"sha": "5929b8dcf531a2248d079d40b6434a1ecc8ad864", "filename": "tests/target/cfg_mod/other.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fother.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fother.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_mod%2Fother.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,3 @@\n+fn other() -> &str {\n+    \"other\"\n+}"}, {"sha": "ac437e4225aba8eb1a6f8b0da6dc8184aa691c56", "filename": "tests/target/cfg_mod/wasm32.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47a11cd5166a605897beb678095d17abc66c136f/tests%2Ftarget%2Fcfg_mod%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_mod%2Fwasm32.rs?ref=47a11cd5166a605897beb678095d17abc66c136f", "patch": "@@ -0,0 +1,3 @@\n+fn wasm32() -> &str {\n+    \"wasm32\"\n+}"}]}