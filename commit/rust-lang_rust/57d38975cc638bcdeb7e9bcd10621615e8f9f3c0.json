{"sha": "57d38975cc638bcdeb7e9bcd10621615e8f9f3c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZDM4OTc1Y2M2MzhiY2RlYjdlOWJjZDEwNjIxNjE1ZThmOWYzYzA=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-09-26T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-09-26T14:44:41Z"}, "message": "liveness: Use newtype_index for Variable and LiveNode", "tree": {"sha": "b800cdc1f9fc04c21864730f48b46f5a98cd9faf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b800cdc1f9fc04c21864730f48b46f5a98cd9faf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0", "html_url": "https://github.com/rust-lang/rust/commit/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49d1ce00f30a10e607dc30506d3e890d1efb6309", "url": "https://api.github.com/repos/rust-lang/rust/commits/49d1ce00f30a10e607dc30506d3e890d1efb6309", "html_url": "https://github.com/rust-lang/rust/commit/49d1ce00f30a10e607dc30506d3e890d1efb6309"}], "stats": {"total": 113, "additions": 47, "deletions": 66}, "files": [{"sha": "2bd41e68f8b9d4988db53d0450898645858519e3", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=57d38975cc638bcdeb7e9bcd10621615e8f9f3c0", "patch": "@@ -3891,6 +3891,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\","}, {"sha": "df6667a29d50b232fa5f5facc204138b4dbfee6c", "filename": "compiler/rustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0/compiler%2Frustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0/compiler%2Frustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2FCargo.toml?ref=57d38975cc638bcdeb7e9bcd10621615e8f9f3c0", "patch": "@@ -15,5 +15,6 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_ast = { path = \"../rustc_ast\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "c32c9c8eaa68c09dd6081c65a3089ea3c49aa7a6", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=57d38975cc638bcdeb7e9bcd10621615e8f9f3c0", "patch": "@@ -5,6 +5,8 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(const_fn)]\n+#![feature(const_panic)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]"}, {"sha": "8c6d47f992d786c0c8ecf8fa7661562b37d7ae1b", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 43, "deletions": 66, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d38975cc638bcdeb7e9bcd10621615e8f9f3c0/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=57d38975cc638bcdeb7e9bcd10621615e8f9f3c0", "patch": "@@ -62,13 +62,13 @@\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n //!    that `V` holds on entry to `N`. Formally: a node `M` such\n //!    that there exists a path `P` from `N` to `M` where `P` does not\n-//!    write `V`. If the `reader` is `invalid_node()`, then the current\n+//!    write `V`. If the `reader` is `INVALID_NODE`, then the current\n //!    value will never be read (the variable is dead, essentially).\n //!\n //! - `writer`: the `LiveNode` ID of some node which will write the\n //!    variable `V` and which is reachable from `N`. Formally: a node `M`\n //!    such that there exists a path `P` from `N` to `M` and `M` writes\n-//!    `V`. If the `writer` is `invalid_node()`, then there is no writer\n+//!    `V`. If the `writer` is `INVALID_NODE`, then there is no writer\n //!    of `V` that follows `N`.\n //!\n //! - `used`: a boolean value indicating whether `V` is *used*. We\n@@ -92,6 +92,7 @@ use rustc_hir::def::*;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{Expr, HirId, HirIdMap, HirIdSet, Node};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -100,26 +101,20 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n use std::collections::VecDeque;\n-use std::fmt;\n use std::io;\n use std::io::prelude::*;\n use std::rc::Rc;\n \n-#[derive(Copy, Clone, PartialEq)]\n-struct Variable(u32);\n-\n-#[derive(Copy, Clone, PartialEq)]\n-struct LiveNode(u32);\n-\n-impl Variable {\n-    fn get(&self) -> usize {\n-        self.0 as usize\n+rustc_index::newtype_index! {\n+    pub struct Variable {\n+        DEBUG_FORMAT = \"v({})\",\n     }\n }\n \n-impl LiveNode {\n-    fn get(&self) -> usize {\n-        self.0 as usize\n+rustc_index::newtype_index! {\n+    pub struct LiveNode {\n+        DEBUG_FORMAT = \"ln({})\",\n+        const INVALID_NODE = LiveNode::MAX_AS_U32,\n     }\n }\n \n@@ -183,18 +178,6 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_liveness, ..*providers };\n }\n \n-impl fmt::Debug for LiveNode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"ln({})\", self.get())\n-    }\n-}\n-\n-impl fmt::Debug for Variable {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"v({})\", self.get())\n-    }\n-}\n-\n // ______________________________________________________________________\n // Creating ir_maps\n //\n@@ -218,15 +201,11 @@ impl fmt::Debug for Variable {\n // assignment.  And so forth.\n \n impl LiveNode {\n-    fn is_valid(&self) -> bool {\n-        self.0 != u32::MAX\n+    fn is_valid(self) -> bool {\n+        self != INVALID_NODE\n     }\n }\n \n-fn invalid_node() -> LiveNode {\n-    LiveNode(u32::MAX)\n-}\n-\n struct CaptureInfo {\n     ln: LiveNode,\n     var_hid: HirId,\n@@ -252,8 +231,8 @@ struct IrMaps<'tcx> {\n     live_node_map: HirIdMap<LiveNode>,\n     variable_map: HirIdMap<Variable>,\n     capture_info_map: HirIdMap<Rc<Vec<CaptureInfo>>>,\n-    var_kinds: Vec<VarKind>,\n-    lnks: Vec<LiveNodeKind>,\n+    var_kinds: IndexVec<Variable, VarKind>,\n+    lnks: IndexVec<LiveNode, LiveNodeKind>,\n }\n \n impl IrMaps<'tcx> {\n@@ -264,14 +243,13 @@ impl IrMaps<'tcx> {\n             live_node_map: HirIdMap::default(),\n             variable_map: HirIdMap::default(),\n             capture_info_map: Default::default(),\n-            var_kinds: Vec::new(),\n-            lnks: Vec::new(),\n+            var_kinds: IndexVec::new(),\n+            lnks: IndexVec::new(),\n         }\n     }\n \n     fn add_live_node(&mut self, lnk: LiveNodeKind) -> LiveNode {\n-        let ln = LiveNode(self.lnks.len() as u32);\n-        self.lnks.push(lnk);\n+        let ln = self.lnks.push(lnk);\n \n         debug!(\"{:?} is of kind {}\", ln, live_node_kind_to_string(lnk, self.tcx));\n \n@@ -286,8 +264,7 @@ impl IrMaps<'tcx> {\n     }\n \n     fn add_variable(&mut self, vk: VarKind) -> Variable {\n-        let v = Variable(self.var_kinds.len() as u32);\n-        self.var_kinds.push(vk);\n+        let v = self.var_kinds.push(vk);\n \n         match vk {\n             Local(LocalInfo { id: node_id, .. }) | Param(node_id, _) | Upvar(node_id, _) => {\n@@ -310,13 +287,13 @@ impl IrMaps<'tcx> {\n     }\n \n     fn variable_name(&self, var: Variable) -> Symbol {\n-        match self.var_kinds[var.get()] {\n+        match self.var_kinds[var] {\n             Local(LocalInfo { name, .. }) | Param(_, name) | Upvar(_, name) => name,\n         }\n     }\n \n     fn variable_is_shorthand(&self, var: Variable) -> bool {\n-        match self.var_kinds[var.get()] {\n+        match self.var_kinds[var] {\n             Local(LocalInfo { is_shorthand, .. }) => is_shorthand,\n             Param(..) | Upvar(..) => false,\n         }\n@@ -327,7 +304,7 @@ impl IrMaps<'tcx> {\n     }\n \n     fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n-        self.lnks[ln.get()]\n+        self.lnks[ln]\n     }\n }\n \n@@ -556,10 +533,10 @@ struct RWUTable {\n     unpacked_rwus: Vec<RWU>,\n }\n \n-// A constant representing `RWU { reader: invalid_node(); writer: invalid_node(); used: false }`.\n+// A constant representing `RWU { reader: INVALID_NODE; writer: INVALID_NODE; used: false }`.\n const INV_INV_FALSE: u32 = u32::MAX;\n \n-// A constant representing `RWU { reader: invalid_node(); writer: invalid_node(); used: true }`.\n+// A constant representing `RWU { reader: INVALID_NODE; writer: INVALID_NODE; used: true }`.\n const INV_INV_TRUE: u32 = u32::MAX - 1;\n \n impl RWUTable {\n@@ -570,24 +547,24 @@ impl RWUTable {\n     fn get(&self, idx: usize) -> RWU {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE => RWU { reader: invalid_node(), writer: invalid_node(), used: false },\n-            INV_INV_TRUE => RWU { reader: invalid_node(), writer: invalid_node(), used: true },\n+            INV_INV_FALSE => RWU { reader: INVALID_NODE, writer: INVALID_NODE, used: false },\n+            INV_INV_TRUE => RWU { reader: INVALID_NODE, writer: INVALID_NODE, used: true },\n             _ => self.unpacked_rwus[packed_rwu as usize],\n         }\n     }\n \n     fn get_reader(&self, idx: usize) -> LiveNode {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => invalid_node(),\n+            INV_INV_FALSE | INV_INV_TRUE => INVALID_NODE,\n             _ => self.unpacked_rwus[packed_rwu as usize].reader,\n         }\n     }\n \n     fn get_writer(&self, idx: usize) -> LiveNode {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => invalid_node(),\n+            INV_INV_FALSE | INV_INV_TRUE => INVALID_NODE,\n             _ => self.unpacked_rwus[packed_rwu as usize].writer,\n         }\n     }\n@@ -607,7 +584,7 @@ impl RWUTable {\n     }\n \n     fn assign_unpacked(&mut self, idx: usize, rwu: RWU) {\n-        if rwu.reader == invalid_node() && rwu.writer == invalid_node() {\n+        if rwu.reader == INVALID_NODE && rwu.writer == INVALID_NODE {\n             // When we overwrite an indexing entry in `self.packed_rwus` with\n             // `INV_INV_{TRUE,FALSE}` we don't remove the corresponding entry\n             // from `self.unpacked_rwus`; it's not worth the effort, and we\n@@ -634,7 +611,7 @@ struct Liveness<'a, 'tcx> {\n     ir: &'a mut IrMaps<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    successors: Vec<LiveNode>,\n+    successors: IndexVec<LiveNode, LiveNode>,\n     rwu_table: RWUTable,\n \n     /// A live node representing a point of execution before closure entry &\n@@ -667,7 +644,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             ir,\n             typeck_results,\n             param_env,\n-            successors: vec![invalid_node(); num_live_nodes],\n+            successors: IndexVec::from_elem_n(INVALID_NODE, num_live_nodes),\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n             closure_ln,\n             exit_ln,\n@@ -708,7 +685,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn idx(&self, ln: LiveNode, var: Variable) -> usize {\n-        ln.get() * self.ir.var_kinds.len() + var.get()\n+        ln.index() * self.ir.var_kinds.len() + var.index()\n     }\n \n     fn live_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n@@ -719,7 +696,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     // Is this variable live on entry to any of its successor nodes?\n     fn live_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        let successor = self.successors[ln.get()];\n+        let successor = self.successors[ln];\n         self.live_on_entry(successor, var)\n     }\n \n@@ -735,16 +712,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn assigned_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        let successor = self.successors[ln.get()];\n+        let successor = self.successors[ln];\n         self.assigned_on_entry(successor, var)\n     }\n \n     fn indices2<F>(&mut self, ln: LiveNode, succ_ln: LiveNode, mut op: F)\n     where\n         F: FnMut(&mut Liveness<'a, 'tcx>, usize, usize),\n     {\n-        let node_base_idx = self.idx(ln, Variable(0));\n-        let succ_base_idx = self.idx(succ_ln, Variable(0));\n+        let node_base_idx = self.idx(ln, Variable::from(0u32));\n+        let succ_base_idx = self.idx(succ_ln, Variable::from(0u32));\n         for var_idx in 0..self.ir.var_kinds.len() {\n             op(self, node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n@@ -754,11 +731,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     where\n         F: FnMut(usize) -> bool,\n     {\n-        let node_base_idx = self.idx(ln, Variable(0));\n+        let node_base_idx = self.idx(ln, Variable::from(0u32));\n         for var_idx in 0..self.ir.var_kinds.len() {\n             let idx = node_base_idx + var_idx;\n             if test(idx) {\n-                write!(wr, \" {:?}\", Variable(var_idx as u32))?;\n+                write!(wr, \" {:?}\", Variable::from(var_idx))?;\n             }\n         }\n         Ok(())\n@@ -769,14 +746,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut wr = Vec::new();\n         {\n             let wr = &mut wr as &mut dyn Write;\n-            write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n+            write!(wr, \"[{:?} of kind {:?} reads\", ln, self.ir.lnk(ln));\n             self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_valid());\n             write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_valid());\n             write!(wr, \"  uses\");\n             self.write_vars(wr, ln, |idx| self.rwu_table.get_used(idx));\n \n-            write!(wr, \"  precedes {:?}]\", self.successors[ln.get()]);\n+            write!(wr, \"  precedes {:?}]\", self.successors[ln]);\n         }\n         String::from_utf8(wr).unwrap()\n     }\n@@ -787,7 +764,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             \"^^ liveness computation results for body {} (entry={:?})\",\n             {\n                 for ln_idx in 0..self.ir.lnks.len() {\n-                    debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n+                    debug!(\"{:?}\", self.ln_str(LiveNode::from(ln_idx)));\n                 }\n                 hir_id\n             },\n@@ -796,7 +773,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n-        self.successors[ln.get()] = succ_ln;\n+        self.successors[ln] = succ_ln;\n \n         // It is not necessary to initialize the RWUs here because they are all\n         // set to INV_INV_FALSE when they are created, and the sets only grow\n@@ -805,7 +782,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n-        self.successors[ln.get()] = succ_ln;\n+        self.successors[ln] = succ_ln;\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n             this.rwu_table.copy_packed(idx, succ_idx);\n@@ -878,7 +855,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut rwu = self.rwu_table.get(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n-            rwu.reader = invalid_node();\n+            rwu.reader = INVALID_NODE;\n             rwu.writer = ln;\n         }\n "}]}