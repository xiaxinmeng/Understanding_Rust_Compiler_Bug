{"sha": "32772fddd52013a38ece584279b6bc422b2d8b9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNzcyZmRkZDUyMDEzYTM4ZWNlNTg0Mjc5YjZiYzQyMmIyZDhiOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-22T16:48:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-22T16:48:09Z"}, "message": "Auto merge of #52572 - davidtwco:issue-51027, r=nikomatsakis\n\nNLL diagnostics replaced nice closure errors w/ indecipherable free region errors\n\nFixes #51027.\n\nr? @nikomatsakis", "tree": {"sha": "9cfde2d8c6e16dd05f13f9bebcb29a170df26dd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cfde2d8c6e16dd05f13f9bebcb29a170df26dd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32772fddd52013a38ece584279b6bc422b2d8b9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32772fddd52013a38ece584279b6bc422b2d8b9b", "html_url": "https://github.com/rust-lang/rust/commit/32772fddd52013a38ece584279b6bc422b2d8b9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32772fddd52013a38ece584279b6bc422b2d8b9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3b3bc57670ab91a53b2100cf3dfe78947bfe077", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3b3bc57670ab91a53b2100cf3dfe78947bfe077", "html_url": "https://github.com/rust-lang/rust/commit/d3b3bc57670ab91a53b2100cf3dfe78947bfe077"}, {"sha": "c64db0078a425c71e131432c41d9c6fc6f961b0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c64db0078a425c71e131432c41d9c6fc6f961b0e", "html_url": "https://github.com/rust-lang/rust/commit/c64db0078a425c71e131432c41d9c6fc6f961b0e"}], "stats": {"total": 524, "additions": 367, "deletions": 157}, "files": [{"sha": "0359eb9b95d1ba870b0e3a92c719aa61bb57a755", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -119,6 +119,39 @@ impl<'tcx> Place<'tcx> {\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n         }\n     }\n+\n+    /// If this is a field projection, and the field is being projected from a closure type,\n+    /// then returns the index of the field being projected. Note that this closure will always\n+    /// be `self` in the current MIR, because that is the only time we directly access the fields\n+    /// of a closure type.\n+    pub fn is_upvar_field_projection<'cx, 'gcx>(&self, mir: &'cx Mir<'tcx>,\n+                                                tcx: &TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Field> {\n+        let place = if let Place::Projection(ref proj) = self {\n+            if let ProjectionElem::Deref = proj.elem {\n+                &proj.base\n+            } else {\n+                self\n+            }\n+        } else {\n+            self\n+        };\n+\n+        match place {\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(field, _ty) => {\n+                    let base_ty = proj.base.ty(mir, *tcx).to_ty(*tcx);\n+\n+                    if  base_ty.is_closure() || base_ty.is_generator() {\n+                        Some(field)\n+                    } else {\n+                        None\n+                    }\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n }\n \n pub enum RvalueInitializationState {"}, {"sha": "5dca01f8842a09d82ada4710ba28cd3c911fd702", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -726,7 +726,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n+                        let upvar_field_projection = place.is_upvar_field_projection(\n+                            self.mir, &self.tcx);\n+                        if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n                             if self.mir.upvar_decls[var_index].by_ref {\n@@ -785,7 +787,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n \n-                        if let Some(field) = self.is_upvar_field_projection(place) {\n+                        let upvar_field_projection = place.is_upvar_field_projection(\n+                            self.mir, &self.tcx);\n+                        if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n                             buf.push_str(&name);"}, {"sha": "62bf2b0abe4c7df6aedc7952159ad7d76ff3c3fb", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -1214,7 +1214,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 }\n                                 Operand::Move(ref place @ Place::Projection(_))\n                                 | Operand::Copy(ref place @ Place::Projection(_)) => {\n-                                    if let Some(field) = self.is_upvar_field_projection(place) {\n+                                    if let Some(field) = place.is_upvar_field_projection(\n+                                            self.mir, &self.tcx) {\n                                         self.used_mut_upvars.push(field);\n                                     }\n                                 }\n@@ -1803,7 +1804,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 place: place @ Place::Projection(_),\n                 is_local_mutation_allowed: _,\n             } => {\n-                if let Some(field) = self.is_upvar_field_projection(&place) {\n+                if let Some(field) = place.is_upvar_field_projection(self.mir, &self.tcx) {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n@@ -1866,7 +1867,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match self.is_upvar_field_projection(&proj.base)\n+                                        let mode = match place.is_upvar_field_projection(\n+                                            self.mir, &self.tcx)\n                                         {\n                                             Some(field)\n                                                 if {\n@@ -1911,7 +1913,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n-                        if let Some(field) = self.is_upvar_field_projection(place) {\n+                        let upvar_field_projection = place.is_upvar_field_projection(\n+                            self.mir, &self.tcx);\n+                        if let Some(field) = upvar_field_projection {\n                             let decl = &self.mir.upvar_decls[field.index()];\n                             debug!(\n                                 \"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n@@ -1965,28 +1969,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n-\n-    /// If this is a field projection, and the field is being projected from a closure type,\n-    /// then returns the index of the field being projected. Note that this closure will always\n-    /// be `self` in the current MIR, because that is the only time we directly access the fields\n-    /// of a closure type.\n-    fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n-        match *place {\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _ty) => {\n-                    let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-\n-                    if base_ty.is_closure() || base_ty.is_generator() {\n-                        Some(field)\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}, {"sha": "c89dc889b5e392e47e5cb21fdbf93d8b27240448", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 104, "deletions": 22, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -22,6 +22,7 @@ use std::fmt;\n use syntax_pos::Span;\n \n mod region_name;\n+mod var_name;\n \n /// Constraints that are considered interesting can be categorized to\n /// determine why they are interesting. Order of variants indicates\n@@ -30,7 +31,9 @@ mod region_name;\n enum ConstraintCategory {\n     Cast,\n     Assignment,\n+    AssignmentToUpvar,\n     Return,\n+    CallArgumentToUpvar,\n     CallArgument,\n     Other,\n     Boring,\n@@ -39,10 +42,12 @@ enum ConstraintCategory {\n impl fmt::Display for ConstraintCategory {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            ConstraintCategory::Assignment => write!(f, \"assignment\"),\n+            ConstraintCategory::Assignment |\n+            ConstraintCategory::AssignmentToUpvar => write!(f, \"assignment\"),\n             ConstraintCategory::Return => write!(f, \"return\"),\n             ConstraintCategory::Cast => write!(f, \"cast\"),\n-            ConstraintCategory::CallArgument => write!(f, \"argument\"),\n+            ConstraintCategory::CallArgument |\n+            ConstraintCategory::CallArgumentToUpvar => write!(f, \"argument\"),\n             _ => write!(f, \"free region\"),\n         }\n     }\n@@ -130,8 +135,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         index: ConstraintIndex,\n         mir: &Mir<'tcx>,\n+        _infcx: &InferCtxt<'_, '_, 'tcx>,\n     ) -> (ConstraintCategory, Span) {\n         let constraint = self.constraints[index];\n+        debug!(\"classify_constraint: constraint={:?}\", constraint);\n         let span = constraint.locations.span(mir);\n         let location = constraint.locations.from_location().unwrap_or(Location::START);\n \n@@ -140,8 +147,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         let data = &mir[location.block];\n+        debug!(\"classify_constraint: location={:?} data={:?}\", location, data);\n         let category = if location.statement_index == data.statements.len() {\n             if let Some(ref terminator) = data.terminator {\n+                debug!(\"classify_constraint: terminator.kind={:?}\", terminator.kind);\n                 match terminator.kind {\n                     TerminatorKind::DropAndReplace { .. } => ConstraintCategory::Assignment,\n                     TerminatorKind::Call { .. } => ConstraintCategory::CallArgument,\n@@ -152,14 +161,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         } else {\n             let statement = &data.statements[location.statement_index];\n+            debug!(\"classify_constraint: statement.kind={:?}\", statement.kind);\n             match statement.kind {\n                 StatementKind::Assign(ref place, ref rvalue) => {\n+                    debug!(\"classify_constraint: place={:?} rvalue={:?}\", place, rvalue);\n                     if *place == Place::Local(mir::RETURN_PLACE) {\n                         ConstraintCategory::Return\n                     } else {\n                         match rvalue {\n                             Rvalue::Cast(..) => ConstraintCategory::Cast,\n-                            Rvalue::Use(..) => ConstraintCategory::Assignment,\n+                            Rvalue::Use(..) |\n+                            Rvalue::Aggregate(..) => ConstraintCategory::Assignment,\n                             _ => ConstraintCategory::Other,\n                         }\n                     }\n@@ -208,7 +220,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<(ConstraintCategory, Span)> = path.iter()\n-            .map(|&index| self.classify_constraint(index, mir))\n+            .map(|&index| self.classify_constraint(index, mir, infcx))\n             .collect();\n         debug!(\"report_error: categorized_path={:?}\", categorized_path);\n \n@@ -218,30 +230,100 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Get a span\n         let (category, span) = categorized_path.first().unwrap();\n+\n+        let category = match (\n+            category,\n+            self.universal_regions.is_local_free_region(fr),\n+            self.universal_regions.is_local_free_region(outlived_fr),\n+        ) {\n+            (ConstraintCategory::Assignment, true, false) =>\n+                &ConstraintCategory::AssignmentToUpvar,\n+            (ConstraintCategory::CallArgument, true, false) =>\n+                &ConstraintCategory::CallArgumentToUpvar,\n+            (category, _, _) => category,\n+        };\n+\n+        debug!(\"report_error: category={:?}\", category);\n+        match category {\n+            ConstraintCategory::AssignmentToUpvar |\n+            ConstraintCategory::CallArgumentToUpvar =>\n+                self.report_closure_error(mir, infcx, mir_def_id, fr, outlived_fr, category, span),\n+            _ =>\n+                self.report_general_error(mir, infcx, mir_def_id, fr, outlived_fr, category, span),\n+        }\n+    }\n+\n+    fn report_closure_error(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        fr: RegionVid,\n+        outlived_fr: RegionVid,\n+        category: &ConstraintCategory,\n+        span: &Span,\n+    ) {\n+        let fr_name_and_span  = self.get_var_name_and_span_for_region(\n+            infcx.tcx, mir, fr);\n+        let outlived_fr_name_and_span = self.get_var_name_and_span_for_region(\n+            infcx.tcx, mir,outlived_fr);\n+\n+        if fr_name_and_span.is_none() && outlived_fr_name_and_span.is_none() {\n+            return self.report_general_error(mir, infcx, mir_def_id, fr, outlived_fr, category,\n+                                             span);\n+        }\n+\n+        let diag = &mut infcx.tcx.sess.struct_span_err(\n+            *span, &format!(\"borrowed data escapes outside of closure\"),\n+        );\n+\n+        if let Some((outlived_fr_name, outlived_fr_span)) = outlived_fr_name_and_span {\n+            if let Some(name) = outlived_fr_name {\n+                diag.span_label(\n+                    outlived_fr_span,\n+                    format!(\"`{}` is declared here, outside of the closure body\", name),\n+                );\n+            }\n+        }\n+\n+        if let Some((fr_name, fr_span)) = fr_name_and_span {\n+            if let Some(name) = fr_name {\n+                diag.span_label(\n+                    fr_span,\n+                    format!(\"`{}` is a reference that is only valid in the closure body\", name),\n+                );\n+\n+                diag.span_label(*span, format!(\"`{}` escapes the closure body here\", name));\n+            }\n+        }\n+\n+        diag.emit();\n+    }\n+\n+    fn report_general_error(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        fr: RegionVid,\n+        outlived_fr: RegionVid,\n+        category: &ConstraintCategory,\n+        span: &Span,\n+    ) {\n         let diag = &mut infcx.tcx.sess.struct_span_err(\n-            *span,\n-            &format!(\"unsatisfied lifetime constraints\"), // FIXME\n+            *span, &format!(\"unsatisfied lifetime constraints\"), // FIXME\n         );\n \n-        // Figure out how we can refer\n         let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(infcx.tcx, mir, mir_def_id, fr, counter, diag);\n+        let fr_name = self.give_region_a_name(\n+            infcx.tcx, mir, mir_def_id, fr, counter, diag);\n         let outlived_fr_name = self.give_region_a_name(\n-            infcx.tcx,\n-            mir,\n-            mir_def_id,\n-            outlived_fr,\n-            counter,\n-            diag,\n-        );\n+            infcx.tcx, mir, mir_def_id, outlived_fr, counter, diag);\n \n-        diag.span_label(\n-            *span,\n-            format!(\n-                \"{} requires that `{}` must outlive `{}`\",\n-                category, fr_name, outlived_fr_name,\n-            ),\n-        );\n+        diag.span_label(*span, format!(\n+            \"{} requires that `{}` must outlive `{}`\",\n+            category, fr_name, outlived_fr_name,\n+        ));\n \n         diag.emit();\n     }"}, {"sha": "c0eca026331ba3891b2cef0b85d1e58f0db485b9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 12, "deletions": 57, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -12,10 +12,9 @@ use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::ToRegionVid;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{Local, Mir};\n+use rustc::mir::Mir;\n use rustc::ty::subst::{Substs, UnpackedKind};\n use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n-use rustc_data_structures::indexed_vec::Idx;\n use rustc_errors::DiagnosticBuilder;\n use syntax::ast::Name;\n use syntax::symbol::keywords;\n@@ -63,11 +62,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.give_name_from_error_region(tcx, mir_def_id, fr, counter, diag)\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_arguments(\n-                    tcx, mir, mir_def_id, fr, counter, diag,\n-                )\n+                    tcx, mir, mir_def_id, fr, counter, diag)\n             })\n             .or_else(|| {\n-                self.give_name_if_anonymous_region_appears_in_upvars(tcx, mir, fr, counter, diag)\n+                self.give_name_if_anonymous_region_appears_in_upvars(\n+                    tcx, mir, fr, counter, diag)\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_output(tcx, mir, fr, counter, diag)\n@@ -139,24 +138,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<InternedString> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n-        let argument_index = self\n-            .universal_regions\n-            .unnormalized_input_tys\n-            .iter()\n-            .skip(implicit_inputs)\n-            .position(|arg_ty| {\n-                debug!(\n-                    \"give_name_if_anonymous_region_appears_in_arguments: arg_ty = {:?}\",\n-                    arg_ty\n-                );\n-                tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n-            })?;\n-\n-        debug!(\n-            \"give_name_if_anonymous_region_appears_in_arguments: \\\n-             found {:?} in argument {} which has type {:?}\",\n-            fr, argument_index, self.universal_regions.unnormalized_input_tys[argument_index],\n-        );\n+        let argument_index = self.get_argument_index_for_region(tcx, fr)?;\n \n         let arg_ty =\n             self.universal_regions.unnormalized_input_tys[implicit_inputs + argument_index];\n@@ -172,10 +154,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return Some(region_name);\n         }\n \n+        let (_argument_name, argument_span) = self.get_argument_name_and_span_for_region(\n+            mir, argument_index);\n+\n         let region_name = self.synthesize_region_name(counter);\n \n-        let argument_local = Local::new(argument_index + implicit_inputs + 1);\n-        let argument_span = mir.local_decls[argument_local].source_info.span;\n         diag.span_label(\n             argument_span,\n             format!(\"lifetime `{}` appears in this argument\", region_name,),\n@@ -440,42 +423,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<InternedString> {\n-        let upvar_index = self\n-            .universal_regions\n-            .defining_ty\n-            .upvar_tys(tcx)\n-            .position(|upvar_ty| {\n-                debug!(\n-                    \"give_name_if_anonymous_region_appears_in_upvars: upvar_ty = {:?}\",\n-                    upvar_ty,\n-                );\n-                tcx.any_free_region_meets(&upvar_ty, |r| r.to_region_vid() == fr)\n-            })?;\n-\n-        let upvar_ty = self\n-            .universal_regions\n-            .defining_ty\n-            .upvar_tys(tcx)\n-            .nth(upvar_index);\n-\n-        debug!(\n-            \"give_name_if_anonymous_region_appears_in_upvars: \\\n-             found {:?} in upvar {} which has type {:?}\",\n-            fr, upvar_index, upvar_ty,\n-        );\n-\n+        let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n+        let (upvar_name, upvar_span) = self.get_upvar_name_and_span_for_region(tcx, mir,\n+                                                                               upvar_index);\n         let region_name = self.synthesize_region_name(counter);\n \n-        let upvar_hir_id = mir.upvar_decls[upvar_index].var_hir_id.assert_crate_local();\n-        let upvar_node_id = tcx.hir.hir_to_node_id(upvar_hir_id);\n-        let upvar_span = tcx.hir.span(upvar_node_id);\n-        let upvar_name = tcx.hir.name(upvar_node_id);\n         diag.span_label(\n             upvar_span,\n-            format!(\n-                \"lifetime `{}` appears in the type of `{}`\",\n-                region_name, upvar_name,\n-            ),\n+            format!(\"lifetime `{}` appears in the type of `{}`\", region_name, upvar_name),\n         );\n \n         Some(region_name)"}, {"sha": "f1c3a7489ee8f1f2ead6a6f2c65473741b63f08b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::ToRegionVid;\n+use rustc::mir::{Local, Mir};\n+use rustc::ty::{RegionVid, TyCtxt};\n+use rustc_data_structures::indexed_vec::Idx;\n+use syntax::codemap::Span;\n+use syntax_pos::symbol::Symbol;\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    crate fn get_var_name_and_span_for_region(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        fr: RegionVid,\n+    ) -> Option<(Option<Symbol>, Span)> {\n+        debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n+        assert!(self.universal_regions.is_universal_region(fr));\n+\n+        debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n+        self.get_upvar_index_for_region(tcx, fr)\n+            .map(|index| {\n+                let (name, span) = self.get_upvar_name_and_span_for_region(tcx, mir, index);\n+                (Some(name), span)\n+            })\n+            .or_else(|| {\n+                debug!(\"get_var_name_and_span_for_region: attempting argument\");\n+                self.get_argument_index_for_region(tcx, fr)\n+                    .map(|index| self.get_argument_name_and_span_for_region(mir, index))\n+            })\n+    }\n+\n+    /// Search the upvars (if any) to find one that references fr. Return its index.\n+    crate fn get_upvar_index_for_region(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        fr: RegionVid,\n+    ) -> Option<usize> {\n+        let upvar_index = self\n+            .universal_regions\n+            .defining_ty\n+            .upvar_tys(tcx)\n+            .position(|upvar_ty| {\n+                debug!(\n+                    \"get_upvar_index_for_region: upvar_ty = {:?}\",\n+                    upvar_ty,\n+                );\n+                tcx.any_free_region_meets(&upvar_ty, |r| r.to_region_vid() == fr)\n+            })?;\n+\n+        let upvar_ty = self\n+            .universal_regions\n+            .defining_ty\n+            .upvar_tys(tcx)\n+            .nth(upvar_index);\n+\n+        debug!(\n+            \"get_upvar_index_for_region: found {:?} in upvar {} which has type {:?}\",\n+            fr, upvar_index, upvar_ty,\n+        );\n+\n+        Some(upvar_index)\n+    }\n+\n+    /// Given the index of an upvar, finds its name and the span from where it was\n+    /// declared.\n+    crate fn get_upvar_name_and_span_for_region(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        upvar_index: usize,\n+    ) -> (Symbol, Span) {\n+        let upvar_hir_id = mir.upvar_decls[upvar_index].var_hir_id.assert_crate_local();\n+        let upvar_node_id = tcx.hir.hir_to_node_id(upvar_hir_id);\n+        debug!(\"get_upvar_name_and_span_for_region: upvar_node_id={:?}\", upvar_node_id);\n+\n+        let upvar_name = tcx.hir.name(upvar_node_id);\n+        let upvar_span = tcx.hir.span(upvar_node_id);\n+        debug!(\"get_upvar_name_and_span_for_region: upvar_name={:?} upvar_span={:?}\",\n+               upvar_name, upvar_span);\n+\n+        (upvar_name, upvar_span)\n+    }\n+\n+    /// Search the argument types for one that references fr (which should be a free region).\n+    /// Returns Some(_) with the index of the input if one is found.\n+    ///\n+    /// NB: In the case of a closure, the index is indexing into the signature as seen by the\n+    /// user - in particular, index 0 is not the implicit self parameter.\n+    crate fn get_argument_index_for_region(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        fr: RegionVid,\n+    ) -> Option<usize> {\n+        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let argument_index = self\n+            .universal_regions\n+            .unnormalized_input_tys\n+            .iter()\n+            .skip(implicit_inputs)\n+            .position(|arg_ty| {\n+                debug!(\n+                    \"get_argument_index_for_region: arg_ty = {:?}\",\n+                    arg_ty\n+                );\n+                tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n+            })?;\n+\n+        debug!(\n+            \"get_argument_index_for_region: found {:?} in argument {} which has type {:?}\",\n+            fr, argument_index, self.universal_regions.unnormalized_input_tys[argument_index],\n+        );\n+\n+        Some(argument_index)\n+    }\n+\n+    /// Given the index of an argument, finds its name (if any) and the span from where it was\n+    /// declared.\n+    crate fn get_argument_name_and_span_for_region(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        argument_index: usize,\n+    ) -> (Option<Symbol>, Span) {\n+        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let argument_local = Local::new(implicit_inputs + argument_index + 1);\n+        debug!(\"get_argument_name_and_span_for_region: argument_local={:?}\", argument_local);\n+\n+        let argument_name = mir.local_decls[argument_local].name;\n+        let argument_span = mir.local_decls[argument_local].source_info.span;\n+        debug!(\"get_argument_name_and_span_for_region: argument_name={:?} argument_span={:?}\",\n+               argument_name, argument_span);\n+\n+        (argument_name, argument_span)\n+    }\n+\n+}"}, {"sha": "64086cb07917d81a7141e3984271c47d78f890c9", "filename": "src/test/ui/borrowck/issue-45983.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -4,15 +4,15 @@ warning: not reporting region error due to nll\n LL |     give_any(|y| x = Some(y));\n    |                           ^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/issue-45983.rs:17:18\n    |\n LL |     let x = None;\n-   |         - lifetime `'2` appears in the type of `x`\n+   |         - `x` is declared here, outside of the closure body\n LL |     give_any(|y| x = Some(y));\n-   |               -  ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n    |               |\n-   |               lifetime `'1` appears in this argument\n+   |               `y` is a reference that is only valid in the closure body\n \n error[E0594]: cannot assign to `x`, as it is not declared as mutable\n   --> $DIR/issue-45983.rs:17:18"}, {"sha": "b0fbcd3ad9f39e53d7c0a36c1b6b60b14f9ebcfc", "filename": "src/test/ui/borrowck/issue-7573.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -4,17 +4,17 @@ warning: not reporting region error due to nll\n LL |     let mut lines_to_use: Vec<&CrateId> = Vec::new();\n    |                               ^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/issue-7573.rs:32:9\n    |\n LL |     let mut lines_to_use: Vec<&CrateId> = Vec::new();\n-   |         ---------------- lifetime `'2` appears in the type of `lines_to_use`\n+   |         ---------------- `lines_to_use` is declared here, outside of the closure body\n LL |         //~^ NOTE cannot infer an appropriate lifetime\n LL |     let push_id = |installed_id: &CrateId| {\n-   |                                  - let's call the lifetime of this reference `'1`\n+   |                    ------------ `installed_id` is a reference that is only valid in the closure body\n ...\n LL |         lines_to_use.push(installed_id);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `installed_id` escapes the closure body here\n \n error: aborting due to previous error\n "}, {"sha": "1a18817e943655705c715e1c80a7ca952e5da007", "filename": "src/test/ui/borrowck/regions-escape-bound-fn-2.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.nll.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -4,15 +4,15 @@ warning: not reporting region error due to nll\n LL |     with_int(|y| x = Some(y));\n    |                           ^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/regions-escape-bound-fn-2.rs:18:18\n    |\n LL |     let mut x = None;\n-   |         ----- lifetime `'2` appears in the type of `x`\n+   |         ----- `x` is declared here, outside of the closure body\n LL |     with_int(|y| x = Some(y));\n-   |               -  ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n    |               |\n-   |               lifetime `'1` appears in this argument\n+   |               `y` is a reference that is only valid in the closure body\n \n error: aborting due to previous error\n "}, {"sha": "62ea9a0854bde9a1de42dd7b6b6289ae7d3e36ab", "filename": "src/test/ui/borrowck/regions-escape-bound-fn.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -4,15 +4,15 @@ warning: not reporting region error due to nll\n LL |     with_int(|y| x = Some(y));\n    |                      ^^^^^^^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/regions-escape-bound-fn.rs:18:18\n    |\n LL |     let mut x: Option<&isize> = None;\n-   |         ----- lifetime `'2` appears in the type of `x`\n+   |         ----- `x` is declared here, outside of the closure body\n LL |     with_int(|y| x = Some(y));\n-   |               -  ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n    |               |\n-   |               lifetime `'1` appears in this argument\n+   |               `y` is a reference that is only valid in the closure body\n \n error: aborting due to previous error\n "}, {"sha": "44eead9fb5a987e98f45469acdc8bafd4c5c522c", "filename": "src/test/ui/borrowck/regions-escape-unboxed-closure.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -4,15 +4,15 @@ warning: not reporting region error due to nll\n LL |     with_int(&mut |y| x = Some(y));\n    |                           ^^^^^^^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/regions-escape-unboxed-closure.rs:16:23\n    |\n LL |     let mut x: Option<&isize> = None;\n-   |         ----- lifetime `'2` appears in the type of `x`\n+   |         ----- `x` is declared here, outside of the closure body\n LL |     with_int(&mut |y| x = Some(y));\n-   |                    -  ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |                    -  ^^^^^^^^^^^ `y` escapes the closure body here\n    |                    |\n-   |                    lifetime `'1` appears in this argument\n+   |                    `y` is a reference that is only valid in the closure body\n \n error: aborting due to previous error\n "}, {"sha": "8658c618bf24ca6a6b6a31aed66d3e6cc788c7dc", "filename": "src/test/ui/closure-expected-type/expect-region-supply-region.nll.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -22,37 +22,37 @@ warning: not reporting region error due to nll\n LL |         f = Some(x);\n    |             ^^^^^^^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/expect-region-supply-region.rs:28:9\n    |\n LL |     let mut f: Option<&u32> = None;\n-   |         ----- lifetime `'2` appears in the type of `f`\n+   |         ----- `f` is declared here, outside of the closure body\n LL |     closure_expecting_bound(|x| {\n-   |                              - lifetime `'1` appears in this argument\n+   |                              - `x` is a reference that is only valid in the closure body\n LL |         f = Some(x); //~ ERROR borrowed data cannot be stored outside of its closure\n-   |         ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/expect-region-supply-region.rs:38:9\n    |\n LL |     let mut f: Option<&u32> = None;\n-   |         ----- lifetime `'2` appears in the type of `f`\n+   |         ----- `f` is declared here, outside of the closure body\n LL |     closure_expecting_bound(|x: &u32| {\n-   |                                 - let's call the lifetime of this reference `'1`\n+   |                              - `x` is a reference that is only valid in the closure body\n LL |         f = Some(x); //~ ERROR borrowed data cannot be stored outside of its closure\n-   |         ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/expect-region-supply-region.rs:52:9\n    |\n LL |     let mut f: Option<&u32> = None;\n-   |         ----- lifetime `'2` appears in the type of `f`\n+   |         ----- `f` is declared here, outside of the closure body\n ...\n LL |     closure_expecting_bound(|x: &'x u32| {\n-   |                                 - let's call the lifetime of this reference `'1`\n+   |                              - `x` is a reference that is only valid in the closure body\n ...\n LL |         f = Some(x);\n-   |         ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n \n error: aborting due to 3 previous errors\n "}, {"sha": "e26b1956d5e819632e0fb6d090636b36837f6375", "filename": "src/test/ui/in-band-lifetimes/impl/dyn-trait.nll.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fimpl%2Fdyn-trait.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fimpl%2Fdyn-trait.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fimpl%2Fdyn-trait.nll.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -4,11 +4,13 @@ warning: not reporting region error due to nll\n LL |     static_val(x); //~ ERROR cannot infer\n    |                ^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/dyn-trait.rs:32:5\n    |\n+LL | fn with_dyn_debug_static<'a>(x: Box<dyn Debug + 'a>) {\n+   |                              - `x` is a reference that is only valid in the closure body\n LL |     static_val(x); //~ ERROR cannot infer\n-   |     ^^^^^^^^^^^^^ argument requires that `'a` must outlive `'static`\n+   |     ^^^^^^^^^^^^^ `x` escapes the closure body here\n \n error: aborting due to previous error\n "}, {"sha": "f9dda27da0985b36f5d022e4598a1ca6783a859a", "filename": "src/test/ui/issue-16683.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fissue-16683.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fissue-16683.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-16683.nll.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -10,13 +10,13 @@ warning: not reporting region error due to nll\n LL |         self.a(); //~ ERROR cannot infer\n    |              ^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/issue-16683.rs:14:9\n    |\n LL |     fn b(&self) {\n-   |          - let's call the lifetime of this reference `'1`\n+   |          ----- `self` is a reference that is only valid in the closure body\n LL |         self.a(); //~ ERROR cannot infer\n-   |         ^^^^^^^^ argument requires that `'1` must outlive `'a`\n+   |         ^^^^^^^^ `self` escapes the closure body here\n \n error: aborting due to previous error\n "}, {"sha": "5775135aefc5feb472aaed348d862134190e0f28", "filename": "src/test/ui/issue-17758.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fissue-17758.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fissue-17758.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-17758.nll.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -10,13 +10,13 @@ warning: not reporting region error due to nll\n LL |         self.foo();\n    |              ^^^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/issue-17758.rs:17:9\n    |\n LL |     fn bar(&self) {\n-   |            - let's call the lifetime of this reference `'1`\n+   |            ----- `self` is a reference that is only valid in the closure body\n LL |         self.foo();\n-   |         ^^^^^^^^^^ argument requires that `'1` must outlive `'a`\n+   |         ^^^^^^^^^^ `self` escapes the closure body here\n \n error: aborting due to previous error\n "}, {"sha": "d51ba8201aaa62a168151c3ab24b0bf4b3393aeb", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -4,16 +4,16 @@ warning: not reporting region error due to nll\n LL |     foo(cell, |cell_a, cell_x| {\n    |     ^^^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:20\n    |\n LL |     foo(cell, |cell_a, cell_x| {\n-   |                ------  ------ lifetime `'1` appears in this argument\n+   |                ------  ------ `cell_x` is a reference that is only valid in the closure body\n    |                |\n-   |                lifetime `'2` appears in this argument\n+   |                `cell_a` is declared here, outside of the closure body\n LL |         //~^ WARNING not reporting region error due to nll\n LL |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-   |                    ^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |                    ^^^^^^^^^^^^ `cell_x` escapes the closure body here\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:15"}, {"sha": "3177cd7c28f647991730cc80908e060b638d12d8", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -23,16 +23,18 @@ LL | |     });\n    = note: number of external vids: 2\n    = note: where '_#1r: '_#0r\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:5\n    |\n+LL |   fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+   |                     ------ `cell_a` is a reference that is only valid in the closure body\n LL | /     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n LL | |         //~^ ERROR\n LL | |\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n LL | |     });\n-   | |______^ argument requires that `'a` must outlive `'static`\n+   | |______^ `cell_a` escapes the closure body here\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:44:1"}, {"sha": "089c88abcdd4aee5ae8fed1eed5a8630597668ed", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -23,16 +23,18 @@ LL | |     });\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#0r\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:5\n    |\n+LL |   fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+   |                     ------ `cell_a` is a reference that is only valid in the closure body\n LL | /     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n LL | |         //~^ ERROR\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n LL | |         //~^ WARNING not reporting region error due to nll\n LL | |     });\n-   | |______^ argument requires that `'a` must outlive `'static`\n+   | |______^ `cell_a` escapes the closure body here\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:47:1"}, {"sha": "8acf2ef51ecd2ef65b4c0ef822f3ba0085251fcd", "filename": "src/test/ui/nll/issue-50716.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32772fddd52013a38ece584279b6bc422b2d8b9b/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr?ref=32772fddd52013a38ece584279b6bc422b2d8b9b", "patch": "@@ -1,8 +1,11 @@\n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/issue-50716.rs:25:14\n    |\n+LL | fn foo<'a, T: 'static>(s: Box<<&'a T as A>::X>)\n+   |                        - `s` is a reference that is only valid in the closure body\n+...\n LL |     let _x = *s; //~ ERROR\n-   |              ^^ assignment requires that `'a` must outlive `'static`\n+   |              ^^ `s` escapes the closure body here\n \n error: aborting due to previous error\n "}]}