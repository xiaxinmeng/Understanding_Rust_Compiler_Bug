{"sha": "68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YjFhYzk4NzQ0YjhlMDNiYmNjNWFiMzhmM2FmYmQwNGYxZWMwOTc=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-26T11:16:36Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-26T11:23:35Z"}, "message": "Reduce righward drift.", "tree": {"sha": "91158459747784e66944ba2225d3d1c2b4555d1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91158459747784e66944ba2225d3d1c2b4555d1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097", "html_url": "https://github.com/rust-lang/rust/commit/68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d5f721406d7ec1cb0197181a03bd266d66fd6c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d5f721406d7ec1cb0197181a03bd266d66fd6c1", "html_url": "https://github.com/rust-lang/rust/commit/9d5f721406d7ec1cb0197181a03bd266d66fd6c1"}], "stats": {"total": 323, "additions": 160, "deletions": 163}, "files": [{"sha": "d9d475813b073caf1174ee736dc44092c30cc634", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 127, "deletions": 129, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097", "patch": "@@ -343,153 +343,151 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         registry: rustc_driver::diagnostics_registry(),\n     };\n \n-    interface::run_compiler_in_existing_thread_pool(config, |compiler| {\n-        compiler.enter(|queries| {\n-            let sess = compiler.session();\n-\n-            // We need to hold on to the complete resolver, so we cause everything to be\n-            // cloned for the analysis passes to use. Suboptimal, but necessary in the\n-            // current architecture.\n-            let resolver = {\n-                let parts = abort_on_err(queries.expansion(), sess).peek();\n-                let resolver = parts.1.borrow();\n-\n-                // Before we actually clone it, let's force all the extern'd crates to\n-                // actually be loaded, just in case they're only referred to inside\n-                // intra-doc-links\n-                resolver.borrow_mut().access(|resolver| {\n-                    for extern_name in &extern_names {\n-                        resolver.resolve_str_path_error(\n-                            DUMMY_SP, extern_name, TypeNS, CRATE_NODE_ID\n-                        ).unwrap_or_else(\n-                            |()| panic!(\"Unable to resolve external crate {}\", extern_name)\n-                        );\n-                    }\n-                });\n+    interface::run_compiler_in_existing_thread_pool(config, |compiler| { compiler.enter(|queries| {\n+        let sess = compiler.session();\n+\n+        // We need to hold on to the complete resolver, so we cause everything to be\n+        // cloned for the analysis passes to use. Suboptimal, but necessary in the\n+        // current architecture.\n+        let resolver = {\n+            let parts = abort_on_err(queries.expansion(), sess).peek();\n+            let resolver = parts.1.borrow();\n+\n+            // Before we actually clone it, let's force all the extern'd crates to\n+            // actually be loaded, just in case they're only referred to inside\n+            // intra-doc-links\n+            resolver.borrow_mut().access(|resolver| {\n+                for extern_name in &extern_names {\n+                    resolver.resolve_str_path_error(\n+                        DUMMY_SP, extern_name, TypeNS, CRATE_NODE_ID\n+                    ).unwrap_or_else(\n+                        |()| panic!(\"Unable to resolve external crate {}\", extern_name)\n+                    );\n+                }\n+            });\n+\n+            // Now we're good to clone the resolver because everything should be loaded\n+            resolver.clone()\n+        };\n+\n+        if sess.has_errors() {\n+            sess.fatal(\"Compilation failed, aborting rustdoc\");\n+        }\n+\n+        let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n \n-                // Now we're good to clone the resolver because everything should be loaded\n-                resolver.clone()\n+        global_ctxt.enter(|tcx| {\n+            tcx.analysis(LOCAL_CRATE).ok();\n+\n+            // Abort if there were any errors so far\n+            sess.abort_if_errors();\n+\n+            let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n+            // Convert from a HirId set to a DefId set since we don't always have easy access\n+            // to the map from defid -> hirid\n+            let access_levels = AccessLevels {\n+                map: access_levels.map.iter()\n+                                    .map(|(&k, &v)| (tcx.hir().local_def_id(k), v))\n+                                    .collect()\n             };\n \n-            if sess.has_errors() {\n-                sess.fatal(\"Compilation failed, aborting rustdoc\");\n-            }\n+            let mut renderinfo = RenderInfo::default();\n+            renderinfo.access_levels = access_levels;\n+\n+            let mut ctxt = DocContext {\n+                tcx,\n+                resolver,\n+                external_traits: Default::default(),\n+                active_extern_traits: Default::default(),\n+                renderinfo: RefCell::new(renderinfo),\n+                ty_substs: Default::default(),\n+                lt_substs: Default::default(),\n+                ct_substs: Default::default(),\n+                impl_trait_bounds: Default::default(),\n+                fake_def_ids: Default::default(),\n+                all_fake_def_ids: Default::default(),\n+                generated_synthetics: Default::default(),\n+                auto_traits: tcx.all_traits(LOCAL_CRATE).iter().cloned().filter(|trait_def_id| {\n+                    tcx.trait_is_auto(*trait_def_id)\n+                }).collect(),\n+            };\n+            debug!(\"crate: {:?}\", tcx.hir().krate());\n \n-            let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n-\n-            global_ctxt.enter(|tcx| {\n-                tcx.analysis(LOCAL_CRATE).ok();\n-\n-                // Abort if there were any errors so far\n-                sess.abort_if_errors();\n-\n-                let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n-                // Convert from a HirId set to a DefId set since we don't always have easy access\n-                // to the map from defid -> hirid\n-                let access_levels = AccessLevels {\n-                    map: access_levels.map.iter()\n-                                        .map(|(&k, &v)| (tcx.hir().local_def_id(k), v))\n-                                        .collect()\n-                };\n-\n-                let mut renderinfo = RenderInfo::default();\n-                renderinfo.access_levels = access_levels;\n-\n-                let mut ctxt = DocContext {\n-                    tcx,\n-                    resolver,\n-                    external_traits: Default::default(),\n-                    active_extern_traits: Default::default(),\n-                    renderinfo: RefCell::new(renderinfo),\n-                    ty_substs: Default::default(),\n-                    lt_substs: Default::default(),\n-                    ct_substs: Default::default(),\n-                    impl_trait_bounds: Default::default(),\n-                    fake_def_ids: Default::default(),\n-                    all_fake_def_ids: Default::default(),\n-                    generated_synthetics: Default::default(),\n-                    auto_traits: tcx.all_traits(LOCAL_CRATE).iter().cloned().filter(|trait_def_id| {\n-                        tcx.trait_is_auto(*trait_def_id)\n-                    }).collect(),\n-                };\n-                debug!(\"crate: {:?}\", tcx.hir().krate());\n-\n-                let mut krate = clean::krate(&mut ctxt);\n-\n-                fn report_deprecated_attr(name: &str, diag: &errors::Handler) {\n-                    let mut msg = diag.struct_warn(&format!(\"the `#![doc({})]` attribute is \\\n-                                                             considered deprecated\", name));\n-                    msg.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n-\n-                    if name == \"no_default_passes\" {\n-                        msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n-                    }\n+            let mut krate = clean::krate(&mut ctxt);\n+\n+            fn report_deprecated_attr(name: &str, diag: &errors::Handler) {\n+                let mut msg = diag.struct_warn(&format!(\"the `#![doc({})]` attribute is \\\n+                                                         considered deprecated\", name));\n+                msg.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n \n-                    msg.emit();\n+                if name == \"no_default_passes\" {\n+                    msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n                 }\n \n-                // Process all of the crate attributes, extracting plugin metadata along\n-                // with the passes which we are supposed to run.\n-                for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n-                    let diag = ctxt.sess().diagnostic();\n-\n-                    let name = attr.name_or_empty();\n-                    if attr.is_word() {\n-                        if name == sym::no_default_passes {\n-                            report_deprecated_attr(\"no_default_passes\", diag);\n-                            if default_passes == passes::DefaultPassOption::Default {\n-                                default_passes = passes::DefaultPassOption::None;\n-                            }\n-                        }\n-                    } else if let Some(value) = attr.value_str() {\n-                        let sink = match name {\n-                            sym::passes => {\n-                                report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n-                                &mut manual_passes\n-                            },\n-                            sym::plugins => {\n-                                report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n-                                eprintln!(\"WARNING: `#![doc(plugins = \\\"...\\\")]` \\\n-                                          no longer functions; see CVE-2018-1000622\");\n-                                continue\n-                            },\n-                            _ => continue,\n-                        };\n-                        for name in value.as_str().split_whitespace() {\n-                            sink.push(name.to_string());\n-                        }\n-                    }\n+                msg.emit();\n+            }\n+\n+            // Process all of the crate attributes, extracting plugin metadata along\n+            // with the passes which we are supposed to run.\n+            for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n+                let diag = ctxt.sess().diagnostic();\n \n-                    if attr.is_word() && name == sym::document_private_items {\n+                let name = attr.name_or_empty();\n+                if attr.is_word() {\n+                    if name == sym::no_default_passes {\n+                        report_deprecated_attr(\"no_default_passes\", diag);\n                         if default_passes == passes::DefaultPassOption::Default {\n-                            default_passes = passes::DefaultPassOption::Private;\n+                            default_passes = passes::DefaultPassOption::None;\n                         }\n                     }\n+                } else if let Some(value) = attr.value_str() {\n+                    let sink = match name {\n+                        sym::passes => {\n+                            report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n+                            &mut manual_passes\n+                        },\n+                        sym::plugins => {\n+                            report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n+                            eprintln!(\"WARNING: `#![doc(plugins = \\\"...\\\")]` \\\n+                                      no longer functions; see CVE-2018-1000622\");\n+                            continue\n+                        },\n+                        _ => continue,\n+                    };\n+                    for name in value.as_str().split_whitespace() {\n+                        sink.push(name.to_string());\n+                    }\n                 }\n \n-                let passes = passes::defaults(default_passes).iter().chain(manual_passes.into_iter()\n-                    .flat_map(|name| {\n-                        if let Some(pass) = passes::find_pass(&name) {\n-                            Some(pass)\n-                        } else {\n-                            error!(\"unknown pass {}, skipping\", name);\n-                            None\n-                        }\n-                    }));\n+                if attr.is_word() && name == sym::document_private_items {\n+                    if default_passes == passes::DefaultPassOption::Default {\n+                        default_passes = passes::DefaultPassOption::Private;\n+                    }\n+                }\n+            }\n+\n+            let passes = passes::defaults(default_passes).iter().chain(manual_passes.into_iter()\n+                .flat_map(|name| {\n+                    if let Some(pass) = passes::find_pass(&name) {\n+                        Some(pass)\n+                    } else {\n+                        error!(\"unknown pass {}, skipping\", name);\n+                        None\n+                    }\n+                }));\n \n-                info!(\"Executing passes\");\n+            info!(\"Executing passes\");\n \n-                for pass in passes {\n-                    debug!(\"running pass {}\", pass.name);\n-                    krate = (pass.pass)(krate, &ctxt);\n-                }\n+            for pass in passes {\n+                debug!(\"running pass {}\", pass.name);\n+                krate = (pass.pass)(krate, &ctxt);\n+            }\n \n-                ctxt.sess().abort_if_errors();\n+            ctxt.sess().abort_if_errors();\n \n-                (krate, ctxt.renderinfo.into_inner(), render_options)\n-            })\n+            (krate, ctxt.renderinfo.into_inner(), render_options)\n         })\n-    })\n+    }) })\n }\n \n /// `DefId` or parameter index (`ty::ParamTy.index`) of a synthetic type parameter"}, {"sha": "4cb97ccb0bf638a42375850ae0d8518023dbd799", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=68b1ac98744b8e03bbcc5ab38f3afbd04f1ec097", "patch": "@@ -85,42 +85,41 @@ pub fn run(options: Options) -> i32 {\n     let mut test_args = options.test_args.clone();\n     let display_warnings = options.display_warnings;\n \n-    let tests = interface::run_compiler(config, |compiler| -> Result<_, ErrorReported> {\n-        compiler.enter(|queries| {\n-            let lower_to_hir = queries.lower_to_hir()?;\n-\n-            let mut opts = scrape_test_config(lower_to_hir.peek().0.borrow().krate());\n-            opts.display_warnings |= options.display_warnings;\n-            let enable_per_target_ignores = options.enable_per_target_ignores;\n-            let mut collector = Collector::new(\n-                queries.crate_name()?.peek().to_string(),\n-                options,\n-                false,\n-                opts,\n-                Some(compiler.source_map().clone()),\n-                None,\n-                enable_per_target_ignores,\n-            );\n-\n-            let mut global_ctxt = queries.global_ctxt()?.take();\n-\n-            global_ctxt.enter(|tcx| {\n-                let krate = tcx.hir().krate();\n-                let mut hir_collector = HirCollector {\n-                    sess: compiler.session(),\n-                    collector: &mut collector,\n-                    map: tcx.hir(),\n-                    codes: ErrorCodes::from(compiler.session().opts\n-                                                    .unstable_features.is_nightly_build()),\n-                };\n-                hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n-                    intravisit::walk_crate(this, krate);\n-                });\n+    let tests = interface::run_compiler(config, |compiler| { compiler.enter(|queries| {\n+        let lower_to_hir = queries.lower_to_hir()?;\n+\n+        let mut opts = scrape_test_config(lower_to_hir.peek().0.borrow().krate());\n+        opts.display_warnings |= options.display_warnings;\n+        let enable_per_target_ignores = options.enable_per_target_ignores;\n+        let mut collector = Collector::new(\n+            queries.crate_name()?.peek().to_string(),\n+            options,\n+            false,\n+            opts,\n+            Some(compiler.source_map().clone()),\n+            None,\n+            enable_per_target_ignores,\n+        );\n+\n+        let mut global_ctxt = queries.global_ctxt()?.take();\n+\n+        global_ctxt.enter(|tcx| {\n+            let krate = tcx.hir().krate();\n+            let mut hir_collector = HirCollector {\n+                sess: compiler.session(),\n+                collector: &mut collector,\n+                map: tcx.hir(),\n+                codes: ErrorCodes::from(compiler.session().opts\n+                                                .unstable_features.is_nightly_build()),\n+            };\n+            hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n+                intravisit::walk_crate(this, krate);\n             });\n+        });\n \n-            Ok(collector.tests)\n-        })\n-    }).expect(\"compiler aborted in rustdoc!\");\n+        let ret : Result<_, ErrorReported> = Ok(collector.tests);\n+        ret\n+    }) }).expect(\"compiler aborted in rustdoc!\");\n \n     test_args.insert(0, \"rustdoctest\".to_string());\n "}]}