{"sha": "b47e1e9eda303e42896821cbc8d9bbc127890abb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0N2UxZTllZGEzMDNlNDI4OTY4MjFjYmM4ZDliYmMxMjc4OTBhYmI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-16T22:55:55Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-16T23:20:54Z"}, "message": "modernize std::deque\n\n* use a proper exported data type with private fields\n* implement core::container::Container\n* use the current constructor convention\n* use explicit self\n* get rid of DVec and the mutable fields\n\nCloses #2343", "tree": {"sha": "044b3e6b85d20cb7f281f42fe2cead8c622e130a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/044b3e6b85d20cb7f281f42fe2cead8c622e130a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b47e1e9eda303e42896821cbc8d9bbc127890abb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b47e1e9eda303e42896821cbc8d9bbc127890abb", "html_url": "https://github.com/rust-lang/rust/commit/b47e1e9eda303e42896821cbc8d9bbc127890abb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b47e1e9eda303e42896821cbc8d9bbc127890abb/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d8c25b825f109c9ae33ff0e52a061b62ae9f434", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d8c25b825f109c9ae33ff0e52a061b62ae9f434", "html_url": "https://github.com/rust-lang/rust/commit/8d8c25b825f109c9ae33ff0e52a061b62ae9f434"}], "stats": {"total": 257, "additions": 116, "deletions": 141}, "files": [{"sha": "86b904be3cbe3cd3d730ab9bace616e66e77e485", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 109, "deletions": 132, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/b47e1e9eda303e42896821cbc8d9bbc127890abb/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47e1e9eda303e42896821cbc8d9bbc127890abb/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=b47e1e9eda303e42896821cbc8d9bbc127890abb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,145 +8,122 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A deque. Untested as of yet. Likely buggy\n-#[forbid(non_camel_case_types)];\n-\n+use core::container::{Container, Mutable};\n use core::cmp::Eq;\n-use core::dvec::DVec;\n-use core::dvec;\n use core::prelude::*;\n use core::uint;\n use core::vec;\n \n-pub trait Deque<T> {\n-    fn size() -> uint;\n-    fn add_front(v: T);\n-    fn add_back(v: T);\n-    fn pop_front() -> T;\n-    fn pop_back() -> T;\n-    fn peek_front() -> T;\n-    fn peek_back() -> T;\n-    fn get(int) -> T;\n+const initial_capacity: uint = 32u; // 2^5\n+\n+pub struct Deque<T> {\n+    priv nelts: uint,\n+    priv lo: uint,\n+    priv hi: uint,\n+    priv elts: ~[Option<T>]\n }\n \n-// FIXME (#2343) eventually, a proper datatype plus an exported impl would\n-// be preferrable.\n-pub fn create<T: Copy>() -> Deque<T> {\n-    type Cell<T> = Option<T>;\n+impl<T> Container for Deque<T> {\n+    pure fn len(&self) -> uint { self.nelts }\n+    pure fn is_empty(&self) -> bool { self.len() == 0 }\n+}\n \n-    let initial_capacity: uint = 32u; // 2^5\n-     /**\n-      * Grow is only called on full elts, so nelts is also len(elts), unlike\n-      * elsewhere.\n-      */\n-    fn grow<T: Copy>(nelts: uint, lo: uint, elts: ~[Cell<T>])\n-      -> ~[Cell<T>] {\n-        let mut elts = elts;\n-        assert (nelts == vec::len(elts));\n-        let mut rv = ~[];\n+impl<T: Copy> Deque<T> {\n+    static pure fn new() -> Deque<T> {\n+        Deque{nelts: 0, lo: 0, hi: 0,\n+              elts: vec::from_fn(initial_capacity, |_| None)}\n+    }\n \n-        let mut i = 0u;\n-        let nalloc = uint::next_power_of_two(nelts + 1u);\n-        while i < nalloc {\n-            if i < nelts {\n-                rv.push(elts[(lo + i) % nelts]);\n-            } else { rv.push(None); }\n-            i += 1u;\n+    fn add_front(&mut self, t: T) {\n+        let oldlo: uint = self.lo;\n+        if self.lo == 0u {\n+            self.lo = self.elts.len() - 1u;\n+        } else { self.lo -= 1u; }\n+        if self.lo == self.hi {\n+            self.elts = grow(self.nelts, oldlo, self.elts);\n+            self.lo = self.elts.len() - 1u;\n+            self.hi = self.nelts;\n         }\n+        self.elts[self.lo] = Some(t);\n+        self.nelts += 1u;\n+    }\n \n-        rv\n+    fn add_back(&mut self, t: T) {\n+        if self.lo == self.hi && self.nelts != 0u {\n+            self.elts = grow(self.nelts, self.lo, self.elts);\n+            self.lo = 0u;\n+            self.hi = self.nelts;\n+        }\n+        self.elts[self.hi] = Some(t);\n+        self.hi = (self.hi + 1u) % self.elts.len();\n+        self.nelts += 1u;\n     }\n-    fn get<T: Copy>(elts: &DVec<Cell<T>>, i: uint) -> T {\n-        match (*elts).get_elt(i) { Some(t) => t, _ => fail!() }\n+\n+    fn pop_front(&mut self) -> T {\n+        let t: T = get(self.elts, self.lo);\n+        self.elts[self.lo] = None;\n+        self.lo = (self.lo + 1u) % self.elts.len();\n+        self.nelts -= 1u;\n+        return t;\n     }\n \n-    struct Repr<T> {\n-        mut nelts: uint,\n-        mut lo: uint,\n-        mut hi: uint,\n-        elts: DVec<Cell<T>>,\n+    fn pop_back(&mut self) -> T {\n+        if self.hi == 0u {\n+            self.hi = self.elts.len() - 1u;\n+        } else { self.hi -= 1u; }\n+        let t: T = get(self.elts, self.hi);\n+        self.elts[self.hi] = None;\n+        self.nelts -= 1u;\n+        return t;\n     }\n \n-    impl<T: Copy> Deque<T> for Repr<T> {\n-        fn size() -> uint { return self.nelts; }\n-        fn add_front(t: T) {\n-            let oldlo: uint = self.lo;\n-            if self.lo == 0u {\n-                self.lo = self.elts.len() - 1u;\n-            } else { self.lo -= 1u; }\n-            if self.lo == self.hi {\n-                self.elts.swap(|v| grow(self.nelts, oldlo, v));\n-                self.lo = self.elts.len() - 1u;\n-                self.hi = self.nelts;\n-            }\n-            self.elts.set_elt(self.lo, Some(t));\n-            self.nelts += 1u;\n-        }\n-        fn add_back(t: T) {\n-            if self.lo == self.hi && self.nelts != 0u {\n-                self.elts.swap(|v| grow(self.nelts, self.lo, v));\n-                self.lo = 0u;\n-                self.hi = self.nelts;\n-            }\n-            self.elts.set_elt(self.hi, Some(t));\n-            self.hi = (self.hi + 1u) % self.elts.len();\n-            self.nelts += 1u;\n-        }\n-        /**\n-         * We actually release (turn to none()) the T we're popping so\n-         * that we don't keep anyone's refcount up unexpectedly.\n-         */\n-        fn pop_front() -> T {\n-            let t: T = get(&self.elts, self.lo);\n-            self.elts.set_elt(self.lo, None);\n-            self.lo = (self.lo + 1u) % self.elts.len();\n-            self.nelts -= 1u;\n-            return t;\n-        }\n-        fn pop_back() -> T {\n-            if self.hi == 0u {\n-                self.hi = self.elts.len() - 1u;\n-            } else { self.hi -= 1u; }\n-            let t: T = get(&self.elts, self.hi);\n-            self.elts.set_elt(self.hi, None);\n-            self.nelts -= 1u;\n-            return t;\n-        }\n-        fn peek_front() -> T { return get(&self.elts, self.lo); }\n-        fn peek_back() -> T { return get(&self.elts, self.hi - 1u); }\n-        fn get(i: int) -> T {\n-            let idx = (self.lo + (i as uint)) % self.elts.len();\n-            return get(&self.elts, idx);\n-        }\n+    fn peek_front(&self) -> T { return get(self.elts, self.lo); }\n+\n+    fn peek_back(&self) -> T { return get(self.elts, self.hi - 1u); }\n+\n+    fn get(&self, i: int) -> T {\n+        let idx = (self.lo + (i as uint)) % self.elts.len();\n+        return get(self.elts, idx);\n+    }\n+}\n+\n+/// Grow is only called on full elts, so nelts is also len(elts), unlike\n+/// elsewhere.\n+fn grow<T: Copy>(nelts: uint, lo: uint, elts: &[Option<T>]) -> ~[Option<T>] {\n+    assert nelts == elts.len();\n+    let mut rv = ~[];\n+\n+    let mut i = 0u;\n+    let nalloc = uint::next_power_of_two(nelts + 1u);\n+    while i < nalloc {\n+        if i < nelts {\n+            rv.push(elts[(lo + i) % nelts]);\n+        } else { rv.push(None); }\n+        i += 1u;\n     }\n \n-    let repr: Repr<T> = Repr {\n-        nelts: 0u,\n-        lo: 0u,\n-        hi: 0u,\n-        elts: dvec::from_vec(vec::from_elem(initial_capacity, None)),\n-    };\n+    rv\n+}\n \n-    repr as Deque::<T>\n+fn get<T: Copy>(elts: &[Option<T>], i: uint) -> T {\n+    match elts[i] { Some(t) => t, _ => fail!() }\n }\n \n #[cfg(test)]\n mod tests {\n     use core::prelude::*;\n-\n-    use deque::*;\n-    use deque;\n+    use super::*;\n \n     #[test]\n     fn test_simple() {\n-        let d: deque::Deque<int> = deque::create::<int>();\n-        assert (d.size() == 0u);\n+        let mut d = Deque::new();\n+        assert (d.len() == 0u);\n         d.add_front(17);\n         d.add_front(42);\n         d.add_back(137);\n-        assert (d.size() == 3u);\n+        assert (d.len() == 3u);\n         d.add_back(137);\n-        assert (d.size() == 4u);\n+        assert (d.len() == 4u);\n         log(debug, d.peek_front());\n         assert (d.peek_front() == 42);\n         log(debug, d.peek_back());\n@@ -163,15 +140,15 @@ mod tests {\n         i = d.pop_back();\n         log(debug, i);\n         assert (i == 17);\n-        assert (d.size() == 0u);\n+        assert (d.len() == 0u);\n         d.add_back(3);\n-        assert (d.size() == 1u);\n+        assert (d.len() == 1u);\n         d.add_front(2);\n-        assert (d.size() == 2u);\n+        assert (d.len() == 2u);\n         d.add_back(4);\n-        assert (d.size() == 3u);\n+        assert (d.len() == 3u);\n         d.add_front(1);\n-        assert (d.size() == 4u);\n+        assert (d.len() == 4u);\n         log(debug, d.get(0));\n         log(debug, d.get(1));\n         log(debug, d.get(2));\n@@ -189,59 +166,59 @@ mod tests {\n         let c: @int = @64;\n         let d: @int = @175;\n \n-        let deq: deque::Deque<@int> = deque::create::<@int>();\n-        assert (deq.size() == 0u);\n+        let mut deq = Deque::new();\n+        assert (deq.len() == 0u);\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        assert (deq.size() == 3u);\n+        assert (deq.len() == 3u);\n         deq.add_back(d);\n-        assert (deq.size() == 4u);\n+        assert (deq.len() == 4u);\n         assert (deq.peek_front() == b);\n         assert (deq.peek_back() == d);\n         assert (deq.pop_front() == b);\n         assert (deq.pop_back() == d);\n         assert (deq.pop_back() == c);\n         assert (deq.pop_back() == a);\n-        assert (deq.size() == 0u);\n+        assert (deq.len() == 0u);\n         deq.add_back(c);\n-        assert (deq.size() == 1u);\n+        assert (deq.len() == 1u);\n         deq.add_front(b);\n-        assert (deq.size() == 2u);\n+        assert (deq.len() == 2u);\n         deq.add_back(d);\n-        assert (deq.size() == 3u);\n+        assert (deq.len() == 3u);\n         deq.add_front(a);\n-        assert (deq.size() == 4u);\n+        assert (deq.len() == 4u);\n         assert (deq.get(0) == a);\n         assert (deq.get(1) == b);\n         assert (deq.get(2) == c);\n         assert (deq.get(3) == d);\n     }\n \n     fn test_parameterized<T: Copy Eq Durable>(a: T, b: T, c: T, d: T) {\n-        let deq: deque::Deque<T> = deque::create::<T>();\n-        assert (deq.size() == 0u);\n+        let mut deq = Deque::new();\n+        assert (deq.len() == 0u);\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        assert (deq.size() == 3u);\n+        assert (deq.len() == 3u);\n         deq.add_back(d);\n-        assert (deq.size() == 4u);\n+        assert (deq.len() == 4u);\n         assert deq.peek_front() == b;\n         assert deq.peek_back() == d;\n         assert deq.pop_front() == b;\n         assert deq.pop_back() == d;\n         assert deq.pop_back() == c;\n         assert deq.pop_back() == a;\n-        assert (deq.size() == 0u);\n+        assert (deq.len() == 0u);\n         deq.add_back(c);\n-        assert (deq.size() == 1u);\n+        assert (deq.len() == 1u);\n         deq.add_front(b);\n-        assert (deq.size() == 2u);\n+        assert (deq.len() == 2u);\n         deq.add_back(d);\n-        assert (deq.size() == 3u);\n+        assert (deq.len() == 3u);\n         deq.add_front(a);\n-        assert (deq.size() == 4u);\n+        assert (deq.len() == 4u);\n         assert deq.get(0) == a;\n         assert deq.get(1) == b;\n         assert deq.get(2) == c;"}, {"sha": "f1d5749e8402f84ce268180d744a9d1b5fc4a736", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b47e1e9eda303e42896821cbc8d9bbc127890abb/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47e1e9eda303e42896821cbc8d9bbc127890abb/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=b47e1e9eda303e42896821cbc8d9bbc127890abb", "patch": "@@ -23,7 +23,6 @@ use std::time;\n use std::oldmap;\n use std::oldmap::Map;\n use std::oldmap::HashMap;\n-use std::deque;\n use std::deque::Deque;\n use std::par;\n use core::io::WriterUtil;\n@@ -124,18 +123,18 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     let mut marks : ~[node_id]\n         = vec::from_elem(vec::len(graph), -1i64);\n \n-    let Q = deque::create();\n+    let mut q = Deque::new();\n \n-    Q.add_back(key);\n+    q.add_back(key);\n     marks[key] = key;\n \n-    while Q.size() > 0 {\n-        let t = Q.pop_front();\n+    while !q.is_empty() {\n+        let t = q.pop_front();\n \n         do graph[t].each() |k| {\n             if marks[*k] == -1i64 {\n                 marks[*k] = t;\n-                Q.add_back(*k);\n+                q.add_back(*k);\n             }\n             true\n         };"}, {"sha": "a7afa1d6f349429ec9d7ea8c39f415894c73dec6", "filename": "src/test/run-pass/issue-2383.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b47e1e9eda303e42896821cbc8d9bbc127890abb/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b47e1e9eda303e42896821cbc8d9bbc127890abb/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2383.rs?ref=b47e1e9eda303e42896821cbc8d9bbc127890abb", "patch": "@@ -11,10 +11,9 @@\n // except according to those terms.\n \n extern mod std;\n-use std::deque;\n use std::deque::Deque;\n \n pub fn main() {\n-    let Q = deque::create();\n-    Q.add_back(10);\n+    let mut q = Deque::new();\n+    q.add_back(10);\n }"}]}