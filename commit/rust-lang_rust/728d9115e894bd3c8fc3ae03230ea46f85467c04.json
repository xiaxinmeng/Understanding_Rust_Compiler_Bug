{"sha": "728d9115e894bd3c8fc3ae03230ea46f85467c04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOGQ5MTE1ZTg5NGJkM2M4ZmMzYWUwMzIzMGVhNDZmODU0NjdjMDQ=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-02-28T05:05:32Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-02-28T17:41:33Z"}, "message": "Fix windows\n\nAlso back out keepalive support for TCP since the API is perhaps not\nactually what we want. You can't read the interval on Windows, and\nwe should probably separate the functionality of turning keepalive on\nand overriding the interval.", "tree": {"sha": "3e5867efbe40eb47af9655ba457137cb1d1f82a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e5867efbe40eb47af9655ba457137cb1d1f82a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/728d9115e894bd3c8fc3ae03230ea46f85467c04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/728d9115e894bd3c8fc3ae03230ea46f85467c04", "html_url": "https://github.com/rust-lang/rust/commit/728d9115e894bd3c8fc3ae03230ea46f85467c04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/728d9115e894bd3c8fc3ae03230ea46f85467c04/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7", "html_url": "https://github.com/rust-lang/rust/commit/5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7"}], "stats": {"total": 229, "additions": 55, "deletions": 174}, "files": [{"sha": "0073b8f119afa6b72770a1f8aa717daf537c7edd", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/728d9115e894bd3c8fc3ae03230ea46f85467c04/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728d9115e894bd3c8fc3ae03230ea46f85467c04/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=728d9115e894bd3c8fc3ae03230ea46f85467c04", "patch": "@@ -203,34 +203,6 @@ impl TcpStream {\n         self.0.nodelay()\n     }\n \n-    /// Sets whether keepalive messages are enabled to be sent on this socket.\n-    ///\n-    /// On Unix, this option will set the `SO_KEEPALIVE` as well as the\n-    /// `TCP_KEEPALIVE` or `TCP_KEEPIDLE` option (depending on your platform).\n-    /// On Windows, this will set the `SIO_KEEPALIVE_VALS` option.\n-    ///\n-    /// If `None` is specified then keepalive messages are disabled, otherwise\n-    /// the duration specified will be the time to remain idle before sending a\n-    /// TCP keepalive probe.\n-    ///\n-    /// Some platforms specify this value in seconds, so sub-second\n-    /// specifications may be omitted.\n-    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n-    pub fn set_keepalive(&self, keepalive: Option<Duration>) -> io::Result<()> {\n-        self.0.set_keepalive(keepalive)\n-    }\n-\n-    /// Returns whether keepalive messages are enabled on this socket, and if so\n-    /// the duration of time between them.\n-    ///\n-    /// For more information about this option, see [`set_keepalive`][link].\n-    ///\n-    /// [link]: #tymethod.set_keepalive\n-    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n-    pub fn keepalive(&self) -> io::Result<Option<Duration>> {\n-        self.0.keepalive()\n-    }\n-\n     /// Sets the value for the `IP_TTL` option on this socket.\n     ///\n     /// This value sets the time-to-live field that is used in every packet sent\n@@ -1156,21 +1128,6 @@ mod tests {\n         assert_eq!(false, t!(stream.nodelay()));\n     }\n \n-    #[test]\n-    fn keepalive() {\n-        let addr = next_test_ip4();\n-        let _listener = t!(TcpListener::bind(&addr));\n-\n-        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n-        let dur = Duration::new(15410, 0);\n-\n-        assert_eq!(None, t!(stream.keepalive()));\n-        t!(stream.set_keepalive(Some(dur)));\n-        assert_eq!(Some(dur), t!(stream.keepalive()));\n-        t!(stream.set_keepalive(None));\n-        assert_eq!(None, t!(stream.keepalive()));\n-    }\n-\n     #[test]\n     fn ttl() {\n         let ttl = 100;"}, {"sha": "c8738fd1ba52475bb86ae8663012b936f95d4a55", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/728d9115e894bd3c8fc3ae03230ea46f85467c04/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728d9115e894bd3c8fc3ae03230ea46f85467c04/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=728d9115e894bd3c8fc3ae03230ea46f85467c04", "patch": "@@ -14,7 +14,7 @@ use cmp;\n use ffi::{CStr, CString};\n use fmt;\n use io::{self, Error, ErrorKind};\n-use libc::{c_int, c_char, c_void};\n+use libc::{c_int, c_char, c_void, c_uint};\n use mem;\n #[allow(deprecated)]\n use net::{SocketAddr, Shutdown, IpAddr, Ipv4Addr, Ipv6Addr};\n@@ -84,13 +84,13 @@ fn sockaddr_to_addr(storage: &c::sockaddr_storage,\n }\n \n #[cfg(target_os = \"android\")]\n-fn to_ipv6mr_interface(value: u32) -> c::c_int {\n-    value as c::c_int\n+fn to_ipv6mr_interface(value: u32) -> c_int {\n+    value as c_int\n }\n \n #[cfg(not(target_os = \"android\"))]\n-fn to_ipv6mr_interface(value: u32) -> c::c_uint {\n-    value as c::c_uint\n+fn to_ipv6mr_interface(value: u32) -> c_uint {\n+    value as c_uint\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -239,20 +239,11 @@ impl TcpStream {\n     }\n \n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n-        setsockopt(&self.inner, c::IPPROTO_TCP, c::TCP_NODELAY, nodelay as c_int)\n+        self.inner.set_nodelay(nodelay)\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n-        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_TCP, c::TCP_NODELAY));\n-        Ok(raw != 0)\n-    }\n-\n-    pub fn set_keepalive(&self, keepalive: Option<Duration>) -> io::Result<()> {\n-        self.inner.set_keepalive(keepalive)\n-    }\n-\n-    pub fn keepalive(&self) -> io::Result<Option<Duration>> {\n-        self.inner.keepalive()\n+        self.inner.nodelay()\n     }\n \n     pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {"}, {"sha": "8785da51986dbe1192e3aa8046968c03ba093d80", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 5, "deletions": 39, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/728d9115e894bd3c8fc3ae03230ea46f85467c04/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728d9115e894bd3c8fc3ae03230ea46f85467c04/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=728d9115e894bd3c8fc3ae03230ea46f85467c04", "patch": "@@ -35,16 +35,6 @@ use libc::SOCK_CLOEXEC;\n #[cfg(not(target_os = \"linux\"))]\n const SOCK_CLOEXEC: c_int = 0;\n \n-#[cfg(any(target_os = \"openbsd\", taret_os = \"freebsd\"))]\n-use libc::SO_KEEPALIVE as TCP_KEEPALIVE;\n-#[cfg(any(target_os = \"macos\", taret_os = \"ios\"))]\n-use libc::TCP_KEEPALIVE;\n-#[cfg(not(any(target_os = \"openbsd\",\n-              target_os = \"freebsd\",\n-              target_os = \"macos\",\n-              target_os = \"ios\")))]\n-use libc::TCP_KEEPIDLE as TCP_KEEPALIVE;\n-\n pub struct Socket(FileDesc);\n \n pub fn init() {}\n@@ -179,37 +169,13 @@ impl Socket {\n         Ok(())\n     }\n \n-    pub fn set_keepalive(&self, keepalive: Option<Duration>) -> io::Result<()> {\n-        try!(setsockopt(self,\n-                        libc::SOL_SOCKET,\n-                        libc::SO_KEEPALIVE,\n-                        keepalive.is_some() as libc::c_int));\n-        if let Some(dur) = keepalive {\n-            let mut raw = dur.as_secs();\n-            if dur.subsec_nanos() > 0 {\n-                raw = raw.saturating_add(1);\n-            }\n-\n-            let raw = if raw > libc::c_int::max_value() as u64 {\n-                libc::c_int::max_value()\n-            } else {\n-                raw as libc::c_int\n-            };\n-\n-            try!(setsockopt(self, libc::IPPROTO_TCP, TCP_KEEPALIVE, raw));\n-        }\n-\n-        Ok(())\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        setsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY, nodelay as c_int)\n     }\n \n-    pub fn keepalive(&self) -> io::Result<Option<Duration>> {\n-        let raw: c_int = try!(getsockopt(self, libc::SOL_SOCKET, libc::SO_KEEPALIVE));\n-        if raw == 0 {\n-            return Ok(None);\n-        }\n-\n-        let raw: c_int = try!(getsockopt(self, libc::IPPROTO_TCP, TCP_KEEPALIVE));\n-        Ok(Some(Duration::from_secs(raw as u64)))\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY));\n+        Ok(raw != 0)\n     }\n \n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {"}, {"sha": "472ffdf9e1d93d20a95e942951843bafcc4013bb", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/728d9115e894bd3c8fc3ae03230ea46f85467c04/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728d9115e894bd3c8fc3ae03230ea46f85467c04/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=728d9115e894bd3c8fc3ae03230ea46f85467c04", "patch": "@@ -13,7 +13,7 @@\n #![allow(bad_style)]\n #![cfg_attr(test, allow(dead_code))]\n \n-use os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort};\n+use os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort,};\n use os::raw::{c_char, c_ulonglong};\n use libc::{wchar_t, size_t, c_void};\n use ptr;\n@@ -78,13 +78,6 @@ pub type SOCKET = ::os::windows::raw::SOCKET;\n pub type socklen_t = c_int;\n pub type ADDRESS_FAMILY = USHORT;\n \n-pub type LPWSAOVERLAPPED_COMPLETION_ROUTINE =\n-    Option<unsafe extern \"system\" fn(dwError: DWORD,\n-                                     cbTransferred: DWORD,\n-                                     lpOverlapped: LPWSAOVERLAPPED,\n-                                     dwFlags: DWORD)>;\n-pub type LPWSAOVERLAPPED = *mut OVERLAPPED;\n-\n pub const TRUE: BOOL = 1;\n pub const FALSE: BOOL = 0;\n \n@@ -121,7 +114,6 @@ pub const FILE_FLAG_OPEN_REPARSE_POINT: DWORD = 0x00200000;\n pub const FILE_FLAG_BACKUP_SEMANTICS: DWORD = 0x02000000;\n pub const SECURITY_SQOS_PRESENT: DWORD = 0x00100000;\n \n-pub const SIO_KEEPALIVE_VALS: DWORD = 0x98000004;\n pub const FIONBIO: c_ulong = 0x8004667e;\n \n #[repr(C)]\n@@ -233,6 +225,33 @@ pub const SOL_SOCKET: c_int = 0xffff;\n pub const SO_RCVTIMEO: c_int = 0x1006;\n pub const SO_SNDTIMEO: c_int = 0x1005;\n pub const SO_REUSEADDR: c_int = 0x0004;\n+pub const IPPROTO_IP: c_int = 0;\n+pub const IPPROTO_TCP: c_int = 6;\n+pub const IPPROTO_IPV6: c_int = 41;\n+pub const TCP_NODELAY: c_int = 0x0001;\n+pub const IP_TTL: c_int = 4;\n+pub const IPV6_V6ONLY: c_int = 27;\n+pub const SO_ERROR: c_int = 0x1007;\n+pub const SO_BROADCAST: c_int = 0x0020;\n+pub const IP_MULTICAST_LOOP: c_int = 11;\n+pub const IPV6_MULTICAST_LOOP: c_int = 11;\n+pub const IP_MULTICAST_TTL: c_int = 10;\n+pub const IP_ADD_MEMBERSHIP: c_int = 12;\n+pub const IP_DROP_MEMBERSHIP: c_int = 13;\n+pub const IPV6_ADD_MEMBERSHIP: c_int = 12;\n+pub const IPV6_DROP_MEMBERSHIP: c_int = 13;\n+\n+#[repr(C)]\n+pub struct ip_mreq {\n+    pub imr_multiaddr: in_addr,\n+    pub imr_interface: in_addr,\n+}\n+\n+#[repr(C)]\n+pub struct ipv6_mreq {\n+    pub ipv6mr_multiaddr: in6_addr,\n+    pub ipv6mr_interface: c_uint,\n+}\n \n pub const VOLUME_NAME_DOS: DWORD = 0x0;\n pub const MOVEFILE_REPLACE_EXISTING: DWORD = 1;\n@@ -785,13 +804,6 @@ pub struct in6_addr {\n     pub s6_addr: [u8; 16],\n }\n \n-#[repr(C)]\n-pub struct tcp_keepalive {\n-    pub onoff: c_ulong,\n-    pub keepalivetime: c_ulong,\n-    pub keepaliveinterval: c_ulong,\n-}\n-\n #[cfg(all(target_arch = \"x86_64\", target_env = \"gnu\"))]\n pub enum UNWIND_HISTORY_TABLE {}\n \n@@ -850,17 +862,7 @@ extern \"system\" {\n                       lpProtocolInfo: LPWSAPROTOCOL_INFO,\n                       g: GROUP,\n                       dwFlags: DWORD) -> SOCKET;\n-    pub fn WSAIoctl(s: SOCKET,\n-                    dwIoControlCode: DWORD,\n-                    lpvInBuffer: LPVOID,\n-                    cbInBuffer: DWORD,\n-                    lpvOutBuffer: LPVOID,\n-                    cbOutBuffer: DWORD,\n-                    lpcbBytesReturned: LPDWORD,\n-                    lpOverlapped: LPWSAOVERLAPPED,\n-                    lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE)\n-                    -> c_int;\n-    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut u_long) -> c_int;\n+    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;\n     pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;"}, {"sha": "dfa44a651e61ccabea96f1101c3897c3f4a7e96d", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 14, "deletions": 49, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/728d9115e894bd3c8fc3ae03230ea46f85467c04/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728d9115e894bd3c8fc3ae03230ea46f85467c04/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=728d9115e894bd3c8fc3ae03230ea46f85467c04", "patch": "@@ -10,7 +10,7 @@\n \n use cmp;\n use io;\n-use libc::{c_int, c_void};\n+use libc::{c_int, c_void, c_ulong};\n use mem;\n use net::{SocketAddr, Shutdown};\n use num::One;\n@@ -186,58 +186,23 @@ impl Socket {\n         Ok(())\n     }\n \n-    pub fn set_keepalive(&self, keepalive: Option<Duration>) -> io::Result<()> {\n-        let ms = keepalive.map(sys::dur2timeout).unwrap_or(c::INFINITE);\n-        let ka = c::tcp_keepalive {\n-            onoff: keepalive.is_some() as c::c_ulong,\n-            keepalivetime: ms as c::c_ulong,\n-            keepaliveinterval: ms as c::c_ulong,\n-        };\n-        sys::cvt(unsafe {\n-            c::WSAIoctl(self.0,\n-                        c::SIO_KEEPALIVE_VALS,\n-                        &ka as *const _ as *mut _,\n-                        mem::size_of_val(&ka) as c::DWORD,\n-                        0 as *mut _,\n-                        0,\n-                        0 as *mut _,\n-                        0 as *mut _,\n-                        None)\n-        }).map(|_| ())\n-    }\n-\n-    pub fn keepalive(&self) -> io::Result<Option<Duration>> {\n-        let mut ka = c::tcp_keepalive {\n-            onoff: 0,\n-            keepalivetime: 0,\n-            keepaliveinterval: 0,\n-        };\n-        try!(sys::cvt(unsafe {\n-            WSAIoctl(self.0,\n-                     c::SIO_KEEPALIVE_VALS,\n-                     0 as *mut _,\n-                     0,\n-                     &mut ka as *mut _ as *mut _,\n-                     mem::size_of_val(&ka) as c::DWORD,\n-                     0 as *mut _,\n-                     0 as *mut _,\n-                     None)\n-        }));\n-\n-        if ka.onoff == 0 {\n-            Ok(None)\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let mut nonblocking = nonblocking as c_ulong;\n+        let r = unsafe { c::ioctlsocket(self.0, c::FIONBIO as c_int, &mut nonblocking) };\n+        if r == 0 {\n+            Ok(())\n         } else {\n-            let secs = ka.keepaliveinterval / 1000;\n-            let nsec = (ka.keepaliveinterval % 1000) * 1000000;\n-            Ok(Some(Duration::new(secs as u64, nsec as u32)))\n+            Err(io::Error::last_os_error())\n         }\n     }\n \n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        let mut nonblocking = nonblocking as c::c_ulong;\n-        sys::cvt(unsafe {\n-            c::ioctlsocket(self.0, c::FIONBIO as c::c_int, &mut nonblocking)\n-        }).map(|_| ())\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        net::setsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY, nodelay as c::BYTE)\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        let raw: c::BYTE = try!(net::getsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY));\n+        Ok(raw != 0)\n     }\n }\n "}]}