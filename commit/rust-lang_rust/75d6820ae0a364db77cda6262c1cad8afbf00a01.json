{"sha": "75d6820ae0a364db77cda6262c1cad8afbf00a01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZDY4MjBhZTBhMzY0ZGI3N2NkYTYyNjJjMWNhZDhhZmJmMDBhMDE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-17T14:38:16Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-29T11:17:15Z"}, "message": "Track closure signatures & kinds in freshened types\n\nThis allows caching closure signatures and kinds in the normal selection\nand evaluation caches, and fixes the exponential worst-case in\n@remram44's example, which is a part of #43787.\n\nThis improvement is complenentary to #43999 - they fix different cases.", "tree": {"sha": "934b7f6203dbe44405e1a2f22fcee1b44042def8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/934b7f6203dbe44405e1a2f22fcee1b44042def8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75d6820ae0a364db77cda6262c1cad8afbf00a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75d6820ae0a364db77cda6262c1cad8afbf00a01", "html_url": "https://github.com/rust-lang/rust/commit/75d6820ae0a364db77cda6262c1cad8afbf00a01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75d6820ae0a364db77cda6262c1cad8afbf00a01/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f82dea299e7a8c4aa149196545917043f66af2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f82dea299e7a8c4aa149196545917043f66af2f", "html_url": "https://github.com/rust-lang/rust/commit/6f82dea299e7a8c4aa149196545917043f66af2f"}], "stats": {"total": 215, "additions": 155, "deletions": 60}, "files": [{"sha": "c274f8bda9fb054d4bce1434af121dc48cbadabf", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 146, "deletions": 4, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/75d6820ae0a364db77cda6262c1cad8afbf00a01/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d6820ae0a364db77cda6262c1cad8afbf00a01/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=75d6820ae0a364db77cda6262c1cad8afbf00a01", "patch": "@@ -19,10 +19,21 @@\n //! fact an unbound type variable, we want the match to be regarded as ambiguous, because depending\n //! on what type that type variable is ultimately assigned, the match may or may not succeed.\n //!\n+//! To handle closures, freshened types also have to contain the signature and kind of any\n+//! closure in the local inference context, as otherwise the cache key might be invalidated.\n+//! The way this is done is somewhat hacky - the closure signature is appended to the substs,\n+//! as well as the closure kind \"encoded\" as a type. Also, special handling is needed when\n+//! the closure signature contains a reference to the original closure.\n+//!\n //! Note that you should be careful not to allow the output of freshening to leak to the user in\n //! error messages or in any other form. Freshening is only really useful as an internal detail.\n //!\n-//! __An important detail concerning regions.__ The freshener also replaces *all* regions with\n+//! Because of the manipulation required to handle closures, doing arbitrary operations on\n+//! freshened types is not recommended. However, in addition to doing equality/hash\n+//! comparisons (for caching), it is possible to do a `ty::_match` operation between\n+//! 2 freshened types - this works even with the closure encoding.\n+//!\n+//! __An important detail concerning regions.__ The freshener also replaces *all* free regions with\n //! 'erased. The reason behind this is that, in general, we do not take region relationships into\n //! account when making type-overloaded decisions. This is important because of the design of the\n //! region inferencer, which is not based on unification but rather on accumulating and then\n@@ -32,7 +43,10 @@\n \n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeFolder;\n+use ty::subst::Substs;\n use util::nodemap::FxHashMap;\n+use hir::def_id::DefId;\n+\n use std::collections::hash_map::Entry;\n \n use super::InferCtxt;\n@@ -42,6 +56,7 @@ pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     freshen_count: u32,\n     freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n+    closure_set: Vec<DefId>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -51,6 +66,7 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n             infcx,\n             freshen_count: 0,\n             freshen_map: FxHashMap(),\n+            closure_set: vec![],\n         }\n     }\n \n@@ -76,6 +92,88 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    fn next_fresh<F>(&mut self,\n+                     freshener: F)\n+                     -> Ty<'tcx>\n+        where F: FnOnce(u32) -> ty::InferTy,\n+    {\n+        let index = self.freshen_count;\n+        self.freshen_count += 1;\n+        self.infcx.tcx.mk_infer(freshener(index))\n+    }\n+\n+    fn freshen_closure_like<M, C>(&mut self,\n+                                  def_id: DefId,\n+                                  substs: ty::ClosureSubsts<'tcx>,\n+                                  t: Ty<'tcx>,\n+                                  markers: M,\n+                                  combine: C)\n+                                  -> Ty<'tcx>\n+        where M: FnOnce(&mut Self) -> (Ty<'tcx>, Ty<'tcx>),\n+              C: FnOnce(&'tcx Substs<'tcx>) -> Ty<'tcx>\n+    {\n+        let tcx = self.infcx.tcx;\n+\n+        let closure_in_progress = self.infcx.in_progress_tables.map_or(false, |tables| {\n+            tcx.hir.as_local_node_id(def_id).map_or(false, |closure_id| {\n+                tables.borrow().local_id_root ==\n+                    Some(DefId::local(tcx.hir.node_to_hir_id(closure_id).owner))\n+            })\n+        });\n+\n+        if !closure_in_progress {\n+            // If this closure belongs to another infcx, its kind etc. were\n+            // fully inferred and its signature/kind are exactly what's listed\n+            // in its infcx. So we don't need to add the markers for them.\n+            return t.super_fold_with(self);\n+        }\n+\n+        // We are encoding a closure in progress. Because we want our freshening\n+        // key to contain all inference information needed to make sense of our\n+        // value, we need to encode the closure signature and kind. The way\n+        // we do that is to add them as 2 variables to the closure substs,\n+        // basically because it's there (and nobody cares about adding extra stuff\n+        // to substs).\n+        //\n+        // This means the \"freshened\" closure substs ends up looking like\n+        //     fresh_substs = [PARENT_SUBSTS* ; UPVARS* ; SIG_MARKER ; KIND_MARKER]\n+        let (marker_1, marker_2) = if self.closure_set.contains(&def_id) {\n+            // We found the closure def-id within its own signature. Just\n+            // leave a new freshened type - any matching operations would\n+            // have found and compared the exterior closure already to\n+            // get here.\n+            //\n+            // In that case, we already know what the signature would\n+            // be - the parent closure on the stack already contains a\n+            // \"copy\" of the signature, so there is no reason to encode\n+            // it again for injectivity. Just use a fresh type variable\n+            // to make everything comparable.\n+            //\n+            // For example (closure kinds omitted for clarity)\n+            //     t=[closure FOO sig=[closure BAR sig=[closure FOO ..]]]\n+            // Would get encoded to\n+            //     t=[closure FOO sig=[closure BAR sig=[closure FOO sig=$0]]]\n+            //\n+            // and we can decode by having\n+            //     $0=[closure BAR {sig doesn't exist in decode}]\n+            // and get\n+            //     t=[closure FOO]\n+            //     sig[FOO] = [closure BAR]\n+            //     sig[BAR] = [closure FOO]\n+            (self.next_fresh(ty::FreshTy), self.next_fresh(ty::FreshTy))\n+        } else {\n+            self.closure_set.push(def_id);\n+            let markers = markers(self);\n+            self.closure_set.pop();\n+            markers\n+        };\n+\n+        combine(tcx.mk_substs(\n+            substs.substs.iter().map(|k| k.fold_with(self)).chain(\n+                [marker_1, marker_2].iter().cloned().map(From::from)\n+                    )))\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -105,7 +203,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.needs_infer() && !t.has_erasable_regions() {\n+        if !t.needs_infer() && !t.has_erasable_regions() &&\n+            !(t.has_closure_types() && self.infcx.in_progress_tables.is_some()) {\n             return t;\n         }\n \n@@ -150,6 +249,51 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 t\n             }\n \n+            ty::TyClosure(def_id, substs) => {\n+                self.freshen_closure_like(\n+                    def_id, substs, t,\n+                    |this| {\n+                        // HACK: use a \"random\" integer type to mark the kind. Because\n+                        // different closure kinds shouldn't get unified during\n+                        // selection, the \"subtyping\" relationship (where any kind is\n+                        // better than no kind) shouldn't  matter here, just that the\n+                        // types are different.\n+                        let closure_kind = this.infcx.closure_kind(def_id);\n+                        let closure_kind_marker = match closure_kind {\n+                            None => tcx.types.i8,\n+                            Some(ty::ClosureKind::Fn) => tcx.types.i16,\n+                            Some(ty::ClosureKind::FnMut) => tcx.types.i32,\n+                            Some(ty::ClosureKind::FnOnce) => tcx.types.i64,\n+                        };\n+\n+                        let closure_sig = this.infcx.fn_sig(def_id);\n+                        (tcx.mk_fn_ptr(closure_sig.fold_with(this)),\n+                         closure_kind_marker)\n+                    },\n+                    |substs| tcx.mk_closure(def_id, substs)\n+                )\n+            }\n+\n+            ty::TyGenerator(def_id, substs, interior) => {\n+                self.freshen_closure_like(\n+                    def_id, substs, t,\n+                    |this| {\n+                        let gen_sig = this.infcx.generator_sig(def_id).unwrap();\n+                        // FIXME: want to revise this strategy when generator\n+                        // signatures can actually contain LBRs.\n+                        let sig = this.tcx().no_late_bound_regions(&gen_sig)\n+                            .unwrap_or_else(|| {\n+                                bug!(\"late-bound regions in signature of {:?}\",\n+                                     def_id)\n+                            });\n+                        (sig.yield_ty, sig.return_ty).fold_with(this)\n+                    },\n+                    |substs| {\n+                        tcx.mk_generator(def_id, ty::ClosureSubsts { substs }, interior)\n+                    }\n+                )\n+            }\n+\n             ty::TyBool |\n             ty::TyChar |\n             ty::TyInt(..) |\n@@ -165,8 +309,6 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyFnDef(..) |\n             ty::TyFnPtr(_) |\n             ty::TyDynamic(..) |\n-            ty::TyClosure(..) |\n-            ty::TyGenerator(..) |\n             ty::TyNever |\n             ty::TyTuple(..) |\n             ty::TyProjection(..) |"}, {"sha": "d6f27699e0a49827c9e1ea5eb4682c0e4255c463", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 9, "deletions": 56, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/75d6820ae0a364db77cda6262c1cad8afbf00a01/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75d6820ae0a364db77cda6262c1cad8afbf00a01/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=75d6820ae0a364db77cda6262c1cad8afbf00a01", "patch": "@@ -904,14 +904,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                dep_node: DepNodeIndex,\n                                result: EvaluationResult)\n     {\n-        // Avoid caching results that depend on more than just the trait-ref:\n-        // The stack can create recursion, and closure signatures\n-        // being yet uninferred can create \"spurious\" EvaluatedToAmbig\n-        // and EvaluatedToOk.\n-        if result.is_stack_dependent() ||\n-            ((result == EvaluatedToAmbig || result == EvaluatedToOk)\n-             && trait_ref.has_closure_types())\n-        {\n+        // Avoid caching results that depend on more than just the trait-ref\n+        // - the stack can create recursion.\n+        if result.is_stack_dependent() {\n             return;\n         }\n \n@@ -971,15 +966,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             this.candidate_from_obligation_no_cache(stack)\n         });\n \n-        if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n-            debug!(\"CACHE MISS: SELECT({:?})={:?}\",\n-                   cache_fresh_trait_pred, candidate);\n-            self.insert_candidate_cache(stack.obligation.param_env,\n-                                        cache_fresh_trait_pred,\n-                                        dep_node,\n-                                        candidate.clone());\n-        }\n-\n+        debug!(\"CACHE MISS: SELECT({:?})={:?}\",\n+               cache_fresh_trait_pred, candidate);\n+        self.insert_candidate_cache(stack.obligation.param_env,\n+                                    cache_fresh_trait_pred,\n+                                    dep_node,\n+                                    candidate.clone());\n         candidate\n     }\n \n@@ -1219,45 +1211,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                   .insert(trait_ref, WithDepNode::new(dep_node, candidate));\n     }\n \n-    fn should_update_candidate_cache(&mut self,\n-                                     cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>,\n-                                     candidate: &SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n-                                     -> bool\n-    {\n-        // In general, it's a good idea to cache results, even\n-        // ambiguous ones, to save us some trouble later. But we have\n-        // to be careful not to cache results that could be\n-        // invalidated later by advances in inference. Normally, this\n-        // is not an issue, because any inference variables whose\n-        // types are not yet bound are \"freshened\" in the cache key,\n-        // which means that if we later get the same request once that\n-        // type variable IS bound, we'll have a different cache key.\n-        // For example, if we have `Vec<_#0t> : Foo`, and `_#0t` is\n-        // not yet known, we may cache the result as `None`. But if\n-        // later `_#0t` is bound to `Bar`, then when we freshen we'll\n-        // have `Vec<Bar> : Foo` as the cache key.\n-        //\n-        // HOWEVER, it CAN happen that we get an ambiguity result in\n-        // one particular case around closures where the cache key\n-        // would not change. That is when the precise types of the\n-        // upvars that a closure references have not yet been figured\n-        // out (i.e., because it is not yet known if they are captured\n-        // by ref, and if by ref, what kind of ref). In these cases,\n-        // when matching a builtin bound, we will yield back an\n-        // ambiguous result. But the *cache key* is just the closure type,\n-        // it doesn't capture the state of the upvar computation.\n-        //\n-        // To avoid this trap, just don't cache ambiguous results if\n-        // the self-type contains no inference byproducts (that really\n-        // shouldn't happen in other circumstances anyway, given\n-        // coherence).\n-\n-        match *candidate {\n-            Ok(Some(_)) | Err(_) => true,\n-            Ok(None) => cache_fresh_trait_pred.has_infer_types()\n-        }\n-    }\n-\n     fn assemble_candidates<'o>(&mut self,\n                                stack: &TraitObligationStack<'o, 'tcx>)\n                                -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>"}]}