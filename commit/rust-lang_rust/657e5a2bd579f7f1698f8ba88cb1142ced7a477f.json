{"sha": "657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1N2U1YTJiZDU3OWY3ZjE2OThmOGJhODhjYjExNDJjZWQ3YTQ3N2Y=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-28T19:15:41Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-28T23:12:33Z"}, "message": "Renamed what's left of rust_dom to rust_scheduler", "tree": {"sha": "46ed664d666330679e343cde537b9d9e3f33b3e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46ed664d666330679e343cde537b9d9e3f33b3e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "html_url": "https://github.com/rust-lang/rust/commit/657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/comments", "author": null, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02f6645fca946fd7cb9f55036c05a908f0567ceb", "url": "https://api.github.com/repos/rust-lang/rust/commits/02f6645fca946fd7cb9f55036c05a908f0567ceb", "html_url": "https://github.com/rust-lang/rust/commit/02f6645fca946fd7cb9f55036c05a908f0567ceb"}], "stats": {"total": 624, "additions": 303, "deletions": 321}, "files": [{"sha": "bd935d660ff8e7d54b682fdc5e8614bb8a2dcfc7", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -10,7 +10,7 @@ RUNTIME_CS := rt/sync/timer.cpp \\\n               rt/rust_run_program.cpp \\\n               rt/rust_crate_cache.cpp \\\n               rt/rust_comm.cpp \\\n-              rt/rust_dom.cpp \\\n+              rt/rust_scheduler.cpp \\\n               rt/rust_task.cpp \\\n               rt/rust_task_list.cpp \\\n               rt/rust_proxy.cpp \\\n@@ -37,7 +37,7 @@ RUNTIME_HDR := rt/globals.h \\\n                rt/rust_util.h \\\n                rt/rust_chan.h \\\n                rt/rust_port.h \\\n-               rt/rust_dom.h \\\n+               rt/rust_scheduler.h \\\n                rt/rust_task.h \\\n                rt/rust_task_list.h \\\n                rt/rust_proxy.h \\"}, {"sha": "8c0067ff002e2914401f303fab2a363909d36c0b", "filename": "src/rt/circular_buffer.cpp", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Fcircular_buffer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Fcircular_buffer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -5,34 +5,34 @@\n #include \"rust_internal.h\"\n \n circular_buffer::circular_buffer(rust_task *task, size_t unit_sz) :\n-    dom(task->dom),\n+    sched(task->sched),\n     task(task),\n     unit_sz(unit_sz),\n     _buffer_sz(initial_size()),\n     _next(0),\n     _unread(0),\n     _buffer((uint8_t *)task->malloc(_buffer_sz)) {\n \n-    A(dom, unit_sz, \"Unit size must be larger than zero.\");\n+    A(sched, unit_sz, \"Unit size must be larger than zero.\");\n \n-    DLOG(dom, mem, \"new circular_buffer(buffer_sz=%d, unread=%d)\"\n+    DLOG(sched, mem, \"new circular_buffer(buffer_sz=%d, unread=%d)\"\n          \"-> circular_buffer=0x%\" PRIxPTR,\n          _buffer_sz, _unread, this);\n \n-    A(dom, _buffer, \"Failed to allocate buffer.\");\n+    A(sched, _buffer, \"Failed to allocate buffer.\");\n }\n \n circular_buffer::~circular_buffer() {\n-    DLOG(dom, mem, \"~circular_buffer 0x%\" PRIxPTR, this);\n-    I(dom, _buffer);\n-    W(dom, _unread == 0,\n+    DLOG(sched, mem, \"~circular_buffer 0x%\" PRIxPTR, this);\n+    I(sched, _buffer);\n+    W(sched, _unread == 0,\n       \"freeing circular_buffer with %d unread bytes\", _unread);\n     task->free(_buffer);\n }\n \n size_t\n circular_buffer::initial_size() {\n-    I(dom, unit_sz > 0);\n+    I(sched, unit_sz > 0);\n     return INITIAL_CIRCULAR_BUFFER_SIZE_IN_UNITS * unit_sz;\n }\n \n@@ -41,8 +41,8 @@ circular_buffer::initial_size() {\n  */\n void\n circular_buffer::transfer(void *dst) {\n-    I(dom, dst);\n-    I(dom, _unread <= _buffer_sz);\n+    I(sched, dst);\n+    I(sched, _unread <= _buffer_sz);\n \n     uint8_t *ptr = (uint8_t *) dst;\n \n@@ -54,13 +54,13 @@ circular_buffer::transfer(void *dst) {\n     } else {\n         head_sz = _buffer_sz - _next;\n     }\n-    I(dom, _next + head_sz <= _buffer_sz);\n+    I(sched, _next + head_sz <= _buffer_sz);\n     memcpy(ptr, _buffer + _next, head_sz);\n \n     // Then copy any other items from the beginning of the buffer\n-    I(dom, _unread >= head_sz);\n+    I(sched, _unread >= head_sz);\n     size_t tail_sz = _unread - head_sz;\n-    I(dom, head_sz + tail_sz <= _buffer_sz);\n+    I(sched, head_sz + tail_sz <= _buffer_sz);\n     memcpy(ptr + head_sz, _buffer, tail_sz);\n }\n \n@@ -70,37 +70,37 @@ circular_buffer::transfer(void *dst) {\n  */\n void\n circular_buffer::enqueue(void *src) {\n-    I(dom, src);\n-    I(dom, _unread <= _buffer_sz);\n-    I(dom, _buffer);\n+    I(sched, src);\n+    I(sched, _unread <= _buffer_sz);\n+    I(sched, _buffer);\n \n     // Grow if necessary.\n     if (_unread == _buffer_sz) {\n         grow();\n     }\n \n-    DLOG(dom, mem, \"circular_buffer enqueue \"\n+    DLOG(sched, mem, \"circular_buffer enqueue \"\n          \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n          _unread, _next, _buffer_sz, unit_sz);\n \n-    I(dom, _unread < _buffer_sz);\n-    I(dom, _unread + unit_sz <= _buffer_sz);\n+    I(sched, _unread < _buffer_sz);\n+    I(sched, _unread + unit_sz <= _buffer_sz);\n \n     // Copy data\n     size_t dst_idx = _next + _unread;\n-    I(dom, dst_idx >= _buffer_sz || dst_idx + unit_sz <= _buffer_sz);\n+    I(sched, dst_idx >= _buffer_sz || dst_idx + unit_sz <= _buffer_sz);\n     if (dst_idx >= _buffer_sz) {\n         dst_idx -= _buffer_sz;\n \n-        I(dom, _next >= unit_sz);\n-        I(dom, dst_idx <= _next - unit_sz);\n+        I(sched, _next >= unit_sz);\n+        I(sched, dst_idx <= _next - unit_sz);\n     }\n \n-    I(dom, dst_idx + unit_sz <= _buffer_sz);\n+    I(sched, dst_idx + unit_sz <= _buffer_sz);\n     memcpy(&_buffer[dst_idx], src, unit_sz);\n     _unread += unit_sz;\n \n-    DLOG(dom, mem, \"circular_buffer pushed data at index: %d\", dst_idx);\n+    DLOG(sched, mem, \"circular_buffer pushed data at index: %d\", dst_idx);\n }\n \n /**\n@@ -110,21 +110,21 @@ circular_buffer::enqueue(void *src) {\n  */\n void\n circular_buffer::dequeue(void *dst) {\n-    I(dom, unit_sz > 0);\n-    I(dom, _unread >= unit_sz);\n-    I(dom, _unread <= _buffer_sz);\n-    I(dom, _buffer);\n+    I(sched, unit_sz > 0);\n+    I(sched, _unread >= unit_sz);\n+    I(sched, _unread <= _buffer_sz);\n+    I(sched, _buffer);\n \n-    DLOG(dom, mem,\n+    DLOG(sched, mem,\n              \"circular_buffer dequeue \"\n              \"unread: %d, next: %d, buffer_sz: %d, unit_sz: %d\",\n              _unread, _next, _buffer_sz, unit_sz);\n \n-    I(dom, _next + unit_sz <= _buffer_sz);\n+    I(sched, _next + unit_sz <= _buffer_sz);\n     if (dst != NULL) {\n         memcpy(dst, &_buffer[_next], unit_sz);\n     }\n-    DLOG(dom, mem, \"shifted data from index %d\", _next);\n+    DLOG(sched, mem, \"shifted data from index %d\", _next);\n     _unread -= unit_sz;\n     _next += unit_sz;\n     if (_next == _buffer_sz) {\n@@ -140,8 +140,8 @@ circular_buffer::dequeue(void *dst) {\n void\n circular_buffer::grow() {\n     size_t new_buffer_sz = _buffer_sz * 2;\n-    I(dom, new_buffer_sz <= MAX_CIRCULAR_BUFFER_SIZE);\n-    DLOG(dom, mem, \"circular_buffer is growing to %d bytes\", new_buffer_sz);\n+    I(sched, new_buffer_sz <= MAX_CIRCULAR_BUFFER_SIZE);\n+    DLOG(sched, mem, \"circular_buffer is growing to %d bytes\", new_buffer_sz);\n     void *new_buffer = task->malloc(new_buffer_sz);\n     transfer(new_buffer);\n     task->free(_buffer);\n@@ -153,8 +153,8 @@ circular_buffer::grow() {\n void\n circular_buffer::shrink() {\n     size_t new_buffer_sz = _buffer_sz / 2;\n-    I(dom, initial_size() <= new_buffer_sz);\n-    DLOG(dom, mem, \"circular_buffer is shrinking to %d bytes\", new_buffer_sz);\n+    I(sched, initial_size() <= new_buffer_sz);\n+    DLOG(sched, mem, \"circular_buffer is shrinking to %d bytes\", new_buffer_sz);\n     void *new_buffer = task->malloc(new_buffer_sz);\n     transfer(new_buffer);\n     task->free(_buffer);"}, {"sha": "eb1e49494ea6991436115f206b228ef58d3da479", "filename": "src/rt/circular_buffer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Fcircular_buffer.h", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Fcircular_buffer.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fcircular_buffer.h?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -10,7 +10,7 @@ circular_buffer : public task_owned<circular_buffer> {\n     static const size_t INITIAL_CIRCULAR_BUFFER_SIZE_IN_UNITS = 8;\n     static const size_t MAX_CIRCULAR_BUFFER_SIZE = 1 << 24;\n \n-    rust_dom *dom;\n+    rust_scheduler *sched;\n \n public:\n     rust_task *task;"}, {"sha": "02ab54fd2e191e1ba8eeeca34e68f012cfbf3219", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -39,13 +39,13 @@ command_line_args : public kernel_owned<command_line_args>\n         size_t vec_fill = sizeof(rust_str *) * argc;\n         size_t vec_alloc = next_power_of_two(sizeof(rust_vec) + vec_fill);\n         void *mem = kernel->malloc(vec_alloc);\n-        args = new (mem) rust_vec(task->dom, vec_alloc, 0, NULL);\n+        args = new (mem) rust_vec(task->sched, vec_alloc, 0, NULL);\n         rust_str **strs = (rust_str**) &args->data[0];\n         for (int i = 0; i < argc; ++i) {\n             size_t str_fill = strlen(argv[i]) + 1;\n             size_t str_alloc = next_power_of_two(sizeof(rust_str) + str_fill);\n             mem = kernel->malloc(str_alloc);\n-            strs[i] = new (mem) rust_str(task->dom, str_alloc, str_fill,\n+            strs[i] = new (mem) rust_str(task->sched, str_alloc, str_fill,\n                                          (uint8_t const *)argv[i]);\n         }\n         args->fill = vec_fill;\n@@ -98,21 +98,21 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n     rust_srv *srv = new rust_srv();\n     rust_kernel *kernel = new rust_kernel(srv);\n     kernel->start();\n-    rust_dom *dom = kernel->get_domain();\n+    rust_scheduler *sched = kernel->get_scheduler();\n     command_line_args *args \n-        = new (kernel) command_line_args(dom->root_task, argc, argv);\n+        = new (kernel) command_line_args(sched->root_task, argc, argv);\n \n-    DLOG(dom, dom, \"startup: %d args in 0x%\" PRIxPTR,\n+    DLOG(sched, dom, \"startup: %d args in 0x%\" PRIxPTR,\n              args->argc, (uintptr_t)args->args);\n     for (int i = 0; i < args->argc; i++) {\n-        DLOG(dom, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n+        DLOG(sched, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n \n-    dom->root_task->start(main_fn, (uintptr_t)args->args);\n+    sched->root_task->start(main_fn, (uintptr_t)args->args);\n \n     int num_threads = get_num_threads();\n \n-    DLOG(dom, dom, \"Using %d worker threads.\", num_threads);\n+    DLOG(sched, dom, \"Using %d worker threads.\", num_threads);\n \n     int ret = kernel->start_task_threads(num_threads);\n     delete args;"}, {"sha": "a7325bc066d1b436b9d023efd0b9a2bf33732865", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -9,7 +9,7 @@\n \n extern \"C\" CDECL rust_str*\n last_os_error(rust_task *task) {\n-    rust_dom *dom = task->dom;\n+    rust_scheduler *sched = task->sched;\n     LOG(task, task, \"last_os_error()\");\n \n #if defined(__WIN32__)\n@@ -47,7 +47,7 @@ last_os_error(rust_task *task) {\n         task->fail(1);\n         return NULL;\n     }\n-    rust_str *st = new (mem) rust_str(dom, alloc, fill, (const uint8_t *)buf);\n+    rust_str *st = new (mem) rust_str(sched, alloc, fill, (const uint8_t *)buf);\n \n #ifdef __WIN32__\n     LocalFree((HLOCAL)buf);\n@@ -57,7 +57,7 @@ last_os_error(rust_task *task) {\n \n extern \"C\" CDECL rust_str *\n rust_getcwd(rust_task *task) {\n-    rust_dom *dom = task->dom;\n+    rust_scheduler *sched = task->sched;\n     LOG(task, task, \"rust_getcwd()\");\n \n     char cbuf[BUF_BYTES];\n@@ -80,7 +80,7 @@ rust_getcwd(rust_task *task) {\n     }\n \n     rust_str *st;\n-    st = new (mem) rust_str(dom, alloc, fill, (const uint8_t *)cbuf);\n+    st = new (mem) rust_str(sched, alloc, fill, (const uint8_t *)cbuf);\n \n     return st;    \n }\n@@ -124,7 +124,7 @@ unsupervise(rust_task *task) {\n extern \"C\" CDECL rust_vec*\n vec_alloc(rust_task *task, type_desc *t, type_desc *elem_t, size_t n_elts)\n {\n-    rust_dom *dom = task->dom;\n+    rust_scheduler *sched = task->sched;\n     LOG(task, mem, \"vec_alloc %\" PRIdPTR \" elements of size %\" PRIdPTR,\n         n_elts, elem_t->size);\n     size_t fill = n_elts * elem_t->size;\n@@ -134,7 +134,7 @@ vec_alloc(rust_task *task, type_desc *t, type_desc *elem_t, size_t n_elts)\n         task->fail(4);\n         return NULL;\n     }\n-    rust_vec *vec = new (mem) rust_vec(dom, alloc, 0, NULL);\n+    rust_vec *vec = new (mem) rust_vec(sched, alloc, 0, NULL);\n     return vec;\n }\n \n@@ -198,11 +198,11 @@ vec_alloc_with_data(rust_task *task,\n                     size_t elt_size,\n                     void *d)\n {\n-    rust_dom *dom = task->dom;\n+    rust_scheduler *sched = task->sched;\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + (n_elts * elt_size));\n     void *mem = task->malloc(alloc, memory_region::LOCAL);\n     if (!mem) return NULL;\n-    return new (mem) rust_vec(dom, alloc, fill * elt_size, (uint8_t*)d);\n+    return new (mem) rust_vec(sched, alloc, fill * elt_size, (uint8_t*)d);\n }\n \n extern \"C\" CDECL rust_vec*\n@@ -355,13 +355,13 @@ str_from_buf(rust_task *task, char *buf, unsigned int len) {\n extern \"C\" CDECL void *\n rand_new(rust_task *task)\n {\n-    rust_dom *dom = task->dom;\n+    rust_scheduler *sched = task->sched;\n     randctx *rctx = (randctx *) task->malloc(sizeof(randctx));\n     if (!rctx) {\n         task->fail(1);\n         return NULL;\n     }\n-    isaac_init(dom, rctx);\n+    isaac_init(sched, rctx);\n     return rctx;\n }\n "}, {"sha": "778fb6b16fdf2205318ddc08b8b0115e101f8b02", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -22,7 +22,7 @@ rust_chan::rust_chan(rust_task *task,\n rust_chan::~rust_chan() {\n     LOG(task, comm, \"del rust_chan(task=0x%\" PRIxPTR \")\", (uintptr_t) this);\n \n-    A(task->dom, is_associated() == false,\n+    A(task->sched, is_associated() == false,\n       \"Channel must be disassociated before being freed.\");\n     --task->ref_count;\n }\n@@ -49,7 +49,7 @@ bool rust_chan::is_associated() {\n  * Unlink this channel from its associated port.\n  */\n void rust_chan::disassociate() {\n-    A(task->dom, is_associated(), \"Channel must be associated with a port.\");\n+    A(task->sched, is_associated(), \"Channel must be associated with a port.\");\n \n     if (port->is_proxy() == false) {\n         LOG(task, task,\n@@ -69,14 +69,14 @@ void rust_chan::disassociate() {\n void rust_chan::send(void *sptr) {\n     buffer.enqueue(sptr);\n \n-    rust_dom *dom = task->dom;\n+    rust_scheduler *sched = task->sched;\n     if (!is_associated()) {\n-        W(dom, is_associated(),\n+        W(sched, is_associated(),\n           \"rust_chan::transmit with no associated port.\");\n         return;\n     }\n \n-    A(dom, !buffer.is_empty(),\n+    A(sched, !buffer.is_empty(),\n       \"rust_chan::transmit with nothing to send.\");\n \n     if (port->is_proxy()) {\n@@ -86,7 +86,7 @@ void rust_chan::send(void *sptr) {\n     } else {\n         rust_port *target_port = port->referent();\n         if (target_port->task->blocked_on(target_port)) {\n-            DLOG(dom, comm, \"dequeued in rendezvous_ptr\");\n+            DLOG(sched, comm, \"dequeued in rendezvous_ptr\");\n             buffer.dequeue(target_port->task->rendezvous_ptr);\n             target_port->task->rendezvous_ptr = 0;\n             target_port->task->wakeup(target_port);"}, {"sha": "7d3822d253a36b58f1e0a65306d659d677a175cb", "filename": "src/rt/rust_crate_cache.cpp", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_crate_cache.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_crate_cache.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_cache.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -7,16 +7,16 @@ rust_crate_cache::get_type_desc(size_t size,\n                                 size_t n_descs,\n                                 type_desc const **descs)\n {\n-    I(dom, n_descs > 1);\n+    I(sched, n_descs > 1);\n     type_desc *td = NULL;\n     size_t keysz = n_descs * sizeof(type_desc*);\n     HASH_FIND(hh, this->type_descs, descs, keysz, td);\n     if (td) {\n-        DLOG(dom, cache, \"rust_crate_cache::get_type_desc hit\");\n+        DLOG(sched, cache, \"rust_crate_cache::get_type_desc hit\");\n         return td;\n     }\n-    DLOG(dom, cache, \"rust_crate_cache::get_type_desc miss\");\n-    td = (type_desc*) dom->kernel->malloc(sizeof(type_desc) + keysz);\n+    DLOG(sched, cache, \"rust_crate_cache::get_type_desc miss\");\n+    td = (type_desc*) sched->kernel->malloc(sizeof(type_desc) + keysz);\n     if (!td)\n         return NULL;\n     // By convention, desc 0 is the root descriptor.\n@@ -27,7 +27,7 @@ rust_crate_cache::get_type_desc(size_t size,\n     td->size = size;\n     td->align = align;\n     for (size_t i = 0; i < n_descs; ++i) {\n-        DLOG(dom, cache,\n+        DLOG(sched, cache,\n                  \"rust_crate_cache::descs[%\" PRIdPTR \"] = 0x%\" PRIxPTR,\n                  i, descs[i]);\n         td->descs[i] = descs[i];\n@@ -38,22 +38,22 @@ rust_crate_cache::get_type_desc(size_t size,\n     return td;\n }\n \n-rust_crate_cache::rust_crate_cache(rust_dom *dom)\n+rust_crate_cache::rust_crate_cache(rust_scheduler *sched)\n     : type_descs(NULL),\n-      dom(dom),\n+      sched(sched),\n       idx(0)\n {\n }\n \n void\n rust_crate_cache::flush() {\n-    DLOG(dom, cache, \"rust_crate_cache::flush()\");\n+    DLOG(sched, cache, \"rust_crate_cache::flush()\");\n \n     while (type_descs) {\n         type_desc *d = type_descs;\n         HASH_DEL(type_descs, d);\n-        DLOG(dom, mem, \"rust_crate_cache::flush() tydesc %\" PRIxPTR, d);\n-        dom->kernel->free(d);\n+        DLOG(sched, mem, \"rust_crate_cache::flush() tydesc %\" PRIxPTR, d);\n+        sched->kernel->free(d);\n     }\n }\n "}, {"sha": "a57ef607f60eaf02832e92a89cde8c5a591ea533", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -50,7 +50,7 @@ extern \"C\" {\n #include \"sync/lock_and_signal.h\"\n #include \"sync/lock_free_queue.h\"\n \n-struct rust_dom;\n+struct rust_scheduler;\n struct rust_task;\n class rust_log;\n class rust_port;\n@@ -174,7 +174,7 @@ template <typename T> class ptr_vec : public task_owned<ptr_vec<T> > {\n #include \"rust_proxy.h\"\n #include \"rust_kernel.h\"\n #include \"rust_message.h\"\n-#include \"rust_dom.h\"\n+#include \"rust_scheduler.h\"\n \n struct rust_timer {\n     // FIXME: This will probably eventually need replacement\n@@ -183,7 +183,7 @@ struct rust_timer {\n     // For now it's just the most basic \"thread that can interrupt\n     // its associated domain-thread\" device, so that we have\n     // *some* form of task-preemption.\n-    rust_dom *dom;\n+    rust_scheduler *sched;\n     uintptr_t exit_flag;\n \n #if defined(__WIN32__)\n@@ -193,7 +193,7 @@ struct rust_timer {\n     pthread_t thread;\n #endif\n \n-    rust_timer(rust_dom *dom);\n+    rust_timer(rust_scheduler *sched);\n     ~rust_timer();\n };\n "}, {"sha": "f3ebfd4f4b9516feb3c9f48c0c30e3f828f82758", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -13,55 +13,55 @@ rust_kernel::rust_kernel(rust_srv *srv) :\n     _srv(srv),\n     _interrupt_kernel_loop(FALSE) \n {\n-    dom = create_domain(\"main\");\n+    sched = create_scheduler(\"main\");\n }\n \n-rust_dom *\n-rust_kernel::create_domain(const char *name) {\n+rust_scheduler *\n+rust_kernel::create_scheduler(const char *name) {\n     _kernel_lock.lock();\n     rust_message_queue *message_queue =\n         new (this) rust_message_queue(_srv, this);\n     rust_srv *srv = _srv->clone();\n-    rust_dom *dom =\n-        new (this) rust_dom(this, message_queue, srv, name);\n-    rust_handle<rust_dom> *handle = internal_get_dom_handle(dom);\n+    rust_scheduler *sched =\n+        new (this) rust_scheduler(this, message_queue, srv, name);\n+    rust_handle<rust_scheduler> *handle = internal_get_sched_handle(sched);\n     message_queue->associate(handle);\n     message_queues.append(message_queue);\n-    KLOG(\"created domain: \" PTR \", name: %s, index: %d\",\n-         dom, name, dom->list_index);\n+    KLOG(\"created scheduler: \" PTR \", name: %s, index: %d\",\n+         sched, name, sched->list_index);\n     _kernel_lock.signal_all();\n     _kernel_lock.unlock();\n-    return dom;\n+    return sched;\n }\n \n void\n-rust_kernel::destroy_domain() {\n+rust_kernel::destroy_scheduler() {\n     _kernel_lock.lock();\n-    KLOG(\"deleting domain: \" PTR \", name: %s, index: %d\",\n-        dom, dom->name, dom->list_index);\n-    dom->message_queue->disassociate();\n-    rust_srv *srv = dom->srv;\n-    delete dom;\n+    KLOG(\"deleting scheduler: \" PTR \", name: %s, index: %d\",\n+        sched, sched->name, sched->list_index);\n+    sched->message_queue->disassociate();\n+    rust_srv *srv = sched->srv;\n+    delete sched;\n     delete srv;\n     _kernel_lock.signal_all();\n     _kernel_lock.unlock();\n }\n \n-rust_handle<rust_dom> *\n-rust_kernel::internal_get_dom_handle(rust_dom *dom) {\n-    rust_handle<rust_dom> *handle = NULL;\n-    if (_dom_handles.get(dom, &handle) == false) {\n+rust_handle<rust_scheduler> *\n+rust_kernel::internal_get_sched_handle(rust_scheduler *sched) {\n+    rust_handle<rust_scheduler> *handle = NULL;\n+    if (_sched_handles.get(sched, &handle) == false) {\n         handle =\n-            new (this) rust_handle<rust_dom>(this, dom->message_queue, dom);\n-        _dom_handles.put(dom, handle);\n+            new (this) rust_handle<rust_scheduler>(this, sched->message_queue, sched);\n+        _sched_handles.put(sched, handle);\n     }\n     return handle;\n }\n \n-rust_handle<rust_dom> *\n-rust_kernel::get_dom_handle(rust_dom *dom) {\n+rust_handle<rust_scheduler> *\n+rust_kernel::get_sched_handle(rust_scheduler *sched) {\n     _kernel_lock.lock();\n-    rust_handle<rust_dom> *handle = internal_get_dom_handle(dom);\n+    rust_handle<rust_scheduler> *handle = internal_get_sched_handle(sched);\n     _kernel_lock.unlock();\n     return handle;\n }\n@@ -72,7 +72,7 @@ rust_kernel::get_task_handle(rust_task *task) {\n     rust_handle<rust_task> *handle = NULL;\n     if (_task_handles.get(task, &handle) == false) {\n         handle =\n-            new (this) rust_handle<rust_task>(this, task->dom->message_queue,\n+            new (this) rust_handle<rust_task>(this, task->sched->message_queue,\n                                               task);\n         _task_handles.put(task, handle);\n     }\n@@ -87,7 +87,7 @@ rust_kernel::get_port_handle(rust_port *port) {\n     if (_port_handles.get(port, &handle) == false) {\n         handle =\n             new (this) rust_handle<rust_port>(this,\n-                                              port->task->dom->message_queue,\n+                                              port->task->sched->message_queue,\n                                               port);\n         _port_handles.put(port, handle);\n     }\n@@ -96,9 +96,8 @@ rust_kernel::get_port_handle(rust_port *port) {\n }\n \n void\n-rust_kernel::log_all_domain_state() {\n-    KLOG(\"log_all_domain_state\");\n-    dom->log_state();\n+rust_kernel::log_all_scheduler_state() {\n+    sched->log_state();\n }\n \n /**\n@@ -159,7 +158,7 @@ rust_kernel::terminate_kernel_loop() {\n }\n \n rust_kernel::~rust_kernel() {\n-    destroy_domain();\n+    destroy_scheduler();\n \n     terminate_kernel_loop();\n \n@@ -175,8 +174,8 @@ rust_kernel::~rust_kernel() {\n     KLOG(\"..task handles freed\");\n     free_handles(_port_handles);\n     KLOG(\"..port handles freed\");\n-    free_handles(_dom_handles);\n-    KLOG(\"..dom handles freed\");\n+    free_handles(_sched_handles);\n+    KLOG(\"..sched handles freed\");\n \n     KLOG(\"freeing queues\");\n \n@@ -235,14 +234,14 @@ int rust_kernel::start_task_threads(int num_threads)\n         threads.push(thread);\n     }\n     \n-    dom->start_main_loop(0);\n+    sched->start_main_loop(0);\n \n     while(threads.pop(&thread)) {\n         thread->join();\n         delete thread;\n     }\n \n-    return dom->rval;\n+    return sched->rval;\n }\n \n #ifdef __WIN32__\n@@ -257,9 +256,9 @@ rust_kernel::win32_require(LPCTSTR fn, BOOL ok) {\n                       NULL, err,\n                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                       (LPTSTR) &buf, 0, NULL );\n-        DLOG_ERR(dom, dom, \"%s failed with error %ld: %s\", fn, err, buf);\n+        DLOG_ERR(sched, dom, \"%s failed with error %ld: %s\", fn, err, buf);\n         LocalFree((HLOCAL)buf);\n-        I(dom, ok);\n+        I(sched, ok);\n     }\n }\n #endif\n@@ -271,7 +270,7 @@ rust_task_thread::rust_task_thread(int id, rust_kernel *owner)\n \n void rust_task_thread::run()\n {\n-    owner->dom->start_main_loop(id);\n+    owner->sched->start_main_loop(id);\n }\n \n //"}, {"sha": "a1fba33bf8918a2f891b14300d6ad705bb6cbbd8", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -52,7 +52,7 @@ class rust_kernel : public rust_thread {\n      */\n     hash_map<rust_task *, rust_handle<rust_task> *> _task_handles;\n     hash_map<rust_port *, rust_handle<rust_port> *> _port_handles;\n-    hash_map<rust_dom *, rust_handle<rust_dom> *> _dom_handles;\n+    hash_map<rust_scheduler *, rust_handle<rust_scheduler> *> _sched_handles;\n \n     template<class T> void free_handles(hash_map<T*, rust_handle<T>* > &map);\n \n@@ -65,15 +65,16 @@ class rust_kernel : public rust_thread {\n     void terminate_kernel_loop();\n     void pump_message_queues();\n \n-    rust_handle<rust_dom> *internal_get_dom_handle(rust_dom *dom);\n+    rust_handle<rust_scheduler> *\n+    internal_get_sched_handle(rust_scheduler *sched);\n \n-    rust_dom *create_domain(const char *name);\n-    void destroy_domain();\n+    rust_scheduler *create_scheduler(const char *name);\n+    void destroy_scheduler();\n \n     array_list<rust_task_thread *> threads;\n \n public:\n-    rust_dom *dom;\n+    rust_scheduler *sched;\n     lock_and_signal scheduler_lock;\n \n     /**\n@@ -85,7 +86,7 @@ class rust_kernel : public rust_thread {\n      */\n     indexed_list<rust_message_queue> message_queues;\n \n-    rust_handle<rust_dom> *get_dom_handle(rust_dom *dom);\n+    rust_handle<rust_scheduler> *get_sched_handle(rust_scheduler *sched);\n     rust_handle<rust_task> *get_task_handle(rust_task *task);\n     rust_handle<rust_port> *get_port_handle(rust_port *port);\n \n@@ -103,15 +104,15 @@ class rust_kernel : public rust_thread {\n     void\n     notify_message_enqueued(rust_message_queue *queue, rust_message *message);\n \n-    void log_all_domain_state();\n+    void log_all_scheduler_state();\n     void log(uint32_t level, char const *fmt, ...);\n     virtual ~rust_kernel();\n \n     void *malloc(size_t size);\n     void free(void *mem);\n \n     // FIXME: this should go away\n-    inline rust_dom *get_domain() const { return dom; }\n+    inline rust_scheduler *get_scheduler() const { return sched; }\n \n     int start_task_threads(int num_threads);\n "}, {"sha": "a2ab77b1b551320f50b031c637bd486f6e01f069", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -23,9 +23,9 @@ static const char * _foreground_colors[] = { \"[37m\",\n static lock_and_signal _log_lock;\n static uint32_t _last_thread_id;\n \n-rust_log::rust_log(rust_srv *srv, rust_dom *dom) :\n+rust_log::rust_log(rust_srv *srv, rust_scheduler *sched) :\n     _srv(srv),\n-    _dom(dom),\n+    _sched(sched),\n     _use_colors(getenv(\"RUST_COLOR_LOG\")) {\n }\n \n@@ -104,12 +104,12 @@ rust_log::trace_ln(rust_task *task, uint32_t level, char *message) {\n     uint32_t thread_id = hash((uint32_t) pthread_self());\n #endif\n     char prefix[BUF_BYTES] = \"\";\n-    if (_dom && _dom->name) {\n+    if (_sched && _sched->name) {\n         append_string(prefix, \"%04\" PRIxPTR \":%.10s:\",\n-                      thread_id, _dom->name);\n+                      thread_id, _sched->name);\n     } else {\n         append_string(prefix, \"%04\" PRIxPTR \":0x%08\" PRIxPTR \":\",\n-                      thread_id, (uintptr_t) _dom);\n+                      thread_id, (uintptr_t) _sched);\n     }\n     if (task) {\n         if (task->name) {"}, {"sha": "ce0d8f593efce164e0e67fe96b98c81a62508e2f", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -1,34 +1,35 @@\n+// -*- c++ -*-\n #ifndef RUST_LOG_H\n #define RUST_LOG_H\n \n const uint32_t log_err = 0;\n const uint32_t log_note = 1;\n \n #define LOG(task, field, ...)                                   \\\n-    DLOG_LVL(log_note, task, task->dom, field, __VA_ARGS__)\n+    DLOG_LVL(log_note, task, task->sched, field, __VA_ARGS__)\n #define LOG_ERR(task, field, ...)                               \\\n-    DLOG_LVL(log_err, task, task->dom, field, __VA_ARGS__)\n-#define DLOG(dom, field, ...)                                   \\\n-    DLOG_LVL(log_note, NULL, dom, field, __VA_ARGS__)\n-#define DLOG_ERR(dom, field, ...)                               \\\n-    DLOG_LVL(log_err, NULL, dom, field, __VA_ARGS__)\n-#define LOGPTR(dom, msg, ptrval)                                \\\n-    DLOG_LVL(log_note, NULL, dom, mem, \"%s 0x%\" PRIxPTR, msg, ptrval)\n-#define DLOG_LVL(lvl, task, dom, field, ...)                    \\\n+    DLOG_LVL(log_err, task, task->sched, field, __VA_ARGS__)\n+#define DLOG(sched, field, ...)                                   \\\n+    DLOG_LVL(log_note, NULL, sched, field, __VA_ARGS__)\n+#define DLOG_ERR(sched, field, ...)                               \\\n+    DLOG_LVL(log_err, NULL, sched, field, __VA_ARGS__)\n+#define LOGPTR(sched, msg, ptrval)                                \\\n+    DLOG_LVL(log_note, NULL, sched, mem, \"%s 0x%\" PRIxPTR, msg, ptrval)\n+#define DLOG_LVL(lvl, task, sched, field, ...)                    \\\n     do {                                                        \\\n-        rust_dom* _d_ = dom;                                    \\\n+        rust_scheduler* _d_ = sched;                            \\\n         if (log_rt_##field >= lvl && _d_->log_lvl >= lvl) {     \\\n             _d_->log(task, lvl, __VA_ARGS__);                   \\\n         }                                                       \\\n     } while (0)\n \n-struct rust_dom;\n+struct rust_scheduler;\n struct rust_task;\n \n class rust_log {\n \n public:\n-    rust_log(rust_srv *srv, rust_dom *dom);\n+    rust_log(rust_srv *srv, rust_scheduler *sched);\n     virtual ~rust_log();\n \n     enum ansi_color {\n@@ -53,7 +54,7 @@ class rust_log {\n \n private:\n     rust_srv *_srv;\n-    rust_dom *_dom;\n+    rust_scheduler *_sched;\n     bool _use_labels;\n     bool _use_colors;\n     void trace_ln(rust_task *task, char *message);"}, {"sha": "716299e64fe19303dca0753da59a5ffa7da0378c", "filename": "src/rt/rust_message.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_message.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_message.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -112,7 +112,7 @@ void data_message::kernel_process() {\n rust_message_queue::rust_message_queue(rust_srv *srv, rust_kernel *kernel) \n     : region(srv, true),\n       kernel(kernel),\n-      dom_handle(NULL) {\n+      sched_handle(NULL) {\n     // Nop.\n }\n "}, {"sha": "6b95c9ffec78495ab54dbad621229dcd3deea37a", "filename": "src/rt/rust_message.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_message.h", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_message.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.h?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -93,26 +93,26 @@ class rust_message_queue : public lock_free_queue<rust_message*>,\n public:\n     memory_region region;\n     rust_kernel *kernel;\n-    rust_handle<rust_dom> *dom_handle;\n+    rust_handle<rust_scheduler> *sched_handle;\n     int32_t list_index;\n     rust_message_queue(rust_srv *srv, rust_kernel *kernel);\n \n-    void associate(rust_handle<rust_dom> *dom_handle) {\n-        this->dom_handle = dom_handle;\n+    void associate(rust_handle<rust_scheduler> *sched_handle) {\n+        this->sched_handle = sched_handle;\n     }\n \n     /**\n      * The Rust domain relinquishes control to the Rust kernel.\n      */\n     void disassociate() {\n-        this->dom_handle = NULL;\n+        this->sched_handle = NULL;\n     }\n \n     /**\n      * Checks if a Rust domain is responsible for draining the message queue.\n      */\n     bool is_associated() {\n-        return this->dom_handle != NULL;\n+        return this->sched_handle != NULL;\n     }\n \n     void enqueue(rust_message* message) {"}, {"sha": "4ada1ae56973d60a59d010886fe943c888cb86a7", "filename": "src/rt/rust_scheduler.cpp", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -3,7 +3,7 @@\n #include \"rust_internal.h\"\n #include \"globals.h\"\n \n-rust_dom::rust_dom(rust_kernel *kernel,\n+rust_scheduler::rust_scheduler(rust_kernel *kernel,\n     rust_message_queue *message_queue, rust_srv *srv,\n     const char *name) :\n     interrupt_flag(0),\n@@ -32,8 +32,8 @@ rust_dom::rust_dom(rust_kernel *kernel,\n     root_task = create_task(NULL, name);\n }\n \n-rust_dom::~rust_dom() {\n-    DLOG(this, dom, \"~rust_dom %s @0x%\" PRIxPTR, name, (uintptr_t)this);\n+rust_scheduler::~rust_scheduler() {\n+    DLOG(this, dom, \"~rust_scheduler %s @0x%\" PRIxPTR, name, (uintptr_t)this);\n \n     newborn_tasks.delete_all();\n     running_tasks.delete_all();\n@@ -45,7 +45,7 @@ rust_dom::~rust_dom() {\n }\n \n void\n-rust_dom::activate(rust_task *task) {\n+rust_scheduler::activate(rust_task *task) {\n     context ctx;\n \n     task->ctx.next = &ctx;\n@@ -57,7 +57,7 @@ rust_dom::activate(rust_task *task) {\n }\n \n void\n-rust_dom::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n+rust_scheduler::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n     char buf[BUF_BYTES];\n     va_list args;\n     va_start(args, fmt);\n@@ -67,23 +67,23 @@ rust_dom::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n }\n \n void\n-rust_dom::fail() {\n+rust_scheduler::fail() {\n     log(NULL, log_err, \"domain %s @0x%\" PRIxPTR \" root task failed\",\n         name, this);\n     I(this, rval == 0);\n     rval = 1;\n }\n \n size_t\n-rust_dom::number_of_live_tasks() {\n+rust_scheduler::number_of_live_tasks() {\n     return running_tasks.length() + blocked_tasks.length();\n }\n \n /**\n  * Delete any dead tasks.\n  */\n void\n-rust_dom::reap_dead_tasks() {\n+rust_scheduler::reap_dead_tasks() {\n     I(this, kernel->scheduler_lock.lock_held_by_current_thread());\n     for (size_t i = 0; i < dead_tasks.length(); ) {\n         rust_task *task = dead_tasks[i];\n@@ -104,7 +104,7 @@ rust_dom::reap_dead_tasks() {\n /**\n  * Drains and processes incoming pending messages.\n  */\n-void rust_dom::drain_incoming_message_queue(bool process) {\n+void rust_scheduler::drain_incoming_message_queue(bool process) {\n     rust_message *message;\n     while (message_queue->dequeue(&message)) {\n         DLOG(this, comm, \"<== receiving \\\"%s\\\" \" PTR,\n@@ -124,7 +124,7 @@ void rust_dom::drain_incoming_message_queue(bool process) {\n  * Returns NULL if no tasks can be scheduled.\n  */\n rust_task *\n-rust_dom::schedule_task() {\n+rust_scheduler::schedule_task() {\n     I(this, this);\n     // FIXME: in the face of failing tasks, this is not always right.\n     // I(this, n_live_tasks() > 0);\n@@ -142,7 +142,7 @@ rust_dom::schedule_task() {\n }\n \n void\n-rust_dom::log_state() {\n+rust_scheduler::log_state() {\n     if (log_rt_task < log_note) return;\n \n     if (!running_tasks.is_empty()) {\n@@ -182,7 +182,7 @@ rust_dom::log_state() {\n  * drop to zero.\n  */\n int\n-rust_dom::start_main_loop(int id) {\n+rust_scheduler::start_main_loop(int id) {\n     kernel->scheduler_lock.lock();\n \n     // Make sure someone is watching, to pull us out of infinite loops.\n@@ -282,12 +282,12 @@ rust_dom::start_main_loop(int id) {\n }\n \n rust_crate_cache *\n-rust_dom::get_cache() {\n+rust_scheduler::get_cache() {\n     return &cache;\n }\n \n rust_task *\n-rust_dom::create_task(rust_task *spawner, const char *name) {\n+rust_scheduler::create_task(rust_task *spawner, const char *name) {\n     rust_task *task =\n         new (this->kernel) rust_task (this, &newborn_tasks, spawner, name);\n     DLOG(this, task, \"created task: \" PTR \", spawner: %s, name: %s\",", "previous_filename": "src/rt/rust_dom.cpp"}, {"sha": "d3e2df224c782da69a45504dea22e7ab1888e64b", "filename": "src/rt/rust_scheduler.h", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -1,7 +1,7 @@\n-#ifndef RUST_DOM_H\n-#define RUST_DOM_H\n+#ifndef RUST_SCHEDULER_H\n+#define RUST_SCHEDULER_H\n \n-struct rust_dom;\n+struct rust_scheduler;\n \n class\n rust_crate_cache\n@@ -18,15 +18,15 @@ rust_crate_cache\n \n public:\n \n-    rust_dom *dom;\n+    rust_scheduler *sched;\n     size_t idx;\n \n-    rust_crate_cache(rust_dom *dom);\n+    rust_crate_cache(rust_scheduler *sched);\n     ~rust_crate_cache();\n     void flush();\n };\n \n-struct rust_dom : public kernel_owned<rust_dom>, rc_base<rust_dom>\n+struct rust_scheduler : public kernel_owned<rust_scheduler>, rc_base<rust_scheduler>\n {\n     // Fields known to the compiler:\n     uintptr_t interrupt_flag;\n@@ -64,10 +64,10 @@ struct rust_dom : public kernel_owned<rust_dom>, rc_base<rust_dom>\n \n     // Only a pointer to 'name' is kept, so it must live as long as this\n     // domain.\n-    rust_dom(rust_kernel *kernel,\n+    rust_scheduler(rust_kernel *kernel,\n              rust_message_queue *message_queue, rust_srv *srv,\n              const char *name);\n-    ~rust_dom();\n+    ~rust_scheduler();\n     void activate(rust_task *task);\n     void log(rust_task *task, uint32_t level, char const *fmt, ...);\n     rust_log & get_log();\n@@ -89,7 +89,7 @@ struct rust_dom : public kernel_owned<rust_dom>, rc_base<rust_dom>\n };\n \n inline rust_log &\n-rust_dom::get_log() {\n+rust_scheduler::get_log() {\n     return _log;\n }\n \n@@ -104,4 +104,4 @@ rust_dom::get_log() {\n // End:\n //\n \n-#endif /* RUST_DOM_H */\n+#endif /* RUST_SCHEDULER_H */", "previous_filename": "src/rt/rust_dom.h"}, {"sha": "2a3342c683d04591395137d4b0d9452544f1c19d", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 50, "deletions": 70, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -26,10 +26,10 @@ new_stk(rust_task *task, size_t minsz)\n         minsz = min_stk_bytes;\n     size_t sz = sizeof(stk_seg) + minsz;\n     stk_seg *stk = (stk_seg *)task->malloc(sz);\n-    LOGPTR(task->dom, \"new stk\", (uintptr_t)stk);\n+    LOGPTR(task->sched, \"new stk\", (uintptr_t)stk);\n     memset(stk, 0, sizeof(stk_seg));\n     stk->limit = (uintptr_t) &stk->data[minsz];\n-    LOGPTR(task->dom, \"stk limit\", stk->limit);\n+    LOGPTR(task->sched, \"stk limit\", stk->limit);\n     stk->valgrind_id =\n         VALGRIND_STACK_REGISTER(&stk->data[0],\n                                 &stk->data[minsz]);\n@@ -40,7 +40,7 @@ static void\n del_stk(rust_task *task, stk_seg *stk)\n {\n     VALGRIND_STACK_DEREGISTER(stk->valgrind_id);\n-    LOGPTR(task->dom, \"freeing stk segment\", (uintptr_t)stk);\n+    LOGPTR(task->sched, \"freeing stk segment\", (uintptr_t)stk);\n     task->free(stk);\n }\n \n@@ -52,16 +52,16 @@ del_stk(rust_task *task, stk_seg *stk)\n size_t const n_callee_saves = 4;\n size_t const callee_save_fp = 0;\n \n-rust_task::rust_task(rust_dom *dom, rust_task_list *state,\n+rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n                      rust_task *spawner, const char *name) :\n     maybe_proxy<rust_task>(this),\n     stk(NULL),\n     runtime_sp(0),\n     rust_sp(0),\n     gc_alloc_chain(0),\n-    dom(dom),\n+    sched(sched),\n     cache(NULL),\n-    kernel(dom->kernel),\n+    kernel(sched->kernel),\n     name(name),\n     state(state),\n     cond(NULL),\n@@ -71,11 +71,11 @@ rust_task::rust_task(rust_dom *dom, rust_task_list *state,\n     rendezvous_ptr(0),\n     handle(NULL),\n     active(false),\n-    local_region(&dom->srv->local_region),\n-    synchronized_region(&dom->srv->synchronized_region)\n+    local_region(&sched->srv->local_region),\n+    synchronized_region(&sched->srv->synchronized_region)\n {\n-    LOGPTR(dom, \"new task\", (uintptr_t)this);\n-    DLOG(dom, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n+    LOGPTR(sched, \"new task\", (uintptr_t)this);\n+    DLOG(sched, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n \n     stk = new_stk(this, 0);\n     rust_sp = stk->limit;\n@@ -87,33 +87,13 @@ rust_task::rust_task(rust_dom *dom, rust_task_list *state,\n \n rust_task::~rust_task()\n {\n-    DLOG(dom, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n+    DLOG(sched, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n          name, (uintptr_t)this, ref_count);\n \n-    /*\n-      for (uintptr_t fp = get_fp(); fp; fp = get_previous_fp(fp)) {\n-      frame_glue_fns *glue_fns = get_frame_glue_fns(fp);\n-      DLOG(dom, task,\n-      \"~rust_task, frame fp=0x%\" PRIxPTR \", glue_fns=0x%\" PRIxPTR,\n-      fp, glue_fns);\n-      if (glue_fns) {\n-      DLOG(dom, task,\n-               \"~rust_task, mark_glue=0x%\" PRIxPTR,\n-               glue_fns->mark_glue);\n-      DLOG(dom, task,\n-               \"~rust_task, drop_glue=0x%\" PRIxPTR,\n-               glue_fns->drop_glue);\n-      DLOG(dom, task,\n-               \"~rust_task, reloc_glue=0x%\" PRIxPTR,\n-               glue_fns->reloc_glue);\n-      }\n-      }\n-    */\n-\n     /* FIXME: tighten this up, there are some more\n        assertions that hold at task-lifecycle events. */\n-    I(dom, ref_count == 0 ||\n-      (ref_count == 1 && this == dom->root_task));\n+    I(sched, ref_count == 0 ||\n+      (ref_count == 1 && this == sched->root_task));\n \n     del_stk(this, stk);\n }\n@@ -147,7 +127,7 @@ void task_start_wrapper(spawn_args *a)\n         // This is duplicated from upcall_exit, which is probably dead code by\n         // now.\n         LOG(task, task, \"task ref_count: %d\", task->ref_count);\n-        A(task->dom, task->ref_count >= 0,\n+        A(task->sched, task->ref_count >= 0,\n           \"Task ref_count should not be negative on exit!\");\n         task->die();\n         task->notify_tasks_waiting_to_join();\n@@ -160,10 +140,10 @@ void\n rust_task::start(uintptr_t spawnee_fn,\n                  uintptr_t args)\n {\n-    LOGPTR(dom, \"from spawnee\", spawnee_fn);\n+    LOGPTR(sched, \"from spawnee\", spawnee_fn);\n \n-    I(dom, stk->data != NULL);\n-    I(dom, !kernel->scheduler_lock.lock_held_by_current_thread());\n+    I(sched, stk->data != NULL);\n+    I(sched, !kernel->scheduler_lock.lock_held_by_current_thread());\n     \n     scoped_lock with(kernel->scheduler_lock);\n \n@@ -182,7 +162,7 @@ rust_task::start(uintptr_t spawnee_fn,\n     ctx.call((void *)task_start_wrapper, a, sp);\n \n     yield_timer.reset(0);\n-    transition(&dom->newborn_tasks, &dom->running_tasks);\n+    transition(&sched->newborn_tasks, &sched->running_tasks);\n }\n \n void\n@@ -227,8 +207,8 @@ rust_task::kill() {\n     // Unblock the task so it can unwind.\n     unblock();\n \n-    if (this == dom->root_task)\n-        dom->fail();\n+    if (this == sched->root_task)\n+        sched->fail();\n \n     LOG(this, task, \"preparing to unwind task: 0x%\" PRIxPTR, this);\n     // run_on_resume(rust_unwind_glue);\n@@ -237,15 +217,15 @@ rust_task::kill() {\n void\n rust_task::fail(size_t nargs) {\n     // See note in ::kill() regarding who should call this.\n-    DLOG(dom, task, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n+    DLOG(sched, task, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n     backtrace();\n     // Unblock the task so it can unwind.\n     unblock();\n-    if (this == dom->root_task)\n-        dom->fail();\n+    if (this == sched->root_task)\n+        sched->fail();\n     // run_after_return(nargs, rust_unwind_glue);\n     if (supervisor) {\n-        DLOG(dom, task,\n+        DLOG(sched, task,\n              \"task %s @0x%\" PRIxPTR\n              \" propagating failure to supervisor %s @0x%\" PRIxPTR,\n              name, this, supervisor->name, supervisor);\n@@ -259,14 +239,14 @@ void\n rust_task::gc(size_t nargs)\n {\n     // FIXME: not presently implemented; was broken by rustc.\n-    DLOG(dom, task,\n+    DLOG(sched, task,\n              \"task %s @0x%\" PRIxPTR \" garbage collecting\", name, this);\n }\n \n void\n rust_task::unsupervise()\n {\n-    DLOG(dom, task,\n+    DLOG(sched, task,\n              \"task %s @0x%\" PRIxPTR\n              \" disconnecting from supervisor %s @0x%\" PRIxPTR,\n              name, this, supervisor->name, supervisor);\n@@ -302,13 +282,13 @@ rust_task::get_frame_glue_fns(uintptr_t fp) {\n bool\n rust_task::running()\n {\n-    return state == &dom->running_tasks;\n+    return state == &sched->running_tasks;\n }\n \n bool\n rust_task::blocked()\n {\n-    return state == &dom->blocked_tasks;\n+    return state == &sched->blocked_tasks;\n }\n \n bool\n@@ -320,13 +300,13 @@ rust_task::blocked_on(rust_cond *on)\n bool\n rust_task::dead()\n {\n-    return state == &dom->dead_tasks;\n+    return state == &sched->dead_tasks;\n }\n \n void\n rust_task::link_gc(gc_alloc *gcm) {\n-    I(dom, gcm->prev == NULL);\n-    I(dom, gcm->next == NULL);\n+    I(sched, gcm->prev == NULL);\n+    I(sched, gcm->next == NULL);\n     gcm->prev = NULL;\n     gcm->next = gc_alloc_chain;\n     gc_alloc_chain = gcm;\n@@ -361,7 +341,7 @@ rust_task::malloc(size_t sz, type_desc *td)\n         return mem;\n     if (td) {\n         gc_alloc *gcm = (gc_alloc*) mem;\n-        DLOG(dom, task, \"task %s @0x%\" PRIxPTR\n+        DLOG(sched, task, \"task %s @0x%\" PRIxPTR\n              \" allocated %d GC bytes = 0x%\" PRIxPTR,\n              name, (uintptr_t)this, sz, gcm);\n         memset((void*) gcm, 0, sizeof(gc_alloc));\n@@ -384,7 +364,7 @@ rust_task::realloc(void *data, size_t sz, bool is_gc)\n         unlink_gc(gcm);\n         sz += sizeof(gc_alloc);\n         gcm = (gc_alloc*) realloc((void*)gcm, sz, memory_region::LOCAL);\n-        DLOG(dom, task, \"task %s @0x%\" PRIxPTR\n+        DLOG(sched, task, \"task %s @0x%\" PRIxPTR\n              \" reallocated %d GC bytes = 0x%\" PRIxPTR,\n              name, (uintptr_t)this, sz, gcm);\n         if (!gcm)\n@@ -406,7 +386,7 @@ rust_task::free(void *p, bool is_gc)\n     if (is_gc) {\n         gc_alloc *gcm = (gc_alloc*)(((char *)p) - sizeof(gc_alloc));\n         unlink_gc(gcm);\n-        DLOG(dom, mem,\n+        DLOG(sched, mem,\n              \"task %s @0x%\" PRIxPTR \" freeing GC memory = 0x%\" PRIxPTR,\n              name, (uintptr_t)this, gcm);\n         free(gcm, memory_region::LOCAL);\n@@ -417,11 +397,11 @@ rust_task::free(void *p, bool is_gc)\n \n void\n rust_task::transition(rust_task_list *src, rust_task_list *dst) {\n-    I(dom, kernel->scheduler_lock.lock_held_by_current_thread());\n-    DLOG(dom, task,\n+    I(sched, kernel->scheduler_lock.lock_held_by_current_thread());\n+    DLOG(sched, task,\n          \"task %s \" PTR \" state change '%s' -> '%s' while in '%s'\",\n          name, (uintptr_t)this, src->name, dst->name, state->name);\n-    I(dom, state == src);\n+    I(sched, state == src);\n     src->remove(this);\n     dst->append(this);\n     state = dst;\n@@ -431,30 +411,30 @@ void\n rust_task::block(rust_cond *on, const char* name) {\n     LOG(this, task, \"Blocking on 0x%\" PRIxPTR \", cond: 0x%\" PRIxPTR,\n                          (uintptr_t) on, (uintptr_t) cond);\n-    A(dom, cond == NULL, \"Cannot block an already blocked task.\");\n-    A(dom, on != NULL, \"Cannot block on a NULL object.\");\n+    A(sched, cond == NULL, \"Cannot block an already blocked task.\");\n+    A(sched, on != NULL, \"Cannot block on a NULL object.\");\n \n-    transition(&dom->running_tasks, &dom->blocked_tasks);\n+    transition(&sched->running_tasks, &sched->blocked_tasks);\n     cond = on;\n     cond_name = name;\n }\n \n void\n rust_task::wakeup(rust_cond *from) {\n-    A(dom, cond != NULL, \"Cannot wake up unblocked task.\");\n+    A(sched, cond != NULL, \"Cannot wake up unblocked task.\");\n     LOG(this, task, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n                         (uintptr_t) cond, (uintptr_t) from);\n-    A(dom, cond == from, \"Cannot wake up blocked task on wrong condition.\");\n+    A(sched, cond == from, \"Cannot wake up blocked task on wrong condition.\");\n \n-    transition(&dom->blocked_tasks, &dom->running_tasks);\n-    I(dom, cond == from);\n+    transition(&sched->blocked_tasks, &sched->running_tasks);\n+    I(sched, cond == from);\n     cond = NULL;\n     cond_name = \"none\";\n }\n \n void\n rust_task::die() {\n-    transition(&dom->running_tasks, &dom->dead_tasks);\n+    transition(&sched->running_tasks, &sched->dead_tasks);\n }\n \n void\n@@ -467,8 +447,8 @@ rust_crate_cache *\n rust_task::get_crate_cache()\n {\n     if (!cache) {\n-        DLOG(dom, task, \"fetching cache for current crate\");\n-        cache = dom->get_cache();\n+        DLOG(sched, task, \"fetching cache for current crate\");\n+        cache = sched->get_cache();\n     }\n     return cache;\n }\n@@ -486,7 +466,7 @@ rust_task::backtrace() {\n rust_handle<rust_task> *\n rust_task::get_handle() {\n     if (handle == NULL) {\n-        handle = dom->kernel->get_task_handle(this);\n+        handle = sched->kernel->get_task_handle(this);\n     }\n     return handle;\n }\n@@ -503,7 +483,7 @@ rust_task::malloc(size_t size, memory_region::memory_region_type type) {\n     } else if (type == memory_region::SYNCHRONIZED) {\n         return synchronized_region.malloc(size);\n     }\n-    I(dom, false);\n+    I(sched, false);\n     return NULL;\n }\n \n@@ -535,7 +515,7 @@ rust_task::realloc(void *mem, size_t size,\n \n void\n rust_task::free(void *mem, memory_region::memory_region_type type) {\n-    DLOG(dom, mem, \"rust_task::free(0x%\" PRIxPTR \")\", mem);\n+    DLOG(sched, mem, \"rust_task::free(0x%\" PRIxPTR \")\", mem);\n     if (type == memory_region::LOCAL) {\n         local_region.free(mem);\n     } else if (type == memory_region::SYNCHRONIZED) {"}, {"sha": "54287df441439d5ceb0ee867d6ab7522f677d223", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -43,7 +43,7 @@ rust_task : public maybe_proxy<rust_task>,\n     uintptr_t runtime_sp;      // Runtime sp while task running.\n     uintptr_t rust_sp;         // Saved sp when not running.\n     gc_alloc *gc_alloc_chain;  // Linked list of GC allocations.\n-    rust_dom *dom;\n+    rust_scheduler *sched;\n     rust_crate_cache *cache;\n \n     // Fields known only to the runtime.\n@@ -83,7 +83,7 @@ rust_task : public maybe_proxy<rust_task>,\n     memory_region synchronized_region;\n \n     // Only a pointer to 'name' is kept, so it must live as long as this task.\n-    rust_task(rust_dom *dom,\n+    rust_task(rust_scheduler *sched,\n               rust_task_list *state,\n               rust_task *spawner,\n               const char *name);\n@@ -111,8 +111,8 @@ rust_task : public maybe_proxy<rust_task>,\n     void die();\n     void unblock();\n \n-    void check_active() { I(dom, dom->curr_task == this); }\n-    void check_suspended() { I(dom, dom->curr_task != this); }\n+    void check_active() { I(sched, sched->curr_task == this); }\n+    void check_suspended() { I(sched, sched->curr_task != this); }\n \n     // Print a backtrace, if the \"bt\" logging option is on.\n     void backtrace();"}, {"sha": "81441de35f57281b1a96ace29db5aab1ad4ee323", "filename": "src/rt/rust_task_list.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_task_list.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_task_list.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_list.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -1,16 +1,16 @@\n #include \"rust_internal.h\"\n \n-rust_task_list::rust_task_list (rust_dom *dom, const char* name) :\n-    dom(dom), name(name) {\n+rust_task_list::rust_task_list (rust_scheduler *sched, const char* name) :\n+    sched(sched), name(name) {\n     // Nop;\n }\n \n void\n rust_task_list::delete_all() {\n-    DLOG(dom, task, \"deleting all %s tasks\", name);\n+    DLOG(sched, task, \"deleting all %s tasks\", name);\n     while (is_empty() == false) {\n         rust_task *task = pop_value();\n-        DLOG(dom, task, \"deleting task \" PTR, task);\n+        DLOG(sched, task, \"deleting task \" PTR, task);\n         delete task;\n     }\n }"}, {"sha": "0991b32eed85ff76f34b40fc9271c72cf405e148", "filename": "src/rt/rust_task_list.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_task_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_task_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_list.h?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -1,4 +1,4 @@\n-// -*- c++-mode -*-\n+// -*- c++ -*-\n #ifndef RUST_TASK_LIST_H\n #define RUST_TASK_LIST_H\n \n@@ -8,9 +8,9 @@\n class rust_task_list : public indexed_list<rust_task>,\n                        public kernel_owned<rust_task_list> {\n public:\n-    rust_dom *dom;\n+    rust_scheduler *sched;\n     const char* name;\n-    rust_task_list (rust_dom *dom, const char* name);\n+    rust_task_list (rust_scheduler *sched, const char* name);\n     void delete_all();\n };\n "}, {"sha": "2b1c33aa6b9e4ba6ade3279118a0b5965d9e2f09", "filename": "src/rt/rust_timer.cpp", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_timer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_timer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_timer.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -29,8 +29,8 @@ static void *\n timer_loop(void *ptr) {\n     // We were handed the rust_timer that owns us.\n     rust_timer *timer = (rust_timer *)ptr;\n-    rust_dom *dom = timer->dom;\n-    DLOG(dom, timer, \"in timer 0x%\" PRIxPTR, (uintptr_t)timer);\n+    rust_scheduler *sched = timer->sched;\n+    DLOG(sched, timer, \"in timer 0x%\" PRIxPTR, (uintptr_t)timer);\n     size_t ms = TIME_SLICE_IN_MS;\n \n     while (!timer->exit_flag) {\n@@ -39,10 +39,10 @@ timer_loop(void *ptr) {\n #else\n         usleep(ms * 1000);\n #endif\n-        DLOG(dom, timer, \"timer 0x%\" PRIxPTR\n-        \" interrupting domain 0x%\" PRIxPTR, (uintptr_t) timer,\n-                 (uintptr_t) dom);\n-        dom->interrupt_flag = 1;\n+        DLOG(sched, timer, \"timer 0x%\" PRIxPTR\n+        \" interrupting schedain 0x%\" PRIxPTR, (uintptr_t) timer,\n+                 (uintptr_t) sched);\n+        sched->interrupt_flag = 1;\n     }\n #if defined(__WIN32__)\n     ExitThread(0);\n@@ -52,12 +52,12 @@ timer_loop(void *ptr) {\n     return 0;\n }\n \n-rust_timer::rust_timer(rust_dom *dom) :\n-    dom(dom), exit_flag(0) {\n-    DLOG(dom, timer, \"creating timer for domain 0x%\" PRIxPTR, dom);\n+rust_timer::rust_timer(rust_scheduler *sched) :\n+    sched(sched), exit_flag(0) {\n+    DLOG(sched, timer, \"creating timer for domain 0x%\" PRIxPTR, sched);\n #if defined(__WIN32__)\n     thread = CreateThread(NULL, 0, timer_loop, this, 0, NULL);\n-    dom->kernel->win32_require(\"CreateThread\", thread != NULL);\n+    sched->kernel->win32_require(\"CreateThread\", thread != NULL);\n     if (RUNNING_ON_VALGRIND)\n         Sleep(10);\n #else\n@@ -70,7 +70,7 @@ rust_timer::rust_timer(rust_dom *dom) :\n rust_timer::~rust_timer() {\n     exit_flag = 1;\n #if defined(__WIN32__)\n-    dom->kernel->win32_require(\"WaitForSingleObject\",\n+    sched->kernel->win32_require(\"WaitForSingleObject\",\n                                WaitForSingleObject(thread, INFINITE) == \n                                WAIT_OBJECT_0);\n #else"}, {"sha": "18d9f4c1e8cac0a54af007beb1630bdd02ec0f52", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -23,52 +23,52 @@ str_buf(rust_task *task, rust_str *s);\n \n extern \"C\" void\n upcall_grow_task(rust_task *task, size_t n_frame_bytes) {\n-    I(task->dom, false);\n+    I(task->sched, false);\n     LOG_UPCALL_ENTRY(task);\n     task->grow(n_frame_bytes);\n }\n \n extern \"C\" CDECL\n void upcall_log_int(rust_task *task, uint32_t level, int32_t i) {\n     LOG_UPCALL_ENTRY(task);\n-    if (task->dom->log_lvl >= level)\n-        task->dom->log(task, level, \"rust: %\" PRId32 \" (0x%\" PRIx32 \")\",\n+    if (task->sched->log_lvl >= level)\n+        task->sched->log(task, level, \"rust: %\" PRId32 \" (0x%\" PRIx32 \")\",\n                        i, i);\n }\n \n extern \"C\" CDECL\n void upcall_log_float(rust_task *task, uint32_t level, float f) {\n     LOG_UPCALL_ENTRY(task);\n-    if (task->dom->log_lvl >= level)\n-        task->dom->log(task, level, \"rust: %12.12f\", f);\n+    if (task->sched->log_lvl >= level)\n+        task->sched->log(task, level, \"rust: %12.12f\", f);\n }\n \n extern \"C\" CDECL\n void upcall_log_double(rust_task *task, uint32_t level, double *f) {\n     LOG_UPCALL_ENTRY(task);\n-    if (task->dom->log_lvl >= level)\n-        task->dom->log(task, level, \"rust: %12.12f\", *f);\n+    if (task->sched->log_lvl >= level)\n+        task->sched->log(task, level, \"rust: %12.12f\", *f);\n }\n \n extern \"C\" CDECL void\n upcall_log_str(rust_task *task, uint32_t level, rust_str *str) {\n     LOG_UPCALL_ENTRY(task);\n-    if (task->dom->log_lvl >= level) {\n+    if (task->sched->log_lvl >= level) {\n         const char *c = str_buf(task, str);\n-        task->dom->log(task, level, \"rust: %s\", c);\n+        task->sched->log(task, level, \"rust: %s\", c);\n     }\n }\n \n extern \"C\" CDECL void\n upcall_trace_word(rust_task *task, uintptr_t i) {\n     LOG_UPCALL_ENTRY(task);\n-    task->dom->log(task, 2, \"trace: 0x%\" PRIxPTR \"\", i, i, (char) i);\n+    task->sched->log(task, 2, \"trace: 0x%\" PRIxPTR \"\", i, i, (char) i);\n }\n \n extern \"C\" CDECL void\n upcall_trace_str(rust_task *task, char const *c) {\n     LOG_UPCALL_ENTRY(task);\n-    task->dom->log(task, 2, \"trace: %s\", c);\n+    task->sched->log(task, 2, \"trace: %s\", c);\n }\n \n extern \"C\" CDECL rust_port*\n@@ -85,7 +85,7 @@ upcall_del_port(rust_task *task, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n     scoped_lock with(task->kernel->scheduler_lock);\n     LOG(task, comm, \"upcall del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n-    I(task->dom, !port->ref_count);\n+    I(task->sched, !port->ref_count);\n     delete port;\n }\n \n@@ -95,11 +95,11 @@ upcall_del_port(rust_task *task, rust_port *port) {\n extern \"C\" CDECL rust_chan*\n upcall_new_chan(rust_task *task, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_dom *dom = task->dom;\n+    rust_scheduler *sched = task->sched;\n     LOG(task, comm, \"upcall_new_chan(\"\n         \"task=0x%\" PRIxPTR \" (%s), port=0x%\" PRIxPTR \")\",\n         (uintptr_t) task, task->name, port);\n-    I(dom, port);\n+    I(sched, port);\n     return new (task) rust_chan(task, port, port->unit_sz);\n }\n \n@@ -127,7 +127,7 @@ void upcall_del_chan(rust_task *task, rust_chan *chan) {\n \n     LOG(task, comm, \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n \n-    A(task->dom, chan->ref_count == 0,\n+    A(task->sched, chan->ref_count == 0,\n       \"Channel's ref count should be zero.\");\n \n     if (chan->is_associated()) {\n@@ -174,7 +174,7 @@ upcall_clone_chan(rust_task *task, maybe_proxy<rust_task> *target,\n         target_task = target->referent();\n     } else {\n         rust_handle<rust_port> *handle =\n-            task->dom->kernel->get_port_handle(port->as_referent());\n+            task->sched->kernel->get_port_handle(port->as_referent());\n         maybe_proxy<rust_port> *proxy = new rust_proxy<rust_port> (handle);\n         LOG(task, mem, \"new proxy: \" PTR, proxy);\n         port = proxy;\n@@ -275,7 +275,7 @@ upcall_exit(rust_task *task) {\n         LOG_UPCALL_ENTRY(task);\n         scoped_lock with(task->kernel->scheduler_lock);\n         LOG(task, task, \"task ref_count: %d\", task->ref_count);\n-        A(task->dom, task->ref_count >= 0,\n+        A(task->sched, task->ref_count >= 0,\n           \"Task ref_count should not be negative on exit!\");\n         task->die();\n         task->notify_tasks_waiting_to_join();\n@@ -308,8 +308,8 @@ extern \"C\" CDECL void\n upcall_free(rust_task *task, void* ptr, uintptr_t is_gc) {\n     LOG_UPCALL_ENTRY(task);\n     scoped_lock with(task->kernel->scheduler_lock);\n-    rust_dom *dom = task->dom;\n-    DLOG(dom, mem,\n+    rust_scheduler *sched = task->sched;\n+    DLOG(sched, mem,\n              \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n              (uintptr_t)ptr, is_gc);\n     task->free(ptr, (bool) is_gc);\n@@ -320,26 +320,26 @@ upcall_mark(rust_task *task, void* ptr) {\n     LOG_UPCALL_ENTRY(task);\n     scoped_lock with(task->kernel->scheduler_lock);\n \n-    rust_dom *dom = task->dom;\n+    rust_scheduler *sched = task->sched;\n     if (ptr) {\n         gc_alloc *gcm = (gc_alloc*) (((char*)ptr) - sizeof(gc_alloc));\n         uintptr_t marked = (uintptr_t) gcm->mark();\n-        DLOG(dom, gc, \"upcall mark(0x%\" PRIxPTR \") = %\" PRIdPTR,\n+        DLOG(sched, gc, \"upcall mark(0x%\" PRIxPTR \") = %\" PRIdPTR,\n                  (uintptr_t)gcm, marked);\n         return marked;\n     }\n     return 0;\n }\n \n rust_str *make_str(rust_task *task, char const *s, size_t fill) {\n-    rust_dom *dom = task->dom;\n+    rust_scheduler *sched = task->sched;\n     size_t alloc = next_power_of_two(sizeof(rust_str) + fill);\n     void *mem = task->malloc(alloc);\n     if (!mem) {\n         task->fail(3);\n         return NULL;\n     }\n-    rust_str *st = new (mem) rust_str(dom, alloc, fill, (uint8_t const *) s);\n+    rust_str *st = new (mem) rust_str(sched, alloc, fill, (uint8_t const *) s);\n     LOG(task, mem,\n         \"upcall new_str('%s', %\" PRIdPTR \") = 0x%\" PRIxPTR,\n         s, fill, st);\n@@ -366,15 +366,15 @@ extern \"C\" CDECL rust_vec *\n upcall_new_vec(rust_task *task, size_t fill, type_desc *td) {\n     LOG_UPCALL_ENTRY(task);\n     scoped_lock with(task->kernel->scheduler_lock);\n-    rust_dom *dom = task->dom;\n-    DLOG(dom, mem, \"upcall new_vec(%\" PRIdPTR \")\", fill);\n+    rust_scheduler *sched = task->sched;\n+    DLOG(sched, mem, \"upcall new_vec(%\" PRIdPTR \")\", fill);\n     size_t alloc = next_power_of_two(sizeof(rust_vec) + fill);\n     void *mem = task->malloc(alloc, td);\n     if (!mem) {\n         task->fail(3);\n         return NULL;\n     }\n-    rust_vec *v = new (mem) rust_vec(dom, alloc, 0, NULL);\n+    rust_vec *v = new (mem) rust_vec(sched, alloc, 0, NULL);\n     LOG(task, mem,\n               \"upcall new_vec(%\" PRIdPTR \") = 0x%\" PRIxPTR, fill, v);\n     return v;\n@@ -387,7 +387,7 @@ vec_grow(rust_task *task,\n          uintptr_t *need_copy,\n          type_desc *td)\n {\n-    rust_dom *dom = task->dom;\n+    rust_scheduler *sched = task->sched;\n     LOG(task, mem,\n         \"vec_grow(0x%\" PRIxPTR \", %\" PRIdPTR\n         \"), rc=%\" PRIdPTR \" alloc=%\" PRIdPTR \", fill=%\" PRIdPTR\n@@ -438,10 +438,10 @@ vec_grow(rust_task *task,\n         if (v->ref_count != CONST_REFCOUNT)\n             v->deref();\n \n-        v = new (mem) rust_vec(dom, alloc, 0, NULL);\n+        v = new (mem) rust_vec(sched, alloc, 0, NULL);\n         *need_copy = 1;\n     }\n-    I(dom, sizeof(rust_vec) + v->fill <= v->alloc);\n+    I(sched, sizeof(rust_vec) + v->fill <= v->alloc);\n     return v;\n }\n \n@@ -521,8 +521,8 @@ upcall_new_task(rust_task *spawner, rust_vec *name) {\n     // name is a rust string structure.\n     LOG_UPCALL_ENTRY(spawner);\n     scoped_lock with(spawner->kernel->scheduler_lock);\n-    rust_dom *dom = spawner->dom;\n-    rust_task *task = dom->create_task(spawner, (const char *)name->data);\n+    rust_scheduler *sched = spawner->sched;\n+    rust_task *task = sched->create_task(spawner, (const char *)name->data);\n     return task;\n }\n \n@@ -534,8 +534,8 @@ upcall_start_task(rust_task *spawner,\n                   size_t args_sz) {\n     LOG_UPCALL_ENTRY(spawner);\n \n-    rust_dom *dom = spawner->dom;\n-    DLOG(dom, task,\n+    rust_scheduler *sched = spawner->sched;\n+    DLOG(sched, task,\n          \"upcall start_task(task %s @0x%\" PRIxPTR\n          \", spawnee 0x%\" PRIxPTR \")\", \n          task->name, task,\n@@ -563,7 +563,7 @@ upcall_ivec_resize(rust_task *task,\n                    rust_ivec *v,\n                    size_t newsz) {\n     scoped_lock with(task->kernel->scheduler_lock);\n-    I(task->dom, !v->fill);\n+    I(task->sched, !v->fill);\n \n     size_t new_alloc = next_power_of_two(newsz);\n     rust_ivec_heap *new_heap_part = (rust_ivec_heap *)"}, {"sha": "984cd978ec284a7514a0e9f7b5b3a67078e6498f", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/657e5a2bd579f7f1698f8ba88cb1142ced7a477f/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=657e5a2bd579f7f1698f8ba88cb1142ced7a477f", "patch": "@@ -25,39 +25,39 @@ ptr_vec<T>::ptr_vec(rust_task *task) :\n     fill(0),\n     data(new (task) T*[alloc])\n {\n-    I(task->dom, data);\n-    DLOG(task->dom, mem, \"new ptr_vec(data=0x%\" PRIxPTR \") -> 0x%\" PRIxPTR,\n+    I(task->sched, data);\n+    DLOG(task->sched, mem, \"new ptr_vec(data=0x%\" PRIxPTR \") -> 0x%\" PRIxPTR,\n          (uintptr_t)data, (uintptr_t)this);\n }\n \n template <typename T>\n ptr_vec<T>::~ptr_vec()\n {\n-    I(task->dom, data);\n-    DLOG(task->dom, mem, \"~ptr_vec 0x%\" PRIxPTR \", data=0x%\" PRIxPTR,\n+    I(task->sched, data);\n+    DLOG(task->sched, mem, \"~ptr_vec 0x%\" PRIxPTR \", data=0x%\" PRIxPTR,\n          (uintptr_t)this, (uintptr_t)data);\n-    I(task->dom, fill == 0);\n+    I(task->sched, fill == 0);\n     task->free(data);\n }\n \n template <typename T> T *&\n ptr_vec<T>::operator[](size_t offset) {\n-    I(task->dom, data[offset]->idx == offset);\n+    I(task->sched, data[offset]->idx == offset);\n     return data[offset];\n }\n \n template <typename T>\n void\n ptr_vec<T>::push(T *p)\n {\n-    I(task->dom, data);\n-    I(task->dom, fill <= alloc);\n+    I(task->sched, data);\n+    I(task->sched, fill <= alloc);\n     if (fill == alloc) {\n         alloc *= 2;\n         data = (T **)task->realloc(data, alloc * sizeof(T*));\n-        I(task->dom, data);\n+        I(task->sched, data);\n     }\n-    I(task->dom, fill < alloc);\n+    I(task->sched, fill < alloc);\n     p->idx = fill;\n     data[fill++] = p;\n }\n@@ -80,13 +80,13 @@ template <typename T>\n void\n ptr_vec<T>::trim(size_t sz)\n {\n-    I(task->dom, data);\n+    I(task->sched, data);\n     if (sz <= (alloc / 4) &&\n         (alloc / 2) >= INIT_SIZE) {\n         alloc /= 2;\n-        I(task->dom, alloc >= fill);\n+        I(task->sched, alloc >= fill);\n         data = (T **)task->realloc(data, alloc * sizeof(T*));\n-        I(task->dom, data);\n+        I(task->sched, data);\n     }\n }\n \n@@ -95,9 +95,9 @@ void\n ptr_vec<T>::swap_delete(T *item)\n {\n     /* Swap the endpoint into i and decr fill. */\n-    I(task->dom, data);\n-    I(task->dom, fill > 0);\n-    I(task->dom, item->idx < fill);\n+    I(task->sched, data);\n+    I(task->sched, fill > 0);\n+    I(task->sched, item->idx < fill);\n     fill--;\n     if (fill > 0) {\n         T *subst = data[fill];\n@@ -127,22 +127,22 @@ next_power_of_two(size_t s)\n // Initialization helper for ISAAC RNG\n \n static inline void\n-isaac_init(rust_dom *dom, randctx *rctx)\n+isaac_init(rust_scheduler *sched, randctx *rctx)\n {\n         memset(rctx, 0, sizeof(randctx));\n \n #ifdef __WIN32__\n         {\n             HCRYPTPROV hProv;\n-            dom->kernel->win32_require\n+            sched->kernel->win32_require\n                 (_T(\"CryptAcquireContext\"),\n                  CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL,\n                                      CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n-            dom->kernel->win32_require\n+            sched->kernel->win32_require\n                 (_T(\"CryptGenRandom\"),\n                  CryptGenRandom(hProv, sizeof(rctx->randrsl),\n                                 (BYTE*)(&rctx->randrsl)));\n-            dom->kernel->win32_require\n+            sched->kernel->win32_require\n                 (_T(\"CryptReleaseContext\"),\n                  CryptReleaseContext(hProv, 0));\n         }\n@@ -156,11 +156,11 @@ isaac_init(rust_dom *dom, randctx *rctx)\n             }\n         } else {\n             int fd = open(\"/dev/urandom\", O_RDONLY);\n-            I(dom, fd > 0);\n-            I(dom, \n+            I(sched, fd > 0);\n+            I(sched, \n               read(fd, (void*) &rctx->randrsl, sizeof(rctx->randrsl))\n               == sizeof(rctx->randrsl));\n-            I(dom, close(fd) == 0);\n+            I(sched, close(fd) == 0);\n         }\n #endif\n         randinit(rctx, 1);\n@@ -175,9 +175,10 @@ rust_vec : public rc_base<rust_vec>\n     size_t fill;\n     size_t pad; // Pad to align data[0] to 16 bytes.\n     uint8_t data[];\n-    rust_vec(rust_dom *dom, size_t alloc, size_t fill, uint8_t const *d) :\n-        alloc(alloc),\n-        fill(fill)\n+    rust_vec(rust_scheduler *sched, size_t alloc, size_t fill, \n+             uint8_t const *d) \n+        : alloc(alloc),\n+          fill(fill)\n     {\n         if (d)\n             memcpy(&data[0], d, fill);"}]}