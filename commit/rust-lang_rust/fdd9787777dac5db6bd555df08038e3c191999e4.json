{"sha": "fdd9787777dac5db6bd555df08038e3c191999e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZDk3ODc3NzdkYWM1ZGI2YmQ1NTVkZjA4MDM4ZTNjMTkxOTk5ZTQ=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-26T07:18:19Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-11T11:01:44Z"}, "message": "Introduce ConstValue and use it instead of miri's Value for constant values", "tree": {"sha": "c69aed643a634de3d037ce9ea53be02c92c992fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c69aed643a634de3d037ce9ea53be02c92c992fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdd9787777dac5db6bd555df08038e3c191999e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd9787777dac5db6bd555df08038e3c191999e4", "html_url": "https://github.com/rust-lang/rust/commit/fdd9787777dac5db6bd555df08038e3c191999e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdd9787777dac5db6bd555df08038e3c191999e4/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41707d8df9a441e19387a4a61415ee0af58a9e48", "url": "https://api.github.com/repos/rust-lang/rust/commits/41707d8df9a441e19387a4a61415ee0af58a9e48", "html_url": "https://github.com/rust-lang/rust/commit/41707d8df9a441e19387a4a61415ee0af58a9e48"}], "stats": {"total": 1722, "additions": 985, "deletions": 737}, "files": [{"sha": "54dda320e1fca7b4f559e061bad3522c3726458a", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -60,7 +60,7 @@\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n-use mir::interpret::{GlobalId};\n+use mir::interpret::{GlobalId, ConstValue};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};"}, {"sha": "1036eae9b856b0092ec949d94aa3655a33dcfb17", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -384,6 +384,30 @@ for ::middle::const_val::ConstVal<'gcx> {\n     }\n }\n \n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n+for ::mir::interpret::ConstValue<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use mir::interpret::ConstValue::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            ByVal(val) => {\n+                val.hash_stable(hcx, hasher);\n+            }\n+            ByValPair(a, b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+            ByRef(alloc) => {\n+                alloc.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n impl_stable_hash_for!(enum mir::interpret::Value {\n     ByVal(v),\n     ByValPair(a, b),"}, {"sha": "3a76f75d01833a8dbb9ad6cf0653d2e8fd0c7b10", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -11,7 +11,7 @@\n use hir::def_id::DefId;\n use ty::{self, TyCtxt, layout};\n use ty::subst::Substs;\n-use mir::interpret::{Value, PrimVal};\n+use mir::interpret::ConstValue;\n use errors::DiagnosticBuilder;\n \n use graphviz::IntoCow;\n@@ -25,27 +25,7 @@ pub type EvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ConstEvalErr<'tcx>>;\n #[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal<'tcx> {\n     Unevaluated(DefId, &'tcx Substs<'tcx>),\n-    Value(Value),\n-}\n-\n-impl<'tcx> ConstVal<'tcx> {\n-    pub fn to_raw_bits(&self) -> Option<u128> {\n-        match *self {\n-            ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n-                Some(b)\n-            },\n-            _ => None,\n-        }\n-    }\n-    pub fn unwrap_u64(&self) -> u64 {\n-        match self.to_raw_bits() {\n-            Some(val) => {\n-                assert_eq!(val as u64 as u128, val);\n-                val as u64\n-            },\n-            None => bug!(\"expected constant u64, got {:#?}\", self),\n-        }\n-    }\n+    Value(ConstValue<'tcx>),\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "a4c38333da19e8343550ba11ee954756ecb9333a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -945,7 +945,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n-            ty::TyArray(_, len) if len.val.to_raw_bits() == Some(0) => true,\n+            ty::TyArray(_, len) if len.assert_usize(self.tcx) == Some(0) => true,\n             _ => promotable,\n         };\n "}, {"sha": "afdd1c167c6dc781b488a0c06d55be60e757952b", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -10,7 +10,7 @@ mod value;\n \n pub use self::error::{EvalError, EvalResult, EvalErrorKind, AssertMessage};\n \n-pub use self::value::{PrimVal, PrimValKind, Value, Pointer};\n+pub use self::value::{PrimVal, PrimValKind, Value, Pointer, ConstValue};\n \n use std::collections::BTreeMap;\n use std::fmt;\n@@ -20,8 +20,10 @@ use ty::{self, TyCtxt};\n use ty::layout::{self, Align, HasDataLayout};\n use middle::region;\n use std::iter;\n+use std::io;\n use syntax::ast::Mutability;\n use rustc_serialize::{Encoder, Decoder, Decodable, Encodable};\n+use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n \n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Lock {\n@@ -235,7 +237,7 @@ impl fmt::Display for AllocId {\n     }\n }\n \n-#[derive(Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer\n@@ -254,17 +256,69 @@ pub struct Allocation {\n }\n \n impl Allocation {\n-    pub fn from_bytes(slice: &[u8]) -> Self {\n+    pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n         let mut undef_mask = UndefMask::new(0);\n         undef_mask.grow(slice.len() as u64, true);\n         Self {\n             bytes: slice.to_owned(),\n             relocations: BTreeMap::new(),\n             undef_mask,\n-            align: Align::from_bytes(1, 1).unwrap(),\n+            align,\n             runtime_mutability: Mutability::Immutable,\n         }\n     }\n+\n+    pub fn from_byte_aligned_bytes(slice: &[u8]) -> Self {\n+        Allocation::from_bytes(slice, Align::from_bytes(1, 1).unwrap())\n+    }\n+\n+    pub fn undef(size: u64, align: Align) -> Self {\n+        assert_eq!(size as usize as u64, size);\n+        Allocation {\n+            bytes: vec![0; size as usize],\n+            relocations: BTreeMap::new(),\n+            undef_mask: UndefMask::new(size),\n+            align,\n+            runtime_mutability: Mutability::Immutable,\n+        }\n+    }\n+}\n+\n+impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Methods to access integers in the target endianness\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub fn write_target_uint(\n+    endianness: layout::Endian,\n+    mut target: &mut [u8],\n+    data: u128,\n+) -> Result<(), io::Error> {\n+    let len = target.len();\n+    match endianness {\n+        layout::Endian::Little => target.write_uint128::<LittleEndian>(data, len),\n+        layout::Endian::Big => target.write_uint128::<BigEndian>(data, len),\n+    }\n+}\n+\n+pub fn write_target_int(\n+    endianness: layout::Endian,\n+    mut target: &mut [u8],\n+    data: i128,\n+) -> Result<(), io::Error> {\n+    let len = target.len();\n+    match endianness {\n+        layout::Endian::Little => target.write_int128::<LittleEndian>(data, len),\n+        layout::Endian::Big => target.write_int128::<BigEndian>(data, len),\n+    }\n+}\n+\n+pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n+    match endianness {\n+        layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n+        layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "2cd4bf9d18ca55ef3b3aad375bf292561f818f86", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -3,7 +3,69 @@\n use ty::layout::{Align, HasDataLayout};\n use ty;\n \n-use super::{EvalResult, MemoryPointer, PointerArithmetic};\n+use super::{EvalResult, MemoryPointer, PointerArithmetic, Allocation};\n+\n+/// Represents a constant value in Rust. ByVal and ByValPair are optimizations which\n+/// matches Value's optimizations for easy conversions between these two types\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash)]\n+pub enum ConstValue<'tcx> {\n+    // Used only for types with layout::abi::Scalar ABI and ZSTs which use PrimVal::Undef\n+    ByVal(PrimVal),\n+    // Used only for types with layout::abi::ScalarPair\n+    ByValPair(PrimVal, PrimVal),\n+    // Used only for the remaining cases\n+    ByRef(&'tcx Allocation),\n+}\n+\n+impl<'tcx> ConstValue<'tcx> {\n+    #[inline]\n+    pub fn from_byval_value(val: Value) -> Self {\n+        match val {\n+            Value::ByRef(..) => bug!(),\n+            Value::ByValPair(a, b) => ConstValue::ByValPair(a, b),\n+            Value::ByVal(val) => ConstValue::ByVal(val),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_byval_value(&self) -> Option<Value> {\n+        match *self {\n+            ConstValue::ByRef(..) => None,\n+            ConstValue::ByValPair(a, b) => Some(Value::ByValPair(a, b)),\n+            ConstValue::ByVal(val) => Some(Value::ByVal(val)),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn from_primval(val: PrimVal) -> Self {\n+        ConstValue::ByVal(val)\n+    }\n+\n+    #[inline]\n+    pub fn to_primval(&self) -> Option<PrimVal> {\n+        match *self {\n+            ConstValue::ByRef(..) => None,\n+            ConstValue::ByValPair(..) => None,\n+            ConstValue::ByVal(val) => Some(val),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_bits(&self) -> Option<u128> {\n+        match self.to_primval() {\n+            Some(PrimVal::Bytes(val)) => Some(val),\n+            _ => None,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_ptr(&self) -> Option<MemoryPointer> {\n+        match self.to_primval() {\n+            Some(PrimVal::Ptr(ptr)) => Some(ptr),\n+            _ => None,\n+        }\n+    }\n+}\n \n /// A `Value` represents a single self-contained Rust value.\n ///"}, {"sha": "eb12444bcb4c92cc7279bd59a22efcdff47add05", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -13,7 +13,6 @@\n //! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir.html\n \n use graphviz::IntoCow;\n-use middle::const_val::ConstVal;\n use middle::region;\n use rustc_data_structures::sync::{Lrc};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -1549,11 +1548,7 @@ impl<'tcx> Operand<'tcx> {\n             span,\n             ty,\n             literal: Literal::Value {\n-                value: tcx.mk_const(ty::Const {\n-                    // ZST function type\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n-                    ty\n-                })\n+                value: ty::Const::zero_sized(tcx, ty),\n             },\n         })\n     }\n@@ -1881,11 +1876,17 @@ impl<'tcx> Debug for Literal<'tcx> {\n }\n \n /// Write a `ConstVal` in a way closer to the original source code than the `Debug` output.\n-fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n-    use middle::const_val::ConstVal::*;\n+pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n+    use middle::const_val::ConstVal;\n     match const_val.val {\n-        Unevaluated(..) => write!(fmt, \"{:?}\", const_val),\n-        Value(val) => print_miri_value(val, const_val.ty, fmt),\n+        ConstVal::Unevaluated(..) => write!(fmt, \"{:?}\", const_val),\n+        ConstVal::Value(val) => {\n+            if let Some(value) = val.to_byval_value() {\n+                print_miri_value(value, const_val.ty, fmt)\n+            } else {\n+                write!(fmt, \"{:?}:{}\", val, const_val.ty)\n+            }\n+        },\n     }\n }\n "}, {"sha": "67dfad50f4435ee0c67890e913c1517f2ddd9ca1", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                 PlaceTy::Ty {\n                     ty: match ty.sty {\n                         ty::TyArray(inner, size) => {\n-                            let size = size.val.unwrap_u64();\n+                            let size = size.unwrap_usize(tcx);\n                             let len = size - (from as u64) - (to as u64);\n                             tcx.mk_array(inner, len)\n                         }"}, {"sha": "d911f32ed3f1f7bc227d5f08ab4854de38011233", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -24,6 +24,7 @@ use std::hash::Hash;\n use std::intrinsics;\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n+use mir::interpret::Allocation;\n \n /// The shorthand encoding uses an enum's variant index `usize`\n /// and is offset by this value so it never matches a real variant.\n@@ -262,6 +263,15 @@ pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n     Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n }\n \n+#[inline]\n+pub fn decode_allocation<'a, 'tcx, D>(decoder: &mut D)\n+                                 -> Result<&'tcx Allocation, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    Ok(decoder.tcx().intern_const_alloc(Decodable::decode(decoder)?))\n+}\n+\n #[macro_export]\n macro_rules! __impl_decoder_methods {\n     ($($name:ident -> $ty:ty;)*) => {\n@@ -393,6 +403,15 @@ macro_rules! implement_ty_decoder {\n                     decode_const(self)\n                 }\n             }\n+\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::mir::interpret::Allocation>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(\n+                    &mut self\n+                ) -> Result<&'tcx $crate::mir::interpret::Allocation, Self::Error> {\n+                    decode_allocation(self)\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "06e08a0e263cc46fff07adc3005a648fe82f90cb", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -26,14 +26,12 @@ use lint::{self, Lint};\n use ich::{StableHashingContext, NodeIdHashingMode};\n use infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use infer::outlives::free_region_map::FreeRegionMap;\n-use middle::const_val::ConstVal;\n use middle::cstore::{CrateStore, LinkMeta};\n use middle::cstore::EncodedMetadata;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::{self, Mir, interpret};\n-use mir::interpret::{Value, PrimVal};\n use ty::subst::{Kind, Substs, Subst};\n use ty::ReprOptions;\n use ty::Instance;\n@@ -1132,7 +1130,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return alloc_id;\n         }\n         // create an allocation that just contains these bytes\n-        let alloc = interpret::Allocation::from_bytes(bytes);\n+        let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n \n         // the next unique id\n@@ -2375,10 +2373,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        self.mk_ty(TyArray(ty, self.mk_const(ty::Const {\n-            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n.into()))),\n-            ty: self.types.usize\n-        })))\n+        self.mk_ty(TyArray(ty, ty::Const::from_usize(self, n)))\n     }\n \n     pub fn mk_slice(self, ty: Ty<'tcx>) -> Ty<'tcx> {"}, {"sha": "7dfdc592647dbafaa7cdd610c1dcbf60abc5983d", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n             ty::TyForeign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)),\n             ty::TyArray(_, n) => {\n-                match n.val.to_raw_bits() {\n+                match n.assert_usize(tcx) {\n                     Some(n) => format!(\"array of {} elements\", n),\n                     None => \"array\".to_string(),\n                 }"}, {"sha": "19e5406cd0d0a0aadf1d14224914d7280cac8dcb", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }))\n             },\n             TyArray(ty, len) => {\n-                match len.val.to_raw_bits() {\n+                match len.assert_usize(tcx) {\n                     // If the array is definitely non-empty, it's uninhabited if\n                     // the type of its elements is uninhabited.\n                     Some(n) if n != 0 => ty.uninhabited_from(visited, tcx),"}, {"sha": "9cbee143990791d7cca7e799f1f4a8eb6d4d70ba", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -543,7 +543,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 let element = self.layout_of(element)?;\n-                let count = count.val.unwrap_u64();\n+                let count = count.unwrap_usize(tcx);\n                 let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n "}, {"sha": "ca594faf5cd3b67522271e5b3a6783003cf601de", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -11,7 +11,7 @@\n use dep_graph::SerializedDepNodeIndex;\n use dep_graph::DepNode;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n-use mir::interpret::{GlobalId};\n+use mir::interpret::{GlobalId, ConstValue};\n use traits::query::{CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use ty::subst::Substs;"}, {"sha": "80402f87650c6f71c47aeb4908db02f0adb33a09", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -28,7 +28,7 @@ use middle::exported_symbols::{SymbolExportLevel, ExportedSymbol};\n use middle::const_val::EvalResult;\n use mir::mono::{CodegenUnit, Stats};\n use mir;\n-use mir::interpret::{GlobalId};\n+use mir::interpret::{GlobalId, Allocation, ConstValue};\n use session::{CompileResult, CrateDisambiguator};\n use session::config::OutputFilenames;\n use traits::{self, Vtable};"}, {"sha": "eede7bd2ea619ac230f5a63aa0371c1879cafbeb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -22,12 +22,11 @@ use hir::svh::Svh;\n use ich::Fingerprint;\n use ich::StableHashingContext;\n use infer::canonical::{Canonical, Canonicalize};\n-use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n use mir::Mir;\n-use mir::interpret::{GlobalId, Value, PrimVal};\n+use mir::interpret::GlobalId;\n use mir::GeneratorLayout;\n use session::CrateDisambiguator;\n use traits::{self, Reveal};\n@@ -1933,27 +1932,23 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             promoted: None\n         };\n         match tcx.const_eval(param_env.and(cid)) {\n-            Ok(&ty::Const {\n-                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n-                ty,\n-            }) => {\n-                trace!(\"discriminants: {} ({:?})\", b, repr_type);\n-                Some(Discr {\n-                    val: b,\n-                    ty,\n-                })\n-            },\n-            Ok(&ty::Const {\n-                val: ConstVal::Value(other),\n-                ..\n-            }) => {\n-                info!(\"invalid enum discriminant: {:#?}\", other);\n-                ::middle::const_val::struct_error(\n-                    tcx,\n-                    tcx.def_span(expr_did),\n-                    \"constant evaluation of enum discriminant resulted in non-integer\",\n-                ).emit();\n-                None\n+            Ok(val) => {\n+                // FIXME: Find the right type and use it instead of `val.ty` here\n+                if let Some(b) = val.assert_bits(val.ty) {\n+                    trace!(\"discriminants: {} ({:?})\", b, repr_type);\n+                    Some(Discr {\n+                        val: b,\n+                        ty: val.ty,\n+                    })\n+                } else {\n+                    info!(\"invalid enum discriminant: {:#?}\", val);\n+                    ::middle::const_val::struct_error(\n+                        tcx,\n+                        tcx.def_span(expr_did),\n+                        \"constant evaluation of enum discriminant resulted in non-integer\",\n+                    ).emit();\n+                    None\n+                }\n             }\n             Err(err) => {\n                 err.report(tcx, tcx.def_span(expr_did), \"enum discriminant\");\n@@ -1964,7 +1959,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 }\n                 None\n             }\n-            _ => span_bug!(tcx.def_span(expr_did), \"const eval \"),\n         }\n     }\n "}, {"sha": "4a33f1a1f54d2d268bfa3c2319e28fa0aa46780f", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -18,7 +18,7 @@ use middle::const_val::ConstVal;\n use ty::subst::{Kind, UnpackedKind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n-use mir::interpret::{GlobalId, Value, PrimVal};\n+use mir::interpret::GlobalId;\n use util::common::ErrorReported;\n use std::rc::Rc;\n use std::iter;\n@@ -469,8 +469,10 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             assert_eq!(sz_a.ty, tcx.types.usize);\n             assert_eq!(sz_b.ty, tcx.types.usize);\n             let to_u64 = |x: &'tcx ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n+                if let Some(s) = x.assert_usize(tcx) {\n+                    return Ok(s);\n+                }\n                 match x.val {\n-                    ConstVal::Value(Value::ByVal(prim)) => Ok(prim.to_u64().unwrap()),\n                     ConstVal::Unevaluated(def_id, substs) => {\n                         // FIXME(eddyb) get the right param_env.\n                         let param_env = ty::ParamEnv::empty();\n@@ -487,15 +489,10 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                         instance,\n                                         promoted: None\n                                     };\n-                                    match tcx.const_eval(param_env.and(cid)) {\n-                                        Ok(&ty::Const {\n-                                            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n-                                            ..\n-                                        }) => {\n-                                            assert_eq!(b as u64 as u128, b);\n-                                            return Ok(b as u64);\n-                                        }\n-                                        _ => {}\n+                                    if let Some(s) = tcx.const_eval(param_env.and(cid))\n+                                                        .ok()\n+                                                        .map(|c| c.unwrap_usize(tcx)) {\n+                                        return Ok(s)\n                                     }\n                                 }\n                             },"}, {"sha": "f0a7ce54971661db1768ba9e0d71467addb88bfc", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -19,6 +19,7 @@ use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n use util::captures::Captures;\n+use mir::interpret::{Allocation, PrimVal, MemoryPointer, Value, ConstValue};\n \n use std::iter;\n use std::cmp::Ordering;\n@@ -1730,4 +1731,156 @@ pub struct Const<'tcx> {\n     pub val: ConstVal<'tcx>,\n }\n \n+impl<'tcx> Const<'tcx> {\n+    pub fn unevaluated(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> &'tcx Self {\n+        tcx.mk_const(Const {\n+            val: ConstVal::Unevaluated(def_id, substs),\n+            ty,\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn from_const_val(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        val: ConstVal<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> &'tcx Self {\n+        tcx.mk_const(Const {\n+            val,\n+            ty,\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn from_const_value(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        val: ConstValue<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> &'tcx Self {\n+        Self::from_const_val(tcx, ConstVal::Value(val), ty)\n+    }\n+\n+    #[inline]\n+    pub fn from_alloc(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        alloc: &'tcx Allocation,\n+        ty: Ty<'tcx>,\n+    ) -> &'tcx Self {\n+        Self::from_const_value(tcx, ConstValue::ByRef(alloc), ty)\n+    }\n+\n+    #[inline]\n+    pub fn from_byval_value(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        val: Value,\n+        ty: Ty<'tcx>,\n+    ) -> &'tcx Self {\n+        Self::from_const_value(tcx, ConstValue::from_byval_value(val), ty)\n+    }\n+\n+    #[inline]\n+    pub fn from_primval(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        val: PrimVal,\n+        ty: Ty<'tcx>,\n+    ) -> &'tcx Self {\n+        Self::from_const_value(tcx, ConstValue::from_primval(val), ty)\n+    }\n+\n+    #[inline]\n+    pub fn from_bits(\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        val: u128,\n+        ty: Ty<'tcx>,\n+    ) -> &'tcx Self {\n+        Self::from_primval(tcx, PrimVal::Bytes(val), ty)\n+    }\n+\n+    #[inline]\n+    pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n+        Self::from_primval(tcx, PrimVal::Undef, ty)\n+    }\n+\n+    #[inline]\n+    pub fn from_bool(tcx: TyCtxt<'_, '_, 'tcx>, v: bool) -> &'tcx Self {\n+        Self::from_bits(tcx, v as u128, tcx.types.bool)\n+    }\n+\n+    #[inline]\n+    pub fn from_usize(tcx: TyCtxt<'_, '_, 'tcx>, n: u64) -> &'tcx Self {\n+        Self::from_bits(tcx, n as u128, tcx.types.usize)\n+    }\n+\n+    #[inline]\n+    pub fn to_bits(&self, ty: Ty<'_>) -> Option<u128> {\n+        if self.ty != ty {\n+            return None;\n+        }\n+        match self.val {\n+            ConstVal::Value(val) => val.to_bits(),\n+            _ => None,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_ptr(&self) -> Option<MemoryPointer> {\n+        match self.val {\n+            ConstVal::Value(val) => val.to_ptr(),\n+            _ => None,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_primval(&self) -> Option<PrimVal> {\n+        match self.val {\n+            ConstVal::Value(val) => val.to_primval(),\n+            _ => None,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn assert_bits(&self, ty: Ty<'_>) -> Option<u128> {\n+        assert_eq!(self.ty, ty);\n+        match self.val {\n+            ConstVal::Value(val) => val.to_bits(),\n+            _ => None,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn assert_bool(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<bool> {\n+        self.assert_bits(tcx.types.bool).and_then(|v| match v {\n+            0 => Some(false),\n+            1 => Some(true),\n+            _ => None,\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn assert_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<u64> {\n+        self.assert_bits(tcx.types.usize).map(|v| v as u64)\n+    }\n+\n+    #[inline]\n+    pub fn unwrap_bits(&self, ty: Ty<'_>) -> u128 {\n+        match self.assert_bits(ty) {\n+            Some(val) => val,\n+            None => bug!(\"expected bits of {}, got {:#?}\", ty, self),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn unwrap_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n+        match self.assert_usize(tcx) {\n+            Some(val) => val,\n+            None => bug!(\"expected constant usize, got {:#?}\", self),\n+        }\n+    }\n+}\n+\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Const<'tcx> {}"}, {"sha": "76803f4503129815274f0f5094e3a6bd06a1ad96", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -25,7 +25,6 @@ use ty::TypeVariants::*;\n use ty::layout::{Integer, IntegerExt};\n use util::common::ErrorReported;\n use middle::lang_items;\n-use mir::interpret::{Value, PrimVal};\n \n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n@@ -659,9 +658,8 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyArray(_, n) => {\n                 self.hash_discriminant_u8(&n.val);\n                 match n.val {\n-                    ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => self.hash(b),\n+                    ConstVal::Value(alloc) => self.hash(alloc),\n                     ConstVal::Unevaluated(def_id, _) => self.def_id(def_id),\n-                    _ => bug!(\"arrays should not have {:?} as length\", n)\n                 }\n             }\n             TyRawPtr(m) => self.hash(m.mutbl),"}, {"sha": "a6eb468e33836fc43fcddf6ae9e209a95b174c82", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -21,7 +21,6 @@ use ty::{TyClosure, TyGenerator, TyGeneratorWitness, TyForeign, TyProjection, Ty\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use util::nodemap::FxHashSet;\n-use mir::interpret::{Value, PrimVal};\n \n use std::cell::Cell;\n use std::fmt;\n@@ -1183,15 +1182,12 @@ define_print! {\n                 TyArray(ty, sz) => {\n                     print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n                     match sz.val {\n-                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(sz))) => {\n-                            write!(f, \"{}\", sz)?;\n-                        }\n+                        ConstVal::Value(..) => ty::tls::with(|tcx| {\n+                            write!(f, \"{}\", sz.unwrap_usize(tcx))\n+                        })?,\n                         ConstVal::Unevaluated(_def_id, _substs) => {\n                             write!(f, \"_\")?;\n                         }\n-                        _ => {\n-                            write!(f, \"{:?}\", sz)?;\n-                        }\n                     }\n                     write!(f, \"]\")\n                 }"}, {"sha": "1014299c708ddbcb4eb33d6ccda25cef9e0c71c6", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -425,7 +425,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ProjectionElem::Subslice { from, to } => PlaceTy::Ty {\n                 ty: match base_ty.sty {\n                     ty::TyArray(inner, size) => {\n-                        let size = size.val.unwrap_u64();\n+                        let size = size.unwrap_usize(tcx);\n                         let min_size = (from as u64) + (to as u64);\n                         if let Some(rest_size) = size.checked_sub(min_size) {\n                             tcx.mk_array(inner, rest_size)"}, {"sha": "20e11abca9fa0cf9eff30aa1ac1c92453151d7df", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -16,11 +16,10 @@ use rustc_data_structures::indexed_vec::Idx;\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n-use rustc::middle::const_val::ConstVal;\n use rustc::middle::region;\n use rustc::ty::{self, Ty, UpvarSubsts};\n use rustc::mir::*;\n-use rustc::mir::interpret::{Value, PrimVal, EvalErrorKind};\n+use rustc::mir::interpret::EvalErrorKind;\n use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -200,10 +199,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             span: expr_span,\n                             ty: this.hir.tcx().types.u32,\n                             literal: Literal::Value {\n-                                value: this.hir.tcx().mk_const(ty::Const {\n-                                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n-                                    ty: this.hir.tcx().types.u32\n-                                }),\n+                                value: ty::Const::from_bits(\n+                                    this.hir.tcx(),\n+                                    0,\n+                                    this.hir.tcx().types.u32),\n                             },\n                         }));\n                         box AggregateKind::Generator(closure_id, substs, movability)\n@@ -378,10 +377,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let bits = self.hir.integer_bit_width(ty);\n         let n = (!0u128) >> (128 - bits);\n         let literal = Literal::Value {\n-            value: self.hir.tcx().mk_const(ty::Const {\n-                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n))),\n-                ty\n-            })\n+            value: ty::Const::from_bits(self.hir.tcx(), n, ty)\n         };\n \n         self.literal_operand(span, ty, literal)\n@@ -393,10 +389,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let bits = self.hir.integer_bit_width(ty);\n         let n = 1 << (bits - 1);\n         let literal = Literal::Value {\n-            value: self.hir.tcx().mk_const(ty::Const {\n-                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n))),\n-                ty\n-            })\n+            value: ty::Const::from_bits(self.hir.tcx(), n, ty)\n         };\n \n         self.literal_operand(span, ty, literal)"}, {"sha": "913cb944835550be0e97234721aa643bcc5607ed", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -122,12 +122,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         match *match_pair.pattern.kind {\n             PatternKind::Constant { value } => {\n-                // if the places match, the type should match\n-                assert_eq!(match_pair.pattern.ty, switch_ty);\n-\n                 indices.entry(value)\n                        .or_insert_with(|| {\n-                           options.push(value.val.to_raw_bits().expect(\"switching on int\"));\n+                           options.push(value.unwrap_bits(switch_ty));\n                            options.len() - 1\n                        });\n                 true"}, {"sha": "6501dd00fe817493cf4fe50064ad697b7e0ea566", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -13,9 +13,7 @@\n \n use build::Builder;\n \n-use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n-use rustc::mir::interpret::{Value, PrimVal};\n \n use rustc::mir::*;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -64,10 +62,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n         let literal = Literal::Value {\n-            value: self.hir.tcx().mk_const(ty::Const {\n-                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n-                ty\n-            })\n+            value: ty::Const::from_bits(self.hir.tcx(), 0, ty)\n         };\n \n         self.literal_operand(span, ty, literal)"}, {"sha": "e3ff67703bd4ed2fd440dc5065b2d99316fa8b42", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -14,8 +14,7 @@ use hair::cx::Cx;\n use hair::cx::block;\n use hair::cx::to_ref::ToRef;\n use rustc::hir::def::{Def, CtorKind};\n-use rustc::middle::const_val::ConstVal;\n-use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n+use rustc::mir::interpret::GlobalId;\n use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::cast::CastKind as TyCastKind;\n@@ -522,7 +521,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 promoted: None\n             };\n             let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and(global_id)) {\n-                Ok(cv) => cv.val.unwrap_u64(),\n+                Ok(cv) => cv.unwrap_usize(cx.tcx),\n                 Err(e) => {\n                     e.report(cx.tcx, cx.tcx.def_span(def_id), \"array length\");\n                     0\n@@ -635,22 +634,17 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         span: expr.span,\n                         kind: ExprKind::Literal {\n                             literal: Literal::Value {\n-                                value: cx.tcx().mk_const(ty::Const {\n-                                    val,\n-                                    ty,\n-                                }),\n+                                value: val,\n                             },\n                         },\n                     }.to_ref();\n-                    let offset = mk_const(\n-                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(offset as u128))),\n-                    );\n+                    let offset = mk_const(ty::Const::from_bits(cx.tcx, offset as u128, ty));\n                     match did {\n                         Some(did) => {\n                             // in case we are offsetting from a computed discriminant\n                             // and not the beginning of discriminants (which is always `0`)\n                             let substs = Substs::identity_for_item(cx.tcx(), did);\n-                            let lhs = mk_const(ConstVal::Unevaluated(did, substs));\n+                            let lhs = mk_const(ty::Const::unevaluated(cx.tcx(), did, substs, ty));\n                             let bin = ExprKind::Binary {\n                                 op: BinOp::Add,\n                                 lhs,\n@@ -707,10 +701,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n-                value: cx.tcx().mk_const(ty::Const {\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n-                    ty\n-                }),\n+                value: ty::Const::zero_sized(cx.tcx(), ty),\n             },\n         },\n     }\n@@ -764,20 +755,20 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::StructCtor(_, CtorKind::Fn) |\n         Def::VariantCtor(_, CtorKind::Fn) => ExprKind::Literal {\n             literal: Literal::Value {\n-                value: cx.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n-                    ty: cx.tables().node_id_to_type(expr.hir_id)\n-                }),\n+                value: ty::Const::zero_sized(\n+                    cx.tcx,\n+                    cx.tables().node_id_to_type(expr.hir_id)),\n             },\n         },\n \n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => ExprKind::Literal {\n             literal: Literal::Value {\n-                value: cx.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Unevaluated(def_id, substs),\n-                    ty: cx.tables().node_id_to_type(expr.hir_id)\n-                }),\n+                value: ty::Const::unevaluated(\n+                    cx.tcx,\n+                    def_id,\n+                    substs,\n+                    cx.tables().node_id_to_type(expr.hir_id))\n             },\n         },\n "}, {"sha": "4765a82d85b6c1bae1eeb5272e7a4b3badb3131f", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -16,7 +16,6 @@\n \n use hair::*;\n \n-use rustc::middle::const_val::ConstVal;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -31,7 +30,6 @@ use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_data_structures::sync::Lrc;\n-use rustc::mir::interpret::{Value, PrimVal};\n use hair::pattern::parse_float;\n \n #[derive(Clone)]\n@@ -117,10 +115,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n         Literal::Value {\n-            value: self.tcx.mk_const(ty::Const {\n-                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(value as u128))),\n-                ty: self.tcx.types.usize\n-            })\n+            value: ty::Const::from_usize(self.tcx, value),\n         }\n     }\n \n@@ -134,19 +129,13 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value {\n-            value: self.tcx.mk_const(ty::Const {\n-                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(1))),\n-                ty: self.tcx.types.bool\n-            })\n+            value: ty::Const::from_bool(self.tcx, true),\n         }\n     }\n \n     pub fn false_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value {\n-            value: self.tcx.mk_const(ty::Const {\n-                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n-                ty: self.tcx.types.bool\n-            })\n+            value: ty::Const::from_bool(self.tcx, false),\n         }\n     }\n \n@@ -162,6 +151,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         layout::Integer::from_attr(self.tcx, ty).size().bits()\n     }\n \n+    // FIXME: Combine with rustc_mir::hair::pattern::lit_to_const\n     pub fn const_eval_literal(\n         &mut self,\n         lit: &'tcx ast::LitKind,\n@@ -171,7 +161,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     ) -> Literal<'tcx> {\n         trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n \n-        let parse_float = |num, fty| -> Value {\n+        let parse_float = |num, fty| -> ConstValue<'tcx> {\n             parse_float(num, fty, neg).unwrap_or_else(|_| {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n                 self.tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n@@ -193,24 +183,24 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 let s = s.as_str();\n                 let id = self.tcx.allocate_cached(s.as_bytes());\n                 let ptr = MemoryPointer::new(id, 0);\n-                Value::ByValPair(\n+                ConstValue::ByValPair(\n                     PrimVal::Ptr(ptr),\n                     PrimVal::from_u128(s.len() as u128),\n                 )\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_cached(data);\n                 let ptr = MemoryPointer::new(id, 0);\n-                Value::ByVal(PrimVal::Ptr(ptr))\n+                ConstValue::ByVal(PrimVal::Ptr(ptr))\n             },\n-            LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+            LitKind::Byte(n) => ConstValue::ByVal(PrimVal::Bytes(n as u128)),\n             LitKind::Int(n, _) if neg => {\n                 let n = n as i128;\n                 let n = n.overflowing_neg().0;\n                 let n = clamp(n as u128);\n-                Value::ByVal(PrimVal::Bytes(n))\n+                ConstValue::ByVal(PrimVal::Bytes(n))\n             },\n-            LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(clamp(n))),\n+            LitKind::Int(n, _) => ConstValue::ByVal(PrimVal::Bytes(clamp(n))),\n             LitKind::Float(n, fty) => {\n                 parse_float(n, fty)\n             }\n@@ -221,14 +211,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 };\n                 parse_float(n, fty)\n             }\n-            LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n-            LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n+            LitKind::Bool(b) => ConstValue::ByVal(PrimVal::Bytes(b as u128)),\n+            LitKind::Char(c) => ConstValue::ByVal(PrimVal::Bytes(c as u128)),\n         };\n         Literal::Value {\n-            value: self.tcx.mk_const(ty::Const {\n-                val: ConstVal::Value(lit),\n-                ty,\n-            }),\n+            value: ty::Const::from_const_value(self.tcx, lit, ty)\n         }\n     }\n \n@@ -258,11 +245,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty,\n                         Literal::Value {\n-                            value: self.tcx.mk_const(ty::Const {\n-                                // ZST function type\n-                                val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n-                                ty: method_ty\n-                            }),\n+                            value: ty::Const::zero_sized(self.tcx, method_ty)\n                         });\n             }\n         }"}, {"sha": "f930d47dc0bd37e3658f71c8a43bf35eabae4e73", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 92, "deletions": 94, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -25,7 +25,6 @@ use rustc::hir::RangeEnd;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::{Value, PrimVal};\n use rustc::util::common::ErrorReported;\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -180,37 +179,34 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         self.byte_array_map.entry(pat).or_insert_with(|| {\n             match pat.kind {\n                 box PatternKind::Constant {\n-                    value: &ty::Const { val: ConstVal::Value(b), ty }\n+                    value: const_val\n                 } => {\n-                    match b {\n-                        Value::ByVal(PrimVal::Ptr(ptr)) => {\n-                            let is_array_ptr = ty\n-                                .builtin_deref(true)\n-                                .and_then(|t| t.ty.builtin_index())\n-                                .map_or(false, |t| t == tcx.types.u8);\n-                            assert!(is_array_ptr);\n-                            let alloc = tcx\n-                                .interpret_interner\n-                                .get_alloc(ptr.alloc_id)\n-                                .unwrap();\n-                            assert_eq!(ptr.offset, 0);\n-                            // FIXME: check length\n-                            alloc.bytes.iter().map(|b| {\n-                                &*pattern_arena.alloc(Pattern {\n-                                    ty: tcx.types.u8,\n-                                    span: pat.span,\n-                                    kind: box PatternKind::Constant {\n-                                        value: tcx.mk_const(ty::Const {\n-                                            val: ConstVal::Value(Value::ByVal(\n-                                                PrimVal::Bytes(*b as u128),\n-                                            )),\n-                                            ty: tcx.types.u8\n-                                        })\n-                                    }\n-                                })\n-                            }).collect()\n-                        },\n-                        _ => bug!(\"not a byte str: {:?}\", b),\n+                    if let Some(ptr) = const_val.to_ptr() {\n+                        let is_array_ptr = const_val.ty\n+                            .builtin_deref(true)\n+                            .and_then(|t| t.ty.builtin_index())\n+                            .map_or(false, |t| t == tcx.types.u8);\n+                        assert!(is_array_ptr);\n+                        let alloc = tcx\n+                            .interpret_interner\n+                            .get_alloc(ptr.alloc_id)\n+                            .unwrap();\n+                        assert_eq!(ptr.offset, 0);\n+                        // FIXME: check length\n+                        alloc.bytes.iter().map(|b| {\n+                            &*pattern_arena.alloc(Pattern {\n+                                ty: tcx.types.u8,\n+                                span: pat.span,\n+                                kind: box PatternKind::Constant {\n+                                    value: ty::Const::from_bits(\n+                                        tcx,\n+                                        *b as u128,\n+                                        tcx.types.u8)\n+                                }\n+                            })\n+                        }).collect()\n+                    } else {\n+                        bug!(\"not a byte str: {:?}\", const_val)\n                     }\n                 }\n                 _ => span_bug!(pat.span, \"unexpected byte array pattern {:?}\", pat)\n@@ -439,14 +435,11 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     match pcx.ty.sty {\n         ty::TyBool => {\n             [true, false].iter().map(|&b| {\n-                ConstantValue(cx.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b as u128))),\n-                    ty: cx.tcx.types.bool\n-                }))\n+                ConstantValue(ty::Const::from_bool(cx.tcx, b))\n             }).collect()\n         }\n-        ty::TyArray(ref sub_ty, len) if len.val.to_raw_bits().is_some() => {\n-            let len = len.val.unwrap_u64();\n+        ty::TyArray(ref sub_ty, len) if len.assert_usize(cx.tcx).is_some() => {\n+            let len = len.unwrap_usize(cx.tcx);\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n             } else {\n@@ -554,21 +547,23 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     for row in patterns {\n         match *row.kind {\n             PatternKind::Constant {\n-                value: &ty::Const {\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))),\n-                    ty,\n+                value: const_val @ &ty::Const {\n+                    val: ConstVal::Value(..),\n+                    ..\n                 }\n             } => {\n-                let is_array_ptr = ty\n-                    .builtin_deref(true)\n-                    .and_then(|t| t.ty.builtin_index())\n-                    .map_or(false, |t| t == cx.tcx.types.u8);\n-                if is_array_ptr {\n-                    let alloc = cx.tcx\n-                        .interpret_interner\n-                        .get_alloc(ptr.alloc_id)\n-                        .unwrap();\n-                    max_fixed_len = cmp::max(max_fixed_len, alloc.bytes.len() as u64);\n+                if let Some(ptr) = const_val.to_ptr() {\n+                    let is_array_ptr = const_val.ty\n+                        .builtin_deref(true)\n+                        .and_then(|t| t.ty.builtin_index())\n+                        .map_or(false, |t| t == cx.tcx.types.u8);\n+                    if is_array_ptr {\n+                        let alloc = cx.tcx\n+                            .interpret_interner\n+                            .get_alloc(ptr.alloc_id)\n+                            .unwrap();\n+                        max_fixed_len = cmp::max(max_fixed_len, alloc.bytes.len() as u64);\n+                    }\n                 }\n             }\n             PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n@@ -836,7 +831,7 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n /// Returns None in case of a catch-all, which can't be specialized.\n-fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n+fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt,\n                           pat: &Pattern<'tcx>,\n                           pcx: PatternContext)\n                           -> Option<Vec<Constructor<'tcx>>>\n@@ -854,7 +849,7 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n             Some(vec![ConstantRange(lo, hi, end)]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n             ty::TyArray(_, length) => Some(vec![\n-                Slice(length.val.unwrap_u64())\n+                Slice(length.unwrap_usize(cx.tcx))\n             ]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n         },\n@@ -934,27 +929,31 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-fn slice_pat_covered_by_constructor(tcx: TyCtxt, _span: Span,\n-                                    ctor: &Constructor,\n-                                    prefix: &[Pattern],\n-                                    slice: &Option<Pattern>,\n-                                    suffix: &[Pattern])\n-                                    -> Result<bool, ErrorReported> {\n+fn slice_pat_covered_by_constructor<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, '_>,\n+    _span: Span,\n+    ctor: &Constructor,\n+    prefix: &[Pattern<'tcx>],\n+    slice: &Option<Pattern<'tcx>>,\n+    suffix: &[Pattern<'tcx>]\n+) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match *ctor {\n-        ConstantValue(&ty::Const { val: ConstVal::Value(\n-            Value::ByVal(PrimVal::Ptr(ptr))\n-        ), ty }) => {\n-            let is_array_ptr = ty\n-                .builtin_deref(true)\n-                .and_then(|t| t.ty.builtin_index())\n-                .map_or(false, |t| t == tcx.types.u8);\n-            assert!(is_array_ptr);\n-            tcx\n-                .interpret_interner\n-                .get_alloc(ptr.alloc_id)\n-                .unwrap()\n-                .bytes\n-                .as_ref()\n+        ConstantValue(const_val @ &ty::Const { val: ConstVal::Value(..), .. }) => {\n+            if let Some(ptr) = const_val.to_ptr() {\n+                let is_array_ptr = const_val.ty\n+                    .builtin_deref(true)\n+                    .and_then(|t| t.ty.builtin_index())\n+                    .map_or(false, |t| t == tcx.types.u8);\n+                assert!(is_array_ptr);\n+                tcx\n+                    .interpret_interner\n+                    .get_alloc(ptr.alloc_id)\n+                    .unwrap()\n+                    .bytes\n+                    .as_ref()\n+            } else {\n+                bug!()\n+            }\n         }\n         _ => bug!()\n     };\n@@ -969,15 +968,13 @@ fn slice_pat_covered_by_constructor(tcx: TyCtxt, _span: Span,\n             data[data.len()-suffix.len()..].iter().zip(suffix))\n     {\n         match pat.kind {\n-            box PatternKind::Constant { value } => match value.val {\n-                ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n-                    assert_eq!(b as u8 as u128, b);\n-                    if b as u8 != *ch {\n-                        return Ok(false);\n-                    }\n+            box PatternKind::Constant { value } => {\n+                let b = value.unwrap_bits(pat.ty);\n+                assert_eq!(b as u8 as u128, b);\n+                if b as u8 != *ch {\n+                    return Ok(false);\n                 }\n-                _ => span_bug!(pat.span, \"bad const u8 {:?}\", value)\n-            },\n+            }\n             _ => {}\n         }\n     }\n@@ -987,8 +984,8 @@ fn slice_pat_covered_by_constructor(tcx: TyCtxt, _span: Span,\n \n fn constructor_covered_by_range<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    ctor: &Constructor,\n-    from: &ConstVal, to: &ConstVal,\n+    ctor: &Constructor<'tcx>,\n+    from: &'tcx ty::Const<'tcx>, to: &'tcx ty::Const<'tcx>,\n     end: RangeEnd,\n     ty: Ty<'tcx>,\n ) -> Result<bool, ErrorReported> {\n@@ -1006,22 +1003,22 @@ fn constructor_covered_by_range<'a, 'tcx>(\n     }\n     match *ctor {\n         ConstantValue(value) => {\n-            let to = some_or_ok!(cmp_to(&value.val));\n+            let to = some_or_ok!(cmp_to(value));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(some_or_ok!(cmp_from(&value.val)) && end)\n+            Ok(some_or_ok!(cmp_from(value)) && end)\n         },\n         ConstantRange(from, to, RangeEnd::Included) => {\n-            let to = some_or_ok!(cmp_to(&to.val));\n+            let to = some_or_ok!(cmp_to(to));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(some_or_ok!(cmp_from(&from.val)) && end)\n+            Ok(some_or_ok!(cmp_from(from)) && end)\n         },\n         ConstantRange(from, to, RangeEnd::Excluded) => {\n-            let to = some_or_ok!(cmp_to(&to.val));\n+            let to = some_or_ok!(cmp_to(to));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Excluded && to == Ordering::Equal);\n-            Ok(some_or_ok!(cmp_from(&from.val)) && end)\n+            Ok(some_or_ok!(cmp_from(from)) && end)\n         }\n         Single => Ok(true),\n         _ => bug!(),\n@@ -1083,8 +1080,8 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n \n         PatternKind::Constant { value } => {\n             match *constructor {\n-                Slice(..) => match value.val {\n-                    ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))) => {\n+                Slice(..) => {\n+                    if let Some(ptr) = value.to_ptr() {\n                         let is_array_ptr = value.ty\n                             .builtin_deref(true)\n                             .and_then(|t| t.ty.builtin_index())\n@@ -1101,14 +1098,15 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                         } else {\n                             None\n                         }\n-                    }\n-                    _ => span_bug!(pat.span,\n+                    } else {\n+                        span_bug!(pat.span,\n                         \"unexpected const-val {:?} with ctor {:?}\", value, constructor)\n+                    }\n                 },\n                 _ => {\n                     match constructor_covered_by_range(\n                         cx.tcx,\n-                        constructor, &value.val, &value.val, RangeEnd::Included,\n+                        constructor, value, value, RangeEnd::Included,\n                         value.ty,\n                             ) {\n                         Ok(true) => Some(vec![]),\n@@ -1122,7 +1120,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n         PatternKind::Range { lo, hi, ref end } => {\n             match constructor_covered_by_range(\n                 cx.tcx,\n-                constructor, &lo.val, &hi.val, end.clone(), lo.ty,\n+                constructor, lo, hi, end.clone(), lo.ty,\n             ) {\n                 Ok(true) => Some(vec![]),\n                 Ok(false) => None,"}, {"sha": "749e574ff7ad41ca5bfa7420f2ded0f12825491f", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 61, "deletions": 76, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -19,8 +19,8 @@ pub(crate) use self::check_match::check_match;\n use interpret::{const_val_field, const_variant_index, self};\n \n use rustc::middle::const_val::ConstVal;\n-use rustc::mir::{Field, BorrowKind, Mutability};\n-use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n+use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n+use rustc::mir::interpret::{PrimVal, GlobalId, ConstValue};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -124,24 +124,11 @@ pub enum PatternKind<'tcx> {\n \n fn print_const_val(value: &ty::Const, f: &mut fmt::Formatter) -> fmt::Result {\n     match value.val {\n-        ConstVal::Value(v) => print_miri_value(v, value.ty, f),\n+        ConstVal::Value(..) => fmt_const_val(f, value),\n         ConstVal::Unevaluated(..) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n }\n \n-fn print_miri_value(value: Value, ty: Ty, f: &mut fmt::Formatter) -> fmt::Result {\n-    use rustc::ty::TypeVariants::*;\n-    match (value, &ty.sty) {\n-        (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n-        (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyUint(..)) => write!(f, \"{:?}\", n),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyInt(..)) => write!(f, \"{:?}\", n as i128),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n-            write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n-        _ => bug!(\"{:?}: {} not printable in a pattern\", value, ty),\n-    }\n-}\n-\n impl<'tcx> fmt::Display for Pattern<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self.kind {\n@@ -372,7 +359,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     (PatternKind::Constant { value: lo },\n                      PatternKind::Constant { value: hi }) => {\n                         use std::cmp::Ordering;\n-                        match (end, compare_const_vals(self.tcx, &lo.val, &hi.val, ty).unwrap()) {\n+                        match (end, compare_const_vals(self.tcx, lo, hi, ty).unwrap()) {\n                             (RangeEnd::Excluded, Ordering::Less) =>\n                                 PatternKind::Range { lo, hi, end },\n                             (RangeEnd::Excluded, _) => {\n@@ -616,7 +603,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             ty::TyArray(_, len) => {\n                 // fixed-length array\n-                let len = len.val.unwrap_u64();\n+                let len = len.unwrap_usize(self.tcx);\n                 assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n                 PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n             }\n@@ -740,8 +727,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                             self.tables.local_id_root.expect(\"literal outside any scope\"),\n                             self.substs,\n                         );\n-                        let cv = self.tcx.mk_const(ty::Const { val, ty });\n-                        *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n+                        *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n                     },\n                     Err(()) => {\n                         self.errors.push(PatternError::FloatBug);\n@@ -762,8 +748,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                             self.tables.local_id_root.expect(\"literal outside any scope\"),\n                             self.substs,\n                         );\n-                        let cv = self.tcx.mk_const(ty::Const { val, ty });\n-                        *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n+                        *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n                     },\n                     Err(()) => {\n                         self.errors.push(PatternError::FloatBug);\n@@ -866,7 +851,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n             ty::TyArray(_, n) => {\n                 PatternKind::Array {\n-                    prefix: (0..n.val.unwrap_u64())\n+                    prefix: (0..n.unwrap_usize(self.tcx))\n                         .map(|i| adt_subpattern(i as usize, None))\n                         .collect(),\n                     slice: None,\n@@ -1049,45 +1034,48 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n \n pub fn compare_const_vals<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    a: &ConstVal,\n-    b: &ConstVal,\n+    a: &'tcx ty::Const<'tcx>,\n+    b: &'tcx ty::Const<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<Ordering> {\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n-    use rustc::mir::interpret::{Value, PrimVal};\n-    match (a, b) {\n-        (&ConstVal::Value(Value::ByVal(PrimVal::Bytes(a))),\n-         &ConstVal::Value(Value::ByVal(PrimVal::Bytes(b)))) => {\n-            use ::rustc_apfloat::Float;\n-            match ty.sty {\n-                ty::TyFloat(ast::FloatTy::F32) => {\n-                    let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n-                    let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n-                    l.partial_cmp(&r)\n-                },\n-                ty::TyFloat(ast::FloatTy::F64) => {\n-                    let l = ::rustc_apfloat::ieee::Double::from_bits(a);\n-                    let r = ::rustc_apfloat::ieee::Double::from_bits(b);\n-                    l.partial_cmp(&r)\n-                },\n-                ty::TyInt(_) => {\n-                    let a = interpret::sign_extend(tcx, a, ty).expect(\"layout error for TyInt\");\n-                    let b = interpret::sign_extend(tcx, b, ty).expect(\"layout error for TyInt\");\n-                    Some((a as i128).cmp(&(b as i128)))\n-                },\n-                _ => Some(a.cmp(&b)),\n-            }\n-        },\n-        _ if a == b => Some(Ordering::Equal),\n-        _ => None,\n+    // FIXME: This should use assert_bits(ty) instead of use_bits\n+    // but triggers possibly bugs due to mismatching of arrays and slices\n+    if let (Some(a), Some(b)) = (a.to_bits(ty), b.to_bits(ty)) {\n+        use ::rustc_apfloat::Float;\n+        match ty.sty {\n+            ty::TyFloat(ast::FloatTy::F32) => {\n+                let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n+                let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n+                l.partial_cmp(&r)\n+            },\n+            ty::TyFloat(ast::FloatTy::F64) => {\n+                let l = ::rustc_apfloat::ieee::Double::from_bits(a);\n+                let r = ::rustc_apfloat::ieee::Double::from_bits(b);\n+                l.partial_cmp(&r)\n+            },\n+            ty::TyInt(_) => {\n+                let a = interpret::sign_extend(tcx, a, ty).expect(\"layout error for TyInt\");\n+                let b = interpret::sign_extend(tcx, b, ty).expect(\"layout error for TyInt\");\n+                Some((a as i128).cmp(&(b as i128)))\n+            },\n+            _ => Some(a.cmp(&b)),\n+        }\n+    } else {\n+        if a == b {\n+            Some(Ordering::Equal)\n+        } else {\n+            None\n+        }\n     }\n }\n \n+// FIXME: Combine with rustc_mir::hair::cx::const_eval_literal\n fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           ty: Ty<'tcx>,\n                           neg: bool)\n-                          -> Result<ConstVal<'tcx>, ()> {\n+                          -> Result<&'tcx ty::Const<'tcx>, ()> {\n     use syntax::ast::*;\n \n     use rustc::mir::interpret::*;\n@@ -1096,17 +1084,17 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             let s = s.as_str();\n             let id = tcx.allocate_cached(s.as_bytes());\n             let ptr = MemoryPointer::new(id, 0);\n-            Value::ByValPair(\n+            ConstValue::ByValPair(\n                 PrimVal::Ptr(ptr),\n                 PrimVal::from_u128(s.len() as u128),\n             )\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_cached(data);\n             let ptr = MemoryPointer::new(id, 0);\n-            Value::ByVal(PrimVal::Ptr(ptr))\n+            ConstValue::ByVal(PrimVal::Ptr(ptr))\n         },\n-        LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+        LitKind::Byte(n) => ConstValue::ByVal(PrimVal::Bytes(n as u128)),\n         LitKind::Int(n, _) => {\n             enum Int {\n                 Signed(IntTy),\n@@ -1119,31 +1107,28 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 ty::TyUint(other) => Int::Unsigned(other),\n                 _ => bug!(),\n             };\n+            // This converts from LitKind::Int (which is sign extended) to\n+            // PrimVal::Bytes (which is zero extended)\n             let n = match ty {\n                 // FIXME(oli-obk): are these casts correct?\n                 Int::Signed(IntTy::I8) if neg =>\n-                    (n as i128 as i8).overflowing_neg().0 as i128 as u128,\n+                    (n as i8).overflowing_neg().0 as u8 as u128,\n                 Int::Signed(IntTy::I16) if neg =>\n-                    (n as i128 as i16).overflowing_neg().0 as i128 as u128,\n+                    (n as i16).overflowing_neg().0 as u16 as u128,\n                 Int::Signed(IntTy::I32) if neg =>\n-                    (n as i128 as i32).overflowing_neg().0 as i128 as u128,\n+                    (n as i32).overflowing_neg().0 as u32 as u128,\n                 Int::Signed(IntTy::I64) if neg =>\n-                    (n as i128 as i64).overflowing_neg().0 as i128 as u128,\n+                    (n as i64).overflowing_neg().0 as u64 as u128,\n                 Int::Signed(IntTy::I128) if neg =>\n                     (n as i128).overflowing_neg().0 as u128,\n-                Int::Signed(IntTy::I8) => n as i128 as i8 as i128 as u128,\n-                Int::Signed(IntTy::I16) => n as i128 as i16 as i128 as u128,\n-                Int::Signed(IntTy::I32) => n as i128 as i32 as i128 as u128,\n-                Int::Signed(IntTy::I64) => n as i128 as i64 as i128 as u128,\n-                Int::Signed(IntTy::I128) => n,\n-                Int::Unsigned(UintTy::U8) => n as u8 as u128,\n-                Int::Unsigned(UintTy::U16) => n as u16 as u128,\n-                Int::Unsigned(UintTy::U32) => n as u32 as u128,\n-                Int::Unsigned(UintTy::U64) => n as u64 as u128,\n-                Int::Unsigned(UintTy::U128) => n,\n+                Int::Signed(IntTy::I8) | Int::Unsigned(UintTy::U8) => n as u8 as u128,\n+                Int::Signed(IntTy::I16) | Int::Unsigned(UintTy::U16) => n as u16 as u128,\n+                Int::Signed(IntTy::I32) | Int::Unsigned(UintTy::U32) => n as u32 as u128,\n+                Int::Signed(IntTy::I64) | Int::Unsigned(UintTy::U64) => n as u64 as u128,\n+                Int::Signed(IntTy::I128)| Int::Unsigned(UintTy::U128) => n,\n                 _ => bug!(),\n             };\n-            Value::ByVal(PrimVal::Bytes(n))\n+            ConstValue::ByVal(PrimVal::Bytes(n))\n         },\n         LitKind::Float(n, fty) => {\n             parse_float(n, fty, neg)?\n@@ -1155,17 +1140,17 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             };\n             parse_float(n, fty, neg)?\n         }\n-        LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n-        LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n+        LitKind::Bool(b) => ConstValue::ByVal(PrimVal::Bytes(b as u128)),\n+        LitKind::Char(c) => ConstValue::ByVal(PrimVal::Bytes(c as u128)),\n     };\n-    Ok(ConstVal::Value(lit))\n+    Ok(ty::Const::from_const_value(tcx, lit, ty))\n }\n \n-pub fn parse_float(\n+pub fn parse_float<'tcx>(\n     num: Symbol,\n     fty: ast::FloatTy,\n     neg: bool,\n-) -> Result<Value, ()> {\n+) -> Result<ConstValue<'tcx>, ()> {\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Single, Double};\n     use rustc_apfloat::Float;\n@@ -1192,5 +1177,5 @@ pub fn parse_float(\n         }\n     };\n \n-    Ok(Value::ByVal(PrimVal::Bytes(bits)))\n+    Ok(ConstValue::ByVal(PrimVal::Bytes(bits)))\n }"}, {"sha": "b8bb58b9ed24c4db02d1f7cc4dddb7b5c574cd6c", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 86, "deletions": 42, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir;\n-use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n+use rustc::middle::const_val::{ConstEvalErr, ErrKind};\n use rustc::middle::const_val::ErrKind::{TypeckError, CheckMatchError};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n@@ -9,7 +9,10 @@ use rustc::ty::subst::Subst;\n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n-use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, MemoryPointer, Pointer, PrimVal, AllocId};\n+use rustc::mir::interpret::{\n+    EvalResult, EvalError, EvalErrorKind, GlobalId,\n+    Value, Pointer, PrimVal, AllocId, Allocation, ConstValue,\n+};\n use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra, Memory};\n \n use std::fmt;\n@@ -57,19 +60,21 @@ pub fn mk_eval_cx<'a, 'tcx>(\n }\n \n pub fn eval_promoted<'a, 'mir, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> Option<(Value, Pointer, Ty<'tcx>)> {\n-    let (res, ecx) = eval_body_and_ecx(tcx, cid, Some(mir), param_env);\n-    match res {\n-        Ok(val) => Some(val),\n-        Err(mut err) => {\n-            ecx.report(&mut err, false, None);\n-            None\n+    ecx.with_fresh_body(|ecx| {\n+        let res = eval_body_using_ecx(ecx, cid, Some(mir), param_env);\n+        match res {\n+            Ok(val) => Some(val),\n+            Err(mut err) => {\n+                ecx.report(&mut err, false, None);\n+                None\n+            }\n         }\n-    }\n+    })\n }\n \n pub fn eval_body<'a, 'tcx>(\n@@ -87,27 +92,83 @@ pub fn eval_body<'a, 'tcx>(\n     }\n }\n \n+pub fn value_to_const_value<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    val: Value,\n+    ty: Ty<'tcx>,\n+) -> &'tcx ty::Const<'tcx> {\n+    let layout = tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap();\n+\n+    if layout.is_zst() {\n+        return ty::Const::from_const_value(\n+            tcx,\n+            ConstValue::ByVal(PrimVal::Undef),\n+            ty);\n+    }\n+\n+    let val = match layout.abi {\n+        layout::Abi::Scalar(..) => {\n+            if let Value::ByVal(val) = val {\n+                ConstValue::ByVal(val)\n+            } else {\n+                bug!(\"expected ByVal value, got {:?}\", val);\n+            }\n+        }\n+        layout::Abi::ScalarPair(..) => {\n+            if let Value::ByValPair(a, b) = val {\n+                ConstValue::ByValPair(a, b)\n+            } else {\n+                bug!(\"expected ByValPair value, got {:?}\", val);\n+            }\n+        }\n+        _ => {\n+            if let Value::ByRef(ptr, align) = val {\n+                let ptr = ptr.primval.to_ptr().unwrap();\n+                assert_eq!(ptr.offset, 0);\n+                let alloc = tcx.interpret_interner\n+                               .get_alloc(ptr.alloc_id)\n+                               .expect(\"miri allocation never successfully created\");\n+                assert_eq!(align, alloc.align);\n+                ConstValue::ByRef(alloc)\n+            } else {\n+                bug!(\"expected ByRef value, got {:?}\", val);\n+            }\n+        },\n+    };\n+    ty::Const::from_const_value(tcx, val, ty)\n+}\n+\n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> (EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n-    debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n+    debug!(\"eval_body_and_ecx: {:?}, {:?}\", cid, param_env);\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n     let span = tcx.def_span(cid.instance.def_id());\n-    let mut span = mir.map(|mir| mir.span).unwrap_or(span);\n+    let span = mir.map(|mir| mir.span).unwrap_or(span);\n     let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n-    let res = (|| {\n+    let r = eval_body_using_ecx(&mut ecx, cid, mir, param_env);\n+    (r, ecx)\n+}\n+\n+fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n+    ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n+    cid: GlobalId<'tcx>,\n+    mir: Option<&'mir mir::Mir<'tcx>>,\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)> {\n+    debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n+    let tcx = ecx.tcx.tcx;\n         let mut mir = match mir {\n             Some(mir) => mir,\n             None => ecx.load_mir(cid.instance.def)?,\n         };\n         if let Some(index) = cid.promoted {\n             mir = &mir.promoted[index];\n         }\n-        span = mir.span;\n         let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n         assert!(!layout.is_unsized());\n         let ptr = ecx.memory.allocate(\n@@ -139,14 +200,11 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n         let ptr = ptr.into();\n         // always try to read the value and report errors\n         let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n-            // if it's a constant (so it needs no address, directly compute its value)\n-            Some(val) if tcx.is_static(cid.instance.def_id()).is_none() => val,\n+            Some(val) => val,\n             // point at the allocation\n             _ => Value::ByRef(ptr, layout.align),\n         };\n         Ok((value, ptr, layout.ty))\n-    })();\n-    (res, ecx)\n }\n \n pub struct CompileTimeEvaluator;\n@@ -357,14 +415,16 @@ pub fn const_val_field<'a, 'tcx>(\n     instance: ty::Instance<'tcx>,\n     variant: Option<usize>,\n     field: mir::Field,\n-    value: Value,\n+    value: ConstValue<'tcx>,\n     ty: Ty<'tcx>,\n ) -> ::rustc::middle::const_val::EvalResult<'tcx> {\n     trace!(\"const_val_field: {:?}, {:?}, {:?}, {:?}\", instance, field, value, ty);\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let result = (|| {\n+        let value = ecx.const_value_to_value(value, ty)?;\n         let (mut field, ty) = match value {\n-            Value::ByValPair(..) | Value::ByVal(_) => ecx.read_field(value, variant, field, ty)?.expect(\"const_val_field on non-field\"),\n+            Value::ByValPair(..) | Value::ByVal(_) => \n+                ecx.read_field(value, variant, field, ty)?.expect(\"const_val_field on non-field\"),\n             Value::ByRef(ptr, align) => {\n                 let place = Place::Ptr {\n                     ptr,\n@@ -385,10 +445,7 @@ pub fn const_val_field<'a, 'tcx>(\n         Ok((field, ty))\n     })();\n     match result {\n-        Ok((field, ty)) => Ok(tcx.mk_const(ty::Const {\n-            val: ConstVal::Value(field),\n-            ty,\n-        })),\n+        Ok((field, ty)) => Ok(value_to_const_value(tcx, field, ty)),\n         Err(err) => {\n             let (trace, span) = ecx.generate_stacktrace(None);\n             let err = ErrKind::Miri(err, trace);\n@@ -404,11 +461,12 @@ pub fn const_variant_index<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     instance: ty::Instance<'tcx>,\n-    value: Value,\n+    val: ConstValue<'tcx>,\n     ty: Ty<'tcx>,\n ) -> EvalResult<'tcx, usize> {\n-    trace!(\"const_variant_index: {:?}, {:?}, {:?}\", instance, value, ty);\n+    trace!(\"const_variant_index: {:?}, {:?}, {:?}\", instance, val, ty);\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    let value = ecx.const_value_to_value(val, ty)?;\n     let (ptr, align) = match value {\n         Value::ByValPair(..) | Value::ByVal(_) => {\n             let layout = ecx.layout_of(ty)?;\n@@ -432,17 +490,6 @@ pub fn const_eval_provider<'a, 'tcx>(\n     let cid = key.value;\n     let def_id = cid.instance.def.def_id();\n \n-    if tcx.is_foreign_item(def_id) {\n-        let id = tcx.interpret_interner.cache_static(def_id);\n-        let ty = tcx.type_of(def_id);\n-        let layout = tcx.layout_of(key.param_env.and(ty)).unwrap();\n-        let ptr = MemoryPointer::new(id, 0);\n-        return Ok(tcx.mk_const(ty::Const {\n-            val: ConstVal::Value(Value::ByRef(ptr.into(), layout.align)),\n-            ty,\n-        }))\n-    }\n-\n     if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n         let tables = tcx.typeck_tables_of(def_id);\n         let span = tcx.def_span(def_id);\n@@ -469,11 +516,8 @@ pub fn const_eval_provider<'a, 'tcx>(\n     };\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n-    res.map(|(miri_value, _, miri_ty)| {\n-        tcx.mk_const(ty::Const {\n-            val: ConstVal::Value(miri_value),\n-            ty: miri_ty,\n-        })\n+    res.map(|(val, _, miri_ty)| {\n+        value_to_const_value(tcx, val, miri_ty)\n     }).map_err(|mut err| {\n         if tcx.is_static(def_id).is_some() {\n             ecx.report(&mut err, true, None);"}, {"sha": "03137619edaf48d72a0780b073a6446cc575ec53", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 93, "deletions": 78, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -15,7 +15,7 @@ use syntax::codemap::{self, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n     GlobalId, Value, Pointer, PrimVal, PrimValKind,\n-    EvalError, EvalResult, EvalErrorKind, MemoryPointer,\n+    EvalError, EvalResult, EvalErrorKind, MemoryPointer, ConstValue,\n };\n use std::mem;\n \n@@ -116,15 +116,6 @@ pub struct ValTy<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-impl<'tcx> ValTy<'tcx> {\n-    pub fn from(val: &ty::Const<'tcx>) -> Option<Self> {\n-        match val.val {\n-            ConstVal::Value(value) => Some(ValTy { value, ty: val.ty }),\n-            ConstVal::Unevaluated { .. } => None,\n-        }\n-    }\n-}\n-\n impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n     type Target = Value;\n     fn deref(&self) -> &Value {\n@@ -183,6 +174,8 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf\n     }\n }\n \n+const MAX_TERMINATORS: usize = 1_000_000;\n+\n impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n@@ -197,10 +190,19 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             memory: Memory::new(tcx, memory_data),\n             stack: Vec::new(),\n             stack_limit: tcx.sess.const_eval_stack_frame_limit,\n-            terminators_remaining: 1_000_000,\n+            terminators_remaining: MAX_TERMINATORS,\n         }\n     }\n \n+    pub(crate) fn with_fresh_body<F: FnOnce(&mut Self) -> R, R>(&mut self, f: F) -> R {\n+        let stack = mem::replace(&mut self.stack, Vec::new());\n+        let terminators_remaining = mem::replace(&mut self.terminators_remaining, MAX_TERMINATORS);\n+        let r = f(self);\n+        self.stack = stack;\n+        self.terminators_remaining = terminators_remaining;\n+        r\n+    }\n+\n     pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, MemoryPointer> {\n         let layout = self.layout_of(ty)?;\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n@@ -235,7 +237,27 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         ))\n     }\n \n-    pub(super) fn const_to_value(&self, const_val: &ConstVal<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn const_value_to_value(\n+        &mut self,\n+        val: ConstValue<'tcx>,\n+        _ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Value> {\n+        match val {\n+            ConstValue::ByRef(alloc) => {\n+                // FIXME: Allocate new AllocId for all constants inside\n+                let id = self.memory.allocate_value(alloc.clone(), Some(MemoryKind::Stack))?;\n+                Ok(Value::ByRef(MemoryPointer::new(id, 0).into(), alloc.align))\n+            },\n+            ConstValue::ByValPair(a, b) => Ok(Value::ByValPair(a, b)),\n+            ConstValue::ByVal(val) => Ok(Value::ByVal(val)),\n+        }\n+    }\n+\n+    pub(super) fn const_to_value(\n+        &mut self,\n+        const_val: &ConstVal<'tcx>,\n+        ty: Ty<'tcx>\n+    ) -> EvalResult<'tcx, Value> {\n         match *const_val {\n             ConstVal::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n@@ -244,7 +266,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     promoted: None,\n                 }, ty)\n             }\n-            ConstVal::Value(val) => Ok(val),\n+            ConstVal::Value(val) => self.const_value_to_value(val, ty)\n         }\n     }\n \n@@ -568,7 +590,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n             Repeat(ref operand, _) => {\n                 let (elem_ty, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (elem_ty, n.val.unwrap_u64()),\n+                    ty::TyArray(elem_ty, n) => (elem_ty, n.unwrap_usize(self.tcx.tcx)),\n                     _ => {\n                         bug!(\n                             \"tried to assign array-repeat to non-array type {:?}\",\n@@ -592,7 +614,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_place(place)?;\n                 let ty = self.place_ty(place);\n-                let (_, len) = src.elem_ty_and_len(ty);\n+                let (_, len) = src.elem_ty_and_len(ty, self.tcx.tcx);\n                 self.write_primval(\n                     dest,\n                     PrimVal::from_u128(len as u128),\n@@ -822,8 +844,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     Literal::Value { ref value } => self.const_to_value(&value.val, ty)?,\n \n                     Literal::Promoted { index } => {\n+                        let instance = self.frame().instance;\n                         self.read_global_as_value(GlobalId {\n-                            instance: self.frame().instance,\n+                            instance,\n                             promoted: Some(index),\n                         }, ty)?\n                     }\n@@ -997,7 +1020,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(())\n     }\n \n-    pub fn read_global_as_value(&self, gid: GlobalId<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn read_global_as_value(&mut self, gid: GlobalId<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if self.tcx.is_static(gid.instance.def_id()).is_some() {\n             let alloc_id = self\n                 .tcx\n@@ -1341,92 +1364,84 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub fn try_read_value(&self, ptr: Pointer, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n-        use syntax::ast::FloatTy;\n-\n-        let layout = self.layout_of(ty)?;\n-        self.memory.check_align(ptr, ptr_align)?;\n-\n-        if layout.size.bytes() == 0 {\n-            return Ok(Some(Value::ByVal(PrimVal::Undef)));\n-        }\n-\n-        let ptr = ptr.to_ptr()?;\n-        let val = match ty.sty {\n+    pub fn validate_ptr_target(\n+        &self,\n+        ptr: MemoryPointer,\n+        ptr_align: Align,\n+        ty: Ty<'tcx>\n+    ) -> EvalResult<'tcx> {\n+        match ty.sty {\n             ty::TyBool => {\n                 let val = self.memory.read_primval(ptr, ptr_align, 1)?;\n-                let val = match val {\n-                    PrimVal::Bytes(0) => false,\n-                    PrimVal::Bytes(1) => true,\n+                match val {\n+                    PrimVal::Bytes(0) | PrimVal::Bytes(1) => (),\n                     // TODO: This seems a little overeager, should reading at bool type already be insta-UB?\n                     _ => return err!(InvalidBool),\n-                };\n-                PrimVal::from_bool(val)\n+                }\n             }\n             ty::TyChar => {\n                 let c = self.memory.read_primval(ptr, ptr_align, 4)?.to_bytes()? as u32;\n                 match ::std::char::from_u32(c) {\n-                    Some(ch) => PrimVal::from_char(ch),\n+                    Some(..) => (),\n                     None => return err!(InvalidChar(c as u128)),\n                 }\n             }\n \n-            ty::TyInt(int_ty) => {\n-                use syntax::ast::IntTy::*;\n-                let size = match int_ty {\n-                    I8 => 1,\n-                    I16 => 2,\n-                    I32 => 4,\n-                    I64 => 8,\n-                    I128 => 16,\n-                    Isize => self.memory.pointer_size(),\n-                };\n-                self.memory.read_primval(ptr, ptr_align, size)?\n-            }\n-\n-            ty::TyUint(uint_ty) => {\n-                use syntax::ast::UintTy::*;\n-                let size = match uint_ty {\n-                    U8 => 1,\n-                    U16 => 2,\n-                    U32 => 4,\n-                    U64 => 8,\n-                    U128 => 16,\n-                    Usize => self.memory.pointer_size(),\n-                };\n-                self.memory.read_primval(ptr, ptr_align, size)?\n-            }\n-\n-            ty::TyFloat(FloatTy::F32) => {\n-                PrimVal::Bytes(self.memory.read_primval(ptr, ptr_align, 4)?.to_bytes()?)\n-            }\n-            ty::TyFloat(FloatTy::F64) => {\n-                PrimVal::Bytes(self.memory.read_primval(ptr, ptr_align, 8)?.to_bytes()?)\n-            }\n-\n-            ty::TyFnPtr(_) => self.memory.read_ptr_sized(ptr, ptr_align)?,\n+            ty::TyFnPtr(_) => {\n+                self.memory.read_ptr_sized(ptr, ptr_align)?;\n+            },\n             ty::TyRef(_, rty, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: rty, .. }) => {\n-                return self.read_ptr(ptr, ptr_align, rty).map(Some)\n+                self.read_ptr(ptr, ptr_align, rty)?;\n             }\n \n             ty::TyAdt(def, _) => {\n                 if def.is_box() {\n-                    return self.read_ptr(ptr, ptr_align, ty.boxed_ty()).map(Some);\n+                    self.read_ptr(ptr, ptr_align, ty.boxed_ty())?;\n+                    return Ok(());\n                 }\n \n                 if let layout::Abi::Scalar(ref scalar) = self.layout_of(ty)?.abi {\n                     let size = scalar.value.size(self).bytes();\n-                    self.memory.read_primval(ptr, ptr_align, size)?\n-                } else {\n-                    return Ok(None);\n+                    self.memory.read_primval(ptr, ptr_align, size)?;\n                 }\n             }\n \n-            _ => return Ok(None),\n-        };\n+            _ => (),\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn try_read_value(&self, ptr: Pointer, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+        let layout = self.layout_of(ty)?;\n+        self.memory.check_align(ptr, ptr_align)?;\n \n-        Ok(Some(Value::ByVal(val)))\n+        if layout.size.bytes() == 0 {\n+            return Ok(Some(Value::ByVal(PrimVal::Undef)));\n+        }\n+\n+        let ptr = ptr.to_ptr()?;\n+\n+        // Not the right place to do this\n+        //self.validate_ptr_target(ptr, ptr_align, ty)?;\n+\n+        match layout.abi {\n+            layout::Abi::Scalar(..) => {\n+                let primval = self.memory.read_primval(ptr, ptr_align, layout.size.bytes())?;\n+                Ok(Some(Value::ByVal(primval)))\n+            }\n+            layout::Abi::ScalarPair(ref a, ref b) => {\n+                let (a, b) = (&a.value, &b.value);\n+                let (a_size, b_size) = (a.size(self), b.size(self));\n+                let a_ptr = ptr;\n+                let b_offset = a_size.abi_align(b.align(self));\n+                let b_ptr = ptr.offset(b_offset.bytes(), self)?.into();\n+                let a_val = self.memory.read_primval(a_ptr, ptr_align, a_size.bytes())?;\n+                let b_val = self.memory.read_primval(b_ptr, ptr_align, b_size.bytes())?;\n+                Ok(Some(Value::ByValPair(a_val, b_val)))\n+            }\n+            _ => Ok(None),\n+        }\n     }\n \n     pub fn frame(&self) -> &Frame<'mir, 'tcx> {\n@@ -1466,7 +1481,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let ptr = self.into_ptr(src)?;\n                 // u64 cast is from usize to u64, which is always good\n                 let valty = ValTy {\n-                    value: ptr.to_value_with_len(length.val.unwrap_u64() ),\n+                    value: ptr.to_value_with_len(length.unwrap_usize(self.tcx.tcx)),\n                     ty: dest_ty,\n                 };\n                 self.write_value(valty, dest)"}, {"sha": "18cd75ae0bbf4ef4df23568d8830a17229504da4", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 18, "deletions": 51, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -1,15 +1,15 @@\n-use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n-use std::collections::{btree_map, BTreeMap, VecDeque};\n-use std::{ptr, io};\n+use std::collections::{btree_map, VecDeque};\n+use std::ptr;\n \n use rustc::ty::Instance;\n use rustc::ty::maps::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout};\n use syntax::ast::Mutability;\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, Value, Pointer,\n+use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, Value, Pointer,\n                             EvalResult, PrimVal, EvalErrorKind};\n+pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n \n use super::{EvalContext, Machine};\n \n@@ -79,20 +79,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     /// kind is `None` for statics\n-    pub fn allocate(\n+    pub fn allocate_value(\n         &mut self,\n-        size: u64,\n-        align: Align,\n+        alloc: Allocation,\n         kind: Option<MemoryKind<M::MemoryKinds>>,\n-    ) -> EvalResult<'tcx, MemoryPointer> {\n-        assert_eq!(size as usize as u64, size);\n-        let alloc = Allocation {\n-            bytes: vec![0; size as usize],\n-            relocations: BTreeMap::new(),\n-            undef_mask: UndefMask::new(size),\n-            align,\n-            runtime_mutability: Mutability::Immutable,\n-        };\n+    ) -> EvalResult<'tcx, AllocId> {\n         let id = self.tcx.interpret_interner.reserve();\n         M::add_lock(self, id);\n         match kind {\n@@ -105,6 +96,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 self.uninitialized_statics.insert(id, alloc);\n             },\n         }\n+        Ok(id)\n+    }\n+\n+    /// kind is `None` for statics\n+    pub fn allocate(\n+        &mut self,\n+        size: u64,\n+        align: Align,\n+        kind: Option<MemoryKind<M::MemoryKinds>>,\n+    ) -> EvalResult<'tcx, MemoryPointer> {\n+        let id = self.allocate_value(Allocation::undef(size, align), kind)?;\n         Ok(MemoryPointer::new(id, 0))\n     }\n \n@@ -873,41 +875,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Methods to access integers in the target endianness\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub fn write_target_uint(\n-    endianness: layout::Endian,\n-    mut target: &mut [u8],\n-    data: u128,\n-) -> Result<(), io::Error> {\n-    let len = target.len();\n-    match endianness {\n-        layout::Endian::Little => target.write_uint128::<LittleEndian>(data, len),\n-        layout::Endian::Big => target.write_uint128::<BigEndian>(data, len),\n-    }\n-}\n-\n-pub fn write_target_int(\n-    endianness: layout::Endian,\n-    mut target: &mut [u8],\n-    data: i128,\n-) -> Result<(), io::Error> {\n-    let len = target.len();\n-    match endianness {\n-        layout::Endian::Little => target.write_int128::<LittleEndian>(data, len),\n-        layout::Endian::Big => target.write_int128::<BigEndian>(data, len),\n-    }\n-}\n-\n-pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n-    match endianness {\n-        layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n-        layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Unaligned accesses\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "7f9e67a62ccc4d4ad8edf699ca2fd8d83eec35a5", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -26,6 +26,7 @@ pub use self::const_eval::{\n     const_eval_provider,\n     const_val_field,\n     const_variant_index,\n+    value_to_const_value,\n };\n \n pub use self::machine::Machine;"}, {"sha": "883b17b8584fb010ff322449d6262a5e4cced110", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -69,9 +69,13 @@ impl<'tcx> Place {\n         self.to_ptr_align().0.to_ptr()\n     }\n \n-    pub(super) fn elem_ty_and_len(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n+    pub(super) fn elem_ty_and_len(\n+        self,\n+        ty: Ty<'tcx>,\n+        tcx: TyCtxt<'_, 'tcx, '_>\n+    ) -> (Ty<'tcx>, u64) {\n         match ty.sty {\n-            ty::TyArray(elem, n) => (elem, n.val.unwrap_u64() as u64),\n+            ty::TyArray(elem, n) => (elem, n.unwrap_usize(tcx)),\n \n             ty::TySlice(elem) => {\n                 match self {\n@@ -320,7 +324,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let base = self.force_allocation(base)?;\n         let (base_ptr, align) = base.to_ptr_align();\n \n-        let (elem_ty, len) = base.elem_ty_and_len(outer_ty);\n+        let (elem_ty, len) = base.elem_ty_and_len(outer_ty, self.tcx.tcx);\n         let elem_size = self.layout_of(elem_ty)?.size.bytes();\n         assert!(\n             n < len,\n@@ -396,7 +400,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let base = self.force_allocation(base)?;\n                 let (base_ptr, align) = base.to_ptr_align();\n \n-                let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n+                let (elem_ty, n) = base.elem_ty_and_len(base_ty, self.tcx.tcx);\n                 let elem_size = self.layout_of(elem_ty)?.size.bytes();\n                 assert!(n >= min_length as u64);\n \n@@ -415,7 +419,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let base = self.force_allocation(base)?;\n                 let (base_ptr, align) = base.to_ptr_align();\n \n-                let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n+                let (elem_ty, n) = base.elem_ty_and_len(base_ty, self.tcx.tcx);\n                 let elem_size = self.layout_of(elem_ty)?.size.bytes();\n                 assert!(u64::from(from) <= n - u64::from(to));\n                 let ptr = base_ptr.offset(u64::from(from) * elem_size, &self)?;"}, {"sha": "e690e8ee88066cc9b9f99efaaea7d758529175b0", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -194,7 +194,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n-use rustc::mir::interpret::{Value, PrimVal, AllocId, Pointer};\n+use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt};\n@@ -203,7 +203,7 @@ use rustc::session::config;\n use rustc::mir::{self, Location, Promoted};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n-use rustc::mir::interpret::GlobalId;\n+use rustc::mir::interpret::{PrimVal, GlobalId};\n \n use monomorphize::{self, Instance};\n use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -1237,22 +1237,17 @@ fn collect_const<'a, 'tcx>(\n     };\n     match val {\n         ConstVal::Unevaluated(..) => bug!(\"const eval yielded unevaluated const\"),\n-        ConstVal::Value(Value::ByValPair(PrimVal::Ptr(a), PrimVal::Ptr(b))) => {\n+        ConstVal::Value(ConstValue::ByValPair(PrimVal::Ptr(a), PrimVal::Ptr(b))) => {\n             collect_miri(tcx, a.alloc_id, output);\n             collect_miri(tcx, b.alloc_id, output);\n         }\n-        ConstVal::Value(Value::ByValPair(_, PrimVal::Ptr(ptr))) |\n-        ConstVal::Value(Value::ByValPair(PrimVal::Ptr(ptr), _)) |\n-        ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))) =>\n+        ConstVal::Value(ConstValue::ByValPair(_, PrimVal::Ptr(ptr))) |\n+        ConstVal::Value(ConstValue::ByValPair(PrimVal::Ptr(ptr), _)) |\n+        ConstVal::Value(ConstValue::ByVal(PrimVal::Ptr(ptr))) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n-        ConstVal::Value(Value::ByRef(Pointer { primval: PrimVal::Ptr(ptr) }, _)) => {\n-            // by ref should only collect the inner allocation, not the value itself\n-            let alloc = tcx\n-                .interpret_interner\n-                .get_alloc(ptr.alloc_id)\n-                .expect(\"ByRef to extern static is not allowed\");\n-            for &inner in alloc.relocations.values() {\n-                collect_miri(tcx, inner, output);\n+        ConstVal::Value(ConstValue::ByRef(alloc)) => {\n+            for &id in alloc.relocations.values() {\n+                collect_miri(tcx, id, output);\n             }\n         }\n         _ => {},"}, {"sha": "a569ad00d0c65a6a3dcb211ef677964cc2dbbb86", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -313,8 +313,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::TyArray(inner_type, len) => {\n                 output.push('[');\n                 self.push_type_name(inner_type, output);\n-                write!(output, \"; {}\",\n-                    len.val.unwrap_u64()).unwrap();\n+                write!(output, \"; {}\", len.unwrap_usize(self.tcx)).unwrap();\n                 output.push(']');\n             },\n             ty::TySlice(inner_type) => {"}, {"sha": "5b2f3a8b8aac7ee01237d4ee84e572f28e090e74", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -11,12 +11,10 @@\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer;\n-use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::maps::Providers;\n-use rustc::mir::interpret::{Value, PrimVal};\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n@@ -303,7 +301,7 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n         ty::TyArray(ty, len) => {\n-            let len = len.val.unwrap_u64();\n+            let len = len.unwrap_usize(tcx);\n             builder.array_shim(dest, src, ty, len)\n         }\n         ty::TyClosure(def_id, substs) => {\n@@ -442,11 +440,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: func_ty,\n             literal: Literal::Value {\n-                value: tcx.mk_const(ty::Const {\n-                    // ZST function type\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n-                    ty: func_ty\n-                }),\n+                value: ty::Const::zero_sized(self.tcx, func_ty)\n             },\n         });\n \n@@ -506,10 +500,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: self.tcx.types.usize,\n             literal: Literal::Value {\n-                value: self.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(value.into()))),\n-                    ty: self.tcx.types.usize,\n-                })\n+                value: ty::Const::from_usize(self.tcx, value),\n             }\n         }\n     }\n@@ -738,11 +729,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 span,\n                 ty,\n                 literal: Literal::Value {\n-                    value: tcx.mk_const(ty::Const {\n-                        // ZST function type\n-                        val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n-                        ty\n-                    }),\n+                    value: ty::Const::zero_sized(tcx, ty)\n                 },\n              }),\n              vec![rcvr])"}, {"sha": "6b0217c8f7cbc17b48687f4d94a1e83286df3d2c", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 81, "deletions": 47, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -19,15 +19,17 @@ use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionE\n use rustc::mir::visit::{Visitor, PlaceContext};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{TyCtxt, self, Instance};\n-use rustc::mir::interpret::{Value, PrimVal, GlobalId};\n+use rustc::mir::interpret::{Value, PrimVal, GlobalId, EvalResult};\n+use interpret::EvalContext;\n+use interpret::CompileTimeEvaluator;\n use interpret::{eval_promoted, mk_borrowck_eval_cx, ValTy};\n use transform::{MirPass, MirSource};\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::ParamEnv;\n use rustc::ty::layout::{\n-    LayoutOf, TyLayout, LayoutError,\n+    LayoutOf, TyLayout, LayoutError, LayoutCx,\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n@@ -64,6 +66,7 @@ type Const<'tcx> = (Value, ty::Ty<'tcx>, Span);\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'b, 'a, 'tcx:'a+'b> {\n+    ecx: EvalContext<'a, 'b, 'tcx, CompileTimeEvaluator>,\n     mir: &'b Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     source: MirSource,\n@@ -102,7 +105,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n         source: MirSource,\n     ) -> ConstPropagator<'b, 'a, 'tcx> {\n         let param_env = tcx.param_env(source.def_id);\n+        let substs = Substs::identity_for_item(tcx, source.def_id);\n+        let instance = Instance::new(source.def_id, substs);\n+        let ecx = mk_borrowck_eval_cx(tcx, instance, mir, DUMMY_SP).unwrap();\n         ConstPropagator {\n+            ecx,\n             mir,\n             tcx,\n             source,\n@@ -112,7 +119,27 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n         }\n     }\n \n-    fn const_eval(&self, cid: GlobalId<'tcx>, span: Span) -> Option<Const<'tcx>> {\n+    fn use_ecx<F, T>(\n+        &mut self,\n+        span: Span,\n+        f: F\n+    ) -> Option<T>\n+    where\n+        F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n+    {\n+        self.ecx.tcx.span = span;\n+        let r = match f(self) {\n+            Ok(val) => Some(val),\n+            Err(mut err) => {\n+                self.ecx.report(&mut err, false, Some(span));\n+                None\n+            },\n+        };\n+        self.ecx.tcx.span = DUMMY_SP;\n+        r\n+    }\n+\n+    fn const_eval(&mut self, cid: GlobalId<'tcx>, span: Span) -> Option<Const<'tcx>> {\n         let value = match self.tcx.const_eval(self.param_env.and(cid)) {\n             Ok(val) => val,\n             Err(err) => {\n@@ -121,7 +148,9 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             },\n         };\n         let val = match value.val {\n-            ConstVal::Value(v) => v,\n+            ConstVal::Value(v) => {\n+                self.use_ecx(span, |this| this.ecx.const_value_to_value(v, value.ty))?\n+            },\n             _ => bug!(\"eval produced: {:?}\", value),\n         };\n         let val = (val, value.ty, span);\n@@ -132,7 +161,12 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n     fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<Const<'tcx>> {\n         match c.literal {\n             Literal::Value { value } => match value.val {\n-                ConstVal::Value(v) => Some((v, value.ty, c.span)),\n+                ConstVal::Value(v) => {\n+                    let v = self.use_ecx(c.span, |this| {\n+                        this.ecx.const_value_to_value(v, value.ty)\n+                    })?;\n+                    Some((v, value.ty, c.span))\n+                },\n                 ConstVal::Unevaluated(did, substs) => {\n                     let instance = Instance::resolve(\n                         self.tcx,\n@@ -162,7 +196,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 };\n                 // cannot use `const_eval` here, because that would require having the MIR\n                 // for the current function available, but we're producing said MIR right now\n-                let (value, _, ty) = eval_promoted(self.tcx, cid, self.mir, self.param_env)?;\n+                let span = self.mir.span;\n+                let (value, _, ty) = self.use_ecx(span, |this| {\n+                    Ok(eval_promoted(&mut this.ecx, cid, this.mir, this.param_env))\n+                })??;\n                 let val = (value, ty, c.span);\n                 trace!(\"evaluated {:?} to {:?}\", c, val);\n                 Some(val)\n@@ -185,7 +222,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                             use rustc_data_structures::indexed_vec::Idx;\n                             let field_index = field.index();\n                             let val = [a, b][field_index];\n-                            let field = base_layout.field(&*self, field_index).ok()?;\n+                            let cx = LayoutCx {\n+                                tcx: self.tcx,\n+                                param_env: self.param_env,\n+                            };\n+                            let field = base_layout.field(cx, field_index).ok()?;\n                             trace!(\"projection resulted in: {:?}\", val);\n                             Some((Value::ByVal(val), field.ty, span))\n                         },\n@@ -258,19 +299,13 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     // FIXME: can't handle code with generics\n                     return None;\n                 }\n-                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n-                let instance = Instance::new(self.source.def_id, substs);\n-                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n \n                 let val = self.eval_operand(arg)?;\n-                let prim = ecx.value_to_primval(ValTy { value: val.0, ty: val.1 }).ok()?;\n-                match ecx.unary_op(op, prim, val.1) {\n-                    Ok(val) => Some((Value::ByVal(val), place_ty, span)),\n-                    Err(mut err) => {\n-                        ecx.report(&mut err, false, Some(span));\n-                        None\n-                    },\n-                }\n+                let prim = self.use_ecx(span, |this| {\n+                    this.ecx.value_to_primval(ValTy { value: val.0, ty: val.1 })\n+                })?;\n+                let val = self.use_ecx(span, |this| this.ecx.unary_op(op, prim, val.1))?;\n+                Some((Value::ByVal(val), place_ty, span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -287,11 +322,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     // FIXME: can't handle code with generics\n                     return None;\n                 }\n-                let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n-                let instance = Instance::new(self.source.def_id, substs);\n-                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n \n-                let r = ecx.value_to_primval(ValTy { value: right.0, ty: right.1 }).ok()?;\n+                let r = self.use_ecx(span, |this| {\n+                    this.ecx.value_to_primval(ValTy { value: right.0, ty: right.1 })\n+                })?;\n                 if op == BinOp::Shr || op == BinOp::Shl {\n                     let param_env = self.tcx.param_env(self.source.def_id);\n                     let left_ty = left.ty(self.mir, self.tcx);\n@@ -316,31 +350,31 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     }\n                 }\n                 let left = self.eval_operand(left)?;\n-                let l = ecx.value_to_primval(ValTy { value: left.0, ty: left.1 }).ok()?;\n+                let l = self.use_ecx(span, |this| {\n+                    this.ecx.value_to_primval(ValTy { value: left.0, ty: left.1 })\n+                })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n-                match ecx.binary_op(op, l, left.1, r, right.1) {\n-                    Ok((val, overflow)) => {\n-                        let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n-                            Value::ByValPair(\n-                                val,\n-                                PrimVal::from_bool(overflow),\n-                            )\n-                        } else {\n-                            if overflow {\n-                                use rustc::mir::interpret::EvalErrorKind;\n-                                let mut err = EvalErrorKind::Overflow(op).into();\n-                                ecx.report(&mut err, false, Some(span));\n-                                return None;\n-                            }\n-                            Value::ByVal(val)\n-                        };\n-                        Some((val, place_ty, span))\n-                    },\n-                    Err(mut err) => {\n-                        ecx.report(&mut err, false, Some(span));\n-                        None\n-                    },\n-                }\n+                let (val, overflow) = self.use_ecx(span, |this| {\n+                    this.ecx.binary_op(op, l, left.1, r, right.1)\n+                })?;\n+                let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n+                    Value::ByValPair(\n+                        val,\n+                        PrimVal::from_bool(overflow),\n+                    )\n+                } else {\n+                    if overflow {\n+                        use rustc::mir::interpret::EvalErrorKind;\n+                        let mut err = EvalErrorKind::Overflow(op).into();\n+                        self.use_ecx(span, |this| {\n+                            this.ecx.report(&mut err, false, Some(span));\n+                            Ok(())\n+                        });\n+                        return None;\n+                    }\n+                    Value::ByVal(val)\n+                };\n+                Some((val, place_ty, span))\n             },\n         }\n     }"}, {"sha": "0666209d4f13a07fed502354b434dff1006b3fce", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -17,8 +17,6 @@ use dataflow::MoveDataParamEnv;\n use dataflow::{self, do_dataflow, DebugFormatted};\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n-use rustc::middle::const_val::ConstVal;\n-use rustc::mir::interpret::{Value, PrimVal};\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -533,10 +531,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             span,\n             ty: self.tcx.types.bool,\n             literal: Literal::Value {\n-                value: self.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val as u128))),\n-                    ty: self.tcx.types.bool\n-                })\n+                value: ty::Const::from_bool(self.tcx, val)\n             }\n         })))\n     }"}, {"sha": "5da40d04b337399b6526b5bcf64b43c4267bd098", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -61,7 +61,6 @@\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutVisitor};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty};\n@@ -79,7 +78,6 @@ use transform::simplify;\n use transform::no_landing_pads::no_landing_pads;\n use dataflow::{do_dataflow, DebugFormatted, state_for_location};\n use dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n-use rustc::mir::interpret::{Value, PrimVal};\n \n pub struct StateTransform;\n \n@@ -180,10 +178,10 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n             span: source_info.span,\n             ty: self.tcx.types.u32,\n             literal: Literal::Value {\n-                value: self.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(state_disc.into()))),\n-                    ty: self.tcx.types.u32\n-                }),\n+                value: ty::Const::from_bits(\n+                    self.tcx,\n+                    state_disc.into(),\n+                    self.tcx.types.u32),\n             },\n         });\n         Statement {\n@@ -698,10 +696,7 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             span: mir.span,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n-                value: tcx.mk_const(ty::Const {\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n-                    ty: tcx.types.bool\n-                }),\n+                value: ty::Const::from_bool(tcx, false),\n             },\n         }),\n         expected: true,"}, {"sha": "28ab3d6a8574fb3543cf27bc40e15f42192cb97d", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -595,7 +595,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n             Operand::Constant(ref constant) => {\n                 if let Literal::Value {\n-                    value: &ty::Const { val: ConstVal::Unevaluated(def_id, _), ty }\n+                    value: &ty::Const { val: ConstVal::Unevaluated(def_id, _), ty, .. }\n                 } = constant.literal {\n                     // Don't peek inside trait associated constants.\n                     if self.tcx.trait_of_item(def_id).is_some() {\n@@ -690,7 +690,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             _ => false\n                         }\n                     } else if let ty::TyArray(_, len) = ty.sty {\n-                        len.val.unwrap_u64() == 0 &&\n+                        len.unwrap_usize(self.tcx) == 0 &&\n                             self.mode == Mode::Fn\n                     } else {\n                         false"}, {"sha": "72bee040c06a9a676f5b5b3c5fcad9fc00511acc", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -10,10 +10,8 @@\n \n //! A pass that simplifies branches when their condition is known.\n \n-use rustc::ty::{self, TyCtxt};\n-use rustc::middle::const_val::ConstVal;\n+use rustc::ty::TyCtxt;\n use rustc::mir::*;\n-use rustc::mir::interpret::{Value, PrimVal};\n use transform::{MirPass, MirSource};\n \n use std::borrow::Cow;\n@@ -32,16 +30,16 @@ impl MirPass for SimplifyBranches {\n     }\n \n     fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource,\n                           mir: &mut Mir<'tcx>) {\n         for block in mir.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {\n                 TerminatorKind::SwitchInt { discr: Operand::Constant(box Constant {\n                     literal: Literal::Value { ref value }, ..\n-                }), ref values, ref targets, .. } => {\n-                    if let Some(constint) = value.val.to_raw_bits() {\n+                }), switch_ty, ref values, ref targets, .. } => {\n+                    if let Some(constint) = value.assert_bits(switch_ty) {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n                         for (&v, t) in values.iter().zip(targets.iter()) {\n@@ -57,12 +55,9 @@ impl MirPass for SimplifyBranches {\n                 },\n                 TerminatorKind::Assert { target, cond: Operand::Constant(box Constant {\n                     literal: Literal::Value {\n-                        value: &ty::Const {\n-                            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(cond))),\n-                        .. }\n+                        value\n                     }, ..\n-                }), expected, .. } if (cond == 1) == expected => {\n-                    assert!(cond <= 1);\n+                }), expected, .. } if (value.assert_bool(tcx) == Some(true)) == expected => {\n                     TerminatorKind::Goto { target: target }\n                 },\n                 TerminatorKind::FalseEdges { real_target, .. } => {"}, {"sha": "5019c74742a2b3ff31ddc087b85883ae5a1de196", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -81,9 +81,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                 } else {\n                     let place_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n                     if let ty::TyArray(item_ty, const_size) = place_ty.sty {\n-                        if let Some(size) = const_size.val.to_raw_bits() {\n-                            assert!(size <= (u32::max_value() as u128),\n-                                    \"unform array move out doesn't supported\n+                        if let Some(size) = const_size.assert_usize(self.tcx) {\n+                            assert!(size <= u32::max_value() as u64,\n+                                    \"uniform array move out doesn't supported\n                                      for array bigger then u32\");\n                             self.uniform(location, dst_place, proj, item_ty, size as u32);\n                         }\n@@ -203,7 +203,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n                         let opt_size = opt_src_place.and_then(|src_place| {\n                             let src_ty = src_place.ty(mir, tcx).to_ty(tcx);\n                             if let ty::TyArray(_, ref size_o) = src_ty.sty {\n-                                size_o.val.to_raw_bits().map(|n| n as u64)\n+                                size_o.assert_usize(tcx)\n                             } else {\n                                 None\n                             }"}, {"sha": "9fc04dc7d24914a3c66fca69418aeaa2cf984799", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -11,15 +11,13 @@\n use std::fmt;\n use rustc::hir;\n use rustc::mir::*;\n-use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::util::IntTypeExt;\n use rustc_data_structures::indexed_vec::Idx;\n use util::patch::MirPatch;\n-use rustc::mir::interpret::{Value, PrimVal};\n \n use std::{iter, u32};\n \n@@ -809,8 +807,10 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 let succ = self.succ;\n                 self.complete_drop(Some(DropFlagMode::Deep), succ, unwind)\n             }\n-            ty::TyArray(ety, size) => self.open_drop_for_array(\n-                ety, size.val.to_raw_bits().map(|i| i as u64)),\n+            ty::TyArray(ety, size) => {\n+                let size = size.assert_usize(self.tcx());\n+                self.open_drop_for_array(ety, size)\n+            },\n             ty::TySlice(ety) => self.open_drop_for_array(ety, None),\n \n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n@@ -961,10 +961,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,\n             literal: Literal::Value {\n-                value: self.tcx().mk_const(ty::Const {\n-                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.into()))),\n-                    ty: self.tcx().types.usize\n-                })\n+                value: ty::Const::from_usize(self.tcx(), val.into())\n             }\n         })\n     }"}, {"sha": "9d74ad0830f0c236178cc1227b48e0a81ac1fa45", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -402,7 +402,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n \n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n         self.super_const(constant);\n-        let ty::Const { ty, val } = constant;\n+        let ty::Const { ty, val, .. } = constant;\n         self.push(&format!(\"ty::Const\"));\n         self.push(&format!(\"+ ty: {:?}\", ty));\n         self.push(&format!(\"+ val: {:?}\", val));"}, {"sha": "54177c5d5a2cc1644b92ad774f717d7cfea5b5d6", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -199,7 +199,7 @@ pub fn unsized_info<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n     let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n-            C_usize(cx, len.val.unwrap_u64())\n+            C_usize(cx, len.unwrap_usize(cx.tcx))\n         }\n         (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n@@ -1372,8 +1372,7 @@ mod temp_stable_hash_impls {\n }\n \n fn fetch_wasm_section(tcx: TyCtxt, id: DefId) -> (String, Vec<u8>) {\n-    use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n-    use rustc::middle::const_val::ConstVal;\n+    use rustc::mir::interpret::GlobalId;\n \n     info!(\"loading wasm section {:?}\", id);\n \n@@ -1392,18 +1391,7 @@ fn fetch_wasm_section(tcx: TyCtxt, id: DefId) -> (String, Vec<u8>) {\n     let param_env = ty::ParamEnv::reveal_all();\n     let val = tcx.const_eval(param_env.and(cid)).unwrap();\n \n-    let val = match val.val {\n-        ConstVal::Value(val) => val,\n-        ConstVal::Unevaluated(..) => bug!(\"should be evaluated\"),\n-    };\n-    let val = match val {\n-        Value::ByRef(ptr, _align) => ptr.into_inner_primval(),\n-        ref v => bug!(\"should be ByRef, was {:?}\", v),\n-    };\n-    let mem = match val {\n-        PrimVal::Ptr(mem) => mem,\n-        ref v => bug!(\"should be Ptr, was {:?}\", v),\n-    };\n+    let mem = val.to_ptr().expect(\"should be pointer\");\n     assert_eq!(mem.offset, 0);\n     let alloc = tcx\n         .interpret_interner"}, {"sha": "4e77c0df65ef4eeeb6569d2d67b0f237c1d4ca8d", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -277,7 +277,7 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     let upper_bound = match array_or_slice_type.sty {\n         ty::TyArray(_, len) => {\n-            len.val.unwrap_u64() as c_longlong\n+            len.unwrap_usize(cx.tcx) as c_longlong\n         }\n         _ => -1\n     };"}, {"sha": "05a74db3a6ca9842470d51991fc589dc5998c88a", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -97,7 +97,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::TyArray(inner_type, len) => {\n             output.push('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n-            output.push_str(&format!(\"; {}\", len.val.unwrap_u64()));\n+            output.push_str(&format!(\"; {}\", len.unwrap_usize(cx.tcx)));\n             output.push(']');\n         },\n         ty::TySlice(inner_type) => {"}, {"sha": "a10b7c9c9f10f23a818d98dd2b8ead0e96fd3fb5", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 71, "deletions": 35, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -14,7 +14,7 @@ use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{Allocation, GlobalId, MemoryPointer, PrimVal, Value as MiriValue};\n+use rustc::mir::interpret::{GlobalId, MemoryPointer, PrimVal, Allocation, ConstValue};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Scalar};\n use builder::Builder;\n@@ -56,7 +56,7 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n                     consts::get_static(cx, def_id)\n                 } else if let Some(alloc) = cx.tcx.interpret_interner\n                                               .get_alloc(ptr.alloc_id) {\n-                    let init = global_initializer(cx, alloc);\n+                    let init = const_alloc_to_llvm(cx, alloc);\n                     if alloc.runtime_mutability == Mutability::Mutable {\n                         consts::addr_of_mut(cx, init, alloc.align, \"byte_str\")\n                     } else {\n@@ -81,7 +81,50 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n     }\n }\n \n-pub fn global_initializer(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n+fn const_value_to_llvm<'tcx>(cx: &CodegenCx<'_, 'tcx>, val: ConstValue, ty: Ty<'tcx>) -> ValueRef {\n+    let layout = cx.layout_of(ty);\n+\n+    if layout.is_zst() {\n+        return C_undef(layout.immediate_llvm_type(cx));\n+    }\n+\n+    match val {\n+        ConstValue::ByVal(x) => {\n+            let scalar = match layout.abi {\n+                layout::Abi::Scalar(ref x) => x,\n+                _ => bug!(\"const_value_to_llvm: invalid ByVal layout: {:#?}\", layout)\n+            };\n+            primval_to_llvm(\n+                cx,\n+                x,\n+                scalar,\n+                layout.immediate_llvm_type(cx),\n+            )\n+        },\n+        ConstValue::ByValPair(a, b) => {\n+            let (a_scalar, b_scalar) = match layout.abi {\n+                layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n+                _ => bug!(\"const_value_to_llvm: invalid ByValPair layout: {:#?}\", layout)\n+            };\n+            let a_llval = primval_to_llvm(\n+                cx,\n+                a,\n+                a_scalar,\n+                layout.scalar_pair_element_llvm_type(cx, 0),\n+            );\n+            let b_llval = primval_to_llvm(\n+                cx,\n+                b,\n+                b_scalar,\n+                layout.scalar_pair_element_llvm_type(cx, 1),\n+            );\n+            C_struct(cx, &[a_llval, b_llval], false)\n+        },\n+        ConstValue::ByRef(alloc) => const_alloc_to_llvm(cx, alloc),\n+    }\n+}\n+\n+pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n     let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n     let layout = cx.data_layout();\n     let pointer_size = layout.pointer_size.bytes() as usize;\n@@ -96,7 +139,7 @@ pub fn global_initializer(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n         let ptr_offset = read_target_uint(\n             layout.endian,\n             &alloc.bytes[offset..(offset + pointer_size)],\n-        ).expect(\"global_initializer: could not read relocation pointer\") as u64;\n+        ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n         llvals.push(primval_to_llvm(\n             cx,\n             PrimVal::Ptr(MemoryPointer { alloc_id, offset: ptr_offset }),\n@@ -128,25 +171,19 @@ pub fn trans_static_initializer<'a, 'tcx>(\n     let param_env = ty::ParamEnv::reveal_all();\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n-    let ptr = match static_.val {\n-        ConstVal::Value(MiriValue::ByRef(ptr, _)) => ptr,\n+    let val = match static_.val {\n+        ConstVal::Value(val) => val,\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n-\n-    let alloc = cx\n-        .tcx\n-        .interpret_interner\n-        .get_alloc(ptr.primval.to_ptr().expect(\"static has integer pointer\").alloc_id)\n-        .expect(\"miri allocation never successfully created\");\n-    Ok(global_initializer(cx, alloc))\n+    Ok(const_value_to_llvm(cx, val, static_.ty))\n }\n \n impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n-    fn const_to_miri_value(\n+    fn const_to_const_value(\n         &mut self,\n         bx: &Builder<'a, 'tcx>,\n         constant: &'tcx ty::Const<'tcx>,\n-    ) -> Result<MiriValue, ConstEvalErr<'tcx>> {\n+    ) -> Result<ConstValue<'tcx>, ConstEvalErr<'tcx>> {\n         match constant.val {\n             ConstVal::Unevaluated(def_id, ref substs) => {\n                 let tcx = bx.tcx();\n@@ -157,17 +194,17 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     promoted: None,\n                 };\n                 let c = tcx.const_eval(param_env.and(cid))?;\n-                self.const_to_miri_value(bx, c)\n+                self.const_to_const_value(bx, c)\n             },\n-            ConstVal::Value(miri_val) => Ok(miri_val),\n+            ConstVal::Value(val) => Ok(val),\n         }\n     }\n \n-    pub fn mir_constant_to_miri_value(\n+    pub fn mir_constant_to_const_value(\n         &mut self,\n         bx: &Builder<'a, 'tcx>,\n         constant: &mir::Constant<'tcx>,\n-    ) -> Result<MiriValue, ConstEvalErr<'tcx>> {\n+    ) -> Result<ConstValue<'tcx>, ConstEvalErr<'tcx>> {\n         match constant.literal {\n             mir::Literal::Promoted { index } => {\n                 let param_env = ty::ParamEnv::reveal_all();\n@@ -180,7 +217,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             mir::Literal::Value { value } => {\n                 Ok(self.monomorphize(&value))\n             }\n-        }.and_then(|c| self.const_to_miri_value(bx, c))\n+        }.and_then(|c| self.const_to_const_value(bx, c))\n     }\n \n     /// process constant containing SIMD shuffle indices\n@@ -189,11 +226,11 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         bx: &Builder<'a, 'tcx>,\n         constant: &mir::Constant<'tcx>,\n     ) -> (ValueRef, Ty<'tcx>) {\n-        self.mir_constant_to_miri_value(bx, constant)\n+        self.mir_constant_to_const_value(bx, constant)\n             .and_then(|c| {\n                 let field_ty = constant.ty.builtin_index().unwrap();\n                 let fields = match constant.ty.sty {\n-                    ty::TyArray(_, n) => n.val.unwrap_u64(),\n+                    ty::TyArray(_, n) => n.unwrap_usize(bx.tcx()),\n                     ref other => bug!(\"invalid simd shuffle type: {}\", other),\n                 };\n                 let values: Result<Vec<ValueRef>, _> = (0..fields).map(|field| {\n@@ -206,19 +243,18 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         c,\n                         constant.ty,\n                     )?;\n-                    match field.val {\n-                        ConstVal::Value(MiriValue::ByVal(prim)) => {\n-                            let layout = bx.cx.layout_of(field_ty);\n-                            let scalar = match layout.abi {\n-                                layout::Abi::Scalar(ref x) => x,\n-                                _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n-                            };\n-                            Ok(primval_to_llvm(\n-                                bx.cx, prim, scalar,\n-                                layout.immediate_llvm_type(bx.cx),\n-                            ))\n-                        },\n-                        other => bug!(\"simd shuffle field {:?}, {}\", other, constant.ty),\n+                    if let Some(prim) = field.to_primval() {\n+                        let layout = bx.cx.layout_of(field_ty);\n+                        let scalar = match layout.abi {\n+                            layout::Abi::Scalar(ref x) => x,\n+                            _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n+                        };\n+                        Ok(primval_to_llvm(\n+                            bx.cx, prim, scalar,\n+                            layout.immediate_llvm_type(bx.cx),\n+                        ))\n+                    } else {\n+                        bug!(\"simd shuffle field {:?}\", field)\n                     }\n                 }).collect();\n                 let llval = C_struct(bx.cx, &values?, false);"}, {"sha": "432ac44e0a5660e2f33f90042b7912a065f4d3e0", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -11,7 +11,7 @@\n use llvm::ValueRef;\n use rustc::middle::const_val::ConstEvalErr;\n use rustc::mir;\n-use rustc::mir::interpret::Value as MiriValue;\n+use rustc::mir::interpret::ConstValue;\n use rustc::ty;\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -22,12 +22,13 @@ use builder::Builder;\n use value::Value;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n+use consts;\n \n use std::fmt;\n use std::ptr;\n \n use super::{FunctionCx, LocalRef};\n-use super::constant::{primval_to_llvm};\n+use super::constant::{primval_to_llvm, const_alloc_to_llvm};\n use super::place::PlaceRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -94,7 +95,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     }\n \n     pub fn from_const(bx: &Builder<'a, 'tcx>,\n-                      miri_val: MiriValue,\n+                      val: ConstValue<'tcx>,\n                       ty: ty::Ty<'tcx>)\n                       -> Result<OperandRef<'tcx>, ConstEvalErr<'tcx>> {\n         let layout = bx.cx.layout_of(ty);\n@@ -103,8 +104,8 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n             return Ok(OperandRef::new_zst(bx.cx, layout));\n         }\n \n-        let val = match miri_val {\n-            MiriValue::ByVal(x) => {\n+        let val = match val {\n+            ConstValue::ByVal(x) => {\n                 let scalar = match layout.abi {\n                     layout::Abi::Scalar(ref x) => x,\n                     _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n@@ -117,7 +118,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 );\n                 OperandValue::Immediate(llval)\n             },\n-            MiriValue::ByValPair(a, b) => {\n+            ConstValue::ByValPair(a, b) => {\n                 let (a_scalar, b_scalar) = match layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n                     _ => bug!(\"from_const: invalid ByValPair layout: {:#?}\", layout)\n@@ -136,18 +137,11 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 );\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            MiriValue::ByRef(ptr, align) => {\n-                let scalar = layout::Scalar {\n-                    value: layout::Primitive::Pointer,\n-                    valid_range: 0..=!0\n-                };\n-                let ptr = primval_to_llvm(\n-                    bx.cx,\n-                    ptr.into_inner_primval(),\n-                    &scalar,\n-                    layout.llvm_type(bx.cx).ptr_to(),\n-                );\n-                return Ok(PlaceRef::new_sized(ptr, layout, align).load(bx));\n+            ConstValue::ByRef(alloc) => {\n+                let init = const_alloc_to_llvm(bx.cx, alloc);\n+                let llval = consts::addr_of(bx.cx, init, layout.align, \"byte_str\");\n+                let llval = consts::bitcast(llval, layout.llvm_type(bx.cx).ptr_to());\n+                return Ok(PlaceRef::new_sized(llval, layout, alloc.align).load(bx));\n             },\n         };\n \n@@ -396,7 +390,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n \n             mir::Operand::Constant(ref constant) => {\n                 let ty = self.monomorphize(&constant.ty);\n-                self.mir_constant_to_miri_value(bx, constant)\n+                self.mir_constant_to_const_value(bx, constant)\n                     .and_then(|c| OperandRef::from_const(bx, c, ty))\n                     .unwrap_or_else(|err| {\n                         match constant.literal {"}, {"sha": "3b4477564502c4f11f17e8b6a26af70e5585c7f9", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -516,7 +516,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         if let mir::Place::Local(index) = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::TyArray(_, n) = op.layout.ty.sty {\n-                    let n = n.val.unwrap_u64();\n+                    let n = n.unwrap_usize(bx.cx.tcx);\n                     return common::C_usize(bx.cx, n);\n                 }\n             }"}, {"sha": "d307ef30044e12f13d9faa92fc3059fe4265765f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -12,7 +12,6 @@\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n //! is parameterized by an instance of `AstConv`.\n \n-use rustc::middle::const_val::ConstVal;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use hir;\n use hir::def::Def;\n@@ -1087,10 +1086,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyArray(ref ty, length) => {\n                 let length_def_id = tcx.hir.body_owner_def_id(length);\n                 let substs = Substs::identity_for_item(tcx, length_def_id);\n-                let length = tcx.mk_const(ty::Const {\n-                    val: ConstVal::Unevaluated(length_def_id, substs),\n-                    ty: tcx.types.usize\n-                });\n+                let length = ty::Const::unevaluated(tcx, length_def_id, substs, tcx.types.usize);\n                 let array_ty = tcx.mk_ty(ty::TyArray(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }"}, {"sha": "2547952d1043cfc8805b3655a1d8b461c3c03ed0", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -375,7 +375,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 let (inner_ty, slice_ty) = match expected_ty.sty {\n                     ty::TyArray(inner_ty, size) => {\n-                        let size = size.val.unwrap_u64();\n+                        let size = size.unwrap_usize(tcx);\n                         let min_len = before.len() as u64 + after.len() as u64;\n                         if slice.is_none() {\n                             if min_len != size {"}, {"sha": "7b859635f60df1f297a04df6c838db4b33106361", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -4018,7 +4018,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Ok(count) = count {\n-                let zero_or_one = count.val.to_raw_bits().map_or(false, |count| count <= 1);\n+                let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n                 if !zero_or_one {\n                     // For [foo, ..n] where n > 1, `foo` must have\n                     // Copy type:"}, {"sha": "3ffdd5595a2d5a898110ff40508187de58c69496", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -2644,10 +2644,7 @@ impl Clean<Type> for hir::Ty {\n                     promoted: None\n                 };\n                 let n = cx.tcx.const_eval(param_env.and(cid)).unwrap_or_else(|_| {\n-                    cx.tcx.mk_const(ty::Const {\n-                        val: ConstVal::Unevaluated(def_id, substs),\n-                        ty: cx.tcx.types.usize\n-                    })\n+                    ty::Const::unevaluated(cx.tcx, def_id, substs, cx.tcx.types.usize)\n                 });\n                 let n = print_const(cx, n);\n                 Array(box ty.clean(cx), n)\n@@ -3828,9 +3825,9 @@ fn print_const(cx: &DocContext, n: &ty::Const) -> String {\n                 inline::print_inlined_const(cx, def_id)\n             }\n         },\n-        ConstVal::Value(val) => {\n+        ConstVal::Value(..) => {\n             let mut s = String::new();\n-            ::rustc::mir::print_miri_value(val, n.ty, &mut s).unwrap();\n+            ::rustc::mir::fmt_const_val(&mut s, n).unwrap();\n             // array lengths are obviously usize\n             if s.ends_with(\"usize\") {\n                 let n = s.len() - \"usize\".len();"}, {"sha": "1879002e7f3d7cb2750ca73b9aad7aedda4a8347", "filename": "src/test/codegen/link_section.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Ftest%2Fcodegen%2Flink_section.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd9787777dac5db6bd555df08038e3c191999e4/src%2Ftest%2Fcodegen%2Flink_section.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flink_section.rs?ref=fdd9787777dac5db6bd555df08038e3c191999e4", "patch": "@@ -12,17 +12,11 @@\n \n #![crate_type = \"lib\"]\n \n-// CHECK: @VAR1 = constant <{ [4 x i8] }> <{ [4 x i8] c\"\\01\\00\\00\\00\" }>, section \".test_one\"\n+// CHECK: @VAR1 = constant i32 1, section \".test_one\"\n #[no_mangle]\n #[link_section = \".test_one\"]\n-#[cfg(target_endian = \"little\")]\n pub static VAR1: u32 = 1;\n \n-#[no_mangle]\n-#[link_section = \".test_one\"]\n-#[cfg(target_endian = \"big\")]\n-pub static VAR1: u32 = 0x01000000;\n-\n pub enum E {\n     A(u32),\n     B(f32)"}]}