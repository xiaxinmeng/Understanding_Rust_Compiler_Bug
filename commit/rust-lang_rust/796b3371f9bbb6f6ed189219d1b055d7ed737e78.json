{"sha": "796b3371f9bbb6f6ed189219d1b055d7ed737e78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NmIzMzcxZjliYmI2ZjZlZDE4OTIxOWQxYjA1NWQ3ZWQ3MzdlNzg=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-07-24T04:30:25Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-07-28T06:42:53Z"}, "message": "std: Put the option tests into a tests submodule", "tree": {"sha": "0e5d92ecd4f83aa81db629f60c0eb7d69801330b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e5d92ecd4f83aa81db629f60c0eb7d69801330b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/796b3371f9bbb6f6ed189219d1b055d7ed737e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/796b3371f9bbb6f6ed189219d1b055d7ed737e78", "html_url": "https://github.com/rust-lang/rust/commit/796b3371f9bbb6f6ed189219d1b055d7ed737e78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/796b3371f9bbb6f6ed189219d1b055d7ed737e78/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03a16dbb8e6341e622f7d09c9be99ec5502239f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/03a16dbb8e6341e622f7d09c9be99ec5502239f3", "html_url": "https://github.com/rust-lang/rust/commit/03a16dbb8e6341e622f7d09c9be99ec5502239f3"}], "stats": {"total": 216, "additions": 111, "deletions": 105}, "files": [{"sha": "6e4880550ebb4150e04868e7295e181e0f3ebc6e", "filename": "src/libstd/option.rs", "status": "modified", "additions": 111, "deletions": 105, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/796b3371f9bbb6f6ed189219d1b055d7ed737e78/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/796b3371f9bbb6f6ed189219d1b055d7ed737e78/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=796b3371f9bbb6f6ed189219d1b055d7ed737e78", "patch": "@@ -441,134 +441,140 @@ impl<'self, A> Iterator<&'self mut A> for OptionMutIterator<'self, A> {\n     }\n }\n \n-#[test]\n-fn test_unwrap_ptr() {\n-    unsafe {\n-        let x = ~0;\n-        let addr_x: *int = ::cast::transmute(&*x);\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use util;\n+\n+    #[test]\n+    fn test_unwrap_ptr() {\n+        unsafe {\n+            let x = ~0;\n+            let addr_x: *int = ::cast::transmute(&*x);\n+            let opt = Some(x);\n+            let y = opt.unwrap();\n+            let addr_y: *int = ::cast::transmute(&*y);\n+            assert_eq!(addr_x, addr_y);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unwrap_str() {\n+        let x = ~\"test\";\n+        let addr_x = x.as_imm_buf(|buf, _len| buf);\n         let opt = Some(x);\n         let y = opt.unwrap();\n-        let addr_y: *int = ::cast::transmute(&*y);\n+        let addr_y = y.as_imm_buf(|buf, _len| buf);\n         assert_eq!(addr_x, addr_y);\n     }\n-}\n \n-#[test]\n-fn test_unwrap_str() {\n-    let x = ~\"test\";\n-    let addr_x = x.as_imm_buf(|buf, _len| buf);\n-    let opt = Some(x);\n-    let y = opt.unwrap();\n-    let addr_y = y.as_imm_buf(|buf, _len| buf);\n-    assert_eq!(addr_x, addr_y);\n-}\n+    #[test]\n+    fn test_unwrap_resource() {\n+        struct R {\n+           i: @mut int,\n+        }\n \n-#[test]\n-fn test_unwrap_resource() {\n-    struct R {\n-       i: @mut int,\n-    }\n+        #[unsafe_destructor]\n+        impl ::ops::Drop for R {\n+           fn drop(&self) { *(self.i) += 1; }\n+        }\n \n-    #[unsafe_destructor]\n-    impl ::ops::Drop for R {\n-       fn drop(&self) { *(self.i) += 1; }\n-    }\n+        fn R(i: @mut int) -> R {\n+            R {\n+                i: i\n+            }\n+        }\n \n-    fn R(i: @mut int) -> R {\n-        R {\n-            i: i\n+        let i = @mut 0;\n+        {\n+            let x = R(i);\n+            let opt = Some(x);\n+            let _y = opt.unwrap();\n         }\n+        assert_eq!(*i, 1);\n     }\n \n-    let i = @mut 0;\n-    {\n-        let x = R(i);\n-        let opt = Some(x);\n-        let _y = opt.unwrap();\n+    #[test]\n+    fn test_option_dance() {\n+        let x = Some(());\n+        let mut y = Some(5);\n+        let mut y2 = 0;\n+        for x.iter().advance |_x| {\n+            y2 = y.take_unwrap();\n+        }\n+        assert_eq!(y2, 5);\n+        assert!(y.is_none());\n+    }\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn test_option_too_much_dance() {\n+        let mut y = Some(util::NonCopyable);\n+        let _y2 = y.take_unwrap();\n+        let _y3 = y.take_unwrap();\n+    }\n+\n+    #[test]\n+    fn test_option_while_some() {\n+        let mut i = 0;\n+        do Some(10).while_some |j| {\n+            i += 1;\n+            if (j > 0) {\n+                Some(j-1)\n+            } else {\n+                None\n+            }\n+        }\n+        assert_eq!(i, 11);\n     }\n-    assert_eq!(*i, 1);\n-}\n \n-#[test]\n-fn test_option_dance() {\n-    let x = Some(());\n-    let mut y = Some(5);\n-    let mut y2 = 0;\n-    for x.iter().advance |_x| {\n-        y2 = y.take_unwrap();\n+    #[test]\n+    fn test_get_or_zero() {\n+        let some_stuff = Some(42);\n+        assert_eq!(some_stuff.get_or_zero(), 42);\n+        let no_stuff: Option<int> = None;\n+        assert_eq!(no_stuff.get_or_zero(), 0);\n     }\n-    assert_eq!(y2, 5);\n-    assert!(y.is_none());\n-}\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_option_too_much_dance() {\n-    let mut y = Some(util::NonCopyable);\n-    let _y2 = y.take_unwrap();\n-    let _y3 = y.take_unwrap();\n-}\n \n-#[test]\n-fn test_option_while_some() {\n-    let mut i = 0;\n-    do Some(10).while_some |j| {\n-        i += 1;\n-        if (j > 0) {\n-            Some(j-1)\n-        } else {\n-            None\n-        }\n+    #[test]\n+    fn test_filtered() {\n+        let some_stuff = Some(42);\n+        let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n+        assert_eq!(some_stuff.get(), 42);\n+        assert!(modified_stuff.is_none());\n     }\n-    assert_eq!(i, 11);\n-}\n \n-#[test]\n-fn test_get_or_zero() {\n-    let some_stuff = Some(42);\n-    assert_eq!(some_stuff.get_or_zero(), 42);\n-    let no_stuff: Option<int> = None;\n-    assert_eq!(no_stuff.get_or_zero(), 0);\n-}\n+    #[test]\n+    fn test_iter() {\n+        let val = 5;\n \n-#[test]\n-fn test_filtered() {\n-    let some_stuff = Some(42);\n-    let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n-    assert_eq!(some_stuff.get(), 42);\n-    assert!(modified_stuff.is_none());\n-}\n+        let x = Some(val);\n+        let mut it = x.iter();\n \n-#[test]\n-fn test_iter() {\n-    let val = 5;\n-\n-    let x = Some(val);\n-    let mut it = x.iter();\n-\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(it.next(), Some(&val));\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert!(it.next().is_none());\n-}\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.next(), Some(&val));\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert!(it.next().is_none());\n+    }\n \n-#[test]\n-fn test_mut_iter() {\n-    let val = 5;\n-    let new_val = 11;\n+    #[test]\n+    fn test_mut_iter() {\n+        let val = 5;\n+        let new_val = 11;\n \n-    let mut x = Some(val);\n-    let mut it = x.mut_iter();\n+        let mut x = Some(val);\n+        let mut it = x.mut_iter();\n \n-    assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n \n-    match it.next() {\n-        Some(interior) => {\n-            assert_eq!(*interior, val);\n-            *interior = new_val;\n-            assert_eq!(x, Some(new_val));\n+        match it.next() {\n+            Some(interior) => {\n+                assert_eq!(*interior, val);\n+                *interior = new_val;\n+                assert_eq!(x, Some(new_val));\n+            }\n+            None => assert!(false),\n         }\n-        None => assert!(false),\n-    }\n \n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert!(it.next().is_none());\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert!(it.next().is_none());\n+    }\n }"}]}