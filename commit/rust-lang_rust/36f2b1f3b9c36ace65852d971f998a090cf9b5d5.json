{"sha": "36f2b1f3b9c36ace65852d971f998a090cf9b5d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2ZjJiMWYzYjljMzZhY2U2NTg1MmQ5NzFmOTk4YTA5MGNmOWI1ZDU=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-22T11:59:48Z"}, "committer": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-25T19:03:14Z"}, "message": "iterate over `Step`s which are either, newlines or multibyte chars", "tree": {"sha": "7844f2e759fe477f69b8ba449490a6e4fca58977", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7844f2e759fe477f69b8ba449490a6e4fca58977"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36f2b1f3b9c36ace65852d971f998a090cf9b5d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36f2b1f3b9c36ace65852d971f998a090cf9b5d5", "html_url": "https://github.com/rust-lang/rust/commit/36f2b1f3b9c36ace65852d971f998a090cf9b5d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36f2b1f3b9c36ace65852d971f998a090cf9b5d5/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c44ba0f04a0997617d517111d0a08245f0dacac", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c44ba0f04a0997617d517111d0a08245f0dacac", "html_url": "https://github.com/rust-lang/rust/commit/1c44ba0f04a0997617d517111d0a08245f0dacac"}], "stats": {"total": 147, "additions": 121, "deletions": 26}, "files": [{"sha": "c29e2e49a30ab6163eeb059662fae509d60b4154", "filename": "crates/ra_editor/src/line_index.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/36f2b1f3b9c36ace65852d971f998a090cf9b5d5/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f2b1f3b9c36ace65852d971f998a090cf9b5d5/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index.rs?ref=36f2b1f3b9c36ace65852d971f998a090cf9b5d5", "patch": "@@ -15,9 +15,9 @@ pub struct LineCol {\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-struct Utf16Char {\n-    start: TextUnit,\n-    end: TextUnit,\n+pub(crate) struct Utf16Char {\n+    pub(crate) start: TextUnit,\n+    pub(crate) end: TextUnit,\n }\n \n impl Utf16Char {\n@@ -122,7 +122,13 @@ impl LineIndex {\n     }\n \n     pub(crate) fn newlines(&self) -> &[TextUnit] {\n-        &self.newlines[1..]\n+        &self.newlines[..]\n+    }\n+\n+    pub(crate) fn utf16_chars(&self, newline_idx: usize) -> Option<&[Utf16Char]> {\n+        self.utf16_lines\n+            .get(&(newline_idx as u32))\n+            .map(|x| x.as_slice())\n     }\n }\n "}, {"sha": "9c8d801e90958e8050ac54d83ca398966e09f3d9", "filename": "crates/ra_editor/src/line_index_utils.rs", "status": "modified", "additions": 111, "deletions": 22, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/36f2b1f3b9c36ace65852d971f998a090cf9b5d5/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36f2b1f3b9c36ace65852d971f998a090cf9b5d5/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs?ref=36f2b1f3b9c36ace65852d971f998a090cf9b5d5", "patch": "@@ -1,25 +1,94 @@\n use ra_text_edit::AtomTextEdit;\n use ra_syntax::{TextUnit, TextRange};\n-use crate::{LineIndex, LineCol};\n+use crate::{LineIndex, LineCol, line_index::Utf16Char};\n use superslice::Ext;\n \n+#[derive(Debug, Clone)]\n+enum Step {\n+    Newline(TextUnit),\n+    Utf16Char(TextRange),\n+}\n+\n+struct LineIndexStepIter<'a> {\n+    line_index: &'a LineIndex,\n+    newlines: std::slice::Iter<'a, TextUnit>,\n+    next_newline_idx: usize,\n+    utf16_chars: Option<std::slice::Iter<'a, Utf16Char>>,\n+}\n+\n+impl<'a> LineIndexStepIter<'a> {\n+    fn from(line_index: &LineIndex) -> LineIndexStepIter {\n+        let mut x = LineIndexStepIter {\n+            line_index,\n+            newlines: line_index.newlines().iter(),\n+            next_newline_idx: 0,\n+            utf16_chars: None,\n+        };\n+        // skip first newline since it's not real\n+        x.next();\n+        x\n+    }\n+}\n+\n+impl<'a> Iterator for LineIndexStepIter<'a> {\n+    type Item = Step;\n+    fn next(&mut self) -> Option<Step> {\n+        self.utf16_chars\n+            .as_mut()\n+            .and_then(|x| {\n+                None\n+                // TODO Enable\n+                // let x = x.next()?;\n+                // Some(Step::Utf16Char(TextRange::from_to(x.start, x.end)))\n+            })\n+            .or_else(|| {\n+                self.utf16_chars = self\n+                    .line_index\n+                    .utf16_chars(self.next_newline_idx)\n+                    .map(|x| x.iter());\n+                self.next_newline_idx += 1;\n+                let x = self.newlines.next()?;\n+                Some(Step::Newline(*x))\n+            })\n+    }\n+}\n+\n #[derive(Debug)]\n struct OffsetNewlineIter<'a> {\n     text: &'a str,\n     offset: TextUnit,\n }\n \n impl<'a> Iterator for OffsetNewlineIter<'a> {\n-    type Item = TextUnit;\n-    fn next(&mut self) -> Option<TextUnit> {\n-        let next_idx = self\n+    type Item = Step;\n+    fn next(&mut self) -> Option<Step> {\n+        let (next, next_offset) = self\n             .text\n             .char_indices()\n-            .filter_map(|(i, c)| if c == '\\n' { Some(i + 1) } else { None })\n+            .filter_map(|(i, c)| {\n+                if c == '\\n' {\n+                    let next_offset = self.offset + TextUnit::from_usize(i + 1);\n+                    let next = Step::Newline(next_offset);\n+                    Some((next, next_offset))\n+                } else {\n+                    None\n+                    // TODO enable\n+                    // let char_len = TextUnit::of_char(c);\n+                    // if char_len.to_usize() > 1 {\n+                    //     let start = self.offset + TextUnit::from_usize(i);\n+                    //     let end = start + char_len;\n+                    //     let next = Step::Utf16Char(TextRange::from_to(start, end));\n+                    //     let next_offset = end;\n+                    //     Some((next, next_offset))\n+                    // } else {\n+                    //     None\n+                    // }\n+                }\n+            })\n             .next()?;\n-        let next = self.offset + TextUnit::from_usize(next_idx);\n+        let next_idx = (next_offset - self.offset).to_usize();\n         self.text = &self.text[next_idx..];\n-        self.offset = next;\n+        self.offset = next_offset;\n         Some(next)\n     }\n }\n@@ -83,12 +152,16 @@ impl<'a, 'b> Edits<'a, 'b> {\n         res\n     }\n \n-    fn next_newlines(&mut self, candidate: TextUnit) -> NextNewlines {\n+    fn next_step(&mut self, step: &Step) -> NextNewlines {\n+        let step_pos = match step {\n+            &Step::Newline(n) => n,\n+            &Step::Utf16Char(r) => unimplemented!(),\n+        };\n         let res = match &mut self.current {\n             Some(edit) => {\n-                if candidate <= edit.delete.start() {\n+                if step_pos <= edit.delete.start() {\n                     NextNewlines::Use\n-                } else if candidate <= edit.delete.end() {\n+                } else if step_pos <= edit.delete.end() {\n                     let iter = OffsetNewlineIter {\n                         offset: edit.delete.start(),\n                         text: &edit.insert,\n@@ -129,6 +202,17 @@ impl<'a, 'b> Edits<'a, 'b> {\n             TextUnit::from((x.to_usize() as i64 + self.acc_diff) as u32)\n         }\n     }\n+\n+    fn translate_step(&self, x: &Step) -> Step {\n+        if self.acc_diff == 0 {\n+            x.clone()\n+        } else {\n+            match x {\n+                &Step::Newline(n) => Step::Newline(self.translate(n)),\n+                &Step::Utf16Char(r) => Step::Utf16Char(self.translate_range(r)),\n+            }\n+        }\n+    }\n }\n \n pub fn count_newlines(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTextEdit]) -> u32 {\n@@ -143,33 +227,38 @@ pub fn count_newlines(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTex\n \n     let mut lines: u32 = 0;\n \n-    macro_rules! test_newline {\n+    macro_rules! test_step {\n         ($x:ident) => {\n-            if offset < $x {\n-                return lines;\n-            } else {\n-                lines += 1;\n+            match &$x {\n+                Step::Newline(n) => {\n+                    if offset < *n {\n+                        return lines;\n+                    } else {\n+                        lines += 1;\n+                    }\n+                }\n+                Step::Utf16Char(x) => unimplemented!(),\n             }\n         };\n     }\n \n-    for &orig_newline in line_index.newlines() {\n+    for orig_step in LineIndexStepIter::from(line_index) {\n         loop {\n-            let translated_newline = state.translate(orig_newline);\n-            match state.next_newlines(translated_newline) {\n+            let translated_newline = state.translate_step(&orig_step);\n+            match state.next_step(&translated_newline) {\n                 NextNewlines::Use => {\n-                    test_newline!(translated_newline);\n+                    test_step!(translated_newline);\n                     break;\n                 }\n                 NextNewlines::ReplaceMany(ns) => {\n                     for n in ns {\n-                        test_newline!(n);\n+                        test_step!(n);\n                     }\n                     break;\n                 }\n                 NextNewlines::AddMany(ns) => {\n                     for n in ns {\n-                        test_newline!(n);\n+                        test_step!(n);\n                     }\n                 }\n             }\n@@ -181,7 +270,7 @@ pub fn count_newlines(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTex\n             None => break,\n             Some(ns) => {\n                 for n in ns {\n-                    test_newline!(n);\n+                    test_step!(n);\n                 }\n             }\n         }"}]}