{"sha": "bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNmI1YTFhMzZjYjdiMTA1YmZmOGM0ZTI2MjliZjI4ZWNhODQ3MWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-08T17:10:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-08T17:10:52Z"}, "message": "Auto merge of #3854 - ljedrz:rustc_58992, r=phansch\n\nAlign with rust-lang/rust/#58992\n\nSome adjustments needed after the most recent round of HirIdification.", "tree": {"sha": "8fe15321268e43eeb074417ab7e1f01970985533", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fe15321268e43eeb074417ab7e1f01970985533"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "html_url": "https://github.com/rust-lang/rust/commit/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9702b3d2c0905b6975a0e6a9ce25c55f95eba65e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9702b3d2c0905b6975a0e6a9ce25c55f95eba65e", "html_url": "https://github.com/rust-lang/rust/commit/9702b3d2c0905b6975a0e6a9ce25c55f95eba65e"}, {"sha": "5d78250c75db3b1923072cf1be3b03f7d0cef5e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d78250c75db3b1923072cf1be3b03f7d0cef5e2", "html_url": "https://github.com/rust-lang/rust/commit/5d78250c75db3b1923072cf1be3b03f7d0cef5e2"}], "stats": {"total": 88, "additions": 42, "deletions": 46}, "files": [{"sha": "29ee6ae1fed32cbaa1a4eb3098d41372ce1371d7", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -182,7 +182,7 @@ fn get_type_name(cx: &LateContext<'_, '_>, kind: &ty::TyKind<'_>) -> String {\n \n fn compare_inputs(closure_inputs: &mut dyn Iterator<Item = &Arg>, call_args: &mut dyn Iterator<Item = &Expr>) -> bool {\n     for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n-        if let PatKind::Binding(_, _, _, ident, _) = closure_input.pat.node {\n+        if let PatKind::Binding(_, _, ident, _) = closure_input.pat.node {\n             // XXXManishearth Should I be checking the binding mode here?\n             if let ExprKind::Path(QPath::Resolved(None, ref p)) = function_arg.node {\n                 if p.segments.len() != 1 {"}, {"sha": "5378f7d455f7e651bda51b4f470137961f888ece", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -8,7 +8,6 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_target::spec::abi::Abi;\n-use syntax::ast;\n use syntax::source_map::Span;\n \n declare_clippy_lint! {\n@@ -278,8 +277,8 @@ impl<'a, 'tcx> Functions {\n     }\n }\n \n-fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<ast::NodeId> {\n-    if let (&hir::PatKind::Binding(_, id, _, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.node, &ty.node) {\n+fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<hir::HirId> {\n+    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.node, &ty.node) {\n         Some(id)\n     } else {\n         None\n@@ -288,7 +287,7 @@ fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<ast::NodeId> {\n \n struct DerefVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    ptrs: FxHashSet<ast::NodeId>,\n+    ptrs: FxHashSet<hir::HirId>,\n     tables: &'a ty::TypeckTables<'tcx>,\n }\n \n@@ -329,7 +328,7 @@ impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n         if let hir::ExprKind::Path(ref qpath) = ptr.node {\n             if let Def::Local(id) = self.cx.tables.qpath_def(qpath, ptr.hir_id) {\n-                if self.ptrs.contains(&id) {\n+                if self.ptrs.contains(&self.cx.tcx.hir().node_to_hir_id(id)) {\n                     span_lint(\n                         self.cx,\n                         NOT_UNSAFE_PTR_ARG_DEREF,"}, {"sha": "5ef3d8dd4abf101602edf3a7442f01f9f931e875", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -6,7 +6,6 @@ use rustc::hir::BindingAnnotation;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for variable declarations immediately followed by a\n@@ -73,7 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n             if_chain! {\n                 if let Some(expr) = it.peek();\n                 if let hir::StmtKind::Local(ref local) = stmt.node;\n-                if let hir::PatKind::Binding(mode, canonical_id, _, ident, None) = local.pat.node;\n+                if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.node;\n                 if let hir::StmtKind::Expr(ref if_) = expr.node;\n                 if let hir::ExprKind::If(ref cond, ref then, ref else_) = if_.node;\n                 if !used_in_expr(cx, canonical_id, cond);\n@@ -142,7 +141,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n \n struct UsedVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    id: ast::NodeId,\n+    id: hir::HirId,\n     used: bool,\n }\n \n@@ -151,7 +150,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n         if_chain! {\n             if let hir::ExprKind::Path(ref qpath) = expr.node;\n             if let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n-            if self.id == local_id;\n+            if self.id == self.cx.tcx.hir().node_to_hir_id(local_id);\n             then {\n                 self.used = true;\n                 return;\n@@ -166,7 +165,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n \n fn check_assign<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    decl: ast::NodeId,\n+    decl: hir::HirId,\n     block: &'tcx hir::Block,\n ) -> Option<&'tcx hir::Expr> {\n     if_chain! {\n@@ -176,7 +175,7 @@ fn check_assign<'a, 'tcx>(\n         if let hir::ExprKind::Assign(ref var, ref value) = expr.node;\n         if let hir::ExprKind::Path(ref qpath) = var.node;\n         if let Def::Local(local_id) = cx.tables.qpath_def(qpath, var.hir_id);\n-        if decl == local_id;\n+        if decl == cx.tcx.hir().node_to_hir_id(local_id);\n         then {\n             let mut v = UsedVisitor {\n                 cx,\n@@ -199,7 +198,7 @@ fn check_assign<'a, 'tcx>(\n     None\n }\n \n-fn used_in_expr<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, id: ast::NodeId, expr: &'tcx hir::Expr) -> bool {\n+fn used_in_expr<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, id: hir::HirId, expr: &'tcx hir::Expr) -> bool {\n     let mut v = UsedVisitor { cx, id, used: false };\n     hir::intravisit::walk_expr(&mut v, expr);\n     v.used"}, {"sha": "bd7950318054d5ea962fe2861d8c1176d55af1f7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -272,7 +272,7 @@ pub mod zero_div_zero;\n pub use crate::utils::conf::Conf;\n \n mod reexport {\n-    crate use syntax::ast::{Name, NodeId};\n+    crate use syntax::ast::Name;\n }\n \n /// Register all pre expansion lints"}, {"sha": "9fe6504bd421ec6b96c2a02d2dd350728c2c4c17", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -486,8 +486,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         // check for never_loop\n         match expr.node {\n             ExprKind::While(_, ref block, _) | ExprKind::Loop(ref block, _, _) => {\n-                let node_id = cx.tcx.hir().hir_to_node_id(expr.hir_id);\n-                match never_loop_block(block, node_id) {\n+                match never_loop_block(block, expr.hir_id) {\n                     NeverLoopResult::AlwaysBreak => {\n                         span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\")\n                     },\n@@ -664,7 +663,7 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n     }\n }\n \n-fn never_loop_block(block: &Block, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_block(block: &Block, main_loop_id: HirId) -> NeverLoopResult {\n     let stmts = block.stmts.iter().map(stmt_to_expr);\n     let expr = once(block.expr.as_ref().map(|p| &**p));\n     let mut iter = stmts.chain(expr).filter_map(|e| e);\n@@ -679,7 +678,7 @@ fn stmt_to_expr(stmt: &Stmt) -> Option<&Expr> {\n     }\n }\n \n-fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr(expr: &Expr, main_loop_id: HirId) -> NeverLoopResult {\n     match expr.node {\n         ExprKind::Box(ref e)\n         | ExprKind::Unary(_, ref e)\n@@ -753,17 +752,17 @@ fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n     }\n }\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_seq)\n }\n \n-fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_both)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr>>(e: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n     e.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n@@ -784,14 +783,14 @@ fn check_for_loop<'a, 'tcx>(\n     detect_manual_memcpy(cx, pat, arg, body, expr);\n }\n \n-fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> bool {\n+fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: HirId) -> bool {\n     if_chain! {\n         if let ExprKind::Path(ref qpath) = expr.node;\n         if let QPath::Resolved(None, ref path) = *qpath;\n         if path.segments.len() == 1;\n         if let Def::Local(local_id) = cx.tables.qpath_def(qpath, expr.hir_id);\n         // our variable!\n-        if local_id == var;\n+        if cx.tcx.hir().node_to_hir_id(local_id) == var;\n         then {\n             return true;\n         }\n@@ -833,8 +832,8 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n     is_slice || match_type(cx, ty, &paths::VEC) || match_type(cx, ty, &paths::VEC_DEQUE)\n }\n \n-fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> Option<FixedOffsetVar> {\n-    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: ast::NodeId) -> Option<String> {\n+fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: HirId) -> Option<FixedOffsetVar> {\n+    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: HirId) -> Option<String> {\n         match e.node {\n             ExprKind::Lit(ref l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n@@ -889,7 +888,7 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     expr: &Expr,\n-    var: ast::NodeId,\n+    var: HirId,\n ) -> Option<FixedOffsetVar> {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args) = expr.node;\n@@ -907,12 +906,12 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n fn get_indexed_assignments<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     body: &Expr,\n-    var: ast::NodeId,\n+    var: HirId,\n ) -> Vec<(FixedOffsetVar, FixedOffsetVar)> {\n     fn get_assignment<'a, 'tcx>(\n         cx: &LateContext<'a, 'tcx>,\n         e: &Expr,\n-        var: ast::NodeId,\n+        var: HirId,\n     ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n         if let ExprKind::Assign(ref lhs, ref rhs) = e.node {\n             match (\n@@ -970,7 +969,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n     }) = higher::range(cx, arg)\n     {\n         // the var must be a single name\n-        if let PatKind::Binding(_, canonical_id, _, _, _) = pat.node {\n+        if let PatKind::Binding(_, canonical_id, _, _) = pat.node {\n             let print_sum = |arg1: &Offset, arg2: &Offset| -> String {\n                 match (&arg1.value[..], arg1.negate, &arg2.value[..], arg2.negate) {\n                     (\"0\", _, \"0\", _) => \"\".into(),\n@@ -1087,7 +1086,7 @@ fn check_for_loop_range<'a, 'tcx>(\n     }) = higher::range(cx, arg)\n     {\n         // the var must be a single name\n-        if let PatKind::Binding(_, canonical_id, _, ident, _) = pat.node {\n+        if let PatKind::Binding(_, canonical_id, ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n                 cx,\n                 var: canonical_id,\n@@ -1711,7 +1710,7 @@ impl<'tcx> Visitor<'tcx> for UsedVisitor {\n \n struct LocalUsedVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    local: ast::NodeId,\n+    local: HirId,\n     used: bool,\n }\n \n@@ -1733,7 +1732,7 @@ struct VarVisitor<'a, 'tcx: 'a> {\n     /// context reference\n     cx: &'a LateContext<'a, 'tcx>,\n     /// var name to look for as index\n-    var: ast::NodeId,\n+    var: HirId,\n     /// indexed variables that are used mutably\n     indexed_mut: FxHashSet<Name>,\n     /// indirectly indexed variables (`v[(i + 4) % N]`), the extend is `None` for global\n@@ -1841,15 +1840,15 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             then {\n                 match self.cx.tables.qpath_def(qpath, expr.hir_id) {\n                     Def::Upvar(local_id, ..) => {\n-                        if local_id == self.var {\n+                        if self.cx.tcx.hir().node_to_hir_id(local_id) == self.var {\n                             // we are not indexing anything, record that\n                             self.nonindex = true;\n                         }\n                     }\n                     Def::Local(local_id) =>\n                     {\n \n-                        if local_id == self.var {\n+                        if self.cx.tcx.hir().node_to_hir_id(local_id) == self.var {\n                             self.nonindex = true;\n                         } else {\n                             // not the correct variable, but still a variable"}, {"sha": "580d22845b0fee4962bd2b3cd8c9b71f1a0fd111", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -482,7 +482,7 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n         for pat in &arm.pats {\n             if let PatKind::Wild = pat.node {\n                 wildcard_span = Some(pat.span);\n-            } else if let PatKind::Binding(_, _, _, ident, None) = pat.node {\n+            } else if let PatKind::Binding(_, _, ident, None) = pat.node {\n                 wildcard_span = Some(pat.span);\n                 wildcard_ident = Some(ident);\n             }"}, {"sha": "87bf3b5485fb49952d2c08554e2e55fb1001c82d", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -115,7 +115,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n                                 // trait method with default body needs inline in case\n                                 // an impl is not provided\n                                 let desc = \"a default trait method\";\n-                                let item = cx.tcx.hir().expect_trait_item_by_hir_id(tit.id.hir_id);\n+                                let item = cx.tcx.hir().expect_trait_item(tit.id.hir_id);\n                                 check_missing_inline_attrs(cx, &item.attrs, item.span, desc);\n                             }\n                         },"}, {"sha": "a3748d87a83c96bbf8ca58b8faf142283545fcf4", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;\n \n-                if let PatKind::Binding(mode, _, canonical_id, ..) = arg.pat.node;\n+                if let PatKind::Binding(mode, canonical_id, ..) = arg.pat.node;\n                 if !moved_vars.contains(&canonical_id);\n                 then {\n                     if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {"}, {"sha": "bf31b774bba24fd66c9f50c5de431805a3253f65", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n         };\n \n         match expr.node {\n-            hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n+            hir::ExprKind::Match(ref res, _, _) if is_try(cx, expr).is_some() => {\n                 if let hir::ExprKind::Call(ref func, ref args) = res.node {\n                     if let hir::ExprKind::Path(ref path) = func.node {\n                         if match_qpath(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {"}, {"sha": "343098ceeeea4d8bbf471f35f808ffa26d2682e7", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -164,8 +164,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n                         output: &mut self.registered_lints,\n                         cx,\n                     };\n-                    let node_id = cx.tcx.hir().hir_to_node_id(impl_item_refs[0].id.hir_id);\n-                    let body_id = cx.tcx.hir().body_owned_by(node_id);\n+                    let body_id = cx.tcx.hir().body_owned_by(impl_item_refs[0].id.hir_id);\n                     collector.visit_expr(&cx.tcx.hir().body(body_id).value);\n                 }\n             }"}, {"sha": "f6b9a77a573fc75b6f0ad0eeaeabd6447839563b", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=bd6b5a1a36cb7b105bff8c4e2629bf28eca8471e", "patch": "@@ -829,15 +829,15 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<I\n \n /// Check if a given expression is a match expression\n /// expanded from `?` operator or `try` macro.\n-pub fn is_try(expr: &Expr) -> Option<&Expr> {\n-    fn is_ok(arm: &Arm) -> bool {\n+pub fn is_try<'a>(cx: &'_ LateContext<'_, '_>, expr: &'a Expr) -> Option<&'a Expr> {\n+    fn is_ok(cx: &'_ LateContext<'_, '_>, arm: &Arm) -> bool {\n         if_chain! {\n             if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pats[0].node;\n             if match_qpath(path, &paths::RESULT_OK[1..]);\n-            if let PatKind::Binding(_, defid, _, _, None) = pat[0].node;\n+            if let PatKind::Binding(_, hir_id, _, None) = pat[0].node;\n             if let ExprKind::Path(QPath::Resolved(None, ref path)) = arm.body.node;\n             if let Def::Local(lid) = path.def;\n-            if lid == defid;\n+            if cx.tcx.hir().node_to_hir_id(lid) == hir_id;\n             then {\n                 return true;\n             }\n@@ -863,8 +863,8 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n             if arms.len() == 2;\n             if arms[0].pats.len() == 1 && arms[0].guard.is_none();\n             if arms[1].pats.len() == 1 && arms[1].guard.is_none();\n-            if (is_ok(&arms[0]) && is_err(&arms[1])) ||\n-                (is_ok(&arms[1]) && is_err(&arms[0]));\n+            if (is_ok(cx, &arms[0]) && is_err(&arms[1])) ||\n+                (is_ok(cx, &arms[1]) && is_err(&arms[0]));\n             then {\n                 return Some(expr);\n             }"}]}