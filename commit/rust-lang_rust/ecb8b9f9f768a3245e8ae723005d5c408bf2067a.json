{"sha": "ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYjhiOWY5Zjc2OGEzMjQ1ZThhZTcyMzAwNWQ1YzQwOGJmMjA2N2E=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-05-27T05:05:09Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-06-24T04:48:33Z"}, "message": "Update Chalk", "tree": {"sha": "5fca60767dd3a1f86a0da94ac103c20c79a7113a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fca60767dd3a1f86a0da94ac103c20c79a7113a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "html_url": "https://github.com/rust-lang/rust/commit/ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6", "html_url": "https://github.com/rust-lang/rust/commit/0c04344d86f9598f20d9ec86fe87ea2a5d6ff8e6"}], "stats": {"total": 418, "additions": 311, "deletions": 107}, "files": [{"sha": "e0d092ec76a7806b54c9a398656df3b228f7e0f4", "filename": "Cargo.lock", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -434,9 +434,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.11.0\"\n+version = \"0.14.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5b9bd01eab87277d973183a1d2e56bace1c11f8242c52c20636fb7dddf343ac9\"\n+checksum = \"d463e01905d607e181de72e8608721d3269f29176c9a14ce037011316ae7131d\"\n dependencies = [\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n@@ -446,30 +446,31 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.11.0\"\n+version = \"0.14.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6c7a637c3d17ed555aef16e16952a5d1e127bd55178cc30be22afeb92da90c7d\"\n+checksum = \"efaf428f5398d36284f79690cf988762b7c091249f50a6c11db613a46c057000\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n  \"rustc-hash\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.11.0\"\n+version = \"0.14.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"595e5735ded16c3f3dc348f7b15bbb2521a0080b1863cac38ad5271589944670\"\n+checksum = \"fd3fdc1e9f68498ffe80f4a23b0b95f1ca6fb21d5a4c9b0c085fab3ca712bdbe\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.11.0\"\n+version = \"0.14.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5d9d938139db425867a30cc0cfec0269406d8238d0571d829041eaa7a8455d11\"\n+checksum = \"5b9fd4102807b7ebe8fb034fa0f488c5656e1966d3261b558b81a08d519cdb29\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -478,6 +479,7 @@ dependencies = [\n  \"itertools 0.9.0\",\n  \"petgraph\",\n  \"rustc-hash\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -5332,6 +5334,37 @@ dependencies = [\n  \"syn 0.15.35\",\n ]\n \n+[[package]]\n+name = \"tracing\"\n+version = \"0.1.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a41f40ed0e162c911ac6fcb53ecdc8134c46905fdbbae8c50add462a538b495f\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"tracing-attributes\",\n+ \"tracing-core\",\n+]\n+\n+[[package]]\n+name = \"tracing-attributes\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"99bbad0de3fd923c9c3232ead88510b783e5a4d16a6154adffa3d53308de984c\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n+]\n+\n+[[package]]\n+name = \"tracing-core\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0aa83a9a47081cd522c09c81b31aec2c9273424976f922ad61c053b58350b715\"\n+dependencies = [\n+ \"lazy_static\",\n+]\n+\n [[package]]\n name = \"try-lock\"\n version = \"0.2.2\""}, {"sha": "02d82c6793386ab8b3ba7fa1fc9ca72bea49219a", "filename": "src/librustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2FCargo.toml?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -30,7 +30,7 @@ rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n byteorder = { version = \"1.3\" }\n-chalk-ir = \"0.11.0\"\n+chalk-ir = \"0.14.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.7.1\"\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "405af8cb2406c12891fbafa3730a70e7d3bc4458", "filename": "src/librustc_middle/traits/chalk.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -10,6 +10,7 @@ use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n+use rustc_target::spec::abi::Abi;\n \n use smallvec::SmallVec;\n \n@@ -77,6 +78,7 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n     type DefId = DefId;\n     type InternedAdtId = &'tcx AdtDef;\n     type Identifier = ();\n+    type FnAbi = Abi;\n \n     fn debug_program_clause_implication(\n         pci: &chalk_ir::ProgramClauseImplication<Self>,"}, {"sha": "2ade48927526215ac45c883b53aa41833643dbbb", "filename": "src/librustc_trait_selection/traits/chalk_fulfill.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -7,17 +7,17 @@ use crate::traits::{\n     ChalkEnvironmentAndGoal, ChalkEnvironmentClause, FulfillmentError, FulfillmentErrorCode,\n     ObligationCause, PredicateObligation, SelectionError, TraitEngine,\n };\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub struct FulfillmentContext<'tcx> {\n-    obligations: FxHashSet<PredicateObligation<'tcx>>,\n+    obligations: FxIndexSet<PredicateObligation<'tcx>>,\n }\n \n impl FulfillmentContext<'tcx> {\n     crate fn new() -> Self {\n-        FulfillmentContext { obligations: FxHashSet::default() }\n+        FulfillmentContext { obligations: FxIndexSet::default() }\n     }\n }\n \n@@ -79,7 +79,7 @@ fn environment<'tcx>(\n     };\n \n     // FIXME(eddyb) isn't the unordered nature of this a hazard?\n-    let mut inputs = FxHashSet::default();\n+    let mut inputs = FxIndexSet::default();\n \n     match node_kind {\n         // In a trait impl, we assume that the header trait ref and all its\n@@ -140,7 +140,8 @@ fn in_environment(\n         None if obligation.param_env.caller_bounds.is_empty() => ty::List::empty(),\n         // FIXME(chalk): this is hit in ui/where-clauses/where-clause-constraints-are-local-for-trait-impl\n         // and ui/generics/generic-static-methods\n-        _ => bug!(\"non-empty `ParamEnv` with no def-id\"),\n+        //_ => bug!(\"non-empty `ParamEnv` with no def-id\"),\n+        _ => ty::List::empty(),\n     };\n \n     ChalkEnvironmentAndGoal { environment, goal: obligation.predicate }\n@@ -195,15 +196,15 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n         let mut errors = Vec::new();\n-        let mut next_round = FxHashSet::default();\n+        let mut next_round = FxIndexSet::default();\n         let mut making_progress;\n \n         loop {\n             making_progress = false;\n \n             // We iterate over all obligations, and record if we are able\n             // to unambiguously prove at least one obligation.\n-            for obligation in self.obligations.drain() {\n+            for obligation in self.obligations.drain(..) {\n                 let goal_in_environment = in_environment(infcx, &obligation);\n                 let mut orig_values = OriginalQueryValues::default();\n                 let canonical_goal ="}, {"sha": "079b9b10fd0901162a3745fd58f8ae3ecaf0dd0b", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -16,8 +16,8 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n-chalk-ir = \"0.11.0\"\n-chalk-solve = \"0.11.0\"\n+chalk-ir = \"0.14.0\"\n+chalk-solve = \"0.14.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../librustc_infer\" }\n rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "715e5299a37bda7ec2e9e83595276e8190061969", "filename": "src/librustc_traits/chalk/db.rs", "status": "modified", "additions": 146, "deletions": 34, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fdb.rs?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -8,7 +8,7 @@\n \n use rustc_middle::traits::ChalkRustInterner as RustInterner;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, AssocItemContainer, AssocKind, Binder, TyCtxt};\n+use rustc_middle::ty::{self, AssocItemContainer, AssocKind, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n \n@@ -85,14 +85,29 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             .iter()\n             .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+        let associated_ty_ids: Vec<_> = self\n+            .tcx\n+            .associated_items(def_id)\n+            .in_definition_order()\n+            .filter(|i| i.kind == AssocKind::Type)\n+            .map(|i| chalk_ir::AssocTypeId(i.def_id))\n+            .collect();\n \n         let well_known =\n             if self.tcx.lang_items().sized_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::SizedTrait)\n+                Some(chalk_solve::rust_ir::WellKnownTrait::Sized)\n             } else if self.tcx.lang_items().copy_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::CopyTrait)\n+                Some(chalk_solve::rust_ir::WellKnownTrait::Copy)\n             } else if self.tcx.lang_items().clone_trait().map(|t| def_id == t).unwrap_or(false) {\n-                Some(chalk_solve::rust_ir::WellKnownTrait::CloneTrait)\n+                Some(chalk_solve::rust_ir::WellKnownTrait::Clone)\n+            } else if self.tcx.lang_items().drop_trait().map(|t| def_id == t).unwrap_or(false) {\n+                Some(chalk_solve::rust_ir::WellKnownTrait::Drop)\n+            } else if self.tcx.lang_items().fn_trait().map(|t| def_id == t).unwrap_or(false) {\n+                Some(chalk_solve::rust_ir::WellKnownTrait::Fn)\n+            } else if self.tcx.lang_items().fn_once_trait().map(|t| def_id == t).unwrap_or(false) {\n+                Some(chalk_solve::rust_ir::WellKnownTrait::FnOnce)\n+            } else if self.tcx.lang_items().fn_mut_trait().map(|t| def_id == t).unwrap_or(false) {\n+                Some(chalk_solve::rust_ir::WellKnownTrait::FnMut)\n             } else {\n                 None\n             };\n@@ -110,7 +125,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 non_enumerable: true,\n                 coinductive: false,\n             },\n-            associated_ty_ids: vec![],\n+            associated_ty_ids,\n             well_known,\n         })\n     }\n@@ -156,6 +171,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             flags: chalk_solve::rust_ir::AdtFlags {\n                 upstream: !adt_def.did.is_local(),\n                 fundamental: adt_def.is_fundamental(),\n+                phantom_data: adt_def.is_phantom_data(),\n             },\n         });\n         return struct_datum;\n@@ -176,28 +192,32 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n \n         let sig = self.tcx.fn_sig(def_id);\n-        // FIXME(chalk): collect into an intermediate SmallVec here since\n-        // we need `TypeFoldable` for `no_bound_vars`\n-        let argument_types: Binder<Vec<_>> =\n-            sig.map_bound(|i| i.inputs().iter().copied().collect());\n-        let argument_types = argument_types\n-            .no_bound_vars()\n-            .expect(\"FIXME(chalk): late-bound fn parameters not supported in chalk\")\n+        let inputs_and_output = sig.inputs_and_output();\n+        let (inputs_and_output, iobinders, _) = crate::chalk::lowering::collect_bound_vars(\n+            &self.interner,\n+            self.tcx,\n+            &inputs_and_output,\n+        );\n+\n+        let argument_types = inputs_and_output[..inputs_and_output.len() - 1]\n             .iter()\n             .map(|t| t.subst(self.tcx, &bound_vars).lower_into(&self.interner))\n             .collect();\n \n-        let return_type = sig\n-            .output()\n-            .no_bound_vars()\n-            .expect(\"FIXME(chalk): late-bound fn parameters not supported in chalk\")\n+        let return_type = inputs_and_output[inputs_and_output.len() - 1]\n             .subst(self.tcx, &bound_vars)\n             .lower_into(&self.interner);\n \n-        let bound =\n-            chalk_solve::rust_ir::FnDefDatumBound { argument_types, where_clauses, return_type };\n+        let bound = chalk_solve::rust_ir::FnDefDatumBound {\n+            inputs_and_output: chalk_ir::Binders::new(\n+                iobinders,\n+                chalk_solve::rust_ir::FnDefInputsAndOutputDatum { argument_types, return_type },\n+            ),\n+            where_clauses,\n+        };\n         Arc::new(chalk_solve::rust_ir::FnDefDatum {\n             id: fn_def_id,\n+            abi: sig.abi(),\n             binders: chalk_ir::Binders::new(binders, bound),\n         })\n     }\n@@ -326,9 +346,16 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         &self,\n         opaque_ty_id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n-        // FIXME(chalk): actually lower opaque ty\n+        let bound_vars = bound_vars_for_item(self.tcx, opaque_ty_id.0);\n+        let binders = binders_for(&self.interner, bound_vars);\n+        let predicates = self.tcx.predicates_defined_on(opaque_ty_id.0).predicates;\n+        let where_clauses: Vec<_> = predicates\n+            .iter()\n+            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+\n         let value = chalk_solve::rust_ir::OpaqueTyDatumBound {\n-            bounds: chalk_ir::Binders::new(chalk_ir::VariableKinds::new(&self.interner), vec![]),\n+            bounds: chalk_ir::Binders::new(binders, where_clauses),\n         };\n         Arc::new(chalk_solve::rust_ir::OpaqueTyDatum {\n             opaque_ty_id,\n@@ -346,7 +373,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Option<bool> {\n         use chalk_ir::TyData::*;\n         match well_known {\n-            chalk_solve::rust_ir::WellKnownTrait::SizedTrait => match ty {\n+            chalk_solve::rust_ir::WellKnownTrait::Sized => match ty {\n                 Apply(apply) => match apply.name {\n                     chalk_ir::TypeName::Adt(chalk_ir::AdtId(adt_def)) => match adt_def.adt_kind() {\n                         ty::AdtKind::Struct | ty::AdtKind::Union => None,\n@@ -364,8 +391,8 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 | InferenceVar(_, _)\n                 | BoundVar(_) => None,\n             },\n-            chalk_solve::rust_ir::WellKnownTrait::CopyTrait\n-            | chalk_solve::rust_ir::WellKnownTrait::CloneTrait => match ty {\n+            chalk_solve::rust_ir::WellKnownTrait::Copy\n+            | chalk_solve::rust_ir::WellKnownTrait::Clone => match ty {\n                 Apply(apply) => match apply.name {\n                     chalk_ir::TypeName::Adt(chalk_ir::AdtId(adt_def)) => match adt_def.adt_kind() {\n                         ty::AdtKind::Struct | ty::AdtKind::Union => None,\n@@ -383,7 +410,11 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 | InferenceVar(_, _)\n                 | BoundVar(_) => None,\n             },\n-            chalk_solve::rust_ir::WellKnownTrait::DropTrait => None,\n+            chalk_solve::rust_ir::WellKnownTrait::Drop => None,\n+            chalk_solve::rust_ir::WellKnownTrait::Fn => None,\n+            chalk_solve::rust_ir::WellKnownTrait::FnMut => None,\n+            chalk_solve::rust_ir::WellKnownTrait::FnOnce => None,\n+            chalk_solve::rust_ir::WellKnownTrait::Unsize => None,\n         }\n     }\n \n@@ -399,17 +430,17 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         well_known_trait: chalk_solve::rust_ir::WellKnownTrait,\n     ) -> Option<chalk_ir::TraitId<RustInterner<'tcx>>> {\n         use chalk_solve::rust_ir::WellKnownTrait::*;\n-        let t = match well_known_trait {\n-            SizedTrait => {\n-                self.tcx.lang_items().sized_trait().map(|t| chalk_ir::TraitId(t)).unwrap()\n-            }\n-            CopyTrait => self.tcx.lang_items().copy_trait().map(|t| chalk_ir::TraitId(t)).unwrap(),\n-            CloneTrait => {\n-                self.tcx.lang_items().clone_trait().map(|t| chalk_ir::TraitId(t)).unwrap()\n-            }\n-            DropTrait => self.tcx.lang_items().drop_trait().map(|t| chalk_ir::TraitId(t)).unwrap(),\n+        let def_id = match well_known_trait {\n+            Sized => self.tcx.lang_items().sized_trait(),\n+            Copy => self.tcx.lang_items().copy_trait(),\n+            Clone => self.tcx.lang_items().clone_trait(),\n+            Drop => self.tcx.lang_items().drop_trait(),\n+            Fn => self.tcx.lang_items().fn_trait(),\n+            FnMut => self.tcx.lang_items().fn_mut_trait(),\n+            FnOnce => self.tcx.lang_items().fn_once_trait(),\n+            Unsize => self.tcx.lang_items().unsize_trait(),\n         };\n-        Some(t)\n+        def_id.map(|t| chalk_ir::TraitId(t))\n     }\n \n     fn is_object_safe(&self, trait_id: chalk_ir::TraitId<RustInterner<'tcx>>) -> bool {\n@@ -423,6 +454,87 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         // FIXME(chalk): actually get hidden ty\n         self.tcx.mk_ty(ty::Tuple(self.tcx.intern_substs(&[]))).lower_into(&self.interner)\n     }\n+\n+    fn closure_kind(\n+        &self,\n+        _closure_id: chalk_ir::ClosureId<RustInterner<'tcx>>,\n+        substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n+    ) -> chalk_solve::rust_ir::ClosureKind {\n+        let kind = &substs.parameters(&self.interner)[substs.len(&self.interner) - 3];\n+        match kind.assert_ty_ref(&self.interner).data(&self.interner) {\n+            chalk_ir::TyData::Apply(apply) => match apply.name {\n+                chalk_ir::TypeName::Scalar(scalar) => match scalar {\n+                    chalk_ir::Scalar::Int(int_ty) => match int_ty {\n+                        chalk_ir::IntTy::I8 => chalk_solve::rust_ir::ClosureKind::Fn,\n+                        chalk_ir::IntTy::I16 => chalk_solve::rust_ir::ClosureKind::FnMut,\n+                        chalk_ir::IntTy::I32 => chalk_solve::rust_ir::ClosureKind::FnOnce,\n+                        _ => bug!(\"bad closure kind\"),\n+                    },\n+                    _ => bug!(\"bad closure kind\"),\n+                },\n+                _ => bug!(\"bad closure kind\"),\n+            },\n+            _ => bug!(\"bad closure kind\"),\n+        }\n+    }\n+\n+    fn closure_inputs_and_output(\n+        &self,\n+        _closure_id: chalk_ir::ClosureId<RustInterner<'tcx>>,\n+        substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n+    ) -> chalk_ir::Binders<chalk_solve::rust_ir::FnDefInputsAndOutputDatum<RustInterner<'tcx>>>\n+    {\n+        let sig = &substs.parameters(&self.interner)[substs.len(&self.interner) - 2];\n+        match sig.assert_ty_ref(&self.interner).data(&self.interner) {\n+            chalk_ir::TyData::Function(f) => {\n+                let substitution = f.substitution.parameters(&self.interner);\n+                let return_type =\n+                    substitution.last().unwrap().assert_ty_ref(&self.interner).clone();\n+                // Closure arguments are tupled\n+                let argument_tuple = substitution[0].assert_ty_ref(&self.interner);\n+                let argument_types = match argument_tuple.data(&self.interner) {\n+                    chalk_ir::TyData::Apply(apply) => match apply.name {\n+                        chalk_ir::TypeName::Tuple(_) => apply\n+                            .substitution\n+                            .iter(&self.interner)\n+                            .map(|arg| arg.assert_ty_ref(&self.interner))\n+                            .cloned()\n+                            .collect(),\n+                        _ => bug!(\"Expecting closure FnSig args to be tupled.\"),\n+                    },\n+                    _ => bug!(\"Expecting closure FnSig args to be tupled.\"),\n+                };\n+\n+                chalk_ir::Binders::new(\n+                    chalk_ir::VariableKinds::from(\n+                        &self.interner,\n+                        (0..f.num_binders).map(|_| chalk_ir::VariableKind::Lifetime),\n+                    ),\n+                    chalk_solve::rust_ir::FnDefInputsAndOutputDatum { argument_types, return_type },\n+                )\n+            }\n+            _ => panic!(\"Invalid sig.\"),\n+        }\n+    }\n+\n+    fn closure_upvars(\n+        &self,\n+        _closure_id: chalk_ir::ClosureId<RustInterner<'tcx>>,\n+        substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n+    ) -> chalk_ir::Binders<chalk_ir::Ty<RustInterner<'tcx>>> {\n+        let inputs_and_output = self.closure_inputs_and_output(_closure_id, substs);\n+        let tuple = substs.parameters(&self.interner).last().unwrap().assert_ty_ref(&self.interner);\n+        inputs_and_output.map_ref(|_| tuple.clone())\n+    }\n+\n+    fn closure_fn_substitution(\n+        &self,\n+        _closure_id: chalk_ir::ClosureId<RustInterner<'tcx>>,\n+        substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n+    ) -> chalk_ir::Substitution<RustInterner<'tcx>> {\n+        let substitution = &substs.parameters(&self.interner)[0..substs.len(&self.interner) - 3];\n+        chalk_ir::Substitution::from(&self.interner, substitution)\n+    }\n }\n \n /// Creates a `InternalSubsts` that maps each generic parameter to a higher-ranked"}, {"sha": "e09359b8b3fc13ba6d02e1d1b8dafedc80fa89f2", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -43,6 +43,8 @@ use rustc_span::def_id::DefId;\n \n use std::collections::btree_map::{BTreeMap, Entry};\n \n+use chalk_ir::fold::shift::Shift;\n+\n /// Essentially an `Into` with a `&RustInterner` parameter\n crate trait LowerInto<'tcx, T> {\n     /// Lower a rustc construct (e.g., `ty::TraitPredicate`) to a chalk type, consuming `self`.\n@@ -82,7 +84,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             collect_bound_vars(interner, interner.tcx, predicate);\n \n                         Some(\n-                            chalk_ir::ProgramClauseData::ForAll(chalk_ir::Binders::new(\n+                            chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n                                 binders,\n                                 chalk_ir::ProgramClauseImplication {\n                                     consequence: chalk_ir::DomainGoal::FromEnv(\n@@ -102,7 +104,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             collect_bound_vars(interner, interner.tcx, predicate);\n \n                         Some(\n-                            chalk_ir::ProgramClauseData::ForAll(chalk_ir::Binders::new(\n+                            chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n                                 binders,\n                                 chalk_ir::ProgramClauseImplication {\n                                     consequence: chalk_ir::DomainGoal::Holds(\n@@ -127,7 +129,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             collect_bound_vars(interner, interner.tcx, predicate);\n \n                         Some(\n-                            chalk_ir::ProgramClauseData::ForAll(chalk_ir::Binders::new(\n+                            chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n                                 binders,\n                                 chalk_ir::ProgramClauseImplication {\n                                     consequence: chalk_ir::DomainGoal::Holds(\n@@ -153,13 +155,16 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 }\n             }\n             ChalkEnvironmentClause::TypeFromEnv(ty) => Some(\n-                chalk_ir::ProgramClauseData::Implies(chalk_ir::ProgramClauseImplication {\n-                    consequence: chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(\n-                        ty.lower_into(interner),\n-                    )),\n-                    conditions: chalk_ir::Goals::new(interner),\n-                    priority: chalk_ir::ClausePriority::High,\n-                })\n+                chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n+                    chalk_ir::VariableKinds::new(interner),\n+                    chalk_ir::ProgramClauseImplication {\n+                        consequence: chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(\n+                            ty.lower_into(interner).shifted_in(interner),\n+                        )),\n+                        conditions: chalk_ir::Goals::new(interner),\n+                        priority: chalk_ir::ClausePriority::High,\n+                    },\n+                ))\n                 .intern(interner),\n             ),\n         });\n@@ -416,12 +421,15 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                 })\n                 .intern(interner)\n             }\n-            // FIXME(chalk): add region\n-            Dynamic(predicates, _region) => {\n-                TyData::Dyn(chalk_ir::DynTy { bounds: predicates.lower_into(interner) })\n-                    .intern(interner)\n-            }\n-            Closure(_def_id, _) => unimplemented!(),\n+            Dynamic(predicates, region) => TyData::Dyn(chalk_ir::DynTy {\n+                bounds: predicates.lower_into(interner),\n+                lifetime: region.lower_into(interner),\n+            })\n+            .intern(interner),\n+            Closure(def_id, substs) => apply(\n+                chalk_ir::TypeName::Closure(chalk_ir::ClosureId(def_id)),\n+                substs.lower_into(interner),\n+            ),\n             Generator(_def_id, _substs, _) => unimplemented!(),\n             GeneratorWitness(_) => unimplemented!(),\n             Never => apply(chalk_ir::TypeName::Never, empty()),\n@@ -624,7 +632,7 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n     }\n \n     (0..parameters.len()).for_each(|i| {\n-        parameters.get(&(i as u32)).expect(\"Skipped bound var index.\");\n+        parameters.get(&(i as u32)).expect(&format!(\"Skipped bound var index `{:?}`.\", i));\n     });\n \n     let binders = chalk_ir::VariableKinds::from(interner, parameters.into_iter().map(|(_, v)| v));"}, {"sha": "52ec0f2409dce47acb64cec990cafa8a7bf72e95", "filename": "src/librustc_traits/chalk/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_traits%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Flibrustc_traits%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fmod.rs?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -133,6 +133,7 @@ crate fn evaluate_goal<'tcx>(\n                             },\n                             chalk_ir::TypeName::Array => unimplemented!(),\n                             chalk_ir::TypeName::FnDef(_) => unimplemented!(),\n+                            chalk_ir::TypeName::Closure(_) => unimplemented!(),\n                             chalk_ir::TypeName::Never => unimplemented!(),\n                             chalk_ir::TypeName::Tuple(_size) => unimplemented!(),\n                             chalk_ir::TypeName::Slice => unimplemented!(),"}, {"sha": "81114d491d78ebaab04bb300b65ef4cda22f0784", "filename": "src/test/ui/chalkify/closure.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fclosure.rs?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -0,0 +1,39 @@\n+// check-fail\n+// compile-flags: -Z chalk\n+\n+fn main() -> () {\n+    let t = || {};\n+    t();\n+\n+    let mut a = 0;\n+    let mut b = move || {\n+        a = 1;\n+    };\n+    b();\n+\n+    let mut c = b;\n+\n+    c();\n+    b();\n+\n+    let mut a = 0;\n+    let mut b = || {\n+        a = 1;\n+    };\n+    b();\n+\n+    let mut c = b;\n+\n+    c();\n+    b(); //~ ERROR\n+\n+    // FIXME(chalk): this doesn't quite work\n+    /*\n+    let b = |c| {\n+        c\n+    };\n+\n+    let a = &32;\n+    b(a);\n+    */\n+}"}, {"sha": "d5a48a7dc6f950266ba5262d67d1090a79c664c0", "filename": "src/test/ui/chalkify/closure.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Fclosure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Fclosure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fclosure.stderr?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -0,0 +1,18 @@\n+error[E0382]: borrow of moved value: `b`\n+  --> $DIR/closure.rs:28:5\n+   |\n+LL |     let mut c = b;\n+   |                 - value moved here\n+...\n+LL |     b();\n+   |     ^ value borrowed here after move\n+   |\n+note: closure cannot be moved more than once as it is not `Copy` due to moving the variable `a` out of its environment\n+  --> $DIR/closure.rs:21:9\n+   |\n+LL |         a = 1;\n+   |         ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "465eb10241ea20d9e38962bdc3474a094f3b9f84", "filename": "src/test/ui/chalkify/impl_wf.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -23,15 +23,10 @@ impl<T> Bar for Option<T> {\n     type Item = Option<T>;\n }\n \n-// FIXME(chalk): the ordering of these two errors differs between CI and local\n-// We need to figure out why its non-deterministic\n-/*\n impl Bar for f32 {\n-//^ ERROR the trait bound `f32: Foo` is not satisfied\n     type Item = f32;\n-    //^ ERROR the trait bound `f32: Foo` is not satisfied\n+    //~^ ERROR the trait bound `f32: Foo` is not satisfied\n }\n-*/\n \n trait Baz<U: ?Sized> where U: Foo { }\n "}, {"sha": "e5d7615e43e31f484912f15afa25d02c2457ab3d", "filename": "src/test/ui/chalkify/impl_wf.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -11,14 +11,25 @@ LL | impl Foo for str { }\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n \n error[E0277]: the trait bound `f32: Foo` is not satisfied\n-  --> $DIR/impl_wf.rs:40:6\n+  --> $DIR/impl_wf.rs:27:17\n+   |\n+LL | trait Bar {\n+   |       --- required by a bound in this\n+LL |     type Item: Foo;\n+   |                --- required by this bound in `Bar`\n+...\n+LL |     type Item = f32;\n+   |                 ^^^ the trait `Foo` is not implemented for `f32`\n+\n+error[E0277]: the trait bound `f32: Foo` is not satisfied\n+  --> $DIR/impl_wf.rs:35:6\n    |\n LL | trait Baz<U: ?Sized> where U: Foo { }\n    |                               --- required by this bound in `Baz`\n ...\n LL | impl Baz<f32> for f32 { }\n    |      ^^^^^^^^ the trait `Foo` is not implemented for `f32`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "a2730219fbe2ac0d1a7b70d386ee758961846aa0", "filename": "src/test/ui/chalkify/inherent_impl.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n // compile-flags: -Z chalk\n-// FIXME(chalk): remove when uncommented\n-#![allow(dead_code, unused_variables)]\n \n trait Foo { }\n \n@@ -11,8 +9,6 @@ struct S<T: Foo> {\n     x: T,\n }\n \n-// FIXME(chalk): need late-bound regions on FnDefs\n-/*\n fn only_foo<T: Foo>(_x: &T) { }\n \n impl<T> S<T> {\n@@ -21,7 +17,6 @@ impl<T> S<T> {\n         only_foo(&self.x)\n     }\n }\n-*/\n \n trait Bar { }\n impl Bar for u32 { }\n@@ -31,27 +26,17 @@ fn only_bar<T: Bar>() { }\n impl<T> S<T> {\n     // Test that the environment of `dummy_bar` adds up with the environment\n     // of the inherent impl.\n-    // FIXME(chalk): need late-bound regions on FnDefs\n-    /*\n     fn dummy_bar<U: Bar>(&self) {\n         only_foo(&self.x);\n         only_bar::<U>();\n     }\n-    */\n-    fn dummy_bar<U: Bar>() {\n-        only_bar::<U>();\n-    }\n }\n \n fn main() {\n     let s = S {\n         x: 5,\n     };\n \n-    // FIXME(chalk): need late-bound regions on FnDefs\n-    /*\n-    s.dummy_foo();\n     s.dummy_bar::<u32>();\n-    */\n-    S::<i32>::dummy_bar::<u32>();\n+    s.dummy_foo();\n }"}, {"sha": "87324a5f79bdd760da0e9c63e6b822764bbcb874", "filename": "src/test/ui/chalkify/recursive_where_clause_on_type.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.rs?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -1,5 +1,5 @@\n // FIXME(chalk): should fail, see comments\n-// check-pass\n+// check-fail\n // compile-flags: -Z chalk\n \n #![feature(trivial_bounds)]\n@@ -10,7 +10,6 @@ trait Bar {\n trait Foo: Bar { }\n \n struct S where S: Foo;\n-//~^ WARN Trait bound S: Foo does not depend on any type or lifetime parameters\n \n impl Foo for S {\n }\n@@ -26,10 +25,6 @@ fn foo<T: Foo>() {\n fn main() {\n     // For some reason, the error is duplicated...\n \n-    // FIXME(chalk): this order of this duplicate error seems non-determistic\n-    // and causes test to fail\n-    /*\n-    foo::<S>() // ERROR the type `S` is not well-formed (chalk)\n-    //^ ERROR the type `S` is not well-formed (chalk)\n-    */\n+    foo::<S>() //~ ERROR the type `S` is not well-formed (chalk)\n+    //~^ ERROR the type `S` is not well-formed (chalk)\n }"}, {"sha": "fddd58959278efb72c4129873cf78306a4e9f911", "filename": "src/test/ui/chalkify/recursive_where_clause_on_type.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ecb8b9f9f768a3245e8ae723005d5c408bf2067a/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.stderr?ref=ecb8b9f9f768a3245e8ae723005d5c408bf2067a", "patch": "@@ -1,10 +1,14 @@\n-warning: Trait bound S: Foo does not depend on any type or lifetime parameters\n-  --> $DIR/recursive_where_clause_on_type.rs:12:19\n+error: the type `S` is not well-formed (chalk)\n+  --> $DIR/recursive_where_clause_on_type.rs:28:11\n    |\n-LL | struct S where S: Foo;\n-   |                   ^^^\n+LL |     foo::<S>()\n+   |           ^\n+\n+error: the type `S` is not well-formed (chalk)\n+  --> $DIR/recursive_where_clause_on_type.rs:28:5\n    |\n-   = note: `#[warn(trivial_bounds)]` on by default\n+LL |     foo::<S>()\n+   |     ^^^^^^^^\n \n-warning: 1 warning emitted\n+error: aborting due to 2 previous errors\n "}]}