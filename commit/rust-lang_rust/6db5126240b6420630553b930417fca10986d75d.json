{"sha": "6db5126240b6420630553b930417fca10986d75d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYjUxMjYyNDBiNjQyMDYzMDU1M2I5MzA0MTdmY2ExMDk4NmQ3NWQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-25T01:09:46Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-06-26T04:34:56Z"}, "message": "rustc: make ty::mk_* constructors into methods on ty::ctxt.", "tree": {"sha": "47d4a9d04ae043af86e7d544317e61cecc66c7d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47d4a9d04ae043af86e7d544317e61cecc66c7d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6db5126240b6420630553b930417fca10986d75d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6db5126240b6420630553b930417fca10986d75d", "html_url": "https://github.com/rust-lang/rust/commit/6db5126240b6420630553b930417fca10986d75d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6db5126240b6420630553b930417fca10986d75d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2332765cbc5d58fe03356a6adefc83ff6412c1c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/2332765cbc5d58fe03356a6adefc83ff6412c1c2", "html_url": "https://github.com/rust-lang/rust/commit/2332765cbc5d58fe03356a6adefc83ff6412c1c2"}], "stats": {"total": 1007, "additions": 481, "deletions": 526}, "files": [{"sha": "a5b9e40593a839566142adbe2ce243a00edafabd", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -471,14 +471,14 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         let def = parse_def_(st, NominalType, conv);\n         let substs = parse_substs_(st, conv);\n         assert_eq!(next(st), ']');\n-        return ty::mk_enum(tcx, def, st.tcx.mk_substs(substs));\n+        return tcx.mk_enum(def, st.tcx.mk_substs(substs));\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n         let trait_ref = ty::Binder(parse_trait_ref_(st, conv));\n         let bounds = parse_existential_bounds_(st, conv);\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(tcx, trait_ref, bounds);\n+        return tcx.mk_trait(trait_ref, bounds);\n       }\n       'p' => {\n         assert_eq!(next(st), '[');\n@@ -487,38 +487,38 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n         let name = token::intern(&parse_str(st, ']'));\n-        return ty::mk_param(tcx, space, index, name);\n+        return tcx.mk_param(space, index, name);\n       }\n-      '~' => return ty::mk_uniq(tcx, parse_ty_(st, conv)),\n-      '*' => return ty::mk_ptr(tcx, parse_mt_(st, conv)),\n+      '~' => return tcx.mk_box(parse_ty_(st, conv)),\n+      '*' => return tcx.mk_ptr(parse_mt_(st, conv)),\n       '&' => {\n         let r = parse_region_(st, conv);\n         let mt = parse_mt_(st, conv);\n-        return ty::mk_rptr(tcx, tcx.mk_region(r), mt);\n+        return tcx.mk_ref(tcx.mk_region(r), mt);\n       }\n       'V' => {\n         let t = parse_ty_(st, conv);\n-        let sz = parse_size(st);\n-        return ty::mk_vec(tcx, t, sz);\n+        return match parse_size(st) {\n+            Some(n) => tcx.mk_array(t, n),\n+            None => tcx.mk_slice(t)\n+        };\n       }\n       'v' => {\n-        return ty::mk_str(tcx);\n+        return tcx.mk_str();\n       }\n       'T' => {\n         assert_eq!(next(st), '[');\n         let mut params = Vec::new();\n         while peek(st) != ']' { params.push(parse_ty_(st, conv)); }\n         st.pos = st.pos + 1;\n-        return ty::mk_tup(tcx, params);\n+        return tcx.mk_tup(params);\n       }\n       'F' => {\n           let def_id = parse_def_(st, NominalType, conv);\n-          return ty::mk_bare_fn(tcx, Some(def_id),\n-                                tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n+          return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n       }\n       'G' => {\n-          return ty::mk_bare_fn(tcx, None,\n-                                tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n+          return tcx.mk_fn(None, tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n       }\n       '#' => {\n         let pos = parse_hex(st);\n@@ -558,20 +558,20 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n           let did = parse_def_(st, NominalType, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return ty::mk_struct(st.tcx, did, st.tcx.mk_substs(substs));\n+          return st.tcx.mk_struct(did, st.tcx.mk_substs(substs));\n       }\n       'k' => {\n           assert_eq!(next(st), '[');\n           let did = parse_def_(st, ClosureSource, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return ty::mk_closure(st.tcx, did, st.tcx.mk_substs(substs));\n+          return st.tcx.mk_closure(did, st.tcx.mk_substs(substs));\n       }\n       'P' => {\n           assert_eq!(next(st), '[');\n           let trait_ref = parse_trait_ref_(st, conv);\n           let name = token::intern(&parse_str(st, ']'));\n-          return ty::mk_projection(tcx, trait_ref, name);\n+          return tcx.mk_projection(trait_ref, name);\n       }\n       'e' => {\n           return tcx.types.err;"}, {"sha": "fb0131f258d437df00d5561bea74a9b3046f2520", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -49,10 +49,10 @@ pub fn prim_ty_to_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     match nty {\n         ast::TyBool => tcx.types.bool,\n         ast::TyChar => tcx.types.char,\n-        ast::TyInt(it) => ty::mk_mach_int(tcx, it),\n-        ast::TyUint(uit) => ty::mk_mach_uint(tcx, uit),\n-        ast::TyFloat(ft) => ty::mk_mach_float(tcx, ft),\n-        ast::TyStr => ty::mk_str(tcx)\n+        ast::TyInt(it) => tcx.mk_mach_int(it),\n+        ast::TyUint(uit) => tcx.mk_mach_uint(uit),\n+        ast::TyFloat(ft) => tcx.mk_mach_float(ft),\n+        ast::TyStr => tcx.mk_str()\n     }\n }\n "}, {"sha": "dd708cf8f3ae6006da0dd33e27c705546f6eb92f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -651,7 +651,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n         None => v[0]\n     };\n     let left_ty = if real_pat.id == DUMMY_NODE_ID {\n-        ty::mk_nil(cx.tcx)\n+        cx.tcx.mk_nil()\n     } else {\n         let left_ty = ty::pat_ty(cx.tcx, &*real_pat);\n "}, {"sha": "3cdf53e6b0acd3675b0c12182665415e7264a49b", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n         let assoc_type_projections: Vec<_> =\n             trait_def.associated_type_names\n                      .iter()\n-                     .map(|&name| ty::mk_projection(self.tcx(), trait_ref.clone(), name))\n+                     .map(|&name| self.tcx().mk_projection(trait_ref.clone(), name))\n                      .collect();\n         debug!(\"accumulate_from_assoc_types: assoc_type_projections={:?}\",\n                assoc_type_projections);\n@@ -437,7 +437,7 @@ pub fn object_region_bounds<'tcx>(\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n-    let open_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n+    let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n     // Note that we preserve the overall binding levels here.\n     assert!(!open_ty.has_escaping_regions());"}, {"sha": "13b2214d35328f0ee972547377dd9c4940513aa9", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -129,8 +129,8 @@ fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n          .unify_var_value(vid, val)\n          .map_err(|e| int_unification_error(vid_is_expected, e)));\n     match val {\n-        IntType(v) => Ok(ty::mk_mach_int(infcx.tcx, v)),\n-        UintType(v) => Ok(ty::mk_mach_uint(infcx.tcx, v)),\n+        IntType(v) => Ok(infcx.tcx.mk_mach_int(v)),\n+        UintType(v) => Ok(infcx.tcx.mk_mach_uint(v)),\n     }\n }\n \n@@ -145,7 +145,7 @@ fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n          .borrow_mut()\n          .unify_var_value(vid, val)\n          .map_err(|e| float_unification_error(vid_is_expected, e)));\n-    Ok(ty::mk_mach_float(infcx.tcx, val))\n+    Ok(infcx.tcx.mk_mach_float(val))\n }\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {"}, {"sha": "d65c4061f11eb3cb7c6b46c6c9f0c038f5307a15", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n             Entry::Vacant(entry) => {\n                 let index = self.freshen_count;\n                 self.freshen_count += 1;\n-                let t = ty::mk_infer(self.infcx.tcx, freshener(index));\n+                let t = self.infcx.tcx.mk_infer(freshener(index));\n                 entry.insert(t);\n                 t\n             }"}, {"sha": "9005e1b8c53a514e39aa9d22db248efb3685959b", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -507,7 +507,7 @@ pub fn construct_skolemized_substs<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n                                   types: &mut subst::VecPerParamSpace<ty::Ty<'tcx>>,\n                                   defs: &[ty::TypeParameterDef<'tcx>]) {\n         for def in defs {\n-            let ty = ty::mk_param_from_def(tcx, def);\n+            let ty = tcx.mk_param_from_def(def);\n             types.push(def.space, ty);\n         }\n     }"}, {"sha": "2873a59ae8b1aae350e3b064c6b986637a74c41e", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -772,11 +772,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_var(&self) -> Ty<'tcx> {\n-        ty::mk_var(self.tcx, self.next_ty_var_id(false))\n+        self.tcx.mk_var(self.next_ty_var_id(false))\n     }\n \n     pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n-        ty::mk_var(self.tcx, self.next_ty_var_id(true))\n+        self.tcx.mk_var(self.next_ty_var_id(true))\n     }\n \n     pub fn next_ty_vars(&self, n: usize) -> Vec<Ty<'tcx>> {"}, {"sha": "fac7b53ca76aa5b4ec264c066e166e3cde7de7ab", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -1672,7 +1672,7 @@ impl<'tcx> GenericKind<'tcx> {\n             GenericKind::Param(ref p) =>\n                 p.to_ty(tcx),\n             GenericKind::Projection(ref p) =>\n-                ty::mk_projection(tcx, p.trait_ref.clone(), p.item_name),\n+                tcx.mk_projection(p.trait_ref.clone(), p.item_name),\n         }\n     }\n }"}, {"sha": "c13cec45dc44a353e678486754d5730751e6c16d", "filename": "src/librustc/middle/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify_key.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -26,8 +26,8 @@ impl UnifyKey for ty::IntVid {\n impl<'tcx> ToType<'tcx> for IntVarValue {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n-            ty::IntType(i) => ty::mk_mach_int(tcx, i),\n-            ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n+            ty::IntType(i) => tcx.mk_mach_int(i),\n+            ty::UintType(i) => tcx.mk_mach_uint(i),\n         }\n     }\n }\n@@ -43,6 +43,6 @@ impl UnifyKey for ty::FloatVid {\n \n impl<'tcx> ToType<'tcx> for ast::FloatTy {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n-        ty::mk_mach_float(tcx, *self)\n+        tcx.mk_mach_float(*self)\n     }\n }"}, {"sha": "900dbb444e4e677dcd522f42627e3efa6a32aaca", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -30,7 +30,7 @@ pub fn check_crate(tcx: &ctxt) {\n         tcx: tcx,\n         param_envs: Vec::new(),\n         dummy_sized_ty: tcx.types.isize,\n-        dummy_unsized_ty: ty::mk_vec(tcx, tcx.types.isize, None),\n+        dummy_unsized_ty: tcx.mk_slice(tcx.types.isize),\n     };\n     visit::walk_crate(&mut visitor, tcx.map.krate());\n }"}, {"sha": "e0709f51ab1b043214ec88a8a0b2481e1e76480d", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -524,9 +524,9 @@ fn project_type<'cx,'tcx>(\n             Ok(ProjectedTy::Progress(ty, obligations))\n         }\n         None => {\n-            Ok(ProjectedTy::NoProgress(ty::mk_projection(selcx.tcx(),\n-                                                         obligation.predicate.trait_ref.clone(),\n-                                                         obligation.predicate.item_name)))\n+            Ok(ProjectedTy::NoProgress(selcx.tcx().mk_projection(\n+                obligation.predicate.trait_ref.clone(),\n+                obligation.predicate.item_name)))\n         }\n     }\n }"}, {"sha": "86d4e8c753375d2c50f0fbe3e5d961e39b634589", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -2451,7 +2451,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     projection_bounds: data_a.bounds.projection_bounds.clone(),\n                 };\n \n-                let new_trait = ty::mk_trait(tcx, data_a.principal.clone(), bounds);\n+                let new_trait = tcx.mk_trait(data_a.principal.clone(), bounds);\n                 let origin = infer::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, new_trait, target).is_err() {\n                     return Err(Unimplemented);\n@@ -2573,7 +2573,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let param_b = *substs_b.types.get(TypeSpace, i);\n                     new_substs.types.get_mut_slice(TypeSpace)[i] = param_b;\n                 }\n-                let new_struct = ty::mk_struct(tcx, def_id, tcx.mk_substs(new_substs));\n+                let new_struct = tcx.mk_struct(def_id, tcx.mk_substs(new_substs));\n                 let origin = infer::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n                     return Err(Unimplemented);"}, {"sha": "79b9ae22e4b5c3d1703fd0aa803e22772af29dbe", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -456,14 +456,14 @@ pub fn closure_trait_ref_and_return_type<'tcx>(\n {\n     let arguments_tuple = match tuple_arguments {\n         TupleArgumentsFlag::No => sig.0.inputs[0],\n-        TupleArgumentsFlag::Yes => ty::mk_tup(tcx, sig.0.inputs.to_vec()),\n+        TupleArgumentsFlag::Yes => tcx.mk_tup(sig.0.inputs.to_vec()),\n     };\n     let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n     let trait_ref = ty::TraitRef {\n         def_id: fn_trait_def_id,\n         substs: tcx.mk_substs(trait_substs),\n     };\n-    ty::Binder((trait_ref, sig.0.output.unwrap_or(ty::mk_nil(tcx))))\n+    ty::Binder((trait_ref, sig.0.output.unwrap_or(tcx.mk_nil())))\n }\n \n impl<'tcx,O:fmt::Debug> fmt::Debug for super::Obligation<'tcx, O> {"}, {"sha": "51fb11f7452f4450295f2eef82737a3358c0f2e2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 177, "deletions": 192, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -3034,7 +3034,7 @@ impl<'tcx> ctxt<'tcx> {\n             abi: bare_fn.abi,\n             sig: bare_fn.sig.clone()\n         });\n-        ty::mk_bare_fn(self, None, unsafe_fn_ty_a)\n+        self.mk_fn(None, unsafe_fn_ty_a)\n     }\n \n     pub fn mk_bare_fn(&self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n@@ -3085,13 +3085,6 @@ impl<'tcx> ctxt<'tcx> {\n     }\n }\n \n-// Interns a type/name combination, stores the resulting box in cx.interner,\n-// and returns the box as cast to an unsafe ptr (see comments for Ty above).\n-pub fn mk_t<'tcx>(cx: &ctxt<'tcx>, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n-    let mut interner = cx.interner.borrow_mut();\n-    intern_ty(&cx.arenas.type_, &mut *interner, st)\n-}\n-\n fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n                    interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>,\n                    st: TypeVariants<'tcx>)\n@@ -3309,201 +3302,202 @@ impl FlagComputation {\n     }\n }\n \n-pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n-    match tm {\n-        ast::TyIs   => tcx.types.isize,\n-        ast::TyI8   => tcx.types.i8,\n-        ast::TyI16  => tcx.types.i16,\n-        ast::TyI32  => tcx.types.i32,\n-        ast::TyI64  => tcx.types.i64,\n+impl<'tcx> ctxt<'tcx> {\n+    // Interns a type/name combination, stores the resulting box in cx.interner,\n+    // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n+    pub fn mk_ty(&self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n+        let mut interner = self.interner.borrow_mut();\n+        intern_ty(&self.arenas.type_, &mut *interner, st)\n     }\n-}\n \n-pub fn mk_mach_uint<'tcx>(tcx: &ctxt<'tcx>, tm: ast::UintTy) -> Ty<'tcx> {\n-    match tm {\n-        ast::TyUs   => tcx.types.usize,\n-        ast::TyU8   => tcx.types.u8,\n-        ast::TyU16  => tcx.types.u16,\n-        ast::TyU32  => tcx.types.u32,\n-        ast::TyU64  => tcx.types.u64,\n+    pub fn mk_mach_int(&self, tm: ast::IntTy) -> Ty<'tcx> {\n+        match tm {\n+            ast::TyIs   => self.types.isize,\n+            ast::TyI8   => self.types.i8,\n+            ast::TyI16  => self.types.i16,\n+            ast::TyI32  => self.types.i32,\n+            ast::TyI64  => self.types.i64,\n+        }\n     }\n-}\n \n-pub fn mk_mach_float<'tcx>(tcx: &ctxt<'tcx>, tm: ast::FloatTy) -> Ty<'tcx> {\n-    match tm {\n-        ast::TyF32  => tcx.types.f32,\n-        ast::TyF64  => tcx.types.f64,\n+    pub fn mk_mach_uint(&self, tm: ast::UintTy) -> Ty<'tcx> {\n+        match tm {\n+            ast::TyUs   => self.types.usize,\n+            ast::TyU8   => self.types.u8,\n+            ast::TyU16  => self.types.u16,\n+            ast::TyU32  => self.types.u32,\n+            ast::TyU64  => self.types.u64,\n+        }\n     }\n-}\n \n-pub fn mk_str<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n-    mk_t(cx, TyStr)\n-}\n+    pub fn mk_mach_float(&self, tm: ast::FloatTy) -> Ty<'tcx> {\n+        match tm {\n+            ast::TyF32  => self.types.f32,\n+            ast::TyF64  => self.types.f64,\n+        }\n+    }\n \n-pub fn mk_str_slice<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, m: ast::Mutability) -> Ty<'tcx> {\n-    mk_rptr(cx, r,\n-            mt {\n-                ty: mk_t(cx, TyStr),\n-                mutbl: m\n-            })\n-}\n+    pub fn mk_str(&self) -> Ty<'tcx> {\n+        self.mk_ty(TyStr)\n+    }\n \n-pub fn mk_enum<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-    // take a copy of substs so that we own the vectors inside\n-    mk_t(cx, TyEnum(did, substs))\n-}\n+    pub fn mk_static_str(&self) -> Ty<'tcx> {\n+        self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n+    }\n \n-pub fn mk_uniq<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, TyBox(ty)) }\n+    pub fn mk_enum(&self, did: ast::DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        // take a copy of substs so that we own the vectors inside\n+        self.mk_ty(TyEnum(did, substs))\n+    }\n \n-pub fn mk_ptr<'tcx>(cx: &ctxt<'tcx>, tm: mt<'tcx>) -> Ty<'tcx> { mk_t(cx, TyRawPtr(tm)) }\n+    pub fn mk_box(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyBox(ty))\n+    }\n \n-pub fn mk_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx> {\n-    mk_t(cx, TyRef(r, tm))\n-}\n+    pub fn mk_ptr(&self, tm: mt<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyRawPtr(tm))\n+    }\n \n-pub fn mk_mut_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutMutable})\n-}\n-pub fn mk_imm_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutImmutable})\n-}\n+    pub fn mk_ref(&self, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyRef(r, tm))\n+    }\n \n-pub fn mk_mut_ptr<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    mk_ptr(cx, mt {ty: ty, mutbl: ast::MutMutable})\n-}\n+    pub fn mk_mut_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ref(r, mt {ty: ty, mutbl: ast::MutMutable})\n+    }\n \n-pub fn mk_imm_ptr<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    mk_ptr(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n-}\n+    pub fn mk_imm_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ref(r, mt {ty: ty, mutbl: ast::MutImmutable})\n+    }\n \n-pub fn mk_nil_ptr<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n-    mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::MutImmutable})\n-}\n+    pub fn mk_mut_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ptr(mt {ty: ty, mutbl: ast::MutMutable})\n+    }\n \n-pub fn mk_vec<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, sz: Option<usize>) -> Ty<'tcx> {\n-    match sz {\n-        Some(n) => mk_t(cx, TyArray(ty, n)),\n-        None => mk_t(cx, TySlice(ty))\n+    pub fn mk_imm_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ptr(mt {ty: ty, mutbl: ast::MutImmutable})\n     }\n-}\n \n-pub fn mk_slice<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx> {\n-    mk_rptr(cx, r,\n-            mt {\n-                ty: mk_vec(cx, tm.ty, None),\n-                mutbl: tm.mutbl\n-            })\n-}\n+    pub fn mk_nil_ptr(&self) -> Ty<'tcx> {\n+        self.mk_imm_ptr(self.mk_nil())\n+    }\n \n-pub fn mk_tup<'tcx>(cx: &ctxt<'tcx>, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n-    mk_t(cx, TyTuple(ts))\n-}\n+    pub fn mk_array(&self, ty: Ty<'tcx>, n: usize) -> Ty<'tcx> {\n+        self.mk_ty(TyArray(ty, n))\n+    }\n \n-pub fn mk_nil<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n-    mk_tup(cx, Vec::new())\n-}\n+    pub fn mk_slice(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TySlice(ty))\n+    }\n \n-pub fn mk_bool<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n-    mk_t(cx, TyBool)\n-}\n+    pub fn mk_tup(&self, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n+        self.mk_ty(TyTuple(ts))\n+    }\n \n-pub fn mk_bare_fn<'tcx>(cx: &ctxt<'tcx>,\n-                        opt_def_id: Option<ast::DefId>,\n-                        fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n-    mk_t(cx, TyBareFn(opt_def_id, fty))\n-}\n+    pub fn mk_nil(&self) -> Ty<'tcx> {\n+        self.mk_tup(Vec::new())\n+    }\n \n-pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n-                        def_id: ast::DefId,\n-                        input_tys: &[Ty<'tcx>],\n-                        output: Ty<'tcx>) -> Ty<'tcx> {\n-    let input_args = input_tys.iter().cloned().collect();\n-    mk_bare_fn(cx,\n-               Some(def_id),\n-               cx.mk_bare_fn(BareFnTy {\n-                   unsafety: ast::Unsafety::Normal,\n-                   abi: abi::Rust,\n-                   sig: ty::Binder(FnSig {\n-                    inputs: input_args,\n-                    output: ty::FnConverging(output),\n-                    variadic: false\n-                   })\n-                }))\n-}\n-\n-pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n-                      principal: ty::PolyTraitRef<'tcx>,\n-                      bounds: ExistentialBounds<'tcx>)\n-                      -> Ty<'tcx>\n-{\n-    assert!(bound_list_is_sorted(&bounds.projection_bounds));\n+    pub fn mk_bool(&self) -> Ty<'tcx> {\n+        self.mk_ty(TyBool)\n+    }\n \n-    let inner = box TraitTy {\n-        principal: principal,\n-        bounds: bounds\n-    };\n-    mk_t(cx, TyTrait(inner))\n-}\n+    pub fn mk_fn(&self,\n+                 opt_def_id: Option<ast::DefId>,\n+                 fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyBareFn(opt_def_id, fty))\n+    }\n \n-fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n-    bounds.is_empty() ||\n-        bounds[1..].iter().enumerate().all(\n-            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n-}\n+    pub fn mk_ctor_fn(&self,\n+                      def_id: ast::DefId,\n+                      input_tys: &[Ty<'tcx>],\n+                      output: Ty<'tcx>) -> Ty<'tcx> {\n+        let input_args = input_tys.iter().cloned().collect();\n+        self.mk_fn(Some(def_id), self.mk_bare_fn(BareFnTy {\n+            unsafety: ast::Unsafety::Normal,\n+            abi: abi::Rust,\n+            sig: ty::Binder(FnSig {\n+                inputs: input_args,\n+                output: ty::FnConverging(output),\n+                variadic: false\n+            })\n+        }))\n+    }\n \n-pub fn sort_bounds_list(bounds: &mut [ty::PolyProjectionPredicate]) {\n-    bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()))\n-}\n+    pub fn mk_trait(&self,\n+                    principal: ty::PolyTraitRef<'tcx>,\n+                    bounds: ExistentialBounds<'tcx>)\n+                    -> Ty<'tcx>\n+    {\n+        assert!(bound_list_is_sorted(&bounds.projection_bounds));\n \n-pub fn mk_projection<'tcx>(cx: &ctxt<'tcx>,\n-                           trait_ref: TraitRef<'tcx>,\n-                           item_name: ast::Name)\n-                           -> Ty<'tcx> {\n-    // take a copy of substs so that we own the vectors inside\n-    let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n-    mk_t(cx, TyProjection(inner))\n-}\n+        let inner = box TraitTy {\n+            principal: principal,\n+            bounds: bounds\n+        };\n+        self.mk_ty(TyTrait(inner))\n+    }\n \n-pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n-                       substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-    // take a copy of substs so that we own the vectors inside\n-    mk_t(cx, TyStruct(struct_id, substs))\n-}\n+    pub fn mk_projection(&self,\n+                         trait_ref: TraitRef<'tcx>,\n+                         item_name: ast::Name)\n+                         -> Ty<'tcx> {\n+        // take a copy of substs so that we own the vectors inside\n+        let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n+        self.mk_ty(TyProjection(inner))\n+    }\n \n-pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId, substs: &'tcx Substs<'tcx>)\n-                        -> Ty<'tcx> {\n-    mk_t(cx, TyClosure(closure_id, substs))\n-}\n+    pub fn mk_struct(&self, struct_id: ast::DefId,\n+                     substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        // take a copy of substs so that we own the vectors inside\n+        self.mk_ty(TyStruct(struct_id, substs))\n+    }\n \n-pub fn mk_var<'tcx>(cx: &ctxt<'tcx>, v: TyVid) -> Ty<'tcx> {\n-    mk_infer(cx, TyVar(v))\n-}\n+    pub fn mk_closure(&self, closure_id: ast::DefId, substs: &'tcx Substs<'tcx>)\n+                      -> Ty<'tcx> {\n+        self.mk_ty(TyClosure(closure_id, substs))\n+    }\n \n-pub fn mk_int_var<'tcx>(cx: &ctxt<'tcx>, v: IntVid) -> Ty<'tcx> {\n-    mk_infer(cx, IntVar(v))\n-}\n+    pub fn mk_var(&self, v: TyVid) -> Ty<'tcx> {\n+        self.mk_infer(TyVar(v))\n+    }\n \n-pub fn mk_float_var<'tcx>(cx: &ctxt<'tcx>, v: FloatVid) -> Ty<'tcx> {\n-    mk_infer(cx, FloatVar(v))\n-}\n+    pub fn mk_int_var(&self, v: IntVid) -> Ty<'tcx> {\n+        self.mk_infer(IntVar(v))\n+    }\n \n-pub fn mk_infer<'tcx>(cx: &ctxt<'tcx>, it: InferTy) -> Ty<'tcx> {\n-    mk_t(cx, TyInfer(it))\n-}\n+    pub fn mk_float_var(&self, v: FloatVid) -> Ty<'tcx> {\n+        self.mk_infer(FloatVar(v))\n+    }\n+\n+    pub fn mk_infer(&self, it: InferTy) -> Ty<'tcx> {\n+        self.mk_ty(TyInfer(it))\n+    }\n+\n+    pub fn mk_param(&self,\n+                    space: subst::ParamSpace,\n+                    index: u32,\n+                    name: ast::Name) -> Ty<'tcx> {\n+        self.mk_ty(TyParam(ParamTy { space: space, idx: index, name: name }))\n+    }\n+\n+    pub fn mk_self_type(&self) -> Ty<'tcx> {\n+        self.mk_param(subst::SelfSpace, 0, special_idents::type_self.name)\n+    }\n \n-pub fn mk_param<'tcx>(cx: &ctxt<'tcx>,\n-                      space: subst::ParamSpace,\n-                      index: u32,\n-                      name: ast::Name) -> Ty<'tcx> {\n-    mk_t(cx, TyParam(ParamTy { space: space, idx: index, name: name }))\n+    pub fn mk_param_from_def(&self, def: &TypeParameterDef) -> Ty<'tcx> {\n+        self.mk_param(def.space, def.index, def.name)\n+    }\n }\n \n-pub fn mk_self_type<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n-    mk_param(cx, subst::SelfSpace, 0, special_idents::type_self.name)\n+fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n+    bounds.is_empty() ||\n+        bounds[1..].iter().enumerate().all(\n+            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n }\n \n-pub fn mk_param_from_def<'tcx>(cx: &ctxt<'tcx>, def: &TypeParameterDef) -> Ty<'tcx> {\n-    mk_param(cx, def.space, def.index, def.name)\n+pub fn sort_bounds_list(bounds: &mut [ty::PolyProjectionPredicate]) {\n+    bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()))\n }\n \n impl<'tcx> TyS<'tcx> {\n@@ -3586,7 +3580,7 @@ impl ParamTy {\n     }\n \n     pub fn to_ty<'tcx>(self, tcx: &ctxt<'tcx>) -> Ty<'tcx> {\n-        ty::mk_param(tcx, self.space, self.idx, self.name)\n+        tcx.mk_param(self.space, self.idx, self.name)\n     }\n \n     pub fn is_self(&self) -> bool {\n@@ -3657,7 +3651,7 @@ impl<'tcx> TyS<'tcx> {\n     pub fn sequence_element_type(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => ty,\n-            TyStr => mk_mach_uint(cx, ast::TyU8),\n+            TyStr => cx.mk_mach_uint(ast::TyU8),\n             _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n                                       self)),\n         }\n@@ -4745,18 +4739,6 @@ pub fn ty_region(tcx: &ctxt,\n     }\n }\n \n-pub fn free_region_from_def(outlives_extent: region::DestructionScopeData,\n-                            def: &RegionParameterDef)\n-    -> ty::Region\n-{\n-    let ret =\n-        ty::ReFree(ty::FreeRegion { scope: outlives_extent,\n-                                    bound_region: ty::BrNamed(def.def_id,\n-                                                              def.name) });\n-    debug!(\"free_region_from_def returns {:?}\", ret);\n-    ret\n-}\n-\n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n pub fn pat_ty<'tcx>(cx: &ctxt<'tcx>, pat: &ast::Pat) -> Ty<'tcx> {\n@@ -4860,7 +4842,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                AdjustReifyFnPointer => {\n                     match unadjusted_ty.sty {\n                         ty::TyBareFn(Some(_), b) => {\n-                            ty::mk_bare_fn(cx, None, b)\n+                            cx.mk_fn(None, b)\n                         }\n                         _ => {\n                             cx.sess.bug(\n@@ -4932,10 +4914,10 @@ pub fn adjust_ty_for_autoref<'tcx>(cx: &ctxt<'tcx>,\n     match autoref {\n         None => ty,\n         Some(AutoPtr(r, m)) => {\n-            mk_rptr(cx, r, mt { ty: ty, mutbl: m })\n+            cx.mk_ref(r, mt { ty: ty, mutbl: m })\n         }\n         Some(AutoUnsafe(m)) => {\n-            mk_ptr(cx, mt { ty: ty, mutbl: m })\n+            cx.mk_ptr(mt { ty: ty, mutbl: m })\n         }\n     }\n }\n@@ -6185,12 +6167,11 @@ pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n                                     freevar_ty\n                                 }\n                                 UpvarCapture::ByRef(borrow) => {\n-                                    mk_rptr(tcx,\n-                                            tcx.mk_region(borrow.region),\n-                                            ty::mt {\n-                                                ty: freevar_ty,\n-                                                mutbl: borrow.kind.to_mutbl_lossy(),\n-                                            })\n+                                    tcx.mk_ref(tcx.mk_region(borrow.region),\n+                                        ty::mt {\n+                                            ty: freevar_ty,\n+                                            mutbl: borrow.kind.to_mutbl_lossy(),\n+                                        })\n                                 }\n                             };\n \n@@ -6698,8 +6679,12 @@ pub fn construct_free_substs<'a,'tcx>(\n                           all_outlive_extent: region::DestructionScopeData,\n                           region_params: &[RegionParameterDef])\n     {\n-        for r in region_params {\n-            regions.push(r.space, ty::free_region_from_def(all_outlive_extent, r));\n+        for def in region_params {\n+            let region =\n+                ReFree(FreeRegion { scope: all_outlive_extent,\n+                                    bound_region: BrNamed(def.def_id, def.name) });\n+            debug!(\"push_region_params {:?}\", region);\n+            regions.push(def.space, region);\n         }\n     }\n \n@@ -6709,7 +6694,7 @@ pub fn construct_free_substs<'a,'tcx>(\n         for def in defs {\n             debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n                    def);\n-            let ty = ty::mk_param_from_def(tcx, def);\n+            let ty = tcx.mk_param_from_def(def);\n             types.push(def.space, ty);\n        }\n     }\n@@ -7161,7 +7146,7 @@ pub fn make_substs_for_receiver_types<'tcx>(tcx: &ctxt<'tcx>,\n     let meth_tps: Vec<Ty> =\n         method.generics.types.get_slice(subst::FnSpace)\n               .iter()\n-              .map(|def| ty::mk_param_from_def(tcx, def))\n+              .map(|def| tcx.mk_param_from_def(def))\n               .collect();\n     let meth_regions: Vec<ty::Region> =\n         method.generics.regions.get_slice(subst::FnSpace)"}, {"sha": "012f5216ed7e3060d4584ad988b72583268cd5d1", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -641,7 +641,7 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             ty.sty.clone()\n         }\n     };\n-    ty::mk_t(this.tcx(), sty)\n+    this.tcx().mk_ty(sty)\n }\n \n pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,"}, {"sha": "422498624a9d3457dd8717c865c06e3a476f188e", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -469,21 +469,21 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             if a_id == b_id =>\n         {\n             let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n-            Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n+            Ok(tcx.mk_enum(a_id, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyTrait(ref a_), &ty::TyTrait(ref b_)) =>\n         {\n             let principal = try!(relation.relate(&a_.principal, &b_.principal));\n             let bounds = try!(relation.relate(&a_.bounds, &b_.bounds));\n-            Ok(ty::mk_trait(tcx, principal, bounds))\n+            Ok(tcx.mk_trait(principal, bounds))\n         }\n \n         (&ty::TyStruct(a_id, a_substs), &ty::TyStruct(b_id, b_substs))\n             if a_id == b_id =>\n         {\n             let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n-            Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n+            Ok(tcx.mk_struct(a_id, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyClosure(a_id, a_substs),\n@@ -494,33 +494,33 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n             let substs = try!(relate_substs(relation, None, a_substs, b_substs));\n-            Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n+            Ok(tcx.mk_closure(a_id, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyBox(a_inner), &ty::TyBox(b_inner)) =>\n         {\n             let typ = try!(relation.relate(&a_inner, &b_inner));\n-            Ok(ty::mk_uniq(tcx, typ))\n+            Ok(tcx.mk_box(typ))\n         }\n \n         (&ty::TyRawPtr(ref a_mt), &ty::TyRawPtr(ref b_mt)) =>\n         {\n             let mt = try!(relation.relate(a_mt, b_mt));\n-            Ok(ty::mk_ptr(tcx, mt))\n+            Ok(tcx.mk_ptr(mt))\n         }\n \n         (&ty::TyRef(a_r, ref a_mt), &ty::TyRef(b_r, ref b_mt)) =>\n         {\n             let r = try!(relation.relate_with_variance(ty::Contravariant, a_r, b_r));\n             let mt = try!(relation.relate(a_mt, b_mt));\n-            Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n+            Ok(tcx.mk_ref(tcx.mk_region(r), mt))\n         }\n \n         (&ty::TyArray(a_t, sz_a), &ty::TyArray(b_t, sz_b)) =>\n         {\n             let t = try!(relation.relate(&a_t, &b_t));\n             if sz_a == sz_b {\n-                Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n+                Ok(tcx.mk_array(t, sz_a))\n             } else {\n                 Err(ty::terr_fixed_array_size(expected_found(relation, &sz_a, &sz_b)))\n             }\n@@ -529,7 +529,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n         (&ty::TySlice(a_t), &ty::TySlice(b_t)) =>\n         {\n             let t = try!(relation.relate(&a_t, &b_t));\n-            Ok(ty::mk_vec(tcx, t, None))\n+            Ok(tcx.mk_slice(t))\n         }\n \n         (&ty::TyTuple(ref as_), &ty::TyTuple(ref bs)) =>\n@@ -538,7 +538,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n                 let ts = try!(as_.iter().zip(bs)\n                                  .map(|(a, b)| relation.relate(a, b))\n                                  .collect::<Result<_, _>>());\n-                Ok(ty::mk_tup(tcx, ts))\n+                Ok(tcx.mk_tup(ts))\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(ty::terr_tuple_size(\n                     expected_found(relation, &as_.len(), &bs.len())))\n@@ -551,13 +551,13 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             if a_opt_def_id == b_opt_def_id =>\n         {\n             let fty = try!(relation.relate(a_fty, b_fty));\n-            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n+            Ok(tcx.mk_fn(a_opt_def_id, tcx.mk_bare_fn(fty)))\n         }\n \n         (&ty::TyProjection(ref a_data), &ty::TyProjection(ref b_data)) =>\n         {\n             let projection_ty = try!(relation.relate(a_data, b_data));\n-            Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n+            Ok(tcx.mk_projection(projection_ty.trait_ref, projection_ty.item_name))\n         }\n \n         _ =>"}, {"sha": "02ea8859b5c75b6fb0cdb24d131c3e667f7657fa", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -256,30 +256,29 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                 -> Ty<'tcx>\n     {\n         let input_args = input_tys.iter().cloned().collect();\n-        ty::mk_bare_fn(self.infcx.tcx,\n-                       None,\n-                       self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n-                           unsafety: ast::Unsafety::Normal,\n-                           abi: abi::Rust,\n-                           sig: ty::Binder(ty::FnSig {\n-                               inputs: input_args,\n-                               output: ty::FnConverging(output_ty),\n-                               variadic: false\n-                           })\n-                       }))\n+        self.infcx.tcx.mk_fn(None,\n+            self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n+                unsafety: ast::Unsafety::Normal,\n+                abi: abi::Rust,\n+                sig: ty::Binder(ty::FnSig {\n+                    inputs: input_args,\n+                    output: ty::FnConverging(output_ty),\n+                    variadic: false\n+                })\n+            }))\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {\n-        ty::mk_nil(self.infcx.tcx)\n+        self.infcx.tcx.mk_nil()\n     }\n \n     pub fn t_pair(&self, ty1: Ty<'tcx>, ty2: Ty<'tcx>) -> Ty<'tcx> {\n-        ty::mk_tup(self.infcx.tcx, vec![ty1, ty2])\n+        self.infcx.tcx.mk_tup(vec![ty1, ty2])\n     }\n \n     pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        ty::mk_param(self.infcx.tcx, space, index, token::intern(&name[..]))\n+        self.infcx.tcx.mk_param(space, index, token::intern(&name[..]))\n     }\n \n     pub fn re_early_bound(&self,\n@@ -302,32 +301,29 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1));\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound_with_debruijn(&self,\n                                            id: u32,\n                                            debruijn: ty::DebruijnIndex)\n                                            -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let r = ty::ReScope(CodeExtent::from_node_id(id));\n-        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n@@ -337,15 +333,13 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n         let r = self.re_free(nid, id);\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        self.infcx.tcx.mk_region(ty::ReStatic),\n-                        self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(ty::ReStatic),\n+                                   self.tcx().types.isize)\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n@@ -804,9 +798,9 @@ fn walk_ty() {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n         let uint_ty = tcx.types.usize;\n-        let tup1_ty = ty::mk_tup(tcx, vec!(int_ty, uint_ty, int_ty, uint_ty));\n-        let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n-        let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n+        let tup1_ty = tcx.mk_tup(vec!(int_ty, uint_ty, int_ty, uint_ty));\n+        let tup2_ty = tcx.mk_tup(vec!(tup1_ty, tup1_ty, uint_ty));\n+        let uniq_ty = tcx.mk_box(tup2_ty);\n         let walked: Vec<_> = uniq_ty.walk().collect();\n         assert_eq!(walked, [uniq_ty,\n                             tup2_ty,\n@@ -822,9 +816,9 @@ fn walk_ty_skip_subtree() {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n         let uint_ty = tcx.types.usize;\n-        let tup1_ty = ty::mk_tup(tcx, vec!(int_ty, uint_ty, int_ty, uint_ty));\n-        let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n-        let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n+        let tup1_ty = tcx.mk_tup(vec!(int_ty, uint_ty, int_ty, uint_ty));\n+        let tup2_ty = tcx.mk_tup(vec!(tup1_ty, tup1_ty, uint_ty));\n+        let uniq_ty = tcx.mk_box(tup2_ty);\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree."}, {"sha": "29799d34ee5837a0ea8f00f4caa93db87ce61835", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -1699,15 +1699,15 @@ impl LintPass for MissingCopyImplementations {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                ty::mk_struct(cx.tcx, local_def(item.id),\n-                              cx.tcx.mk_substs(Substs::empty()))\n+                cx.tcx.mk_struct(local_def(item.id),\n+                                 cx.tcx.mk_substs(Substs::empty()))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                ty::mk_enum(cx.tcx, local_def(item.id),\n-                            cx.tcx.mk_substs(Substs::empty()))\n+                cx.tcx.mk_enum(local_def(item.id),\n+                               cx.tcx.mk_substs(Substs::empty()))\n             }\n             _ => return,\n         };"}, {"sha": "4667e36c64a9aee93b3d2e37fec6408e142470ca", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -674,9 +674,8 @@ fn bind_subslice_pat(bcx: Block,\n     let slice_begin = InBoundsGEP(bcx, base, &[C_uint(bcx.ccx(), offset_left)]);\n     let slice_len_offset = C_uint(bcx.ccx(), offset_left + offset_right);\n     let slice_len = Sub(bcx, len, slice_len_offset, DebugLoc::None);\n-    let slice_ty = ty::mk_slice(bcx.tcx(),\n-                                bcx.tcx().mk_region(ty::ReStatic),\n-                                ty::mt {ty: unit_ty, mutbl: ast::MutImmutable});\n+    let slice_ty = bcx.tcx().mk_imm_ref(bcx.tcx().mk_region(ty::ReStatic),\n+                                         bcx.tcx().mk_slice(unit_ty));\n     let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n     Store(bcx, slice_begin,\n           GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n@@ -854,9 +853,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                     // NOTE: cast &[u8] and &[u8; N] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n                     let pat_len = val_ty(rhs).element_type().array_length();\n-                    let ty_str_slice = ty::mk_str_slice(cx.tcx(),\n-                                                        cx.tcx().mk_region(ty::ReStatic),\n-                                                        ast::MutImmutable);\n+                    let ty_str_slice = cx.tcx().mk_static_str();\n \n                     let rhs_str = alloc_ty(cx, ty_str_slice, \"rhs_str\");\n                     Store(cx, GEPi(cx, rhs, &[0, 0]), expr::get_dataptr(cx, rhs_str));\n@@ -1063,7 +1060,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                          .unwrap_or(DUMMY_NODE_ID);\n \n     let left_ty = if pat_id == DUMMY_NODE_ID {\n-        ty::mk_nil(tcx)\n+        tcx.mk_nil()\n     } else {\n         node_id_type(bcx, pat_id)\n     };"}, {"sha": "255920aa96d547aeb4d143b8c9ef70d1005b2cb0", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -623,8 +623,8 @@ fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n \n pub fn ty_of_inttype<'tcx>(tcx: &ty::ctxt<'tcx>, ity: IntType) -> Ty<'tcx> {\n     match ity {\n-        attr::SignedInt(t) => ty::mk_mach_int(tcx, t),\n-        attr::UnsignedInt(t) => ty::mk_mach_uint(tcx, t)\n+        attr::SignedInt(t) => tcx.mk_mach_int(t),\n+        attr::UnsignedInt(t) => tcx.mk_mach_uint(t)\n     }\n }\n \n@@ -1078,7 +1078,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                        -> datum::DatumBlock<'blk, 'tcx, datum::Expr>\n {\n     let tcx = bcx.tcx();\n-    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), tcx.dtor_type());\n+    let ptr_ty = bcx.tcx().mk_imm_ptr(tcx.dtor_type());\n     match *r {\n         Univariant(ref st, dtor) if dtor_active(dtor) => {\n             let flag_ptr = GEPi(bcx, val, &[0, st.fields.len() - 1]);"}, {"sha": "b86bf67869d77a75fba2056b67a143c8f95cf668", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -202,10 +202,10 @@ pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let closure_kind = ccx.tcx().closure_kind(closure_id);\n     match closure_kind {\n         ty::FnClosureKind => {\n-            ty::mk_imm_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n+            ccx.tcx().mk_imm_ref(ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n         ty::FnMutClosureKind => {\n-            ty::mk_mut_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n+            ccx.tcx().mk_mut_ref(ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n         ty::FnOnceClosureKind => fn_ty\n     }\n@@ -1579,7 +1579,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n         closure::ClosureEnv::Closure(_) => {\n-            vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n+            vec![ccx.tcx().mk_tup(monomorphized_arg_types)]\n         }\n     };\n     for monomorphized_arg_type in &monomorphized_arg_types {\n@@ -2115,7 +2115,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n     let llfn = declare::define_fn(ccx, &sym[..], cc, llfty,\n-                                   ty::FnConverging(ty::mk_nil(ccx.tcx()))).unwrap_or_else(||{\n+                                   ty::FnConverging(ccx.tcx().mk_nil())).unwrap_or_else(||{\n         ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n     });\n     finish_register_fn(ccx, sym, node_id, llfn);\n@@ -2197,7 +2197,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n                                &ccx.int_type());\n \n         let llfn = declare::define_cfn(ccx, \"main\", llfty,\n-                                       ty::mk_nil(ccx.tcx())).unwrap_or_else(||{\n+                                       ccx.tcx().mk_nil()).unwrap_or_else(||{\n             ccx.sess().span_err(sp, \"entry symbol `main` defined multiple times\");\n             // FIXME: We should be smart and show a better diagnostic here.\n             ccx.sess().help(\"did you use #[no_mangle] on `fn main`? Use #[start] instead\");"}, {"sha": "a7c01036f845e6739d0b9bc0d2b833c4efda620d", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -277,7 +277,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         ty::FnOnceClosureKind => false,\n     };\n     let bare_fn_ty_maybe_ref = if is_by_ref {\n-        ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), bare_fn_ty)\n+        tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), bare_fn_ty)\n     } else {\n         bare_fn_ty\n     };\n@@ -308,18 +308,17 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n             }\n         };\n     let sig = ty::erase_late_bound_regions(tcx, sig);\n-    let tuple_input_ty = ty::mk_tup(tcx, sig.inputs.to_vec());\n-    let tuple_fn_ty = ty::mk_bare_fn(tcx,\n-                                     opt_def_id,\n-                                     tcx.mk_bare_fn(ty::BareFnTy {\n-                                         unsafety: ast::Unsafety::Normal,\n-                                         abi: synabi::RustCall,\n-                                         sig: ty::Binder(ty::FnSig {\n-                                             inputs: vec![bare_fn_ty_maybe_ref,\n-                                                          tuple_input_ty],\n-                                             output: sig.output,\n-                                             variadic: false\n-                                         })}));\n+    let tuple_input_ty = tcx.mk_tup(sig.inputs.to_vec());\n+    let tuple_fn_ty = tcx.mk_fn(opt_def_id,\n+        tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: ast::Unsafety::Normal,\n+            abi: synabi::RustCall,\n+            sig: ty::Binder(ty::FnSig {\n+                inputs: vec![bare_fn_ty_maybe_ref,\n+                             tuple_input_ty],\n+                output: sig.output,\n+                variadic: false\n+            })}));\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n@@ -615,7 +614,7 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Some(method) => match method.origin {\n             ty::MethodTraitObject(_) => match method.ty.sty {\n                 ty::TyBareFn(_, ref fty) => {\n-                    ty::mk_bare_fn(bcx.tcx(), None, meth::opaque_method_ty(bcx.tcx(), fty))\n+                    bcx.tcx().mk_fn(None, meth::opaque_method_ty(bcx.tcx(), fty))\n                 }\n                 _ => method.ty\n             },\n@@ -749,7 +748,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         expr::Ignore => {\n             let ret_ty = match ret_ty {\n                 ty::FnConverging(ret_ty) => ret_ty,\n-                ty::FnDiverging => ty::mk_nil(ccx.tcx())\n+                ty::FnDiverging => ccx.tcx().mk_nil()\n             };\n             if !is_rust_fn ||\n               type_of::return_uses_outptr(ccx, ret_ty) ||"}, {"sha": "b1c86713837674aee00090cba6fcb0a1eaf6db3d", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -363,16 +363,16 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // Find a version of the closure type. Substitute static for the\n     // region since it doesn't really matter.\n     let substs = tcx.mk_substs(substs);\n-    let closure_ty = ty::mk_closure(tcx, closure_def_id, substs);\n-    let ref_closure_ty = ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), closure_ty);\n+    let closure_ty = tcx.mk_closure(closure_def_id, substs);\n+    let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), closure_ty);\n \n     // Make a version with the type of by-ref closure.\n     let ty::ClosureTy { unsafety, abi, mut sig } = typer.closure_type(closure_def_id, substs);\n     sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n     let llref_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n                                                                abi: abi,\n                                                                sig: sig.clone() });\n-    let llref_fn_ty = ty::mk_bare_fn(tcx, None, llref_bare_fn_ty);\n+    let llref_fn_ty = tcx.mk_fn(None, llref_bare_fn_ty);\n     debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n            llref_fn_ty);\n \n@@ -383,7 +383,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let llonce_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n                                                                 abi: abi,\n                                                                 sig: sig });\n-    let llonce_fn_ty = ty::mk_bare_fn(tcx, None, llonce_bare_fn_ty);\n+    let llonce_fn_ty = tcx.mk_fn(None, llonce_bare_fn_ty);\n \n     // Create the by-value helper.\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");"}, {"sha": "a12c07c97501731b3158659dd002928318e1f239", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -306,7 +306,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     // Don't copy data to do a deref+ref\n                     // (i.e., skip the last auto-deref).\n                     llconst = addr_of(cx, llconst, \"autoref\");\n-                    ty = ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), ty);\n+                    ty = cx.tcx().mk_imm_ref(cx.tcx().mk_region(ty::ReStatic), ty);\n                 }\n             } else {\n                 let (dv, dt) = const_deref(cx, llconst, ty);"}, {"sha": "cf9d70cc65727098e9dc957410434ac22c0b4a79", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -791,15 +791,15 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n         ($name:expr, fn() -> $ret:expr) => (\n             if *key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret),\n-                                             ty::mk_nil(ccx.tcx()));\n+                                             ccx.tcx().mk_nil());\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret),\n-                                             ty::mk_nil(ccx.tcx()));\n+                                             ccx.tcx().mk_nil());\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n@@ -939,7 +939,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n             } else if *key == $name {\n                 let f = declare::declare_cfn(ccx, stringify!($cname),\n                                              Type::func(&[$($arg),*], &void),\n-                                             ty::mk_nil(ccx.tcx()));\n+                                             ccx.tcx().mk_nil());\n                 llvm::SetLinkage(f, llvm::InternalLinkage);\n \n                 let bld = ccx.builder();\n@@ -962,7 +962,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n             } else if *key == $name {\n                 let f = declare::declare_cfn(ccx, stringify!($cname),\n                                              Type::func(&[$($arg),*], &$ret),\n-                                             ty::mk_nil(ccx.tcx()));\n+                                             ccx.tcx().mk_nil());\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }"}, {"sha": "54cb87f8a7b3cb9696de3d59d1bc8917f8804c5b", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -562,7 +562,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 unique_type_id: UniqueTypeId,\n                                 span: Span)\n                                 -> MetadataCreationResult {\n-    let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n+    let data_ptr_type = cx.tcx().mk_ptr(ty::mt {\n         ty: element_type,\n         mutbl: ast::MutImmutable\n     });"}, {"sha": "2187b7f6ae1c6d6fe515f0994656332be59b1a0c", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -1110,7 +1110,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              None,\n                              expr.span,\n                              expr.id,\n-                             ty::mk_struct(tcx, did, tcx.mk_substs(substs)),\n+                             tcx.mk_struct(did, tcx.mk_substs(substs)),\n                              dest)\n             } else {\n                 tcx.sess.span_bug(expr.span,\n@@ -1697,7 +1697,7 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            lval: Datum<'tcx, Lvalue>)\n                            -> DatumBlock<'blk, 'tcx, Expr> {\n-    let dest_ty = ty::mk_imm_rptr(bcx.tcx(), bcx.tcx().mk_region(ty::ReStatic), lval.ty);\n+    let dest_ty = bcx.tcx().mk_imm_ref(bcx.tcx().mk_region(ty::ReStatic), lval.ty);\n     let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n     memcpy_ty(bcx, scratch.val, lval.val, scratch.ty);\n \n@@ -2180,7 +2180,7 @@ fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Compute final type. Note that we are loose with the region and\n     // mutability, since those things don't matter in trans.\n     let referent_ty = lv_datum.ty;\n-    let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), bcx.tcx().mk_region(ty::ReStatic), referent_ty);\n+    let ptr_ty = bcx.tcx().mk_imm_ref(bcx.tcx().mk_region(ty::ReStatic), referent_ty);\n \n     // Get the pointer.\n     let llref = lv_datum.to_llref();"}, {"sha": "6f3346b9329a23efcc31472f11eab3f60757ed9c", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -538,7 +538,7 @@ pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n     };\n     let llfn = declare::declare_fn(ccx, name, cconv, llfn_ty,\n-                                   ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+                                   ty::FnConverging(ccx.tcx().mk_nil()));\n     add_argument_attributes(&tys, llfn);\n     debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n            ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));"}, {"sha": "7a5ccd5b9c6171967adc89505a877fbe2daba925", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -218,21 +218,21 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let llty = if type_is_sized(ccx.tcx(), t) {\n         type_of(ccx, t).ptr_to()\n     } else {\n-        type_of(ccx, ty::mk_uniq(ccx.tcx(), t)).ptr_to()\n+        type_of(ccx, ccx.tcx().mk_box(t)).ptr_to()\n     };\n \n     let llfnty = Type::glue_fn(ccx, llty);\n \n     // To avoid infinite recursion, don't `make_drop_glue` until after we've\n     // added the entry to the `drop_glues` cache.\n     if let Some(old_sym) = ccx.available_drop_glues().borrow().get(&g) {\n-        let llfn = declare::declare_cfn(ccx, &old_sym, llfnty, ty::mk_nil(ccx.tcx()));\n+        let llfn = declare::declare_cfn(ccx, &old_sym, llfnty, ccx.tcx().mk_nil());\n         ccx.drop_glues().borrow_mut().insert(g, llfn);\n         return llfn;\n     };\n \n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, \"drop\");\n-    let llfn = declare::define_cfn(ccx, &fn_nm, llfnty, ty::mk_nil(ccx.tcx())).unwrap_or_else(||{\n+    let llfn = declare::define_cfn(ccx, &fn_nm, llfnty, ccx.tcx().mk_nil()).unwrap_or_else(||{\n        ccx.sess().bug(&format!(\"symbol `{}` already defined\", fn_nm));\n     });\n     ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n@@ -243,10 +243,10 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n-                      ty::FnConverging(ty::mk_nil(ccx.tcx())),\n+                      ty::FnConverging(ccx.tcx().mk_nil()),\n                       empty_substs, None, &arena);\n \n-    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    let bcx = init_function(&fcx, false, ty::FnConverging(ccx.tcx().mk_nil()));\n \n     update_linkage(ccx, llfn, None, OriginalTranslation);\n \n@@ -261,7 +261,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let llrawptr0 = get_param(llfn, fcx.arg_offset() as c_uint);\n     let bcx = make_drop_glue(bcx, llrawptr0, g);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n+    finish_fn(&fcx, bcx, ty::FnConverging(ccx.tcx().mk_nil()), DebugLoc::None);\n \n     llfn\n }\n@@ -328,10 +328,9 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let name = csearch::get_symbol(&ccx.sess().cstore, did);\n         let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n         let llty = type_of_dtor(ccx, class_ty);\n-        let dtor_ty = ty::mk_ctor_fn(ccx.tcx(),\n-                                     did,\n-                                     &[get_drop_glue_type(ccx, t)],\n-                                     ty::mk_nil(ccx.tcx()));\n+        let dtor_ty = ccx.tcx().mk_ctor_fn(did,\n+                                           &[get_drop_glue_type(ccx, t)],\n+                                           ccx.tcx().mk_nil());\n         foreign::get_extern_fn(ccx, &mut *ccx.externs().borrow_mut(), &name[..], llvm::CCallConv,\n                                llty, dtor_ty)\n     }\n@@ -371,7 +370,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx.fcx.schedule_drop_adt_contents(cleanup::CustomScope(contents_scope), v0, t);\n \n     let glue_type = get_drop_glue_type(bcx.ccx(), t);\n-    let dtor_ty = ty::mk_ctor_fn(bcx.tcx(), class_did, &[glue_type], ty::mk_nil(bcx.tcx()));\n+    let dtor_ty = bcx.tcx().mk_ctor_fn(class_did, &[glue_type], bcx.tcx().mk_nil());\n     let (_, bcx) = invoke(bcx, dtor_addr, &[v0], dtor_ty, DebugLoc::None);\n \n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)"}, {"sha": "c6107f7d268aff5ad3010a762a35caf957e9b903", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -584,8 +584,8 @@ pub fn trans_object_shim<'a, 'tcx>(\n     debug!(\"trans_object_shim: fty={:?} method_ty={:?}\", fty, method_ty);\n \n     //\n-    let shim_fn_ty = ty::mk_bare_fn(tcx, None, fty);\n-    let method_bare_fn_ty = ty::mk_bare_fn(tcx, None, method_ty);\n+    let shim_fn_ty = tcx.mk_fn(None, fty);\n+    let method_bare_fn_ty = tcx.mk_fn(None, method_ty);\n     let function_name = link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n     let llfn = declare::define_internal_rust_fn(ccx, &function_name, shim_fn_ty).unwrap_or_else(||{\n         ccx.sess().bug(&format!(\"symbol `{}` already defined\", function_name));\n@@ -827,7 +827,7 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n         -> &'tcx ty::BareFnTy<'tcx> {\n     let mut inputs = method_ty.sig.0.inputs.clone();\n-    inputs[0] = ty::mk_mut_ptr(tcx, ty::mk_mach_int(tcx, ast::TyI8));\n+    inputs[0] = tcx.mk_mut_ptr(tcx.mk_mach_int(ast::TyI8));\n \n     tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: method_ty.unsafety,"}, {"sha": "3c6770caef8d10c0da6d1dd6c33c88c1ee123957", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -106,9 +106,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let count = elements_required(bcx, content_expr);\n     debug!(\"    vt={}, count={}\", vt.to_string(ccx), count);\n \n-    let fixed_ty = ty::mk_vec(bcx.tcx(),\n-                              vt.unit_ty,\n-                              Some(count));\n+    let fixed_ty = bcx.tcx().mk_array(vt.unit_ty, count);\n     let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty);\n \n     // Always create an alloca even if zero-sized, to preserve"}, {"sha": "96eae5fd184abee82df637c66ecbca56c9b055c3", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -278,7 +278,7 @@ pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n /// For the raw type without far pointer indirection, see `in_memory_type_of`.\n pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n     let ty = if !type_is_sized(cx.tcx(), ty) {\n-        ty::mk_imm_ptr(cx.tcx(), ty)\n+        cx.tcx().mk_imm_ptr(ty)\n     } else {\n         ty\n     };"}, {"sha": "d5e57e163029d3433fd53572328a11843c394369", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -579,7 +579,7 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n     let (implied_output_region,\n          params_lifetimes) = find_implied_output_region(&*inputs, input_params);\n \n-    let input_ty = ty::mk_tup(this.tcx(), inputs);\n+    let input_ty = this.tcx().mk_tup(inputs);\n \n     let (output, output_span) = match data.output {\n         Some(ref output_ty) => {\n@@ -590,7 +590,7 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n              output_ty.span)\n         }\n         None => {\n-            (ty::mk_nil(this.tcx()), data.span)\n+            (this.tcx().mk_nil(), data.span)\n         }\n     };\n \n@@ -852,7 +852,7 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n     // this, we currently insert a dummy type and then remove it\n     // later. Yuck.\n \n-    let dummy_self_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n+    let dummy_self_ty = tcx.mk_infer(ty::FreshTy(0));\n     if self_ty.is_none() { // if converting for an object type\n         let mut dummy_substs = trait_ref.skip_binder().substs.clone(); // binder moved here -+\n         assert!(dummy_substs.self_ty().is_none());                     //                    |\n@@ -924,7 +924,7 @@ fn ast_path_to_ty<'tcx>(\n     // FIXME(#12938): This is a hack until we have full support for DST.\n     if Some(did) == this.tcx().lang_items.owned_box() {\n         assert_eq!(substs.types.len(TypeSpace), 1);\n-        return ty::mk_uniq(this.tcx(), *substs.types.get(TypeSpace, 0));\n+        return this.tcx().mk_box(*substs.types.get(TypeSpace, 0));\n     }\n \n     decl_ty.subst(this.tcx(), &substs)\n@@ -1081,7 +1081,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n                     ty::item_path_str(tcx, trait_def_id));\n     }\n \n-    ty::mk_trait(tcx, object.principal, object.bounds)\n+    tcx.mk_trait(object.principal, object.bounds)\n }\n \n fn report_ambiguous_associated_type(tcx: &ty::ctxt,\n@@ -1393,7 +1393,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         def::DefTyParam(space, index, _, name) => {\n             check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n-            ty::mk_param(tcx, space, index, name)\n+            tcx.mk_param(space, index, name)\n         }\n         def::DefSelfTy(_, Some((_, self_ty_id))) => {\n             // Self in impl (we know the concrete type).\n@@ -1411,7 +1411,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         def::DefSelfTy(Some(_), None) => {\n             // Self in trait.\n             check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n-            ty::mk_self_type(tcx)\n+            tcx.mk_self_type()\n         }\n         def::DefAssociatedTy(trait_did, _) => {\n             check_path_args(tcx, &base_segments[..base_segments.len()-2], NO_TPS | NO_REGIONS);\n@@ -1509,7 +1509,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     let typ = match ast_ty.node {\n         ast::TyVec(ref ty) => {\n-            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n+            tcx.mk_slice(ast_ty_to_ty(this, rscope, &**ty))\n         }\n         ast::TyObjectSum(ref ty, ref bounds) => {\n             match ast_ty_to_trait_ref(this, rscope, &**ty, bounds) {\n@@ -1527,7 +1527,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             }\n         }\n         ast::TyPtr(ref mt) => {\n-            ty::mk_ptr(tcx, ty::mt {\n+            tcx.mk_ptr(ty::mt {\n                 ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n                 mutbl: mt.mutbl\n             })\n@@ -1540,13 +1540,13 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     rscope,\n                     Some(ty::ObjectLifetimeDefault::Specific(r)));\n             let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n-            ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n+            tcx.mk_ref(tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n         }\n         ast::TyTup(ref fields) => {\n             let flds = fields.iter()\n                              .map(|t| ast_ty_to_ty(this, rscope, &**t))\n                              .collect();\n-            ty::mk_tup(tcx, flds)\n+            tcx.mk_tup(flds)\n         }\n         ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n         ast::TyBareFn(ref bf) => {\n@@ -1555,7 +1555,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                           \"variadic function must have C calling convention\");\n             }\n             let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n-            ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n+            tcx.mk_fn(None, tcx.mk_bare_fn(bare_fn))\n         }\n         ast::TyPolyTraitRef(ref bounds) => {\n             conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds)\n@@ -1603,11 +1603,11 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 Ok(r) => {\n                     match r {\n                         ConstVal::Int(i) =>\n-                            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                        Some(i as usize)),\n+                            tcx.mk_array(ast_ty_to_ty(this, rscope, &**ty),\n+                                         i as usize),\n                         ConstVal::Uint(i) =>\n-                            ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                        Some(i as usize)),\n+                            tcx.mk_array(ast_ty_to_ty(this, rscope, &**ty),\n+                                         i as usize),\n                         _ => {\n                             span_err!(tcx.sess, ast_ty.span, E0249,\n                                       \"expected constant integer expression \\\n@@ -1724,7 +1724,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n                     (Some(self_info.untransformed_self_ty), None)\n                 }\n                 ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n-                    (Some(ty::mk_rptr(this.tcx(),\n+                    (Some(this.tcx().mk_ref(\n                                       this.tcx().mk_region(region),\n                                       ty::mt {\n                                         ty: self_info.untransformed_self_ty,\n@@ -1733,7 +1733,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n                      Some(region))\n                 }\n                 ty::ByBoxExplicitSelfCategory => {\n-                    (Some(ty::mk_uniq(this.tcx(), self_info.untransformed_self_ty)), None)\n+                    (Some(this.tcx().mk_box(self_info.untransformed_self_ty)), None)\n                 }\n             }\n         }\n@@ -1779,7 +1779,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n                                                               implied_output_region,\n                                                               lifetimes_for_params,\n                                                               &**output)),\n-        ast::DefaultReturn(..) => ty::FnConverging(ty::mk_nil(this.tcx())),\n+        ast::DefaultReturn(..) => ty::FnConverging(this.tcx().mk_nil()),\n         ast::NoReturn(..) => ty::FnDiverging\n     };\n "}, {"sha": "c223809b8c80e9abf0dd0438f3b4a6ceddaafae4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -59,8 +59,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n                     if let ty::TyRef(_, mt) = expected_ty.sty {\n                         if let ty::TySlice(_) = mt.ty.sty {\n-                            pat_ty = ty::mk_slice(tcx, tcx.mk_region(ty::ReStatic),\n-                                ty::mt{ ty: tcx.types.u8, mutbl: ast::MutImmutable })\n+                            pat_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n+                                                     tcx.mk_slice(tcx.types.u8))\n                         }\n                     }\n                 }\n@@ -171,7 +171,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     // and T is the expected type.\n                     let region_var = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     let mt = ty::mt { ty: expected, mutbl: mutbl };\n-                    let region_ty = ty::mk_rptr(tcx, tcx.mk_region(region_var), mt);\n+                    let region_ty = tcx.mk_ref(tcx.mk_region(region_var), mt);\n \n                     // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                     // required. However, we use equality, which is stronger. See (*) for\n@@ -246,7 +246,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let element_tys: Vec<_> =\n                 (0..elements.len()).map(|_| fcx.infcx().next_ty_var())\n                                         .collect();\n-            let pat_ty = ty::mk_tup(tcx, element_tys.clone());\n+            let pat_ty = tcx.mk_tup(element_tys.clone());\n             fcx.write_ty(pat.id, pat_ty);\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n             for (element_pat, element_ty) in elements.iter().zip(element_tys) {\n@@ -255,7 +255,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatBox(ref inner) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n-            let uniq_ty = ty::mk_uniq(tcx, inner_ty);\n+            let uniq_ty = tcx.mk_box(inner_ty);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n                 // Here, `demand::subtype` is good enough, but I don't\n@@ -274,7 +274,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n             let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-            let rptr_ty = ty::mk_rptr(tcx, tcx.mk_region(region), mt);\n+            let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n                 // `demand::subtype` would be good enough, but using\n@@ -292,17 +292,17 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n             let inner_ty = fcx.infcx().next_ty_var();\n             let pat_ty = match expected_ty.sty {\n-                ty::TyArray(_, size) => ty::mk_vec(tcx, inner_ty, Some({\n+                ty::TyArray(_, size) => tcx.mk_array(inner_ty, {\n                     let min_len = before.len() + after.len();\n                     match *slice {\n                         Some(_) => cmp::max(min_len, size),\n                         None => min_len\n                     }\n-                })),\n+                }),\n                 _ => {\n                     let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-                    ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n-                        ty: inner_ty,\n+                    tcx.mk_ref(tcx.mk_region(region), ty::mt {\n+                        ty: tcx.mk_slice(inner_ty),\n                         mutbl: expected_ty.builtin_deref(true).map(|mt| mt.mutbl)\n                                                               .unwrap_or(ast::MutImmutable)\n                     })\n@@ -324,8 +324,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 let mutbl = expected_ty.builtin_deref(true)\n                     .map_or(ast::MutImmutable, |mt| mt.mutbl);\n \n-                let slice_ty = ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n-                    ty: inner_ty,\n+                let slice_ty = tcx.mk_ref(tcx.mk_region(region), ty::mt {\n+                    ty: tcx.mk_slice(inner_ty),\n                     mutbl: mutbl\n                 });\n                 check_pat(pcx, &**slice, slice_ty);\n@@ -485,7 +485,7 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // us to give better error messages (pointing to a usually better\n             // arm for inconsistent arms or to the whole match when a `()` type\n             // is required).\n-            Expectation::ExpectHasType(ety) if ety != ty::mk_nil(fcx.tcx()) => {\n+            Expectation::ExpectHasType(ety) if ety != fcx.tcx().mk_nil() => {\n                 check_expr_coercable_to_type(fcx, &*arm.body, ety);\n                 ety\n             }"}, {"sha": "30ed9d9eb2f2425b5d15c33bbc6ed093c45558b0", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -371,7 +371,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                     demand::eqtype(fcx, self.call_expr.span, self_arg_ty, method_arg_ty);\n                 }\n \n-                let nilty = ty::mk_nil(fcx.tcx());\n+                let nilty = fcx.tcx().mk_nil();\n                 demand::eqtype(fcx,\n                                self.call_expr.span,\n                                method_sig.output.unwrap_or(nilty),"}, {"sha": "ec4c4a327143359ac8ccc2787a21c8763313f3da", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -60,10 +60,8 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         abi::RustCall,\n         expected_sig);\n \n-    let closure_type = ty::mk_closure(fcx.ccx.tcx,\n-                                      expr_def_id,\n-                                      fcx.ccx.tcx.mk_substs(\n-                                        fcx.inh.param_env.free_substs.clone()));\n+    let closure_type = fcx.ccx.tcx.mk_closure(expr_def_id,\n+        fcx.ccx.tcx.mk_substs(fcx.inh.param_env.free_substs.clone()));\n \n     fcx.write_ty(expr.id, closure_type);\n \n@@ -83,7 +81,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     // Tuple up the arguments and insert the resulting function type into\n     // the `closures` table.\n-    fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n+    fn_ty.sig.0.inputs = vec![fcx.tcx().mk_tup(fn_ty.sig.0.inputs)];\n \n     debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n            expr_def_id,"}, {"sha": "612b574dfa7c6cfb39c6727f6cc58dac1294d56a", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -201,8 +201,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 // &T to autoref to &&T.\n                 return None;\n             }\n-            let ty = ty::mk_rptr(self.tcx(), r_borrow,\n-                                 mt {ty: inner_ty, mutbl: mutbl_b});\n+            let ty = self.tcx().mk_ref(r_borrow,\n+                                        mt {ty: inner_ty, mutbl: mutbl_b});\n             if let Err(err) = self.subtype(ty, b) {\n                 if first_error.is_none() {\n                     first_error = Some(err);\n@@ -384,7 +384,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n             match b.sty {\n                 ty::TyBareFn(None, _) => {\n-                    let a_fn_pointer = ty::mk_bare_fn(self.tcx(), None, fn_ty_a);\n+                    let a_fn_pointer = self.tcx().mk_fn(None, fn_ty_a);\n                     try!(self.subtype(a_fn_pointer, b));\n                     Ok(Some(ty::AdjustReifyFnPointer))\n                 }\n@@ -411,7 +411,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n \n         // Check that the types which they point at are compatible.\n-        let a_unsafe = ty::mk_ptr(self.tcx(), ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n+        let a_unsafe = self.tcx().mk_ptr(ty::mt{ mutbl: mutbl_b, ty: mt_a.ty });\n         try!(self.subtype(a_unsafe, b));\n         try!(coerce_mutbls(mt_a.mutbl, mutbl_b));\n "}, {"sha": "44768990d68c4ceb472dcff36da55632523fa401", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -275,9 +275,9 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // type.\n \n     // Compute skolemized form of impl and trait method tys.\n-    let impl_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(impl_m.fty.clone()));\n+    let impl_fty = tcx.mk_fn(None, tcx.mk_bare_fn(impl_m.fty.clone()));\n     let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n-    let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n+    let trait_fty = tcx.mk_fn(None, tcx.mk_bare_fn(trait_m.fty.clone()));\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n     let err = infcx.commit_if_ok(|snapshot| {\n@@ -296,12 +296,11 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &impl_sig);\n-        let impl_fty =\n-            ty::mk_bare_fn(tcx,\n-                           None,\n-                           tcx.mk_bare_fn(ty::BareFnTy { unsafety: impl_m.fty.unsafety,\n-                                                         abi: impl_m.fty.abi,\n-                                                         sig: ty::Binder(impl_sig) }));\n+        let impl_fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: impl_m.fty.unsafety,\n+            abi: impl_m.fty.abi,\n+            sig: ty::Binder(impl_sig)\n+        }));\n         debug!(\"compare_impl_method: impl_fty={:?}\",\n                impl_fty);\n \n@@ -316,12 +315,11 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &trait_sig);\n-        let trait_fty =\n-            ty::mk_bare_fn(tcx,\n-                           None,\n-                           tcx.mk_bare_fn(ty::BareFnTy { unsafety: trait_m.fty.unsafety,\n-                                                         abi: trait_m.fty.abi,\n-                                                         sig: ty::Binder(trait_sig) }));\n+        let trait_fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: trait_m.fty.unsafety,\n+            abi: trait_m.fty.abi,\n+            sig: ty::Binder(trait_sig)\n+        }));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\",\n                trait_fty);"}, {"sha": "2104ebaec45c913ce70a6e1d4579bee9b17cb226", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -108,7 +108,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Create the final `MethodCallee`.\n         let method_ty = pick.item.as_opt_method().unwrap();\n-        let fty = ty::mk_bare_fn(self.tcx(), None, self.tcx().mk_bare_fn(ty::BareFnTy {\n+        let fty = self.tcx().mk_fn(None, self.tcx().mk_bare_fn(ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n             unsafety: method_ty.fty.unsafety,\n             abi: method_ty.fty.abi.clone(),"}, {"sha": "6ba9704aa987f33beadfe6572cb1df5867e1cf49", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -224,7 +224,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                                        &method_ty.fty.sig).0;\n     let fn_sig = fcx.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n     let transformed_self_ty = fn_sig.inputs[0];\n-    let fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(ty::BareFnTy {\n+    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n         sig: ty::Binder(fn_sig),\n         unsafety: method_ty.fty.unsafety,\n         abi: method_ty.fty.abi.clone(),"}, {"sha": "a8fc411410567f6ac114201e7725d1e13bf6ab6e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -218,9 +218,8 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     match final_ty.sty {\n         ty::TyArray(elem_ty, _) => {\n-            let slice_ty = ty::mk_vec(fcx.tcx(), elem_ty, None);\n             steps.push(CandidateStep {\n-                self_ty: slice_ty,\n+                self_ty: fcx.tcx().mk_slice(elem_ty),\n                 autoderefs: dereferences,\n                 unsize: true\n             });\n@@ -984,7 +983,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         // Search through mutabilities in order to find one where pick works:\n         [ast::MutImmutable, ast::MutMutable].iter().filter_map(|&m| {\n-            let autoref_ty = ty::mk_rptr(tcx, region, ty::mt {\n+            let autoref_ty = tcx.mk_ref(region, ty::mt {\n                 ty: step.self_ty,\n                 mutbl: m\n             });"}, {"sha": "6826c33359aee2debae0abdc84dc24a46ca68f52", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 66, "deletions": 74, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -1377,7 +1377,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for (_, &mut ref ty) in &mut *self.inh.node_types.borrow_mut() {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n-                demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil(self.tcx()));\n+                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n             } else {\n                 match self.infcx().type_is_unconstrained_numeric(resolved) {\n                     UnconstrainedInt => {\n@@ -1557,7 +1557,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, ty::mk_nil(self.tcx()));\n+        self.write_ty(node_id, self.tcx().mk_nil());\n     }\n     pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx().types.err);\n@@ -2089,7 +2089,7 @@ fn lookup_indexing<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // After we have fully autoderef'd, if the resulting type is [T; n], then\n     // do a final unsized coercion to yield [T].\n     if let ty::TyArray(element_ty, _) = ty.sty {\n-        let adjusted_ty = ty::mk_vec(fcx.tcx(), element_ty, None);\n+        let adjusted_ty = fcx.tcx().mk_slice(element_ty);\n         try_index_step(fcx, MethodCall::expr(expr.id), expr, base_expr,\n                        adjusted_ty, autoderefs, true, lvalue_pref, idx_ty)\n     } else {\n@@ -2191,7 +2191,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let err_inputs = match tuple_arguments {\n             DontTupleArguments => err_inputs,\n-            TupleArguments => vec![ty::mk_tup(fcx.tcx(), err_inputs)],\n+            TupleArguments => vec![fcx.tcx().mk_tup(err_inputs)],\n         };\n \n         check_argument_types(fcx,\n@@ -2433,17 +2433,15 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        ast::LitStr(..) => ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic), ast::MutImmutable),\n+        ast::LitStr(..) => tcx.mk_static_str(),\n         ast::LitBinary(ref v) => {\n-            ty::mk_rptr(tcx, tcx.mk_region(ty::ReStatic), ty::mt {\n-                ty: ty::mk_vec(tcx, tcx.types.u8, Some(v.len())),\n-                mutbl: ast::MutImmutable,\n-            })\n+            tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n+                            tcx.mk_array(tcx.types.u8, v.len()))\n         }\n         ast::LitByte(_) => tcx.types.u8,\n         ast::LitChar(_) => tcx.types.char,\n-        ast::LitInt(_, ast::SignedIntLit(t, _)) => ty::mk_mach_int(tcx, t),\n-        ast::LitInt(_, ast::UnsignedIntLit(t)) => ty::mk_mach_uint(tcx, t),\n+        ast::LitInt(_, ast::SignedIntLit(t, _)) => tcx.mk_mach_int(t),\n+        ast::LitInt(_, ast::UnsignedIntLit(t)) => tcx.mk_mach_uint(t),\n         ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n             let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n@@ -2455,9 +2453,9 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             });\n             opt_ty.unwrap_or_else(\n-                || ty::mk_int_var(tcx, fcx.infcx().next_int_var_id()))\n+                || tcx.mk_int_var(fcx.infcx().next_int_var_id()))\n         }\n-        ast::LitFloat(_, t) => ty::mk_mach_float(tcx, t),\n+        ast::LitFloat(_, t) => tcx.mk_mach_float(t),\n         ast::LitFloatUnsuffixed(_) => {\n             let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n@@ -2466,7 +2464,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             });\n             opt_ty.unwrap_or_else(\n-                || ty::mk_float_var(tcx, fcx.infcx().next_float_var_id()))\n+                || tcx.mk_float_var(fcx.infcx().next_float_var_id()))\n         }\n         ast::LitBool(_) => tcx.types.bool\n     }\n@@ -2705,7 +2703,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                         infer::IfExpressionWithNoElse(sp),\n                                         false,\n                                         then_ty,\n-                                        ty::mk_nil(fcx.tcx()))\n+                                        fcx.tcx().mk_nil())\n             }\n         };\n \n@@ -2991,8 +2989,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         if !error_happened {\n-            fcx.write_ty(node_id, ty::mk_struct(fcx.ccx.tcx,\n-                                class_id, substitutions));\n+            fcx.write_ty(node_id, fcx.ccx.tcx.mk_struct(class_id, substitutions));\n         }\n     }\n \n@@ -3102,7 +3099,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                   let def_id = definition.def_id();\n                   let referent_ty = fcx.expr_ty(&**subexpr);\n                   if tcx.lang_items.exchange_heap() == Some(def_id) {\n-                      fcx.write_ty(id, ty::mk_uniq(tcx, referent_ty));\n+                      fcx.write_ty(id, tcx.mk_box(referent_ty));\n                       checked = true\n                   }\n               }\n@@ -3156,7 +3153,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         if !oprnd_t.references_error() {\n             match unop {\n                 ast::UnUniq => {\n-                    oprnd_t = ty::mk_uniq(tcx, oprnd_t);\n+                    oprnd_t = tcx.mk_box(oprnd_t);\n                 }\n                 ast::UnDeref => {\n                     oprnd_t = structurally_resolved_type(fcx, expr.span, oprnd_t);\n@@ -3247,7 +3244,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             // value whose address was taken can actually be made to live\n             // as long as it needs to live.\n             let region = fcx.infcx().next_region_var(infer::AddrOfRegion(expr.span));\n-            ty::mk_rptr(tcx, tcx.mk_region(region), tm)\n+            tcx.mk_ref(tcx.mk_region(region), tm)\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n@@ -3308,7 +3305,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 match *expr_opt {\n                     None =>\n                         if let Err(_) = fcx.mk_eqty(false, infer::Misc(expr.span),\n-                                                    result_type, ty::mk_nil(fcx.tcx())) {\n+                                                    result_type, fcx.tcx().mk_nil()) {\n                             span_err!(tcx.sess, expr.span, E0069,\n                                 \"`return;` in a function whose return type is \\\n                                  not `()`\");\n@@ -3463,7 +3460,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 t\n             }\n         };\n-        let typ = ty::mk_vec(tcx, typ, Some(args.len()));\n+        let typ = tcx.mk_array(typ, args.len());\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n@@ -3505,7 +3502,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         if element_ty.references_error() {\n             fcx.write_error(id);\n         } else {\n-            let t = ty::mk_vec(tcx, t, Some(count));\n+            let t = tcx.mk_array(t, count);\n             fcx.write_ty(id, t);\n         }\n       }\n@@ -3536,7 +3533,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         if err_field {\n             fcx.write_error(id);\n         } else {\n-            let typ = ty::mk_tup(tcx, elt_ts);\n+            let typ = tcx.mk_tup(elt_ts);\n             fcx.write_ty(id, typ);\n         }\n       }\n@@ -3712,7 +3709,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                      traits::ItemObligation(did)),\n                         &bounds);\n \n-                    ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n+                    tcx.mk_struct(did, tcx.mk_substs(substs))\n                 } else {\n                     span_err!(tcx.sess, expr.span, E0236, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n@@ -3722,7 +3719,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 // Neither start nor end => RangeFull\n                 if let Some(did) = tcx.lang_items.range_full_struct() {\n                     let substs = Substs::new_type(vec![], vec![]);\n-                    ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n+                    tcx.mk_struct(did, tcx.mk_substs(substs))\n                 } else {\n                     span_err!(tcx.sess, expr.span, E0237, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n@@ -3967,7 +3964,7 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx ast::Stmt)  {\n       ast::StmtExpr(ref expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n-        check_expr_has_type(fcx, &**expr, ty::mk_nil(fcx.tcx()));\n+        check_expr_has_type(fcx, &**expr, fcx.tcx().mk_nil());\n         let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot = saw_bot || fcx.infcx().type_var_diverges(expr_ty);\n         saw_err = saw_err || expr_ty.references_error();\n@@ -3993,12 +3990,12 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx ast::Stmt)  {\n }\n \n pub fn check_block_no_value<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, blk: &'tcx ast::Block)  {\n-    check_block_with_expected(fcx, blk, ExpectHasType(ty::mk_nil(fcx.tcx())));\n+    check_block_with_expected(fcx, blk, ExpectHasType(fcx.tcx().mk_nil()));\n     let blkty = fcx.node_ty(blk.id);\n     if blkty.references_error() {\n         fcx.write_error(blk.id);\n     } else {\n-        let nilty = ty::mk_nil(fcx.tcx());\n+        let nilty = fcx.tcx().mk_nil();\n         demand::suptype(fcx, blk.span, nilty, blkty);\n     }\n }\n@@ -4734,8 +4731,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let input_tys: Vec<Ty> =\n             data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n \n-        let tuple_ty =\n-            ty::mk_tup(fcx.tcx(), input_tys);\n+        let tuple_ty = fcx.tcx().mk_tup(input_tys);\n \n         if type_count >= 1 {\n             substs.types.push(space, tuple_ty);\n@@ -4745,7 +4741,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n \n         let output_ty =\n-            output_ty.unwrap_or(ty::mk_nil(fcx.tcx()));\n+            output_ty.unwrap_or(fcx.tcx().mk_nil());\n \n         if type_count >= 2 {\n             substs.types.push(space, output_ty);\n@@ -4952,7 +4948,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n         let name = token::intern(&format!(\"P{}\", n));\n-        ty::mk_param(ccx.tcx, subst::FnSpace, n, name)\n+        ccx.tcx.mk_param(subst::FnSpace, n, name)\n     }\n \n     let tcx = ccx.tcx;\n@@ -4963,22 +4959,22 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n \n         //We only care about the operation here\n         let (n_tps, inputs, output) = match split[1] {\n-            \"cxchg\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)),\n+            \"cxchg\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n                                 param(ccx, 0),\n                                 param(ccx, 0)),\n                         param(ccx, 0)),\n-            \"load\" => (1, vec!(ty::mk_imm_ptr(tcx, param(ccx, 0))),\n+            \"load\" => (1, vec!(tcx.mk_imm_ptr(param(ccx, 0))),\n                        param(ccx, 0)),\n-            \"store\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n-                        ty::mk_nil(tcx)),\n+            \"store\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n+                        tcx.mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n-                (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n+                (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n                  param(ccx, 0))\n             }\n             \"fence\" | \"singlethreadfence\" => {\n-                (0, Vec::new(), ty::mk_nil(tcx))\n+                (0, Vec::new(), tcx.mk_nil())\n             }\n             op => {\n                 span_err!(tcx.sess, it.span, E0092,\n@@ -4991,95 +4987,92 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         (0, Vec::new(), ty::FnDiverging)\n     } else {\n         let (n_tps, inputs, output) = match &name[..] {\n-            \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n+            \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n             \"size_of_val\" |  \"min_align_of_val\" => {\n                 (1, vec![\n-                    ty::mk_imm_rptr(tcx,\n-                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n                                     param(ccx, 0))\n                  ], ccx.tcx.types.usize)\n             }\n             \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n-            \"forget\" => (1, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n+            \"forget\" => (1, vec!( param(ccx, 0) ), tcx.mk_nil()),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n             \"move_val_init\" => {\n                 (1,\n                  vec!(\n-                    ty::mk_mut_rptr(tcx,\n-                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                    tcx.mk_mut_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n                                     param(ccx, 0)),\n                     param(ccx, 0)\n                   ),\n-               ty::mk_nil(tcx))\n+               tcx.mk_nil())\n             }\n             \"drop_in_place\" => {\n-                (1, vec![ty::mk_mut_ptr(tcx, param(ccx, 0))], ty::mk_nil(tcx))\n+                (1, vec![tcx.mk_mut_ptr(param(ccx, 0))], tcx.mk_nil())\n             }\n             \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n \n-            \"type_name\" => (1, Vec::new(), ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic),\n-                                                             ast::MutImmutable)),\n+            \"type_name\" => (1, Vec::new(), tcx.mk_static_str()),\n             \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n             \"offset\" | \"arith_offset\" => {\n               (1,\n                vec!(\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n                   ccx.tcx.types.isize\n                ),\n-               ty::mk_ptr(tcx, ty::mt {\n+               tcx.mk_ptr(ty::mt {\n                    ty: param(ccx, 0),\n                    mutbl: ast::MutImmutable\n                }))\n             }\n             \"copy\" | \"copy_nonoverlapping\" => {\n               (1,\n                vec!(\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n                   tcx.types.usize,\n                ),\n-               ty::mk_nil(tcx))\n+               tcx.mk_nil())\n             }\n             \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n               (1,\n                vec!(\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n                   tcx.types.usize,\n                ),\n-               ty::mk_nil(tcx))\n+               tcx.mk_nil())\n             }\n             \"write_bytes\" | \"volatile_set_memory\" => {\n               (1,\n                vec!(\n-                  ty::mk_ptr(tcx, ty::mt {\n+                  tcx.mk_ptr(ty::mt {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n                   tcx.types.u8,\n                   tcx.types.usize,\n                ),\n-               ty::mk_nil(tcx))\n+               tcx.mk_nil())\n             }\n             \"sqrtf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n             \"sqrtf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n@@ -5160,55 +5153,54 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"bswap64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n \n             \"volatile_load\" =>\n-                (1, vec!( ty::mk_imm_ptr(tcx, param(ccx, 0)) ), param(ccx, 0)),\n+                (1, vec!( tcx.mk_imm_ptr(param(ccx, 0)) ), param(ccx, 0)),\n             \"volatile_store\" =>\n-                (1, vec!( ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ), ty::mk_nil(tcx)),\n+                (1, vec!( tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0) ), tcx.mk_nil()),\n \n             \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.i8, tcx.types.i8),\n-                ty::mk_tup(tcx, vec!(tcx.types.i8, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.i8, tcx.types.bool))),\n \n             \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.i16, tcx.types.i16),\n-                ty::mk_tup(tcx, vec!(tcx.types.i16, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.i16, tcx.types.bool))),\n \n             \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.i32, tcx.types.i32),\n-                ty::mk_tup(tcx, vec!(tcx.types.i32, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.i32, tcx.types.bool))),\n \n             \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.i64, tcx.types.i64),\n-                ty::mk_tup(tcx, vec!(tcx.types.i64, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.i64, tcx.types.bool))),\n \n             \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.u8, tcx.types.u8),\n-                ty::mk_tup(tcx, vec!(tcx.types.u8, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.u8, tcx.types.bool))),\n \n             \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.u16, tcx.types.u16),\n-                ty::mk_tup(tcx, vec!(tcx.types.u16, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.u16, tcx.types.bool))),\n \n             \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n                 (0, vec!(tcx.types.u32, tcx.types.u32),\n-                ty::mk_tup(tcx, vec!(tcx.types.u32, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.u32, tcx.types.bool))),\n \n             \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n                 (0, vec!(tcx.types.u64, tcx.types.u64),\n-                ty::mk_tup(tcx, vec!(tcx.types.u64, tcx.types.bool))),\n+                tcx.mk_tup(vec!(tcx.types.u64, tcx.types.bool))),\n \n             \"unchecked_udiv\" | \"unchecked_sdiv\" | \"unchecked_urem\" | \"unchecked_srem\" =>\n                 (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n \n             \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n                 (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n \n-            \"return_address\" => (0, vec![], ty::mk_imm_ptr(tcx, tcx.types.u8)),\n+            \"return_address\" => (0, vec![], tcx.mk_imm_ptr(tcx.types.u8)),\n \n-            \"assume\" => (0, vec![tcx.types.bool], ty::mk_nil(tcx)),\n+            \"assume\" => (0, vec![tcx.types.bool], tcx.mk_nil()),\n \n             \"discriminant_value\" => (1, vec![\n-                    ty::mk_imm_rptr(tcx,\n-                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n                                                                   ty::BrAnon(0))),\n                                     param(ccx, 0))], tcx.types.u64),\n \n@@ -5220,7 +5212,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         };\n         (n_tps, inputs, ty::FnConverging(output))\n     };\n-    let fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(ty::BareFnTy {\n+    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: ast::Unsafety::Unsafe,\n         abi: abi::RustIntrinsic,\n         sig: ty::Binder(FnSig {"}, {"sha": "b41bb9feb5212ff1a659489a4a95c247c068e553", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -97,9 +97,9 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n             // && and || are a simple case.\n-            demand::suptype(fcx, lhs_expr.span, ty::mk_bool(tcx), lhs_ty);\n-            check_expr_coercable_to_type(fcx, rhs_expr, ty::mk_bool(tcx));\n-            fcx.write_ty(expr.id, ty::mk_bool(tcx));\n+            demand::suptype(fcx, lhs_expr.span, tcx.mk_bool(), lhs_ty);\n+            check_expr_coercable_to_type(fcx, rhs_expr, tcx.mk_bool());\n+            fcx.write_ty(expr.id, tcx.mk_bool());\n         }\n         _ => {\n             // Otherwise, we always treat operators as if they are\n@@ -148,9 +148,9 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.tcx();\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n-            demand::suptype(fcx, lhs_expr.span, ty::mk_bool(tcx), lhs_ty);\n-            demand::suptype(fcx, rhs_expr.span, ty::mk_bool(tcx), rhs_ty);\n-            ty::mk_bool(tcx)\n+            demand::suptype(fcx, lhs_expr.span, tcx.mk_bool(), lhs_ty);\n+            demand::suptype(fcx, rhs_expr.span, tcx.mk_bool(), rhs_ty);\n+            tcx.mk_bool()\n         }\n \n         BinOpCategory::Shift => {\n@@ -193,7 +193,7 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     lhs_ty\n                 }\n             } else {\n-                ty::mk_bool(tcx)\n+                tcx.mk_bool()\n             }\n         }\n     }"}, {"sha": "c659357dd0305ae3769d0afb00e26e8933122be0", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -1520,7 +1520,7 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n     debug!(\"projection_bounds(projection_ty={:?})\",\n            projection_ty);\n \n-    let ty = ty::mk_projection(tcx, projection_ty.trait_ref.clone(), projection_ty.item_name);\n+    let ty = tcx.mk_projection(projection_ty.trait_ref.clone(), projection_ty.item_name);\n \n     // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n     // in looking for a trait definition like:"}, {"sha": "266babda57824b836db5644631466c6dede43980", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -210,8 +210,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             // impl, plus its own.\n             let new_polytype = ty::TypeScheme {\n                 generics: new_method_ty.generics.clone(),\n-                ty: ty::mk_bare_fn(tcx, Some(new_did),\n-                                   tcx.mk_bare_fn(new_method_ty.fty.clone()))\n+                ty: tcx.mk_fn(Some(new_did),\n+                              tcx.mk_bare_fn(new_method_ty.fty.clone()))\n             };\n             debug!(\"new_polytype={:?}\", new_polytype);\n \n@@ -468,12 +468,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n                 (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n                     infer::mk_subr(&infcx, infer::RelateObjectBound(span), *r_b, *r_a);\n-                    check_mutbl(mt_a, mt_b, &|ty| ty::mk_imm_rptr(tcx, r_b, ty))\n+                    check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n                 }\n \n                 (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n                 (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n-                    check_mutbl(mt_a, mt_b, &|ty| ty::mk_imm_ptr(tcx, ty))\n+                    check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n                 }\n \n                 (&ty::TyStruct(def_id_a, substs_a), &ty::TyStruct(def_id_b, substs_b)) => {"}, {"sha": "4c550e5d44ae429559554b076f9e8de94fd05e16", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -416,7 +416,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n                     item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n-        ty::mk_projection(self.tcx(), trait_ref, item_name)\n+        self.tcx().mk_projection(trait_ref, item_name)\n     }\n }\n \n@@ -508,7 +508,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n         // `where T:Foo`.\n \n         let def = astconv.tcx().type_parameter_def(node_id);\n-        let ty = ty::mk_param_from_def(astconv.tcx(), &def);\n+        let ty = astconv.tcx().mk_param_from_def(&def);\n \n         let from_ty_params =\n             self.ty_params\n@@ -577,7 +577,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ast::TupleVariantKind(ref args) if !args.is_empty() => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys, enum_scheme.ty)\n+                tcx.mk_ctor_fn(variant_def_id, &input_tys, enum_scheme.ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -631,8 +631,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     container,\n                                     None);\n \n-    let fty = ty::mk_bare_fn(ccx.tcx, Some(def_id),\n-                             ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n+    let fty = ccx.tcx.mk_fn(Some(def_id),\n+                            ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n     debug!(\"method {} (id {}) has type {:?}\",\n             ident, id, fty);\n     ccx.tcx.tcache.borrow_mut().insert(def_id,TypeScheme {\n@@ -995,7 +995,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n                             methods,\n-                            ty::mk_self_type(tcx),\n+                            tcx.mk_self_type(),\n                             &trait_def.generics,\n                             &trait_predicates);\n \n@@ -1026,7 +1026,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 check_method_self_type(ccx,\n                                        &BindingRscope::new(),\n                                        ccx.method_ty(trait_item.id),\n-                                       ty::mk_self_type(tcx),\n+                                       tcx.mk_self_type(),\n                                        &sig.explicit_self,\n                                        it.id)\n             }\n@@ -1088,7 +1088,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n     let substs = mk_item_substs(ccx, &scheme.generics);\n-    let selfty = ty::mk_struct(tcx, local_def(id), tcx.mk_substs(substs));\n+    let selfty = tcx.mk_struct(local_def(id), tcx.mk_substs(substs));\n \n     // If this struct is enum-like or tuple-like, create the type of its\n     // constructor.\n@@ -1110,8 +1110,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                               .unwrap()\n                                                               .ty)\n                               .collect();\n-                let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n-                                                local_def(ctor_id),\n+                let ctor_fn_ty = tcx.mk_ctor_fn(local_def(ctor_id),\n                                                 &inputs[..],\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n@@ -1177,7 +1176,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         let scope = &(generics, &self_predicate);\n \n         // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n-        let self_param_ty = ty::mk_self_type(tcx);\n+        let self_param_ty = tcx.mk_self_type();\n         let superbounds1 = compute_bounds(&ccx.icx(scope),\n                                     self_param_ty,\n                                     bounds,\n@@ -1295,12 +1294,12 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             generics.ty_params\n                     .iter()\n                     .enumerate()\n-                    .map(|(i, def)| ty::mk_param(tcx, TypeSpace,\n+                    .map(|(i, def)| tcx.mk_param(TypeSpace,\n                                                  i as u32, def.ident.name))\n                     .collect();\n \n         // ...and also create the `Self` parameter.\n-        let self_ty = ty::mk_self_type(tcx);\n+        let self_ty = tcx.mk_self_type();\n \n         Substs::new_trait(types, regions, self_ty)\n     }\n@@ -1389,9 +1388,8 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                 }\n             };\n \n-            let assoc_ty = ty::mk_projection(ccx.tcx,\n-                                             self_trait_ref,\n-                                             trait_item.ident.name);\n+            let assoc_ty = ccx.tcx.mk_projection(self_trait_ref,\n+                                                 trait_item.ident.name);\n \n             let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n                                         assoc_ty,\n@@ -1450,7 +1448,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         ast::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &**decl);\n-            let ty = ty::mk_bare_fn(tcx, Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n+            let ty = tcx.mk_fn(Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemTy(ref t, ref generics) => {\n@@ -1462,13 +1460,13 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             // Create a new generic polytype.\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = ty::mk_enum(tcx, local_def(it.id), tcx.mk_substs(substs));\n+            let t = tcx.mk_enum(local_def(it.id), tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         ast::ItemStruct(_, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = ty::mk_struct(tcx, local_def(it.id), tcx.mk_substs(substs));\n+            let t = tcx.mk_struct(local_def(it.id), tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         ast::ItemDefaultImpl(..) |\n@@ -2121,14 +2119,12 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n         ast::Return(ref ty) =>\n             ty::FnConverging(ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &**ty)),\n         ast::DefaultReturn(..) =>\n-            ty::FnConverging(ty::mk_nil(ccx.tcx)),\n+            ty::FnConverging(ccx.tcx.mk_nil()),\n         ast::NoReturn(..) =>\n             ty::FnDiverging\n     };\n \n-    let t_fn = ty::mk_bare_fn(\n-        ccx.tcx,\n-        None,\n+    let t_fn = ccx.tcx.mk_fn(None,\n         ccx.tcx.mk_bare_fn(ty::BareFnTy {\n             abi: abi,\n             unsafety: ast::Unsafety::Unsafe,\n@@ -2149,7 +2145,7 @@ fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n {\n     let types =\n         ty_generics.types.map(\n-            |def| ty::mk_param_from_def(ccx.tcx, def));\n+            |def| ccx.tcx.mk_param_from_def(def));\n \n     let regions =\n         ty_generics.regions.map("}, {"sha": "34f166e0e0dfb51bea42148c7bcceaaeb9b9fea6", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db5126240b6420630553b930417fca10986d75d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6db5126240b6420630553b930417fca10986d75d", "patch": "@@ -226,12 +226,12 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 }\n                 _ => ()\n             }\n-            let se_ty = ty::mk_bare_fn(tcx, Some(local_def(main_id)), tcx.mk_bare_fn(ty::BareFnTy {\n+            let se_ty = tcx.mk_fn(Some(local_def(main_id)), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: Vec::new(),\n-                    output: ty::FnConverging(ty::mk_nil(tcx)),\n+                    output: ty::FnConverging(tcx.mk_nil()),\n                     variadic: false\n                 })\n             }));\n@@ -272,13 +272,13 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n \n-            let se_ty = ty::mk_bare_fn(tcx, Some(local_def(start_id)), tcx.mk_bare_fn(ty::BareFnTy {\n+            let se_ty = tcx.mk_fn(Some(local_def(start_id)), tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: vec!(\n                         tcx.types.isize,\n-                        ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, tcx.types.u8))\n+                        tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))\n                     ),\n                     output: ty::FnConverging(tcx.types.isize),\n                     variadic: false,"}]}