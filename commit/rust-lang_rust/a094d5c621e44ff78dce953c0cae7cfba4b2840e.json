{"sha": "a094d5c621e44ff78dce953c0cae7cfba4b2840e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOTRkNWM2MjFlNDRmZjc4ZGNlOTUzYzBjYWU3Y2ZiYTRiMjg0MGU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-23T12:49:31Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-23T12:49:31Z"}, "message": "Merge #1147\n\n1147: Handle macros in type checking / HIR r=matklad a=Lapz\n\nAn other attempt at  #1102. I will need to flatten the nested if statements and im also not sure if the way that i get the resolver and module will always work\n\nCo-authored-by: Lenard Pratt <l3np27@gmail.com>", "tree": {"sha": "93d12337483968512db038b0b89aff7b9ef4eb20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93d12337483968512db038b0b89aff7b9ef4eb20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a094d5c621e44ff78dce953c0cae7cfba4b2840e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a094d5c621e44ff78dce953c0cae7cfba4b2840e", "html_url": "https://github.com/rust-lang/rust/commit/a094d5c621e44ff78dce953c0cae7cfba4b2840e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a094d5c621e44ff78dce953c0cae7cfba4b2840e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "e2835b46f6928eda21b7edb44f305f20473a3a98", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2835b46f6928eda21b7edb44f305f20473a3a98", "html_url": "https://github.com/rust-lang/rust/commit/e2835b46f6928eda21b7edb44f305f20473a3a98"}, {"sha": "1ab7066e32ab482c70ea5c9bba7585eba275476a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ab7066e32ab482c70ea5c9bba7585eba275476a", "html_url": "https://github.com/rust-lang/rust/commit/1ab7066e32ab482c70ea5c9bba7585eba275476a"}], "stats": {"total": 148, "additions": 133, "deletions": 15}, "files": [{"sha": "db74d28e8e4d3e3624dbbd257e3c31d5ba5a3e7f", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=a094d5c621e44ff78dce953c0cae7cfba4b2840e", "patch": "@@ -5,13 +5,14 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_syntax::{\n-    SyntaxNodePtr, AstPtr, AstNode,\n+    SyntaxNodePtr, AstPtr, AstNode,TreeArc,\n     ast::{self, LoopBodyOwner, ArgListOwner, NameOwner, LiteralKind,ArrayExprKind, TypeAscriptionOwner}\n };\n \n use crate::{\n     Path, Name, HirDatabase, Resolver,DefWithBody, Either,\n     name::AsName,\n+    ids::{MacroCallId},\n     type_ref::{Mutability, TypeRef},\n };\n use crate::{path::GenericArgs, ty::primitive::{IntTy, UncertainIntTy, FloatTy, UncertainFloatTy}};\n@@ -478,38 +479,54 @@ impl Pat {\n \n // Queries\n \n-pub(crate) struct ExprCollector {\n+pub(crate) struct ExprCollector<DB> {\n+    db: DB,\n     owner: DefWithBody,\n     exprs: Arena<ExprId, Expr>,\n     pats: Arena<PatId, Pat>,\n     source_map: BodySourceMap,\n     params: Vec<PatId>,\n     body_expr: Option<ExprId>,\n+    resolver: Resolver,\n+    // FIXEME: Its a quick hack,see issue #1196\n+    is_in_macro: bool,\n }\n \n-impl ExprCollector {\n-    fn new(owner: DefWithBody) -> Self {\n+impl<'a, DB> ExprCollector<&'a DB>\n+where\n+    DB: HirDatabase,\n+{\n+    fn new(owner: DefWithBody, resolver: Resolver, db: &'a DB) -> Self {\n         ExprCollector {\n             owner,\n+            resolver,\n+            db,\n             exprs: Arena::default(),\n             pats: Arena::default(),\n             source_map: BodySourceMap::default(),\n             params: Vec::new(),\n             body_expr: None,\n+            is_in_macro: false,\n         }\n     }\n-\n     fn alloc_expr(&mut self, expr: Expr, syntax_ptr: SyntaxNodePtr) -> ExprId {\n         let id = self.exprs.alloc(expr);\n-        self.source_map.expr_map.insert(syntax_ptr, id);\n-        self.source_map.expr_map_back.insert(id, syntax_ptr);\n+        if !self.is_in_macro {\n+            self.source_map.expr_map.insert(syntax_ptr, id);\n+            self.source_map.expr_map_back.insert(id, syntax_ptr);\n+        }\n+\n         id\n     }\n \n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n         let id = self.pats.alloc(pat);\n-        self.source_map.pat_map.insert(ptr, id);\n-        self.source_map.pat_map_back.insert(id, ptr);\n+\n+        if !self.is_in_macro {\n+            self.source_map.pat_map.insert(ptr, id);\n+            self.source_map.pat_map_back.insert(id, ptr);\n+        }\n+\n         id\n     }\n \n@@ -794,7 +811,26 @@ impl ExprCollector {\n             ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::ExprKind::MacroCall(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::ExprKind::MacroCall(e) => {\n+                // very hacky.FIXME change to use the macro resolution\n+                let path = e.path().and_then(Path::from_ast);\n+\n+                if let Some(call_id) = self.resolver.resolve_macro_call(self.db, path, e) {\n+                    if let Some(expr) = expand_macro_to_expr(self.db, call_id, e.token_tree()) {\n+                        log::debug!(\"macro expansion {}\", expr.syntax().debug_dump());\n+                        let old = std::mem::replace(&mut self.is_in_macro, true);\n+                        let id = self.collect_expr(&expr);\n+                        self.is_in_macro = old;\n+                        id\n+                    } else {\n+                        // FIXME: Instead of just dropping the error from expansion\n+                        // report it\n+                        self.alloc_expr(Expr::Missing, syntax_ptr)\n+                    }\n+                } else {\n+                    self.alloc_expr(Expr::Missing, syntax_ptr)\n+                }\n+            }\n         }\n     }\n \n@@ -952,11 +988,25 @@ impl ExprCollector {\n     }\n }\n \n+fn expand_macro_to_expr(\n+    db: &impl HirDatabase,\n+    macro_call: MacroCallId,\n+    args: Option<&ast::TokenTree>,\n+) -> Option<TreeArc<ast::Expr>> {\n+    let rules = db.macro_def(macro_call.loc(db).def)?;\n+\n+    let args = mbe::ast_to_token_tree(args?)?.0;\n+\n+    let expanded = rules.expand(&args).ok()?;\n+\n+    mbe::token_tree_to_expr(&expanded).ok()\n+}\n+\n pub(crate) fn body_with_source_map_query(\n     db: &impl HirDatabase,\n     def: DefWithBody,\n ) -> (Arc<Body>, Arc<BodySourceMap>) {\n-    let mut collector = ExprCollector::new(def);\n+    let mut collector = ExprCollector::new(def, def.resolver(db), db);\n \n     match def {\n         DefWithBody::Const(ref c) => collector.collect_const_body(&c.source(db).1),"}, {"sha": "a450d7b843e4d603eb5e17d7ba6f6d7e1ba8248c", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=a094d5c621e44ff78dce953c0cae7cfba4b2840e", "patch": "@@ -104,6 +104,7 @@ pub struct CrateDefMap {\n     /// However, do we want to put it as a global variable?\n     poison_macros: FxHashSet<MacroDefId>,\n \n+    local_macros: FxHashMap<Name, MacroDefId>,\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n@@ -209,6 +210,7 @@ impl CrateDefMap {\n                 modules,\n                 public_macros: FxHashMap::default(),\n                 poison_macros: FxHashSet::default(),\n+                local_macros: FxHashMap::default(),\n                 diagnostics: Vec::new(),\n             }\n         };\n@@ -270,6 +272,10 @@ impl CrateDefMap {\n         (res.resolved_def, res.segment_index)\n     }\n \n+    pub(crate) fn find_macro(&self, name: &Name) -> Option<&MacroDefId> {\n+        self.public_macros.get(name).or(self.local_macros.get(name))\n+    }\n+\n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n     // the result.\n     fn resolve_path_fp("}, {"sha": "b34c9b8e69702a79a79e61f06debe712e016fbdb", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=a094d5c621e44ff78dce953c0cae7cfba4b2840e", "patch": "@@ -131,6 +131,8 @@ where\n     fn define_macro(&mut self, name: Name, macro_id: MacroDefId, export: bool) {\n         if export {\n             self.def_map.public_macros.insert(name.clone(), macro_id);\n+        } else {\n+            self.def_map.local_macros.insert(name.clone(), macro_id);\n         }\n         self.global_macro_scope.insert(name, macro_id);\n     }\n@@ -517,12 +519,12 @@ where\n \n         // Case 2: try to expand macro_rules from this crate, triggering\n         // recursive item collection.\n-        if let Some(&macro_id) =\n-            mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n+        if let Some(macro_id) =\n+            mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(&name))\n         {\n-            let macro_call_id = MacroCallLoc { def: macro_id, ast_id }.id(self.def_collector.db);\n+            let macro_call_id = MacroCallLoc { def: *macro_id, ast_id }.id(self.def_collector.db);\n \n-            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_id);\n+            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, *macro_id);\n             return;\n         }\n \n@@ -614,6 +616,7 @@ mod tests {\n                 modules,\n                 public_macros: FxHashMap::default(),\n                 poison_macros: FxHashSet::default(),\n+                local_macros: FxHashMap::default(),\n                 diagnostics: Vec::new(),\n             }\n         };"}, {"sha": "1b129c752bef257114818d3eb3a47754fbf23841", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=a094d5c621e44ff78dce953c0cae7cfba4b2840e", "patch": "@@ -126,6 +126,10 @@ impl Path {\n         }\n         self.segments.first().map(|s| &s.name)\n     }\n+\n+    pub fn expand_macro_expr(&self) -> Option<Name> {\n+        self.as_ident().and_then(|name| Some(name.clone()))\n+    }\n }\n \n impl GenericArgs {"}, {"sha": "d1f97c1047b3394cf1efbe483cedf3baffdc1346", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=a094d5c621e44ff78dce953c0cae7cfba4b2840e", "patch": "@@ -1,11 +1,15 @@\n //! Name resolution.\n use std::sync::Arc;\n \n+use ra_syntax::ast;\n+\n use rustc_hash::FxHashMap;\n \n use crate::{\n     ModuleDef,\n     code_model_api::Crate,\n+    MacroCallId,\n+    MacroCallLoc,\n     db::HirDatabase,\n     name::{Name, KnownName},\n     nameres::{PerNs, CrateDefMap, CrateModuleId},\n@@ -130,6 +134,31 @@ impl Resolver {\n         resolution\n     }\n \n+    pub fn resolve_macro_call(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: Option<Path>,\n+        call: &ast::MacroCall,\n+    ) -> Option<MacroCallId> {\n+        let name = path.and_then(|path| path.expand_macro_expr()).unwrap_or_else(Name::missing);\n+        let macro_def_id = self.module().and_then(|(module, _)| module.find_macro(&name));\n+        if let Some(def_id) = macro_def_id {\n+            self.module().and_then(|(module, _)| {\n+                // we do this to get the ast_id for the macro call\n+                // if we used the ast_id from the def_id variable\n+                // it gives us the ast_id of the defenition site\n+                let module = module.mk_module(module.root());\n+                let hir_file_id = module.definition_source(db).0;\n+                let ast_id = db.ast_id_map(hir_file_id).ast_id(call).with_file_id(hir_file_id);\n+                let call_loc = MacroCallLoc { def: *def_id, ast_id }.id(db);\n+\n+                Some(call_loc)\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Returns the resolved path segments\n     /// Which may be fully resolved, empty or partially resolved.\n     pub(crate) fn resolve_path_segments(&self, db: &impl HirDatabase, path: &Path) -> PathResult {"}, {"sha": "c76a5012f07ee108ddf5d054cb83cc29aeb1d198", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a094d5c621e44ff78dce953c0cae7cfba4b2840e/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=a094d5c621e44ff78dce953c0cae7cfba4b2840e", "patch": "@@ -2417,6 +2417,30 @@ fn test() -> u64 {\n     );\n }\n \n+#[test]\n+fn infer_macros_expanded() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+struct Foo(Vec<i32>);\n+\n+macro_rules! foo {\n+    ($($item:expr),*) => {\n+            {\n+                Foo(vec![$($item,)*])\n+            }\n+    };\n+}\n+\n+fn main() {\n+    let x = foo!(1,2);\n+}\n+\"#),\n+        @r###\"\n+[156; 182) '{     ...,2); }': ()\n+[166; 167) 'x': Foo\"###\n+    );\n+}\n+\n #[ignore]\n #[test]\n fn method_resolution_trait_before_autoref() {\n@@ -2510,6 +2534,7 @@ fn type_at(content: &str) -> String {\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.parse(file_id);\n+\n     let mut acc = String::new();\n     acc.push_str(\"\\n\");\n \n@@ -2532,6 +2557,7 @@ fn infer(content: &str) -> String {\n             };\n             types.push((syntax_ptr, ty));\n         }\n+\n         // sort ranges for consistency\n         types.sort_by_key(|(ptr, _)| (ptr.range().start(), ptr.range().end()));\n         for (syntax_ptr, ty) in &types {"}]}