{"sha": "3e05f80a3790bb96247e9325fe54e484086f77f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMDVmODBhMzc5MGJiOTYyNDdlOTMyNWZlNTRlNDg0MDg2Zjc3ZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-14T04:22:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-14T04:22:14Z"}, "message": "Auto merge of #52923 - eddyb:relative-imports, r=petrochenkov\n\n#[feature(uniform_paths)]: allow `use x::y;` to resolve through `self::x`, not just `::x`.\n\n_Branch originally by @cramertj, based on @petrochenkov's [description on the internals forum](https://internals.rust-lang.org/t/relative-paths-in-rust-2018/7883/30?u=petrochenkov)._\n_(note, however, that the approach has significantly changed since)_\n\nImplements `#[feature(uniform_paths)]` from #53130, by treating unqualified `use` paths as maybe-relative. That is, `use x::y;`, where `x` is a plain identifier (not a keyword), is no longer the same as `use ::x::y;`, and before picking an external crate named `x`, it first looks for an item named `x` in the same module (i.e. `self::x`) and prefers that local item instead.\n\nSuch a \"maybe-relative\" `x` can only resolve to an external crate if it's listed in \"`extern_prelude`\" (i.e. `core` / `std` and all the crates passed to `--extern`; the latter includes Cargo dependencies) - this is the same condition as being able to refer to the external crate from an unqualified, non-`use` path.\nAll other crates must be explicitly imported with an absolute path, e.g. `use ::x::y;`\n\nTo detect an ambiguity between the external crate and the local item with the same name, a \"canary\" import (e.g. `use self::x as _;`), tagged with the `is_uniform_paths_canary` flag, is injected. As the initial implementation is not sophisticated enough to handle all possible ways in which `self::x` could appear (e.g. from macro expansion), this also guards against accidentally picking the external crate, when it might actually get \"shadowed\" later.\nAlso, more canaries are injected for each block scope around the `use`, as `self::x` cannot resolve to any items named `x` in those scopes, but non-`use` paths can, and that could be confusing or even backwards-incompatible.\n\nErrors are emitted only if the main \"canary\" import succeeds while an external crate exists (or if any of the block-scoped ones succeed at all), and ambiguities have custom error reporting, e.g.:\n```rust\n#![feature(uniform_paths)]\npub mod foo {\n    use std::io;\n    pub mod std { pub mod io {} }\n}\n```\n```rust\nerror: import from `std` is ambiguous\n --> test.rs:3:9\n  |\n3 |     use std::io;\n  |         ^^^ could refer to external crate `::std`\n4 |     pub mod std { pub mod io {} }\n  |     ----------------------------- could also refer to `self::std`\n  |\n  = help: write `::std` or `self::std` explicitly instead\n  = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n```\nAnother example, this time with a block-scoped item shadowing a module-scoped one:\n```rust\n#![feature(uniform_paths)]\nenum Foo { A, B }\nfn main() {\n    enum Foo {}\n    use Foo::*;\n}\n```\n```rust\nerror: import from `Foo` is ambiguous\n --> test.rs:5:9\n  |\n4 |     enum Foo {}\n  |     ----------- shadowed by block-scoped `Foo`\n5 |     use Foo::*;\n  |         ^^^\n  |\n  = help: write `::Foo` or `self::Foo` explicitly instead\n  = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n```\n\nAdditionally, this PR, because replacing \"the `finalize_import` hack\" was a blocker:\n* fixes #52140\n* fixes #52141\n* fixes #52705\n\ncc @aturon @joshtriplett", "tree": {"sha": "1e7fdb011323c7e175d76fa1a690386e06ffb274", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e7fdb011323c7e175d76fa1a690386e06ffb274"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e05f80a3790bb96247e9325fe54e484086f77f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e05f80a3790bb96247e9325fe54e484086f77f5", "html_url": "https://github.com/rust-lang/rust/commit/3e05f80a3790bb96247e9325fe54e484086f77f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e05f80a3790bb96247e9325fe54e484086f77f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5a448b3f47b22c9cb010198bdcc49d4392b090b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5a448b3f47b22c9cb010198bdcc49d4392b090b", "html_url": "https://github.com/rust-lang/rust/commit/d5a448b3f47b22c9cb010198bdcc49d4392b090b"}, {"sha": "13bc0b5a48aff52e828b6b645b166ccfa56e7681", "url": "https://api.github.com/repos/rust-lang/rust/commits/13bc0b5a48aff52e828b6b645b166ccfa56e7681", "html_url": "https://github.com/rust-lang/rust/commit/13bc0b5a48aff52e828b6b645b166ccfa56e7681"}], "stats": {"total": 1566, "additions": 1295, "deletions": 271}, "files": [{"sha": "ee98cc6cf927e1d31c9212340f75dd09d9e8f476", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -865,7 +865,7 @@ where\n \n     krate = time(sess, \"crate injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n-        syntax::std_inject::maybe_inject_crates_ref(krate, alt_std_name)\n+        syntax::std_inject::maybe_inject_crates_ref(krate, alt_std_name, sess.edition())\n     });\n \n     let mut addl_plugins = Some(addl_plugins);"}, {"sha": "a10bb3e25df656208f111dd80cdf57e72f62ad5a", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -1139,32 +1139,4 @@ impl<'a> CrateLoader<'a> {\n \n         cnum\n     }\n-\n-    pub fn process_use_extern(\n-        &mut self,\n-        name: Symbol,\n-        span: Span,\n-        id: ast::NodeId,\n-        definitions: &Definitions,\n-    ) -> CrateNum {\n-        let cnum = self.resolve_crate(\n-            &None, name, name, None, None, span, PathKind::Crate, DepKind::Explicit\n-        ).0;\n-\n-        let def_id = definitions.opt_local_def_id(id).unwrap();\n-        let path_len = definitions.def_path(def_id.index).data.len();\n-\n-        self.update_extern_crate(\n-            cnum,\n-            ExternCrate {\n-                src: ExternCrateSource::Use,\n-                span,\n-                path_len,\n-                direct: true,\n-            },\n-            &mut FxHashSet(),\n-        );\n-\n-        cnum\n-    }\n }"}, {"sha": "fa2af891f109b86770589ecda50eb36dbdac87b7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 183, "deletions": 24, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -17,7 +17,7 @@ use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n-use {PerNS, Resolver, ResolverArenas};\n+use {ModuleOrUniformRoot, PerNS, Resolver, ResolverArenas};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n@@ -113,16 +113,24 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n     }\n \n-    fn build_reduced_graph_for_use_tree(&mut self,\n-                                        root_use_tree: &ast::UseTree,\n-                                        root_id: NodeId,\n-                                        use_tree: &ast::UseTree,\n-                                        id: NodeId,\n-                                        vis: ty::Visibility,\n-                                        prefix: &ast::Path,\n-                                        nested: bool,\n-                                        item: &Item,\n-                                        expansion: Mark) {\n+    fn build_reduced_graph_for_use_tree(\n+        &mut self,\n+        root_use_tree: &ast::UseTree,\n+        root_id: NodeId,\n+        use_tree: &ast::UseTree,\n+        id: NodeId,\n+        vis: ty::Visibility,\n+        prefix: &ast::Path,\n+        mut uniform_paths_canary_emitted: bool,\n+        nested: bool,\n+        item: &Item,\n+        expansion: Mark,\n+    ) {\n+        debug!(\"build_reduced_graph_for_use_tree(prefix={:?}, \\\n+                uniform_paths_canary_emitted={}, \\\n+                use_tree={:?}, nested={})\",\n+               prefix, uniform_paths_canary_emitted, use_tree, nested);\n+\n         let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n         let path = &use_tree.prefix;\n \n@@ -131,6 +139,103 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             .map(|seg| seg.ident)\n             .collect();\n \n+        debug!(\"build_reduced_graph_for_use_tree: module_path={:?}\", module_path);\n+\n+        // `#[feature(uniform_paths)]` allows an unqualified import path,\n+        // e.g. `use x::...;` to resolve not just globally (`use ::x::...;`)\n+        // but also relatively (`use self::x::...;`). To catch ambiguities\n+        // that might arise from both of these being available and resolution\n+        // silently picking one of them, an artificial `use self::x as _;`\n+        // import is injected as a \"canary\", and an error is emitted if it\n+        // successfully resolves while an `x` external crate exists.\n+        //\n+        // For each block scope around the `use` item, one special canary\n+        // import of the form `use x as _;` is also injected, having its\n+        // parent set to that scope; `resolve_imports` will only resolve\n+        // it within its appropriate scope; if any of them successfully\n+        // resolve, an ambiguity error is emitted, since the original\n+        // import can't see the item in the block scope (`self::x` only\n+        // looks in the enclosing module), but a non-`use` path could.\n+        //\n+        // Additionally, the canary might be able to catch limitations of the\n+        // current implementation, where `::x` may be chosen due to `self::x`\n+        // not existing, but `self::x` could appear later, from macro expansion.\n+        //\n+        // NB. The canary currently only errors if the `x::...` path *could*\n+        // resolve as a relative path through the extern crate, i.e. `x` is\n+        // in `extern_prelude`, *even though* `::x` might still forcefully\n+        // load a non-`extern_prelude` crate.\n+        // While always producing an ambiguity errors if `self::x` exists and\n+        // a crate *could* be loaded, would be more conservative, imports for\n+        // local modules named `test` (or less commonly, `syntax` or `log`),\n+        // would need to be qualified (e.g. `self::test`), which is considered\n+        // ergonomically unacceptable.\n+        let emit_uniform_paths_canary =\n+            !uniform_paths_canary_emitted &&\n+            module_path.get(0).map_or(false, |ident| {\n+                !ident.is_path_segment_keyword()\n+            });\n+        if emit_uniform_paths_canary {\n+            // Relative paths should only get here if the feature-gate is on.\n+            assert!(self.session.rust_2018() &&\n+                    self.session.features_untracked().uniform_paths);\n+\n+            let source = module_path[0];\n+            // Helper closure to emit a canary with the given base path.\n+            let emit = |this: &mut Self, base: Option<Ident>| {\n+                let subclass = SingleImport {\n+                    target: Ident {\n+                        name: keywords::Underscore.name().gensymed(),\n+                        span: source.span,\n+                    },\n+                    source,\n+                    result: PerNS {\n+                        type_ns: Cell::new(Err(Undetermined)),\n+                        value_ns: Cell::new(Err(Undetermined)),\n+                        macro_ns: Cell::new(Err(Undetermined)),\n+                    },\n+                    type_ns_only: false,\n+                };\n+                this.add_import_directive(\n+                    base.into_iter().collect(),\n+                    subclass.clone(),\n+                    source.span,\n+                    id,\n+                    root_use_tree.span,\n+                    root_id,\n+                    ty::Visibility::Invisible,\n+                    expansion,\n+                    true, // is_uniform_paths_canary\n+                );\n+            };\n+\n+            // A single simple `self::x` canary.\n+            emit(self, Some(Ident {\n+                name: keywords::SelfValue.name(),\n+                span: source.span,\n+            }));\n+\n+            // One special unprefixed canary per block scope around\n+            // the import, to detect items unreachable by `self::x`.\n+            let orig_current_module = self.current_module;\n+            let mut span = source.span.modern();\n+            loop {\n+                match self.current_module.kind {\n+                    ModuleKind::Block(..) => emit(self, None),\n+                    ModuleKind::Def(..) => break,\n+                }\n+                match self.hygienic_lexical_parent(self.current_module, &mut span) {\n+                    Some(module) => {\n+                        self.current_module = module;\n+                    }\n+                    None => break,\n+                }\n+            }\n+            self.current_module = orig_current_module;\n+\n+            uniform_paths_canary_emitted = true;\n+        }\n+\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n                 let mut ident = use_tree.ident();\n@@ -142,8 +247,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if source.name == keywords::SelfValue.name() {\n                         type_ns_only = true;\n \n-                        let last_segment = *module_path.last().unwrap();\n-                        if last_segment.name == keywords::CrateRoot.name() {\n+                        let empty_prefix = module_path.last().map_or(true, |ident| {\n+                            ident.name == keywords::CrateRoot.name()\n+                        });\n+                        if empty_prefix {\n                             resolve_error(\n                                 self,\n                                 use_tree.span,\n@@ -154,10 +261,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         }\n \n                         // Replace `use foo::self;` with `use foo;`\n-                        let _ = module_path.pop();\n-                        source = last_segment;\n+                        source = module_path.pop().unwrap();\n                         if rename.is_none() {\n-                            ident = last_segment;\n+                            ident = source;\n                         }\n                     }\n                 } else {\n@@ -169,13 +275,23 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n \n                     // Disallow `use $crate;`\n-                    if source.name == keywords::DollarCrate.name() && path.segments.len() == 1 {\n+                    if source.name == keywords::DollarCrate.name() && module_path.is_empty() {\n                         let crate_root = self.resolve_crate_root(source);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(_, name) => name,\n                             ModuleKind::Block(..) => unreachable!(),\n                         };\n-                        source.name = crate_name;\n+                        // HACK(eddyb) unclear how good this is, but keeping `$crate`\n+                        // in `source` breaks `src/test/compile-fail/import-crate-var.rs`,\n+                        // while the current crate doesn't have a valid `crate_name`.\n+                        if crate_name != keywords::Invalid.name() {\n+                            // `crate_name` should not be interpreted as relative.\n+                            module_path.push(Ident {\n+                                name: keywords::CrateRoot.name(),\n+                                span: source.span,\n+                            });\n+                            source.name = crate_name;\n+                        }\n                         if rename.is_none() {\n                             ident.name = crate_name;\n                         }\n@@ -187,6 +303,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                 }\n \n+                if ident.name == keywords::Crate.name() {\n+                    self.session.span_err(ident.span,\n+                        \"crate root imports need to be explicitly named: \\\n+                         `use crate as name;`\");\n+                }\n+\n                 let subclass = SingleImport {\n                     target: ident,\n                     source,\n@@ -206,6 +328,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     root_id,\n                     vis,\n                     expansion,\n+                    false, // is_uniform_paths_canary\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n@@ -222,6 +345,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     root_id,\n                     vis,\n                     expansion,\n+                    false, // is_uniform_paths_canary\n                 );\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n@@ -256,7 +380,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 for &(ref tree, id) in items {\n                     self.build_reduced_graph_for_use_tree(\n-                        root_use_tree, root_id, tree, id, vis, &prefix, true, item, expansion\n+                        root_use_tree,\n+                        root_id,\n+                        tree,\n+                        id,\n+                        vis,\n+                        &prefix,\n+                        uniform_paths_canary_emitted,\n+                        true,\n+                        item,\n+                        expansion,\n                     );\n                 }\n             }\n@@ -272,14 +405,32 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         match item.node {\n             ItemKind::Use(ref use_tree) => {\n+                let uniform_paths =\n+                    self.session.rust_2018() &&\n+                    self.session.features_untracked().uniform_paths;\n                 // Imports are resolved as global by default, add starting root segment.\n+                let root = if !uniform_paths {\n+                    use_tree.prefix.make_root()\n+                } else {\n+                    // Except when `#![feature(uniform_paths)]` is on.\n+                    None\n+                };\n                 let prefix = ast::Path {\n-                    segments: use_tree.prefix.make_root().into_iter().collect(),\n+                    segments: root.into_iter().collect(),\n                     span: use_tree.span,\n                 };\n \n                 self.build_reduced_graph_for_use_tree(\n-                    use_tree, item.id, use_tree, item.id, vis, &prefix, false, item, expansion,\n+                    use_tree,\n+                    item.id,\n+                    use_tree,\n+                    item.id,\n+                    vis,\n+                    &prefix,\n+                    false, // uniform_paths_canary_emitted\n+                    false,\n+                    item,\n+                    expansion,\n                 );\n             }\n \n@@ -299,14 +450,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     root_id: item.id,\n                     id: item.id,\n                     parent,\n-                    imported_module: Cell::new(Some(module)),\n+                    imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate(orig_name),\n                     root_span: item.span,\n                     span: item.span,\n                     module_path: Vec::new(),\n                     vis: Cell::new(vis),\n                     expansion,\n                     used: Cell::new(used),\n+                    is_uniform_paths_canary: false,\n                 });\n                 self.potentially_unused_imports.push(directive);\n                 let imported_binding = self.import(binding, directive);\n@@ -701,14 +853,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             root_id: item.id,\n             id: item.id,\n             parent: graph_root,\n-            imported_module: Cell::new(Some(module)),\n+            imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n             subclass: ImportDirectiveSubclass::MacroUse,\n             root_span: span,\n             span,\n             module_path: Vec::new(),\n             vis: Cell::new(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))),\n             expansion,\n             used: Cell::new(false),\n+            is_uniform_paths_canary: false,\n         });\n \n         if let Some(span) = legacy_imports.import_all {\n@@ -721,7 +874,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         } else {\n             for (name, span) in legacy_imports.imports {\n                 let ident = Ident::with_empty_ctxt(name);\n-                let result = self.resolve_ident_in_module(module, ident, MacroNS, false, span);\n+                let result = self.resolve_ident_in_module(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    MacroNS,\n+                    false,\n+                    span,\n+                );\n                 if let Ok(binding) = result {\n                     let directive = macro_use_directive(span);\n                     self.potentially_unused_imports.push(directive);"}, {"sha": "992ea12ffa2b14c44dde94f4fdfc303ac356d791", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 146, "deletions": 74, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -953,9 +953,20 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum ModuleOrUniformRoot<'a> {\n+    /// Regular module.\n+    Module(Module<'a>),\n+\n+    /// The `{{root}}` (`CrateRoot` aka \"global\") / `extern` initial segment\n+    /// in which external crates resolve, and also `crate` (only in `{{root}}`,\n+    /// but *not* `extern`), in the Rust 2018 edition.\n+    UniformRoot(Name),\n+}\n+\n #[derive(Clone, Debug)]\n enum PathResult<'a> {\n-    Module(Module<'a>),\n+    Module(ModuleOrUniformRoot<'a>),\n     NonModule(PathResolution),\n     Indeterminate,\n     Failed(Span, String, bool /* is the error from the last segment? */),\n@@ -1583,11 +1594,13 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let hir::Path { ref segments, span, ref mut def } = *path;\n         let path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n-        match self.resolve_path(&path, Some(namespace), true, span, CrateLint::No) {\n-            PathResult::Module(module) => *def = module.def().unwrap(),\n+        match self.resolve_path(None, &path, Some(namespace), true, span, CrateLint::No) {\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n             PathResult::NonModule(..) => match self.resolve_path(\n+                None,\n                 &path,\n                 None,\n                 true,\n@@ -1599,6 +1612,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 }\n                 _ => {}\n             },\n+            PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n             PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed(span, msg, _) => {\n                 error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -1881,7 +1895,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             };\n \n             let item = self.resolve_ident_in_module_unadjusted(\n-                module, ident, ns, false, record_used, path_span,\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                record_used,\n+                path_span,\n             );\n             if let Ok(binding) = item {\n                 // The ident resolves to an item.\n@@ -1906,7 +1925,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let orig_current_module = self.current_module;\n             self.current_module = module; // Lexical resolutions can never be a privacy error.\n             let result = self.resolve_ident_in_module_unadjusted(\n-                module, ident, ns, false, record_used, path_span,\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                record_used,\n+                path_span,\n             );\n             self.current_module = orig_current_module;\n \n@@ -1954,8 +1978,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n             if let Some(prelude) = self.prelude {\n-                if let Ok(binding) = self.resolve_ident_in_module_unadjusted(prelude, ident, ns,\n-                                                                        false, false, path_span) {\n+                if let Ok(binding) = self.resolve_ident_in_module_unadjusted(\n+                    ModuleOrUniformRoot::Module(prelude),\n+                    ident,\n+                    ns,\n+                    false,\n+                    false,\n+                    path_span,\n+                ) {\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n             }\n@@ -2013,16 +2043,18 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn resolve_ident_in_module(&mut self,\n-                               module: Module<'a>,\n+                               module: ModuleOrUniformRoot<'a>,\n                                mut ident: Ident,\n                                ns: Namespace,\n                                record_used: bool,\n                                span: Span)\n                                -> Result<&'a NameBinding<'a>, Determinacy> {\n         ident.span = ident.span.modern();\n         let orig_current_module = self.current_module;\n-        if let Some(def) = ident.span.adjust(module.expansion) {\n-            self.current_module = self.macro_def_scope(def);\n+        if let ModuleOrUniformRoot::Module(module) = module {\n+            if let Some(def) = ident.span.adjust(module.expansion) {\n+                self.current_module = self.macro_def_scope(def);\n+            }\n         }\n         let result = self.resolve_ident_in_module_unadjusted(\n             module, ident, ns, false, record_used, span,\n@@ -2410,13 +2442,16 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             if def != Def::Err {\n                 new_id = Some(def.def_id());\n                 let span = trait_ref.path.span;\n-                if let PathResult::Module(module) = self.resolve_path(\n-                    &path,\n-                    None,\n-                    false,\n-                    span,\n-                    CrateLint::SimplePath(trait_ref.ref_id),\n-                ) {\n+                if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n+                    self.resolve_path(\n+                        None,\n+                        &path,\n+                        None,\n+                        false,\n+                        span,\n+                        CrateLint::SimplePath(trait_ref.ref_id),\n+                    )\n+                {\n                     new_val = Some((module, trait_ref.clone()));\n                 }\n             }\n@@ -2533,7 +2568,13 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if self.resolve_ident_in_module(module, ident, ns, false, span).is_err() {\n+            if self.resolve_ident_in_module(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                span,\n+            ).is_err() {\n                 let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n                 resolve_error(self, span, err(ident.name, &path_names_to_string(path)));\n             }\n@@ -2908,9 +2949,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     (String::new(), \"the crate root\".to_string())\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n-                    let mod_prefix = match this.resolve_path(mod_path, Some(TypeNS),\n+                    let mod_prefix = match this.resolve_path(None, mod_path, Some(TypeNS),\n                                                              false, span, CrateLint::No) {\n-                        PathResult::Module(module) => module.def(),\n+                        PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                            module.def(),\n                         _ => None,\n                     }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n                     (mod_prefix, format!(\"`{}`\", names_to_string(mod_path)))\n@@ -3319,14 +3361,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n \n         let result = match self.resolve_path(\n+            None,\n             &path,\n             Some(ns),\n             true,\n             span,\n             crate_lint,\n         ) {\n             PathResult::NonModule(path_res) => path_res,\n-            PathResult::Module(module) if !module.is_normal() => {\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n                 PathResolution::new(module.def().unwrap())\n             }\n             // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n@@ -3341,18 +3384,21 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             //\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n-            PathResult::Module(..) | PathResult::Failed(..)\n+            PathResult::Module(ModuleOrUniformRoot::Module(_)) |\n+            PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types\n                            .contains_key(&path[0].name) => {\n                 let prim = self.primitive_type_table.primitive_types[&path[0].name];\n                 PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n-            PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                PathResolution::new(module.def().unwrap()),\n             PathResult::Failed(span, msg, false) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 err_path_resolution()\n             }\n+            PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n             PathResult::Failed(..) => return None,\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n         };\n@@ -3362,14 +3408,16 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n            path[0].name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(\n+                    None,\n                     &[*path.last().unwrap()],\n                     Some(ns),\n                     false,\n                     span,\n                     CrateLint::No,\n                 ) {\n                     PathResult::NonModule(path_res) => path_res.base_def(),\n-                    PathResult::Module(module) => module.def().unwrap(),\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                        module.def().unwrap(),\n                     _ => return Some(result),\n                 }\n             };\n@@ -3384,13 +3432,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n     fn resolve_path(\n         &mut self,\n+        base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Ident],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        let mut module = None;\n+        let mut module = base_module;\n         let mut allow_super = true;\n         let mut second_binding = None;\n \n@@ -3412,49 +3461,48 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             if i == 0 && ns == TypeNS && name == keywords::SelfValue.name() {\n                 let mut ctxt = ident.span.ctxt().modern();\n-                module = Some(self.resolve_self(&mut ctxt, self.current_module));\n+                module = Some(ModuleOrUniformRoot::Module(\n+                    self.resolve_self(&mut ctxt, self.current_module)));\n                 continue\n             } else if allow_super && ns == TypeNS && name == keywords::Super.name() {\n                 let mut ctxt = ident.span.ctxt().modern();\n-                let self_module = match i {\n-                    0 => self.resolve_self(&mut ctxt, self.current_module),\n-                    _ => module.unwrap(),\n+                let self_module_parent = match i {\n+                    0 => self.resolve_self(&mut ctxt, self.current_module).parent,\n+                    _ => match module {\n+                        Some(ModuleOrUniformRoot::Module(module)) => module.parent,\n+                        _ => None,\n+                    },\n                 };\n-                if let Some(parent) = self_module.parent {\n-                    module = Some(self.resolve_self(&mut ctxt, parent));\n+                if let Some(parent) = self_module_parent {\n+                    module = Some(ModuleOrUniformRoot::Module(\n+                        self.resolve_self(&mut ctxt, parent)));\n                     continue\n                 } else {\n                     let msg = \"There are too many initial `super`s.\".to_string();\n                     return PathResult::Failed(ident.span, msg, false);\n                 }\n-            } else if i == 0 && ns == TypeNS && name == keywords::Extern.name() {\n-                continue;\n             }\n             allow_super = false;\n \n             if ns == TypeNS {\n+                if i == 0 {\n+                    if name == keywords::Extern.name() ||\n+                       name == keywords::CrateRoot.name() &&\n+                       self.session.features_untracked().extern_absolute_paths &&\n+                       self.session.rust_2018() {\n+                        module = Some(ModuleOrUniformRoot::UniformRoot(name));\n+                        continue;\n+                    }\n+                }\n                 if (i == 0 && name == keywords::CrateRoot.name()) ||\n                    (i == 0 && name == keywords::Crate.name()) ||\n                    (i == 0 && name == keywords::DollarCrate.name()) ||\n                    (i == 1 && name == keywords::Crate.name() &&\n                               path[0].name == keywords::CrateRoot.name()) {\n                     // `::a::b`, `crate::a::b`, `::crate::a::b` or `$crate::a::b`\n-                    module = Some(self.resolve_crate_root(ident));\n+                    module = Some(ModuleOrUniformRoot::Module(\n+                        self.resolve_crate_root(ident)));\n                     continue\n-                } else if i == 1 && !ident.is_path_segment_keyword() {\n-                    let prev_name = path[0].name;\n-                    if prev_name == keywords::Extern.name() ||\n-                       prev_name == keywords::CrateRoot.name() &&\n-                       self.session.features_untracked().extern_absolute_paths &&\n-                       self.session.rust_2018() {\n-                        // `::extern_crate::a::b`\n-                        let crate_id = self.crate_loader.process_path_extern(name, ident.span);\n-                        let crate_root =\n-                            self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n-                        self.populate_module_if_necessary(crate_root);\n-                        module = Some(crate_root);\n-                        continue\n-                    }\n                 }\n             }\n \n@@ -3513,7 +3561,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     let def = binding.def();\n                     let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(def);\n                     if let Some(next_module) = binding.module() {\n-                        module = Some(next_module);\n+                        module = Some(ModuleOrUniformRoot::Module(next_module));\n                     } else if def == Def::ToolMod && i + 1 != path.len() {\n                         let def = Def::NonMacroAttr(NonMacroAttrKind::Tool);\n                         return PathResult::NonModule(PathResolution::new(def));\n@@ -3537,14 +3585,18 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 }\n                 Err(Undetermined) => return PathResult::Indeterminate,\n                 Err(Determined) => {\n-                    if let Some(module) = module {\n+                    if let Some(ModuleOrUniformRoot::Module(module)) = module {\n                         if opt_ns.is_some() && !module.is_normal() {\n                             return PathResult::NonModule(PathResolution::with_unresolved_segments(\n                                 module.def().unwrap(), path.len() - i\n                             ));\n                         }\n                     }\n-                    let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n+                    let module_def = match module {\n+                        Some(ModuleOrUniformRoot::Module(module)) => module.def(),\n+                        _ => None,\n+                    };\n+                    let msg = if module_def == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n                             self.lookup_import_candidates(name, TypeNS, is_mod);\n@@ -3568,7 +3620,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         self.lint_if_path_starts_with_module(crate_lint, path, path_span, second_binding);\n \n-        PathResult::Module(module.unwrap_or(self.graph_root))\n+        PathResult::Module(module.unwrap_or_else(|| {\n+            span_bug!(path_span, \"resolve_path: empty(?) path {:?} has no module\", path);\n+        }))\n+\n     }\n \n     fn lint_if_path_starts_with_module(\n@@ -3578,6 +3633,17 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         path_span: Span,\n         second_binding: Option<&NameBinding>,\n     ) {\n+        // In the 2018 edition this lint is a hard error, so nothing to do\n+        if self.session.rust_2018() {\n+            return\n+        }\n+\n+        // In the 2015 edition there's no use in emitting lints unless the\n+        // crate's already enabled the feature that we're going to suggest\n+        if !self.session.features_untracked().crate_in_paths {\n+            return\n+        }\n+\n         let (diag_id, diag_span) = match crate_lint {\n             CrateLint::No => return,\n             CrateLint::SimplePath(id) => (id, path_span),\n@@ -3620,24 +3686,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n         }\n \n-        self.lint_path_starts_with_module(diag_id, diag_span);\n-    }\n-\n-    fn lint_path_starts_with_module(&self, id: NodeId, span: Span) {\n-        // In the 2018 edition this lint is a hard error, so nothing to do\n-        if self.session.rust_2018() {\n-            return\n-        }\n-        // In the 2015 edition there's no use in emitting lints unless the\n-        // crate's already enabled the feature that we're going to suggest\n-        if !self.session.features_untracked().crate_in_paths {\n-            return\n-        }\n         let diag = lint::builtin::BuiltinLintDiagnostics\n-            ::AbsPathWithModule(span);\n+            ::AbsPathWithModule(diag_span);\n         self.session.buffer_lint_with_diagnostic(\n             lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n-            id, span,\n+            diag_id, diag_span,\n             \"absolute paths must start with `self`, `super`, \\\n             `crate`, or an external crate name in the 2018 edition\",\n             diag);\n@@ -3782,8 +3835,13 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         // Look for associated items in the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if let Ok(binding) =\n-                    self.resolve_ident_in_module(module, ident, ns, false, module.span) {\n+            if let Ok(binding) = self.resolve_ident_in_module(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    false,\n+                    module.span,\n+                ) {\n                 let def = binding.def();\n                 if filter_fn(def) {\n                     return Some(if self.has_self.contains(&def.def_id()) {\n@@ -3855,9 +3913,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path(mod_path, Some(TypeNS),\n+            if let PathResult::Module(module) = self.resolve_path(None, mod_path, Some(TypeNS),\n                                                                   false, span, CrateLint::No) {\n-                add_module_candidates(module, &mut names);\n+                if let ModuleOrUniformRoot::Module(module) = module {\n+                    add_module_candidates(module, &mut names);\n+                }\n             }\n         }\n \n@@ -4096,7 +4156,13 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((module, _)) = self.current_trait_ref {\n-            if self.resolve_ident_in_module(module, ident, ns, false, module.span).is_ok() {\n+            if self.resolve_ident_in_module(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                module.span,\n+            ).is_ok() {\n                 let def_id = module.def_id().unwrap();\n                 found_traits.push(TraitCandidate { def_id: def_id, import_id: None });\n             }\n@@ -4144,8 +4210,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             if ident.span.glob_adjust(module.expansion, binding.span.ctxt().modern()).is_none() {\n                 continue\n             }\n-            if self.resolve_ident_in_module_unadjusted(module, ident, ns, false, false, module.span)\n-                   .is_ok() {\n+            if self.resolve_ident_in_module_unadjusted(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                false,\n+                module.span,\n+            ).is_ok() {\n                 let import_id = match binding.kind {\n                     NameBindingKind::Import { directive, .. } => {\n                         self.maybe_unused_trait_imports.insert(directive.id);"}, {"sha": "44d0c888c5dd248bc63b80dd3a397e7731db9b75", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -10,6 +10,7 @@\n \n use {AmbiguityError, CrateLint, Resolver, ResolutionError, is_known_tool, resolve_error};\n use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n+use ModuleOrUniformRoot;\n use Namespace::{self, TypeNS, MacroNS};\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use resolve_imports::ImportResolver;\n@@ -538,7 +539,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 return Err(Determinacy::Determined);\n             }\n \n-            let def = match self.resolve_path(&path, Some(MacroNS), false, span, CrateLint::No) {\n+            let res = self.resolve_path(None, &path, Some(MacroNS), false, span, CrateLint::No);\n+            let def = match res {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n@@ -655,7 +657,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 WhereToResolve::Module(module) => {\n                     let orig_current_module = mem::replace(&mut self.current_module, module);\n                     let binding = self.resolve_ident_in_module_unadjusted(\n-                            module, ident, ns, true, record_used, path_span,\n+                        ModuleOrUniformRoot::Module(module),\n+                        ident,\n+                        ns,\n+                        true,\n+                        record_used,\n+                        path_span,\n                     );\n                     self.current_module = orig_current_module;\n                     binding.map(MacroBinding::Modern)\n@@ -715,9 +722,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     let mut result = Err(Determinacy::Determined);\n                     if use_prelude {\n                         if let Some(prelude) = self.prelude {\n-                            if let Ok(binding) =\n-                                    self.resolve_ident_in_module_unadjusted(prelude, ident, ns,\n-                                                                          false, false, path_span) {\n+                            if let Ok(binding) = self.resolve_ident_in_module_unadjusted(\n+                                ModuleOrUniformRoot::Module(prelude),\n+                                ident,\n+                                ns,\n+                                false,\n+                                false,\n+                                path_span,\n+                            ) {\n                                 result = Ok(MacroBinding::Global(binding));\n                             }\n                         }\n@@ -893,7 +905,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            match self.resolve_path(&path, Some(MacroNS), true, span, CrateLint::No) {\n+            match self.resolve_path(None, &path, Some(MacroNS), true, span, CrateLint::No) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));"}, {"sha": "1d8cc609f95ac6da1276ab59c97d2dc6818f2193", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 249, "deletions": 116, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -10,8 +10,8 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use {AmbiguityError, CrateLint, Module, PerNS};\n-use Namespace::{self, TypeNS, MacroNS};\n+use {AmbiguityError, CrateLint, Module, ModuleOrUniformRoot, PerNS};\n+use Namespace::{self, TypeNS, MacroNS, ValueNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use Resolver;\n use {names_to_string, module_to_string};\n@@ -85,11 +85,19 @@ pub struct ImportDirective<'a> {\n \n     pub parent: Module<'a>,\n     pub module_path: Vec<Ident>,\n-    pub imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n+    /// The resolution of `module_path`.\n+    pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub vis: Cell<ty::Visibility>,\n     pub expansion: Mark,\n     pub used: Cell<bool>,\n+\n+    /// Whether this import is a \"canary\" for the `uniform_paths` feature,\n+    /// i.e. `use x::...;` results in an `use self::x as _;` canary.\n+    /// This flag affects diagnostics: an error is reported if and only if\n+    /// the import resolves successfully and an external crate with the same\n+    /// name (`x` above) also exists; any resolution failures are ignored.\n+    pub is_uniform_paths_canary: bool,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -133,13 +141,87 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n     /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `record_used` is `Some`, expansion and import resolution must be complete.\n     pub fn resolve_ident_in_module_unadjusted(&mut self,\n-                                              module: Module<'a>,\n+                                              module: ModuleOrUniformRoot<'a>,\n                                               ident: Ident,\n                                               ns: Namespace,\n                                               restricted_shadowing: bool,\n                                               record_used: bool,\n                                               path_span: Span)\n                                               -> Result<&'a NameBinding<'a>, Determinacy> {\n+        let module = match module {\n+            ModuleOrUniformRoot::Module(module) => module,\n+            ModuleOrUniformRoot::UniformRoot(root) => {\n+                // HACK(eddyb): `resolve_path` uses `keywords::Invalid` to indicate\n+                // paths of length 0, and currently these are relative `use` paths.\n+                let can_be_relative = !ident.is_path_segment_keyword() &&\n+                    root == keywords::Invalid.name();\n+                if can_be_relative {\n+                    // Relative paths should only get here if the feature-gate is on.\n+                    assert!(self.session.rust_2018() &&\n+                            self.session.features_untracked().uniform_paths);\n+\n+                    // Try first to resolve relatively.\n+                    let mut ctxt = ident.span.ctxt().modern();\n+                    let self_module = self.resolve_self(&mut ctxt, self.current_module);\n+\n+                    let binding = self.resolve_ident_in_module_unadjusted(\n+                        ModuleOrUniformRoot::Module(self_module),\n+                        ident,\n+                        ns,\n+                        restricted_shadowing,\n+                        record_used,\n+                        path_span,\n+                    );\n+\n+                    // FIXME(eddyb) This may give false negatives, specifically\n+                    // if a crate with the same name is found in `extern_prelude`,\n+                    // preventing the check below this one from returning `binding`\n+                    // in all cases.\n+                    //\n+                    // That is, if there's no crate with the same name, `binding`\n+                    // is always returned, which is the result of doing the exact\n+                    // same lookup of `ident`, in the `self` module.\n+                    // But when a crate does exist, it will get chosen even when\n+                    // macro expansion could result in a success from the lookup\n+                    // in the `self` module, later on.\n+                    //\n+                    // NB. This is currently alleviated by the \"ambiguity canaries\"\n+                    // (see `is_uniform_paths_canary`) that get introduced for the\n+                    // maybe-relative imports handled here: if the false negative\n+                    // case were to arise, it would *also* cause an ambiguity error.\n+                    if binding.is_ok() {\n+                        return binding;\n+                    }\n+\n+                    // Fall back to resolving to an external crate.\n+                    if !self.extern_prelude.contains(&ident.name) {\n+                        // ... unless the crate name is not in the `extern_prelude`.\n+                        return binding;\n+                    }\n+                }\n+\n+                let crate_root = if\n+                    root != keywords::Extern.name() &&\n+                    (\n+                        ident.name == keywords::Crate.name() ||\n+                        ident.name == keywords::DollarCrate.name()\n+                    )\n+                {\n+                    self.resolve_crate_root(ident)\n+                } else if !ident.is_path_segment_keyword() {\n+                    let crate_id =\n+                        self.crate_loader.process_path_extern(ident.name, ident.span);\n+                    self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n+                } else {\n+                    return Err(Determined);\n+                };\n+                self.populate_module_if_necessary(crate_root);\n+                let binding = (crate_root, ty::Visibility::Public,\n+                               ident.span, Mark::root()).to_name_binding(self.arenas);\n+                return Ok(binding);\n+            }\n+        };\n+\n         self.populate_module_if_necessary(module);\n \n         let resolution = self.resolution(module, ident, ns)\n@@ -260,15 +342,24 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             if !self.is_accessible(glob_import.vis.get()) {\n                 continue\n             }\n-            let module = unwrap_or!(glob_import.imported_module.get(), return Err(Undetermined));\n+            let module = match glob_import.imported_module.get() {\n+                Some(ModuleOrUniformRoot::Module(module)) => module,\n+                Some(ModuleOrUniformRoot::UniformRoot(_)) => continue,\n+                None => return Err(Undetermined),\n+            };\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n             match ident.span.glob_adjust(module.expansion, glob_import.span.ctxt().modern()) {\n                 Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n                 Some(None) => {}\n                 None => continue,\n             };\n             let result = self.resolve_ident_in_module_unadjusted(\n-                module, ident, ns, false, false, path_span,\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                false,\n+                false,\n+                path_span,\n             );\n             self.current_module = orig_current_module;\n             match result {\n@@ -290,7 +381,8 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                                 root_span: Span,\n                                 root_id: NodeId,\n                                 vis: ty::Visibility,\n-                                expansion: Mark) {\n+                                expansion: Mark,\n+                                is_uniform_paths_canary: bool) {\n         let current_module = self.current_module;\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n             parent: current_module,\n@@ -304,8 +396,11 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             vis: Cell::new(vis),\n             expansion,\n             used: Cell::new(false),\n+            is_uniform_paths_canary,\n         });\n \n+        debug!(\"add_import_directive({:?})\", directive);\n+\n         self.indeterminate_imports.push(directive);\n         match directive.subclass {\n             SingleImport { target, type_ns_only, .. } => {\n@@ -523,7 +618,55 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let mut seen_spans = FxHashSet();\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n-            if let Some((span, err)) = self.finalize_import(import) {\n+            let error = self.finalize_import(import);\n+\n+            // For a `#![feature(uniform_paths)]` `use self::x as _` canary,\n+            // failure is ignored, while success may cause an ambiguity error.\n+            if import.is_uniform_paths_canary {\n+                let (name, result) = match import.subclass {\n+                    SingleImport { source, ref result, .. } => {\n+                        let type_ns = result[TypeNS].get().ok();\n+                        let value_ns = result[ValueNS].get().ok();\n+                        (source.name, type_ns.or(value_ns))\n+                    }\n+                    _ => bug!(),\n+                };\n+\n+                if error.is_some() {\n+                    continue;\n+                }\n+\n+                let is_explicit_self =\n+                    import.module_path.len() > 0 &&\n+                    import.module_path[0].name == keywords::SelfValue.name();\n+                let extern_crate_exists = self.extern_prelude.contains(&name);\n+\n+                // A successful `self::x` is ambiguous with an `x` external crate.\n+                if is_explicit_self && !extern_crate_exists {\n+                    continue;\n+                }\n+\n+                errors = true;\n+\n+                let msg = format!(\"import from `{}` is ambiguous\", name);\n+                let mut err = self.session.struct_span_err(import.span, &msg);\n+                if extern_crate_exists {\n+                    err.span_label(import.span,\n+                        format!(\"could refer to external crate `::{}`\", name));\n+                }\n+                if let Some(result) = result {\n+                    if is_explicit_self {\n+                        err.span_label(result.span,\n+                            format!(\"could also refer to `self::{}`\", name));\n+                    } else {\n+                        err.span_label(result.span,\n+                            format!(\"shadowed by block-scoped `{}`\", name));\n+                    }\n+                }\n+                err.help(&format!(\"write `::{0}` or `self::{0}` explicitly instead\", name));\n+                err.note(\"relative `use` paths enabled by `#![feature(uniform_paths)]`\");\n+                err.emit();\n+            } else if let Some((span, err)) = error {\n                 errors = true;\n \n                 if let SingleImport { source, ref result, .. } = import.subclass {\n@@ -553,9 +696,14 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n         if !errors {\n-            if let Some(import) = self.indeterminate_imports.iter().next() {\n+            for import in &self.indeterminate_imports {\n+                if import.is_uniform_paths_canary {\n+                    continue;\n+                }\n+\n                 let error = ResolutionError::UnresolvedImport(None);\n                 resolve_error(self.resolver, import.span, error);\n+                break;\n             }\n         }\n     }\n@@ -576,8 +724,18 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::Invisible);\n-            let result = self.resolve_path(&directive.module_path[..], None, false,\n-                                           directive.span, directive.crate_lint());\n+            let result = self.resolve_path(\n+                Some(if directive.is_uniform_paths_canary {\n+                    ModuleOrUniformRoot::Module(directive.parent)\n+                } else {\n+                    ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n+                }),\n+                &directive.module_path[..],\n+                None,\n+                false,\n+                directive.span,\n+                directive.crate_lint(),\n+            );\n             directive.vis.set(vis);\n \n             match result {\n@@ -644,77 +802,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<(Span, String)> {\n         self.current_module = directive.parent;\n         let ImportDirective { ref module_path, span, .. } = *directive;\n-        let mut warn_if_binding_comes_from_local_crate = false;\n-\n-        // FIXME: Last path segment is treated specially in import resolution, so extern crate\n-        // mode for absolute paths needs some special support for single-segment imports.\n-        if module_path.len() == 1 && (module_path[0].name == keywords::CrateRoot.name() ||\n-                                      module_path[0].name == keywords::Extern.name()) {\n-            let is_extern = module_path[0].name == keywords::Extern.name() ||\n-                            (self.session.features_untracked().extern_absolute_paths &&\n-                             self.session.rust_2018());\n-            match directive.subclass {\n-                GlobImport { .. } if is_extern => {\n-                    return Some((directive.span,\n-                                 \"cannot glob-import all possible crates\".to_string()));\n-                }\n-                GlobImport { .. } if self.session.features_untracked().extern_absolute_paths => {\n-                    self.lint_path_starts_with_module(\n-                        directive.root_id,\n-                        directive.root_span,\n-                    );\n-                }\n-                SingleImport { source, target, .. } => {\n-                    let crate_root = if source.name == keywords::Crate.name() &&\n-                                        module_path[0].name != keywords::Extern.name() {\n-                        if target.name == keywords::Crate.name() {\n-                            return Some((directive.span,\n-                                         \"crate root imports need to be explicitly named: \\\n-                                          `use crate as name;`\".to_string()));\n-                        } else {\n-                            Some(self.resolve_crate_root(source))\n-                        }\n-                    } else if is_extern && !source.is_path_segment_keyword() {\n-                        let crate_id =\n-                            self.resolver.crate_loader.process_use_extern(\n-                                source.name,\n-                                directive.span,\n-                                directive.id,\n-                                &self.resolver.definitions,\n-                            );\n-                        let crate_root =\n-                            self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n-                        self.populate_module_if_necessary(crate_root);\n-                        Some(crate_root)\n-                    } else {\n-                        warn_if_binding_comes_from_local_crate = true;\n-                        None\n-                    };\n-\n-                    if let Some(crate_root) = crate_root {\n-                        let binding = (crate_root, ty::Visibility::Public, directive.span,\n-                                       directive.expansion).to_name_binding(self.arenas);\n-                        let binding = self.arenas.alloc_name_binding(NameBinding {\n-                            kind: NameBindingKind::Import {\n-                                binding,\n-                                directive,\n-                                used: Cell::new(false),\n-                            },\n-                            vis: directive.vis.get(),\n-                            span: directive.span,\n-                            expansion: directive.expansion,\n-                        });\n-                        let _ = self.try_define(directive.parent, target, TypeNS, binding);\n-                        let import = self.import_map.entry(directive.id).or_default();\n-                        import[TypeNS] = Some(PathResolution::new(binding.def()));\n-                        return None;\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n \n         let module_result = self.resolve_path(\n+            Some(if directive.is_uniform_paths_canary {\n+                ModuleOrUniformRoot::Module(directive.parent)\n+            } else {\n+                ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n+            }),\n             &module_path,\n             None,\n             true,\n@@ -734,7 +828,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 if !self_path.is_empty() && !is_special(self_path[0]) &&\n                    !(self_path.len() > 1 && is_special(self_path[1])) {\n                     self_path[0].name = keywords::SelfValue.name();\n-                    self_result = Some(self.resolve_path(&self_path, None, false,\n+                    self_result = Some(self.resolve_path(None, &self_path, None, false,\n                                                          span, CrateLint::No));\n                 }\n                 return if let Some(PathResult::Module(..)) = self_result {\n@@ -748,12 +842,27 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n         let (ident, result, type_ns_only) = match directive.subclass {\n             SingleImport { source, ref result, type_ns_only, .. } => (source, result, type_ns_only),\n-            GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n-                // Importing a module into itself is not allowed.\n-                return Some((directive.span,\n-                             \"Cannot glob-import a module into itself.\".to_string()));\n-            }\n             GlobImport { is_prelude, ref max_vis } => {\n+                if module_path.len() <= 1 {\n+                    // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n+                    // 2 segments, so the `resolve_path` above won't trigger it.\n+                    let mut full_path = module_path.clone();\n+                    full_path.push(keywords::Invalid.ident());\n+                    self.lint_if_path_starts_with_module(\n+                        directive.crate_lint(),\n+                        &full_path,\n+                        directive.span,\n+                        None,\n+                    );\n+                }\n+\n+                if let ModuleOrUniformRoot::Module(module) = module {\n+                    if module.def_id() == directive.parent.def_id() {\n+                        // Importing a module into itself is not allowed.\n+                        return Some((directive.span,\n+                            \"Cannot glob-import a module into itself.\".to_string()));\n+                    }\n+                }\n                 if !is_prelude &&\n                    max_vis.get() != ty::Visibility::Invisible && // Allow empty globs.\n                    !max_vis.get().is_at_least(directive.vis.get(), &*self) {\n@@ -770,8 +879,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             if let Ok(binding) = result[ns].get() {\n                 all_ns_err = false;\n                 if this.record_use(ident, ns, binding, directive.span) {\n-                    this.resolution(module, ident, ns).borrow_mut().binding =\n-                        Some(this.dummy_binding);\n+                    if let ModuleOrUniformRoot::Module(module) = module {\n+                        this.resolution(module, ident, ns).borrow_mut().binding =\n+                            Some(this.dummy_binding);\n+                    }\n                 }\n             }\n         });\n@@ -786,8 +897,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             });\n \n             return if all_ns_failed {\n-                let resolutions = module.resolutions.borrow();\n-                let names = resolutions.iter().filter_map(|(&(ref i, _), resolution)| {\n+                let resolutions = match module {\n+                    ModuleOrUniformRoot::Module(module) =>\n+                        Some(module.resolutions.borrow()),\n+                    ModuleOrUniformRoot::UniformRoot(_) => None,\n+                };\n+                let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n+                let names = resolutions.filter_map(|(&(ref i, _), resolution)| {\n                     if *i == ident { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n                         NameResolution { binding: Some(name_binding), .. } => {\n@@ -813,11 +929,24 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                         Some(name) => format!(\". Did you mean to use `{}`?\", name),\n                         None => \"\".to_owned(),\n                     };\n-                let module_str = module_to_string(module);\n-                let msg = if let Some(module_str) = module_str {\n-                    format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n-                } else {\n-                    format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n+                let msg = match module {\n+                    ModuleOrUniformRoot::Module(module) => {\n+                        let module_str = module_to_string(module);\n+                        if let Some(module_str) = module_str {\n+                            format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n+                        } else {\n+                            format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n+                        }\n+                    }\n+                    ModuleOrUniformRoot::UniformRoot(_) => {\n+                        if !ident.is_path_segment_keyword() {\n+                            format!(\"no `{}` external crate{}\", ident, lev_suggestion)\n+                        } else {\n+                            // HACK(eddyb) this shows up for `self` & `super`, which\n+                            // should work instead - for now keep the same error message.\n+                            format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n+                        }\n+                    }\n                 };\n                 Some((span, msg))\n             } else {\n@@ -868,26 +997,20 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n         }\n \n-        if warn_if_binding_comes_from_local_crate {\n-            let mut warned = false;\n+        if module_path.len() <= 1 {\n+            // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n+            // 2 segments, so the `resolve_path` above won't trigger it.\n+            let mut full_path = module_path.clone();\n+            full_path.push(ident);\n             self.per_ns(|this, ns| {\n-                let binding = match result[ns].get().ok() {\n-                    Some(b) => b,\n-                    None => return\n-                };\n-                if let NameBindingKind::Import { directive: d, .. } = binding.kind {\n-                    if let ImportDirectiveSubclass::ExternCrate(..) = d.subclass {\n-                        return\n-                    }\n-                }\n-                if warned {\n-                    return\n+                if let Ok(binding) = result[ns].get() {\n+                    this.lint_if_path_starts_with_module(\n+                        directive.crate_lint(),\n+                        &full_path,\n+                        directive.span,\n+                        Some(binding),\n+                    );\n                 }\n-                warned = true;\n-                this.lint_path_starts_with_module(\n-                    directive.root_id,\n-                    directive.root_span,\n-                );\n             });\n         }\n \n@@ -904,7 +1027,15 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     }\n \n     fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {\n-        let module = directive.imported_module.get().unwrap();\n+        let module = match directive.imported_module.get().unwrap() {\n+            ModuleOrUniformRoot::Module(module) => module,\n+            ModuleOrUniformRoot::UniformRoot(_) => {\n+                self.session.span_err(directive.span,\n+                    \"cannot glob-import all possible crates\");\n+                return;\n+            }\n+        };\n+\n         self.populate_module_if_necessary(module);\n \n         if let Some(Def::Trait(_)) = module.def() {\n@@ -1026,8 +1157,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                             };\n                             let mut err = self.session.struct_span_err(binding.span, &msg);\n \n-                            let imported_module = directive.imported_module.get()\n-                                .expect(\"module should exist\");\n+                            let imported_module = match directive.imported_module.get() {\n+                                Some(ModuleOrUniformRoot::Module(module)) => module,\n+                                _ => bug!(\"module should exist\"),\n+                            };\n                             let resolutions = imported_module.parent.expect(\"parent should exist\")\n                                 .resolutions.borrow();\n                             let enum_path_segment_index = directive.module_path.len() - 1;"}, {"sha": "b66946affadb3a4d00099ab6da35822b24c3db55", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -101,7 +101,7 @@ impl Path {\n     // or starts with something like `self`/`super`/`$crate`/etc.\n     pub fn make_root(&self) -> Option<PathSegment> {\n         if let Some(ident) = self.segments.get(0).map(|seg| seg.ident) {\n-            if ident.is_path_segment_keyword() && ident.name != keywords::Crate.name() {\n+            if ident.is_path_segment_keyword() {\n                 return None;\n             }\n         }"}, {"sha": "56e69b9df9e0407c1d68715b420b1590da17c71b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -507,6 +507,9 @@ declare_features! (\n \n     // Support for arbitrary delimited token streams in non-macro attributes.\n     (active, unrestricted_attribute_tokens, \"1.30.0\", Some(44690), None),\n+\n+    // Allows `use x::y;` to resolve through `self::x`, not just `::x`.\n+    (active, uniform_paths, \"1.30.0\", Some(53130), None),\n );\n \n declare_features! ("}, {"sha": "626a610017d42949d26dd19df1f69d5d93f8b085", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -11,6 +11,8 @@\n use ast;\n use attr;\n use std::cell::Cell;\n+use std::iter;\n+use edition::Edition;\n use ext::hygiene::{Mark, SyntaxContext};\n use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n@@ -43,7 +45,13 @@ thread_local! {\n     static INJECTED_CRATE_NAME: Cell<Option<&'static str>> = Cell::new(None);\n }\n \n-pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>) -> ast::Crate {\n+pub fn maybe_inject_crates_ref(\n+    mut krate: ast::Crate,\n+    alt_std_name: Option<&str>,\n+    edition: Edition,\n+) -> ast::Crate {\n+    let rust_2018 = edition >= Edition::Edition2018;\n+\n     // the first name in this list is the crate name of the crate with the prelude\n     let names: &[&str] = if attr::contains_name(&krate.attrs, \"no_core\") {\n         return krate;\n@@ -58,14 +66,27 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>\n     };\n \n     // .rev() to preserve ordering above in combination with insert(0, ...)\n-    for name in names.iter().rev() {\n+    let alt_std_name = alt_std_name.map(Symbol::intern);\n+    for orig_name in names.iter().rev() {\n+        let orig_name = Symbol::intern(orig_name);\n+        let mut rename = orig_name;\n+        // HACK(eddyb) gensym the injected crates on the Rust 2018 edition,\n+        // so they don't accidentally interfere with the new import paths.\n+        if rust_2018 {\n+            rename = orig_name.gensymed();\n+        }\n+        let orig_name = if rename != orig_name {\n+            Some(orig_name)\n+        } else {\n+            None\n+        };\n         krate.module.items.insert(0, P(ast::Item {\n             attrs: vec![attr::mk_attr_outer(DUMMY_SP,\n                                             attr::mk_attr_id(),\n                                             attr::mk_word_item(ast::Ident::from_str(\"macro_use\")))],\n             vis: dummy_spanned(ast::VisibilityKind::Inherited),\n-            node: ast::ItemKind::ExternCrate(alt_std_name.map(Symbol::intern)),\n-            ident: ast::Ident::from_str(name),\n+            node: ast::ItemKind::ExternCrate(alt_std_name.or(orig_name)),\n+            ident: ast::Ident::with_empty_ctxt(rename),\n             id: ast::DUMMY_NODE_ID,\n             span: DUMMY_SP,\n             tokens: None,\n@@ -91,9 +112,11 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>\n         vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n-                segments: [name, \"prelude\", \"v1\"].into_iter().map(|name| {\n-                    ast::PathSegment::from_ident(ast::Ident::from_str(name))\n-                }).collect(),\n+                segments: iter::once(keywords::CrateRoot.ident())\n+                    .chain(\n+                        [name, \"prelude\", \"v1\"].iter().cloned()\n+                            .map(ast::Ident::from_str)\n+                    ).map(ast::PathSegment::from_ident).collect(),\n                 span,\n             },\n             kind: ast::UseTreeKind::Glob,"}, {"sha": "4a667f020ad343081e6af632ea6d335755f9fa99", "filename": "src/test/compile-fail/dollar-crate-is-keyword.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -10,7 +10,11 @@\n \n macro_rules! m {\n     () => {\n-        struct $crate {} //~ ERROR expected identifier, found reserved identifier `$crate`\n+        // Avoid having more than one `$crate`-named item in the same module,\n+        // as even though they error, they still parse as `$crate` and conflict.\n+        mod foo {\n+            struct $crate {} //~ ERROR expected identifier, found reserved identifier `$crate`\n+        }\n \n         use $crate; // OK\n                     //~^ WARN `$crate` may not be imported"}, {"sha": "b09883d9adeeae254c6f30590f4bba48e7ec695d", "filename": "src/test/compile-fail/import-crate-var.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fcompile-fail%2Fimport-crate-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fcompile-fail%2Fimport-crate-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-crate-var.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -9,15 +9,14 @@\n // except according to those terms.\n \n // aux-build:import_crate_var.rs\n-// error-pattern: `$crate` may not be imported\n-// error-pattern: `use $crate;` was erroneously allowed and will become a hard error\n-// error-pattern: compilation successful\n \n #![feature(rustc_attrs)]\n \n #[macro_use] extern crate import_crate_var;\n \n #[rustc_error]\n-fn main() {\n+fn main() { //~ ERROR compilation successful\n     m!();\n+    //~^ WARN `$crate` may not be imported\n+    //~| NOTE `use $crate;` was erroneously allowed and will become a hard error\n }"}, {"sha": "3e44585395788110784e8d3864fd1b77ebe5a00f", "filename": "src/test/compile-fail/keyword-extern-as-identifier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fcompile-fail%2Fkeyword-extern-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fcompile-fail%2Fkeyword-extern-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword-extern-as-identifier.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -11,5 +11,5 @@\n #![feature(extern_in_paths)]\n \n fn main() {\n-    let extern = 0; //~ ERROR expected unit struct/variant or constant, found module `extern`\n+    let extern = 0; //~ ERROR cannot find unit struct/variant or constant `extern` in this scope\n }"}, {"sha": "69fc4b4f7f8fcb1dc41e82caf0132b888ac8421a", "filename": "src/test/compile-fail/rfc-2126-extern-absolute-paths/single-segment.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-absolute-paths%2Fsingle-segment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-absolute-paths%2Fsingle-segment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-absolute-paths%2Fsingle-segment.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -11,10 +11,8 @@\n // aux-build:xcrate.rs\n // edition:2018\n \n-use crate; //~ ERROR unresolved import `crate`\n-           //~^ NOTE crate root imports need to be explicitly named: `use crate as name;`\n-use *; //~ ERROR unresolved import `*`\n-       //~^ NOTE cannot glob-import all possible crates\n+use crate; //~ ERROR crate root imports need to be explicitly named: `use crate as name;`\n+use *; //~ ERROR cannot glob-import all possible crates\n \n fn main() {\n     let s = ::xcrate; //~ ERROR expected value, found module `xcrate`"}, {"sha": "017844a0252e274218fd12275d665839b59d5993", "filename": "src/test/compile-fail/rfc-2126-extern-in-paths/single-segment.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-in-paths%2Fsingle-segment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-in-paths%2Fsingle-segment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-extern-in-paths%2Fsingle-segment.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -14,8 +14,7 @@\n \n use extern; //~ ERROR unresolved import `extern`\n             //~^ NOTE no `extern` in the root\n-use extern::*; //~ ERROR unresolved import `extern::*`\n-               //~^ NOTE cannot glob-import all possible crates\n+use extern::*; //~ ERROR cannot glob-import all possible crates\n \n fn main() {\n     let s = extern::xcrate; //~ ERROR expected value, found module `extern::xcrate`"}, {"sha": "b8d920754ad7922846dcb55caa79f80fa2f7d1b7", "filename": "src/test/pretty/cast-lt.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fpretty%2Fcast-lt.pp", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fpretty%2Fcast-lt.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fcast-lt.pp?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -1,7 +1,7 @@\n #![feature(prelude_import)]\n #![no_std]\n #[prelude_import]\n-use std::prelude::v1::*;\n+use ::std::prelude::v1::*;\n #[macro_use]\n extern crate std;\n // Copyright 2017 The Rust Project Developers. See the COPYRIGHT"}, {"sha": "5f42b86c82a81e3c3984675c28a10c6431c81b7a", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -1,5 +1,5 @@\n #[prelude_import]\n-use std::prelude::v1::*;\n+use ::std::prelude::v1::*;\n #[macro_use]\n extern crate std;\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT"}, {"sha": "bf8dee0863a1bc51c502a06a59b9419ba9ff9b56", "filename": "src/test/run-pass/issue-52140/auxiliary/some_crate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52140%2Fauxiliary%2Fsome_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52140%2Fauxiliary%2Fsome_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52140%2Fauxiliary%2Fsome_crate.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn hello() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "6fae6adc44248502e69a83141e78c1c739e711ae", "filename": "src/test/run-pass/issue-52140/main.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52140%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52140%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52140%2Fmain.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:some_crate.rs\n+// edition:2018\n+\n+mod foo {\n+    pub use some_crate;\n+}\n+\n+fn main() {\n+    ::some_crate::hello();\n+    foo::some_crate::hello();\n+}"}, {"sha": "bf8dee0863a1bc51c502a06a59b9419ba9ff9b56", "filename": "src/test/run-pass/issue-52141/auxiliary/some_crate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52141%2Fauxiliary%2Fsome_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52141%2Fauxiliary%2Fsome_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52141%2Fauxiliary%2Fsome_crate.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn hello() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "8f3fc9f96989452119d0d397304e5a44d1a02010", "filename": "src/test/run-pass/issue-52141/main.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52141%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52141%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52141%2Fmain.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:some_crate.rs\n+// edition:2018\n+\n+use some_crate as some_name;\n+\n+mod foo {\n+    pub use crate::some_name::*;\n+}\n+\n+fn main() {\n+    ::some_crate::hello();\n+    some_name::hello();\n+    foo::hello();\n+}"}, {"sha": "48d53a2cbac0aa0c9df4d791792ed35890a753ed", "filename": "src/test/run-pass/issue-52705/auxiliary/png.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52705%2Fauxiliary%2Fpng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52705%2Fauxiliary%2Fpng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52705%2Fauxiliary%2Fpng.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+pub struct DecodingError;"}, {"sha": "101f67e3e7b98dfa278b5be1bb3f5fd26e93f1e2", "filename": "src/test/run-pass/issue-52705/main.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52705%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Fissue-52705%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52705%2Fmain.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:png.rs\n+// edition:2018\n+\n+mod png {\n+    use png as png_ext;\n+\n+    fn foo() -> png_ext::DecodingError { unimplemented!() }\n+}\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "086fd58cffa9e1d5cb2d9244edd7fd4b933f600c", "filename": "src/test/run-pass/uniform-paths/basic-nested.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic-nested.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `basic.rs`, but nested in modules.\n+\n+mod foo {\n+    // Test that ambiguity errors are not emitted between `self::test` and\n+    // `::test`, assuming the latter (crate) is not in `extern_prelude`.\n+    mod test {\n+        pub struct Foo(pub ());\n+    }\n+    pub use test::Foo;\n+\n+    // Test that qualified paths can refer to both the external crate and local item.\n+    mod std {\n+        pub struct io(pub ());\n+    }\n+    pub use ::std::io as std_io;\n+    pub use self::std::io as local_io;\n+}\n+\n+// Test that we can refer to the external crate unqualified\n+// (when there isn't a local item with the same name).\n+use std::io;\n+\n+mod bar {\n+    // Also test the unqualified external crate import in a nested module,\n+    // to show that the above import doesn't resolve through a local `std`\n+    // item, e.g. the automatically injected `extern crate std;`, which in\n+    // the Rust 2018 should no longer be visible through `crate::std`.\n+    pub use std::io;\n+}\n+\n+\n+fn main() {\n+    foo::Foo(());\n+    foo::std_io::stdout();\n+    foo::local_io(());\n+    io::stdout();\n+    bar::io::stdout();\n+}"}, {"sha": "59a0404e4c360b8588e44de1d44d4633bc4f70ea", "filename": "src/test/run-pass/uniform-paths/basic.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// Test that ambiguity errors are not emitted between `self::test` and\n+// `::test`, assuming the latter (crate) is not in `extern_prelude`.\n+mod test {\n+    pub struct Foo(pub ());\n+}\n+use test::Foo;\n+\n+// Test that qualified paths can refer to both the external crate and local item.\n+mod std {\n+    pub struct io(pub ());\n+}\n+use ::std::io as std_io;\n+use self::std::io as local_io;\n+\n+fn main() {\n+    Foo(());\n+    std_io::stdout();\n+    local_io(());\n+}"}, {"sha": "9cf05cd956039235881b3c7d0164d4997bc9c26c", "filename": "src/test/run-pass/uniform-paths/macros-nested.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros-nested.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `macros.rs`, but nested in modules.\n+\n+mod foo {\n+    // Test that ambiguity errors are not emitted between `self::test` and\n+    // `::test`, assuming the latter (crate) is not in `extern_prelude`.\n+    macro_rules! m1 {\n+        () => {\n+            mod test {\n+                pub struct Foo(pub ());\n+            }\n+        }\n+    }\n+    pub use test::Foo;\n+    m1!();\n+\n+    // Test that qualified paths can refer to both the external crate and local item.\n+    macro_rules! m2 {\n+        () => {\n+            mod std {\n+                pub struct io(pub ());\n+            }\n+        }\n+    }\n+    pub use ::std::io as std_io;\n+    pub use self::std::io as local_io;\n+    m2!();\n+}\n+\n+// Test that we can refer to the external crate unqualified\n+// (when there isn't a local item with the same name).\n+use std::io;\n+\n+mod bar {\n+    // Also test the unqualified external crate import in a nested module,\n+    // to show that the above import doesn't resolve through a local `std`\n+    // item, e.g. the automatically injected `extern crate std;`, which in\n+    // the Rust 2018 should no longer be visible through `crate::std`.\n+    pub use std::io;\n+}\n+\n+\n+fn main() {\n+    foo::Foo(());\n+    foo::std_io::stdout();\n+    foo::local_io(());\n+    io::stdout();\n+    bar::io::stdout();\n+}"}, {"sha": "ad74f5d0876bb94c3a713a03d37ec27003fad2a1", "filename": "src/test/run-pass/uniform-paths/macros.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `basic.rs`, but with macros defining local items.\n+\n+// Test that ambiguity errors are not emitted between `self::test` and\n+// `::test`, assuming the latter (crate) is not in `extern_prelude`.\n+macro_rules! m1 {\n+    () => {\n+        mod test {\n+            pub struct Foo(pub ());\n+        }\n+    }\n+}\n+use test::Foo;\n+m1!();\n+\n+// Test that qualified paths can refer to both the external crate and local item.\n+macro_rules! m2 {\n+    () => {\n+        mod std {\n+            pub struct io(pub ());\n+        }\n+    }\n+}\n+use ::std::io as std_io;\n+use self::std::io as local_io;\n+m2!();\n+\n+fn main() {\n+    Foo(());\n+    std_io::stdout();\n+    local_io(());\n+}"}, {"sha": "a3eefa7134c470ee4a17cdcae09cc69519ae225e", "filename": "src/test/run-pass/uniform-paths/same-crate.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Funiform-paths%2Fsame-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Frun-pass%2Funiform-paths%2Fsame-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fsame-crate.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+pub const A: usize = 0;\n+\n+pub mod foo {\n+    pub const B: usize = 1;\n+\n+    pub mod bar {\n+        pub const C: usize = 2;\n+\n+        pub enum E {\n+            V1(usize),\n+            V2(String),\n+        }\n+\n+        pub fn test() -> String {\n+            format!(\"{} {} {}\", crate::A, crate::foo::B, C)\n+        }\n+\n+        pub fn test_use() -> String {\n+            use crate::A;\n+            use crate::foo::B;\n+\n+            format!(\"{} {} {}\", A, B, C)\n+        }\n+\n+        pub fn test_enum() -> String {\n+            use E::*;\n+            match E::V1(10) {\n+                V1(i) => { format!(\"V1: {}\", i) }\n+                V2(s) => { format!(\"V2: {}\", s) }\n+            }\n+        }\n+    }\n+\n+    pub fn test() -> String {\n+        format!(\"{} {} {}\", crate::A, B, bar::C)\n+    }\n+\n+    pub fn test_use() -> String {\n+        use crate::A;\n+        use bar::C;\n+\n+        format!(\"{} {} {}\", A, B, C)\n+    }\n+\n+    pub fn test_enum() -> String {\n+        use bar::E::*;\n+        match bar::E::V1(10) {\n+            V1(i) => { format!(\"V1: {}\", i) }\n+            V2(s) => { format!(\"V2: {}\", s) }\n+        }\n+    }\n+}\n+\n+pub fn test() -> String {\n+    format!(\"{} {} {}\", A, foo::B, foo::bar::C)\n+}\n+\n+pub fn test_use() -> String {\n+    use foo::B;\n+    use foo::bar::C;\n+\n+    format!(\"{} {} {}\", A, B, C)\n+}\n+\n+pub fn test_enum() -> String {\n+    use foo::bar::E::*;\n+    match foo::bar::E::V1(10) {\n+        V1(i) => { format!(\"V1: {}\", i) }\n+        V2(s) => { format!(\"V2: {}\", s) }\n+    }\n+}\n+\n+fn main() {\n+    let output = [\n+        test(),\n+        foo::test(),\n+        foo::bar::test(),\n+        test_use(),\n+        foo::test_use(),\n+        foo::bar::test_use(),\n+        test_enum(),\n+        foo::test_enum(),\n+        foo::bar::test_enum(),\n+    ].join(\"\\n\");\n+    assert_eq!(output, \"\\\n+0 1 2\n+0 1 2\n+0 1 2\n+0 1 2\n+0 1 2\n+0 1 2\n+V1: 10\n+V1: 10\n+V1: 10\");\n+}"}, {"sha": "140655d52bd46a17002a2aa7141f1a343ed03d16", "filename": "src/test/ui/feature-gate-uniform-paths.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Ffeature-gate-uniform-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Ffeature-gate-uniform-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-uniform-paths.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod foo {\n+    pub use bar::Bar;\n+    //~^ ERROR unresolved import `bar`\n+\n+    pub mod bar {\n+        pub struct Bar;\n+    }\n+}\n+\n+fn main() {\n+    let _ = foo::Bar;\n+}"}, {"sha": "68faacfcbe75eafc318128796ce5fd34e1836951", "filename": "src/test/ui/feature-gate-uniform-paths.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Ffeature-gate-uniform-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Ffeature-gate-uniform-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-uniform-paths.stderr?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,9 @@\n+error[E0432]: unresolved import `bar`\n+  --> $DIR/feature-gate-uniform-paths.rs:12:13\n+   |\n+LL |     pub use bar::Bar;\n+   |             ^^^ Did you mean `self::bar`?\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "5f29e7bc99e94bf472bc7e13448bb47b13543335", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros-nested.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `ambiguity-macros.rs`, but nested in a module.\n+\n+mod foo {\n+    pub use std::io;\n+    //~^ ERROR import from `std` is ambiguous\n+\n+    macro_rules! m {\n+        () => {\n+            mod std {\n+                pub struct io;\n+            }\n+        }\n+    }\n+    m!();\n+}\n+\n+fn main() {}"}, {"sha": "d400987dfee3c8e8522618308dcff8f2107f6a2c", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros-nested.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,16 @@\n+error: import from `std` is ambiguous\n+  --> $DIR/ambiguity-macros-nested.rs:18:13\n+   |\n+LL |       pub use std::io;\n+   |               ^^^ could refer to external crate `::std`\n+...\n+LL | /             mod std {\n+LL | |                 pub struct io;\n+LL | |             }\n+   | |_____________- could also refer to `self::std`\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "547b2508b96ab42c453eaa8ab370131aab7a41f4", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `ambiguity.rs`, but with macros defining local items.\n+\n+use std::io;\n+//~^ ERROR import from `std` is ambiguous\n+\n+macro_rules! m {\n+    () => {\n+        mod std {\n+            pub struct io;\n+        }\n+    }\n+}\n+m!();\n+\n+fn main() {}"}, {"sha": "24a2061a3cb2aa63488465079bdb4442073d30d2", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,16 @@\n+error: import from `std` is ambiguous\n+  --> $DIR/ambiguity-macros.rs:17:5\n+   |\n+LL |   use std::io;\n+   |       ^^^ could refer to external crate `::std`\n+...\n+LL | /         mod std {\n+LL | |             pub struct io;\n+LL | |         }\n+   | |_________- could also refer to `self::std`\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "fe00fd94ee942a69069f1bebe78cf5ff88f8cfc0", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-nested.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `ambiguity.rs`, but nested in a module.\n+\n+mod foo {\n+    pub use std::io;\n+    //~^ ERROR import from `std` is ambiguous\n+\n+    mod std {\n+        pub struct io;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5104aba8b44a21b500dc84bd34e2c76a4a3f860d", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-nested.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,16 @@\n+error: import from `std` is ambiguous\n+  --> $DIR/ambiguity-nested.rs:18:13\n+   |\n+LL |       pub use std::io;\n+   |               ^^^ could refer to external crate `::std`\n+...\n+LL | /     mod std {\n+LL | |         pub struct io;\n+LL | |     }\n+   | |_____- could also refer to `self::std`\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "49ab2f0c19168e0e0071c21273e5869257894ca9", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+use std::io;\n+//~^ ERROR import from `std` is ambiguous\n+\n+mod std {\n+    pub struct io;\n+}\n+\n+fn main() {}"}, {"sha": "2e227dce96cb0ce7ffd348fd843fedb519ad0b41", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,16 @@\n+error: import from `std` is ambiguous\n+  --> $DIR/ambiguity.rs:15:5\n+   |\n+LL |   use std::io;\n+   |       ^^^ could refer to external crate `::std`\n+...\n+LL | / mod std {\n+LL | |     pub struct io;\n+LL | | }\n+   | |_- could also refer to `self::std`\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "b8489c61dadeeba13bd14c19a4dd7a102e9dfbce", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+enum Foo { A, B }\n+\n+fn main() {\n+    enum Foo {}\n+    use Foo::*;\n+    //~^ ERROR import from `Foo` is ambiguous\n+\n+    let _ = (A, B);\n+}"}, {"sha": "656af91a8c7fef55aa6e4d715ea4ed3605fb996e", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e05f80a3790bb96247e9325fe54e484086f77f5/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr?ref=3e05f80a3790bb96247e9325fe54e484086f77f5", "patch": "@@ -0,0 +1,13 @@\n+error: import from `Foo` is ambiguous\n+  --> $DIR/block-scoped-shadow.rs:19:9\n+   |\n+LL |     enum Foo {}\n+   |     ----------- shadowed by block-scoped `Foo`\n+LL |     use Foo::*;\n+   |         ^^^\n+   |\n+   = help: write `::Foo` or `self::Foo` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}]}