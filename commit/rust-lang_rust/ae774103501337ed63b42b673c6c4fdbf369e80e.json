{"sha": "ae774103501337ed63b42b673c6c4fdbf369e80e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNzc0MTAzNTAxMzM3ZWQ2M2I0MmI2NzNjNmM0ZmRiZjM2OWU4MGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-10T10:00:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-10T10:00:56Z"}, "message": "Auto merge of #35405 - futile:tests_warn_timeout, r=brson\n\nAdd warning timeout for tests that run >1min\n\nThis makes it easier to identify hanging tests. As described in #2873,\nwhen a test doesn't finish, we so far had no information on which test\nthat was. In this PR, we add a duration of 60 seconds for each test,\nafter which a warning will be printed mentioning that this specific test\nhas been running for a long time already.\n\nExample output:\nhttps://gist.github.com/futile/6ea3eed85fe632df8633c1b03c08b012\n\nr? @brson", "tree": {"sha": "25906f014a7bd0ed0dccfba3fe99dfcd3f18a7aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25906f014a7bd0ed0dccfba3fe99dfcd3f18a7aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae774103501337ed63b42b673c6c4fdbf369e80e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae774103501337ed63b42b673c6c4fdbf369e80e", "html_url": "https://github.com/rust-lang/rust/commit/ae774103501337ed63b42b673c6c4fdbf369e80e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae774103501337ed63b42b673c6c4fdbf369e80e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "561c4e1dd3f39434085d7958a69628600a71937c", "url": "https://api.github.com/repos/rust-lang/rust/commits/561c4e1dd3f39434085d7958a69628600a71937c", "html_url": "https://github.com/rust-lang/rust/commit/561c4e1dd3f39434085d7958a69628600a71937c"}, {"sha": "e9950618eac5133be9226b8eef2a2a4987245356", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9950618eac5133be9226b8eef2a2a4987245356", "html_url": "https://github.com/rust-lang/rust/commit/e9950618eac5133be9226b8eef2a2a4987245356"}], "stats": {"total": 59, "additions": 58, "deletions": 1}, "files": [{"sha": "64515b900d5b188e5b364319ecdd2d40ebd2ce90", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ae774103501337ed63b42b673c6c4fdbf369e80e/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae774103501337ed63b42b673c6c4fdbf369e80e/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ae774103501337ed63b42b673c6c4fdbf369e80e", "patch": "@@ -42,6 +42,7 @@\n #![feature(staged_api)]\n #![feature(question_mark)]\n #![feature(panic_unwind)]\n+#![feature(mpsc_recv_timeout)]\n \n extern crate getopts;\n extern crate term;\n@@ -73,6 +74,8 @@ use std::sync::{Arc, Mutex};\n use std::thread;\n use std::time::{Instant, Duration};\n \n+const TEST_WARN_TIMEOUT_S: u64 = 60;\n+\n // to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use {Bencher, TestName, TestResult, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n@@ -592,6 +595,12 @@ impl<T: Write> ConsoleTestState<T> {\n         }\n     }\n \n+    pub fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_plain(&format!(\"test {} has been running for over {} seconds\\n\",\n+                                  desc.name,\n+                                  TEST_WARN_TIMEOUT_S))\n+    }\n+\n     pub fn write_log(&mut self, test: &TestDesc, result: &TestResult) -> io::Result<()> {\n         match self.log_out {\n             None => Ok(()),\n@@ -709,6 +718,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n+            TeTimeout(ref test) => st.write_timeout(test),\n             TeResult(test, result, stdout) => {\n                 st.write_log(&test, &result)?;\n                 st.write_result(&result)?;\n@@ -830,6 +840,7 @@ enum TestEvent {\n     TeFiltered(Vec<TestDesc>),\n     TeWait(TestDesc, NamePadding),\n     TeResult(TestDesc, TestResult, Vec<u8>),\n+    TeTimeout(TestDesc),\n }\n \n pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n@@ -838,6 +849,9 @@ pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n     where F: FnMut(TestEvent) -> io::Result<()>\n {\n+    use std::collections::HashMap;\n+    use std::sync::mpsc::RecvTimeoutError;\n+\n     let mut filtered_tests = filter_tests(opts, tests);\n     if !opts.bench_benchmarks {\n         filtered_tests = convert_benchmarks_to_tests(filtered_tests);\n@@ -867,6 +881,29 @@ fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) ->\n \n     let (tx, rx) = channel::<MonitorMsg>();\n \n+    let mut running_tests: HashMap<TestDesc, Instant> = HashMap::new();\n+\n+    fn get_timed_out_tests(running_tests: &mut HashMap<TestDesc, Instant>) -> Vec<TestDesc> {\n+        let now = Instant::now();\n+        let timed_out = running_tests.iter()\n+            .filter_map(|(desc, timeout)| if &now >= timeout { Some(desc.clone())} else { None })\n+            .collect();\n+        for test in &timed_out {\n+            running_tests.remove(test);\n+        }\n+        timed_out\n+    };\n+\n+    fn calc_timeout(running_tests: &HashMap<TestDesc, Instant>) -> Option<Duration> {\n+        running_tests.values().min().map(|next_timeout| {\n+            let now = Instant::now();\n+            if *next_timeout >= now {\n+                *next_timeout - now\n+            } else {\n+                Duration::new(0, 0)\n+            }})\n+    };\n+\n     while pending > 0 || !remaining.is_empty() {\n         while pending < concurrency && !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n@@ -876,11 +913,31 @@ fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) ->\n                 // that hang forever.\n                 callback(TeWait(test.desc.clone(), test.testfn.padding()))?;\n             }\n+            let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n+            running_tests.insert(test.desc.clone(), timeout);\n             run_test(opts, !opts.run_tests, test, tx.clone());\n             pending += 1;\n         }\n \n-        let (desc, result, stdout) = rx.recv().unwrap();\n+        let mut res;\n+        loop {\n+            if let Some(timeout) = calc_timeout(&running_tests) {\n+                res = rx.recv_timeout(timeout);\n+                for test in get_timed_out_tests(&mut running_tests) {\n+                    callback(TeTimeout(test))?;\n+                }\n+                if res != Err(RecvTimeoutError::Timeout) {\n+                    break;\n+                }\n+            } else {\n+                res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n+                break;\n+            }\n+        }\n+\n+        let (desc, result, stdout) = res.unwrap();\n+        running_tests.remove(&desc);\n+\n         if concurrency != 1 {\n             callback(TeWait(desc.clone(), PadNone))?;\n         }"}]}