{"sha": "cbb5a001792618a2f100e3198f1f874cdce6900f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYjVhMDAxNzkyNjE4YTJmMTAwZTMxOThmMWY4NzRjZGNlNjkwMGY=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-06-06T20:13:52Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-01-14T02:26:38Z"}, "message": "Parallelize and optimize parts of HIR map creation", "tree": {"sha": "cdc1d80d2a1e6d024bf8b5de78ced4eab236790f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdc1d80d2a1e6d024bf8b5de78ced4eab236790f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbb5a001792618a2f100e3198f1f874cdce6900f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbb5a001792618a2f100e3198f1f874cdce6900f", "html_url": "https://github.com/rust-lang/rust/commit/cbb5a001792618a2f100e3198f1f874cdce6900f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbb5a001792618a2f100e3198f1f874cdce6900f/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9aee7ed335cfcaad33a6f6492497588b3d421b2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aee7ed335cfcaad33a6f6492497588b3d421b2d", "html_url": "https://github.com/rust-lang/rust/commit/9aee7ed335cfcaad33a6f6492497588b3d421b2d"}], "stats": {"total": 101, "additions": 57, "deletions": 44}, "files": [{"sha": "ae9bb37842990f393562ac56686e566e7b1aa810", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cbb5a001792618a2f100e3198f1f874cdce6900f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb5a001792618a2f100e3198f1f874cdce6900f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=cbb5a001792618a2f100e3198f1f874cdce6900f", "patch": "@@ -6,6 +6,7 @@ use rustc_data_structures::svh::Svh;\n use ich::Fingerprint;\n use middle::cstore::CrateStore;\n use session::CrateDisambiguator;\n+use session::Session;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax::source_map::SourceMap;\n@@ -92,11 +93,11 @@ where\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n-    pub(super) fn root(krate: &'hir Crate,\n+    pub(super) fn root(sess: &'a Session,\n+                       krate: &'hir Crate,\n                        dep_graph: &'a DepGraph,\n                        definitions: &'a definitions::Definitions,\n-                       mut hcx: StableHashingContext<'a>,\n-                       source_map: &'a SourceMap)\n+                       mut hcx: StableHashingContext<'a>)\n                 -> NodeCollector<'a, 'hir> {\n         let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n \n@@ -141,8 +142,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n         let mut collector = NodeCollector {\n             krate,\n-            source_map,\n-            map: vec![],\n+            source_map: sess.source_map(),\n+            map: repeat(None).take(sess.current_node_id_count()).collect(),\n             parent_node: CRATE_NODE_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n             current_full_dep_index: root_mod_full_dep_index,\n@@ -219,10 +220,6 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n     fn insert_entry(&mut self, id: NodeId, entry: Entry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n-        let len = self.map.len();\n-        if id.as_usize() >= len {\n-            self.map.extend(repeat(None).take(id.as_usize() - len + 1));\n-        }\n         self.map[id.as_usize()] = Some(entry);\n     }\n "}, {"sha": "91c8c29144406739d5d8456249a19f417793724e", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cbb5a001792618a2f100e3198f1f874cdce6900f/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb5a001792618a2f100e3198f1f874cdce6900f/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=cbb5a001792618a2f100e3198f1f874cdce6900f", "patch": "@@ -3,19 +3,24 @@ use hir::{self, intravisit, HirId, ItemLocalId};\n use syntax::ast::NodeId;\n use hir::itemlikevisit::ItemLikeVisitor;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::{Lock, ParallelIterator, par_iter};\n \n pub fn check_crate<'hir>(hir_map: &hir::map::Map<'hir>) {\n-    let mut outer_visitor = OuterVisitor {\n-        hir_map,\n-        errors: vec![],\n-    };\n-\n     hir_map.dep_graph.assert_ignored();\n \n-    hir_map.krate().visit_all_item_likes(&mut outer_visitor);\n-    if !outer_visitor.errors.is_empty() {\n-        let message = outer_visitor\n-            .errors\n+    let errors = Lock::new(Vec::new());\n+\n+    par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n+        hir_map.visit_item_likes_in_module(hir_map.local_def_id(*module_id), &mut OuterVisitor {\n+            hir_map,\n+            errors: &errors,\n+        });\n+    });\n+\n+    let errors = errors.into_inner();\n+\n+    if !errors.is_empty() {\n+        let message = errors\n             .iter()\n             .fold(String::new(), |s1, s2| s1 + \"\\n\" + s2);\n         bug!(\"{}\", message);\n@@ -26,12 +31,12 @@ struct HirIdValidator<'a, 'hir: 'a> {\n     hir_map: &'a hir::map::Map<'hir>,\n     owner_def_index: Option<DefIndex>,\n     hir_ids_seen: FxHashMap<ItemLocalId, NodeId>,\n-    errors: Vec<String>,\n+    errors: &'a Lock<Vec<String>>,\n }\n \n struct OuterVisitor<'a, 'hir: 'a> {\n     hir_map: &'a hir::map::Map<'hir>,\n-    errors: Vec<String>,\n+    errors: &'a Lock<Vec<String>>,\n }\n \n impl<'a, 'hir: 'a> OuterVisitor<'a, 'hir> {\n@@ -42,7 +47,7 @@ impl<'a, 'hir: 'a> OuterVisitor<'a, 'hir> {\n             hir_map,\n             owner_def_index: None,\n             hir_ids_seen: Default::default(),\n-            errors: Vec::new(),\n+            errors: self.errors,\n         }\n     }\n }\n@@ -51,23 +56,25 @@ impl<'a, 'hir: 'a> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir hir::Item) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n         inner_visitor.check(i.id, |this| intravisit::walk_item(this, i));\n-        self.errors.extend(inner_visitor.errors.drain(..));\n     }\n \n     fn visit_trait_item(&mut self, i: &'hir hir::TraitItem) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n         inner_visitor.check(i.id, |this| intravisit::walk_trait_item(this, i));\n-        self.errors.extend(inner_visitor.errors.drain(..));\n     }\n \n     fn visit_impl_item(&mut self, i: &'hir hir::ImplItem) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n         inner_visitor.check(i.id, |this| intravisit::walk_impl_item(this, i));\n-        self.errors.extend(inner_visitor.errors.drain(..));\n     }\n }\n \n impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n+    #[cold]\n+    #[inline(never)]\n+    fn error(&self, f: impl FnOnce() -> String) {\n+        self.errors.lock().push(f());\n+    }\n \n     fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self,\n                                                        node_id: NodeId,\n@@ -119,7 +126,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n                                            local_id,\n                                            self.hir_map.node_to_string(node_id)));\n             }\n-            self.errors.push(format!(\n+            self.error(|| format!(\n                 \"ItemLocalIds not assigned densely in {}. \\\n                 Max ItemLocalId = {}, missing IDs = {:?}; seens IDs = {:?}\",\n                 self.hir_map.def_path(DefId::local(owner_def_index)).to_string_no_crate(),\n@@ -145,14 +152,14 @@ impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n         let stable_id = self.hir_map.definitions().node_to_hir_id[node_id];\n \n         if stable_id == hir::DUMMY_HIR_ID {\n-            self.errors.push(format!(\"HirIdValidator: No HirId assigned for NodeId {}: {:?}\",\n+            self.error(|| format!(\"HirIdValidator: No HirId assigned for NodeId {}: {:?}\",\n                                      node_id,\n                                      self.hir_map.node_to_string(node_id)));\n             return;\n         }\n \n         if owner != stable_id.owner {\n-            self.errors.push(format!(\n+            self.error(|| format!(\n                 \"HirIdValidator: The recorded owner of {} is {} instead of {}\",\n                 self.hir_map.node_to_string(node_id),\n                 self.hir_map.def_path(DefId::local(stable_id.owner)).to_string_no_crate(),\n@@ -161,7 +168,7 @@ impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n \n         if let Some(prev) = self.hir_ids_seen.insert(stable_id.local_id, node_id) {\n             if prev != node_id {\n-                self.errors.push(format!(\n+                self.error(|| format!(\n                     \"HirIdValidator: Same HirId {}/{} assigned for nodes {} and {}\",\n                     self.hir_map.def_path(DefId::local(stable_id.owner)).to_string_no_crate(),\n                     stable_id.local_id.as_usize(),"}, {"sha": "869baef1f5afc9ee3c2a8f9d9b4d0cb5e70d5aff", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cbb5a001792618a2f100e3198f1f874cdce6900f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb5a001792618a2f100e3198f1f874cdce6900f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=cbb5a001792618a2f100e3198f1f874cdce6900f", "patch": "@@ -7,10 +7,11 @@ use dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n use hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId, DefIndexAddressSpace};\n \n-use middle::cstore::CrateStore;\n+use middle::cstore::CrateStoreDyn;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::sync::join;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n@@ -20,6 +21,7 @@ use hir::*;\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir::print::Nested;\n use util::nodemap::FxHashMap;\n+use util::common::time;\n \n use std::io;\n use std::result::Result::Err;\n@@ -1045,26 +1047,32 @@ impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n \n pub fn map_crate<'hir>(sess: &::session::Session,\n-                       cstore: &dyn CrateStore,\n-                       forest: &'hir mut Forest,\n+                       cstore: &CrateStoreDyn,\n+                       forest: &'hir Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n-    let (map, crate_hash) = {\n+    let ((map, crate_hash), hir_to_node_id) = join(|| {\n         let hcx = ::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n \n-        let mut collector = NodeCollector::root(&forest.krate,\n+        let mut collector = NodeCollector::root(sess,\n+                                                &forest.krate,\n                                                 &forest.dep_graph,\n                                                 &definitions,\n-                                                hcx,\n-                                                sess.source_map());\n+                                                hcx);\n         intravisit::walk_crate(&mut collector, &forest.krate);\n \n         let crate_disambiguator = sess.local_crate_disambiguator();\n         let cmdline_args = sess.opts.dep_tracking_hash();\n-        collector.finalize_and_compute_crate_hash(crate_disambiguator,\n-                                                  cstore,\n-                                                  cmdline_args)\n-    };\n+        collector.finalize_and_compute_crate_hash(\n+            crate_disambiguator,\n+            cstore,\n+            cmdline_args\n+        )\n+    }, || {\n+        // Build the reverse mapping of `node_to_hir_id`.\n+        definitions.node_to_hir_id.iter_enumerated()\n+                    .map(|(node_id, &hir_id)| (hir_id, node_id)).collect()\n+    });\n \n     if log_enabled!(::log::Level::Debug) {\n         // This only makes sense for ordered stores; note the\n@@ -1078,10 +1086,6 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    // Build the reverse mapping of `node_to_hir_id`.\n-    let hir_to_node_id = definitions.node_to_hir_id.iter_enumerated()\n-        .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();\n-\n     let map = Map {\n         forest,\n         dep_graph: forest.dep_graph.clone(),\n@@ -1091,7 +1095,9 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n         definitions,\n     };\n \n-    hir_id_validator::check_crate(&map);\n+    time(sess, \"validate hir map\", || {\n+        hir_id_validator::check_crate(&map);\n+    });\n \n     map\n }"}, {"sha": "fa0dfc4b38c8c4837d425321cf12377a97ac541c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb5a001792618a2f100e3198f1f874cdce6900f/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb5a001792618a2f100e3198f1f874cdce6900f/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=cbb5a001792618a2f100e3198f1f874cdce6900f", "patch": "@@ -407,6 +407,9 @@ impl Session {\n     pub fn next_node_id(&self) -> NodeId {\n         self.reserve_node_ids(1)\n     }\n+    pub(crate) fn current_node_id_count(&self) -> usize {\n+        self.next_node_id.get().as_u32() as usize\n+    }\n     pub fn diagnostic<'a>(&'a self) -> &'a errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }"}]}