{"sha": "5c7d530b5ec520073f7388519f39033a7b342eef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjN2Q1MzBiNWVjNTIwMDczZjczODg1MTlmMzkwMzNhN2IzNDJlZWY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-19T15:26:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-19T15:26:39Z"}, "message": "Rollup merge of #79149 - sexxi-goose:upvar_ref, r=nikomatsakis\n\nMove capture lowering from THIR to MIR\n\nThis allows us to:\n- Handle precise Places captured by a closure directly in MIR. Handling\n  captures in MIR is easier since we can rely on/ tweak PlaceBuilder to\n  generate `mir::Place`s that resemble how we store captures (`hir::Place`).\n\n- Handle `let _ = x` case when feature `capture_disjoint_fields`\n  is enabled directly in MIR. This is required to be done in MIR since\n  patterns are desugared in MIR.\n\nCloses: rust-lang/project-rfc-2229#25\n\nr? ```@nikomatsakis```", "tree": {"sha": "3f10fb9bc32c224aa589ff3984c41f6fecfb8a83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f10fb9bc32c224aa589ff3984c41f6fecfb8a83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c7d530b5ec520073f7388519f39033a7b342eef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfto6vCRBK7hj4Ov3rIwAAdHIIAFUGUB8A8RSAg9zuCayx8MHe\n3+dGJ0Nbr37+GJbnodGdSOeXexf7A1NKTIuGpmzS7j2vGZQEuJ0aq9og2wqjiip/\n2MEEG/qQRjXqGfJ1R8lNCE9pOQ/yNLN/C18S4EfRhHfAXYv12rn3SHweg6Hej3M+\nJHQvYGJn69o0wb4RLMXarmxv7M9dD7VElYf2/gOtEQM7/iaCtWwOf0NDOEtxpwWL\nbM4wPCKCzPrLdadPhhbvvgORwumvo2/fNvDyAtR6IbIbDc+UlJS1Bx/gRwIX9Qr5\nQTwuQQQ+zsWclTWDmlCS2nHhHfJHBubrLy3SBQOvVzjnSswz5uyAYEhgQRc91Hg=\n=Aspn\n-----END PGP SIGNATURE-----\n", "payload": "tree 3f10fb9bc32c224aa589ff3984c41f6fecfb8a83\nparent 62838c6b391768708ef260e27e82e9e05e11e046\nparent 9f70e782f7ee7c67c4ea693639c0e87b984d0234\nauthor Dylan DPC <dylan.dpc@gmail.com> 1605799599 +0100\ncommitter GitHub <noreply@github.com> 1605799599 +0100\n\nRollup merge of #79149 - sexxi-goose:upvar_ref, r=nikomatsakis\n\nMove capture lowering from THIR to MIR\n\nThis allows us to:\n- Handle precise Places captured by a closure directly in MIR. Handling\n  captures in MIR is easier since we can rely on/ tweak PlaceBuilder to\n  generate `mir::Place`s that resemble how we store captures (`hir::Place`).\n\n- Handle `let _ = x` case when feature `capture_disjoint_fields`\n  is enabled directly in MIR. This is required to be done in MIR since\n  patterns are desugared in MIR.\n\nCloses: rust-lang/project-rfc-2229#25\n\nr? ```@nikomatsakis```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c7d530b5ec520073f7388519f39033a7b342eef", "html_url": "https://github.com/rust-lang/rust/commit/5c7d530b5ec520073f7388519f39033a7b342eef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c7d530b5ec520073f7388519f39033a7b342eef/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62838c6b391768708ef260e27e82e9e05e11e046", "url": "https://api.github.com/repos/rust-lang/rust/commits/62838c6b391768708ef260e27e82e9e05e11e046", "html_url": "https://github.com/rust-lang/rust/commit/62838c6b391768708ef260e27e82e9e05e11e046"}, {"sha": "9f70e782f7ee7c67c4ea693639c0e87b984d0234", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f70e782f7ee7c67c4ea693639c0e87b984d0234", "html_url": "https://github.com/rust-lang/rust/commit/9f70e782f7ee7c67c4ea693639c0e87b984d0234"}], "stats": {"total": 232, "additions": 108, "deletions": 124}, "files": [{"sha": "e6263e5d6cf9bdbdf39a6378daab00f90bf6d122", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=5c7d530b5ec520073f7388519f39033a7b342eef", "patch": "@@ -160,7 +160,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 expr_span,\n                 source_info,\n             ),\n-            ExprKind::SelfRef => block.and(PlaceBuilder::from(Local::new(1))),\n+            ExprKind::UpvarRef { closure_def_id, var_hir_id } => {\n+                let capture = this\n+                    .hir\n+                    .typeck_results\n+                    .closure_captures\n+                    .get(&closure_def_id)\n+                    .and_then(|captures| captures.get_full(&var_hir_id));\n+\n+                if capture.is_none() {\n+                    if !this.hir.tcx().features().capture_disjoint_fields {\n+                        bug!(\n+                            \"No associated capture found for {:?} even though \\\n+                            capture_disjoint_fields isn't enabled\",\n+                            expr.kind\n+                        )\n+                    }\n+                    // FIXME(project-rfc-2229#24): Handle this case properly\n+                }\n+\n+                // Unwrap until the FIXME has been resolved\n+                let (capture_index, _, upvar_id) = capture.unwrap();\n+                this.lower_closure_capture(block, capture_index, *upvar_id)\n+            }\n+\n             ExprKind::VarRef { id } => {\n                 let place_builder = if this.is_bound_var_in_guard(id) {\n                     let index = this.var_local_id(id, RefWithinGuard);\n@@ -270,6 +293,61 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    /// Lower a closure/generator capture by representing it as a field\n+    /// access within the desugared closure/generator.\n+    ///\n+    /// `capture_index` is the index of the capture within the desugared\n+    /// closure/generator.\n+    fn lower_closure_capture(\n+        &mut self,\n+        block: BasicBlock,\n+        capture_index: usize,\n+        upvar_id: ty::UpvarId,\n+    )  -> BlockAnd<PlaceBuilder<'tcx>> {\n+        let closure_ty = self\n+            .hir\n+            .typeck_results()\n+            .node_type(self.hir.tcx().hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n+\n+        // Captures are represented using fields inside a structure.\n+        // This represents accessing self in the closure structure\n+        let mut place_builder = PlaceBuilder::from(Local::new(1));\n+\n+        // In case of Fn/FnMut closures we must deref to access the fields\n+        // Generators are considered FnOnce, so we ignore this step for them.\n+        if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n+            match self.hir.infcx().closure_kind(closure_substs).unwrap() {\n+                ty::ClosureKind::Fn | ty::ClosureKind::FnMut => {\n+                    place_builder = place_builder.deref();\n+                }\n+                ty::ClosureKind::FnOnce => {}\n+            }\n+        }\n+\n+        let substs = match closure_ty.kind() {\n+            ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n+            ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n+            _ => bug!(\"Lowering capture for non-closure type {:?}\", closure_ty)\n+        };\n+\n+        // Access the capture by accessing the field within the Closure struct.\n+        //\n+        // We must have inferred the capture types since we are building MIR, therefore\n+        // it's safe to call `upvar_tys` and we can unwrap here because\n+        // we know that the capture exists and is the `capture_index`-th capture.\n+        let var_ty = substs.upvar_tys().nth(capture_index).unwrap();\n+        place_builder = place_builder.field(Field::new(capture_index), var_ty);\n+\n+        // If the variable is captured via ByRef(Immutable/Mutable) Borrow,\n+        // we need to deref it\n+        match self.hir.typeck_results.upvar_capture(upvar_id) {\n+            ty::UpvarCapture::ByRef(_) => {\n+                block.and(place_builder.deref())\n+            }\n+            ty::UpvarCapture::ByValue(_) => block.and(place_builder),\n+        }\n+    }\n+\n     /// Lower an index expression\n     ///\n     /// This has two complications;"}, {"sha": "b6728c6b2ce94ee8004a63de8bfdc6fc7630763d", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=5c7d530b5ec520073f7388519f39033a7b342eef", "patch": "@@ -250,7 +250,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Deref { .. }\n             | ExprKind::Index { .. }\n             | ExprKind::VarRef { .. }\n-            | ExprKind::SelfRef\n+            | ExprKind::UpvarRef { .. }\n             | ExprKind::Break { .. }\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }"}, {"sha": "8561170856fd415708d02d6621f5f4d79b654487", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=5c7d530b5ec520073f7388519f39033a7b342eef", "patch": "@@ -38,7 +38,7 @@ impl Category {\n             ExprKind::Field { .. }\n             | ExprKind::Deref { .. }\n             | ExprKind::Index { .. }\n-            | ExprKind::SelfRef\n+            | ExprKind::UpvarRef { .. }\n             | ExprKind::VarRef { .. }\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => Some(Category::Place),"}, {"sha": "50001c38dc73744fe512571a2b12f9a9785649ea", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=5c7d530b5ec520073f7388519f39033a7b342eef", "patch": "@@ -400,7 +400,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             // Avoid creating a temporary\n             ExprKind::VarRef { .. }\n-            | ExprKind::SelfRef\n+            | ExprKind::UpvarRef { .. }\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => {\n                 debug_assert!(Category::of(&expr.kind) == Some(Category::Place));"}, {"sha": "e404afeb698a6809cf9209eb9a7ad51b7b7eb78c", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 118, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=5c7d530b5ec520073f7388519f39033a7b342eef", "patch": "@@ -880,130 +880,26 @@ fn convert_path_expr<'a, 'tcx>(\n             ExprKind::Deref { arg: Expr { ty, temp_lifetime, span: expr.span, kind }.to_ref() }\n         }\n \n-        Res::Local(var_hir_id) => convert_var(cx, expr, var_hir_id),\n+        Res::Local(var_hir_id) => convert_var(cx, var_hir_id),\n \n         _ => span_bug!(expr.span, \"res `{:?}` not yet implemented\", res),\n     }\n }\n \n-fn convert_var<'tcx>(\n-    cx: &mut Cx<'_, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    var_hir_id: hir::HirId,\n-) -> ExprKind<'tcx> {\n-    let upvar_index = cx\n-        .typeck_results()\n-        .closure_captures\n-        .get(&cx.body_owner)\n-        .and_then(|upvars| upvars.get_full(&var_hir_id).map(|(i, _, _)| i));\n-\n-    debug!(\n-        \"convert_var({:?}): upvar_index={:?}, body_owner={:?}\",\n-        var_hir_id, upvar_index, cx.body_owner\n-    );\n-\n-    let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-\n-    match upvar_index {\n-        None => ExprKind::VarRef { id: var_hir_id },\n+fn convert_var<'tcx>(cx: &mut Cx<'_, 'tcx>, var_hir_id: hir::HirId) -> ExprKind<'tcx> {\n+    // We want upvars here not captures.\n+    // Captures will be handled in MIR.\n+    let is_upvar = cx\n+        .tcx\n+        .upvars_mentioned(cx.body_owner)\n+        .map_or(false, |upvars| upvars.contains_key(&var_hir_id));\n \n-        Some(upvar_index) => {\n-            let closure_def_id = cx.body_owner;\n-            let upvar_id = ty::UpvarId {\n-                var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                closure_expr_id: closure_def_id.expect_local(),\n-            };\n-            let var_ty = cx.typeck_results().node_type(var_hir_id);\n+    debug!(\"convert_var({:?}): is_upvar={}, body_owner={:?}\", var_hir_id, is_upvar, cx.body_owner);\n \n-            // FIXME free regions in closures are not right\n-            let closure_ty = cx\n-                .typeck_results()\n-                .node_type(cx.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id));\n-\n-            // FIXME we're just hard-coding the idea that the\n-            // signature will be &self or &mut self and hence will\n-            // have a bound region with number 0\n-            let region = ty::ReFree(ty::FreeRegion {\n-                scope: closure_def_id,\n-                bound_region: ty::BoundRegion::BrAnon(0),\n-            });\n-            let region = cx.tcx.mk_region(region);\n-\n-            let self_expr = if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n-                match cx.infcx.closure_kind(closure_substs).unwrap() {\n-                    ty::ClosureKind::Fn => {\n-                        let ref_closure_ty = cx.tcx.mk_ref(\n-                            region,\n-                            ty::TypeAndMut { ty: closure_ty, mutbl: hir::Mutability::Not },\n-                        );\n-                        Expr {\n-                            ty: closure_ty,\n-                            temp_lifetime,\n-                            span: expr.span,\n-                            kind: ExprKind::Deref {\n-                                arg: Expr {\n-                                    ty: ref_closure_ty,\n-                                    temp_lifetime,\n-                                    span: expr.span,\n-                                    kind: ExprKind::SelfRef,\n-                                }\n-                                .to_ref(),\n-                            },\n-                        }\n-                    }\n-                    ty::ClosureKind::FnMut => {\n-                        let ref_closure_ty = cx.tcx.mk_ref(\n-                            region,\n-                            ty::TypeAndMut { ty: closure_ty, mutbl: hir::Mutability::Mut },\n-                        );\n-                        Expr {\n-                            ty: closure_ty,\n-                            temp_lifetime,\n-                            span: expr.span,\n-                            kind: ExprKind::Deref {\n-                                arg: Expr {\n-                                    ty: ref_closure_ty,\n-                                    temp_lifetime,\n-                                    span: expr.span,\n-                                    kind: ExprKind::SelfRef,\n-                                }\n-                                .to_ref(),\n-                            },\n-                        }\n-                    }\n-                    ty::ClosureKind::FnOnce => Expr {\n-                        ty: closure_ty,\n-                        temp_lifetime,\n-                        span: expr.span,\n-                        kind: ExprKind::SelfRef,\n-                    },\n-                }\n-            } else {\n-                Expr { ty: closure_ty, temp_lifetime, span: expr.span, kind: ExprKind::SelfRef }\n-            };\n-\n-            // at this point we have `self.n`, which loads up the upvar\n-            let field_kind =\n-                ExprKind::Field { lhs: self_expr.to_ref(), name: Field::new(upvar_index) };\n-\n-            // ...but the upvar might be an `&T` or `&mut T` capture, at which\n-            // point we need an implicit deref\n-            match cx.typeck_results().upvar_capture(upvar_id) {\n-                ty::UpvarCapture::ByValue(_) => field_kind,\n-                ty::UpvarCapture::ByRef(borrow) => ExprKind::Deref {\n-                    arg: Expr {\n-                        temp_lifetime,\n-                        ty: cx.tcx.mk_ref(\n-                            borrow.region,\n-                            ty::TypeAndMut { ty: var_ty, mutbl: borrow.kind.to_mutbl_lossy() },\n-                        ),\n-                        span: expr.span,\n-                        kind: field_kind,\n-                    }\n-                    .to_ref(),\n-                },\n-            }\n-        }\n+    if is_upvar {\n+        ExprKind::UpvarRef { closure_def_id: cx.body_owner, var_hir_id }\n+    } else {\n+        ExprKind::VarRef { id: var_hir_id }\n     }\n }\n \n@@ -1102,7 +998,7 @@ fn capture_upvar<'tcx>(\n         temp_lifetime,\n         ty: var_ty,\n         span: closure_expr.span,\n-        kind: convert_var(cx, closure_expr, var_hir_id),\n+        kind: convert_var(cx, var_hir_id),\n     };\n     match upvar_capture {\n         ty::UpvarCapture::ByValue(_) => captured_var.to_ref(),"}, {"sha": "465808cea9dd50cc9c1e03d9e99f2dcfb71e85bd", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=5c7d530b5ec520073f7388519f39033a7b342eef", "patch": "@@ -186,6 +186,10 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         ty.needs_drop(self.tcx, self.param_env)\n     }\n \n+    crate fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n+        self.infcx\n+    }\n+\n     crate fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }"}, {"sha": "1a901746d5086e971def252630d15dacd845a8d5", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c7d530b5ec520073f7388519f39033a7b342eef/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=5c7d530b5ec520073f7388519f39033a7b342eef", "patch": "@@ -211,8 +211,14 @@ crate enum ExprKind<'tcx> {\n     VarRef {\n         id: hir::HirId,\n     },\n-    /// first argument, used for self in a closure\n-    SelfRef,\n+    /// Used to represent upvars mentioned in a closure/generator\n+    UpvarRef {\n+        /// DefId of the closure/generator\n+        closure_def_id: DefId,\n+\n+        /// HirId of the root variable\n+        var_hir_id: hir::HirId,\n+    },\n     Borrow {\n         borrow_kind: BorrowKind,\n         arg: ExprRef<'tcx>,"}]}