{"sha": "4c79967760840c446ed6e7b570e68d91c8ed6a03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNzk5Njc3NjA4NDBjNDQ2ZWQ2ZTdiNTcwZTY4ZDkxYzhlZDZhMDM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-22T18:31:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-22T18:31:18Z"}, "message": "Rollup merge of #59170 - varkor:const-generics-rustdoc, r=QuietMisdreavus,eddyb\n\nAdd const generics to rustdoc\n\nSplit out from #53645. This work is a collaborative effort with @yodaldevoid.\n\nThe `FIXME`s are waiting on a refactor to `LazyConst`. I'll address these in a follow up, but I thought it would be better to implement the rest now to avoid bitrot.\n\nr? @QuietMisdreavus", "tree": {"sha": "5a424e3ebe0eb8772d5122463378582402bb2bc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a424e3ebe0eb8772d5122463378582402bb2bc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c79967760840c446ed6e7b570e68d91c8ed6a03", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJclSn2CRBK7hj4Ov3rIwAAdHIIAC7lWibY7YKz+GF2JAjc9zJI\nZEN7bqMxYUQkQjvM4UnMKITixTW4lTk1hke6s+vEvXQJgb6FeDjZfhMaHYFeoF57\nEpYZSWUn6X5DyPOPBwVz4wlWYiL4raqTF2MoNoyzFXPcER2BplvOpXymoZZI+Sw9\nzEiHWxgkjINMwfvsDfqAG0kdnZ8LsNslc4heknpQa+alWb/zWrB6pKVnJKDq368v\nsY3gKe0YIorXW5ni0e5/tb1oBISYu8razNzms1dqCDZYr93Ij2vZR49lCRJDZok1\nle9BNx/hT6HXgF6yOuUXupu0tpiSDhn4gIGfAvRHPE/t08ujzm2kdWGU6EfR4fA=\n=72Fn\n-----END PGP SIGNATURE-----\n", "payload": "tree 5a424e3ebe0eb8772d5122463378582402bb2bc3\nparent 5481b4e1d719a7d6de349c2e7a09574093710554\nparent 9bc58118fc80e01eab53c72cfd8658b58d21c593\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1553279478 +0100\ncommitter GitHub <noreply@github.com> 1553279478 +0100\n\nRollup merge of #59170 - varkor:const-generics-rustdoc, r=QuietMisdreavus,eddyb\n\nAdd const generics to rustdoc\n\nSplit out from #53645. This work is a collaborative effort with @yodaldevoid.\n\nThe `FIXME`s are waiting on a refactor to `LazyConst`. I'll address these in a follow up, but I thought it would be better to implement the rest now to avoid bitrot.\n\nr? @QuietMisdreavus\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c79967760840c446ed6e7b570e68d91c8ed6a03", "html_url": "https://github.com/rust-lang/rust/commit/4c79967760840c446ed6e7b570e68d91c8ed6a03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c79967760840c446ed6e7b570e68d91c8ed6a03/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5481b4e1d719a7d6de349c2e7a09574093710554", "url": "https://api.github.com/repos/rust-lang/rust/commits/5481b4e1d719a7d6de349c2e7a09574093710554", "html_url": "https://github.com/rust-lang/rust/commit/5481b4e1d719a7d6de349c2e7a09574093710554"}, {"sha": "9bc58118fc80e01eab53c72cfd8658b58d21c593", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc58118fc80e01eab53c72cfd8658b58d21c593", "html_url": "https://github.com/rust-lang/rust/commit/9bc58118fc80e01eab53c72cfd8658b58d21c593"}], "stats": {"total": 273, "additions": 156, "deletions": 117}, "files": [{"sha": "bff4190ae7925cb6aa6002f62cf1f5f82ed99727", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=4c79967760840c446ed6e7b570e68d91c8ed6a03", "patch": "@@ -591,12 +591,12 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            hir::ItemKind::Fn(ref decl, header, ref typarams, body) => {\n+            hir::ItemKind::Fn(ref decl, header, ref param_names, body) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n                               header,\n                               Some(item.ident.name),\n-                              typarams,\n+                              param_names,\n                               &item.vis,\n                               &[],\n                               Some(body))?;"}, {"sha": "adbe73b165ef4b812901be583e908b104929ab90", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=4c79967760840c446ed6e7b570e68d91c8ed6a03", "patch": "@@ -435,7 +435,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     let new_ty = match &poly_trait.trait_ {\n                         &Type::ResolvedPath {\n                             ref path,\n-                            ref typarams,\n+                            ref param_names,\n                             ref did,\n                             ref is_generic,\n                         } => {\n@@ -444,7 +444,13 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                                                 .expect(\"segments were empty\");\n \n                             let (old_input, old_output) = match last_segment.args {\n-                                GenericArgs::AngleBracketed { types, .. } => (types, None),\n+                                GenericArgs::AngleBracketed { args, .. } => {\n+                                    let types = args.iter().filter_map(|arg| match arg {\n+                                        GenericArg::Type(ty) => Some(ty.clone()),\n+                                        _ => None,\n+                                    }).collect();\n+                                    (types, None)\n+                                }\n                                 GenericArgs::Parenthesized { inputs, output, .. } => {\n                                     (inputs, output)\n                                 }\n@@ -469,7 +475,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n                             Type::ResolvedPath {\n                                 path: new_path,\n-                                typarams: typarams.clone(),\n+                                param_names: param_names.clone(),\n                                 did: did.clone(),\n                                 is_generic: *is_generic,\n                             }\n@@ -669,7 +675,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                             match **trait_ {\n                                 Type::ResolvedPath {\n                                     path: ref trait_path,\n-                                    ref typarams,\n+                                    ref param_names,\n                                     ref did,\n                                     ref is_generic,\n                                 } => {\n@@ -724,7 +730,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                         PolyTrait {\n                                             trait_: Type::ResolvedPath {\n                                                 path: new_trait_path,\n-                                                typarams: typarams.clone(),\n+                                                param_names: param_names.clone(),\n                                                 did: did.clone(),\n                                                 is_generic: *is_generic,\n                                             },"}, {"sha": "ba4481733d592cab99a8381dd8f5d4569e37d008", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 103, "deletions": 77, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4c79967760840c446ed6e7b570e68d91c8ed6a03", "patch": "@@ -17,11 +17,11 @@ use rustc::middle::resolve_lifetime as rl;\n use rustc::middle::lang_items;\n use rustc::middle::stability;\n use rustc::mir::interpret::{GlobalId, ConstValue};\n-use rustc::hir::{self, GenericArg, HirVec};\n+use rustc::hir::{self, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::map::DisambiguatedDefPathData;\n-use rustc::ty::subst::{Kind, InternalSubsts, SubstsRef};\n+use rustc::ty::subst::{Kind, InternalSubsts, SubstsRef, UnpackedKind};\n use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::ty::layout::VariantIdx;\n@@ -1057,7 +1057,7 @@ impl GenericBound {\n         GenericBound::TraitBound(PolyTrait {\n             trait_: ResolvedPath {\n                 path,\n-                typarams: None,\n+                param_names: None,\n                 did,\n                 is_generic: false,\n             },\n@@ -1101,42 +1101,48 @@ impl Clean<GenericBound> for hir::GenericBound {\n     }\n }\n \n-fn external_generic_args(cx: &DocContext<'_>, trait_did: Option<DefId>, has_self: bool,\n-                        bindings: Vec<TypeBinding>, substs: SubstsRef<'_>) -> GenericArgs {\n-    let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n-    let types = substs.types().skip(has_self as usize).collect::<Vec<_>>();\n+fn external_generic_args(\n+    cx: &DocContext<'_>,\n+    trait_did: Option<DefId>,\n+    has_self: bool,\n+    bindings: Vec<TypeBinding>,\n+    substs: SubstsRef<'_>,\n+) -> GenericArgs {\n+    let mut skip_self = has_self;\n+    let mut ty_sty = None;\n+    let args: Vec<_> = substs.iter().filter_map(|kind| match kind.unpack() {\n+        UnpackedKind::Lifetime(lt) => {\n+            lt.clean(cx).and_then(|lt| Some(GenericArg::Lifetime(lt)))\n+        }\n+        UnpackedKind::Type(_) if skip_self => {\n+            skip_self = false;\n+            None\n+        }\n+        UnpackedKind::Type(ty) => {\n+            ty_sty = Some(&ty.sty);\n+            Some(GenericArg::Type(ty.clean(cx)))\n+        }\n+        UnpackedKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n+    }).collect();\n \n     match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n         Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n-            assert_eq!(types.len(), 1);\n-            let inputs = match types[0].sty {\n-                ty::Tuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n-                _ => {\n-                    return GenericArgs::AngleBracketed {\n-                        lifetimes,\n-                        types: types.clean(cx),\n-                        bindings,\n-                    }\n-                }\n+            assert!(ty_sty.is_some());\n+            let inputs = match ty_sty {\n+                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.clean(cx)).collect(),\n+                _ => return GenericArgs::AngleBracketed { args, bindings },\n             };\n             let output = None;\n             // FIXME(#20299) return type comes from a projection now\n             // match types[1].sty {\n             //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n             //     _ => Some(types[1].clean(cx))\n             // };\n-            GenericArgs::Parenthesized {\n-                inputs,\n-                output,\n-            }\n+            GenericArgs::Parenthesized { inputs, output }\n         },\n         _ => {\n-            GenericArgs::AngleBracketed {\n-                lifetimes,\n-                types: types.clean(cx),\n-                bindings,\n-            }\n+            GenericArgs::AngleBracketed { args, bindings }\n         }\n     }\n }\n@@ -1188,7 +1194,7 @@ impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n             PolyTrait {\n                 trait_: ResolvedPath {\n                     path,\n-                    typarams: None,\n+                    param_names: None,\n                     did: trait_ref.def_id,\n                     is_generic: false,\n                 },\n@@ -1474,14 +1480,14 @@ impl GenericParamDef {\n     }\n }\n \n-impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n+impl Clean<GenericParamDef> for ty::GenericParamDef {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             ty::GenericParamDefKind::Lifetime => {\n                 (self.name.to_string(), GenericParamDefKind::Lifetime)\n             }\n             ty::GenericParamDefKind::Type { has_default, .. } => {\n-                cx.renderinfo.borrow_mut().external_typarams\n+                cx.renderinfo.borrow_mut().external_param_names\n                              .insert(self.def_id, self.name.clean(cx));\n                 let default = if has_default {\n                     Some(cx.tcx.type_of(self.def_id).clean(cx))\n@@ -1496,7 +1502,10 @@ impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n                 })\n             }\n             ty::GenericParamDefKind::Const { .. } => {\n-                unimplemented!() // FIXME(const_generics)\n+                (self.name.clean(cx), GenericParamDefKind::Const {\n+                    did: self.def_id,\n+                    ty: cx.tcx.type_of(self.def_id).clean(cx),\n+                })\n             }\n         };\n \n@@ -1697,9 +1706,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                         .flat_map(|param| match param.kind {\n                             ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n                             ty::GenericParamDefKind::Type { .. } => None,\n-                            ty::GenericParamDefKind::Const { .. } => {\n-                                unimplemented!() // FIXME(const_generics)\n-                            }\n+                            ty::GenericParamDefKind::Const { .. } => Some(param.clean(cx)),\n                         }).chain(simplify::ty_params(stripped_typarams).into_iter())\n                         .collect(),\n             where_predicates: simplify::where_clauses(cx, where_predicates),\n@@ -2260,7 +2267,7 @@ pub enum Type {\n     /// Structs/enums/traits (most that'd be an `hir::TyKind::Path`).\n     ResolvedPath {\n         path: Path,\n-        typarams: Option<Vec<GenericBound>>,\n+        param_names: Option<Vec<GenericBound>>,\n         did: DefId,\n         /// `true` if is a `T::Name` path for associated types.\n         is_generic: bool,\n@@ -2381,12 +2388,15 @@ impl Type {\n         }\n     }\n \n-    pub fn generics(&self) -> Option<&[Type]> {\n+    pub fn generics(&self) -> Option<Vec<Type>> {\n         match *self {\n             ResolvedPath { ref path, .. } => {\n                 path.segments.last().and_then(|seg| {\n-                    if let GenericArgs::AngleBracketed { ref types, .. } = seg.args {\n-                        Some(&**types)\n+                    if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n+                        Some(args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Type(ty) => Some(ty.clone()),\n+                            _ => None,\n+                        }).collect())\n                     } else {\n                         None\n                     }\n@@ -2722,15 +2732,15 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 match bounds[0].clean(cx).trait_ {\n-                    ResolvedPath { path, typarams: None, did, is_generic } => {\n+                    ResolvedPath { path, param_names: None, did, is_generic } => {\n                         let mut bounds: Vec<self::GenericBound> = bounds[1..].iter().map(|bound| {\n                             self::GenericBound::TraitBound(bound.clean(cx),\n                                                            hir::TraitBoundModifier::None)\n                         }).collect();\n                         if !lifetime.is_elided() {\n                             bounds.push(self::GenericBound::Outlives(lifetime.clean(cx)));\n                         }\n-                        ResolvedPath { path, typarams: Some(bounds), did, is_generic, }\n+                        ResolvedPath { path, param_names: Some(bounds), did, is_generic, }\n                     }\n                     _ => Infer // shouldn't happen\n                 }\n@@ -2797,7 +2807,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                          None, false, vec![], substs);\n                 ResolvedPath {\n                     path,\n-                    typarams: None,\n+                    param_names: None,\n                     did,\n                     is_generic: false,\n                 }\n@@ -2808,7 +2818,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                          None, false, vec![], InternalSubsts::empty());\n                 ResolvedPath {\n                     path: path,\n-                    typarams: None,\n+                    param_names: None,\n                     did: did,\n                     is_generic: false,\n                 }\n@@ -2829,8 +2839,8 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n                 inline::record_extern_fqn(cx, did, TypeKind::Trait);\n \n-                let mut typarams = vec![];\n-                reg.clean(cx).map(|b| typarams.push(GenericBound::Outlives(b)));\n+                let mut param_names = vec![];\n+                reg.clean(cx).map(|b| param_names.push(GenericBound::Outlives(b)));\n                 for did in dids {\n                     let empty = cx.tcx.intern_substs(&[]);\n                     let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n@@ -2839,13 +2849,13 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     let bound = GenericBound::TraitBound(PolyTrait {\n                         trait_: ResolvedPath {\n                             path,\n-                            typarams: None,\n+                            param_names: None,\n                             did,\n                             is_generic: false,\n                         },\n                         generic_params: Vec::new(),\n                     }, hir::TraitBoundModifier::None);\n-                    typarams.push(bound);\n+                    param_names.push(bound);\n                 }\n \n                 let mut bindings = vec![];\n@@ -2860,7 +2870,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     false, bindings, substs);\n                 ResolvedPath {\n                     path,\n-                    typarams: Some(typarams),\n+                    param_names: Some(param_names),\n                     did,\n                     is_generic: false,\n                 }\n@@ -2937,6 +2947,15 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Constant {\n+        Constant {\n+            type_: self.ty.clean(cx),\n+            expr: format!(\"{:?}\", self.val), // FIXME(const_generics)\n+        }\n+    }\n+}\n+\n impl Clean<Item> for hir::StructField {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n@@ -3244,11 +3263,27 @@ impl Clean<Path> for hir::Path {\n     }\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n+pub enum GenericArg {\n+    Lifetime(Lifetime),\n+    Type(Type),\n+    Const(Constant),\n+}\n+\n+impl fmt::Display for GenericArg {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            GenericArg::Lifetime(lt) => lt.fmt(f),\n+            GenericArg::Type(ty) => ty.fmt(f),\n+            GenericArg::Const(ct) => ct.fmt(f),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub enum GenericArgs {\n     AngleBracketed {\n-        lifetimes: Vec<Lifetime>,\n-        types: Vec<Type>,\n+        args: Vec<GenericArg>,\n         bindings: Vec<TypeBinding>,\n     },\n     Parenthesized {\n@@ -3266,27 +3301,19 @@ impl Clean<GenericArgs> for hir::GenericArgs {\n                 output: if output != Type::Tuple(Vec::new()) { Some(output) } else { None }\n             }\n         } else {\n-            let (mut lifetimes, mut types) = (vec![], vec![]);\n-            let mut elided_lifetimes = true;\n-            for arg in &self.args {\n-                match arg {\n-                    GenericArg::Lifetime(lt) => {\n-                        if !lt.is_elided() {\n-                            elided_lifetimes = false;\n-                        }\n-                        lifetimes.push(lt.clean(cx));\n-                    }\n-                    GenericArg::Type(ty) => {\n-                        types.push(ty.clean(cx));\n-                    }\n-                    GenericArg::Const(..) => {\n-                        unimplemented!() // FIXME(const_generics)\n-                    }\n-                }\n-            }\n+            let elide_lifetimes = self.args.iter().all(|arg| match arg {\n+                hir::GenericArg::Lifetime(lt) => lt.is_elided(),\n+                _ => true,\n+            });\n             GenericArgs::AngleBracketed {\n-                lifetimes: if elided_lifetimes { vec![] } else { lifetimes },\n-                types,\n+                args: self.args.iter().filter_map(|arg| match arg {\n+                    hir::GenericArg::Lifetime(lt) if !elide_lifetimes => {\n+                        Some(GenericArg::Lifetime(lt.clean(cx)))\n+                    }\n+                    hir::GenericArg::Lifetime(_) => None,\n+                    hir::GenericArg::Type(ty) => Some(GenericArg::Type(ty.clean(cx))),\n+                    hir::GenericArg::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n+                }).collect(),\n                 bindings: self.bindings.clean(cx),\n             }\n         }\n@@ -3310,8 +3337,8 @@ impl Clean<PathSegment> for hir::PathSegment {\n \n fn strip_type(ty: Type) -> Type {\n     match ty {\n-        Type::ResolvedPath { path, typarams, did, is_generic } => {\n-            Type::ResolvedPath { path: strip_path(&path), typarams, did, is_generic }\n+        Type::ResolvedPath { path, param_names, did, is_generic } => {\n+            Type::ResolvedPath { path: strip_path(&path), param_names, did, is_generic }\n         }\n         Type::Tuple(inner_tys) => {\n             Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n@@ -3338,9 +3365,8 @@ fn strip_path(path: &Path) -> Path {\n         PathSegment {\n             name: s.name.clone(),\n             args: GenericArgs::AngleBracketed {\n-                lifetimes: Vec::new(),\n-                types: Vec::new(),\n-                bindings: Vec::new(),\n+                args: vec![],\n+                bindings: vec![],\n             }\n         }\n     }).collect();\n@@ -3491,7 +3517,7 @@ impl Clean<Item> for doctree::Static {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct Constant {\n     pub type_: Type,\n     pub expr: String,\n@@ -3971,7 +3997,7 @@ fn resolve_type(cx: &DocContext<'_>,\n         _ => false,\n     };\n     let did = register_def(&*cx, path.def);\n-    ResolvedPath { path: path, typarams: None, did: did, is_generic: is_generic }\n+    ResolvedPath { path: path, param_names: None, did: did, is_generic: is_generic }\n }\n \n pub fn register_def(cx: &DocContext<'_>, def: Def) -> DefId {\n@@ -4397,9 +4423,9 @@ impl From<GenericBound> for SimpleBound {\n         match bound.clone() {\n             GenericBound::Outlives(l) => SimpleBound::Outlives(l),\n             GenericBound::TraitBound(t, mod_) => match t.trait_ {\n-                Type::ResolvedPath { path, typarams, .. } => {\n+                Type::ResolvedPath { path, param_names, .. } => {\n                     SimpleBound::TraitBound(path.segments,\n-                                            typarams\n+                                            param_names\n                                                 .map_or_else(|| Vec::new(), |v| v.iter()\n                                                         .map(|p| SimpleBound::from(p.clone()))\n                                                         .collect()),"}, {"sha": "1982a16f3b81dd84c95bef0fdc4a0d2a9a409fc1", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4c79967760840c446ed6e7b570e68d91c8ed6a03", "patch": "@@ -236,8 +236,16 @@ impl<'tcx> DocContext<'tcx> {\n                 ty::GenericParamDefKind::Type { .. } => {\n                     args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n                 }\n-                ty::GenericParamDefKind::Const { .. } => {\n-                    unimplemented!() // FIXME(const_generics)\n+                ty::GenericParamDefKind::Const => {\n+                    args.push(hir::GenericArg::Const(hir::ConstArg {\n+                        value: hir::AnonConst {\n+                            hir_id: hir::DUMMY_HIR_ID,\n+                            body: hir::BodyId {\n+                                hir_id: hir::DUMMY_HIR_ID,\n+                            }\n+                        },\n+                        span: DUMMY_SP,\n+                    }))\n                 }\n             }\n         }"}, {"sha": "3d8af7c7716b1475439bd40ba3252c09d6ccdb3e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=4c79967760840c446ed6e7b570e68d91c8ed6a03", "patch": "@@ -260,6 +260,14 @@ impl fmt::Display for clean::Lifetime {\n     }\n }\n \n+impl fmt::Display for clean::Constant {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.expr, f)?;\n+        f.write_str(\": \")?;\n+        fmt::Display::fmt(&self.type_, f)\n+    }\n+}\n+\n impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if !self.generic_params.is_empty() {\n@@ -301,32 +309,23 @@ impl fmt::Display for clean::GenericBound {\n impl fmt::Display for clean::GenericArgs {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            clean::GenericArgs::AngleBracketed {\n-                ref lifetimes, ref types, ref bindings\n-            } => {\n-                if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n+            clean::GenericArgs::AngleBracketed { ref args, ref bindings } => {\n+                if !args.is_empty() || !bindings.is_empty() {\n                     if f.alternate() {\n                         f.write_str(\"<\")?;\n                     } else {\n                         f.write_str(\"&lt;\")?;\n                     }\n                     let mut comma = false;\n-                    for lifetime in lifetimes {\n-                        if comma {\n-                            f.write_str(\", \")?;\n-                        }\n-                        comma = true;\n-                        write!(f, \"{}\", *lifetime)?;\n-                    }\n-                    for ty in types {\n+                    for arg in args {\n                         if comma {\n                             f.write_str(\", \")?;\n                         }\n                         comma = true;\n                         if f.alternate() {\n-                            write!(f, \"{:#}\", *ty)?;\n+                            write!(f, \"{:#}\", *arg)?;\n                         } else {\n-                            write!(f, \"{}\", *ty)?;\n+                            write!(f, \"{}\", *arg)?;\n                         }\n                     }\n                     for binding in bindings {\n@@ -522,8 +521,8 @@ fn primitive_link(f: &mut fmt::Formatter<'_>,\n \n /// Helper to render type parameters\n fn tybounds(w: &mut fmt::Formatter<'_>,\n-            typarams: &Option<Vec<clean::GenericBound>>) -> fmt::Result {\n-    match *typarams {\n+            param_names: &Option<Vec<clean::GenericBound>>) -> fmt::Result {\n+    match *param_names {\n         Some(ref params) => {\n             for param in params {\n                 write!(w, \" + \")?;\n@@ -560,13 +559,13 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n         clean::Generic(ref name) => {\n             f.write_str(name)\n         }\n-        clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n-            if typarams.is_some() {\n+        clean::ResolvedPath{ did, ref param_names, ref path, is_generic } => {\n+            if param_names.is_some() {\n                 f.write_str(\"dyn \")?;\n             }\n             // Paths like T::Output and Self::Output should be rendered with all segments\n             resolved_path(f, did, path, is_generic, use_absolute)?;\n-            tybounds(f, typarams)\n+            tybounds(f, param_names)\n         }\n         clean::Infer => write!(f, \"_\"),\n         clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n@@ -664,7 +663,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                         }\n                     }\n                 }\n-                clean::ResolvedPath { typarams: Some(ref v), .. } if !v.is_empty() => {\n+                clean::ResolvedPath { param_names: Some(ref v), .. } if !v.is_empty() => {\n                     write!(f, \"{}{}{}(\", amp, lt, m)?;\n                     fmt_type(&ty, f, use_absolute)?;\n                     write!(f, \")\")\n@@ -718,7 +717,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                 //        the ugliness comes from inlining across crates where\n                 //        everything comes in as a fully resolved QPath (hard to\n                 //        look at).\n-                box clean::ResolvedPath { did, ref typarams, .. } => {\n+                box clean::ResolvedPath { did, ref param_names, .. } => {\n                     match href(did) {\n                         Some((ref url, _, ref path)) if !f.alternate() => {\n                             write!(f,\n@@ -732,8 +731,8 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) ->\n                         _ => write!(f, \"{}\", name)?,\n                     }\n \n-                    // FIXME: `typarams` are not rendered, and this seems bad?\n-                    drop(typarams);\n+                    // FIXME: `param_names` are not rendered, and this seems bad?\n+                    drop(param_names);\n                     Ok(())\n                 }\n                 _ => {\n@@ -772,7 +771,7 @@ fn fmt_impl(i: &clean::Impl,\n             fmt::Display::fmt(ty, f)?;\n         } else {\n             match *ty {\n-                clean::ResolvedPath { typarams: None, ref path, is_generic: false, .. } => {\n+                clean::ResolvedPath { param_names: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n                     fmt::Display::fmt(&last.name, f)?;\n                     fmt::Display::fmt(&last.args, f)?;"}, {"sha": "445ce0637662d4918faf168e0ac9ca9d9ac869a1", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=4c79967760840c446ed6e7b570e68d91c8ed6a03", "patch": "@@ -271,7 +271,7 @@ pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n     /// when pretty-printing a type (so pretty-printing doesn't have to\n     /// painfully maintain a context like this)\n-    pub typarams: FxHashMap<DefId, String>,\n+    pub param_names: FxHashMap<DefId, String>,\n \n     /// Maps a type ID to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n@@ -368,7 +368,7 @@ pub struct Cache {\n pub struct RenderInfo {\n     pub inlined: FxHashSet<DefId>,\n     pub external_paths: crate::core::ExternalPaths,\n-    pub external_typarams: FxHashMap<DefId, String>,\n+    pub external_param_names: FxHashMap<DefId, String>,\n     pub exact_paths: FxHashMap<DefId, Vec<String>>,\n     pub access_levels: AccessLevels<DefId>,\n     pub deref_trait_did: Option<DefId>,\n@@ -601,7 +601,7 @@ pub fn run(mut krate: clean::Crate,\n     let RenderInfo {\n         inlined: _,\n         external_paths,\n-        external_typarams,\n+        external_param_names,\n         exact_paths,\n         access_levels,\n         deref_trait_did,\n@@ -635,7 +635,7 @@ pub fn run(mut krate: clean::Crate,\n         deref_mut_trait_did,\n         owned_box_did,\n         masked_crates: mem::replace(&mut krate.masked_crates, Default::default()),\n-        typarams: external_typarams,\n+        param_names: external_param_names,\n         aliases: Default::default(),\n     };\n \n@@ -1751,7 +1751,7 @@ impl<'a> Cache {\n                 clean::GenericParamDefKind::Lifetime => {}\n                 clean::GenericParamDefKind::Type { did, .. } |\n                 clean::GenericParamDefKind::Const { did, .. } => {\n-                    self.typarams.insert(did, param.name.clone());\n+                    self.param_names.insert(did, param.name.clone());\n                 }\n             }\n         }"}, {"sha": "07df14ddc722cc50b85b9582307794aa0d8e0fb4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c79967760840c446ed6e7b570e68d91c8ed6a03/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4c79967760840c446ed6e7b570e68d91c8ed6a03", "patch": "@@ -1263,13 +1263,13 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            ast::ItemKind::Fn(ref decl, header, ref typarams, ref body) => {\n+            ast::ItemKind::Fn(ref decl, header, ref param_names, ref body) => {\n                 self.head(\"\")?;\n                 self.print_fn(\n                     decl,\n                     header,\n                     Some(item.ident),\n-                    typarams,\n+                    param_names,\n                     &item.vis\n                 )?;\n                 self.s.word(\" \")?;"}]}