{"sha": "bacf9e9887872a40d16798813aa66b6916cc6a4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhY2Y5ZTk4ODc4NzJhNDBkMTY3OTg4MTNhYTY2YjY5MTZjYzZhNGU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-21T00:29:13Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-26T17:03:10Z"}, "message": "Clean up a bunch of box related code.", "tree": {"sha": "c5c891581469feb745be5e3b0884da32eeb4fa8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5c891581469feb745be5e3b0884da32eeb4fa8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bacf9e9887872a40d16798813aa66b6916cc6a4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bacf9e9887872a40d16798813aa66b6916cc6a4e", "html_url": "https://github.com/rust-lang/rust/commit/bacf9e9887872a40d16798813aa66b6916cc6a4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bacf9e9887872a40d16798813aa66b6916cc6a4e/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9d3ad0736dfc3a69f50155d2251f195de54b6c6", "html_url": "https://github.com/rust-lang/rust/commit/b9d3ad0736dfc3a69f50155d2251f195de54b6c6"}], "stats": {"total": 65, "additions": 27, "deletions": 38}, "files": [{"sha": "1adcbf8511555e2b9070800459f71fab9f44ade9", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bacf9e9887872a40d16798813aa66b6916cc6a4e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacf9e9887872a40d16798813aa66b6916cc6a4e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=bacf9e9887872a40d16798813aa66b6916cc6a4e", "patch": "@@ -398,18 +398,16 @@ fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef) ->\n     ret {box: box, body: body};\n }\n \n-fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    malloc_general_dyn(bcx, t, heap_shared,\n+fn malloc_general(bcx: block, t: ty::t, heap: heap) ->\n+    {box: ValueRef, body: ValueRef} {\n+    malloc_general_dyn(bcx, t, heap,\n                        llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n }\n-fn malloc_unique(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    malloc_general_dyn(bcx, t, heap_exchange,\n-                       llsize_of(bcx.ccx(), type_of(bcx.ccx(), t)))\n+fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n+    malloc_general(bcx, t, heap_shared)\n }\n-\n-fn malloc_unique_dyn(bcx: block, t: ty::t, size: ValueRef\n-                    ) -> {box: ValueRef, body: ValueRef} {\n-    malloc_general_dyn(bcx, t, heap_exchange, size)\n+fn malloc_unique(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n+    malloc_general(bcx, t, heap_exchange)\n }\n \n // Type descriptor and type glue stuff\n@@ -1487,6 +1485,19 @@ fn trans_lit(cx: block, e: @ast::expr, lit: ast::lit, dest: dest) -> block {\n     }\n }\n \n+\n+fn trans_boxed_expr(bcx: block, contents: @ast::expr,\n+                    t: ty::t, heap: heap,\n+                    dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"trans_boxed_expr\");\n+    let {box, body} = malloc_general(bcx, t, heap);\n+    add_clean_free(bcx, box, true);\n+    let bcx = trans_expr_save_in(bcx, contents, body);\n+    revoke_clean(bcx, box);\n+    ret store_in_dest(bcx, box, dest);\n+}\n+\n+\n fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_unary\");\n@@ -1509,35 +1520,25 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n     alt op {\n       ast::not {\n         let {bcx, val} = trans_temp_expr(bcx, e);\n-        ret store_in_dest(bcx, Not(bcx, val), dest);\n+        store_in_dest(bcx, Not(bcx, val), dest)\n       }\n       ast::neg {\n         let {bcx, val} = trans_temp_expr(bcx, e);\n         let neg = if ty::type_is_fp(e_ty) {\n             FNeg(bcx, val)\n         } else { Neg(bcx, val) };\n-        ret store_in_dest(bcx, neg, dest);\n+        store_in_dest(bcx, neg, dest)\n       }\n       ast::box(_) {\n-        let mut {box, body} = malloc_boxed(bcx, e_ty);\n-        add_clean_free(bcx, box, false);\n-        // Cast the body type to the type of the value. This is needed to\n-        // make enums work, since enums have a different LLVM type depending\n-        // on whether they're boxed or not\n-        let ccx = bcx.ccx();\n-        let llety = T_ptr(type_of(ccx, e_ty));\n-        body = PointerCast(bcx, body, llety);\n-        let bcx = trans_expr_save_in(bcx, e, body);\n-        revoke_clean(bcx, box);\n-        ret store_in_dest(bcx, box, dest);\n+        trans_boxed_expr(bcx, e, e_ty, heap_shared, dest)\n       }\n       ast::uniq(_) {\n-        ret uniq::trans_uniq(bcx, e, un_expr.id, dest);\n+        trans_boxed_expr(bcx, e, e_ty, heap_exchange, dest)\n       }\n       ast::deref {\n         bcx.sess().bug(\"deref expressions should have been \\\n                                translated using trans_lval(), not \\\n-                               trans_unary()\");\n+                               trans_unary()\")\n       }\n     }\n }"}, {"sha": "e0440147f16b6add6410015bac532e527799a1e4", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bacf9e9887872a40d16798813aa66b6916cc6a4e/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacf9e9887872a40d16798813aa66b6916cc6a4e/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=bacf9e9887872a40d16798813aa66b6916cc6a4e", "patch": "@@ -5,19 +5,7 @@ import build::*;\n import base::*;\n import shape::llsize_of;\n \n-export trans_uniq, make_free_glue, autoderef, duplicate;\n-\n-fn trans_uniq(bcx: block, contents: @ast::expr,\n-              node_id: ast::node_id, dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(\"uniq::trans_uniq\");\n-    let uniq_ty = node_id_type(bcx, node_id);\n-    let contents_ty = content_ty(uniq_ty);\n-    let {box, body} = malloc_unique(bcx, contents_ty);\n-    add_clean_free(bcx, box, true);\n-    let bcx = trans_expr_save_in(bcx, contents, body);\n-    revoke_clean(bcx, box);\n-    ret store_in_dest(bcx, box, dest);\n-}\n+export make_free_glue, autoderef, duplicate;\n \n fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)\n     -> block {\n@@ -64,4 +52,4 @@ fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     Store(bcx, td, dst_tydesc_ptr);\n \n     ret rslt(bcx, dst_box);\n-}\n\\ No newline at end of file\n+}"}]}