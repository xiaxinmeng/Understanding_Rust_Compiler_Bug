{"sha": "976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NmQ3YTUzY2JiMzVkMmY3ODE0ZDJkMTNkY2M1NWEzMDRkNWU3YTc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-06-26T14:00:42Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-19T05:53:57Z"}, "message": "debuginfo: Began refactoring of composite type handling.", "tree": {"sha": "417c37c9430085d23d08de92c953959d72389adc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/417c37c9430085d23d08de92c953959d72389adc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7", "html_url": "https://github.com/rust-lang/rust/commit/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3514a5af0629715604c9bfde11917133b9692798", "url": "https://api.github.com/repos/rust-lang/rust/commits/3514a5af0629715604c9bfde11917133b9692798", "html_url": "https://github.com/rust-lang/rust/commit/3514a5af0629715604c9bfde11917133b9692798"}], "stats": {"total": 340, "additions": 293, "deletions": 47}, "files": [{"sha": "215c002eec8d26c9df1fa269d0581451c50a05c6", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7", "patch": "@@ -1635,6 +1635,14 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMABIAlignmentOfType(TD: TargetDataRef,\n                                   Ty: TypeRef) -> c_uint;\n+\n+        /** Computes the byte offset of the indexed struct element for a target. */\n+        #[fast_ffi]\n+        pub unsafe fn LLVMOffsetOfElement(TD: TargetDataRef,\n+                                          StructTy: TypeRef,\n+                                          Element: c_uint)\n+                                       -> c_ulonglong;\n+\n         /**\n          * Returns the minimum alignment of a type when part of a call frame.\n          */"}, {"sha": "74d8825d6d46823a41bde9de131204a1fe850320", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 175, "deletions": 38, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7", "patch": "@@ -49,6 +49,7 @@ use lib::llvm::debuginfo::*;\n use middle::trans::common::*;\n use middle::trans::machine;\n use middle::trans::type_of;\n+use middle::trans::type_::Type;\n use middle::trans;\n use middle::ty;\n use util::ppaux::ty_to_str;\n@@ -65,6 +66,8 @@ use syntax::codemap::span;\n use syntax::{ast, codemap, ast_util, ast_map};\n use syntax::parse::token;\n \n+\n+\n static DW_LANG_RUST: int = 0x9000;\n \n static AutoVariableTag: int = 256;\n@@ -594,17 +597,102 @@ fn create_struct(cx: &mut CrateContext, struct_type: ty::t, fields: ~[ty::field]\n                 -> DICompositeType {\n     debug!(\"create_struct: %?\", ty::get(struct_type));\n \n+    let struct_name = ty_to_str(cx.tcx, struct_type);\n+    let struct_llvm_type = type_of::type_of(cx, struct_type);\n+\n+    let field_llvm_types = fields.map(|field| type_of::type_of(cx, field.mt.ty));\n+    let field_names = fields.map(|field| cx.sess.str_of(field.ident).to_owned());\n+    let field_types_metadata = fields.map(|field| create_ty(cx, field.mt.ty, span));\n+\n+    return create_composite_type(\n+        cx,\n+        struct_llvm_type,\n+        struct_name,\n+        field_llvm_types,\n+        field_names,\n+        field_types_metadata,\n+        span);\n+}\n+\n+fn create_tuple(cx: &mut CrateContext,\n+                tuple_type: ty::t,\n+                component_types: &[ty::t],\n+                span: span)\n+             -> DICompositeType {\n+\n+    let tuple_name = (cx.sess.str_of((dbg_cx(cx).names)(\"tuple\"))).to_owned();\n+    let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n+    // Create a vec of empty strings. A vec::build_n() function would be nice for this.\n+    let mut component_names : ~[~str] = vec::with_capacity(component_types.len());\n+    component_names.grow_fn(component_types.len(), |_| ~\"\");\n+\n+    let component_llvm_types = component_types.map(|it| type_of::type_of(cx, *it));\n+    let component_types_metadata = component_types.map(|it| create_ty(cx, *it, span));\n+\n+    return create_composite_type(\n+        cx,\n+        tuple_llvm_type,\n+        tuple_name,\n+        component_llvm_types,\n+        component_names,\n+        component_types_metadata,\n+        span);\n+}\n+\n+fn create_composite_type(cx: &mut CrateContext,\n+                         composite_llvm_type: Type,\n+                         composite_type_name: &str,\n+                         member_llvm_types: &[Type],\n+                         member_names: &[~str],\n+                         member_type_metadata: &[DIType],\n+                         span: span)\n+                      -> DICompositeType {\n+\n     let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n+    let file_metadata = create_file(cx, loc.file.name);\n+\n+    let composite_size = machine::llsize_of_alloc(cx, composite_llvm_type);\n+    let composite_align = machine::llalign_of_min(cx, composite_llvm_type);\n+\n+    let member_metadata = create_DIArray(\n+        DIB(cx),\n+        // transform the ty::t array of components into an array of DIEs\n+        do vec::mapi(member_llvm_types) |i, member_llvm_type| {\n+            let member_size = machine::llsize_of_alloc(cx, *member_llvm_type);\n+            let member_align = machine::llalign_of_min(cx, *member_llvm_type);\n+            let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n+            let member_name : &str = member_names[i];\n+\n+            do member_name.as_c_str |member_name| { unsafe {\n+                llvm::LLVMDIBuilderCreateMemberType(\n+                    DIB(cx),\n+                    file_metadata,\n+                    member_name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    bytes_to_bits(member_size),\n+                    bytes_to_bits(member_align),\n+                    bytes_to_bits(member_offset),\n+                    0,\n+                    member_type_metadata[i])\n+            }}\n+        });\n \n-    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, struct_type), file_md, loc.line);\n-    for fields.iter().advance |field| {\n-        let field_t = field.mt.ty;\n-        let ty_md = create_ty(cx, field_t, span);\n-        let (size, align) = size_and_align_of(cx, field_t);\n-        scx.add_member(cx.sess.str_of(field.ident), loc.line, size, align, ty_md);\n-    }\n-    return scx.finalize();\n+    return do composite_type_name.as_c_str |name| { unsafe {\n+        llvm::LLVMDIBuilderCreateStructType(\n+            DIB(cx),\n+            file_metadata,\n+            name,\n+            file_metadata,\n+            loc.line as c_uint,\n+            bytes_to_bits(composite_size),\n+            bytes_to_bits(composite_align),\n+            0,\n+            ptr::null(),\n+            member_metadata,\n+            0,\n+            ptr::null())\n+    }};\n }\n \n // returns (void* type as a ValueRef, size in bytes, align in bytes)\n@@ -639,30 +727,83 @@ fn create_tuple(cx: &mut CrateContext, tuple_type: ty::t, elements: &[ty::t], sp\n     return scx.finalize();\n }\n \n-fn create_boxed_type(cx: &mut CrateContext, contents: ty::t,\n-                     span: span, boxed: DIType) -> DICompositeType {\n-    debug!(\"create_boxed_type: %?\", ty::get(contents));\n-\n-    let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n-    let int_t = ty::mk_int();\n-    let refcount_type = create_basic_type(cx, int_t, span);\n-    let name = ty_to_str(cx.tcx, contents);\n-\n-    let mut scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n-    scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n-               sys::min_align_of::<uint>(), refcount_type);\n-    // the tydesc and other pointers should be irrelevant to the\n-    // debugger, so treat them as void* types\n-    let (vp, vpsize, vpalign) = voidptr(cx);\n-    scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n-    scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n-    scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n-    let (size, align) = size_and_align_of(cx, contents);\n-    scx.add_member(\"boxed\", 0, size, align, boxed);\n-    return scx.finalize();\n+fn create_boxed_type(cx: &mut CrateContext,\n+                     content_type: ty::t,\n+                     span: span)\n+                  -> DICompositeType {\n+\n+    debug!(\"create_boxed_type: %?\", ty::get(content_type));\n+\n+    let content_llvm_type = type_of::type_of(cx, content_type);\n+    let content_type_metadata = create_ty(cx, content_type, span);\n+\n+    let box_llvm_type = Type::box(cx, &content_llvm_type);\n+    let member_llvm_types = box_llvm_type.field_types();\n+    let member_names = [~\"refcnt\", ~\"tydesc\", ~\"prev\", ~\"next\", ~\"val\"];\n+\n+    assert!(box_layout_is_as_expected(cx, member_llvm_types, content_llvm_type));\n+\n+    let int_type = ty::mk_int();\n+    let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n+\n+    let member_types_metadata = [\n+        create_ty(cx, int_type, span),\n+        create_ty(cx, nil_pointer_type, span),\n+        create_ty(cx, nil_pointer_type, span),\n+        create_ty(cx, nil_pointer_type, span),\n+        content_type_metadata\n+    ];\n+\n+    return create_composite_type(\n+        cx,\n+        box_llvm_type,\n+        \"box name\",\n+        member_llvm_types,\n+        member_names,\n+        member_types_metadata,\n+        span);\n+\n+    fn box_layout_is_as_expected(cx: &CrateContext,\n+                                 member_types: &[Type],\n+                                 content_type: Type)\n+                              -> bool {\n+        return member_types[0] == cx.int_type\n+            && member_types[1] == cx.tydesc_type.ptr_to()\n+            && member_types[2] == Type::i8().ptr_to()\n+            && member_types[3] == Type::i8().ptr_to()\n+            && member_types[4] == content_type;\n+    }\n }\n \n+// fn create_boxed_type(cx: &mut CrateContext,\n+//                      contents: ty::t,\n+//                      span: span,\n+//                      boxed: DIType)\n+//                   -> DICompositeType {\n+\n+//     debug!(\"create_boxed_type: %?\", ty::get(contents));\n+\n+//     let loc = span_start(cx, span);\n+//     let file_md = create_file(cx, loc.file.name);\n+//     let int_t = ty::mk_int();\n+//     let refcount_type = create_basic_type(cx, int_t, span);\n+//     let name = ty_to_str(cx.tcx, contents);\n+\n+//     let mut scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n+//     scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n+//                sys::min_align_of::<uint>(), refcount_type);\n+//     // the tydesc and other pointers should be irrelevant to the\n+//     // debugger, so treat them as void* types\n+//     let (vp, vpsize, vpalign) = voidptr(cx);\n+//     scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n+//     scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n+//     scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n+//     let (size, align) = size_and_align_of(cx, contents);\n+//     scx.add_member(\"val\", 0, size, align, boxed);\n+//     return scx.finalize();\n+// }\n+\n+\n fn create_fixed_vec(cx: &mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n                     len: uint, span: span) -> DIType {\n     debug!(\"create_fixed_vec: %?\", ty::get(_vec_t));\n@@ -840,9 +981,8 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n             create_unimpl_ty(cx, t)\n         }\n         ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => {\n-            let boxed = create_ty(cx, mt.ty, span);\n-            let box_md = create_boxed_type(cx, mt.ty, span, boxed);\n-            create_pointer_type(cx, t, span, box_md)\n+            let box_metadata = create_boxed_type(cx, mt.ty, span);\n+            create_pointer_type(cx, t, span, box_metadata)\n         },\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {\n@@ -858,10 +998,7 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span) -> DIType {\n                 }\n             }\n         },\n-        ty::ty_ptr(ref mt) => {\n-            let pointee = create_ty(cx, mt.ty, span);\n-            create_pointer_type(cx, t, span, pointee)\n-        },\n+        ty::ty_ptr(ref mt) |\n         ty::ty_rptr(_, ref mt) => {\n             let pointee = create_ty(cx, mt.ty, span);\n             create_pointer_type(cx, t, span, pointee)"}, {"sha": "c0b57a22065376047485793943d28fdb0b019b67", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7", "patch": "@@ -113,3 +113,48 @@ pub fn llalign_of(cx: &CrateContext, ty: Type) -> ValueRef {\n             llvm::LLVMAlignOf(ty.to_ref()), cx.int_type.to_ref(), False);\n     }\n }\n+\n+pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: uint) -> uint {\n+    unsafe {\n+        return llvm::LLVMOffsetOfElement(cx.td.lltd, struct_ty.to_ref(), element as u32) as uint;\n+    }\n+}\n+\n+// Computes the size of the data part of an enum.\n+pub fn static_size_of_enum(cx: &mut CrateContext, t: ty::t) -> uint {\n+    if cx.enum_sizes.contains_key(&t) {\n+        return cx.enum_sizes.get_copy(&t);\n+    }\n+\n+    debug!(\"static_size_of_enum %s\", ty_to_str(cx.tcx, t));\n+\n+    match ty::get(t).sty {\n+        ty::ty_enum(tid, ref substs) => {\n+            // Compute max(variant sizes).\n+            let mut max_size = 0;\n+            let variants = ty::enum_variants(cx.tcx, tid);\n+            for variants.iter().advance |variant| {\n+                if variant.args.len() == 0 {\n+                    loop;\n+                }\n+\n+                let lltypes = variant.args.map(|&variant_arg| {\n+                    let substituted = ty::subst(cx.tcx, substs, variant_arg);\n+                    type_of::sizing_type_of(cx, substituted)\n+                });\n+\n+                debug!(\"static_size_of_enum: variant %s type %s\",\n+                       cx.tcx.sess.str_of(variant.name),\n+                       cx.tn.type_to_str(Type::struct_(lltypes, false)));\n+\n+                let this_size = llsize_of_real(cx, Type::struct_(lltypes, false));\n+                if max_size < this_size {\n+                    max_size = this_size;\n+                }\n+            }\n+            cx.enum_sizes.insert(t, max_size);\n+            return max_size;\n+        }\n+        _ => cx.sess.bug(\"static_size_of_enum called on non-enum\")\n+    }\n+}"}, {"sha": "543d8f1cdb7a43598e6d8b7df5aaeeece5ac89b6", "filename": "src/test/debug-info/box.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Ftest%2Fdebug-info%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Ftest%2Fdebug-info%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbox.rs?ref=976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7", "patch": "@@ -8,20 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-\n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n // debugger:break _zzz\n // debugger:run\n // debugger:finish\n-// debugger:print a->boxed\n+// debugger:print a->val\n // check:$1 = 1\n-// debugger:print b->boxed\n+// debugger:print b->val\n // check:$2 = {2, 3.5}\n-// debugger:print c->boxed\n+// debugger:print c->val\n // check:$3 = 4\n-// debugger:print d->boxed\n+// debugger:print d->val\n // check:$4 = false\n \n fn main() {"}, {"sha": "31b4746267554c4754a3237b5e76664d9e7fb6af", "filename": "src/test/debug-info/boxed-struct.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fboxed-struct.rs?ref=976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// GDB doesn't know about UTF-32 character encoding and will print a rust char as only its numerical\n+// value.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print unique->val\n+// check:$1 = {x = 99, y = 999, z = 9999, w = 99999}\n+\n+// debugger:print managed->val\n+// check:$2 = {x = 88, y = 888, z = 8888, w = 88888}\n+\n+// debugger:print unique_dtor->val\n+// check:$3 = {x = 77, y = 777, z = 7777, w = 77777}\n+\n+// debugger:print managed_dtor->val\n+// check:$4 = {x = 33, y = 333, z = 3333, w = 33333}\n+\n+struct StructWithSomePadding {\n+    x: i16,\n+    y: i32,\n+    z: i32,\n+    w: i64\n+}\n+\n+struct StructWithDestructor {\n+    x: i16,\n+    y: i32,\n+    z: i32,\n+    w: i64\n+}\n+\n+impl Drop for StructWithDestructor {\n+    fn drop(&self) {}\n+}\n+\n+fn main() {\n+\n+    let unique = ~StructWithSomePadding { x: 99, y: 999, z: 9999, w: 99999 };\n+    let managed = @StructWithSomePadding { x: 88, y: 888, z: 8888, w: 88888 };\n+\n+    let unique_dtor = ~StructWithDestructor { x: 77, y: 777, z: 7777, w: 77777 };\n+    let managed_dtor = @StructWithDestructor { x: 33, y: 333, z: 3333, w: 33333 };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}\n\\ No newline at end of file"}, {"sha": "9c72c676d54460ef9057213d43f688415c361f29", "filename": "src/test/debug-info/struct-with-destructor.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct-with-destructor.rs?ref=976d7a53cbb35d2f7814d2d13dcc55a304d5e7a7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n@@ -34,7 +32,7 @@ struct WithDestructor {\n }\n \n impl Drop for WithDestructor {\n-    fn finalize(&self) {}\n+    fn drop(&self) {}\n }\n \n struct NoDestructorGuarded {"}]}