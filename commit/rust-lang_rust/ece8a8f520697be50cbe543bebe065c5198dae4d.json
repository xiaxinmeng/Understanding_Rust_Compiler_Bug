{"sha": "ece8a8f520697be50cbe543bebe065c5198dae4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZThhOGY1MjA2OTdiZTUwY2JlNTQzYmViZTA2NWM1MTk4ZGFlNGQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-30T00:33:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T17:32:33Z"}, "message": "std: Remove io::io_error\n\n* All I/O now returns IoResult<T> = Result<T, IoError>\n* All formatting traits now return fmt::Result = IoResult<()>\n* The if_ok!() macro was added to libstd", "tree": {"sha": "fa1bf049d3b5d781c8c56e0d0491a655ece485a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa1bf049d3b5d781c8c56e0d0491a655ece485a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ece8a8f520697be50cbe543bebe065c5198dae4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ece8a8f520697be50cbe543bebe065c5198dae4d", "html_url": "https://github.com/rust-lang/rust/commit/ece8a8f520697be50cbe543bebe065c5198dae4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ece8a8f520697be50cbe543bebe065c5198dae4d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be4fc638092bf896c5c6c0672136b83b71e491ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/be4fc638092bf896c5c6c0672136b83b71e491ee", "html_url": "https://github.com/rust-lang/rust/commit/be4fc638092bf896c5c6c0672136b83b71e491ee"}], "stats": {"total": 1981, "additions": 920, "deletions": 1061}, "files": [{"sha": "e0944dea9b27628a6c68ed33be188e5f92cc6ddc", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 92, "deletions": 86, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -501,6 +501,8 @@ use num::Signed;\n pub mod parse;\n pub mod rt;\n \n+pub type Result = io::IoResult<()>;\n+\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n@@ -527,7 +529,7 @@ pub struct Formatter<'a> {\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n pub struct Argument<'a> {\n-    priv formatter: extern \"Rust\" fn(&util::Void, &mut Formatter),\n+    priv formatter: extern \"Rust\" fn(&util::Void, &mut Formatter) -> Result,\n     priv value: &'a util::Void,\n }\n \n@@ -561,50 +563,50 @@ pub struct Arguments<'a> {\n /// to this trait. There is not an explicit way of selecting this trait to be\n /// used for formatting, it is only if no other format is specified.\n #[allow(missing_doc)]\n-pub trait Show { fn fmt(&Self, &mut Formatter); }\n+pub trait Show { fn fmt(&Self, &mut Formatter) -> Result; }\n \n /// Format trait for the `b` character\n #[allow(missing_doc)]\n-pub trait Bool { fn fmt(&Self, &mut Formatter); }\n+pub trait Bool { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `c` character\n #[allow(missing_doc)]\n-pub trait Char { fn fmt(&Self, &mut Formatter); }\n+pub trait Char { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `i` and `d` characters\n #[allow(missing_doc)]\n-pub trait Signed { fn fmt(&Self, &mut Formatter); }\n+pub trait Signed { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `u` character\n #[allow(missing_doc)]\n-pub trait Unsigned { fn fmt(&Self, &mut Formatter); }\n+pub trait Unsigned { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `o` character\n #[allow(missing_doc)]\n-pub trait Octal { fn fmt(&Self, &mut Formatter); }\n+pub trait Octal { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `b` character\n #[allow(missing_doc)]\n-pub trait Binary { fn fmt(&Self, &mut Formatter); }\n+pub trait Binary { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `x` character\n #[allow(missing_doc)]\n-pub trait LowerHex { fn fmt(&Self, &mut Formatter); }\n+pub trait LowerHex { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `X` character\n #[allow(missing_doc)]\n-pub trait UpperHex { fn fmt(&Self, &mut Formatter); }\n+pub trait UpperHex { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `s` character\n #[allow(missing_doc)]\n-pub trait String { fn fmt(&Self, &mut Formatter); }\n+pub trait String { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `?` character\n #[allow(missing_doc)]\n-pub trait Poly { fn fmt(&Self, &mut Formatter); }\n+pub trait Poly { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `p` character\n #[allow(missing_doc)]\n-pub trait Pointer { fn fmt(&Self, &mut Formatter); }\n+pub trait Pointer { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `f` character\n #[allow(missing_doc)]\n-pub trait Float { fn fmt(&Self, &mut Formatter); }\n+pub trait Float { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `e` character\n #[allow(missing_doc)]\n-pub trait LowerExp { fn fmt(&Self, &mut Formatter); }\n+pub trait LowerExp { fn fmt(&Self, &mut Formatter) -> Result; }\n /// Format trait for the `E` character\n #[allow(missing_doc)]\n-pub trait UpperExp { fn fmt(&Self, &mut Formatter); }\n+pub trait UpperExp { fn fmt(&Self, &mut Formatter) -> Result; }\n \n // FIXME #11938 - UFCS would make us able call the above methods\n // directly Show::show(x, fmt).\n@@ -659,15 +661,15 @@ uniform_fn_call_workaround! {\n /// let w = &mut io::stdout() as &mut io::Writer;\n /// format_args!(|args| { fmt::write(w, args) }, \"Hello, {}!\", \"world\");\n /// ```\n-pub fn write(output: &mut io::Writer, args: &Arguments) {\n+pub fn write(output: &mut io::Writer, args: &Arguments) -> Result {\n     unsafe { write_unsafe(output, args.fmt, args.args) }\n }\n \n /// The `writeln` function takes the same arguments as `write`, except that it\n /// will also write a newline (`\\n`) character at the end of the format string.\n-pub fn writeln(output: &mut io::Writer, args: &Arguments) {\n-    unsafe { write_unsafe(output, args.fmt, args.args) }\n-    output.write(['\\n' as u8]);\n+pub fn writeln(output: &mut io::Writer, args: &Arguments) -> Result {\n+    let first = unsafe { write_unsafe(output, args.fmt, args.args) };\n+    first.and_then(|()| output.write(['\\n' as u8]))\n }\n \n /// The `write_unsafe` function takes an output stream, a precompiled format\n@@ -692,7 +694,7 @@ pub fn writeln(output: &mut io::Writer, args: &Arguments) {\n /// format string.\n pub unsafe fn write_unsafe(output: &mut io::Writer,\n                            fmt: &[rt::Piece],\n-                           args: &[Argument]) {\n+                           args: &[Argument]) -> Result {\n     let mut formatter = Formatter {\n         flags: 0,\n         width: None,\n@@ -704,8 +706,9 @@ pub unsafe fn write_unsafe(output: &mut io::Writer,\n         curarg: args.iter(),\n     };\n     for piece in fmt.iter() {\n-        formatter.run(piece, None);\n+        if_ok!(formatter.run(piece, None));\n     }\n+    Ok(())\n }\n \n /// The format function takes a precompiled format string and a list of\n@@ -752,7 +755,7 @@ pub fn format(args: &Arguments) -> ~str {\n /// format string.\n pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n     let mut output = MemWriter::new();\n-    write_unsafe(&mut output as &mut io::Writer, fmt, args);\n+    write_unsafe(&mut output as &mut io::Writer, fmt, args).unwrap();\n     return str::from_utf8_owned(output.unwrap()).unwrap();\n }\n \n@@ -762,10 +765,10 @@ impl<'a> Formatter<'a> {\n     // at runtime. This consumes all of the compile-time statics generated by\n     // the format! syntax extension.\n \n-    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n+    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) -> Result {\n         match *piece {\n-            rt::String(s) => { self.buf.write(s.as_bytes()); }\n-            rt::CurrentArgument(()) => { self.buf.write(cur.unwrap().as_bytes()); }\n+            rt::String(s) => self.buf.write(s.as_bytes()),\n+            rt::CurrentArgument(()) => self.buf.write(cur.unwrap().as_bytes()),\n             rt::Argument(ref arg) => {\n                 // Fill in the format parameters into the formatter\n                 self.fill = arg.format.fill;\n@@ -782,8 +785,8 @@ impl<'a> Formatter<'a> {\n \n                 // Then actually do some printing\n                 match arg.method {\n-                    None => { (value.formatter)(value.value, self); }\n-                    Some(ref method) => { self.execute(*method, value); }\n+                    None => (value.formatter)(value.value, self),\n+                    Some(ref method) => self.execute(*method, value)\n                 }\n             }\n         }\n@@ -804,7 +807,7 @@ impl<'a> Formatter<'a> {\n         }\n     }\n \n-    fn execute(&mut self, method: &rt::Method, arg: Argument) {\n+    fn execute(&mut self, method: &rt::Method, arg: Argument) -> Result {\n         match *method {\n             // Pluralization is selection upon a numeric value specified as the\n             // parameter.\n@@ -847,7 +850,7 @@ impl<'a> Formatter<'a> {\n                     }\n                 }\n \n-                self.runplural(value, *default);\n+                self.runplural(value, *default)\n             }\n \n             // Select is just a matching against the string specified.\n@@ -860,24 +863,26 @@ impl<'a> Formatter<'a> {\n                 for s in selectors.iter() {\n                     if s.selector == value {\n                         for piece in s.result.iter() {\n-                            self.run(piece, Some(value));\n+                            if_ok!(self.run(piece, Some(value)));\n                         }\n-                        return;\n+                        return Ok(());\n                     }\n                 }\n                 for piece in default.iter() {\n-                    self.run(piece, Some(value));\n+                    if_ok!(self.run(piece, Some(value)));\n                 }\n+                Ok(())\n             }\n         }\n     }\n \n-    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n+    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) -> Result {\n         ::uint::to_str_bytes(value, 10, |buf| {\n             let valuestr = str::from_utf8(buf).unwrap();\n             for piece in pieces.iter() {\n-                self.run(piece, Some(valuestr));\n+                if_ok!(self.run(piece, Some(valuestr)));\n             }\n+            Ok(())\n         })\n     }\n \n@@ -899,7 +904,7 @@ impl<'a> Formatter<'a> {\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n     pub fn pad_integral(&mut self, s: &[u8], alternate_prefix: &str,\n-                        positive: bool) {\n+                        positive: bool) -> Result {\n         use fmt::parse::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n \n         let mut actual_len = s.len();\n@@ -916,32 +921,32 @@ impl<'a> Formatter<'a> {\n         let sign = |this: &mut Formatter| {\n             if !signprinted {\n                 if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {\n-                    this.buf.write(['+' as u8]);\n+                    if_ok!(this.buf.write(['+' as u8]));\n                 } else if !positive {\n-                    this.buf.write(['-' as u8]);\n+                    if_ok!(this.buf.write(['-' as u8]));\n                 }\n                 if this.flags & 1 << (FlagAlternate as uint) != 0 {\n-                    this.buf.write(alternate_prefix.as_bytes());\n+                    if_ok!(this.buf.write(alternate_prefix.as_bytes()));\n                 }\n                 signprinted = true;\n             }\n+            Ok(())\n         };\n \n         let emit = |this: &mut Formatter| {\n-            sign(this);\n-            this.buf.write(s);\n+            sign(this).and_then(|()| this.buf.write(s))\n         };\n \n         match self.width {\n-            None => { emit(self) }\n-            Some(min) if actual_len >= min => { emit(self) }\n+            None => emit(self),\n+            Some(min) if actual_len >= min => emit(self),\n             Some(min) => {\n                 if self.flags & 1 << (FlagSignAwareZeroPad as uint) != 0 {\n                     self.fill = '0';\n-                    sign(self);\n+                    if_ok!(sign(self));\n                 }\n                 self.with_padding(min - actual_len, parse::AlignRight, |me| {\n-                    emit(me);\n+                    emit(me)\n                 })\n             }\n         }\n@@ -958,11 +963,10 @@ impl<'a> Formatter<'a> {\n     ///               is longer than this length\n     ///\n     /// Notably this function ignored the `flag` parameters\n-    pub fn pad(&mut self, s: &str) {\n+    pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n         if self.width.is_none() && self.precision.is_none() {\n-            self.buf.write(s.as_bytes());\n-            return\n+            return self.buf.write(s.as_bytes());\n         }\n         // The `precision` field can be interpreted as a `max-width` for the\n         // string being formatted\n@@ -974,8 +978,7 @@ impl<'a> Formatter<'a> {\n                 let char_len = s.char_len();\n                 if char_len >= max {\n                     let nchars = ::cmp::min(max, char_len);\n-                    self.buf.write(s.slice_chars(0, nchars).as_bytes());\n-                    return\n+                    return self.buf.write(s.slice_chars(0, nchars).as_bytes());\n                 }\n             }\n             None => {}\n@@ -985,7 +988,7 @@ impl<'a> Formatter<'a> {\n         match self.width {\n             // If we're under the maximum length, and there's no minimum length\n             // requirements, then we can just emit the string\n-            None => { self.buf.write(s.as_bytes()) }\n+            None => self.buf.write(s.as_bytes()),\n \n             // If we're under the maximum width, check if we're over the minimum\n             // width, if so it's as easy as just emitting the string.\n@@ -997,7 +1000,7 @@ impl<'a> Formatter<'a> {\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n                 self.with_padding(width - s.len(), parse::AlignLeft, |me| {\n-                    me.buf.write(s.as_bytes());\n+                    me.buf.write(s.as_bytes())\n                 })\n             }\n         }\n@@ -1006,29 +1009,30 @@ impl<'a> Formatter<'a> {\n     fn with_padding(&mut self,\n                     padding: uint,\n                     default: parse::Alignment,\n-                    f: |&mut Formatter|) {\n+                    f: |&mut Formatter| -> Result) -> Result {\n         let align = match self.align {\n             parse::AlignUnknown => default,\n             parse::AlignLeft | parse::AlignRight => self.align\n         };\n         if align == parse::AlignLeft {\n-            f(self);\n+            if_ok!(f(self));\n         }\n         let mut fill = [0u8, ..4];\n         let len = self.fill.encode_utf8(fill);\n         for _ in range(0, padding) {\n-            self.buf.write(fill.slice_to(len));\n+            if_ok!(self.buf.write(fill.slice_to(len)));\n         }\n         if align == parse::AlignRight {\n-            f(self);\n+            if_ok!(f(self));\n         }\n+        Ok(())\n     }\n }\n \n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n-pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter),\n+pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n     unsafe {\n         Argument {\n@@ -1055,66 +1059,66 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n // Implementations of the core formatting traits\n \n impl Bool for bool {\n-    fn fmt(b: &bool, f: &mut Formatter) {\n-        String::fmt(&(if *b {\"true\"} else {\"false\"}), f);\n+    fn fmt(b: &bool, f: &mut Formatter) -> Result {\n+        String::fmt(&(if *b {\"true\"} else {\"false\"}), f)\n     }\n }\n \n impl<'a, T: str::Str> String for T {\n-    fn fmt(s: &T, f: &mut Formatter) {\n-        f.pad(s.as_slice());\n+    fn fmt(s: &T, f: &mut Formatter) -> Result {\n+        f.pad(s.as_slice())\n     }\n }\n \n impl Char for char {\n-    fn fmt(c: &char, f: &mut Formatter) {\n+    fn fmt(c: &char, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8, ..4];\n         let amt = c.encode_utf8(utf8);\n         let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };\n-        String::fmt(&s, f);\n+        String::fmt(&s, f)\n     }\n }\n \n macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n                        $name:ident, $prefix:expr) => {\n     impl $name for $ty {\n-        fn fmt(c: &$ty, f: &mut Formatter) {\n+        fn fmt(c: &$ty, f: &mut Formatter) -> Result {\n             ::$into::to_str_bytes(*c as $into, $base, |buf| {\n-                f.pad_integral(buf, $prefix, true);\n+                f.pad_integral(buf, $prefix, true)\n             })\n         }\n     }\n })\n macro_rules! upper_hex(($ty:ident, $into:ident) => {\n     impl UpperHex for $ty {\n-        fn fmt(c: &$ty, f: &mut Formatter) {\n+        fn fmt(c: &$ty, f: &mut Formatter) -> Result {\n             ::$into::to_str_bytes(*c as $into, 16, |buf| {\n-                upperhex(buf, f);\n+                upperhex(buf, f)\n             })\n         }\n     }\n })\n // Not sure why, but this causes an \"unresolved enum variant, struct or const\"\n // when inlined into the above macro...\n #[doc(hidden)]\n-pub fn upperhex(buf: &[u8], f: &mut Formatter) {\n+pub fn upperhex(buf: &[u8], f: &mut Formatter) -> Result {\n     let mut local = [0u8, ..16];\n     for i in ::iter::range(0, buf.len()) {\n         local[i] = match buf[i] as char {\n             'a' .. 'f' => (buf[i] - 'a' as u8) + 'A' as u8,\n             c => c as u8,\n         }\n     }\n-    f.pad_integral(local.slice_to(buf.len()), \"0x\", true);\n+    f.pad_integral(local.slice_to(buf.len()), \"0x\", true)\n }\n \n macro_rules! integer(($signed:ident, $unsigned:ident) => {\n     // Signed is special because it actuall emits the negative sign,\n     // nothing else should do that, however.\n     impl Signed for $signed {\n-        fn fmt(c: &$signed, f: &mut Formatter) {\n+        fn fmt(c: &$signed, f: &mut Formatter) -> Result {\n             ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10, |buf| {\n-                f.pad_integral(buf, \"\", *c >= 0);\n+                f.pad_integral(buf, \"\", *c >= 0)\n             })\n         }\n     }\n@@ -1138,75 +1142,77 @@ integer!(i64, u64)\n \n macro_rules! floating(($ty:ident) => {\n     impl Float for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) {\n+        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n                 Some(i) => ::$ty::to_str_exact(f.abs(), i),\n                 None => ::$ty::to_str_digits(f.abs(), 6)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n+            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n         }\n     }\n \n     impl LowerExp for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) {\n+        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n                 Some(i) => ::$ty::to_str_exp_exact(f.abs(), i, false),\n                 None => ::$ty::to_str_exp_digits(f.abs(), 6, false)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n+            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n         }\n     }\n \n     impl UpperExp for $ty {\n-        fn fmt(f: &$ty, fmt: &mut Formatter) {\n+        fn fmt(f: &$ty, fmt: &mut Formatter) -> Result {\n             // FIXME: this shouldn't perform an allocation\n             let s = match fmt.precision {\n                 Some(i) => ::$ty::to_str_exp_exact(f.abs(), i, true),\n                 None => ::$ty::to_str_exp_digits(f.abs(), 6, true)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0);\n+            fmt.pad_integral(s.as_bytes(), \"\", *f >= 0.0)\n         }\n     }\n })\n floating!(f32)\n floating!(f64)\n \n impl<T> Poly for T {\n-    fn fmt(t: &T, f: &mut Formatter) {\n+    fn fmt(t: &T, f: &mut Formatter) -> Result {\n         match (f.width, f.precision) {\n             (None, None) => {\n-                repr::write_repr(f.buf, t);\n+                repr::write_repr(f.buf, t)\n             }\n \n             // If we have a specified width for formatting, then we have to make\n             // this allocation of a new string\n             _ => {\n                 let s = repr::repr_to_str(t);\n-                f.pad(s);\n+                f.pad(s)\n             }\n         }\n     }\n }\n \n impl<T> Pointer for *T {\n-    fn fmt(t: &*T, f: &mut Formatter) {\n+    fn fmt(t: &*T, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (parse::FlagAlternate as uint);\n         ::uint::to_str_bytes(*t as uint, 16, |buf| {\n-            f.pad_integral(buf, \"0x\", true);\n+            f.pad_integral(buf, \"0x\", true)\n         })\n     }\n }\n impl<T> Pointer for *mut T {\n-    fn fmt(t: &*mut T, f: &mut Formatter) { Pointer::fmt(&(*t as *T), f) }\n+    fn fmt(t: &*mut T, f: &mut Formatter) -> Result {\n+        Pointer::fmt(&(*t as *T), f)\n+    }\n }\n \n // Implementation of Show for various core types\n \n macro_rules! delegate(($ty:ty to $other:ident) => {\n     impl<'a> Show for $ty {\n-        fn fmt(me: &$ty, f: &mut Formatter) {\n+        fn fmt(me: &$ty, f: &mut Formatter) -> Result {\n             $other::fmt(me, f)\n         }\n     }\n@@ -1229,10 +1235,10 @@ delegate!(f32 to Float)\n delegate!(f64 to Float)\n \n impl<T> Show for *T {\n-    fn fmt(me: &*T, f: &mut Formatter) { Pointer::fmt(me, f) }\n+    fn fmt(me: &*T, f: &mut Formatter) -> Result { Pointer::fmt(me, f) }\n }\n impl<T> Show for *mut T {\n-    fn fmt(me: &*mut T, f: &mut Formatter) { Pointer::fmt(me, f) }\n+    fn fmt(me: &*mut T, f: &mut Formatter) -> Result { Pointer::fmt(me, f) }\n }\n \n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,"}, {"sha": "4163d1e0c96e8d94cffbdba914bd0c731e0b6482", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -27,13 +27,14 @@\n #[allow(missing_doc)];\n \n use container::Container;\n+use io::{Writer, IoResult};\n use iter::Iterator;\n+use num::ToStrRadix;\n use option::{Some, None};\n-use io::Writer;\n+use result::Ok;\n use str::OwnedStr;\n use to_bytes::IterBytes;\n use vec::ImmutableVector;\n-use num::ToStrRadix;\n \n // Alias `SipState` to `State`.\n pub use State = hash::SipState;\n@@ -164,7 +165,7 @@ macro_rules! compress (\n impl Writer for SipState {\n     // Methods for io::writer\n     #[inline]\n-    fn write(&mut self, msg: &[u8]) {\n+    fn write(&mut self, msg: &[u8]) -> IoResult<()> {\n         let length = msg.len();\n         self.length += length;\n \n@@ -180,7 +181,7 @@ impl Writer for SipState {\n                     t += 1;\n                 }\n                 self.ntail += length;\n-                return;\n+                return Ok(())\n             }\n \n             let mut t = 0;\n@@ -222,17 +223,14 @@ impl Writer for SipState {\n             t += 1\n         }\n         self.ntail = left;\n-    }\n-\n-    fn flush(&mut self) {\n-        // No-op\n+        Ok(())\n     }\n }\n \n impl Streaming for SipState {\n     #[inline]\n     fn input(&mut self, buf: &[u8]) {\n-        self.write(buf);\n+        self.write(buf).unwrap();\n     }\n \n     #[inline]"}, {"sha": "5e64862cbecb802e765d6367d47fd341efd54db4", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -11,10 +11,11 @@\n //! Buffering wrappers for I/O traits\n \n use container::Container;\n-use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE};\n+use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::ExactSize;\n use num;\n-use option::{Option, Some, None};\n+use option::{Some, None};\n+use result::{Ok, Err};\n use vec::{OwnedVector, ImmutableVector, MutableVector};\n use vec;\n \n@@ -86,17 +87,12 @@ impl<R: Reader> BufferedReader<R> {\n }\n \n impl<R: Reader> Buffer for BufferedReader<R> {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] {\n-        if self.pos == self.cap {\n-            match self.inner.read(self.buf) {\n-                Some(cap) => {\n-                    self.pos = 0;\n-                    self.cap = cap;\n-                }\n-                None => { self.eof = true; }\n-            }\n+    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+        while self.pos == self.cap {\n+            self.cap = if_ok!(self.inner.read(self.buf));\n+            self.pos = 0;\n         }\n-        return self.buf.slice(self.pos, self.cap);\n+        Ok(self.buf.slice(self.pos, self.cap))\n     }\n \n     fn consume(&mut self, amt: uint) {\n@@ -106,18 +102,15 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n }\n \n impl<R: Reader> Reader for BufferedReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let nread = {\n-            let available = self.fill();\n+            let available = if_ok!(self.fill());\n             let nread = num::min(available.len(), buf.len());\n             vec::bytes::copy_memory(buf, available.slice_to(nread));\n             nread\n         };\n         self.pos += nread;\n-        if nread == 0 && buf.len() != 0 && self.eof {\n-            return None;\n-        }\n-        Some(nread)\n+        Ok(nread)\n     }\n }\n \n@@ -161,10 +154,13 @@ impl<W: Writer> BufferedWriter<W> {\n         BufferedWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n-    fn flush_buf(&mut self) {\n+    fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            self.inner.write(self.buf.slice_to(self.pos));\n+            let ret = self.inner.write(self.buf.slice_to(self.pos));\n             self.pos = 0;\n+            ret\n+        } else {\n+            Ok(())\n         }\n     }\n \n@@ -178,29 +174,30 @@ impl<W: Writer> BufferedWriter<W> {\n     ///\n     /// The buffer is flushed before returning the writer.\n     pub fn unwrap(mut self) -> W {\n-        self.flush_buf();\n+        // FIXME: is failing the right thing to do if flushing fails?\n+        self.flush_buf().unwrap();\n         self.inner\n     }\n }\n \n impl<W: Writer> Writer for BufferedWriter<W> {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         if self.pos + buf.len() > self.buf.len() {\n-            self.flush_buf();\n+            if_ok!(self.flush_buf());\n         }\n \n         if buf.len() > self.buf.len() {\n-            self.inner.write(buf);\n+            self.inner.write(buf)\n         } else {\n             let dst = self.buf.mut_slice_from(self.pos);\n             vec::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n+            Ok(())\n         }\n     }\n \n-    fn flush(&mut self) {\n-        self.flush_buf();\n-        self.inner.flush();\n+    fn flush(&mut self) -> IoResult<()> {\n+        self.flush_buf().and_then(|()| self.inner.flush())\n     }\n }\n \n@@ -234,18 +231,19 @@ impl<W: Writer> LineBufferedWriter<W> {\n }\n \n impl<W: Writer> Writer for LineBufferedWriter<W> {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == '\\n' as u8) {\n             Some(i) => {\n-                self.inner.write(buf.slice_to(i + 1));\n-                self.inner.flush();\n-                self.inner.write(buf.slice_from(i + 1));\n+                if_ok!(self.inner.write(buf.slice_to(i + 1)));\n+                if_ok!(self.inner.flush());\n+                if_ok!(self.inner.write(buf.slice_from(i + 1)));\n+                Ok(())\n             }\n             None => self.inner.write(buf),\n         }\n     }\n \n-    fn flush(&mut self) { self.inner.flush() }\n+    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n }\n \n struct InternalBufferedWriter<W>(BufferedWriter<W>);\n@@ -258,7 +256,9 @@ impl<W> InternalBufferedWriter<W> {\n }\n \n impl<W: Reader> Reader for InternalBufferedWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.get_mut_ref().inner.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.get_mut_ref().inner.read(buf)\n+    }\n }\n \n /// Wraps a Stream and buffers input and output to and from it\n@@ -326,17 +326,23 @@ impl<S: Stream> BufferedStream<S> {\n }\n \n impl<S: Stream> Buffer for BufferedStream<S> {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] { self.inner.fill() }\n+    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill() }\n     fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n }\n \n impl<S: Stream> Reader for BufferedStream<S> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.inner.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.inner.read(buf)\n+    }\n }\n \n impl<S: Stream> Writer for BufferedStream<S> {\n-    fn write(&mut self, buf: &[u8]) { self.inner.inner.get_mut_ref().write(buf) }\n-    fn flush(&mut self) { self.inner.inner.get_mut_ref().flush() }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.inner.inner.get_mut_ref().write(buf)\n+    }\n+    fn flush(&mut self) -> IoResult<()> {\n+        self.inner.inner.get_mut_ref().flush()\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "e86ad50d69081a75f9f7f948700407f4fc708ccb", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -14,7 +14,7 @@ use comm::{Port, Chan};\n use cmp;\n use io;\n use option::{None, Option, Some};\n-use super::{Reader, Writer};\n+use super::{Reader, Writer, IoResult};\n use vec::{bytes, CloneableVector, MutableVector, ImmutableVector};\n \n /// Allows reading from a port.\n@@ -49,7 +49,7 @@ impl PortReader {\n }\n \n impl Reader for PortReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let mut num_read = 0;\n         loop {\n             match self.buf {\n@@ -71,10 +71,9 @@ impl Reader for PortReader {\n             self.closed = self.buf.is_none();\n         }\n         if self.closed && num_read == 0 {\n-            io::io_error::cond.raise(io::standard_error(io::EndOfFile));\n-            None\n+            Err(io::standard_error(io::EndOfFile))\n         } else {\n-            Some(num_read)\n+            Ok(num_read)\n         }\n     }\n }\n@@ -98,13 +97,15 @@ impl ChanWriter {\n }\n \n impl Writer for ChanWriter {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         if !self.chan.try_send(buf.to_owned()) {\n-            io::io_error::cond.raise(io::IoError {\n+            Err(io::IoError {\n                 kind: io::BrokenPipe,\n                 desc: \"Pipe closed\",\n                 detail: None\n-            });\n+            })\n+        } else {\n+            Ok(())\n         }\n     }\n }"}, {"sha": "7e1dbcaeade52fab891c10cf8b4d3cc5dcb94b53", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -46,7 +46,7 @@ impl<'r, R: Reader> Bytes<'r, R> {\n impl<'r, R: Reader> Iterator<u8> for Bytes<'r, R> {\n     #[inline]\n     fn next(&mut self) -> Option<u8> {\n-        self.reader.read_byte()\n+        self.reader.read_byte().ok()\n     }\n }\n "}, {"sha": "867e0ebd6ee090d6d5fb991b4ae800b1dc4a8cf4", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 171, "deletions": 188, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -27,21 +27,25 @@ particular bits of it, etc.\n \n # Example\n \n-    use std::io::{File, fs};\n+```rust\n+# #[allow(unused_must_use)];\n+use std::io::{File, fs};\n \n-    let path = Path::new(\"foo.txt\");\n+let path = Path::new(\"foo.txt\");\n \n-    // create the file, whether it exists or not\n-    let mut file = File::create(&path);\n-    file.write(bytes!(\"foobar\"));\n+// create the file, whether it exists or not\n+let mut file = File::create(&path);\n+file.write(bytes!(\"foobar\"));\n+# drop(file);\n \n-    // open the file in read-only mode\n-    let mut file = File::open(&path);\n-    file.read_to_end();\n+// open the file in read-only mode\n+let mut file = File::open(&path);\n+file.read_to_end();\n \n-    println!(\"{}\", path.stat().size);\n-    fs::symlink(&path, &Path::new(\"bar.txt\"));\n-    fs::unlink(&path);\n+println!(\"{}\", path.stat().size);\n+# drop(file);\n+fs::unlink(&path);\n+```\n \n */\n \n@@ -50,7 +54,7 @@ use clone::Clone;\n use iter::Iterator;\n use super::{Reader, Writer, Seek};\n use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n-            FileMode, FileAccess, FileStat, io_error, FilePermission};\n+            FileMode, FileAccess, FileStat, IoResult, FilePermission};\n use rt::rtio::{RtioFileStream, IoFactory, LocalIo};\n use io;\n use option::{Some, None, Option};\n@@ -81,22 +85,19 @@ impl File {\n     ///\n     /// # Example\n     ///\n-    ///     use std::io::{File, io_error, Open, ReadWrite};\n+    /// ```rust\n+    /// use std::io::{File, Open, ReadWrite};\n     ///\n-    ///     let p = Path::new(\"/some/file/path.txt\");\n+    /// let p = Path::new(\"/some/file/path.txt\");\n     ///\n-    ///     io_error::cond.trap(|_| {\n-    ///         // hoo-boy...\n-    ///     }).inside(|| {\n-    ///         let file = match File::open_mode(&p, Open, ReadWrite) {\n-    ///             Some(s) => s,\n-    ///             None => fail!(\"whoops! I'm sure this raised, anyways..\")\n-    ///         };\n-    ///         // do some stuff with that file\n+    /// let file = match File::open_mode(&p, Open, ReadWrite) {\n+    ///     Ok(f) => f,\n+    ///     Err(e) => fail!(\"file error: {}\", e),\n+    /// };\n+    /// // do some stuff with that file\n     ///\n-    ///         // the file will be closed at the end of this block\n-    ///     })\n-    ///     // ..\n+    /// // the file will be closed at the end of this block\n+    /// ```\n     ///\n     /// `FileMode` and `FileAccess` provide information about the permissions\n     /// context in which a given stream is created. More information about them\n@@ -119,7 +120,7 @@ impl File {\n     /// * Filesystem-level errors (full disk, etc)\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n-                     access: FileAccess) -> Option<File> {\n+                     access: FileAccess) -> IoResult<File> {\n         LocalIo::maybe_raise(|io| {\n             io.fs_open(&path.to_c_str(), mode, access).map(|fd| {\n                 File {\n@@ -139,10 +140,12 @@ impl File {\n     ///\n     /// # Example\n     ///\n-    ///     use std::io::File;\n+    /// ```rust\n+    /// use std::io::File;\n     ///\n-    ///     let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n-    pub fn open(path: &Path) -> Option<File> {\n+    /// let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n+    /// ```\n+    pub fn open(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Open, Read)\n     }\n \n@@ -154,11 +157,16 @@ impl File {\n     ///\n     /// # Example\n     ///\n-    ///     use std::io::File;\n+    /// ```rust\n+    /// # #[allow(unused_must_use)];\n+    /// use std::io::File;\n     ///\n-    ///     let mut f = File::create(&Path::new(\"foo.txt\"));\n-    ///     f.write(bytes!(\"This is a sample file\"));\n-    pub fn create(path: &Path) -> Option<File> {\n+    /// let mut f = File::create(&Path::new(\"foo.txt\"));\n+    /// f.write(bytes!(\"This is a sample file\"));\n+    /// # drop(f);\n+    /// # ::std::io::fs::unlnk(&Path::new(\"foo.txt\"));\n+    /// ```\n+    pub fn create(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Truncate, Write)\n     }\n \n@@ -174,8 +182,8 @@ impl File {\n     /// # Errors\n     ///\n     /// This function will raise on the `io_error` condition on failure.\n-    pub fn fsync(&mut self) {\n-        let _ = self.fd.fsync().map_err(|e| io_error::cond.raise(e));\n+    pub fn fsync(&mut self) -> IoResult<()> {\n+        self.fd.fsync()\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n@@ -186,8 +194,8 @@ impl File {\n     /// # Errors\n     ///\n     /// This function will raise on the `io_error` condition on failure.\n-    pub fn datasync(&mut self) {\n-        let _ = self.fd.datasync().map_err(|e| io_error::cond.raise(e));\n+    pub fn datasync(&mut self) -> IoResult<()> {\n+        self.fd.datasync()\n     }\n \n     /// Either truncates or extends the underlying file, updating the size of\n@@ -202,8 +210,8 @@ impl File {\n     /// # Errors\n     ///\n     /// On error, this function will raise on the `io_error` condition.\n-    pub fn truncate(&mut self, size: i64) {\n-        let _ = self.fd.truncate(size).map_err(|e| io_error::cond.raise(e));\n+    pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n+        self.fd.truncate(size)\n     }\n \n     /// Tests whether this stream has reached EOF.\n@@ -219,12 +227,13 @@ impl File {\n ///\n /// # Example\n ///\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io::fs;\n ///\n-///     let p = Path::new(\"/some/file/path.txt\");\n-///     fs::unlink(&p);\n-///     // if we made it here without failing, then the\n-///     // unlink operation was successful\n+/// let p = Path::new(\"/some/file/path.txt\");\n+/// fs::unlink(&p);\n+/// ```\n ///\n /// Note that, just because an unlink call was successful, it is not\n /// guaranteed that a file is immediately deleted (e.g. depending on\n@@ -235,8 +244,8 @@ impl File {\n /// This function will raise an `io_error` condition if the path points to a\n /// directory, the user lacks permissions to remove the file, or if some\n /// other filesystem-level error occurs.\n-pub fn unlink(path: &Path) {\n-    LocalIo::maybe_raise(|io| io.fs_unlink(&path.to_c_str()));\n+pub fn unlink(path: &Path) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_unlink(&path.to_c_str()))\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -249,48 +258,26 @@ pub fn unlink(path: &Path) {\n ///\n /// # Example\n ///\n-///     use std::io;\n-///     use std::io::fs;\n+/// ```rust\n+/// use std::io;\n+/// use std::io::fs;\n ///\n-///     let p = Path::new(\"/some/file/path.txt\");\n-///     match io::result(|| fs::stat(&p)) {\n-///         Ok(stat) => { /* ... */ }\n-///         Err(e) => { /* handle error */ }\n-///     }\n+/// let p = Path::new(\"/some/file/path.txt\");\n+/// match fs::stat(&p) {\n+///     Ok(stat) => { /* ... */ }\n+///     Err(e) => { /* handle error */ }\n+/// }\n+/// ```\n ///\n /// # Errors\n ///\n /// This call will raise an `io_error` condition if the user lacks the\n /// requisite permissions to perform a `stat` call on the given path or if\n /// there is no entry in the filesystem at the provided path.\n-pub fn stat(path: &Path) -> FileStat {\n+pub fn stat(path: &Path) -> IoResult<FileStat> {\n     LocalIo::maybe_raise(|io| {\n         io.fs_stat(&path.to_c_str())\n-    }).unwrap_or_else(dummystat)\n-}\n-\n-fn dummystat() -> FileStat {\n-    FileStat {\n-        path: Path::new(\"\"),\n-        size: 0,\n-        kind: io::TypeFile,\n-        perm: 0,\n-        created: 0,\n-        modified: 0,\n-        accessed: 0,\n-        unstable: io::UnstableFileStat {\n-            device: 0,\n-            inode: 0,\n-            rdev: 0,\n-            nlink: 0,\n-            uid: 0,\n-            gid: 0,\n-            blksize: 0,\n-            blocks: 0,\n-            flags: 0,\n-            gen: 0,\n-        }\n-    }\n+    })\n }\n \n /// Perform the same operation as the `stat` function, except that this\n@@ -301,28 +288,30 @@ fn dummystat() -> FileStat {\n /// # Errors\n ///\n /// See `stat`\n-pub fn lstat(path: &Path) -> FileStat {\n+pub fn lstat(path: &Path) -> IoResult<FileStat> {\n     LocalIo::maybe_raise(|io| {\n         io.fs_lstat(&path.to_c_str())\n-    }).unwrap_or_else(dummystat)\n+    })\n }\n \n /// Rename a file or directory to a new name.\n ///\n /// # Example\n ///\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io::fs;\n ///\n-///     fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n-///     // Oh boy, nothing was raised!\n+/// fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n+/// ```\n ///\n /// # Errors\n ///\n /// Will raise an `io_error` condition if the provided `path` doesn't exist,\n /// the process lacks permissions to view the contents, or if some other\n /// intermittent I/O error occurs.\n-pub fn rename(from: &Path, to: &Path) {\n-    LocalIo::maybe_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()));\n+pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()))\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -333,10 +322,12 @@ pub fn rename(from: &Path, to: &Path) {\n ///\n /// # Example\n ///\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io::fs;\n ///\n-///     fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n-///     // Oh boy, nothing was raised!\n+/// fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n+/// ```\n ///\n /// # Errors\n ///\n@@ -351,58 +342,63 @@ pub fn rename(from: &Path, to: &Path) {\n /// Note that this copy is not atomic in that once the destination is\n /// ensured to not exist, there is nothing preventing the destination from\n /// being created and then destroyed by this operation.\n-pub fn copy(from: &Path, to: &Path) {\n+pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n     if !from.is_file() {\n-        return io_error::cond.raise(IoError {\n+        return Err(IoError {\n             kind: io::MismatchedFileTypeForOperation,\n             desc: \"the source path is not an existing file\",\n             detail: None,\n-        });\n+        })\n     }\n \n-    let mut reader = match File::open(from) { Some(f) => f, None => return };\n-    let mut writer = match File::create(to) { Some(f) => f, None => return };\n+    let mut reader = if_ok!(File::open(from));\n+    let mut writer = if_ok!(File::create(to));\n     let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n \n     loop {\n-        match reader.read(buf) {\n-            Some(amt) => writer.write(buf.slice_to(amt)),\n-            None => break\n-        }\n+        let amt = match reader.read(buf) {\n+            Ok(n) => n,\n+            Err(ref e) if e.kind == io::EndOfFile => { break }\n+            Err(e) => return Err(e)\n+        };\n+        if_ok!(writer.write(buf.slice_to(amt)));\n     }\n \n-    chmod(to, from.stat().perm)\n+    chmod(to, if_ok!(from.stat()).perm)\n }\n \n /// Changes the permission mode bits found on a file or a directory. This\n /// function takes a mask from the `io` module\n ///\n /// # Example\n ///\n-///     use std::io;\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)]\n+/// use std::io;\n+/// use std::io::fs;\n ///\n-///     fs::chmod(&Path::new(\"file.txt\"), io::UserFile);\n-///     fs::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n-///     fs::chmod(&Path::new(\"dir\"),      io::UserDir);\n-///     fs::chmod(&Path::new(\"file.exe\"), io::UserExec);\n+/// fs::chmod(&Path::new(\"file.txt\"), io::UserFile);\n+/// fs::chmod(&Path::new(\"file.txt\"), io::UserRead | io::UserWrite);\n+/// fs::chmod(&Path::new(\"dir\"),      io::UserDir);\n+/// fs::chmod(&Path::new(\"file.exe\"), io::UserExec);\n+/// ```\n ///\n /// # Errors\n ///\n /// If this function encounters an I/O error, it will raise on the `io_error`\n /// condition. Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n-pub fn chmod(path: &Path, mode: io::FilePermission) {\n-    LocalIo::maybe_raise(|io| io.fs_chmod(&path.to_c_str(), mode));\n+pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_chmod(&path.to_c_str(), mode))\n }\n \n /// Change the user and group owners of a file at the specified path.\n ///\n /// # Errors\n ///\n /// This function will raise on the `io_error` condition on failure.\n-pub fn chown(path: &Path, uid: int, gid: int) {\n-    LocalIo::maybe_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid));\n+pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid))\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n@@ -412,8 +408,8 @@ pub fn chown(path: &Path, uid: int, gid: int) {\n /// # Errors\n ///\n /// This function will raise on the `io_error` condition on failure.\n-pub fn link(src: &Path, dst: &Path) {\n-    LocalIo::maybe_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()));\n+pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()))\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n@@ -422,8 +418,8 @@ pub fn link(src: &Path, dst: &Path) {\n /// # Errors\n ///\n /// This function will raise on the `io_error` condition on failure.\n-pub fn symlink(src: &Path, dst: &Path) {\n-    LocalIo::maybe_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()));\n+pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()))\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -433,83 +429,89 @@ pub fn symlink(src: &Path, dst: &Path) {\n /// This function will raise on the `io_error` condition on failure. Failure\n /// conditions include reading a file that does not exist or reading a file\n /// which is not a symlink.\n-pub fn readlink(path: &Path) -> Option<Path> {\n+pub fn readlink(path: &Path) -> IoResult<Path> {\n     LocalIo::maybe_raise(|io| io.fs_readlink(&path.to_c_str()))\n }\n \n /// Create a new, empty directory at the provided path\n ///\n /// # Example\n ///\n-///     use std::libc::S_IRWXU;\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io;\n+/// use std::io::fs;\n ///\n-///     let p = Path::new(\"/some/dir\");\n-///     fs::mkdir(&p, S_IRWXU as int);\n-///     // If we got here, our directory exists! Hooray!\n+/// let p = Path::new(\"/some/dir\");\n+/// fs::mkdir(&p, io::UserRWX);\n+/// ```\n ///\n /// # Errors\n ///\n /// This call will raise an `io_error` condition if the user lacks permissions\n /// to make a new directory at the provided path, or if the directory already\n /// exists.\n-pub fn mkdir(path: &Path, mode: FilePermission) {\n-    LocalIo::maybe_raise(|io| io.fs_mkdir(&path.to_c_str(), mode));\n+pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_mkdir(&path.to_c_str(), mode))\n }\n \n /// Remove an existing, empty directory\n ///\n /// # Example\n ///\n-///     use std::io::fs;\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io::fs;\n ///\n-///     let p = Path::new(\"/some/dir\");\n-///     fs::rmdir(&p);\n-///     // good riddance, you mean ol' directory\n+/// let p = Path::new(\"/some/dir\");\n+/// fs::rmdir(&p);\n+/// ```\n ///\n /// # Errors\n ///\n /// This call will raise an `io_error` condition if the user lacks permissions\n /// to remove the directory at the provided path, or if the directory isn't\n /// empty.\n-pub fn rmdir(path: &Path) {\n-    LocalIo::maybe_raise(|io| io.fs_rmdir(&path.to_c_str()));\n+pub fn rmdir(path: &Path) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_rmdir(&path.to_c_str()))\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n ///\n /// # Example\n ///\n-///     use std::io::fs;\n+/// ```rust\n+/// use std::io::fs;\n ///\n-///     // one possible implementation of fs::walk_dir only visiting files\n-///     fn visit_dirs(dir: &Path, cb: |&Path|) {\n-///         if dir.is_dir() {\n-///             let contents = fs::readdir(dir).unwrap();\n-///             for entry in contents.iter() {\n-///                 if entry.is_dir() { visit_dirs(entry, cb); }\n-///                 else { cb(entry); }\n-///             }\n+/// // one possible implementation of fs::walk_dir only visiting files\n+/// fn visit_dirs(dir: &Path, cb: |&Path|) {\n+///     if dir.is_dir() {\n+///         let contents = fs::readdir(dir).unwrap();\n+///         for entry in contents.iter() {\n+///             if entry.is_dir() { visit_dirs(entry, cb); }\n+///             else { cb(entry); }\n ///         }\n-///         else { fail!(\"nope\"); }\n ///     }\n+///     else { fail!(\"nope\"); }\n+/// }\n+/// ```\n ///\n /// # Errors\n ///\n /// Will raise an `io_error` condition if the provided `from` doesn't exist,\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n-pub fn readdir(path: &Path) -> ~[Path] {\n+pub fn readdir(path: &Path) -> IoResult<~[Path]> {\n     LocalIo::maybe_raise(|io| {\n         io.fs_readdir(&path.to_c_str(), 0)\n-    }).unwrap_or_else(|| ~[])\n+    })\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n /// rooted at `path`. The path given will not be iterated over, and this will\n /// perform iteration in a top-down order.\n-pub fn walk_dir(path: &Path) -> Directories {\n-    Directories { stack: readdir(path) }\n+pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n+    Ok(Directories { stack: if_ok!(readdir(path)) })\n }\n \n /// An iterator which walks over a directory\n@@ -522,7 +524,10 @@ impl Iterator<Path> for Directories {\n         match self.stack.shift() {\n             Some(path) => {\n                 if path.is_dir() {\n-                    self.stack.push_all_move(readdir(&path));\n+                    match readdir(&path) {\n+                        Ok(dirs) => { self.stack.push_all_move(dirs); }\n+                        Err(..) => {}\n+                    }\n                 }\n                 Some(path)\n             }\n@@ -539,14 +544,14 @@ impl Iterator<Path> for Directories {\n /// This function will raise on the `io_error` condition if an error\n /// happens, see `fs::mkdir` for more information about error conditions\n /// and performance.\n-pub fn mkdir_recursive(path: &Path, mode: FilePermission) {\n+pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n     // tjc: if directory exists but with different permissions,\n     // should we return false?\n     if path.is_dir() {\n-        return\n+        return Ok(())\n     }\n     if path.filename().is_some() {\n-        mkdir_recursive(&path.dir_path(), mode);\n+        if_ok!(mkdir_recursive(&path.dir_path(), mode));\n     }\n     mkdir(path, mode)\n }\n@@ -559,17 +564,17 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) {\n /// This function will raise on the `io_error` condition if an error\n /// happens. See `file::unlink` and `fs::readdir` for possible error\n /// conditions.\n-pub fn rmdir_recursive(path: &Path) {\n-    let children = readdir(path);\n+pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n+    let children = if_ok!(readdir(path));\n     for child in children.iter() {\n         if child.is_dir() {\n-            rmdir_recursive(child);\n+            if_ok!(rmdir_recursive(child));\n         } else {\n-            unlink(child);\n+            if_ok!(unlink(child));\n         }\n     }\n     // Directory should now be empty\n-    rmdir(path);\n+    rmdir(path)\n }\n \n /// Changes the timestamps for a file's last modification and access time.\n@@ -582,64 +587,42 @@ pub fn rmdir_recursive(path: &Path) {\n /// This function will raise on the `io_error` condition if an error\n /// happens.\n // FIXME(#10301) these arguments should not be u64\n-pub fn change_file_times(path: &Path, atime: u64, mtime: u64) {\n-    LocalIo::maybe_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime));\n+pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n+    LocalIo::maybe_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime))\n }\n \n impl Reader for File {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         match self.fd.read(buf) {\n             Ok(read) => {\n                 self.last_nread = read;\n                 match read {\n-                    0 => None,\n-                    _ => Some(read as uint)\n+                    0 => Err(io::standard_error(io::EndOfFile)),\n+                    _ => Ok(read as uint)\n                 }\n             },\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != io::EndOfFile {\n-                    io_error::cond.raise(ioerr);\n-                }\n-                return None;\n-            }\n+            Err(e) => Err(e),\n         }\n     }\n }\n \n impl Writer for File {\n-    fn write(&mut self, buf: &[u8]) {\n-        match self.fd.write(buf) {\n-            Ok(()) => (),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n-        }\n-    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.fd.write(buf) }\n }\n \n impl Seek for File {\n-    fn tell(&self) -> u64 {\n-        let res = self.fd.tell();\n-        match res {\n-            Ok(cursor) => cursor,\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                return -1;\n-            }\n-        }\n+    fn tell(&self) -> IoResult<u64> {\n+        self.fd.tell()\n     }\n \n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         match self.fd.seek(pos, style) {\n             Ok(_) => {\n                 // successful seek resets EOF indicator\n                 self.last_nread = -1;\n-                ()\n-            },\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n+                Ok(())\n             }\n+            Err(e) => Err(e),\n         }\n     }\n }\n@@ -650,7 +633,7 @@ impl path::Path {\n     /// Consult the `file::stat` documentation for more info.\n     ///\n     /// This call preserves identical runtime/error semantics with `file::stat`.\n-    pub fn stat(&self) -> FileStat { stat(self) }\n+    pub fn stat(&self) -> IoResult<FileStat> { stat(self) }\n \n     /// Boolean value indicator whether the underlying file exists on the local\n     /// filesystem. This will return true if the path points to either a\n@@ -660,7 +643,7 @@ impl path::Path {\n     ///\n     /// Will not raise a condition\n     pub fn exists(&self) -> bool {\n-        io::result(|| self.stat()).is_ok()\n+        self.stat().is_ok()\n     }\n \n     /// Whether the underlying implementation (be it a file path, or something\n@@ -672,7 +655,7 @@ impl path::Path {\n     ///\n     /// Will not raise a condition\n     pub fn is_file(&self) -> bool {\n-        match io::result(|| self.stat()) {\n+        match self.stat() {\n             Ok(s) => s.kind == io::TypeFile,\n             Err(..) => false\n         }\n@@ -687,7 +670,7 @@ impl path::Path {\n     ///\n     /// Will not raise a condition\n     pub fn is_dir(&self) -> bool {\n-        match io::result(|| self.stat()) {\n+        match self.stat() {\n             Ok(s) => s.kind == io::TypeDirectory,\n             Err(..) => false\n         }"}, {"sha": "f3535df5c5ee7c850eb1243da7659e1d19d1259b", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -13,9 +13,10 @@\n use cmp::max;\n use cmp::min;\n use container::Container;\n-use option::{Option, Some, None};\n-use super::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, io_error,\n-            OtherIoError};\n+use option::None;\n+use result::{Err, Ok};\n+use io;\n+use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use vec;\n use vec::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n \n@@ -59,7 +60,7 @@ impl MemWriter {\n }\n \n impl Writer for MemWriter {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         // Make sure the internal buffer is as least as big as where we\n         // currently are\n         let difference = self.pos as i64 - self.buf.len() as i64;\n@@ -86,14 +87,15 @@ impl Writer for MemWriter {\n \n         // Bump us forward\n         self.pos += buf.len();\n+        Ok(())\n     }\n }\n \n // FIXME(#10432)\n impl Seek for MemWriter {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n+    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n \n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         // compute offset as signed and clamp to prevent overflow\n         let offset = match style {\n             SeekSet => { 0 }\n@@ -102,6 +104,7 @@ impl Seek for MemWriter {\n         } as i64;\n \n         self.pos = max(0, offset+pos) as uint;\n+        Ok(())\n     }\n }\n \n@@ -148,8 +151,8 @@ impl MemReader {\n }\n \n impl Reader for MemReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        if self.eof() { return None }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n@@ -161,17 +164,19 @@ impl Reader for MemReader {\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());\n \n-        return Some(write_len);\n+        return Ok(write_len);\n     }\n }\n \n impl Seek for MemReader {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) -> IoResult<()> { fail!() }\n }\n \n impl Buffer for MemReader {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n+    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+        Ok(self.buf.slice_from(self.pos))\n+    }\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }\n \n@@ -207,28 +212,28 @@ impl<'a> BufWriter<'a> {\n }\n \n impl<'a> Writer for BufWriter<'a> {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         // raises a condition if the entire write does not fit in the buffer\n         let max_size = self.buf.len();\n         if self.pos >= max_size || (self.pos + buf.len()) > max_size {\n-            io_error::cond.raise(IoError {\n-                kind: OtherIoError,\n+            return Err(IoError {\n+                kind: io::OtherIoError,\n                 desc: \"Trying to write past end of buffer\",\n                 detail: None\n-            });\n-            return;\n+            })\n         }\n \n         vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos), buf);\n         self.pos += buf.len();\n+        Ok(())\n     }\n }\n \n // FIXME(#10432)\n impl<'a> Seek for BufWriter<'a> {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n+    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n \n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         // compute offset as signed and clamp to prevent overflow\n         let offset = match style {\n             SeekSet => { 0 }\n@@ -237,6 +242,7 @@ impl<'a> Seek for BufWriter<'a> {\n         } as i64;\n \n         self.pos = max(0, offset+pos) as uint;\n+        Ok(())\n     }\n }\n \n@@ -274,8 +280,8 @@ impl<'a> BufReader<'a> {\n }\n \n impl<'a> Reader for BufReader<'a> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        if self.eof() { return None }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n@@ -287,18 +293,19 @@ impl<'a> Reader for BufReader<'a> {\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());\n \n-        return Some(write_len);\n+        return Ok(write_len);\n      }\n }\n \n impl<'a> Seek for BufReader<'a> {\n-    fn tell(&self) -> u64 { self.pos as u64 }\n-\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) -> IoResult<()> { fail!() }\n }\n \n impl<'a> Buffer for BufReader<'a> {\n-    fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n+    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+        Ok(self.buf.slice_from(self.pos))\n+    }\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }\n \n@@ -388,7 +395,7 @@ mod test {\n \n         let mut called = false;\n         io_error::cond.trap(|err| {\n-            assert_eq!(err.kind, OtherIoError);\n+            assert_eq!(err.kind, io::OtherIoError);\n             called = true;\n         }).inside(|| {\n             writer.write([0, 0]);"}, {"sha": "1cf137279c4215ef2be81148a427e76aad5e6a02", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 197, "deletions": 243, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -290,15 +290,15 @@ Out of scope\n \n use cast;\n use char::Char;\n-use condition::Guard;\n use container::Container;\n+use fmt;\n use int;\n use iter::Iterator;\n use option::{Option, Some, None};\n use path::Path;\n use result::{Ok, Err, Result};\n-use str;\n use str::{StrSlice, OwnedStr};\n+use str;\n use to_str::ToStr;\n use uint;\n use unstable::finally::Finally;\n@@ -347,8 +347,8 @@ mod mem;\n /// Non-blocking access to stdin, stdout, stderr\n pub mod stdio;\n \n-/// Implementations for Option\n-mod option;\n+/// Implementations for Result\n+mod result;\n \n /// Extension traits\n pub mod extensions;\n@@ -373,17 +373,30 @@ mod comm_adapters;\n // https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n static DEFAULT_BUF_SIZE: uint = 1024 * 64;\n \n+pub type IoResult<T> = Result<T, IoError>;\n+\n /// The type passed to I/O condition handlers to indicate error\n ///\n /// # FIXME\n ///\n /// Is something like this sufficient? It's kind of archaic\n+#[deriving(Eq, Clone)]\n pub struct IoError {\n     kind: IoErrorKind,\n     desc: &'static str,\n     detail: Option<~str>\n }\n \n+impl fmt::Default for IoError {\n+    fn fmt(err: &IoError, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        if_ok!(fmt.buf.write_str(err.desc));\n+        match err.detail {\n+            Some(ref s) => write!(fmt.buf, \" ({})\", *s),\n+            None => Ok(())\n+        }\n+    }\n+}\n+\n // FIXME: #8242 implementing manually because deriving doesn't work for some reason\n impl ToStr for IoError {\n     fn to_str(&self) -> ~str {\n@@ -398,9 +411,8 @@ impl ToStr for IoError {\n     }\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Clone)]\n pub enum IoErrorKind {\n-    PreviousIoError,\n     OtherIoError,\n     EndOfFile,\n     FileNotFound,\n@@ -424,7 +436,6 @@ pub enum IoErrorKind {\n impl ToStr for IoErrorKind {\n     fn to_str(&self) -> ~str {\n         match *self {\n-            PreviousIoError => ~\"PreviousIoError\",\n             OtherIoError => ~\"OtherIoError\",\n             EndOfFile => ~\"EndOfFile\",\n             FileNotFound => ~\"FileNotFound\",\n@@ -446,38 +457,6 @@ impl ToStr for IoErrorKind {\n     }\n }\n \n-// FIXME: Can't put doc comments on macros\n-// Raised by `I/O` operations on error.\n-condition! {\n-    pub io_error: IoError -> ();\n-}\n-\n-/// Helper for wrapper calls where you want to\n-/// ignore any io_errors that might be raised\n-pub fn ignore_io_error() -> Guard<'static,IoError,()> {\n-    io_error::cond.trap(|_| {\n-        // just swallow the error.. downstream users\n-        // who can make a decision based on a None result\n-        // won't care\n-    }).guard()\n-}\n-\n-/// Helper for catching an I/O error and wrapping it in a Result object. The\n-/// return result will be the last I/O error that happened or the result of the\n-/// closure if no error occurred.\n-pub fn result<T>(cb: || -> T) -> Result<T, IoError> {\n-    let mut err = None;\n-    let ret = io_error::cond.trap(|e| {\n-        if err.is_none() {\n-            err = Some(e);\n-        }\n-    }).inside(cb);\n-    match err {\n-        Some(e) => Err(e),\n-        None => Ok(ret),\n-    }\n-}\n-\n pub trait Reader {\n \n     // Only two methods which need to get implemented for this trait\n@@ -504,7 +483,7 @@ pub trait Reader {\n     /// Will people often need to slice their vectors to call this\n     /// and will that be annoying?\n     /// Is it actually possible for 0 bytes to be read successfully?\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint>;\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n \n     // Convenient helper methods based on the above methods\n \n@@ -514,16 +493,17 @@ pub trait Reader {\n     ///\n     /// Raises the same conditions as the `read` method. Returns\n     /// `None` if the condition is handled.\n-    fn read_byte(&mut self) -> Option<u8> {\n+    fn read_byte(&mut self) -> IoResult<u8> {\n         let mut buf = [0];\n-        match self.read(buf) {\n-            Some(0) => {\n-                debug!(\"read 0 bytes. trying again\");\n-                self.read_byte()\n+        loop {\n+            match self.read(buf) {\n+                Ok(0) => {\n+                    debug!(\"read 0 bytes. trying again\");\n+                }\n+                Ok(1) => return Ok(buf[0]),\n+                Ok(_) => unreachable!(),\n+                Err(e) => return Err(e)\n             }\n-            Some(1) => Some(buf[0]),\n-            Some(_) => unreachable!(),\n-            None => None\n         }\n     }\n \n@@ -537,30 +517,26 @@ pub trait Reader {\n     /// Raises the same conditions as `read`. Additionally raises `io_error`\n     /// on EOF. If `io_error` is handled then `push_bytes` may push less\n     /// than the requested number of bytes.\n-    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) {\n-        unsafe {\n-            let start_len = buf.len();\n-            let mut total_read = 0;\n-\n-            buf.reserve_additional(len);\n-            buf.set_len(start_len + len);\n-\n-            (|| {\n-                while total_read < len {\n-                    let len = buf.len();\n-                    let slice = buf.mut_slice(start_len + total_read, len);\n-                    match self.read(slice) {\n-                        Some(nread) => {\n-                            total_read += nread;\n-                        }\n-                        None => {\n-                            io_error::cond.raise(standard_error(EndOfFile));\n-                            break;\n-                        }\n+    fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) -> IoResult<()> {\n+        let start_len = buf.len();\n+        let mut total_read = 0;\n+\n+        buf.reserve_additional(len);\n+        unsafe { buf.set_len(start_len + len); }\n+\n+        (|| {\n+            while total_read < len {\n+                let len = buf.len();\n+                let slice = buf.mut_slice(start_len + total_read, len);\n+                match self.read(slice) {\n+                    Ok(nread) => {\n+                        total_read += nread;\n                     }\n+                    Err(e) => return Err(e)\n                 }\n-            }).finally(|| buf.set_len(start_len + total_read))\n-        }\n+            }\n+            Ok(())\n+        }).finally(|| unsafe { buf.set_len(start_len + total_read) })\n     }\n \n     /// Reads `len` bytes and gives you back a new vector of length `len`\n@@ -570,10 +546,10 @@ pub trait Reader {\n     /// Raises the same conditions as `read`. Additionally raises `io_error`\n     /// on EOF. If `io_error` is handled then the returned vector may\n     /// contain less than the requested number of bytes.\n-    fn read_bytes(&mut self, len: uint) -> ~[u8] {\n+    fn read_bytes(&mut self, len: uint) -> IoResult<~[u8]> {\n         let mut buf = vec::with_capacity(len);\n-        self.push_bytes(&mut buf, len);\n-        return buf;\n+        if_ok!(self.push_bytes(&mut buf, len));\n+        return Ok(buf);\n     }\n \n     /// Reads all remaining bytes from the stream.\n@@ -582,21 +558,16 @@ pub trait Reader {\n     ///\n     /// Raises the same conditions as the `read` method except for\n     /// `EndOfFile` which is swallowed.\n-    fn read_to_end(&mut self) -> ~[u8] {\n+    fn read_to_end(&mut self) -> IoResult<~[u8]> {\n         let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n-        let mut keep_reading = true;\n-        io_error::cond.trap(|e| {\n-            if e.kind == EndOfFile {\n-                keep_reading = false;\n-            } else {\n-                io_error::cond.raise(e)\n+        loop {\n+            match self.push_bytes(&mut buf, DEFAULT_BUF_SIZE) {\n+                Ok(()) => {}\n+                Err(ref e) if e.kind == EndOfFile => break,\n+                Err(e) => return Err(e)\n             }\n-        }).inside(|| {\n-            while keep_reading {\n-                self.push_bytes(&mut buf, DEFAULT_BUF_SIZE)\n-            }\n-        });\n-        return buf;\n+        }\n+        return Ok(buf);\n     }\n \n     /// Reads all of the remaining bytes of this stream, interpreting them as a\n@@ -606,14 +577,13 @@ pub trait Reader {\n     ///\n     /// This function will raise all the same conditions as the `read` method,\n     /// along with raising a condition if the input is not valid UTF-8.\n-    fn read_to_str(&mut self) -> ~str {\n-        match str::from_utf8_owned(self.read_to_end()) {\n-            Some(s) => s,\n-            None => {\n-                io_error::cond.raise(standard_error(InvalidInput));\n-                ~\"\"\n+    fn read_to_str(&mut self) -> IoResult<~str> {\n+        self.read_to_end().and_then(|s| {\n+            match str::from_utf8_owned(s) {\n+                Some(s) => Ok(s),\n+                None => Err(standard_error(InvalidInput)),\n             }\n-        }\n+        })\n     }\n \n     /// Create an iterator that reads a single byte on\n@@ -633,225 +603,219 @@ pub trait Reader {\n     /// Reads `n` little-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_uint_n(&mut self, nbytes: uint) -> u64 {\n+    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64;\n         let mut pos = 0;\n         let mut i = nbytes;\n         while i > 0 {\n-            val += (self.read_u8() as u64) << pos;\n+            val += (if_ok!(self.read_u8()) as u64) << pos;\n             pos += 8;\n             i -= 1;\n         }\n-        val\n+        Ok(val)\n     }\n \n     /// Reads `n` little-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_int_n(&mut self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n+    fn read_le_int_n(&mut self, nbytes: uint) -> IoResult<i64> {\n+        self.read_le_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n     }\n \n     /// Reads `n` big-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_uint_n(&mut self, nbytes: uint) -> u64 {\n+    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64;\n         let mut i = nbytes;\n         while i > 0 {\n             i -= 1;\n-            val += (self.read_u8() as u64) << i * 8;\n+            val += (if_ok!(self.read_u8()) as u64) << i * 8;\n         }\n-        val\n+        Ok(val)\n     }\n \n     /// Reads `n` big-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_int_n(&mut self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n+    fn read_be_int_n(&mut self, nbytes: uint) -> IoResult<i64> {\n+        self.read_be_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n     }\n \n     /// Reads a little-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_le_uint(&mut self) -> uint {\n-        self.read_le_uint_n(uint::BYTES) as uint\n+    fn read_le_uint(&mut self) -> IoResult<uint> {\n+        self.read_le_uint_n(uint::BYTES).map(|i| i as uint)\n     }\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_le_int(&mut self) -> int {\n-        self.read_le_int_n(int::BYTES) as int\n+    fn read_le_int(&mut self) -> IoResult<int> {\n+        self.read_le_int_n(int::BYTES).map(|i| i as int)\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_be_uint(&mut self) -> uint {\n-        self.read_be_uint_n(uint::BYTES) as uint\n+    fn read_be_uint(&mut self) -> IoResult<uint> {\n+        self.read_be_uint_n(uint::BYTES).map(|i| i as uint)\n     }\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n-    fn read_be_int(&mut self) -> int {\n-        self.read_be_int_n(int::BYTES) as int\n+    fn read_be_int(&mut self) -> IoResult<int> {\n+        self.read_be_int_n(int::BYTES).map(|i| i as int)\n     }\n \n     /// Reads a big-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    fn read_be_u64(&mut self) -> u64 {\n+    fn read_be_u64(&mut self) -> IoResult<u64> {\n         self.read_be_uint_n(8)\n     }\n \n     /// Reads a big-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    fn read_be_u32(&mut self) -> u32 {\n-        self.read_be_uint_n(4) as u32\n+    fn read_be_u32(&mut self) -> IoResult<u32> {\n+        self.read_be_uint_n(4).map(|i| i as u32)\n     }\n \n     /// Reads a big-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    fn read_be_u16(&mut self) -> u16 {\n-        self.read_be_uint_n(2) as u16\n+    fn read_be_u16(&mut self) -> IoResult<u16> {\n+        self.read_be_uint_n(2).map(|i| i as u16)\n     }\n \n     /// Reads a big-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    fn read_be_i64(&mut self) -> i64 {\n+    fn read_be_i64(&mut self) -> IoResult<i64> {\n         self.read_be_int_n(8)\n     }\n \n     /// Reads a big-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    fn read_be_i32(&mut self) -> i32 {\n-        self.read_be_int_n(4) as i32\n+    fn read_be_i32(&mut self) -> IoResult<i32> {\n+        self.read_be_int_n(4).map(|i| i as i32)\n     }\n \n     /// Reads a big-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    fn read_be_i16(&mut self) -> i16 {\n-        self.read_be_int_n(2) as i16\n+    fn read_be_i16(&mut self) -> IoResult<i16> {\n+        self.read_be_int_n(2).map(|i| i as i16)\n     }\n \n     /// Reads a big-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_be_f64(&mut self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_be_u64())\n-        }\n+    fn read_be_f64(&mut self) -> IoResult<f64> {\n+        self.read_be_u64().map(|i| unsafe {\n+            cast::transmute::<u64, f64>(i)\n+        })\n     }\n \n     /// Reads a big-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_be_f32(&mut self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_be_u32())\n-        }\n+    fn read_be_f32(&mut self) -> IoResult<f32> {\n+        self.read_be_u32().map(|i| unsafe {\n+            cast::transmute::<u32, f32>(i)\n+        })\n     }\n \n     /// Reads a little-endian `u64`.\n     ///\n     /// `u64`s are 8 bytes long.\n-    fn read_le_u64(&mut self) -> u64 {\n+    fn read_le_u64(&mut self) -> IoResult<u64> {\n         self.read_le_uint_n(8)\n     }\n \n     /// Reads a little-endian `u32`.\n     ///\n     /// `u32`s are 4 bytes long.\n-    fn read_le_u32(&mut self) -> u32 {\n-        self.read_le_uint_n(4) as u32\n+    fn read_le_u32(&mut self) -> IoResult<u32> {\n+        self.read_le_uint_n(4).map(|i| i as u32)\n     }\n \n     /// Reads a little-endian `u16`.\n     ///\n     /// `u16`s are 2 bytes long.\n-    fn read_le_u16(&mut self) -> u16 {\n-        self.read_le_uint_n(2) as u16\n+    fn read_le_u16(&mut self) -> IoResult<u16> {\n+        self.read_le_uint_n(2).map(|i| i as u16)\n     }\n \n     /// Reads a little-endian `i64`.\n     ///\n     /// `i64`s are 8 bytes long.\n-    fn read_le_i64(&mut self) -> i64 {\n+    fn read_le_i64(&mut self) -> IoResult<i64> {\n         self.read_le_int_n(8)\n     }\n \n     /// Reads a little-endian `i32`.\n     ///\n     /// `i32`s are 4 bytes long.\n-    fn read_le_i32(&mut self) -> i32 {\n-        self.read_le_int_n(4) as i32\n+    fn read_le_i32(&mut self) -> IoResult<i32> {\n+        self.read_le_int_n(4).map(|i| i as i32)\n     }\n \n     /// Reads a little-endian `i16`.\n     ///\n     /// `i16`s are 2 bytes long.\n-    fn read_le_i16(&mut self) -> i16 {\n-        self.read_le_int_n(2) as i16\n+    fn read_le_i16(&mut self) -> IoResult<i16> {\n+        self.read_le_int_n(2).map(|i| i as i16)\n     }\n \n     /// Reads a little-endian `f64`.\n     ///\n     /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_le_f64(&mut self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_le_u64())\n-        }\n+    fn read_le_f64(&mut self) -> IoResult<f64> {\n+        self.read_le_u64().map(|i| unsafe {\n+            cast::transmute::<u64, f64>(i)\n+        })\n     }\n \n     /// Reads a little-endian `f32`.\n     ///\n     /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_le_f32(&mut self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_le_u32())\n-        }\n+    fn read_le_f32(&mut self) -> IoResult<f32> {\n+        self.read_le_u32().map(|i| unsafe {\n+            cast::transmute::<u32, f32>(i)\n+        })\n     }\n \n     /// Read a u8.\n     ///\n     /// `u8`s are 1 byte.\n-    fn read_u8(&mut self) -> u8 {\n-        match self.read_byte() {\n-            Some(b) => b,\n-            None => 0\n-        }\n+    fn read_u8(&mut self) -> IoResult<u8> {\n+        self.read_byte()\n     }\n \n     /// Read an i8.\n     ///\n     /// `i8`s are 1 byte.\n-    fn read_i8(&mut self) -> i8 {\n-        match self.read_byte() {\n-            Some(b) => b as i8,\n-            None => 0\n-        }\n+    fn read_i8(&mut self) -> IoResult<i8> {\n+        self.read_byte().map(|i| i as i8)\n     }\n \n }\n \n impl Reader for ~Reader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.read(buf) }\n }\n \n impl<'a> Reader for &'a mut Reader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.read(buf) }\n }\n \n fn extend_sign(val: u64, nbytes: uint) -> i64 {\n@@ -865,23 +829,23 @@ pub trait Writer {\n     /// # Failure\n     ///\n     /// Raises the `io_error` condition on error\n-    fn write(&mut self, buf: &[u8]);\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n \n     /// Flush this output stream, ensuring that all intermediately buffered\n     /// contents reach their destination.\n     ///\n     /// This is by default a no-op and implementers of the `Writer` trait should\n     /// decide whether their stream needs to be buffered or not.\n-    fn flush(&mut self) {}\n+    fn flush(&mut self) -> IoResult<()> { Ok(()) }\n \n     /// Write a rust string into this sink.\n     ///\n     /// The bytes written will be the UTF-8 encoded version of the input string.\n     /// If other encodings are desired, it is recommended to compose this stream\n     /// with another performing the conversion, or to use `write` with a\n     /// converted byte-array instead.\n-    fn write_str(&mut self, s: &str) {\n-        self.write(s.as_bytes());\n+    fn write_str(&mut self, s: &str) -> IoResult<()> {\n+        self.write(s.as_bytes())\n     }\n \n     /// Writes a string into this sink, and then writes a literal newline (`\\n`)\n@@ -891,157 +855,156 @@ pub trait Writer {\n     ///\n     /// If other encodings or line ending flavors are desired, it is recommended\n     /// that the `write` method is used specifically instead.\n-    fn write_line(&mut self, s: &str) {\n-        self.write_str(s);\n-        self.write(['\\n' as u8]);\n+    fn write_line(&mut self, s: &str) -> IoResult<()> {\n+        self.write_str(s).and_then(|()| self.write(['\\n' as u8]))\n     }\n \n     /// Write a single char, encoded as UTF-8.\n-    fn write_char(&mut self, c: char) {\n+    fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n         let n = c.encode_utf8(buf.as_mut_slice());\n-        self.write(buf.slice_to(n));\n+        self.write(buf.slice_to(n))\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n-    fn write_int(&mut self, n: int) {\n+    fn write_int(&mut self, n: int) -> IoResult<()> {\n         int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n-    fn write_uint(&mut self, n: uint) {\n+    fn write_uint(&mut self, n: uint) -> IoResult<()> {\n         uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n \n     /// Write a little-endian uint (number of bytes depends on system).\n-    fn write_le_uint(&mut self, n: uint) {\n+    fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write(v))\n     }\n \n     /// Write a little-endian int (number of bytes depends on system).\n-    fn write_le_int(&mut self, n: int) {\n+    fn write_le_int(&mut self, n: int) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian uint (number of bytes depends on system).\n-    fn write_be_uint(&mut self, n: uint) {\n+    fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian int (number of bytes depends on system).\n-    fn write_be_int(&mut self, n: int) {\n+    fn write_be_int(&mut self, n: int) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes).\n-    fn write_be_u64(&mut self, n: u64) {\n+    fn write_be_u64(&mut self, n: u64) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n, 8u, |v| self.write(v))\n     }\n \n     /// Write a big-endian u32 (4 bytes).\n-    fn write_be_u32(&mut self, n: u32) {\n+    fn write_be_u32(&mut self, n: u32) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a big-endian u16 (2 bytes).\n-    fn write_be_u16(&mut self, n: u16) {\n+    fn write_be_u16(&mut self, n: u16) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i64 (8 bytes).\n-    fn write_be_i64(&mut self, n: i64) {\n+    fn write_be_i64(&mut self, n: i64) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i32 (4 bytes).\n-    fn write_be_i32(&mut self, n: i32) {\n+    fn write_be_i32(&mut self, n: i32) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a big-endian i16 (2 bytes).\n-    fn write_be_i16(&mut self, n: i16) {\n+    fn write_be_i16(&mut self, n: i16) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    fn write_be_f64(&mut self, f: f64) {\n+    fn write_be_f64(&mut self, f: f64) -> IoResult<()> {\n         unsafe {\n             self.write_be_u64(cast::transmute(f))\n         }\n     }\n \n     /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    fn write_be_f32(&mut self, f: f32) {\n+    fn write_be_f32(&mut self, f: f32) -> IoResult<()> {\n         unsafe {\n             self.write_be_u32(cast::transmute(f))\n         }\n     }\n \n     /// Write a little-endian u64 (8 bytes).\n-    fn write_le_u64(&mut self, n: u64) {\n+    fn write_le_u64(&mut self, n: u64) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n, 8u, |v| self.write(v))\n     }\n \n     /// Write a little-endian u32 (4 bytes).\n-    fn write_le_u32(&mut self, n: u32) {\n+    fn write_le_u32(&mut self, n: u32) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a little-endian u16 (2 bytes).\n-    fn write_le_u16(&mut self, n: u16) {\n+    fn write_le_u16(&mut self, n: u16) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i64 (8 bytes).\n-    fn write_le_i64(&mut self, n: i64) {\n+    fn write_le_i64(&mut self, n: i64) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i32 (4 bytes).\n-    fn write_le_i32(&mut self, n: i32) {\n+    fn write_le_i32(&mut self, n: i32) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n     /// Write a little-endian i16 (2 bytes).\n-    fn write_le_i16(&mut self, n: i16) {\n+    fn write_le_i16(&mut self, n: i16) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n     /// Write a little-endian IEEE754 double-precision floating-point\n     /// (8 bytes).\n-    fn write_le_f64(&mut self, f: f64) {\n+    fn write_le_f64(&mut self, f: f64) -> IoResult<()> {\n         unsafe {\n             self.write_le_u64(cast::transmute(f))\n         }\n     }\n \n     /// Write a little-endian IEEE754 single-precision floating-point\n     /// (4 bytes).\n-    fn write_le_f32(&mut self, f: f32) {\n+    fn write_le_f32(&mut self, f: f32) -> IoResult<()> {\n         unsafe {\n             self.write_le_u32(cast::transmute(f))\n         }\n     }\n \n     /// Write a u8 (1 byte).\n-    fn write_u8(&mut self, n: u8) {\n+    fn write_u8(&mut self, n: u8) -> IoResult<()> {\n         self.write([n])\n     }\n \n     /// Write a i8 (1 byte).\n-    fn write_i8(&mut self, n: i8) {\n+    fn write_i8(&mut self, n: i8) -> IoResult<()> {\n         self.write([n as u8])\n     }\n }\n \n impl Writer for ~Writer {\n-    fn write(&mut self, buf: &[u8]) { self.write(buf) }\n-    fn flush(&mut self) { self.flush() }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n+    fn flush(&mut self) -> IoResult<()> { self.flush() }\n }\n \n impl<'a> Writer for &'a mut Writer {\n-    fn write(&mut self, buf: &[u8]) { self.write(buf) }\n-    fn flush(&mut self) { self.flush() }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write(buf) }\n+    fn flush(&mut self) -> IoResult<()> { self.flush() }\n }\n \n pub trait Stream: Reader + Writer { }\n@@ -1068,7 +1031,7 @@ pub struct Lines<'r, T> {\n \n impl<'r, T: Buffer> Iterator<~str> for Lines<'r, T> {\n     fn next(&mut self) -> Option<~str> {\n-        self.buffer.read_line()\n+        self.buffer.read_line().ok()\n     }\n }\n \n@@ -1089,7 +1052,7 @@ pub trait Buffer: Reader {\n     ///\n     /// This function will raise on the `io_error` condition if a read error is\n     /// encountered.\n-    fn fill<'a>(&'a mut self) -> &'a [u8];\n+    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]>;\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n     /// so they should no longer be returned in calls to `fill` or `read`.\n@@ -1116,7 +1079,7 @@ pub trait Buffer: Reader {\n     /// `EndOfFile` which is swallowed) if a read error is encountered.\n     /// The task will also fail if sequence of bytes leading up to\n     /// the newline character are not valid UTF-8.\n-    fn read_line(&mut self) -> Option<~str> {\n+    fn read_line(&mut self) -> IoResult<~str> {\n         self.read_until('\\n' as u8).map(|line| str::from_utf8_owned(line).unwrap())\n     }\n \n@@ -1140,39 +1103,32 @@ pub trait Buffer: Reader {\n     ///\n     /// This function will raise on the `io_error` condition if a read error is\n     /// encountered, except that `EndOfFile` is swallowed.\n-    fn read_until(&mut self, byte: u8) -> Option<~[u8]> {\n+    fn read_until(&mut self, byte: u8) -> IoResult<~[u8]> {\n         let mut res = ~[];\n \n-        io_error::cond.trap(|e| {\n-            if e.kind != EndOfFile {\n-                io_error::cond.raise(e);\n-            }\n-        }).inside(|| {\n-            let mut used;\n-            loop {\n-                {\n-                    let available = self.fill();\n-                    match available.iter().position(|&b| b == byte) {\n-                        Some(i) => {\n-                            res.push_all(available.slice_to(i + 1));\n-                            used = i + 1;\n-                            break\n-                        }\n-                        None => {\n-                            res.push_all(available);\n-                            used = available.len();\n-                        }\n+        let mut used;\n+        loop {\n+            {\n+                let available = if_ok!(self.fill());\n+                match available.iter().position(|&b| b == byte) {\n+                    Some(i) => {\n+                        res.push_all(available.slice_to(i + 1));\n+                        used = i + 1;\n+                        break\n+                    }\n+                    None => {\n+                        res.push_all(available);\n+                        used = available.len();\n                     }\n                 }\n-                if used == 0 {\n-                    break\n-                }\n-                self.consume(used);\n+            }\n+            if used == 0 {\n+                break\n             }\n             self.consume(used);\n-        });\n-        return if res.len() == 0 {None} else {Some(res)};\n-\n+        }\n+        self.consume(used);\n+        Ok(res)\n     }\n \n     /// Reads the next utf8-encoded character from the underlying stream.\n@@ -1184,27 +1140,26 @@ pub trait Buffer: Reader {\n     ///\n     /// This function will raise on the `io_error` condition if a read error is\n     /// encountered.\n-    fn read_char(&mut self) -> Option<char> {\n+    fn read_char(&mut self) -> IoResult<char> {\n         let width = {\n-            let available = self.fill();\n-            if available.len() == 0 { return None } // read error\n+            let available = if_ok!(self.fill());\n             str::utf8_char_width(available[0])\n         };\n-        if width == 0 { return None } // not uf8\n+        if width == 0 { return Err(standard_error(InvalidInput)) } // not uf8\n         let mut buf = [0, ..4];\n         {\n             let mut start = 0;\n             loop {\n-                match self.read(buf.mut_slice(start, width)) {\n-                    Some(n) if n == width - start => break,\n-                    Some(n) if n < width - start => { start += n; }\n-                    Some(..) | None => return None // read error\n+                match if_ok!(self.read(buf.mut_slice(start, width))) {\n+                    n if n == width - start => break,\n+                    n if n < width - start => { start += n; }\n+                    _ => return Err(standard_error(InvalidInput)),\n                 }\n             }\n         }\n         match str::from_utf8(buf.slice_to(width)) {\n-            Some(s) => Some(s.char_at(0)),\n-            None => None\n+            Some(s) => Ok(s.char_at(0)),\n+            None => Err(standard_error(InvalidInput))\n         }\n     }\n }\n@@ -1222,7 +1177,7 @@ pub enum SeekStyle {\n /// * Are `u64` and `i64` the right choices?\n pub trait Seek {\n     /// Return position of file cursor in the stream\n-    fn tell(&self) -> u64;\n+    fn tell(&self) -> IoResult<u64>;\n \n     /// Seek to an offset in a stream\n     ///\n@@ -1231,7 +1186,7 @@ pub trait Seek {\n     /// # FIXME\n     ///\n     /// * What is the behavior when seeking past the end of a stream?\n-    fn seek(&mut self, pos: i64, style: SeekStyle);\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;\n }\n \n /// A listener is a value that can consume itself to start listening for connections.\n@@ -1243,7 +1198,7 @@ pub trait Listener<T, A: Acceptor<T>> {\n     ///\n     /// Raises `io_error` condition. If the condition is handled,\n     /// then `listen` returns `None`.\n-    fn listen(self) -> Option<A>;\n+    fn listen(self) -> IoResult<A>;\n }\n \n /// An acceptor is a value that presents incoming connections\n@@ -1253,7 +1208,7 @@ pub trait Acceptor<T> {\n     /// # Failure\n     /// Raise `io_error` condition. If the condition is handled,\n     /// then `accept` returns `None`.\n-    fn accept(&mut self) -> Option<T>;\n+    fn accept(&mut self) -> IoResult<T>;\n \n     /// Create an iterator over incoming connection attempts\n     fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> {\n@@ -1272,15 +1227,14 @@ pub struct IncomingConnections<'a, A> {\n     priv inc: &'a mut A,\n }\n \n-impl<'a, T, A: Acceptor<T>> Iterator<Option<T>> for IncomingConnections<'a, A> {\n-    fn next(&mut self) -> Option<Option<T>> {\n+impl<'a, T, A: Acceptor<T>> Iterator<IoResult<T>> for IncomingConnections<'a, A> {\n+    fn next(&mut self) -> Option<IoResult<T>> {\n         Some(self.inc.accept())\n     }\n }\n \n pub fn standard_error(kind: IoErrorKind) -> IoError {\n     let desc = match kind {\n-        PreviousIoError => \"failing due to previous I/O error\",\n         EndOfFile => \"end of file\",\n         IoUnavailable => \"I/O is unavailable\",\n         InvalidInput => \"invalid input\","}, {"sha": "1f8f8beeae33cb9c3b07973575c67089c4be4eee", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -17,8 +17,9 @@ getaddrinfo()\n \n */\n \n-use option::{Option, Some, None};\n+use io::IoResult;\n use io::net::ip::{SocketAddr, IpAddr};\n+use option::{Option, Some, None};\n use rt::rtio::{IoFactory, LocalIo};\n use vec::ImmutableVector;\n \n@@ -73,7 +74,7 @@ pub struct Info {\n /// # Failure\n ///\n /// On failure, this will raise on the `io_error` condition.\n-pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n+pub fn get_host_addresses(host: &str) -> IoResult<~[IpAddr]> {\n     lookup(Some(host), None, None).map(|a| a.map(|i| i.address.ip))\n }\n \n@@ -94,7 +95,7 @@ pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n /// FIXME: this is not public because the `Hint` structure is not ready for public\n ///      consumption just yet.\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n-          -> Option<~[Info]> {\n+          -> IoResult<~[Info]> {\n     LocalIo::maybe_raise(|io| io.get_host_addresses(hostname, servname, hint))\n }\n "}, {"sha": "cc923d5b736588261deec0741b58c56e6c373002", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 15, "deletions": 67, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::{Option, Some, None};\n-use result::{Ok, Err};\n use io::net::ip::SocketAddr;\n-use io::{Reader, Writer, Listener, Acceptor};\n-use io::{io_error, EndOfFile};\n+use io::{Reader, Writer, Listener, Acceptor, IoResult};\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n \n@@ -25,91 +22,48 @@ impl TcpStream {\n         TcpStream { obj: s }\n     }\n \n-    pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n+    pub fn connect(addr: SocketAddr) -> IoResult<TcpStream> {\n         LocalIo::maybe_raise(|io| {\n             io.tcp_connect(addr).map(TcpStream::new)\n         })\n     }\n \n-    pub fn peer_name(&mut self) -> Option<SocketAddr> {\n-        match self.obj.peer_name() {\n-            Ok(pn) => Some(pn),\n-            Err(ioerr) => {\n-                debug!(\"failed to get peer name: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n+        self.obj.peer_name()\n     }\n \n-    pub fn socket_name(&mut self) -> Option<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(sn) => Some(sn),\n-            Err(ioerr) => {\n-                debug!(\"failed to get socket name: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n+        self.obj.socket_name()\n     }\n }\n \n impl Reader for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.obj.read(buf) {\n-            Ok(read) => Some(read),\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != EndOfFile {\n-                    io_error::cond.raise(ioerr);\n-                }\n-                return None;\n-            }\n-        }\n-    }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n }\n \n impl Writer for TcpStream {\n-    fn write(&mut self, buf: &[u8]) {\n-        match self.obj.write(buf) {\n-            Ok(_) => (),\n-            Err(ioerr) => io_error::cond.raise(ioerr),\n-        }\n-    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n }\n \n pub struct TcpListener {\n     priv obj: ~RtioTcpListener\n }\n \n impl TcpListener {\n-    pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n+    pub fn bind(addr: SocketAddr) -> IoResult<TcpListener> {\n         LocalIo::maybe_raise(|io| {\n             io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n         })\n     }\n \n-    pub fn socket_name(&mut self) -> Option<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(sn) => Some(sn),\n-            Err(ioerr) => {\n-                debug!(\"failed to get socket name: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n+        self.obj.socket_name()\n     }\n }\n \n impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n-    fn listen(self) -> Option<TcpAcceptor> {\n-        match self.obj.listen() {\n-            Ok(acceptor) => Some(TcpAcceptor { obj: acceptor }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    fn listen(self) -> IoResult<TcpAcceptor> {\n+        self.obj.listen().map(|acceptor| TcpAcceptor { obj: acceptor })\n     }\n }\n \n@@ -118,14 +72,8 @@ pub struct TcpAcceptor {\n }\n \n impl Acceptor<TcpStream> for TcpAcceptor {\n-    fn accept(&mut self) -> Option<TcpStream> {\n-        match self.obj.accept() {\n-            Ok(s) => Some(TcpStream::new(s)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    fn accept(&mut self) -> IoResult<TcpStream> {\n+        self.obj.accept().map(TcpStream::new)\n     }\n }\n "}, {"sha": "abb6bdea75bf797063b0f5365a1c9c8bf610937a", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 14, "deletions": 35, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -8,57 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::{Option, Some, None};\n use result::{Ok, Err};\n use io::net::ip::SocketAddr;\n-use io::{Reader, Writer};\n-use io::{io_error, EndOfFile};\n+use io::{Reader, Writer, IoResult};\n use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, LocalIo};\n \n pub struct UdpSocket {\n     priv obj: ~RtioUdpSocket\n }\n \n impl UdpSocket {\n-    pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n+    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {\n         LocalIo::maybe_raise(|io| {\n             io.udp_bind(addr).map(|s| UdpSocket { obj: s })\n         })\n     }\n \n-    pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, SocketAddr)> {\n-        match self.obj.recvfrom(buf) {\n-            Ok((nread, src)) => Some((nread, src)),\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != EndOfFile {\n-                    io_error::cond.raise(ioerr);\n-                }\n-                None\n-            }\n-        }\n+    pub fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n+        self.obj.recvfrom(buf)\n     }\n \n-    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) {\n-        match self.obj.sendto(buf, dst) {\n-            Ok(_) => (),\n-            Err(ioerr) => io_error::cond.raise(ioerr),\n-        }\n+    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n+        self.obj.sendto(buf, dst)\n     }\n \n     pub fn connect(self, other: SocketAddr) -> UdpStream {\n         UdpStream { socket: self, connectedTo: other }\n     }\n \n-    pub fn socket_name(&mut self) -> Option<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(sn) => Some(sn),\n-            Err(ioerr) => {\n-                debug!(\"failed to get socket name: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n+        self.obj.socket_name()\n     }\n }\n \n@@ -76,21 +55,21 @@ impl UdpStream {\n }\n \n impl Reader for UdpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let peer = self.connectedTo;\n         self.as_socket(|sock| {\n             match sock.recvfrom(buf) {\n-                Some((_nread, src)) if src != peer => Some(0),\n-                Some((nread, _src)) => Some(nread),\n-                None => None,\n+                Ok((_nread, src)) if src != peer => Ok(0),\n+                Ok((nread, _src)) => Ok(nread),\n+                Err(e) => Err(e),\n             }\n         })\n     }\n }\n \n impl Writer for UdpStream {\n-    fn write(&mut self, buf: &[u8]) {\n-        self.as_socket(|sock| sock.sendto(buf, self.connectedTo));\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.as_socket(|sock| sock.sendto(buf, self.connectedTo))\n     }\n }\n "}, {"sha": "b8b396b24fdd533a30fa834b7cff938e7c90cb1a", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -28,7 +28,7 @@ use c_str::ToCStr;\n use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n use io::pipe::PipeStream;\n-use io::{io_error, Listener, Acceptor, Reader, Writer};\n+use io::{Listener, Acceptor, Reader, Writer, IoResult};\n \n /// A stream which communicates over a named pipe.\n pub struct UnixStream {\n@@ -52,25 +52,27 @@ impl UnixStream {\n     ///\n     /// # Example\n     ///\n-    ///     use std::io::net::unix::UnixStream;\n+    /// ```rust\n+    /// # #[allow(unused_must_use)];\n+    /// use std::io::net::unix::UnixStream;\n     ///\n-    ///     let server = Path(\"path/to/my/socket\");\n-    ///     let mut stream = UnixStream::connect(&server);\n-    ///     stream.write([1, 2, 3]);\n-    ///\n-    pub fn connect<P: ToCStr>(path: &P) -> Option<UnixStream> {\n+    /// let server = Path::new(\"path/to/my/socket\");\n+    /// let mut stream = UnixStream::connect(&server);\n+    /// stream.write([1, 2, 3]);\n+    /// ```\n+    pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n         LocalIo::maybe_raise(|io| {\n             io.unix_connect(&path.to_c_str()).map(UnixStream::new)\n         })\n     }\n }\n \n impl Reader for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.obj.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n }\n \n impl Writer for UnixStream {\n-    fn write(&mut self, buf: &[u8]) { self.obj.write(buf) }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n }\n \n pub struct UnixListener {\n@@ -91,31 +93,27 @@ impl UnixListener {\n     ///\n     /// # Example\n     ///\n-    ///     use std::io::net::unix::UnixListener;\n-    ///\n-    ///     let server = Path(\"path/to/my/socket\");\n-    ///     let mut stream = UnixListener::bind(&server);\n-    ///     for client in stream.incoming() {\n-    ///         let mut client = client;\n-    ///         client.write([1, 2, 3, 4]);\n-    ///     }\n+    /// ```\n+    /// use std::io::net::unix::UnixListener;\n+    /// use std::io::Listener;\n     ///\n-    pub fn bind<P: ToCStr>(path: &P) -> Option<UnixListener> {\n+    /// let server = Path::new(\"path/to/my/socket\");\n+    /// let mut stream = UnixListener::bind(&server);\n+    /// for client in stream.incoming() {\n+    ///     let mut client = client;\n+    ///     client.write([1, 2, 3, 4]);\n+    /// }\n+    /// ```\n+    pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> {\n         LocalIo::maybe_raise(|io| {\n             io.unix_bind(&path.to_c_str()).map(|s| UnixListener { obj: s })\n         })\n     }\n }\n \n impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n-    fn listen(self) -> Option<UnixAcceptor> {\n-        match self.obj.listen() {\n-            Ok(acceptor) => Some(UnixAcceptor { obj: acceptor }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    fn listen(self) -> IoResult<UnixAcceptor> {\n+        self.obj.listen().map(|obj| UnixAcceptor { obj: obj })\n     }\n }\n \n@@ -124,14 +122,8 @@ pub struct UnixAcceptor {\n }\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n-    fn accept(&mut self) -> Option<UnixStream> {\n-        match self.obj.accept() {\n-            Ok(s) => Some(UnixStream::new(s)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n-            }\n-        }\n+    fn accept(&mut self) -> IoResult<UnixStream> {\n+        self.obj.accept().map(UnixStream::new)\n     }\n }\n "}, {"sha": "34d8bf96aa2a95d73580dcb0d89c0fdf5d6618c8", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -14,7 +14,7 @@\n //! enough so that pipes can be created to child processes.\n \n use prelude::*;\n-use io::{io_error, EndOfFile};\n+use io::IoResult;\n use libc;\n use rt::rtio::{RtioPipe, LocalIo};\n \n@@ -42,7 +42,7 @@ impl PipeStream {\n     ///\n     /// If the pipe cannot be created, an error will be raised on the\n     /// `io_error` condition.\n-    pub fn open(fd: libc::c_int) -> Option<PipeStream> {\n+    pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {\n         LocalIo::maybe_raise(|io| {\n             io.pipe_open(fd).map(|obj| PipeStream { obj: obj })\n         })\n@@ -54,29 +54,11 @@ impl PipeStream {\n }\n \n impl Reader for PipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.obj.read(buf) {\n-            Ok(read) => Some(read),\n-            Err(ioerr) => {\n-                // EOF is indicated by returning None\n-                if ioerr.kind != EndOfFile {\n-                    io_error::cond.raise(ioerr);\n-                }\n-                return None;\n-            }\n-        }\n-    }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n }\n \n impl Writer for PipeStream {\n-    fn write(&mut self, buf: &[u8]) {\n-        match self.obj.write(buf) {\n-            Ok(_) => (),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n-        }\n-    }\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n }\n \n #[cfg(test)]"}, {"sha": "62f6b3c3029dfde319080ecfd538215cd6b75f7a", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -14,7 +14,7 @@ use prelude::*;\n \n use libc;\n use io;\n-use io::io_error;\n+use io::IoResult;\n use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n \n use fmt;\n@@ -93,7 +93,7 @@ pub enum ProcessExit {\n \n impl fmt::Show for ProcessExit {\n     /// Format a ProcessExit enum, to nicely present the information.\n-    fn fmt(obj: &ProcessExit, f: &mut fmt::Formatter) {\n+    fn fmt(obj: &ProcessExit, f: &mut fmt::Formatter) -> fmt::Result {\n         match *obj {\n             ExitStatus(code) =>  write!(f.buf, \"exit code: {}\", code),\n             ExitSignal(code) =>  write!(f.buf, \"signal: {}\", code),\n@@ -118,7 +118,7 @@ impl ProcessExit {\n impl Process {\n     /// Creates a new pipe initialized, but not bound to any particular\n     /// source/destination\n-    pub fn new(config: ProcessConfig) -> Option<Process> {\n+    pub fn new(config: ProcessConfig) -> IoResult<Process> {\n         let mut config = Some(config);\n         LocalIo::maybe_raise(|io| {\n             io.spawn(config.take_unwrap()).map(|(p, io)| {\n@@ -142,13 +142,8 @@ impl Process {\n     /// function.\n     ///\n     /// If the signal delivery fails, then the `io_error` condition is raised on\n-    pub fn signal(&mut self, signal: int) {\n-        match self.handle.kill(signal) {\n-            Ok(()) => {}\n-            Err(err) => {\n-                io_error::cond.raise(err)\n-            }\n-        }\n+    pub fn signal(&mut self, signal: int) -> IoResult<()> {\n+        self.handle.kill(signal)\n     }\n \n     /// Wait for the child to exit completely, returning the status that it"}, {"sha": "6eed4d146bab5dcf391f454546613a86e9a0e14d", "filename": "src/libstd/io/result.rs", "status": "renamed", "additions": 29, "deletions": 45, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -14,80 +14,64 @@\n //! These implementations allow e.g. `Option<File>` to be used\n //! as a `Reader` without unwrapping the option first.\n \n-use option::*;\n-use super::{Reader, Writer, Listener, Acceptor, Seek, SeekStyle};\n-use super::{standard_error, PreviousIoError, io_error, IoError};\n+use clone::Clone;\n+use result::{Ok, Err};\n+use super::{Reader, Writer, Listener, Acceptor, Seek, SeekStyle, IoResult};\n \n-fn prev_io_error() -> IoError {\n-    standard_error(PreviousIoError)\n-}\n-\n-impl<W: Writer> Writer for Option<W> {\n-    fn write(&mut self, buf: &[u8]) {\n+impl<W: Writer> Writer for IoResult<W> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match *self {\n-            Some(ref mut writer) => writer.write(buf),\n-            None => io_error::cond.raise(prev_io_error())\n+            Ok(ref mut writer) => writer.write(buf),\n+            Err(ref e) => Err((*e).clone())\n         }\n     }\n \n-    fn flush(&mut self) {\n+    fn flush(&mut self) -> IoResult<()> {\n         match *self {\n-            Some(ref mut writer) => writer.flush(),\n-            None => io_error::cond.raise(prev_io_error())\n+            Ok(ref mut writer) => writer.flush(),\n+            Err(ref e) => Err(e.clone()),\n         }\n     }\n }\n \n-impl<R: Reader> Reader for Option<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+impl<R: Reader> Reader for IoResult<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         match *self {\n-            Some(ref mut reader) => reader.read(buf),\n-            None => {\n-                io_error::cond.raise(prev_io_error());\n-                None\n-            }\n+            Ok(ref mut reader) => reader.read(buf),\n+            Err(ref e) => Err(e.clone()),\n         }\n     }\n }\n \n-impl<S: Seek> Seek for Option<S> {\n-    fn tell(&self) -> u64 {\n+impl<S: Seek> Seek for IoResult<S> {\n+    fn tell(&self) -> IoResult<u64> {\n         match *self {\n-            Some(ref seeker) => seeker.tell(),\n-            None => {\n-                io_error::cond.raise(prev_io_error());\n-                0\n-            }\n+            Ok(ref seeker) => seeker.tell(),\n+            Err(ref e) => Err(e.clone()),\n         }\n     }\n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         match *self {\n-            Some(ref mut seeker) => seeker.seek(pos, style),\n-            None => io_error::cond.raise(prev_io_error())\n+            Ok(ref mut seeker) => seeker.seek(pos, style),\n+            Err(ref e) => Err(e.clone())\n         }\n     }\n }\n \n-impl<T, A: Acceptor<T>, L: Listener<T, A>> Listener<T, A> for Option<L> {\n-    fn listen(self) -> Option<A> {\n+impl<T, A: Acceptor<T>, L: Listener<T, A>> Listener<T, A> for IoResult<L> {\n+    fn listen(self) -> IoResult<A> {\n         match self {\n-            Some(listener) => listener.listen(),\n-            None => {\n-                io_error::cond.raise(prev_io_error());\n-                None\n-            }\n+            Ok(listener) => listener.listen(),\n+            Err(e) => Err(e),\n         }\n     }\n }\n \n-impl<T, A: Acceptor<T>> Acceptor<T> for Option<A> {\n-    fn accept(&mut self) -> Option<T> {\n+impl<T, A: Acceptor<T>> Acceptor<T> for IoResult<A> {\n+    fn accept(&mut self) -> IoResult<T> {\n         match *self {\n-            Some(ref mut acceptor) => acceptor.accept(),\n-            None => {\n-                io_error::cond.raise(prev_io_error());\n-                None\n-            }\n+            Ok(ref mut acceptor) => acceptor.accept(),\n+            Err(ref e) => Err(e.clone()),\n         }\n     }\n }", "previous_filename": "src/libstd/io/option.rs"}, {"sha": "aaec1aba4b83a817bdf0605d46114f77e60a2694", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -20,10 +20,11 @@ definitions for a number of signals.\n */\n \n use clone::Clone;\n+use result::{Ok, Err};\n use comm::{Port, SharedChan};\n use container::{Map, MutableMap};\n use hashmap;\n-use option::{Some, None};\n+use io;\n use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n \n #[repr(int)]\n@@ -117,18 +118,18 @@ impl Listener {\n     /// If this function fails to register a signal handler, then an error will\n     /// be raised on the `io_error` condition and the function will return\n     /// false.\n-    pub fn register(&mut self, signum: Signum) -> bool {\n+    pub fn register(&mut self, signum: Signum) -> io::IoResult<()> {\n         if self.handles.contains_key(&signum) {\n-            return true; // self is already listening to signum, so succeed\n+            return Ok(()); // self is already listening to signum, so succeed\n         }\n         match LocalIo::maybe_raise(|io| {\n             io.signal(signum, self.chan.clone())\n         }) {\n-            Some(handle) => {\n+            Ok(handle) => {\n                 self.handles.insert(signum, handle);\n-                true\n+                Ok(())\n             }\n-            None => false\n+            Err(e) => Err(e)\n         }\n     }\n "}, {"sha": "bdf013233c091d68d4ebc933ec8b834c9d806b91", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 29, "deletions": 47, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -28,7 +28,7 @@ out.write(bytes!(\"Hello, world!\"));\n \n use container::Container;\n use fmt;\n-use io::{Reader, Writer, io_error, IoError, OtherIoError,\n+use io::{Reader, Writer, IoResult, IoError, OtherIoError,\n          standard_error, EndOfFile, LineBufferedWriter};\n use libc;\n use option::{Option, Some, None};\n@@ -114,7 +114,8 @@ fn reset_helper(w: ~Writer,\n     match f(t.get(), w) {\n         Some(mut w) => {\n             drop(t);\n-            w.flush();\n+            // FIXME: is failing right here?\n+            w.flush().unwrap();\n             Some(w)\n         }\n         None => None\n@@ -155,9 +156,9 @@ pub fn set_stderr(stderr: ~Writer) -> Option<~Writer> {\n //          // io1 aliases io2\n //      })\n //  })\n-fn with_task_stdout(f: |&mut Writer|) {\n+fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) {\n     let task: Option<~Task> = Local::try_take();\n-    match task {\n+    let result = match task {\n         Some(mut task) => {\n             // Printing may run arbitrary code, so ensure that the task is in\n             // TLS to allow all std services. Note that this means a print while\n@@ -169,7 +170,7 @@ fn with_task_stdout(f: |&mut Writer|) {\n             if my_stdout.is_none() {\n                 my_stdout = Some(~LineBufferedWriter::new(stdout()) as ~Writer);\n             }\n-            f(*my_stdout.get_mut_ref());\n+            let ret = f(*my_stdout.get_mut_ref());\n \n             // Note that we need to be careful when putting the stdout handle\n             // back into the task. If the handle was set to `Some` while\n@@ -184,22 +185,29 @@ fn with_task_stdout(f: |&mut Writer|) {\n             let prev = util::replace(&mut t.get().stdout, my_stdout);\n             drop(t);\n             drop(prev);\n+            ret\n         }\n \n         None => {\n             struct Stdout;\n             impl Writer for Stdout {\n-                fn write(&mut self, data: &[u8]) {\n+                fn write(&mut self, data: &[u8]) -> IoResult<()> {\n                     unsafe {\n                         libc::write(libc::STDOUT_FILENO,\n                                     data.as_ptr() as *libc::c_void,\n                                     data.len() as libc::size_t);\n                     }\n+                    Ok(()) // just ignore the results\n                 }\n             }\n             let mut io = Stdout;\n-            f(&mut io as &mut Writer);\n+            f(&mut io as &mut Writer)\n         }\n+    };\n+\n+    match result {\n+        Ok(()) => {}\n+        Err(e) => fail!(\"failed printing to stdout: {}\", e),\n     }\n }\n \n@@ -226,8 +234,7 @@ pub fn print(s: &str) {\n /// `\\n` character is printed to the console after the string.\n pub fn println(s: &str) {\n     with_task_stdout(|io| {\n-        io.write(s.as_bytes());\n-        io.write(['\\n' as u8]);\n+        io.write(s.as_bytes()).and_then(|()| io.write(['\\n' as u8]))\n     })\n }\n \n@@ -249,7 +256,7 @@ pub struct StdReader {\n }\n \n impl Reader for StdReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let ret = match self.inner {\n             TTY(ref mut tty) => tty.read(buf),\n             File(ref mut file) => file.read(buf).map(|i| i as uint),\n@@ -260,15 +267,8 @@ impl Reader for StdReader {\n             // return an actual EOF error, but apparently for stdin it's a\n             // little different. Hence, here we convert a 0 length read to an\n             // end-of-file indicator so the caller knows to stop reading.\n-            Ok(0) => {\n-                io_error::cond.raise(standard_error(EndOfFile));\n-                None\n-            }\n-            Ok(amt) => Some(amt),\n-            Err(e) => {\n-                io_error::cond.raise(e);\n-                None\n-            }\n+            Ok(0) => { Err(standard_error(EndOfFile)) }\n+            ret @ Ok(..) | ret @ Err(..) => ret,\n         }\n     }\n }\n@@ -289,24 +289,15 @@ impl StdWriter {\n     ///\n     /// This function will raise on the `io_error` condition if an error\n     /// happens.\n-    pub fn winsize(&mut self) -> Option<(int, int)> {\n+    pub fn winsize(&mut self) -> IoResult<(int, int)> {\n         match self.inner {\n-            TTY(ref mut tty) => {\n-                match tty.get_winsize() {\n-                    Ok(p) => Some(p),\n-                    Err(e) => {\n-                        io_error::cond.raise(e);\n-                        None\n-                    }\n-                }\n-            }\n+            TTY(ref mut tty) => tty.get_winsize(),\n             File(..) => {\n-                io_error::cond.raise(IoError {\n+                Err(IoError {\n                     kind: OtherIoError,\n                     desc: \"stream is not a tty\",\n                     detail: None,\n-                });\n-                None\n+                })\n             }\n         }\n     }\n@@ -318,20 +309,15 @@ impl StdWriter {\n     ///\n     /// This function will raise on the `io_error` condition if an error\n     /// happens.\n-    pub fn set_raw(&mut self, raw: bool) {\n+    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n         match self.inner {\n-            TTY(ref mut tty) => {\n-                match tty.set_raw(raw) {\n-                    Ok(()) => {},\n-                    Err(e) => io_error::cond.raise(e),\n-                }\n-            }\n+            TTY(ref mut tty) => tty.set_raw(raw),\n             File(..) => {\n-                io_error::cond.raise(IoError {\n+                Err(IoError {\n                     kind: OtherIoError,\n                     desc: \"stream is not a tty\",\n                     detail: None,\n-                });\n+                })\n             }\n         }\n     }\n@@ -346,14 +332,10 @@ impl StdWriter {\n }\n \n impl Writer for StdWriter {\n-    fn write(&mut self, buf: &[u8]) {\n-        let ret = match self.inner {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        match self.inner {\n             TTY(ref mut tty) => tty.write(buf),\n             File(ref mut file) => file.write(buf),\n-        };\n-        match ret {\n-            Ok(()) => {}\n-            Err(e) => io_error::cond.raise(e)\n         }\n     }\n }"}, {"sha": "692aaa7afd05ed8fc992d14f1ef5a9c3c306cb8e", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -39,16 +39,17 @@ loop {\n */\n \n use comm::Port;\n-use option::Option;\n use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n+use io::IoResult;\n \n pub struct Timer {\n     priv obj: ~RtioTimer\n }\n \n /// Sleep the current task for `msecs` milliseconds.\n pub fn sleep(msecs: u64) {\n-    let mut timer = Timer::new().expect(\"timer::sleep: could not create a Timer\");\n+    let timer = Timer::new();\n+    let mut timer = timer.ok().expect(\"timer::sleep: could not create a Timer\");\n \n     timer.sleep(msecs)\n }\n@@ -57,7 +58,7 @@ impl Timer {\n     /// Creates a new timer which can be used to put the current task to sleep\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n-    pub fn new() -> Option<Timer> {\n+    pub fn new() -> IoResult<Timer> {\n         LocalIo::maybe_raise(|io| io.timer_init().map(|t| Timer { obj: t }))\n     }\n "}, {"sha": "2c7f64ba747ef41f20d5face4770c8c61c05bcfd", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -7,8 +7,10 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n use prelude::*;\n use cmp;\n+use io;\n use vec::bytes::MutableByteVector;\n \n /// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n@@ -25,9 +27,9 @@ impl<'a, R: Reader> LimitReader<'a, R> {\n }\n \n impl<'a, R: Reader> Reader for LimitReader<'a, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         if self.limit == 0 {\n-            return None;\n+            return Err(io::standard_error(io::EndOfFile));\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n@@ -43,17 +45,17 @@ pub struct NullWriter;\n \n impl Writer for NullWriter {\n     #[inline]\n-    fn write(&mut self, _buf: &[u8]) { }\n+    fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> { Ok(()) }\n }\n \n /// A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.\n pub struct ZeroReader;\n \n impl Reader for ZeroReader {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         buf.set_memory(0);\n-        Some(buf.len())\n+        Ok(buf.len())\n     }\n }\n \n@@ -62,8 +64,8 @@ pub struct NullReader;\n \n impl Reader for NullReader {\n     #[inline]\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> {\n-        None\n+    fn read(&mut self, _buf: &mut [u8]) -> io::IoResult<uint> {\n+        Err(io::standard_error(io::EndOfFile))\n     }\n }\n \n@@ -81,17 +83,21 @@ impl MultiWriter {\n \n impl Writer for MultiWriter {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+        let mut ret = Ok(());\n         for writer in self.writers.mut_iter() {\n-            writer.write(buf);\n+            ret = ret.and(writer.write(buf));\n         }\n+        return ret;\n     }\n \n     #[inline]\n-    fn flush(&mut self) {\n+    fn flush(&mut self) -> io::IoResult<()> {\n+        let mut ret = Ok(());\n         for writer in self.writers.mut_iter() {\n-            writer.flush();\n+            ret = ret.and(writer.flush());\n         }\n+        return ret;\n     }\n }\n \n@@ -111,20 +117,25 @@ impl<R: Reader, I: Iterator<R>> ChainedReader<I, R> {\n }\n \n impl<R: Reader, I: Iterator<R>> Reader for ChainedReader<I, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         loop {\n-            match self.cur_reader {\n+            let err = match self.cur_reader {\n                 Some(ref mut r) => {\n                     match r.read(buf) {\n-                        Some(len) => return Some(len),\n-                        None => {}\n+                        Ok(len) => return Ok(len),\n+                        Err(ref e) if e.kind == io::EndOfFile => None,\n+                        Err(e) => Some(e),\n                     }\n                 }\n                 None => break\n+            };\n+            self.cur_reader = self.readers.next();\n+            match err {\n+                Some(e) => return Err(e),\n+                None => {}\n             }\n-            self.cur_reader = self.readers.next()\n         }\n-        None\n+        Err(io::standard_error(io::EndOfFile))\n     }\n }\n \n@@ -150,22 +161,23 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n }\n \n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        self.reader.read(buf).map(|len| {\n-            self.writer.write(buf.slice_to(len));\n-            len\n+    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        self.reader.read(buf).and_then(|len| {\n+            self.writer.write(buf.slice_to(len)).map(|()| len)\n         })\n     }\n }\n \n /// Copies all data from a `Reader` to a `Writer`.\n-pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) {\n+pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n     let mut buf = [0, ..super::DEFAULT_BUF_SIZE];\n     loop {\n-        match r.read(buf) {\n-            Some(len) => w.write(buf.slice_to(len)),\n-            None => break\n-        }\n+        let len = match r.read(buf) {\n+            Ok(len) => len,\n+            Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n+            Err(e) => return Err(e),\n+        };\n+        if_ok!(w.write(buf.slice_to(len)));\n     }\n }\n "}, {"sha": "c5e66ffc7be10bbd067abb0b6068a078c5b705e3", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -102,6 +102,7 @@ use io::Writer;\n use ops::Drop;\n use option::{Some, None, Option};\n use prelude::drop;\n+use result::{Ok, Err};\n use rt::local::Local;\n use rt::task::Task;\n use util;\n@@ -131,13 +132,19 @@ struct DefaultLogger {\n impl Logger for DefaultLogger {\n     // by default, just ignore the level\n     fn log(&mut self, _level: u32, args: &fmt::Arguments) {\n-        fmt::writeln(&mut self.handle, args);\n+        match fmt::writeln(&mut self.handle, args) {\n+            Err(e) => fail!(\"failed to log: {}\", e),\n+            Ok(()) => {}\n+        }\n     }\n }\n \n impl Drop for DefaultLogger {\n     fn drop(&mut self) {\n-        self.handle.flush();\n+        match self.handle.flush() {\n+            Err(e) => fail!(\"failed to flush a logger: {}\", e),\n+            Ok(()) => {}\n+        }\n     }\n }\n "}, {"sha": "b31ae92d7421da08271cc11a09e6cb5f5aca69d1", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -197,3 +197,8 @@ macro_rules! local_data_key (\n         pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n     )\n )\n+\n+#[macro_export]\n+macro_rules! if_ok (\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+)"}, {"sha": "19478e3dbb3c8ed99e5faa8177d6634f1ff95be8", "filename": "src/libstd/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -382,7 +382,7 @@ impl<T: Default> Option<T> {\n \n impl<T: fmt::Show> fmt::Show for Option<T> {\n     #[inline]\n-    fn fmt(s: &Option<T>, f: &mut fmt::Formatter) {\n+    fn fmt(s: &Option<T>, f: &mut fmt::Formatter) -> fmt::Result {\n         match *s {\n             Some(ref t) => write!(f.buf, \"Some({})\", *t),\n             None        => write!(f.buf, \"None\")"}, {"sha": "1afada0a45a12f1d5c20d9838f577b3b6ca233da", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -929,7 +929,7 @@ pub enum MapError {\n }\n \n impl fmt::Show for MapError {\n-    fn fmt(val: &MapError, out: &mut fmt::Formatter) {\n+    fn fmt(val: &MapError, out: &mut fmt::Formatter) -> fmt::Result {\n         let str = match *val {\n             ErrFdNotAvail => \"fd not available for reading or writing\",\n             ErrInvalidFd => \"Invalid fd\",\n@@ -944,23 +944,19 @@ impl fmt::Show for MapError {\n             ErrAlreadyExists => \"File mapping for specified file already exists\",\n             ErrZeroLength => \"Zero-length mapping not allowed\",\n             ErrUnknown(code) => {\n-                write!(out.buf, \"Unknown error = {}\", code);\n-                return\n+                return write!(out.buf, \"Unknown error = {}\", code)\n             },\n             ErrVirtualAlloc(code) => {\n-                write!(out.buf, \"VirtualAlloc failure = {}\", code);\n-                return\n+                return write!(out.buf, \"VirtualAlloc failure = {}\", code)\n             },\n             ErrCreateFileMappingW(code) => {\n-                format!(\"CreateFileMappingW failure = {}\", code);\n-                return\n+                return write!(out.buf, \"CreateFileMappingW failure = {}\", code)\n             },\n             ErrMapViewOfFile(code) => {\n-                write!(out.buf, \"MapViewOfFile failure = {}\", code);\n-                return\n+                return write!(out.buf, \"MapViewOfFile failure = {}\", code)\n             }\n         };\n-        write!(out.buf, \"{}\", str);\n+        write!(out.buf, \"{}\", str)\n     }\n }\n "}, {"sha": "190cf5745f46c873c6d301519284e38a4da93242", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -533,7 +533,7 @@ pub struct Display<'a, P> {\n }\n \n impl<'a, P: GenericPath> fmt::Show for Display<'a, P> {\n-    fn fmt(d: &Display<P>, f: &mut fmt::Formatter) {\n+    fn fmt(d: &Display<P>, f: &mut fmt::Formatter) -> fmt::Display {\n         d.with_str(|s| f.pad(s))\n     }\n }"}, {"sha": "e9068c6b0c8a54c66690b64e6f4982e7f8e71c3d", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -62,7 +62,7 @@ impl OSRng {\n     pub fn new() -> OSRng {\n         use path::Path;\n         let reader = File::open(&Path::new(\"/dev/urandom\"));\n-        let reader = reader.expect(\"Error opening /dev/urandom\");\n+        let reader = reader.ok().expect(\"Error opening /dev/urandom\");\n         let reader_rng = ReaderRng::new(reader);\n \n         OSRng { inner: reader_rng }"}, {"sha": "621d70970f02f8de9202f66f7dff383591ca508c", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -11,7 +11,7 @@\n //! A wrapper around any Reader to treat it as an RNG.\n \n use container::Container;\n-use option::{Some, None};\n+use result::{Ok, Err};\n use io::Reader;\n \n use rand::Rng;\n@@ -49,26 +49,26 @@ impl<R: Reader> Rng for ReaderRng<R> {\n         // platform just involves blitting the bytes into the memory\n         // of the u32, similarly for BE on BE; avoiding byteswapping.\n         if cfg!(target_endian=\"little\") {\n-            self.reader.read_le_u32()\n+            self.reader.read_le_u32().unwrap()\n         } else {\n-            self.reader.read_be_u32()\n+            self.reader.read_be_u32().unwrap()\n         }\n     }\n     fn next_u64(&mut self) -> u64 {\n         // see above for explanation.\n         if cfg!(target_endian=\"little\") {\n-            self.reader.read_le_u64()\n+            self.reader.read_le_u64().unwrap()\n         } else {\n-            self.reader.read_be_u64()\n+            self.reader.read_be_u64().unwrap()\n         }\n     }\n     fn fill_bytes(&mut self, v: &mut [u8]) {\n         if v.len() == 0 { return }\n         match self.reader.read(v) {\n-            Some(n) if n == v.len() => return,\n-            Some(n) => fail!(\"ReaderRng.fill_bytes could not fill buffer: \\\n-                              read {} out of {} bytes.\", n, v.len()),\n-            None => fail!(\"ReaderRng.fill_bytes reached eof.\")\n+            Ok(n) if n == v.len() => return,\n+            Ok(n) => fail!(\"ReaderRng.fill_bytes could not fill buffer: \\\n+                            read {} out of {} bytes.\", n, v.len()),\n+            Err(e) => fail!(\"ReaderRng.fill_bytes error: {}\", e)\n         }\n     }\n }"}, {"sha": "44ee5de7ac34cc3c1018960eb15dbe1f7faecc97", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -66,6 +66,8 @@ impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n     pub fn bump_past<T>(&mut self) {\n         self.bump(mem::size_of::<T>());\n     }\n+\n+    pub fn unwrap(self) -> V { self.inner }\n }\n \n /// Abstract type-directed pointer-movement using the MovePtr trait"}, {"sha": "f71649602b23144cbb0f4d17ad34469bf625f971", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 118, "deletions": 88, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -21,48 +21,57 @@ use char;\n use container::Container;\n use io;\n use iter::Iterator;\n-use option::{Some, None};\n+use option::{Some, None, Option};\n use ptr;\n use reflect;\n use reflect::{MovePtr, align};\n+use result::{Ok, Err};\n use str::StrSlice;\n use to_str::ToStr;\n use vec::OwnedVector;\n use unstable::intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use unstable::raw;\n \n+macro_rules! if_ok( ($me:expr, $e:expr) => (\n+    match $e {\n+        Ok(()) => {},\n+        Err(e) => { $me.last_err = Some(e); return false; }\n+    }\n+) )\n+\n /// Representations\n \n trait Repr {\n-    fn write_repr(&self, writer: &mut io::Writer);\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()>;\n }\n \n impl Repr for () {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n-        writer.write(\"()\".as_bytes());\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n+        writer.write(\"()\".as_bytes())\n     }\n }\n \n impl Repr for bool {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n         let s = if *self { \"true\" } else { \"false\" };\n         writer.write(s.as_bytes())\n     }\n }\n \n impl Repr for int {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n         ::int::to_str_bytes(*self, 10u, |bits| {\n-            writer.write(bits);\n+            writer.write(bits)\n         })\n     }\n }\n \n macro_rules! int_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n         ::$ty::to_str_bytes(*self, 10u, |bits| {\n-            writer.write(bits);\n-            writer.write(bytes!($suffix));\n+            writer.write(bits).and_then(|()| {\n+                writer.write(bytes!($suffix))\n+            })\n         })\n     }\n }))\n@@ -78,10 +87,11 @@ int_repr!(u32, \"u32\")\n int_repr!(u64, \"u64\")\n \n macro_rules! num_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: &mut io::Writer) {\n+    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n         let s = self.to_str();\n-        writer.write(s.as_bytes());\n-        writer.write(bytes!($suffix));\n+        writer.write(s.as_bytes()).and_then(|()| {\n+            writer.write(bytes!($suffix))\n+        })\n     }\n }))\n \n@@ -100,7 +110,8 @@ pub struct ReprVisitor<'a> {\n     priv ptr: *u8,\n     priv ptr_stk: ~[*u8],\n     priv var_stk: ~[VariantState],\n-    priv writer: &'a mut io::Writer\n+    priv writer: &'a mut io::Writer,\n+    priv last_err: Option<io::IoError>,\n }\n \n pub fn ReprVisitor<'a>(ptr: *u8,\n@@ -110,6 +121,7 @@ pub fn ReprVisitor<'a>(ptr: *u8,\n         ptr_stk: ~[],\n         var_stk: ~[],\n         writer: writer,\n+        last_err: None,\n     }\n }\n \n@@ -130,11 +142,10 @@ impl<'a> ReprVisitor<'a> {\n     // Various helpers for the TyVisitor impl\n \n     #[inline]\n-    pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T|) -> bool {\n+    pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n         unsafe {\n-            f(self, transmute::<*u8,&T>(self.ptr));\n+            f(self, transmute::<*u8,&T>(self.ptr))\n         }\n-        true\n     }\n \n     #[inline]\n@@ -152,43 +163,53 @@ impl<'a> ReprVisitor<'a> {\n                 ptr_stk: ~[],\n                 var_stk: ~[],\n                 writer: ::cast::transmute_copy(&self.writer),\n+                last_err: None,\n             };\n             let mut v = reflect::MovePtrAdaptor(u);\n             // Obviously this should not be a thing, but blame #8401 for now\n             visit_tydesc(inner, &mut v as &mut TyVisitor);\n-            true\n+            match v.unwrap().last_err {\n+                Some(e) => {\n+                    self.last_err = Some(e);\n+                    false\n+                }\n+                None => true,\n+            }\n         }\n     }\n \n     #[inline]\n     pub fn write<T:Repr>(&mut self) -> bool {\n         self.get(|this, v:&T| {\n-            v.write_repr(unsafe { ::cast::transmute_copy(&this.writer) });\n+            if_ok!(this, v.write_repr(this.writer));\n+            true\n         })\n     }\n \n-    pub fn write_escaped_slice(&mut self, slice: &str) {\n-        self.writer.write(['\"' as u8]);\n+    pub fn write_escaped_slice(&mut self, slice: &str) -> bool {\n+        if_ok!(self, self.writer.write(['\"' as u8]));\n         for ch in slice.chars() {\n-            self.write_escaped_char(ch, true);\n+            if !self.write_escaped_char(ch, true) { return false }\n         }\n-        self.writer.write(['\"' as u8]);\n+        if_ok!(self, self.writer.write(['\"' as u8]));\n+        true\n     }\n \n-    pub fn write_mut_qualifier(&mut self, mtbl: uint) {\n+    pub fn write_mut_qualifier(&mut self, mtbl: uint) -> bool {\n         if mtbl == 0 {\n-            self.writer.write(\"mut \".as_bytes());\n+            if_ok!(self, self.writer.write(\"mut \".as_bytes()));\n         } else if mtbl == 1 {\n             // skip, this is ast::m_imm\n         } else {\n             fail!(\"invalid mutability value\");\n         }\n+        true\n     }\n \n     pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool {\n         let mut p = ptr as *u8;\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n-        self.writer.write(['[' as u8]);\n+        if_ok!(self, self.writer.write(['[' as u8]));\n         let mut first = true;\n         let mut left = len;\n         // unit structs have 0 size, and don't loop forever.\n@@ -197,22 +218,22 @@ impl<'a> ReprVisitor<'a> {\n             if first {\n                 first = false;\n             } else {\n-                self.writer.write(\", \".as_bytes());\n+                if_ok!(self, self.writer.write(\", \".as_bytes()));\n             }\n             self.visit_ptr_inner(p as *u8, inner);\n             p = align(unsafe { ptr::offset(p, sz as int) as uint }, al) as *u8;\n             left -= dec;\n         }\n-        self.writer.write([']' as u8]);\n+        if_ok!(self, self.writer.write([']' as u8]));\n         true\n     }\n \n     pub fn write_unboxed_vec_repr(&mut self, _: uint, v: &raw::Vec<()>, inner: *TyDesc) -> bool {\n         self.write_vec_range(ptr::to_unsafe_ptr(&v.data), v.fill, inner)\n     }\n \n-    fn write_escaped_char(&mut self, ch: char, is_str: bool) {\n-        match ch {\n+    fn write_escaped_char(&mut self, ch: char, is_str: bool) -> bool {\n+        if_ok!(self, match ch {\n             '\\t' => self.writer.write(\"\\\\t\".as_bytes()),\n             '\\r' => self.writer.write(\"\\\\r\".as_bytes()),\n             '\\n' => self.writer.write(\"\\\\n\".as_bytes()),\n@@ -234,16 +255,18 @@ impl<'a> ReprVisitor<'a> {\n             '\\x20'..'\\x7e' => self.writer.write([ch as u8]),\n             _ => {\n                 char::escape_unicode(ch, |c| {\n-                    self.writer.write([c as u8]);\n-                })\n+                    let _ = self.writer.write([c as u8]);\n+                });\n+                Ok(())\n             }\n-        }\n+        });\n+        return true;\n     }\n }\n \n impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_bot(&mut self) -> bool {\n-        self.writer.write(\"!\".as_bytes());\n+        if_ok!(self, self.writer.write(\"!\".as_bytes()));\n         true\n     }\n     fn visit_nil(&mut self) -> bool { self.write::<()>() }\n@@ -265,9 +288,10 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_char(&mut self) -> bool {\n         self.get::<char>(|this, &ch| {\n-            this.writer.write(['\\'' as u8]);\n-            this.write_escaped_char(ch, false);\n-            this.writer.write(['\\'' as u8]);\n+            if_ok!(this, this.writer.write(['\\'' as u8]));\n+            if !this.write_escaped_char(ch, false) { return false }\n+            if_ok!(this, this.writer.write(['\\'' as u8]));\n+            true\n         })\n     }\n \n@@ -277,8 +301,8 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_estr_uniq(&mut self) -> bool {\n         self.get::<~str>(|this, s| {\n-            this.writer.write(['~' as u8]);\n-            this.write_escaped_slice(*s);\n+            if_ok!(this, this.writer.write(['~' as u8]));\n+            this.write_escaped_slice(*s)\n         })\n     }\n \n@@ -291,34 +315,35 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                         _align: uint) -> bool { fail!(); }\n \n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write(['@' as u8]);\n+        if_ok!(self, self.writer.write(['@' as u8]));\n         self.write_mut_qualifier(mtbl);\n         self.get::<&raw::Box<()>>(|this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *u8;\n-            this.visit_ptr_inner(p, inner);\n+            this.visit_ptr_inner(p, inner)\n         })\n     }\n \n     fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write(['~' as u8]);\n+        if_ok!(self, self.writer.write(['~' as u8]));\n         self.get::<*u8>(|this, b| {\n-            this.visit_ptr_inner(*b, inner);\n+            this.visit_ptr_inner(*b, inner)\n         })\n     }\n \n     fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n         self.get::<*u8>(|this, p| {\n-            write!(this.writer, \"({} as *\", *p);\n+            if_ok!(this, write!(this.writer, \"({} as *\", *p));\n             this.write_mut_qualifier(mtbl);\n-            this.writer.write(\"())\".as_bytes());\n+            if_ok!(this, this.writer.write(\"())\".as_bytes()));\n+            true\n         })\n     }\n \n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write(['&' as u8]);\n+        if_ok!(self, self.writer.write(['&' as u8]));\n         self.write_mut_qualifier(mtbl);\n         self.get::<*u8>(|this, p| {\n-            this.visit_ptr_inner(*p, inner);\n+            this.visit_ptr_inner(*p, inner)\n         })\n     }\n \n@@ -327,76 +352,76 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<raw::Vec<()>>(|this, b| {\n-            this.write_unboxed_vec_repr(mtbl, b, inner);\n+            this.write_unboxed_vec_repr(mtbl, b, inner)\n         })\n     }\n \n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n-            this.writer.write(['@' as u8]);\n+            if_ok!(this, this.writer.write(['@' as u8]));\n             this.write_mut_qualifier(mtbl);\n-            this.write_unboxed_vec_repr(mtbl, &b.data, inner);\n+            this.write_unboxed_vec_repr(mtbl, &b.data, inner)\n         })\n     }\n \n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<&raw::Vec<()>>(|this, b| {\n-            this.writer.write(['~' as u8]);\n-            this.write_unboxed_vec_repr(mtbl, *b, inner);\n+            if_ok!(this, this.writer.write(['~' as u8]));\n+            this.write_unboxed_vec_repr(mtbl, *b, inner)\n         })\n     }\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<raw::Slice<()>>(|this, s| {\n-            this.writer.write(['&' as u8]);\n+            if_ok!(this, this.writer.write(['&' as u8]));\n             this.write_mut_qualifier(mtbl);\n             let size = unsafe {\n                 if (*inner).size == 0 { 1 } else { (*inner).size }\n             };\n-            this.write_vec_range(s.data, s.len * size, inner);\n+            this.write_vec_range(s.data, s.len * size, inner)\n         })\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n                         _: uint, inner: *TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n         self.get::<()>(|this, b| {\n-            this.write_vec_range(ptr::to_unsafe_ptr(b), assumed_size, inner);\n+            this.write_vec_range(ptr::to_unsafe_ptr(b), assumed_size, inner)\n         })\n     }\n \n     fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        self.writer.write(['{' as u8]);\n+        if_ok!(self, self.writer.write(['{' as u8]));\n         true\n     }\n \n     fn visit_rec_field(&mut self, i: uint, name: &str,\n                        mtbl: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write(\", \".as_bytes());\n+            if_ok!(self, self.writer.write(\", \".as_bytes()));\n         }\n         self.write_mut_qualifier(mtbl);\n-        self.writer.write(name.as_bytes());\n-        self.writer.write(\": \".as_bytes());\n+        if_ok!(self, self.writer.write(name.as_bytes()));\n+        if_ok!(self, self.writer.write(\": \".as_bytes()));\n         self.visit_inner(inner);\n         true\n     }\n \n     fn visit_leave_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        self.writer.write(['}' as u8]);\n+        if_ok!(self, self.writer.write(['}' as u8]));\n         true\n     }\n \n     fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n                          _sz: uint, _align: uint) -> bool {\n-        self.writer.write(name.as_bytes());\n+        if_ok!(self, self.writer.write(name.as_bytes()));\n         if n_fields != 0 {\n             if named_fields {\n-                self.writer.write(['{' as u8]);\n+                if_ok!(self, self.writer.write(['{' as u8]));\n             } else {\n-                self.writer.write(['(' as u8]);\n+                if_ok!(self, self.writer.write(['(' as u8]));\n             }\n         }\n         true\n@@ -405,11 +430,11 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n                          _mtbl: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write(\", \".as_bytes());\n+            if_ok!(self, self.writer.write(\", \".as_bytes()));\n         }\n         if named {\n-            self.writer.write(name.as_bytes());\n-            self.writer.write(\": \".as_bytes());\n+            if_ok!(self, self.writer.write(name.as_bytes()));\n+            if_ok!(self, self.writer.write(\": \".as_bytes()));\n         }\n         self.visit_inner(inner);\n         true\n@@ -419,23 +444,23 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                          _sz: uint, _align: uint) -> bool {\n         if n_fields != 0 {\n             if named_fields {\n-                self.writer.write(['}' as u8]);\n+                if_ok!(self, self.writer.write(['}' as u8]));\n             } else {\n-                self.writer.write([')' as u8]);\n+                if_ok!(self, self.writer.write([')' as u8]));\n             }\n         }\n         true\n     }\n \n     fn visit_enter_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n-        self.writer.write(['(' as u8]);\n+        if_ok!(self, self.writer.write(['(' as u8]));\n         true\n     }\n \n     fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write(\", \".as_bytes());\n+            if_ok!(self, self.writer.write(\", \".as_bytes()));\n         }\n         self.visit_inner(inner);\n         true\n@@ -444,9 +469,9 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_leave_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool {\n         if _n_fields == 1 {\n-            self.writer.write([',' as u8]);\n+            if_ok!(self, self.writer.write([',' as u8]));\n         }\n-        self.writer.write([')' as u8]);\n+        if_ok!(self, self.writer.write([')' as u8]));\n         true\n     }\n \n@@ -482,9 +507,9 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         }\n \n         if write {\n-            self.writer.write(name.as_bytes());\n+            if_ok!(self, self.writer.write(name.as_bytes()));\n             if n_fields > 0 {\n-                self.writer.write(['(' as u8]);\n+                if_ok!(self, self.writer.write(['(' as u8]));\n             }\n         }\n         true\n@@ -498,7 +523,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if i != 0 {\n-                    self.writer.write(\", \".as_bytes());\n+                    if_ok!(self, self.writer.write(\", \".as_bytes()));\n                 }\n                 if ! self.visit_inner(inner) {\n                     return false;\n@@ -516,7 +541,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if n_fields > 0 {\n-                    self.writer.write([')' as u8]);\n+                    if_ok!(self, self.writer.write([')' as u8]));\n                 }\n             }\n             _ => ()\n@@ -538,28 +563,29 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool {\n-        self.writer.write(\"fn(\".as_bytes());\n+        if_ok!(self, self.writer.write(\"fn(\".as_bytes()));\n         true\n     }\n \n     fn visit_fn_input(&mut self, i: uint, _mode: uint, inner: *TyDesc) -> bool {\n         if i != 0 {\n-            self.writer.write(\", \".as_bytes());\n+            if_ok!(self, self.writer.write(\", \".as_bytes()));\n         }\n         let name = unsafe { (*inner).name };\n-        self.writer.write(name.as_bytes());\n+        if_ok!(self, self.writer.write(name.as_bytes()));\n         true\n     }\n \n-    fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n+    fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool,\n+                       inner: *TyDesc) -> bool {\n         if variadic {\n-            self.writer.write(\", ...\".as_bytes());\n+            if_ok!(self, self.writer.write(\", ...\".as_bytes()));\n         }\n-        self.writer.write(\")\".as_bytes());\n+        if_ok!(self, self.writer.write(\")\".as_bytes()));\n         let name = unsafe { (*inner).name };\n         if name != \"()\" {\n-            self.writer.write(\" -> \".as_bytes());\n-            self.writer.write(name.as_bytes());\n+            if_ok!(self, self.writer.write(\" -> \".as_bytes()));\n+            if_ok!(self, self.writer.write(name.as_bytes()));\n         }\n         true\n     }\n@@ -569,7 +595,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n \n     fn visit_trait(&mut self, name: &str) -> bool {\n-        self.writer.write(name.as_bytes());\n+        if_ok!(self, self.writer.write(name.as_bytes()));\n         true\n     }\n \n@@ -582,13 +608,17 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_closure_ptr(&mut self, _ck: uint) -> bool { true }\n }\n \n-pub fn write_repr<T>(writer: &mut io::Writer, object: &T) {\n+pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *u8;\n         let tydesc = get_tydesc::<T>();\n         let u = ReprVisitor(ptr, writer);\n         let mut v = reflect::MovePtrAdaptor(u);\n         visit_tydesc(tydesc, &mut v as &mut TyVisitor);\n+        match v.unwrap().last_err {\n+            Some(e) => Err(e),\n+            None => Ok(()),\n+        }\n     }\n }\n \n@@ -597,7 +627,7 @@ pub fn repr_to_str<T>(t: &T) -> ~str {\n     use io;\n \n     let mut result = io::MemWriter::new();\n-    write_repr(&mut result as &mut io::Writer, t);\n+    write_repr(&mut result as &mut io::Writer, t).unwrap();\n     str::from_utf8_owned(result.unwrap()).unwrap()\n }\n \n@@ -615,7 +645,7 @@ fn test_repr() {\n \n     fn exact_test<T>(t: &T, e:&str) {\n         let mut m = io::MemWriter::new();\n-        write_repr(&mut m as &mut io::Writer, t);\n+        write_repr(&mut m as &mut io::Writer, t).unwrap();\n         let s = str::from_utf8_owned(m.unwrap()).unwrap();\n         assert_eq!(s.as_slice(), e);\n     }"}, {"sha": "846bba7533fed755ceee6972b440d672dee5ff26", "filename": "src/libstd/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -208,7 +208,7 @@ impl<T, E> Result<T, E> {\n \n impl<T: fmt::Show, E: fmt::Show> fmt::Show for Result<T, E> {\n     #[inline]\n-    fn fmt(s: &Result<T, E>, f: &mut fmt::Formatter) {\n+    fn fmt(s: &Result<T, E>, f: &mut fmt::Formatter) -> fmt::Result {\n         match *s {\n             Ok(ref t) => write!(f.buf, \"Ok({})\", *t),\n             Err(ref e) => write!(f.buf, \"Err({})\", *e)"}, {"sha": "35b1e21df067731e6e93b5f97affca2685673710", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -16,13 +16,13 @@ use libc;\n use ops::Drop;\n use option::{Option, Some, None};\n use path::Path;\n-use result::{Result, Ok, Err};\n+use result::{Result, Err};\n use rt::task::Task;\n use rt::local::Local;\n \n use ai = io::net::addrinfo;\n use io;\n-use io::IoError;\n+use io::{IoError, IoResult};\n use io::net::ip::{IpAddr, SocketAddr};\n use io::process::{ProcessConfig, ProcessExit};\n use io::signal::Signum;\n@@ -116,23 +116,12 @@ impl<'a> LocalIo<'a> {\n         return ret;\n     }\n \n-    pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>)\n-        -> Option<T>\n+    pub fn maybe_raise<T>(f: |io: &mut IoFactory| -> IoResult<T>)\n+        -> IoResult<T>\n     {\n         match LocalIo::borrow() {\n-            None => {\n-                io::io_error::cond.raise(io::standard_error(io::IoUnavailable));\n-                None\n-            }\n-            Some(mut io) => {\n-                match f(io.get()) {\n-                    Ok(t) => Some(t),\n-                    Err(ioerr) => {\n-                        io::io_error::cond.raise(ioerr);\n-                        None\n-                    }\n-                }\n-            }\n+            None => Err(io::standard_error(io::IoUnavailable)),\n+            Some(mut io) => f(io.get()),\n         }\n     }\n "}, {"sha": "515eb93001af2e56a1d957948fd6e69879cae4b4", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -119,15 +119,16 @@ impl Task {\n \n             // Run the task main function, then do some cleanup.\n             f.finally(|| {\n+                #[allow(unused_must_use)]\n                 fn close_outputs() {\n                     let mut task = Local::borrow(None::<Task>);\n                     let logger = task.get().logger.take();\n                     let stderr = task.get().stderr.take();\n                     let stdout = task.get().stdout.take();\n                     drop(task);\n                     drop(logger); // loggers are responsible for flushing\n-                    match stdout { Some(mut w) => w.flush(), None => {} }\n-                    match stderr { Some(mut w) => w.flush(), None => {} }\n+                    match stdout { Some(mut w) => { w.flush(); }, None => {} }\n+                    match stderr { Some(mut w) => { w.flush(); }, None => {} }\n                 }\n \n                 // First, flush/destroy the user stdout/logger because these"}, {"sha": "9aece13b84ca1cf1b8ae4ee8cdc46f764144cfe2", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -464,9 +464,10 @@ fn begin_unwind_inner(msg: ~Any, file: &'static str, line: uint) -> ! {\n             match task.stderr.take() {\n                 Some(mut stderr) => {\n                     Local::put(task);\n-                    format_args!(|args| ::fmt::writeln(stderr, args),\n-                                 \"task '{}' failed at '{}', {}:{}\",\n-                                 n, msg_s, file, line);\n+                    // FIXME: what to do when the task printing fails?\n+                    let _err = format_args!(|args| ::fmt::writeln(stderr, args),\n+                                            \"task '{}' failed at '{}', {}:{}\",\n+                                            n, msg_s, file, line);\n                     task = Local::take();\n \n                     match util::replace(&mut task.stderr, Some(stderr)) {"}, {"sha": "69e240f30bcf026af4a40d3e98a85f800ac6f815", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -11,10 +11,12 @@\n use container::Container;\n use fmt;\n use from_str::FromStr;\n+use io::IoResult;\n use iter::Iterator;\n use libc;\n use option::{Some, None, Option};\n use os;\n+use result::Ok;\n use str::StrSlice;\n use unstable::running_on_valgrind;\n use vec::ImmutableVector;\n@@ -73,16 +75,17 @@ pub fn dumb_println(args: &fmt::Arguments) {\n \n     struct Stderr;\n     impl io::Writer for Stderr {\n-        fn write(&mut self, data: &[u8]) {\n+        fn write(&mut self, data: &[u8]) -> IoResult<()> {\n             unsafe {\n                 libc::write(libc::STDERR_FILENO,\n                             data.as_ptr() as *libc::c_void,\n                             data.len() as libc::size_t);\n             }\n+            Ok(()) // yes, we're lying\n         }\n     }\n     let mut w = Stderr;\n-    fmt::writeln(&mut w as &mut io::Writer, args);\n+    let _ = fmt::writeln(&mut w as &mut io::Writer, args);\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "fe4693a079f88e16fefddf3362f5f6aa7da9d4c1", "filename": "src/libstd/run.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -119,7 +119,8 @@ impl Process {\n      * * options - Options to configure the environment of the process,\n      *             the working directory and the standard IO streams.\n      */\n-    pub fn new(prog: &str, args: &[~str], options: ProcessOptions) -> Option<Process> {\n+    pub fn new(prog: &str, args: &[~str],\n+               options: ProcessOptions) -> io::IoResult<Process> {\n         let ProcessOptions { env, dir, in_fd, out_fd, err_fd } = options;\n         let env = env.as_ref().map(|a| a.as_slice());\n         let cwd = dir.as_ref().map(|a| a.as_str().unwrap());\n@@ -138,10 +139,7 @@ impl Process {\n             cwd: cwd,\n             io: rtio,\n         };\n-        match process::Process::new(rtconfig) {\n-            Some(inner) => Some(Process { inner: inner }),\n-            None => None\n-        }\n+        process::Process::new(rtconfig).map(|p| Process { inner: p })\n     }\n \n     /// Returns the unique id of the process\n@@ -224,19 +222,17 @@ impl Process {\n         let ch_clone = ch.clone();\n \n         spawn(proc() {\n-            let _guard = io::ignore_io_error();\n             let mut error = error;\n             match error {\n                 Some(ref mut e) => ch.send((2, e.read_to_end())),\n-                None => ch.send((2, ~[]))\n+                None => ch.send((2, Ok(~[])))\n             }\n         });\n         spawn(proc() {\n-            let _guard = io::ignore_io_error();\n             let mut output = output;\n             match output {\n                 Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n-                None => ch_clone.send((1, ~[]))\n+                None => ch_clone.send((1, Ok(~[])))\n             }\n         });\n \n@@ -251,8 +247,8 @@ impl Process {\n         };\n \n         return ProcessOutput {status: status,\n-                              output: outs,\n-                              error: errs};\n+                              output: outs.ok().unwrap_or(~[]),\n+                              error: errs.ok().unwrap_or(~[]) };\n     }\n \n     /**\n@@ -263,7 +259,8 @@ impl Process {\n      * TerminateProcess(..) will be called.\n      */\n     pub fn destroy(&mut self) {\n-        self.inner.signal(io::process::PleaseExitSignal);\n+        // This should never fail because we own the process\n+        self.inner.signal(io::process::PleaseExitSignal).unwrap();\n         self.finish();\n     }\n \n@@ -275,8 +272,10 @@ impl Process {\n      * TerminateProcess(..) will be called.\n      */\n     pub fn force_destroy(&mut self) {\n-        self.inner.signal(io::process::MustDieSignal);\n+        // This should never fail because we own the process\n+        self.inner.signal(io::process::MustDieSignal).unwrap();\n         self.finish();\n+\n     }\n }\n \n@@ -293,18 +292,14 @@ impl Process {\n  *\n  * The process's exit code, or None if the child process could not be started\n  */\n-pub fn process_status(prog: &str, args: &[~str]) -> Option<ProcessExit> {\n-    let mut opt_prog = Process::new(prog, args, ProcessOptions {\n+pub fn process_status(prog: &str, args: &[~str]) -> io::IoResult<ProcessExit> {\n+    Process::new(prog, args, ProcessOptions {\n         env: None,\n         dir: None,\n         in_fd: Some(unsafe { libc::dup(libc::STDIN_FILENO) }),\n         out_fd: Some(unsafe { libc::dup(libc::STDOUT_FILENO) }),\n         err_fd: Some(unsafe { libc::dup(libc::STDERR_FILENO) })\n-    });\n-    match opt_prog {\n-        Some(ref mut prog) => Some(prog.finish()),\n-        None => None\n-    }\n+    }).map(|mut p| p.finish())\n }\n \n /**\n@@ -320,12 +315,10 @@ pub fn process_status(prog: &str, args: &[~str]) -> Option<ProcessExit> {\n  * The process's stdout/stderr output and exit code, or None if the child process could not be\n  * started.\n  */\n-pub fn process_output(prog: &str, args: &[~str]) -> Option<ProcessOutput> {\n-    let mut opt_prog = Process::new(prog, args, ProcessOptions::new());\n-    match opt_prog {\n-        Some(ref mut prog) => Some(prog.finish_with_output()),\n-        None => None\n-    }\n+pub fn process_output(prog: &str, args: &[~str]) -> io::IoResult<ProcessOutput> {\n+    Process::new(prog, args, ProcessOptions::new()).map(|mut p| {\n+        p.finish_with_output()\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "c8bd1907c5c0e59f7a18983db5b78fb989010c1e", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ece8a8f520697be50cbe543bebe065c5198dae4d/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=ece8a8f520697be50cbe543bebe065c5198dae4d", "patch": "@@ -349,7 +349,7 @@ impl<A:IterBytes> ToBytes for A {\n \n         let mut m = ::io::MemWriter::new();\n         self.iter_bytes(lsb0, |bytes| {\n-            m.write(bytes);\n+            m.write(bytes).unwrap();\n             true\n         });\n         m.unwrap()"}]}