{"sha": "61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZjIwNzYxZDMxMjRmNWExYjFjYWVlOGFhMTU2MzdjYzdmOTJkOGU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-03T10:11:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-03T10:11:32Z"}, "message": "Merge branch 'master' into stacked-borrows-2-phase", "tree": {"sha": "47ae018cfce50fcbb67972e23401439aa86dd0fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47ae018cfce50fcbb67972e23401439aa86dd0fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcBQFUCRBK7hj4Ov3rIwAAdHIIAGG/5WU05PWgydpt+nf8aL0t\nAkpIc8iPSapv73d3pLk3owv713w+nSyALC9f/Q5QLlMZ+SYyjPbo4qmRy4Mq1RAc\nH5Ja/kAD3gGBPCxGZ+3qtspK0Ddi61Q7ZbnQGib/ZKQBlskrB2snkL6yHKuYKZNx\nZfztFaChc1gGwhC7Uufk1zg4IWHHS71u+uStnbPlkXZW/gcsSjrVHYN2fu7+q8Fv\n1JN/XzuFZ455ctEzmjiV/xhl6VZgyZO9OWFfCf9Cjz03l1/L/K8sAk3csvukH7oM\nwh80xOH8VF8ulGRMKbNFPb0JqBiL3xrsI5F9+92pD40/xELE/UvCXSm7qUVlAyU=\n=hLnM\n-----END PGP SIGNATURE-----\n", "payload": "tree 47ae018cfce50fcbb67972e23401439aa86dd0fd\nparent b6e5822601beb443faed97d7d7333ba543ea119d\nparent 5bde40cb63b71a1dd805b37bb72300389af120a4\nauthor Ralf Jung <post@ralfj.de> 1543831892 +0100\ncommitter GitHub <noreply@github.com> 1543831892 +0100\n\nMerge branch 'master' into stacked-borrows-2-phase"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "html_url": "https://github.com/rust-lang/rust/commit/61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6e5822601beb443faed97d7d7333ba543ea119d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e5822601beb443faed97d7d7333ba543ea119d", "html_url": "https://github.com/rust-lang/rust/commit/b6e5822601beb443faed97d7d7333ba543ea119d"}, {"sha": "5bde40cb63b71a1dd805b37bb72300389af120a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bde40cb63b71a1dd805b37bb72300389af120a4", "html_url": "https://github.com/rust-lang/rust/commit/5bde40cb63b71a1dd805b37bb72300389af120a4"}], "stats": {"total": 173, "additions": 114, "deletions": 59}, "files": [{"sha": "087b7c6642729415f3aff02ef6b3116433acb028", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -1 +1 @@\n-nightly-2018-11-30\n+nightly-2018-12-03"}, {"sha": "2dc6eee5de9dbe75bfa720237f37047264e73a46", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -155,6 +155,9 @@ fn setup(ask_user: bool) {\n     File::create(dir.join(\"Xargo.toml\")).unwrap()\n         .write_all(br#\"\n [dependencies.std]\n+default_features = false\n+# We need the `panic_unwind` feature because we use the `unwind` panic strategy.\n+# Using `abort` works for libstd, but then libtest will not compile.\n features = [\"panic_unwind\"]\n \n [dependencies.test]"}, {"sha": "71abff2675e3cd856af4166ae7394cc79741ff2d", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -310,26 +310,9 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n     const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::MutStatic);\n \n+    #[inline(always)]\n     fn enforce_validity(ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool {\n-        if !ecx.machine.validate {\n-            return false;\n-        }\n-\n-        // Some functions are whitelisted until we figure out how to fix them.\n-        // We walk up the stack a few frames to also cover their callees.\n-        const WHITELIST: &[(&str, &str)] = &[\n-            // Uses mem::uninitialized\n-            (\"std::sys::windows::mutex::Mutex::\", \"\"),\n-        ];\n-        for frame in ecx.stack().iter()\n-            .rev().take(3)\n-        {\n-            let name = frame.instance.to_string();\n-            if WHITELIST.iter().any(|(prefix, suffix)| name.starts_with(prefix) && name.ends_with(suffix)) {\n-                return false;\n-            }\n-        }\n-        true\n+        ecx.machine.validate\n     }\n \n     /// Returns Ok() when the function was handled, fail otherwise"}, {"sha": "e9fb0aa7779751d9dc2ca7202998fafc0e6b264e", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -303,14 +303,28 @@ impl<'tcx> Stack {\n     /// is met: We cannot push `Uniq` onto frozen stacks.\n     /// `kind` indicates which kind of reference is being created.\n     fn create(&mut self, bor: Borrow, kind: RefKind) {\n-        if self.frozen_since.is_some() {\n-            // A frozen location?  Possible if we create a barrier, then push again.\n-            assert!(bor.is_shared(), \"We should never try creating a unique borrow for a frozen stack\");\n-            trace!(\"create: Not doing anything on frozen location\");\n+        // When creating a frozen reference, freeze.  This ensures F1.\n+        // We also do *not* push anything else to the stack, making sure that no nother kind\n+        // of access (like writing through raw pointers) is permitted.\n+        if kind == RefKind::Frozen {\n+            let bor_t = match bor {\n+                Borrow::Shr(Some(t)) => t,\n+                _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n+            };\n+            // It is possible that we already are frozen (e.g. if we just pushed a barrier,\n+            // the redundancy check would not have kicked in).\n+            match self.frozen_since {\n+                Some(loc_t) => assert!(loc_t <= bor_t, \"Trying to freeze location for longer than it was already frozen\"),\n+                None => {\n+                    trace!(\"create: Freezing\");\n+                    self.frozen_since = Some(bor_t);\n+                }\n+            }\n             return;\n         }\n-        // First, push.  We do this even if we will later freeze, because we\n-        // will allow mutation of shared data at the expense of unfreezing.\n+        assert!(self.frozen_since.is_none(), \"Trying to create non-frozen reference to frozen location\");\n+\n+        // Push new item to the stack.\n         let itm = match bor {\n             Borrow::Uniq(t) => BorStackItem::Uniq(t),\n             Borrow::Shr(_) => BorStackItem::Shr,\n@@ -325,15 +339,6 @@ impl<'tcx> Stack {\n             trace!(\"create: Pushing {:?}\", itm);\n             self.borrows.push(itm);\n         }\n-        // Then, maybe freeze.  This is part 2 of ensuring F1.\n-        if kind == RefKind::Frozen {\n-            let bor_t = match bor {\n-                Borrow::Shr(Some(t)) => t,\n-                _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n-            };\n-            trace!(\"create: Freezing\");\n-            self.frozen_since = Some(bor_t);\n-        }\n     }\n \n     /// Add a barrier"}, {"sha": "a653aa5003f6d4da712027e3f1abe154941ccffe", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_write3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write3.rs?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     // Make sure raw ptr with raw tag cannot mutate frozen location without breaking the shared ref.\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n-    unsafe { *ptr = 42; }\n-    let _val = *r#ref; //~ ERROR is not frozen\n+    unsafe { *ptr = 42; } //~ ERROR does not exist on the stack\n+    let _val = *r#ref;\n }"}, {"sha": "22a80e27103e1ec126c86de0664ca8c89fde6f07", "filename": "tests/compile-fail-fullmir/stacked_borrows/pass_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -3,7 +3,7 @@ fn foo(_: &i32) {}\n \n fn main() {\n     let x = &mut 42;\n-    let xraw = &*x as *const _ as *mut _;\n+    let xraw = x as *mut _;\n     let xref = unsafe { &*xraw };\n     unsafe { *xraw = 42 }; // unfreeze\n     foo(xref); //~ ERROR is not frozen"}, {"sha": "560c9dfb665dd518d2474531f54d1a1d80f1a25e", "filename": "tests/compile-fail-fullmir/stacked_borrows/shr_frozen_violation1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fshr_frozen_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fshr_frozen_violation1.rs?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -0,0 +1,16 @@\n+fn foo(x: &mut i32) -> i32 {\n+  *x = 5;\n+  unknown_code(&*x);\n+  *x // must return 5\n+}\n+\n+fn main() {\n+    println!(\"{}\", foo(&mut 0));\n+}\n+\n+// If we replace the `*const` by `&`, my current dev version of miri\n+// *does* find the problem, but not for a good reason: It finds it because\n+// of barriers, and we shouldn't rely on unknown code using barriers.\n+fn unknown_code(x: *const i32) {\n+    unsafe { *(x as *mut i32) = 7; } //~ ERROR barrier\n+}"}, {"sha": "859890aba9f2e679e546a6f5dac210a374b4d80d", "filename": "tests/compiletest.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -124,16 +124,33 @@ fn is_target_dir<P: Into<PathBuf>>(path: P) -> bool {\n     path.metadata().map(|m| m.is_dir()).unwrap_or(false)\n }\n \n-fn for_all_targets<F: FnMut(String)>(sysroot: &Path, mut f: F) {\n+fn target_has_std<P: Into<PathBuf>>(path: P) -> bool {\n+    let mut path = path.into();\n+    path.push(\"lib\");\n+    std::fs::read_dir(path)\n+        .expect(\"invalid target\")\n+        .map(|entry| entry.unwrap())\n+        .filter(|entry| entry.file_type().unwrap().is_file())\n+        .filter_map(|entry| entry.file_name().into_string().ok())\n+        .any(|file_name| file_name.starts_with(\"libstd\") && file_name.ends_with(\".rlib\"))\n+}\n+\n+\n+fn for_all_targets<F: FnMut(String)>(sysroot: &Path, f: F) {\n     let target_dir = sysroot.join(\"lib\").join(\"rustlib\");\n-    for entry in std::fs::read_dir(target_dir).expect(\"invalid sysroot\") {\n-        let entry = entry.unwrap();\n-        if !is_target_dir(entry.path()) {\n-            continue;\n-        }\n-        let target = entry.file_name().into_string().unwrap();\n-        f(target);\n+    let mut targets = std::fs::read_dir(target_dir)\n+        .expect(\"invalid sysroot\")\n+        .map(|entry| entry.unwrap())\n+        .filter(|entry| is_target_dir(entry.path()))\n+        .filter(|entry| target_has_std(entry.path()))\n+        .map(|entry| entry.file_name().into_string().unwrap())\n+        .peekable();\n+\n+    if targets.peek().is_none() {\n+        panic!(\"No valid targets found\");\n     }\n+\n+    targets.for_each(f);\n }\n \n fn get_sysroot() -> PathBuf {"}, {"sha": "d92cff0b084e6b726f55ebedd4767163353a418a", "filename": "tests/run-pass-fullmir/vecdeque.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Frun-pass-fullmir%2Fvecdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Frun-pass-fullmir%2Fvecdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fvecdeque.rs?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Validation disabled until https://github.com/rust-lang/rust/pull/56161 lands\n+// compile-flags: -Zmiri-disable-validation\n+\n use std::collections::VecDeque;\n \n fn main() {"}, {"sha": "0bc8b15c5f24ebbf2aed0659ce99378d500578f6", "filename": "tests/run-pass/refcell.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Frun-pass%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Frun-pass%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frefcell.rs?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -39,6 +39,13 @@ fn aliasing_mut_and_shr() {\n         *aliasing += 4;\n         let _shr = &*rc;\n         *aliasing += 4;\n+        // also turning this into a frozen ref now must work\n+        let aliasing = &*aliasing;\n+        let _val = *aliasing;\n+        let _escape_to_raw = rc as *const _; // this must NOT unfreeze\n+        let _val = *aliasing;\n+        let _shr = &*rc; // this must NOT unfreeze\n+        let _val = *aliasing;\n     }\n \n     let rc = RefCell::new(23);\n@@ -48,7 +55,23 @@ fn aliasing_mut_and_shr() {\n     assert_eq!(*rc.borrow(), 23+12);\n }\n \n+fn aliasing_frz_and_shr() {\n+    fn inner(rc: &RefCell<i32>, aliasing: &i32) {\n+        let _val = *aliasing;\n+        let _escape_to_raw = rc as *const _; // this must NOT unfreeze\n+        let _val = *aliasing;\n+        let _shr = &*rc; // this must NOT unfreeze\n+        let _val = *aliasing;\n+    }\n+\n+    let rc = RefCell::new(23);\n+    let bshr = rc.borrow();\n+    inner(&rc, &*bshr);\n+    assert_eq!(*rc.borrow(), 23);\n+}\n+\n fn main() {\n     lots_of_funny_borrows();\n     aliasing_mut_and_shr();\n+    aliasing_frz_and_shr();\n }"}, {"sha": "388765c29eabd6ff1f646df758852e1fe85e8e9f", "filename": "tests/run-pass/stacked-borrows.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Frun-pass%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f20761d3124f5a1b1caee8aa15637cc7f92d8e/tests%2Frun-pass%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows.rs?ref=61f20761d3124f5a1b1caee8aa15637cc7f92d8e", "patch": "@@ -4,10 +4,11 @@ fn main() {\n     read_does_not_invalidate1();\n     read_does_not_invalidate2();\n     ref_raw_int_raw();\n-    mut_shr_raw();\n     mut_raw_then_mut_shr();\n+    mut_shr_then_mut_raw();\n     mut_raw_mut();\n     partially_invalidate_mut();\n+    drop_after_sharing();\n }\n \n // Deref a raw ptr to access a field of a large struct, where the field\n@@ -53,18 +54,6 @@ fn ref_raw_int_raw() {\n     assert_eq!(unsafe { *xraw }, 3);\n }\n \n-// Creating a raw from a `&mut` through an `&` works, even if we\n-// write through that raw.\n-fn mut_shr_raw() {\n-    let mut x = 2;\n-    {\n-        let xref = &mut x;\n-        let xraw = &*xref as *const i32 as *mut i32;\n-        unsafe { *xraw = 4; }\n-    }\n-    assert_eq!(x, 4);\n-}\n-\n // Escape a mut to raw, then share the same mut and use the share, then the raw.\n // That should work.\n fn mut_raw_then_mut_shr() {\n@@ -77,6 +66,16 @@ fn mut_raw_then_mut_shr() {\n     assert_eq!(x, 4);\n }\n \n+// Create first a shared reference and then a raw pointer from a `&mut`\n+// should permit mutation through that raw pointer.\n+fn mut_shr_then_mut_raw() {\n+    let xref = &mut 2;\n+    let _xshr = &*xref;\n+    let xraw = xref as *mut _;\n+    unsafe { *xraw = 3; }\n+    assert_eq!(*xref, 3);\n+}\n+\n // Ensure that if we derive from a mut a raw, and then from that a mut,\n // and then read through the original mut, that does not invalidate the raw.\n // This shows that the read-exception for `&mut` applies even if the `Shr` item\n@@ -107,3 +106,9 @@ fn partially_invalidate_mut() {\n     *shard += 1; // so we can still use `shard`.\n     assert_eq!(*data, (1, 1));\n }\n+\n+// Make sure that we can handle the situation where a loaction is frozen when being dropped.\n+fn drop_after_sharing() {\n+    let x = String::from(\"hello!\");\n+    let _len = x.len();\n+}"}]}