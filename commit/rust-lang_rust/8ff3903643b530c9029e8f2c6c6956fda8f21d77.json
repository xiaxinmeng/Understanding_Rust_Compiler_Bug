{"sha": "8ff3903643b530c9029e8f2c6c6956fda8f21d77", "node_id": "C_kwDOAAsO6NoAKDhmZjM5MDM2NDNiNTMwYzkwMjllOGYyYzZjNjk1NmZkYThmMjFkNzc", "commit": {"author": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-03-05T15:03:22Z"}, "committer": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-05-02T10:30:09Z"}, "message": "initial step towards implementing C string literals", "tree": {"sha": "e424bc1501abc62c70ad0c622777a0c6cb4cd0e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e424bc1501abc62c70ad0c622777a0c6cb4cd0e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ff3903643b530c9029e8f2c6c6956fda8f21d77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff3903643b530c9029e8f2c6c6956fda8f21d77", "html_url": "https://github.com/rust-lang/rust/commit/8ff3903643b530c9029e8f2c6c6956fda8f21d77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ff3903643b530c9029e8f2c6c6956fda8f21d77/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b99493492ad59c7a44c65373558175db42b4151", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b99493492ad59c7a44c65373558175db42b4151", "html_url": "https://github.com/rust-lang/rust/commit/7b99493492ad59c7a44c65373558175db42b4151"}], "stats": {"total": 390, "additions": 310, "deletions": 80}, "files": [{"sha": "fb22e4640647d03aae6da8336367fc2edfe2341a", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -1814,6 +1814,8 @@ pub enum LitKind {\n     /// A byte string (`b\"foo\"`). Not stored as a symbol because it might be\n     /// non-utf8, and symbols only allow utf8 strings.\n     ByteStr(Lrc<[u8]>, StrStyle),\n+    /// A C String (`c\"foo\"`).\n+    CStr(Lrc<[u8]>, StrStyle),\n     /// A byte char (`b'f'`).\n     Byte(u8),\n     /// A character literal (`'a'`).\n@@ -1868,6 +1870,7 @@ impl LitKind {\n             // unsuffixed variants\n             LitKind::Str(..)\n             | LitKind::ByteStr(..)\n+            | LitKind::CStr(..)\n             | LitKind::Byte(..)\n             | LitKind::Char(..)\n             | LitKind::Int(_, LitIntType::Unsuffixed)"}, {"sha": "42b843482a32b386ff9bf374fd342360cebff71d", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -74,6 +74,8 @@ pub enum LitKind {\n     StrRaw(u8), // raw string delimited by `n` hash symbols\n     ByteStr,\n     ByteStrRaw(u8), // raw byte string delimited by `n` hash symbols\n+    CStr,\n+    CStrRaw(u8),\n     Err,\n }\n \n@@ -141,6 +143,10 @@ impl fmt::Display for Lit {\n                 delim = \"#\".repeat(n as usize),\n                 string = symbol\n             )?,\n+            CStr => write!(f, \"c\\\"{symbol}\\\"\")?,\n+            CStrRaw(n) => {\n+                write!(f, \"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize))?\n+            }\n             Integer | Float | Bool | Err => write!(f, \"{symbol}\")?,\n         }\n \n@@ -170,6 +176,7 @@ impl LitKind {\n             Float => \"float\",\n             Str | StrRaw(..) => \"string\",\n             ByteStr | ByteStrRaw(..) => \"byte string\",\n+            CStr | CStrRaw(..) => \"C string\",\n             Err => \"error\",\n         }\n     }"}, {"sha": "8534011e18921ef99600297c0f45ec27b48710f8", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -2,7 +2,10 @@\n \n use crate::ast::{self, LitKind, MetaItemLit, StrStyle};\n use crate::token::{self, Token};\n-use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n+use rustc_lexer::unescape::{\n+    byte_from_char, unescape_byte, unescape_c_string, unescape_char, unescape_literal, CStrUnit,\n+    Mode,\n+};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n use std::{ascii, fmt, str};\n@@ -158,6 +161,52 @@ impl LitKind {\n \n                 LitKind::ByteStr(bytes.into(), StrStyle::Raw(n))\n             }\n+            token::CStr => {\n+                let s = symbol.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut error = Ok(());\n+                unescape_c_string(s, Mode::CStr, &mut |span, c| match c {\n+                    Ok(CStrUnit::Byte(0) | CStrUnit::Char('\\0')) => {\n+                        error = Err(LitError::NulInCStr(span));\n+                    }\n+                    Ok(CStrUnit::Byte(b)) => buf.push(b),\n+                    Ok(CStrUnit::Char(c)) if c.len_utf8() == 1 => buf.push(c as u8),\n+                    Ok(CStrUnit::Char(c)) => {\n+                        buf.extend_from_slice(c.encode_utf8(&mut [0; 4]).as_bytes())\n+                    }\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n+                        }\n+                    }\n+                });\n+                error?;\n+                buf.push(b'\\0');\n+                LitKind::CStr(buf.into(), StrStyle::Cooked)\n+            }\n+            token::CStrRaw(n) => {\n+                let s = symbol.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut error = Ok(());\n+                unescape_c_string(s, Mode::RawCStr, &mut |span, c| match c {\n+                    Ok(CStrUnit::Byte(0) | CStrUnit::Char('\\0')) => {\n+                        error = Err(LitError::NulInCStr(span));\n+                    }\n+                    Ok(CStrUnit::Byte(b)) => buf.push(b),\n+                    Ok(CStrUnit::Char(c)) if c.len_utf8() == 1 => buf.push(c as u8),\n+                    Ok(CStrUnit::Char(c)) => {\n+                        buf.extend_from_slice(c.encode_utf8(&mut [0; 4]).as_bytes())\n+                    }\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n+                        }\n+                    }\n+                });\n+                error?;\n+                buf.push(b'\\0');\n+                LitKind::CStr(buf.into(), StrStyle::Raw(n))\n+            }\n             token::Err => LitKind::Err,\n         })\n     }\n@@ -191,6 +240,8 @@ impl fmt::Display for LitKind {\n                     string = symbol\n                 )?;\n             }\n+            // TODO need to reescape\n+            LitKind::CStr(..) => todo!(),\n             LitKind::Int(n, ty) => {\n                 write!(f, \"{n}\")?;\n                 match ty {\n@@ -237,6 +288,8 @@ impl MetaItemLit {\n             LitKind::Str(_, ast::StrStyle::Raw(n)) => token::StrRaw(n),\n             LitKind::ByteStr(_, ast::StrStyle::Cooked) => token::ByteStr,\n             LitKind::ByteStr(_, ast::StrStyle::Raw(n)) => token::ByteStrRaw(n),\n+            LitKind::CStr(_, ast::StrStyle::Cooked) => token::CStr,\n+            LitKind::CStr(_, ast::StrStyle::Raw(n)) => token::CStrRaw(n),\n             LitKind::Byte(_) => token::Byte,\n             LitKind::Char(_) => token::Char,\n             LitKind::Int(..) => token::Integer,"}, {"sha": "535ac89e751d529e6a89dc0e85cf57dde92d6d8c", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -210,6 +210,8 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n         token::ByteStrRaw(n) => {\n             format!(\"br{delim}\\\"{string}\\\"{delim}\", delim = \"#\".repeat(n as usize), string = symbol)\n         }\n+        // TODO\n+        token::CStr | token::CStrRaw(_) => todo!(),\n         token::Integer | token::Float | token::Bool | token::Err => symbol.to_string(),\n     };\n "}, {"sha": "50e88ae2eeeded88a87001354979231f75cc6792", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -32,6 +32,10 @@ pub fn expand_concat(\n                 Ok(ast::LitKind::Bool(b)) => {\n                     accumulator.push_str(&b.to_string());\n                 }\n+                Ok(ast::LitKind::CStr(..)) => {\n+                    cx.span_err(e.span, \"cannot concatenate a C string literal\");\n+                    has_errors = true;\n+                }\n                 Ok(ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..)) => {\n                     cx.emit_err(errors::ConcatBytestr { span: e.span });\n                     has_errors = true;"}, {"sha": "ae674995e42946464f27629c32281e272fd9f6c1", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -18,6 +18,10 @@ fn invalid_type_err(\n     };\n     let snippet = cx.sess.source_map().span_to_snippet(span).ok();\n     match ast::LitKind::from_token_lit(token_lit) {\n+        Ok(ast::LitKind::CStr(_, _)) => {\n+            // TODO\n+            cx.span_err(span, \"cannot concatenate C string litearls\");\n+        }\n         Ok(ast::LitKind::Char(_)) => {\n             let sugg =\n                 snippet.map(|snippet| ConcatBytesInvalidSuggestion::CharLit { span, snippet });"}, {"sha": "04bdea273ebd5f9dc0bc50c269549074392241a6", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -61,6 +61,8 @@ impl FromInternal<token::LitKind> for LitKind {\n             token::StrRaw(n) => LitKind::StrRaw(n),\n             token::ByteStr => LitKind::ByteStr,\n             token::ByteStrRaw(n) => LitKind::ByteStrRaw(n),\n+            // TODO\n+            token::CStr | token::CStrRaw(_) => todo!(),\n             token::Err => LitKind::Err,\n             token::Bool => unreachable!(),\n         }\n@@ -436,6 +438,8 @@ impl server::FreeFunctions for Rustc<'_, '_> {\n                 | token::LitKind::StrRaw(_)\n                 | token::LitKind::ByteStr\n                 | token::LitKind::ByteStrRaw(_)\n+                | token::LitKind::CStr\n+                | token::LitKind::CStrRaw(_)\n                 | token::LitKind::Err => return Err(()),\n                 token::LitKind::Integer | token::LitKind::Float => {}\n             }"}, {"sha": "7ddafc9083a151c93767334a2048bf38a5d612e5", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -332,6 +332,7 @@ language_item_table! {\n     RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n \n     String,                  sym::String,              string,                     Target::Struct,         GenericRequirement::None;\n+    CStr,                    sym::CStr,                c_str,                      Target::Struct,         GenericRequirement::None;\n }\n \n pub enum GenericRequirement {"}, {"sha": "374266638d160599fb97ae0773b0ac7a706e72ca", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -1300,6 +1300,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 opt_ty.unwrap_or_else(|| self.next_float_var())\n             }\n             ast::LitKind::Bool(_) => tcx.types.bool,\n+            ast::LitKind::CStr(_, _) => tcx.mk_imm_ref(\n+                tcx.lifetimes.re_static,\n+                tcx.type_of(tcx.require_lang_item(hir::LangItem::CStr, Some(lit.span)))\n+                    .skip_binder(),\n+            ),\n             ast::LitKind::Err => tcx.ty_error_misc(),\n         }\n     }"}, {"sha": "95cb1f93e3906b0ac576a700c7267a6fb882939a", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -186,12 +186,16 @@ pub enum LiteralKind {\n     Str { terminated: bool },\n     /// \"b\"abc\"\", \"b\"abc\"\n     ByteStr { terminated: bool },\n+    /// `c\"abc\"`, `c\"abc`\n+    CStr { terminated: bool },\n     /// \"r\"abc\"\", \"r#\"abc\"#\", \"r####\"ab\"###\"c\"####\", \"r#\"a\". `None` indicates\n     /// an invalid literal.\n     RawStr { n_hashes: Option<u8> },\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\". `None`\n     /// indicates an invalid literal.\n     RawByteStr { n_hashes: Option<u8> },\n+    /// `cr\"abc\"`, \"cr#\"abc\"#\", `cr#\"a`. `None` is invalid.\n+    RawCStr { n_hashes: Option<u8> },\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n@@ -391,6 +395,32 @@ impl Cursor<'_> {\n                 _ => self.ident_or_unknown_prefix(),\n             },\n \n+            // TODO deduplicate this code\n+            // c-string literal, raw c-string literal or identifier.\n+            'c' => match (self.first(), self.second()) {\n+                ('\"', _) => {\n+                    self.bump();\n+                    let terminated = self.double_quoted_string();\n+                    let suffix_start = self.pos_within_token();\n+                    if terminated {\n+                        self.eat_literal_suffix();\n+                    }\n+                    let kind = CStr { terminated };\n+                    Literal { kind, suffix_start }\n+                }\n+                ('r', '\"') | ('r', '#') => {\n+                    self.bump();\n+                    let res = self.raw_double_quoted_string(2);\n+                    let suffix_start = self.pos_within_token();\n+                    if res.is_ok() {\n+                        self.eat_literal_suffix();\n+                    }\n+                    let kind = RawCStr { n_hashes: res.ok() };\n+                    Literal { kind, suffix_start }\n+                }\n+                _ => self.ident_or_unknown_prefix(),\n+            },\n+\n             // Identifier (this should be checked after other variant that can\n             // start as identifier).\n             c if is_id_start(c) => self.ident_or_unknown_prefix(),"}, {"sha": "4b707c9ec9619386b9271e5b0681e8ce20a80f85", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 121, "deletions": 78, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -90,6 +90,39 @@ where\n         Mode::RawStr | Mode::RawByteStr => {\n             unescape_raw_str_or_raw_byte_str(src, mode == Mode::RawByteStr, callback)\n         }\n+        Mode::CStr | Mode::RawCStr => unreachable!(),\n+    }\n+}\n+\n+pub enum CStrUnit {\n+    Byte(u8),\n+    Char(char),\n+}\n+\n+impl From<u8> for CStrUnit {\n+    fn from(value: u8) -> Self {\n+        CStrUnit::Byte(value)\n+    }\n+}\n+\n+impl From<char> for CStrUnit {\n+    fn from(value: char) -> Self {\n+        CStrUnit::Char(value)\n+    }\n+}\n+\n+pub fn unescape_c_string<F>(src: &str, mode: Mode, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<CStrUnit, EscapeError>),\n+{\n+    if mode == Mode::RawCStr {\n+        unescape_raw_str_or_raw_byte_str(\n+            src,\n+            mode.characters_should_be_ascii(),\n+            &mut |r, result| callback(r, result.map(CStrUnit::Char)),\n+        );\n+    } else {\n+        unescape_str_common(src, mode, callback);\n     }\n }\n \n@@ -114,19 +147,26 @@ pub enum Mode {\n     ByteStr,\n     RawStr,\n     RawByteStr,\n+    CStr,\n+    RawCStr,\n }\n \n impl Mode {\n     pub fn in_double_quotes(self) -> bool {\n         match self {\n-            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => true,\n+            Mode::Str\n+            | Mode::ByteStr\n+            | Mode::RawStr\n+            | Mode::RawByteStr\n+            | Mode::CStr\n+            | Mode::RawCStr => true,\n             Mode::Char | Mode::Byte => false,\n         }\n     }\n \n     pub fn is_byte(self) -> bool {\n         match self {\n-            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr | Mode::CStr | Mode::RawCStr => true,\n             Mode::Char | Mode::Str | Mode::RawStr => false,\n         }\n     }\n@@ -163,62 +203,63 @@ fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError\n             value as char\n         }\n \n-        'u' => {\n-            // We've parsed '\\u', now we have to parse '{..}'.\n+        'u' => scan_unicode(chars, is_byte)?,\n+        _ => return Err(EscapeError::InvalidEscape),\n+    };\n+    Ok(res)\n+}\n \n-            if chars.next() != Some('{') {\n-                return Err(EscapeError::NoBraceInUnicodeEscape);\n-            }\n+fn scan_unicode(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n+    // We've parsed '\\u', now we have to parse '{..}'.\n \n-            // First character must be a hexadecimal digit.\n-            let mut n_digits = 1;\n-            let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n-                '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n-                '}' => return Err(EscapeError::EmptyUnicodeEscape),\n-                c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n-            };\n-\n-            // First character is valid, now parse the rest of the number\n-            // and closing brace.\n-            loop {\n-                match chars.next() {\n-                    None => return Err(EscapeError::UnclosedUnicodeEscape),\n-                    Some('_') => continue,\n-                    Some('}') => {\n-                        if n_digits > 6 {\n-                            return Err(EscapeError::OverlongUnicodeEscape);\n-                        }\n-\n-                        // Incorrect syntax has higher priority for error reporting\n-                        // than unallowed value for a literal.\n-                        if is_byte {\n-                            return Err(EscapeError::UnicodeEscapeInByte);\n-                        }\n-\n-                        break std::char::from_u32(value).ok_or_else(|| {\n-                            if value > 0x10FFFF {\n-                                EscapeError::OutOfRangeUnicodeEscape\n-                            } else {\n-                                EscapeError::LoneSurrogateUnicodeEscape\n-                            }\n-                        })?;\n-                    }\n-                    Some(c) => {\n-                        let digit: u32 =\n-                            c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n-                        n_digits += 1;\n-                        if n_digits > 6 {\n-                            // Stop updating value since we're sure that it's incorrect already.\n-                            continue;\n-                        }\n-                        value = value * 16 + digit;\n+    if chars.next() != Some('{') {\n+        return Err(EscapeError::NoBraceInUnicodeEscape);\n+    }\n+\n+    // First character must be a hexadecimal digit.\n+    let mut n_digits = 1;\n+    let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n+        '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n+        '}' => return Err(EscapeError::EmptyUnicodeEscape),\n+        c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n+    };\n+\n+    // First character is valid, now parse the rest of the number\n+    // and closing brace.\n+    loop {\n+        match chars.next() {\n+            None => return Err(EscapeError::UnclosedUnicodeEscape),\n+            Some('_') => continue,\n+            Some('}') => {\n+                if n_digits > 6 {\n+                    return Err(EscapeError::OverlongUnicodeEscape);\n+                }\n+\n+                // Incorrect syntax has higher priority for error reporting\n+                // than unallowed value for a literal.\n+                if is_byte {\n+                    return Err(EscapeError::UnicodeEscapeInByte);\n+                }\n+\n+                break std::char::from_u32(value).ok_or_else(|| {\n+                    if value > 0x10FFFF {\n+                        EscapeError::OutOfRangeUnicodeEscape\n+                    } else {\n+                        EscapeError::LoneSurrogateUnicodeEscape\n                     }\n-                };\n+                });\n             }\n-        }\n-        _ => return Err(EscapeError::InvalidEscape),\n-    };\n-    Ok(res)\n+            Some(c) => {\n+                let digit: u32 = c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n+                n_digits += 1;\n+                if n_digits > 6 {\n+                    // Stop updating value since we're sure that it's incorrect already.\n+                    continue;\n+                }\n+                value = value * 16 + digit;\n+            }\n+        };\n+    }\n }\n \n #[inline]\n@@ -266,7 +307,9 @@ where\n                         // if unescaped '\\' character is followed by '\\n'.\n                         // For details see [Rust language reference]\n                         // (https://doc.rust-lang.org/reference/tokens.html#string-literals).\n-                        skip_ascii_whitespace(&mut chars, start, callback);\n+                        skip_ascii_whitespace(&mut chars, start, &mut |range, err| {\n+                            callback(range, Err(err))\n+                        });\n                         continue;\n                     }\n                     _ => scan_escape(&mut chars, is_byte),\n@@ -281,32 +324,32 @@ where\n         let end = src.len() - chars.as_str().len();\n         callback(start..end, res);\n     }\n+}\n \n-    fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n-    where\n-        F: FnMut(Range<usize>, Result<char, EscapeError>),\n-    {\n-        let tail = chars.as_str();\n-        let first_non_space = tail\n-            .bytes()\n-            .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n-            .unwrap_or(tail.len());\n-        if tail[1..first_non_space].contains('\\n') {\n-            // The +1 accounts for the escaping slash.\n-            let end = start + first_non_space + 1;\n-            callback(start..end, Err(EscapeError::MultipleSkippedLinesWarning));\n-        }\n-        let tail = &tail[first_non_space..];\n-        if let Some(c) = tail.chars().nth(0) {\n-            if c.is_whitespace() {\n-                // For error reporting, we would like the span to contain the character that was not\n-                // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n-                let end = start + first_non_space + c.len_utf8() + 1;\n-                callback(start..end, Err(EscapeError::UnskippedWhitespaceWarning));\n-            }\n+fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, EscapeError),\n+{\n+    let tail = chars.as_str();\n+    let first_non_space = tail\n+        .bytes()\n+        .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n+        .unwrap_or(tail.len());\n+    if tail[1..first_non_space].contains('\\n') {\n+        // The +1 accounts for the escaping slash.\n+        let end = start + first_non_space + 1;\n+        callback(start..end, EscapeError::MultipleSkippedLinesWarning);\n+    }\n+    let tail = &tail[first_non_space..];\n+    if let Some(c) = tail.chars().nth(0) {\n+        if c.is_whitespace() {\n+            // For error reporting, we would like the span to contain the character that was not\n+            // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n+            let end = start + first_non_space + c.len_utf8() + 1;\n+            callback(start..end, EscapeError::UnskippedWhitespaceWarning);\n         }\n-        *chars = tail.chars();\n     }\n+    *chars = tail.chars();\n }\n \n /// Takes a contents of a string literal (without quotes) and produces a"}, {"sha": "b2050780309f83e1e3bcc008508d04b9ef3ab21f", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -415,6 +415,16 @@ impl<'a> StringReader<'a> {\n                 }\n                 self.cook_quoted(token::ByteStr, Mode::ByteStr, start, end, 2, 1) // b\" \"\n             }\n+            rustc_lexer::LiteralKind::CStr { terminated } => {\n+                if !terminated {\n+                    self.sess.span_diagnostic.span_fatal_with_code(\n+                        self.mk_sp(start + BytePos(1), end),\n+                        \"unterminated C string\",\n+                        error_code!(E0767),\n+                    )\n+                }\n+                self.cook_c_string(token::CStr, Mode::CStr, start, end, 2, 1) // c\" \"\n+            }\n             rustc_lexer::LiteralKind::RawStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n@@ -433,6 +443,15 @@ impl<'a> StringReader<'a> {\n                     self.report_raw_str_error(start, 2);\n                 }\n             }\n+            rustc_lexer::LiteralKind::RawCStr { n_hashes } => {\n+                if let Some(n_hashes) = n_hashes {\n+                    let n = u32::from(n_hashes);\n+                    let kind = token::CStrRaw(n_hashes);\n+                    self.cook_c_string(kind, Mode::RawCStr, start, end, 3 + n, 1 + n) // cr##\" \"##\n+                } else {\n+                    self.report_raw_str_error(start, 2);\n+                }\n+            }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n                 if empty_int {\n                     let span = self.mk_sp(start, end);\n@@ -692,6 +711,51 @@ impl<'a> StringReader<'a> {\n             (token::Err, self.symbol_from_to(start, end))\n         }\n     }\n+\n+    fn cook_c_string(\n+        &self,\n+        kind: token::LitKind,\n+        mode: Mode,\n+        start: BytePos,\n+        end: BytePos,\n+        prefix_len: u32,\n+        postfix_len: u32,\n+    ) -> (token::LitKind, Symbol) {\n+        let mut has_fatal_err = false;\n+        let content_start = start + BytePos(prefix_len);\n+        let content_end = end - BytePos(postfix_len);\n+        let lit_content = self.str_from_to(content_start, content_end);\n+        unescape::unescape_c_string(lit_content, mode, &mut |range, result| {\n+            // Here we only check for errors. The actual unescaping is done later.\n+            if let Err(err) = result {\n+                let span_with_quotes = self.mk_sp(start, end);\n+                let (start, end) = (range.start as u32, range.end as u32);\n+                let lo = content_start + BytePos(start);\n+                let hi = lo + BytePos(end - start);\n+                let span = self.mk_sp(lo, hi);\n+                if err.is_fatal() {\n+                    has_fatal_err = true;\n+                }\n+                emit_unescape_error(\n+                    &self.sess.span_diagnostic,\n+                    lit_content,\n+                    span_with_quotes,\n+                    span,\n+                    mode,\n+                    range,\n+                    err,\n+                );\n+            }\n+        });\n+\n+        // We normally exclude the quotes for the symbol, but for errors we\n+        // include it because it results in clearer error messages.\n+        if !has_fatal_err {\n+            (kind, Symbol::intern(lit_content))\n+        } else {\n+            (token::Err, self.symbol_from_to(start, end))\n+        }\n+    }\n }\n \n pub fn nfc_normalize(string: &str) -> Symbol {"}, {"sha": "2ac679b6bc3475f017ff6ecd2a89707c32e7fcff", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -82,6 +82,7 @@ use crate::str;\n #[cfg_attr(not(test), rustc_diagnostic_item = \"CStr\")]\n #[stable(feature = \"core_c_str\", since = \"1.64.0\")]\n #[rustc_has_incoherent_inherent_impls]\n+#[cfg_attr(not(bootstrap), lang = \"CStr\")]\n // FIXME:\n // `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n // on `CStr` being layout-compatible with `[u8]`."}, {"sha": "c94968b4817cbea0ecc52d857efb7fc4e567a77d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -811,7 +811,9 @@ impl<'src> Classifier<'src> {\n                 | LiteralKind::Str { .. }\n                 | LiteralKind::ByteStr { .. }\n                 | LiteralKind::RawStr { .. }\n-                | LiteralKind::RawByteStr { .. } => Class::String,\n+                | LiteralKind::RawByteStr { .. }\n+                | LiteralKind::CStr { .. }\n+                | LiteralKind::RawCStr { .. } => Class::String,\n                 // Number literals.\n                 LiteralKind::Float { .. } | LiteralKind::Int { .. } => Class::Number,\n             },"}, {"sha": "a48f4c77f857fb5cd8119d9c5aea9d1958eca4e5", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -284,6 +284,7 @@ impl<'a> NormalizedPat<'a> {\n                     LitKind::Str(sym, _) => Self::LitStr(sym),\n                     LitKind::ByteStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Byte(val) => Self::LitInt(val.into()),\n+                    LitKind::CStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Char(val) => Self::LitInt(val.into()),\n                     LitKind::Int(val, _) => Self::LitInt(val),\n                     LitKind::Bool(val) => Self::LitBool(val),"}, {"sha": "f75dff46624e40cf2b4bce71df762f9c333c1a67", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -304,6 +304,11 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 kind!(\"ByteStr(ref {vec})\");\n                 chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n             },\n+            LitKind::CStr(ref vec, _) => {\n+                bind!(self, vec);\n+                kind!(\"CStr(ref {vec})\");\n+                chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n+            }\n             LitKind::Str(s, _) => {\n                 bind!(self, s);\n                 kind!(\"Str({s}, _)\");"}, {"sha": "7c7ec6d334d9bc7dadff7024da2a7b5395d47246", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ff3903643b530c9029e8f2c6c6956fda8f21d77/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff3903643b530c9029e8f2c6c6956fda8f21d77/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=8ff3903643b530c9029e8f2c6c6956fda8f21d77", "patch": "@@ -211,6 +211,7 @@ pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n         LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n         LitKind::Byte(b) => Constant::Int(u128::from(b)),\n         LitKind::ByteStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n+        LitKind::CStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n         LitKind::Char(c) => Constant::Char(c),\n         LitKind::Int(n, _) => Constant::Int(n),\n         LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {"}]}