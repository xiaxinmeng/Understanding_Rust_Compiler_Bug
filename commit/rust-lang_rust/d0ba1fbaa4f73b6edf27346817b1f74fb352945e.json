{"sha": "d0ba1fbaa4f73b6edf27346817b1f74fb352945e", "node_id": "C_kwDOAAsO6NoAKGQwYmExZmJhYTRmNzNiNmVkZjI3MzQ2ODE3YjFmNzRmYjM1Mjk0NWU", "commit": {"author": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-08-24T18:14:41Z"}, "committer": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-08-31T16:56:42Z"}, "message": "port of locator.rs to SessionDiagnostics, fix some of the errors\nrevealed by tests, manually add a panic to test for dead code", "tree": {"sha": "22e92c346091977abcfd068046c7d1ab1b38d4fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22e92c346091977abcfd068046c7d1ab1b38d4fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0ba1fbaa4f73b6edf27346817b1f74fb352945e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ba1fbaa4f73b6edf27346817b1f74fb352945e", "html_url": "https://github.com/rust-lang/rust/commit/d0ba1fbaa4f73b6edf27346817b1f74fb352945e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0ba1fbaa4f73b6edf27346817b1f74fb352945e/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "bd8e312d73f07517e24a58a201e8524ebe4da8da", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd8e312d73f07517e24a58a201e8524ebe4da8da", "html_url": "https://github.com/rust-lang/rust/commit/bd8e312d73f07517e24a58a201e8524ebe4da8da"}], "stats": {"total": 661, "additions": 448, "deletions": 213}, "files": [{"sha": "e3e58cf8bed7ea93c7a60ae8eeae875d9e44f7c8", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d0ba1fbaa4f73b6edf27346817b1f74fb352945e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d0ba1fbaa4f73b6edf27346817b1f74fb352945e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=d0ba1fbaa4f73b6edf27346817b1f74fb352945e", "patch": "@@ -170,3 +170,58 @@ metadata_failed_create_file =\n \n metadata_failed_create_encoded_metadata =\n     failed to create encoded metadata from file: {$err}\n+\n+metadata_non_ascii_name =\n+    cannot load a crate with a non-ascii name `{$crate_name}`\n+\n+metadata_extern_location_not_exist =\n+    extern location for {$crate_name} does not exist: {$location}\n+\n+metadata_extern_location_not_file =\n+    extern location for {$crate_name} is not a file: {$location}\n+\n+metadata_multiple_candidates =\n+    multiple {$flavor} candidates for `{$crate_name}` found\n+\n+metadata_multiple_matching_crates =\n+    multiple matching crates for `{$crate_name}`\n+    .note = candidates:{$candidates}\n+\n+metadata_symbol_conflicts_current =\n+    the current crate is indistinguishable from one of its dependencies: it has the same crate-name `{$crate_name}` and was compiled with the same `-C metadata` arguments. This will result in symbol conflicts between the two.\n+\n+metadata_symbol_conflicts_others =\n+    found two different crates with name `{$crate_name}` that are not distinguished by differing `-C metadata`. This will result in symbol conflicts between the two.\n+\n+metadata_stable_crate_id_collision =\n+    found crates (`{$crate_name0}` and `{$crate_name1}`) with colliding StableCrateId values.\n+\n+metadata_dl_error =\n+    {$err}\n+\n+metadata_newer_crate_version =\n+    found possibly newer version of crate `{$crate_name}`{$add_info}\n+    .note = perhaps that crate needs to be recompiled?\n+\n+metadata_found_crate_versions =\n+    the following crate versions were found:{$found_crates}\n+\n+metadata_no_crate_with_triple =\n+    couldn't find crate `{$crate_name}` with expected target triple {$locator_triple}{$add_info}\n+\n+metadata_found_staticlib =\n+    found staticlib `{$crate_name}` instead of rlib or dylib{$add_info}\n+    .help = please recompile that crate using --crate-type lib\n+\n+metadata_incompatible_rustc =\n+    found crate `{$crate_name}` compiled by an incompatible version of rustc{$add_info}\n+    .help = please recompile that crate using this compiler ({$rustc_version}) (consider running `cargo clean` first)\n+\n+metadata_invalid_meta_files =\n+    found invalid metadata files for crate `{$crate_name}`{$add_info}\n+\n+metadata_cannot_find_crate =\n+    can't find crate for `{$crate_name}`{$add_info}\n+\n+metadata_no_dylib_plugin =\n+    plugin `{$crate_name}` only found in rlib format, but must be available in dylib format"}, {"sha": "d3f35ca8d164fb2a4d85f913517f899c71b3d44a", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 252, "deletions": 5, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/d0ba1fbaa4f73b6edf27346817b1f74fb352945e/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ba1fbaa4f73b6edf27346817b1f74fb352945e/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=d0ba1fbaa4f73b6edf27346817b1f74fb352945e", "patch": "@@ -1,6 +1,10 @@\n-// use rustc_errors::ErrorGuaranteed;\n+use std::path::PathBuf;\n+\n+use rustc_errors::{DiagnosticId, ErrorGuaranteed};\n use rustc_macros::SessionDiagnostic;\n-use rustc_span::Span;\n+use rustc_session::{config, SessionDiagnostic};\n+use rustc_span::{sym, Span, Symbol};\n+use rustc_target::spec::TargetTriple;\n \n #[derive(SessionDiagnostic)]\n #[diag(metadata::rlib_required)]\n@@ -104,8 +108,8 @@ pub struct WasmImportForm {\n #[derive(SessionDiagnostic)]\n #[diag(metadata::empty_link_name, code = \"E0454\")]\n pub struct EmptyLinkName {\n-    #[label]\n     #[primary_span]\n+    #[label]\n     pub span: Span,\n }\n \n@@ -126,8 +130,8 @@ pub struct FrameworkOnlyWindows {\n #[derive(SessionDiagnostic)]\n #[diag(metadata::unknown_link_kind, code = \"E0458\")]\n pub struct UnknownLinkKind {\n-    #[label]\n     #[primary_span]\n+    #[label]\n     pub span: Span,\n     pub kind: String,\n }\n@@ -221,8 +225,8 @@ pub struct IncompatibleWasmLink {\n #[derive(SessionDiagnostic)]\n #[diag(metadata::link_requires_name, code = \"E0459\")]\n pub struct LinkRequiresName {\n-    #[label]\n     #[primary_span]\n+    #[label]\n     pub span: Span,\n }\n \n@@ -378,3 +382,246 @@ pub struct FailedCreateFile {\n pub struct FailedCreateEncodedMetadata {\n     pub err: String,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::non_ascii_name)]\n+pub struct NonAsciiName {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::extern_location_not_exist)]\n+pub struct ExternLocationNotExist {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+    pub location: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::extern_location_not_file)]\n+pub struct ExternLocationNotFile {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+    pub location: String,\n+}\n+\n+pub struct MultipleCandidates {\n+    pub span: Span,\n+    pub flavor: String,\n+    pub crate_name: String,\n+    pub candidates: Vec<PathBuf>,\n+}\n+\n+impl SessionDiagnostic<'_> for MultipleCandidates {\n+    fn into_diagnostic(\n+        self,\n+        sess: &'_ rustc_session::parse::ParseSess,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = sess.struct_err(rustc_errors::fluent::metadata::multiple_candidates);\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"flavor\", self.flavor);\n+        diag.code(DiagnosticId::Error(\"E0465\".into()));\n+        diag.set_span(self.span);\n+        for (i, candidate) in self.candidates.iter().enumerate() {\n+            diag.span_note(self.span, &format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::multiple_matching_crates, code = \"E0464\")]\n+#[note]\n+pub struct MultipleMatchingCrates {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+    pub candidates: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::symbol_conflicts_current, code = \"E0519\")]\n+pub struct SymbolConflictsCurrent {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::symbol_conflicts_others, code = \"E0523\")]\n+pub struct SymbolConflictsOthers {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::stable_crate_id_collision)]\n+pub struct StableCrateIdCollision {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name0: String,\n+    pub crate_name1: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::dl_error)]\n+pub struct DlError {\n+    #[primary_span]\n+    pub span: Span,\n+    pub err: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::newer_crate_version, code = \"E0460\")]\n+#[note]\n+#[note(metadata::found_crate_versions)]\n+pub struct NewerCrateVersion {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+    pub add_info: String,\n+    pub found_crates: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_crate_with_triple, code = \"E0461\")]\n+#[note(metadata::found_crate_versions)]\n+pub struct NoCrateWithTriple {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+    pub locator_triple: String,\n+    pub add_info: String,\n+    pub found_crates: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::found_staticlib, code = \"E0462\")]\n+#[note(metadata::found_crate_versions)]\n+#[help]\n+pub struct FoundStaticlib {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+    pub add_info: String,\n+    pub found_crates: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::incompatible_rustc, code = \"E0514\")]\n+#[note(metadata::found_crate_versions)]\n+#[help]\n+pub struct IncompatibleRustc {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+    pub add_info: String,\n+    pub found_crates: String,\n+    pub rustc_version: String,\n+}\n+\n+pub struct InvalidMetadataFiles {\n+    pub span: Span,\n+    pub crate_name: String,\n+    pub add_info: String,\n+    pub crate_rejections: Vec<String>,\n+}\n+\n+impl SessionDiagnostic<'_> for InvalidMetadataFiles {\n+    fn into_diagnostic(\n+        self,\n+        sess: &'_ rustc_session::parse::ParseSess,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = sess.struct_err(rustc_errors::fluent::metadata::invalid_meta_files);\n+        diag.set_arg(\"crate_name\", self.crate_name);\n+        diag.set_arg(\"add_info\", self.add_info);\n+        diag.code(DiagnosticId::Error(\"E0786\".into()));\n+        diag.set_span(self.span);\n+        for crate_rejection in self.crate_rejections {\n+            diag.note(crate_rejection);\n+        }\n+        diag\n+    }\n+}\n+\n+pub struct CannotFindCrate {\n+    pub span: Span,\n+    pub crate_name: String,\n+    pub crate_name_symbol: Symbol,\n+    pub add_info: String,\n+    pub missing_core: bool,\n+    pub current_crate: String,\n+    pub is_nightly_build: bool,\n+    pub profiler_runtime: Symbol,\n+    pub locator_triple: TargetTriple,\n+}\n+\n+impl SessionDiagnostic<'_> for CannotFindCrate {\n+    fn into_diagnostic(\n+        self,\n+        sess: &'_ rustc_session::parse::ParseSess,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = sess.struct_err(rustc_errors::fluent::metadata::cannot_find_crate);\n+        diag.set_arg(\"crate_name\", self.crate_name.clone());\n+        diag.set_arg(\"add_info\", self.add_info);\n+        diag.code(DiagnosticId::Error(\"E0463\".into()));\n+        diag.set_span(self.span);\n+        // FIXME: Find a way to distill this logic down into the derived SessionDiagnostic form\n+        if (self.crate_name_symbol == sym::std || self.crate_name_symbol == sym::core)\n+            && self.locator_triple != TargetTriple::from_triple(config::host_triple())\n+        {\n+            if self.missing_core {\n+                diag.note(&format!(\"the `{}` target may not be installed\", self.locator_triple));\n+            } else {\n+                diag.note(&format!(\n+                    \"the `{}` target may not support the standard library\",\n+                    self.locator_triple\n+                ));\n+            }\n+            // NOTE: this suggests using rustup, even though the user may not have it installed.\n+            // That's because they could choose to install it; or this may give them a hint which\n+            // target they need to install from their distro.\n+            if self.missing_core {\n+                diag.help(&format!(\n+                    \"consider downloading the target with `rustup target add {}`\",\n+                    self.locator_triple\n+                ));\n+            }\n+            // Suggest using #![no_std]. #[no_core] is unstable and not really supported anyway.\n+            // NOTE: this is a dummy span if `extern crate std` was injected by the compiler.\n+            // If it's not a dummy, that means someone added `extern crate std` explicitly and\n+            // `#![no_std]` won't help.\n+            if !self.missing_core && self.span.is_dummy() {\n+                diag.note(&format!(\n+                    \"`std` is required by `{}` because it does not declare `#![no_std]`\",\n+                    self.current_crate\n+                ));\n+            }\n+            if self.is_nightly_build {\n+                diag.help(\"consider building the standard library from source with `cargo build -Zbuild-std`\");\n+            }\n+        } else if self.crate_name_symbol == self.profiler_runtime {\n+            diag.note(\"the compiler may have been built without the profiler runtime\");\n+        } else if self.crate_name.starts_with(\"rustc_\") {\n+            diag.help(\n+                \"maybe you need to install the missing components with: \\\n+                             `rustup component add rust-src rustc-dev llvm-tools-preview`\",\n+            );\n+        }\n+        diag.span_label(self.span, \"can't find crate\");\n+        diag\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(metadata::no_dylib_plugin, code = \"E0457\")]\n+pub struct NoDylibPlugin {\n+    #[primary_span]\n+    pub span: Span,\n+    pub crate_name: String,\n+}"}, {"sha": "83c8756078ec41139b04c2d2909646a225ab2423", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 141, "deletions": 207, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/d0ba1fbaa4f73b6edf27346817b1f74fb352945e/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ba1fbaa4f73b6edf27346817b1f74fb352945e/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=d0ba1fbaa4f73b6edf27346817b1f74fb352945e", "patch": "@@ -213,21 +213,27 @@\n //! metadata::locator or metadata::creader for all the juicy details!\n \n use crate::creader::Library;\n+use crate::errors::{\n+    CannotFindCrate, DlError, ExternLocationNotExist, ExternLocationNotFile, FoundStaticlib,\n+    IncompatibleRustc, InvalidMetadataFiles, MultipleCandidates, MultipleMatchingCrates,\n+    NewerCrateVersion, NoCrateWithTriple, NoDylibPlugin, NonAsciiName, StableCrateIdCollision,\n+    SymbolConflictsCurrent, SymbolConflictsOthers,\n+};\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n-use rustc_errors::{struct_span_err, FatalError};\n+use rustc_errors::FatalError;\n use rustc_session::config::{self, CrateType};\n use rustc_session::cstore::{CrateSource, MetadataLoader};\n use rustc_session::filesearch::FileSearch;\n use rustc_session::search_paths::PathKind;\n use rustc_session::utils::CanonicalizedPath;\n use rustc_session::Session;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n use rustc_target::spec::{Target, TargetTriple};\n \n@@ -938,41 +944,33 @@ impl fmt::Display for MetadataError<'_> {\n \n impl CrateError {\n     pub(crate) fn report(self, sess: &Session, span: Span, missing_core: bool) {\n-        let mut diag = match self {\n-            CrateError::NonAsciiName(crate_name) => sess.struct_span_err(\n-                span,\n-                &format!(\"cannot load a crate with a non-ascii name `{}`\", crate_name),\n-            ),\n-            CrateError::ExternLocationNotExist(crate_name, loc) => sess.struct_span_err(\n-                span,\n-                &format!(\"extern location for {} does not exist: {}\", crate_name, loc.display()),\n-            ),\n-            CrateError::ExternLocationNotFile(crate_name, loc) => sess.struct_span_err(\n-                span,\n-                &format!(\"extern location for {} is not a file: {}\", crate_name, loc.display()),\n-            ),\n+        match self {\n+            CrateError::NonAsciiName(crate_name) => {\n+                sess.emit_err(NonAsciiName { span, crate_name: crate_name.to_string() });\n+            }\n+            CrateError::ExternLocationNotExist(crate_name, loc) => {\n+                sess.emit_err(ExternLocationNotExist {\n+                    span,\n+                    crate_name: crate_name.to_string(),\n+                    location: loc.display().to_string(),\n+                });\n+            }\n+            CrateError::ExternLocationNotFile(crate_name, loc) => {\n+                sess.emit_err(ExternLocationNotFile {\n+                    span,\n+                    crate_name: crate_name.to_string(),\n+                    location: loc.display().to_string(),\n+                });\n+            }\n             CrateError::MultipleCandidates(crate_name, flavor, candidates) => {\n-                let mut err = struct_span_err!(\n-                    sess,\n+                sess.emit_err(MultipleCandidates {\n                     span,\n-                    E0465,\n-                    \"multiple {} candidates for `{}` found\",\n-                    flavor,\n-                    crate_name,\n-                );\n-                for (i, candidate) in candidates.iter().enumerate() {\n-                    err.span_note(span, &format!(\"candidate #{}: {}\", i + 1, candidate.display()));\n-                }\n-                err\n+                    flavor: flavor.to_string(),\n+                    crate_name: crate_name.to_string(),\n+                    candidates,\n+                });\n             }\n             CrateError::MultipleMatchingCrates(crate_name, libraries) => {\n-                let mut err = struct_span_err!(\n-                    sess,\n-                    span,\n-                    E0464,\n-                    \"multiple matching crates for `{}`\",\n-                    crate_name\n-                );\n                 let mut libraries: Vec<_> = libraries.into_values().collect();\n                 // Make ordering of candidates deterministic.\n                 // This has to `clone()` to work around lifetime restrictions with `sort_by_key()`.\n@@ -1000,223 +998,159 @@ impl CrateError {\n                         s\n                     })\n                     .collect::<String>();\n-                err.note(&format!(\"candidates:{}\", candidates));\n-                err\n+                sess.emit_err(MultipleMatchingCrates {\n+                    span,\n+                    crate_name: crate_name.to_string(),\n+                    candidates,\n+                });\n+            }\n+            CrateError::SymbolConflictsCurrent(root_name) => {\n+                sess.emit_err(SymbolConflictsCurrent { span, crate_name: root_name.to_string() });\n+            }\n+            CrateError::SymbolConflictsOthers(root_name) => {\n+                sess.emit_err(SymbolConflictsOthers { span, crate_name: root_name.to_string() });\n             }\n-            CrateError::SymbolConflictsCurrent(root_name) => struct_span_err!(\n-                sess,\n-                span,\n-                E0519,\n-                \"the current crate is indistinguishable from one of its dependencies: it has the \\\n-                 same crate-name `{}` and was compiled with the same `-C metadata` arguments. \\\n-                 This will result in symbol conflicts between the two.\",\n-                root_name,\n-            ),\n-            CrateError::SymbolConflictsOthers(root_name) => struct_span_err!(\n-                sess,\n-                span,\n-                E0523,\n-                \"found two different crates with name `{}` that are not distinguished by differing \\\n-                 `-C metadata`. This will result in symbol conflicts between the two.\",\n-                root_name,\n-            ),\n             CrateError::StableCrateIdCollision(crate_name0, crate_name1) => {\n-                let msg = format!(\n-                    \"found crates (`{}` and `{}`) with colliding StableCrateId values.\",\n-                    crate_name0, crate_name1\n-                );\n-                sess.struct_span_err(span, &msg)\n+                sess.emit_err(StableCrateIdCollision {\n+                    span,\n+                    crate_name0: crate_name0.to_string(),\n+                    crate_name1: crate_name1.to_string(),\n+                });\n+            }\n+            CrateError::DlOpen(s) | CrateError::DlSym(s) => {\n+                sess.emit_err(DlError { span, err: s.to_string() });\n             }\n-            CrateError::DlOpen(s) | CrateError::DlSym(s) => sess.struct_span_err(span, &s),\n             CrateError::LocatorCombined(locator) => {\n                 let crate_name = locator.crate_name;\n-                let add = match &locator.root {\n+                let add_info = match &locator.root {\n                     None => String::new(),\n                     Some(r) => format!(\" which `{}` depends on\", r.name),\n                 };\n-                let mut msg = \"the following crate versions were found:\".to_string();\n-                let mut err = if !locator.crate_rejections.via_hash.is_empty() {\n-                    let mut err = struct_span_err!(\n-                        sess,\n-                        span,\n-                        E0460,\n-                        \"found possibly newer version of crate `{}`{}\",\n-                        crate_name,\n-                        add,\n-                    );\n-                    err.note(\"perhaps that crate needs to be recompiled?\");\n+                // FIXME: Is there any way to get these notes and helps onto every diagnostic in this\n+                // huge branch arm without changing them all to manual implementations?\n+                let mut global_loc_notes = Vec::new();\n+                let mut global_loc_helps = Vec::new();\n+                if !locator.crate_rejections.via_filename.is_empty() {\n+                    let mismatches = locator.crate_rejections.via_filename.iter();\n+                    for CrateMismatch { path, .. } in mismatches {\n+                        global_loc_notes.push(format!(\n+                            \"extern location for {} is of an unknown type: {}\",\n+                            crate_name,\n+                            path.display(),\n+                        ));\n+                        global_loc_helps.push(format!(\n+                            \"file name should be lib*.rlib or {}*.{}\",\n+                            locator.dll_prefix, locator.dll_suffix\n+                        ));\n+                    }\n+                    panic!(\"!!!!! REVERT THIS COMMIT !!!!!\");\n+                }\n+                let mut found_crates = String::new();\n+                if !locator.crate_rejections.via_hash.is_empty() {\n                     let mismatches = locator.crate_rejections.via_hash.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n-                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n+                        found_crates.push_str(&format!(\n+                            \"\\ncrate `{}`: {}\",\n+                            crate_name,\n+                            path.display()\n+                        ));\n                     }\n                     if let Some(r) = locator.root {\n                         for path in r.source.paths() {\n-                            msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.name, path.display()));\n+                            found_crates.push_str(&format!(\n+                                \"\\ncrate `{}`: {}\",\n+                                r.name,\n+                                path.display()\n+                            ));\n                         }\n                     }\n-                    err.note(&msg);\n-                    err\n-                } else if !locator.crate_rejections.via_triple.is_empty() {\n-                    let mut err = struct_span_err!(\n-                        sess,\n+                    sess.emit_err(NewerCrateVersion {\n                         span,\n-                        E0461,\n-                        \"couldn't find crate `{}` with expected target triple {}{}\",\n-                        crate_name,\n-                        locator.triple,\n-                        add,\n-                    );\n+                        crate_name: crate_name.to_string(),\n+                        add_info,\n+                        found_crates,\n+                    });\n+                } else if !locator.crate_rejections.via_triple.is_empty() {\n                     let mismatches = locator.crate_rejections.via_triple.iter();\n                     for CrateMismatch { path, got } in mismatches {\n-                        msg.push_str(&format!(\n+                        found_crates.push_str(&format!(\n                             \"\\ncrate `{}`, target triple {}: {}\",\n                             crate_name,\n                             got,\n                             path.display(),\n                         ));\n                     }\n-                    err.note(&msg);\n-                    err\n-                } else if !locator.crate_rejections.via_kind.is_empty() {\n-                    let mut err = struct_span_err!(\n-                        sess,\n+                    sess.emit_err(NoCrateWithTriple {\n                         span,\n-                        E0462,\n-                        \"found staticlib `{}` instead of rlib or dylib{}\",\n-                        crate_name,\n-                        add,\n-                    );\n-                    err.help(\"please recompile that crate using --crate-type lib\");\n+                        crate_name: crate_name.to_string(),\n+                        locator_triple: locator.triple.to_string(),\n+                        add_info,\n+                        found_crates,\n+                    });\n+                } else if !locator.crate_rejections.via_kind.is_empty() {\n                     let mismatches = locator.crate_rejections.via_kind.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n-                        msg.push_str(&format!(\"\\ncrate `{}`: {}\", crate_name, path.display()));\n+                        found_crates.push_str(&format!(\n+                            \"\\ncrate `{}`: {}\",\n+                            crate_name,\n+                            path.display()\n+                        ));\n                     }\n-                    err.note(&msg);\n-                    err\n-                } else if !locator.crate_rejections.via_version.is_empty() {\n-                    let mut err = struct_span_err!(\n-                        sess,\n+                    sess.emit_err(FoundStaticlib {\n                         span,\n-                        E0514,\n-                        \"found crate `{}` compiled by an incompatible version of rustc{}\",\n-                        crate_name,\n-                        add,\n-                    );\n-                    err.help(&format!(\n-                        \"please recompile that crate using this compiler ({}) \\\n-                         (consider running `cargo clean` first)\",\n-                        rustc_version(),\n-                    ));\n+                        crate_name: crate_name.to_string(),\n+                        add_info,\n+                        found_crates,\n+                    });\n+                } else if !locator.crate_rejections.via_version.is_empty() {\n                     let mismatches = locator.crate_rejections.via_version.iter();\n                     for CrateMismatch { path, got } in mismatches {\n-                        msg.push_str(&format!(\n+                        found_crates.push_str(&format!(\n                             \"\\ncrate `{}` compiled by {}: {}\",\n                             crate_name,\n                             got,\n                             path.display(),\n                         ));\n                     }\n-                    err.note(&msg);\n-                    err\n-                } else if !locator.crate_rejections.via_invalid.is_empty() {\n-                    let mut err = struct_span_err!(\n-                        sess,\n+                    sess.emit_err(IncompatibleRustc {\n                         span,\n-                        E0786,\n-                        \"found invalid metadata files for crate `{}`{}\",\n-                        crate_name,\n-                        add,\n-                    );\n+                        crate_name: crate_name.to_string(),\n+                        add_info,\n+                        found_crates,\n+                        rustc_version: rustc_version(),\n+                    });\n+                } else if !locator.crate_rejections.via_invalid.is_empty() {\n+                    let mut crate_rejections = Vec::new();\n                     for CrateMismatch { path: _, got } in locator.crate_rejections.via_invalid {\n-                        err.note(&got);\n+                        crate_rejections.push(got);\n                     }\n-                    err\n+                    sess.emit_err(InvalidMetadataFiles {\n+                        span,\n+                        crate_name: crate_name.to_string(),\n+                        add_info,\n+                        crate_rejections,\n+                    });\n                 } else {\n-                    let mut err = struct_span_err!(\n-                        sess,\n+                    sess.emit_err(CannotFindCrate {\n                         span,\n-                        E0463,\n-                        \"can't find crate for `{}`{}\",\n-                        crate_name,\n-                        add,\n-                    );\n-\n-                    if (crate_name == sym::std || crate_name == sym::core)\n-                        && locator.triple != TargetTriple::from_triple(config::host_triple())\n-                    {\n-                        if missing_core {\n-                            err.note(&format!(\n-                                \"the `{}` target may not be installed\",\n-                                locator.triple\n-                            ));\n-                        } else {\n-                            err.note(&format!(\n-                                \"the `{}` target may not support the standard library\",\n-                                locator.triple\n-                            ));\n-                        }\n-                        // NOTE: this suggests using rustup, even though the user may not have it installed.\n-                        // That's because they could choose to install it; or this may give them a hint which\n-                        // target they need to install from their distro.\n-                        if missing_core {\n-                            err.help(&format!(\n-                                \"consider downloading the target with `rustup target add {}`\",\n-                                locator.triple\n-                            ));\n-                        }\n-                        // Suggest using #![no_std]. #[no_core] is unstable and not really supported anyway.\n-                        // NOTE: this is a dummy span if `extern crate std` was injected by the compiler.\n-                        // If it's not a dummy, that means someone added `extern crate std` explicitly and `#![no_std]` won't help.\n-                        if !missing_core && span.is_dummy() {\n-                            let current_crate =\n-                                sess.opts.crate_name.as_deref().unwrap_or(\"<unknown>\");\n-                            err.note(&format!(\n-                                \"`std` is required by `{}` because it does not declare `#![no_std]`\",\n-                                current_crate\n-                            ));\n-                        }\n-                        if sess.is_nightly_build() {\n-                            err.help(\"consider building the standard library from source with `cargo build -Zbuild-std`\");\n-                        }\n-                    } else if crate_name\n-                        == Symbol::intern(&sess.opts.unstable_opts.profiler_runtime)\n-                    {\n-                        err.note(\"the compiler may have been built without the profiler runtime\");\n-                    } else if crate_name.as_str().starts_with(\"rustc_\") {\n-                        err.help(\n-                            \"maybe you need to install the missing components with: \\\n-                             `rustup component add rust-src rustc-dev llvm-tools-preview`\",\n-                        );\n-                    }\n-                    err.span_label(span, \"can't find crate\");\n-                    err\n-                };\n-\n-                if !locator.crate_rejections.via_filename.is_empty() {\n-                    let mismatches = locator.crate_rejections.via_filename.iter();\n-                    for CrateMismatch { path, .. } in mismatches {\n-                        err.note(&format!(\n-                            \"extern location for {} is of an unknown type: {}\",\n-                            crate_name,\n-                            path.display(),\n-                        ))\n-                        .help(&format!(\n-                            \"file name should be lib*.rlib or {}*.{}\",\n-                            locator.dll_prefix, locator.dll_suffix\n-                        ));\n-                    }\n+                        crate_name: crate_name.to_string(),\n+                        crate_name_symbol: crate_name,\n+                        add_info,\n+                        missing_core,\n+                        current_crate: sess\n+                            .opts\n+                            .crate_name\n+                            .clone()\n+                            .unwrap_or(\"<unknown>\".to_string()),\n+                        is_nightly_build: sess.is_nightly_build(),\n+                        profiler_runtime: Symbol::intern(&sess.opts.unstable_opts.profiler_runtime),\n+                        locator_triple: locator.triple,\n+                    });\n                 }\n-                err\n             }\n-            CrateError::NonDylibPlugin(crate_name) => struct_span_err!(\n-                sess,\n-                span,\n-                E0457,\n-                \"plugin `{}` only found in rlib format, but must be available in dylib format\",\n-                crate_name,\n-            ),\n-        };\n-\n-        diag.emit();\n+            CrateError::NonDylibPlugin(crate_name) => {\n+                sess.emit_err(NoDylibPlugin { span, crate_name: crate_name.to_string() });\n+            }\n+        }\n     }\n }"}, {"sha": "dbaa2e9defa1af625b19333f0143f9593355a3ae", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0ba1fbaa4f73b6edf27346817b1f74fb352945e/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ba1fbaa4f73b6edf27346817b1f74fb352945e/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=d0ba1fbaa4f73b6edf27346817b1f74fb352945e", "patch": "@@ -1,7 +1,6 @@\n use rustc_ast::{NestedMetaItem, CRATE_NODE_ID};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_middle::ty::{List, ParamEnv, ParamEnvAnd, Ty, TyCtxt};"}]}