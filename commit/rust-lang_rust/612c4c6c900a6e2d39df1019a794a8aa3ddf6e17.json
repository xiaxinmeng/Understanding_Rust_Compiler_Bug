{"sha": "612c4c6c900a6e2d39df1019a794a8aa3ddf6e17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMmM0YzZjOTAwYTZlMmQzOWRmMTAxOWE3OTRhOGFhM2RkZjZlMTc=", "commit": {"author": {"name": "Adam Perry", "email": "adam.n.perry@gmail.com", "date": "2019-12-24T03:25:09Z"}, "committer": {"name": "Adam Perry", "email": "adam.n.perry@gmail.com", "date": "2020-01-04T18:02:17Z"}, "message": "Update ABI in const impls of panic_fn/begin_panic_fn.", "tree": {"sha": "654262669e2c99acec282bed49d98d36faa34078", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/654262669e2c99acec282bed49d98d36faa34078"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17", "html_url": "https://github.com/rust-lang/rust/commit/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/comments", "author": {"login": "anp", "id": 6812281, "node_id": "MDQ6VXNlcjY4MTIyODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6812281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anp", "html_url": "https://github.com/anp", "followers_url": "https://api.github.com/users/anp/followers", "following_url": "https://api.github.com/users/anp/following{/other_user}", "gists_url": "https://api.github.com/users/anp/gists{/gist_id}", "starred_url": "https://api.github.com/users/anp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anp/subscriptions", "organizations_url": "https://api.github.com/users/anp/orgs", "repos_url": "https://api.github.com/users/anp/repos", "events_url": "https://api.github.com/users/anp/events{/privacy}", "received_events_url": "https://api.github.com/users/anp/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anp", "id": 6812281, "node_id": "MDQ6VXNlcjY4MTIyODE=", "avatar_url": "https://avatars.githubusercontent.com/u/6812281?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anp", "html_url": "https://github.com/anp", "followers_url": "https://api.github.com/users/anp/followers", "following_url": "https://api.github.com/users/anp/following{/other_user}", "gists_url": "https://api.github.com/users/anp/gists{/gist_id}", "starred_url": "https://api.github.com/users/anp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anp/subscriptions", "organizations_url": "https://api.github.com/users/anp/orgs", "repos_url": "https://api.github.com/users/anp/repos", "events_url": "https://api.github.com/users/anp/events{/privacy}", "received_events_url": "https://api.github.com/users/anp/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e218da425160d4babaa46d7da1720a11ac6c02fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e218da425160d4babaa46d7da1720a11ac6c02fa", "html_url": "https://github.com/rust-lang/rust/commit/e218da425160d4babaa46d7da1720a11ac6c02fa"}], "stats": {"total": 61, "additions": 22, "deletions": 39}, "files": [{"sha": "aa9c718c3eb682425d0515dc92430f5e4b4c6c12", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=612c4c6c900a6e2d39df1019a794a8aa3ddf6e17", "patch": "@@ -177,6 +177,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n@@ -199,7 +200,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 // Some functions we support even if they are non-const -- but avoid testing\n                 // that for const fn!  We certainly do *not* want to actually call the fn\n                 // though, so be sure we return here.\n-                return if ecx.hook_panic_fn(instance, args, ret)? {\n+                return if ecx.hook_panic_fn(span, instance, args)? {\n                     Ok(None)\n                 } else {\n                     throw_unsup_format!(\"calling non-const function `{}`\", instance)"}, {"sha": "b075e8ea383e1511889d1dba3c85d22f89b70901", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=612c4c6c900a6e2d39df1019a794a8aa3ddf6e17", "patch": "@@ -366,47 +366,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if an intercept happened.\n     pub fn hook_panic_fn(\n         &mut self,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        _ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let def_id = instance.def_id();\n-        if Some(def_id) == self.tcx.lang_items().panic_fn() {\n-            // &'static str, &core::panic::Location { &'static str, u32, u32 }\n-            assert!(args.len() == 2);\n+        if Some(def_id) == self.tcx.lang_items().panic_fn()\n+            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+        {\n+            // &'static str\n+            assert!(args.len() == 1);\n \n             let msg_place = self.deref_operand(args[0])?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n-\n-            let location = self.deref_operand(args[1])?;\n-            let (file, line, col) = (\n-                self.mplace_field(location, 0)?,\n-                self.mplace_field(location, 1)?,\n-                self.mplace_field(location, 2)?,\n-            );\n-\n-            let file_place = self.deref_operand(file.into())?;\n-            let file = Symbol::intern(self.read_str(file_place)?);\n-            let line = self.read_scalar(line.into())?.to_u32()?;\n-            let col = self.read_scalar(col.into())?.to_u32()?;\n-            throw_panic!(Panic { msg, file, line, col })\n-        } else if Some(def_id) == self.tcx.lang_items().begin_panic_fn() {\n-            assert!(args.len() == 2);\n-            // &'static str, &core::panic::Location { &'static str, u32, u32 }\n-            let msg = args[0];\n-            let place = self.deref_operand(args[1])?;\n-            let (file, line, col) = (\n-                self.mplace_field(place, 0)?,\n-                self.mplace_field(place, 1)?,\n-                self.mplace_field(place, 2)?,\n-            );\n-\n-            let msg_place = self.deref_operand(msg.into())?;\n-            let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let file_place = self.deref_operand(file.into())?;\n-            let file = Symbol::intern(self.read_str(file_place)?);\n-            let line = self.read_scalar(line.into())?.to_u32()?;\n-            let col = self.read_scalar(col.into())?.to_u32()?;\n+            let span = self.find_closest_untracked_caller_location().unwrap_or(span);\n+            let (file, line, col) = self.location_triple_for_span(span);\n             throw_panic!(Panic { msg, file, line, col })\n         } else {\n             return Ok(false);"}, {"sha": "0b07cb2f654200b0a1d6513a3545f62121d5dbcc", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=612c4c6c900a6e2d39df1019a794a8aa3ddf6e17", "patch": "@@ -9,8 +9,9 @@ use crate::interpret::{\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// Walks up the callstack from the intrinsic's callsite, searching for the first frame which is\n-    /// not `#[track_caller]`.\n+    /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n+    /// frame which is not `#[track_caller]`. If the first frame found lacks `#[track_caller]`, then\n+    /// `None` is returned and the callsite of the function invocation itself should be used.\n     crate fn find_closest_untracked_caller_location(&self) -> Option<Span> {\n         let mut caller_span = None;\n         for next_caller in self.stack.iter().rev() {\n@@ -54,9 +55,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     pub fn alloc_caller_location_for_span(&mut self, span: Span) -> MPlaceTy<'tcx, M::PointerTag> {\n+        let (file, line, column) = self.location_triple_for_span(span);\n+        self.alloc_caller_location(file, line, column)\n+    }\n+\n+    pub fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n-        self.alloc_caller_location(\n+        (\n             Symbol::intern(&caller.file.name.to_string()),\n             caller.line as u32,\n             caller.col_display as u32 + 1,"}, {"sha": "3dc572d256d8ed661b2de81c08274e566914528d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=612c4c6c900a6e2d39df1019a794a8aa3ddf6e17", "patch": "@@ -139,6 +139,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// was used.\n     fn find_mir_or_eval_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,"}, {"sha": "7b0efd21778829f9e967e062a80da16f53a919f2", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=612c4c6c900a6e2d39df1019a794a8aa3ddf6e17", "patch": "@@ -238,7 +238,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::CloneShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n-                let body = match M::find_mir_or_eval_fn(self, instance, args, ret, unwind)? {\n+                let body = match M::find_mir_or_eval_fn(self, span, instance, args, ret, unwind)? {\n                     Some(body) => body,\n                     None => return Ok(()),\n                 };"}, {"sha": "4580ae631c2f424de8522ecc36aa83fffc0d0b8c", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/612c4c6c900a6e2d39df1019a794a8aa3ddf6e17/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=612c4c6c900a6e2d39df1019a794a8aa3ddf6e17", "patch": "@@ -125,6 +125,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n \n     fn find_mir_or_eval_fn(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _span: Span,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n         _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,"}]}