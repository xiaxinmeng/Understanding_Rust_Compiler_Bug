{"sha": "d861982ca6a1fa5773373362771aa08b9f732de0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NjE5ODJjYTZhMWZhNTc3MzM3MzM2Mjc3MWFhMDhiOWY3MzJkZTA=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2016-12-26T13:34:03Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-07-28T13:46:23Z"}, "message": "Generator literal support", "tree": {"sha": "06d990dc877d7a629a152185b1c039edb073c4ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06d990dc877d7a629a152185b1c039edb073c4ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d861982ca6a1fa5773373362771aa08b9f732de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d861982ca6a1fa5773373362771aa08b9f732de0", "html_url": "https://github.com/rust-lang/rust/commit/d861982ca6a1fa5773373362771aa08b9f732de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d861982ca6a1fa5773373362771aa08b9f732de0/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f815ca771b59fe652a5f88f198810b5dc37a4c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f815ca771b59fe652a5f88f198810b5dc37a4c9", "html_url": "https://github.com/rust-lang/rust/commit/6f815ca771b59fe652a5f88f198810b5dc37a4c9"}], "stats": {"total": 3499, "additions": 3239, "deletions": 260}, "files": [{"sha": "92330ad6333a2b459f3b7f51b210a87df3b98f05", "filename": "src/libcore/ops/generator.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The result of a generator resumption.\n+#[derive(Debug)]\n+#[cfg(not(stage0))]\n+#[lang = \"generator_state\"]\n+#[unstable(feature = \"generator_trait\", issue = \"0\")]\n+pub enum State<Y, R> {\n+    /// The generator suspended with a value.\n+    Yielded(Y),\n+\n+    /// The generator completed with a return value.\n+    Complete(R),\n+}\n+\n+/// The trait implemented by builtin generator types.\n+#[cfg(not(stage0))]\n+#[lang = \"generator\"]\n+#[unstable(feature = \"generator_trait\", issue = \"0\")]\n+#[fundamental]\n+pub trait Generator<Arg = ()> {\n+    /// The type of value this generator yields.\n+    type Yield;\n+\n+    /// The type of value this generator returns.\n+    type Return;\n+\n+    /// This resumes the execution of the generator. \n+    fn resume(&mut self, arg: Arg) -> State<Self::Yield, Self::Return>;\n+}"}, {"sha": "36b0a3c8a3472da6306c0293cd8ba2d603c4b343", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -152,6 +152,7 @@ mod bit;\n mod deref;\n mod drop;\n mod function;\n+mod generator;\n mod index;\n mod place;\n mod range;\n@@ -189,6 +190,13 @@ pub use self::range::{RangeInclusive, RangeToInclusive};\n #[unstable(feature = \"try_trait\", issue = \"42327\")]\n pub use self::try::Try;\n \n+#[unstable(feature = \"generator_trait\", issue = \"0\")]\n+#[cfg(not(stage0))]\n+pub use self::generator::State;\n+#[unstable(feature = \"generator_trait\", issue = \"0\")]\n+#[cfg(not(stage0))]\n+pub use self::generator::Generator;\n+\n #[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n pub use self::place::{Place, Placer, InPlace, Boxed, BoxPlace};\n "}, {"sha": "36aeaba0c5ec6499e0fb5a6f97273784b3da6d7c", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -389,6 +389,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprUnary(_, ref e) |\n             hir::ExprField(ref e, _) |\n             hir::ExprTupField(ref e, _) |\n+            hir::ExprSuspend(ref e) |\n             hir::ExprRepeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }\n@@ -401,6 +402,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             hir::ExprClosure(..) |\n             hir::ExprLit(..) |\n+            hir::ExprImplArg(_) |\n             hir::ExprPath(_) => {\n                 self.straightline(expr, pred, None::<hir::Expr>.iter())\n             }"}, {"sha": "47a0f67a640746f68e9b84676a675ebbae17f21c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -399,6 +399,9 @@ pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n         visitor.visit_id(argument.id);\n         visitor.visit_pat(&argument.pat);\n     }\n+    if let Some(ref impl_arg) = body.impl_arg {\n+        visitor.visit_id(impl_arg.id);\n+    }\n     visitor.visit_expr(&body.value);\n }\n \n@@ -978,7 +981,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprClosure(_, ref function_declaration, body, _fn_decl_span) => {\n+        ExprClosure(_, ref function_declaration, body, _fn_decl_span, _gen) => {\n             visitor.visit_fn(FnKind::Closure(&expression.attrs),\n                              function_declaration,\n                              body,\n@@ -1042,6 +1045,12 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 visitor.visit_expr(input)\n             }\n         }\n+        ExprSuspend(ref subexpression) => {\n+            visitor.visit_expr(subexpression);\n+        }\n+        ExprImplArg(id) => {\n+            visitor.visit_id(id);\n+        },\n     }\n }\n "}, {"sha": "410f5e8d5ef40e6fc0dc1dfd7aaa709e63ccf382", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 70, "deletions": 28, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -92,6 +92,8 @@ pub struct LoweringContext<'a> {\n     trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n     trait_default_impl: BTreeMap<DefId, NodeId>,\n \n+    impl_arg: Option<NodeId>,\n+\n     catch_scopes: Vec<NodeId>,\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n@@ -137,6 +139,7 @@ pub fn lower_crate(sess: &Session,\n         trait_impls: BTreeMap::new(),\n         trait_default_impl: BTreeMap::new(),\n         exported_macros: Vec::new(),\n+        impl_arg: None,\n         catch_scopes: Vec::new(),\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n@@ -362,12 +365,24 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n+    fn impl_arg_id(&mut self) -> NodeId {\n+        if self.impl_arg.is_none() {\n+            self.impl_arg = Some(self.next_id());\n+        }\n+        self.impl_arg.unwrap()\n+    }\n+\n     fn record_body(&mut self, value: hir::Expr, decl: Option<&FnDecl>)\n                    -> hir::BodyId {\n+        let span = value.span;\n         let body = hir::Body {\n             arguments: decl.map_or(hir_vec![], |decl| {\n                 decl.inputs.iter().map(|x| self.lower_arg(x)).collect()\n             }),\n+            impl_arg: self.impl_arg.map(|id| hir::ImplArg {\n+                id,\n+                span,\n+            }),\n             value,\n         };\n         let id = body.id();\n@@ -425,6 +440,17 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n+    fn lower_body<F>(&mut self, decl: Option<&FnDecl>, f: F) -> hir::BodyId\n+        where F: FnOnce(&mut LoweringContext) -> hir::Expr\n+    {\n+        let old_impl_arg = self.impl_arg;\n+        self.impl_arg = None;\n+        let result = f(self);\n+        let r = self.record_body(result, decl);\n+        self.impl_arg = old_impl_arg;\n+        r\n+    }\n+\n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -609,13 +635,12 @@ impl<'a> LoweringContext<'a> {\n                 })))\n             }\n             TyKind::Array(ref ty, ref length) => {\n-                let length = self.lower_expr(length);\n-                hir::TyArray(self.lower_ty(ty),\n-                             self.record_body(length, None))\n+                let body = self.lower_body(None, |this| this.lower_expr(length));\n+                hir::TyArray(self.lower_ty(ty), body)\n             }\n             TyKind::Typeof(ref expr) => {\n-                let expr = self.lower_expr(expr);\n-                hir::TyTypeof(self.record_body(expr, None))\n+                let body = self.lower_body(None, |this| this.lower_expr(expr));\n+                hir::TyTypeof(body)\n             }\n             TyKind::TraitObject(ref bounds) => {\n                 let mut lifetime_bound = None;\n@@ -672,8 +697,7 @@ impl<'a> LoweringContext<'a> {\n                 attrs: self.lower_attrs(&v.node.attrs),\n                 data: self.lower_variant_data(&v.node.data),\n                 disr_expr: v.node.disr_expr.as_ref().map(|e| {\n-                    let e = self.lower_expr(e);\n-                    self.record_body(e, None)\n+                    self.lower_body(None, |this| this.lower_expr(e))\n                 }),\n             },\n             span: v.span,\n@@ -1287,21 +1311,21 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemUse(path, kind)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n-                let value = self.lower_expr(e);\n+                let body = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemStatic(self.lower_ty(t),\n                                 self.lower_mutability(m),\n-                                self.record_body(value, None))\n+                                body)\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                let value = self.lower_expr(e);\n-                hir::ItemConst(self.lower_ty(t),\n-                               self.record_body(value, None))\n+                let body = self.lower_body(None, |this| this.lower_expr(e));\n+                hir::ItemConst(self.lower_ty(t), body)\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 self.with_new_scopes(|this| {\n-                    let body = this.lower_block(body, false);\n-                    let body = this.expr_block(body, ThinVec::new());\n-                    let body_id = this.record_body(body, Some(decl));\n+                    let body_id = this.lower_body(Some(decl), |this| {\n+                        let body = this.lower_block(body, false);\n+                        this.expr_block(body, ThinVec::new())\n+                    });\n                     hir::ItemFn(this.lower_fn_decl(decl),\n                                               this.lower_unsafety(unsafety),\n                                               this.lower_constness(constness),\n@@ -1394,8 +1418,7 @@ impl<'a> LoweringContext<'a> {\n                     TraitItemKind::Const(ref ty, ref default) => {\n                         hir::TraitItemKind::Const(this.lower_ty(ty),\n                                                   default.as_ref().map(|x| {\n-                            let value = this.lower_expr(x);\n-                            this.record_body(value, None)\n+                            this.lower_body(None, |this| this.lower_expr(x))\n                         }))\n                     }\n                     TraitItemKind::Method(ref sig, None) => {\n@@ -1404,9 +1427,10 @@ impl<'a> LoweringContext<'a> {\n                                                    hir::TraitMethod::Required(names))\n                     }\n                     TraitItemKind::Method(ref sig, Some(ref body)) => {\n+                        let body_id = this.lower_body(Some(&sig.decl), |this| {\n                         let body = this.lower_block(body, false);\n-                        let expr = this.expr_block(body, ThinVec::new());\n-                        let body_id = this.record_body(expr, Some(&sig.decl));\n+                            this.expr_block(body, ThinVec::new())\n+                        });\n                         hir::TraitItemKind::Method(this.lower_method_sig(sig),\n                                                    hir::TraitMethod::Provided(body_id))\n                     }\n@@ -1455,14 +1479,14 @@ impl<'a> LoweringContext<'a> {\n                 defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n-                        let value = this.lower_expr(expr);\n-                        let body_id = this.record_body(value, None);\n+                        let body_id = this.lower_body(None, |this| this.lower_expr(expr));\n                         hir::ImplItemKind::Const(this.lower_ty(ty), body_id)\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n+                        let body_id = this.lower_body(Some(&sig.decl), |this| {\n                         let body = this.lower_block(body, false);\n-                        let expr = this.expr_block(body, ThinVec::new());\n-                        let body_id = this.record_body(expr, Some(&sig.decl));\n+                            this.expr_block(body, ThinVec::new())\n+                        });\n                         hir::ImplItemKind::Method(this.lower_method_sig(sig), body_id)\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n@@ -1834,8 +1858,8 @@ impl<'a> LoweringContext<'a> {\n             }\n             ExprKind::Repeat(ref expr, ref count) => {\n                 let expr = P(self.lower_expr(expr));\n-                let count = self.lower_expr(count);\n-                hir::ExprRepeat(expr, self.record_body(count, None))\n+                let body = self.lower_body(None, |this| this.lower_expr(count));\n+                hir::ExprRepeat(expr, body)\n             }\n             ExprKind::Tup(ref elts) => {\n                 hir::ExprTup(elts.iter().map(|x| self.lower_expr(x)).collect())\n@@ -1928,11 +1952,17 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n                 self.with_new_scopes(|this| {\n                     this.with_parent_def(e.id, |this| {\n-                        let expr = this.lower_expr(body);\n+                        let mut gen = None;\n+                        let body_id = this.lower_body(Some(decl), |this| {\n+                            let e = this.lower_expr(body);\n+                            gen = this.impl_arg.map(|_| hir::GeneratorClause::Movable);\n+                            e\n+                        });\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         this.record_body(expr, Some(decl)),\n-                                         fn_decl_span)\n+                                         body_id,\n+                                         fn_decl_span,\n+                                         gen)\n                     })\n                 })\n             }\n@@ -2068,6 +2098,18 @@ impl<'a> LoweringContext<'a> {\n                 return ex;\n             }\n \n+            ExprKind::Yield(ref opt_expr) => {\n+                self.impl_arg_id();\n+                let expr = opt_expr.as_ref().map(|x| self.lower_expr(x)).unwrap_or_else(|| {\n+                    self.expr(e.span, hir::ExprTup(hir_vec![]), ThinVec::new())\n+                });\n+                hir::ExprSuspend(P(expr))\n+            }\n+\n+            ExprKind::ImplArg => {\n+                hir::ExprImplArg(self.impl_arg_id())\n+            }\n+            \n             // Desugar ExprIfLet\n             // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n             ExprKind::IfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {"}, {"sha": "7094bd5b2cc1f578cbd8418c8e222a7f9bb63ebc", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -252,7 +252,8 @@ impl<'a> FnLikeNode<'a> {\n                 }\n             },\n             map::NodeExpr(e) => match e.node {\n-                ast::ExprClosure(_, ref decl, block, _fn_decl_span) =>\n+                ast::ExprClosure(_, ref decl, block, _fn_decl_span, _gen) =>\n+                    // FIXME: Does this need handling for generators?\n                     closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },"}, {"sha": "dfc1c7ad361322bbb8583345d2694d48eefb0f11", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -182,6 +182,13 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n         });\n     }\n \n+    fn visit_body(&mut self, b: &'hir Body) {\n+        if let Some(ref impl_arg) = b.impl_arg {\n+            self.insert(impl_arg.id, NodeImplArg(impl_arg));\n+        }\n+        intravisit::walk_body(self, b);\n+    }\n+\n     fn visit_fn(&mut self, fk: intravisit::FnKind<'hir>, fd: &'hir FnDecl,\n                 b: BodyId, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);"}, {"sha": "9a04cef5ee0fac3bf032b8ddac5c738565856c24", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -55,6 +55,7 @@ pub enum Node<'hir> {\n     NodeTraitRef(&'hir TraitRef),\n     NodeLocal(&'hir Pat),\n     NodePat(&'hir Pat),\n+    NodeImplArg(&'hir ImplArg),\n     NodeBlock(&'hir Block),\n \n     /// NodeStructCtor represents a tuple struct.\n@@ -84,6 +85,7 @@ enum MapEntry<'hir> {\n     EntryTy(NodeId, &'hir Ty),\n     EntryTraitRef(NodeId, &'hir TraitRef),\n     EntryLocal(NodeId, &'hir Pat),\n+    EntryImplArg(NodeId, &'hir ImplArg),\n     EntryPat(NodeId, &'hir Pat),\n     EntryBlock(NodeId, &'hir Block),\n     EntryStructCtor(NodeId, &'hir VariantData),\n@@ -115,6 +117,7 @@ impl<'hir> MapEntry<'hir> {\n             NodeTy(n) => EntryTy(p, n),\n             NodeTraitRef(n) => EntryTraitRef(p, n),\n             NodeLocal(n) => EntryLocal(p, n),\n+            NodeImplArg(n) => EntryImplArg(p, n),\n             NodePat(n) => EntryPat(p, n),\n             NodeBlock(n) => EntryBlock(p, n),\n             NodeStructCtor(n) => EntryStructCtor(p, n),\n@@ -136,6 +139,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryStmt(id, _) => id,\n             EntryTy(id, _) => id,\n             EntryTraitRef(id, _) => id,\n+            EntryImplArg(id, _) => id,\n             EntryLocal(id, _) => id,\n             EntryPat(id, _) => id,\n             EntryBlock(id, _) => id,\n@@ -162,13 +166,16 @@ impl<'hir> MapEntry<'hir> {\n             EntryTy(_, n) => NodeTy(n),\n             EntryTraitRef(_, n) => NodeTraitRef(n),\n             EntryLocal(_, n) => NodeLocal(n),\n+            EntryImplArg(_, n) => NodeImplArg(n),\n             EntryPat(_, n) => NodePat(n),\n             EntryBlock(_, n) => NodeBlock(n),\n             EntryStructCtor(_, n) => NodeStructCtor(n),\n             EntryLifetime(_, n) => NodeLifetime(n),\n             EntryTyParam(_, n) => NodeTyParam(n),\n             EntryVisibility(_, n) => NodeVisibility(n),\n-            _ => return None\n+\n+            NotPresent |\n+            RootCrate => return None\n         })\n     }\n \n@@ -201,7 +208,7 @@ impl<'hir> MapEntry<'hir> {\n \n             EntryExpr(_, expr) => {\n                 match expr.node {\n-                    ExprClosure(.., body, _) => Some(body),\n+                    ExprClosure(.., body, _, _) => Some(body),\n                     _ => None,\n                 }\n             }\n@@ -320,6 +327,7 @@ impl<'hir> Map<'hir> {\n                 EntryTy(p, _) |\n                 EntryTraitRef(p, _) |\n                 EntryLocal(p, _) |\n+                EntryImplArg(p, _) |\n                 EntryPat(p, _) |\n                 EntryBlock(p, _) |\n                 EntryStructCtor(p, _) |\n@@ -895,6 +903,7 @@ impl<'hir> Map<'hir> {\n             Some(EntryTy(_, ty)) => ty.span,\n             Some(EntryTraitRef(_, tr)) => tr.path.span,\n             Some(EntryLocal(_, pat)) => pat.span,\n+            Some(EntryImplArg(_, impl_arg)) => impl_arg.span,\n             Some(EntryPat(_, pat)) => pat.span,\n             Some(EntryBlock(_, block)) => block.span,\n             Some(EntryStructCtor(_, _)) => self.expect_item(self.get_parent(id)).span,\n@@ -1104,6 +1113,7 @@ impl<'a> print::State<'a> {\n             }\n             NodeLifetime(a)    => self.print_lifetime(&a),\n             NodeVisibility(a)  => self.print_visibility(&a),\n+            NodeImplArg(_)     => bug!(\"cannot print ImplArg\"),\n             NodeTyParam(_)     => bug!(\"cannot print TyParam\"),\n             NodeField(_)       => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n@@ -1205,6 +1215,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeLocal(_)) => {\n             format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n+        Some(NodeImplArg(_)) => {\n+            format!(\"impl_arg {}{}\", map.node_to_pretty_string(id), id_str)\n+        }\n         Some(NodePat(_)) => {\n             format!(\"pat {}{}\", map.node_to_pretty_string(id), id_str)\n         }"}, {"sha": "28d5cf2472d7a16f94ffdf3dea9b316eac02fe78", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -925,6 +925,13 @@ pub enum UnsafeSource {\n     UserProvided,\n }\n \n+/// represents an implicit argument of a generator\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ImplArg {\n+    pub id: NodeId,\n+    pub span: Span,\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct BodyId {\n     pub node_id: NodeId,\n@@ -934,7 +941,8 @@ pub struct BodyId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Body {\n     pub arguments: HirVec<Arg>,\n-    pub value: Expr\n+    pub value: Expr,\n+    pub impl_arg: Option<ImplArg>,\n }\n \n impl Body {\n@@ -943,6 +951,10 @@ impl Body {\n             node_id: self.value.id\n         }\n     }\n+\n+    pub fn is_generator(&self) -> bool {\n+        self.impl_arg.is_some()\n+    }\n }\n \n /// An expression\n@@ -1011,7 +1023,7 @@ pub enum Expr_ {\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span),\n+    ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorClause>),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -1056,6 +1068,12 @@ pub enum Expr_ {\n     /// For example, `[1; 5]`. The first expression is the element\n     /// to be repeated; the second is the number of times to repeat it.\n     ExprRepeat(P<Expr>, BodyId),\n+\n+    /// A suspension point for generators\n+    ExprSuspend(P<Expr>),\n+\n+    /// The argument to a generator\n+    ExprImplArg(NodeId),\n }\n \n /// Optionally `Self`-qualified value/type path or associated extension.\n@@ -1184,6 +1202,12 @@ pub struct Destination {\n     pub target_id: ScopeTarget,\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum GeneratorClause {\n+    Immovable,\n+    Movable,\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum CaptureClause {\n     CaptureByValue,"}, {"sha": "4be48708bb3a1a844ea10dd43a04ef7d87383b85", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -1312,7 +1312,12 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose_(expr.span, indent_unit)?;\n             }\n-            hir::ExprClosure(capture_clause, ref decl, body, _fn_decl_span) => {\n+            hir::ExprClosure(capture_clause, ref decl, body, _fn_decl_span, gen) => {\n+                if gen.is_some() {\n+                    self.head(\"gen\")?;\n+                    space(&mut self.s)?;\n+                }\n+                \n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_closure_args(&decl, body)?;\n@@ -1461,6 +1466,15 @@ impl<'a> State<'a> {\n \n                 self.pclose()?;\n             }\n+            hir::ExprSuspend(ref expr) => {\n+                word(&mut self.s, \"suspend \")?;\n+                self.print_expr(&expr)?;\n+            }\n+            hir::ExprImplArg(_) => {\n+                word(&mut self.s, \"gen\")?;\n+                space(&mut self.s)?;\n+                word(&mut self.s, \"arg\")?;\n+            }\n         }\n         self.ann.post(self, NodeExpr(expr))?;\n         self.end()"}, {"sha": "d2cc186bad4330e9818077062240bcdf9c209213", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -573,6 +573,8 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::E\n                 hir::ExprBreak(..)      |\n                 hir::ExprAgain(..)      |\n                 hir::ExprRet(..)        |\n+                hir::ExprSuspend(..)    |\n+                hir::ExprImplArg(..)    |\n                 hir::ExprInlineAsm(..)  |\n                 hir::ExprRepeat(..)     |\n                 hir::ExprTup(..)        => {\n@@ -637,7 +639,7 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprWhile(cond, body, label),\n     ExprLoop(body, label, loop_src),\n     ExprMatch(matchee, arms, match_src),\n-    ExprClosure(capture_clause, decl, body_id, span),\n+    ExprClosure(capture_clause, decl, body_id, span, gen),\n     ExprBlock(blk),\n     ExprAssign(lhs, rhs),\n     ExprAssignOp(op, lhs, rhs),\n@@ -651,7 +653,9 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprRet(val),\n     ExprInlineAsm(asm, inputs, outputs),\n     ExprStruct(path, fields, base),\n-    ExprRepeat(val, times)\n+    ExprRepeat(val, times),\n+    ExprSuspend(val),\n+    ExprImplArg(id)\n });\n \n impl_stable_hash_for!(enum hir::LocalSource {\n@@ -686,6 +690,11 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::M\n     }\n }\n \n+impl_stable_hash_for!(enum hir::GeneratorClause {\n+    Immovable,\n+    Movable\n+});\n+\n impl_stable_hash_for!(enum hir::CaptureClause {\n     CaptureByValue,\n     CaptureByRef\n@@ -1022,9 +1031,15 @@ impl_stable_hash_for!(struct hir::Arg {\n     id\n });\n \n+impl_stable_hash_for!(struct hir::ImplArg {\n+    id,\n+    span\n+});\n+\n impl_stable_hash_for!(struct hir::Body {\n     arguments,\n-    value\n+    value,\n+    impl_arg\n });\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::BodyId {"}, {"sha": "d273c6c9c42f15a9dc15c99a2e099b68d96f59f7", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::mem;\n \n-\n+impl_stable_hash_for!(struct mir::GeneratorLayout<'tcx> { fields });\n impl_stable_hash_for!(struct mir::SourceInfo { span, scope });\n impl_stable_hash_for!(enum mir::Mutability { Mut, Not });\n impl_stable_hash_for!(enum mir::BorrowKind { Shared, Unique, Mut });\n@@ -54,9 +54,11 @@ for mir::Terminator<'tcx> {\n             mir::TerminatorKind::SwitchInt { .. } |\n             mir::TerminatorKind::Resume |\n             mir::TerminatorKind::Return |\n+            mir::TerminatorKind::GeneratorDrop |\n             mir::TerminatorKind::Unreachable |\n             mir::TerminatorKind::Drop { .. } |\n             mir::TerminatorKind::DropAndReplace { .. } |\n+            mir::TerminatorKind::Suspend { .. } |\n             mir::TerminatorKind::Call { .. } => false,\n         };\n \n@@ -146,6 +148,7 @@ for mir::TerminatorKind<'tcx> {\n             }\n             mir::TerminatorKind::Resume |\n             mir::TerminatorKind::Return |\n+            mir::TerminatorKind::GeneratorDrop |\n             mir::TerminatorKind::Unreachable => {}\n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n                 location.hash_stable(hcx, hasher);\n@@ -161,6 +164,13 @@ for mir::TerminatorKind<'tcx> {\n                 target.hash_stable(hcx, hasher);\n                 unwind.hash_stable(hcx, hasher);\n             }\n+            mir::TerminatorKind::Suspend { ref value,\n+                                        resume,\n+                                        drop } => {\n+                value.hash_stable(hcx, hasher);\n+                resume.hash_stable(hcx, hasher);\n+                drop.hash_stable(hcx, hasher);\n+            }\n             mir::TerminatorKind::Call { ref func,\n                                         ref args,\n                                         ref destination,\n@@ -200,6 +210,8 @@ for mir::AssertMessage<'tcx> {\n             mir::AssertMessage::Math(ref const_math_err) => {\n                 const_math_err.hash_stable(hcx, hasher);\n             }\n+            mir::AssertMessage::GeneratorResumedAfterReturn => (),\n+            mir::AssertMessage::GeneratorResumedAfterPanic => (),\n         }\n     }\n }\n@@ -406,7 +418,8 @@ for mir::AggregateKind<'tcx> {\n                 substs.hash_stable(hcx, hasher);\n                 active_field.hash_stable(hcx, hasher);\n             }\n-            mir::AggregateKind::Closure(def_id, ref substs) => {\n+            mir::AggregateKind::Closure(def_id, ref substs) |\n+            mir::AggregateKind::Generator(def_id, ref substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }"}, {"sha": "22f202a35ecf7d385cd01a467e922d6d5b004fa2", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -142,6 +142,12 @@ for ty::UpvarCapture<'tcx> {\n     }\n }\n \n+impl_stable_hash_for!(struct ty::GenSig<'tcx> {\n+    impl_arg_ty,\n+    suspend_ty,\n+    return_ty\n+});\n+\n impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     inputs_and_output,\n     variadic,\n@@ -315,6 +321,8 @@ for ::middle::const_val::ConstVal<'tcx> {\n \n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n+impl_stable_hash_for!(tuple_struct ty::GeneratorInterior<'tcx> { ty });\n+\n impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     parent,\n     predicates\n@@ -541,6 +549,12 @@ for ty::TypeVariants<'tcx>\n                 def_id.hash_stable(hcx, hasher);\n                 closure_substs.hash_stable(hcx, hasher);\n             }\n+            TyGenerator(def_id, closure_substs, interior)\n+             => {\n+                def_id.hash_stable(hcx, hasher);\n+                closure_substs.hash_stable(hcx, hasher);\n+                interior.hash_stable(hcx, hasher);\n+            }\n             TyTuple(inner_tys, from_diverging_type_var) => {\n                 inner_tys.hash_stable(hcx, hasher);\n                 from_diverging_type_var.hash_stable(hcx, hasher);\n@@ -620,6 +634,8 @@ for ty::TypeckTables<'tcx> {\n             ref upvar_capture_map,\n             ref closure_tys,\n             ref closure_kinds,\n+            ref generator_interiors,\n+            ref generator_sigs,\n             ref liberated_fn_sigs,\n             ref fru_field_types,\n \n@@ -650,6 +666,8 @@ for ty::TypeckTables<'tcx> {\n \n             ich::hash_stable_nodemap(hcx, hasher, closure_tys);\n             ich::hash_stable_nodemap(hcx, hasher, closure_kinds);\n+            ich::hash_stable_nodemap(hcx, hasher, generator_interiors);\n+            ich::hash_stable_nodemap(hcx, hasher, generator_sigs);\n             ich::hash_stable_nodemap(hcx, hasher, liberated_fn_sigs);\n             ich::hash_stable_nodemap(hcx, hasher, fru_field_types);\n             ich::hash_stable_nodemap(hcx, hasher, cast_kinds);"}, {"sha": "a4b83af194d042a0dc27d74e8a792a21b0caf334", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -16,13 +16,15 @@ use ty::{self, Ty, TyInfer, TyVar};\n \n use syntax::ast::NodeId;\n use syntax_pos::Span;\n+use syntax_pos::DUMMY_SP;\n \n struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     target_ty: &'a Ty<'tcx>,\n     hir_map: &'a hir::map::Map<'gcx>,\n     found_local_pattern: Option<&'gcx Pat>,\n     found_arg_pattern: Option<&'gcx Pat>,\n+    found_impl_arg: bool,\n }\n \n impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n@@ -68,6 +70,11 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n                 self.found_arg_pattern = Some(&*argument.pat);\n             }\n         }\n+        if let Some(ref impl_arg) = body.impl_arg {\n+            if !self.found_impl_arg && self.node_matches_type(impl_arg.id) {\n+                self.found_impl_arg = true;\n+            }\n+        }\n         intravisit::walk_body(self, body);\n     }\n }\n@@ -101,6 +108,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             hir_map: &self.tcx.hir,\n             found_local_pattern: None,\n             found_arg_pattern: None,\n+            found_impl_arg: false,\n         };\n \n         if let Some(body_id) = body_id {\n@@ -137,6 +145,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n+        if local_visitor.found_impl_arg {\n+            labels.push((DUMMY_SP, format!(\"consider giving a type to the implicit generator argument\")));\n+        }\n+\n         let mut err = struct_span_err!(self.tcx.sess,\n                                        err_span,\n                                        E0282,"}, {"sha": "b8b5a55f57806eaf9cee92cb70e7be71175fc771", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -166,6 +166,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyFnPtr(_) |\n             ty::TyDynamic(..) |\n             ty::TyClosure(..) |\n+            ty::TyGenerator(..) |\n             ty::TyNever |\n             ty::TyTuple(..) |\n             ty::TyProjection(..) |"}, {"sha": "59fab366eaf4937c88ad0e8788d0878fade7ec45", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -992,6 +992,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.next_region_var(EarlyBoundRegion(span, def.name, def.issue_32330))\n     }\n \n+    pub fn type_var_for_impl_arg(&self,\n+                                span: Span,\n+                                def_id: DefId)\n+                            -> Ty<'tcx> {\n+        let default = Some(type_variable::Default {\n+            ty: self.tcx.mk_nil(),\n+            origin_span: span,\n+            def_id: def_id,\n+        });\n+\n+        let ty_var_id = self.type_variables\n+                            .borrow_mut()\n+                            .new_var(false,\n+                                     TypeVariableOrigin::TypeInference(span),\n+                                     default);\n+\n+        self.tcx.mk_var(ty_var_id)\n+    }\n+\n     /// Create a type inference variable for the given\n     /// type parameter definition. The substitutions are\n     /// for actual parameters that may be referred to by\n@@ -1362,6 +1381,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.fn_sig(def_id)\n     }\n+\n+    pub fn generator_sig(&self, def_id: DefId) -> Option<ty::PolyGenSig<'tcx>> {\n+        if let Some(tables) = self.in_progress_tables {\n+            if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+                if let Some(&ty) = tables.borrow().generator_sigs.get(&id) {\n+                    return ty.map(|t| ty::Binder(t));\n+                }\n+            }\n+        }\n+\n+        self.tcx.generator_sig(def_id)\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {"}, {"sha": "945b612027b9ee4802a9e68f956e1f74f7f6451e", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -517,13 +517,19 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprClosure(.., fn_decl_span) => {\n+            hir::ExprClosure(.., fn_decl_span, _) => {\n                 self.walk_captures(expr, fn_decl_span)\n             }\n \n             hir::ExprBox(ref base) => {\n                 self.consume_expr(&base);\n             }\n+\n+            hir::ExprSuspend(ref value) => {\n+                self.consume_expr(&value);\n+            }\n+\n+            hir::ExprImplArg(_) => { }\n         }\n     }\n "}, {"sha": "a36828ffcc93c8bf63e3972b08847e2265d28fc2", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -315,6 +315,9 @@ language_item_table! {\n     FnMutTraitLangItem,              \"fn_mut\",                  fn_mut_trait;\n     FnOnceTraitLangItem,             \"fn_once\",                 fn_once_trait;\n \n+    GeneratorStateLangItem,          \"generator_state\",         gen_state;\n+    GeneratorTraitLangItem,          \"generator\",               gen_trait;\n+\n     EqTraitLangItem,                 \"eq\",                      eq_trait;\n     OrdTraitLangItem,                \"ord\",                     ord_trait;\n "}, {"sha": "1487ae5908e5d40554e59ab791856c14f0d3034f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -249,6 +249,7 @@ struct LocalInfo {\n \n #[derive(Copy, Clone, Debug)]\n enum VarKind {\n+    ImplArg(NodeId),\n     Arg(NodeId, ast::Name),\n     Local(LocalInfo),\n     CleanExit\n@@ -304,7 +305,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n         self.num_vars += 1;\n \n         match vk {\n-            Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n+            Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) | ImplArg(node_id) => {\n                 self.variable_map.insert(node_id, v);\n             },\n             CleanExit => {}\n@@ -329,6 +330,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             Local(LocalInfo { name, .. }) | Arg(_, name) => {\n                 name.to_string()\n             },\n+            ImplArg(_) => \"<impl-arg>\".to_string(),\n             CleanExit => \"<clean-exit>\".to_string()\n         }\n     }\n@@ -365,6 +367,10 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n         })\n     };\n \n+    if let Some(ref impl_arg) = body.impl_arg {\n+        fn_maps.add_variable(ImplArg(impl_arg.id));\n+    }\n+\n     // gather up the various local variables, significant expressions,\n     // and so forth:\n     intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n@@ -417,6 +423,10 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         }\n         intravisit::walk_expr(ir, expr);\n       }\n+      hir::ExprImplArg(_) => {\n+          ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+          intravisit::walk_expr(ir, expr);\n+      }\n       hir::ExprClosure(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n@@ -460,7 +470,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       hir::ExprAgain(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n       hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprInlineAsm(..) | hir::ExprBox(..) |\n+      hir::ExprInlineAsm(..) | hir::ExprBox(..) | hir::ExprSuspend(..) |\n       hir::ExprType(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n           intravisit::walk_expr(ir, expr);\n       }\n@@ -881,6 +891,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n+          hir::ExprImplArg(arg_id) => {\n+              self.access_var(expr.id, arg_id, succ, ACC_READ | ACC_USE, expr.span)\n+          }\n \n           hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n               self.access_path(expr.id, path, succ, ACC_READ | ACC_USE)\n@@ -894,7 +907,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprClosure(.., blk_id, _) => {\n+          hir::ExprClosure(.., blk_id, _, _) => {\n               debug!(\"{} is an ExprClosure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n               /*\n@@ -1116,6 +1129,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprCast(ref e, _) |\n           hir::ExprType(ref e, _) |\n           hir::ExprUnary(_, ref e) |\n+          hir::ExprSuspend(ref e) |\n           hir::ExprRepeat(ref e, _) => {\n             self.propagate_through_expr(&e, succ)\n           }\n@@ -1212,6 +1226,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n+          hir::ExprImplArg(arg_id) => {\n+              self.access_var(expr.id, arg_id, succ, acc, expr.span)\n+          }\n           hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n               self.access_path(expr.id, path, succ, acc)\n           }\n@@ -1224,18 +1241,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n+    fn access_var(&mut self, id: NodeId, nid: NodeId, succ: LiveNode, acc: u32, span: Span)\n+                  -> LiveNode {\n+        let ln = self.live_node(id, span);\n+        if acc != 0 {\n+            self.init_from_succ(ln, succ);\n+            let var = self.variable(nid, span);\n+            self.acc(ln, var, acc);\n+        }\n+        ln\n+    }\n+\n     fn access_path(&mut self, id: NodeId, path: &hir::Path, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match path.def {\n           Def::Local(def_id) => {\n             let nid = self.ir.tcx.hir.as_local_node_id(def_id).unwrap();\n-            let ln = self.live_node(id, path.span);\n-            if acc != 0 {\n-                self.init_from_succ(ln, succ);\n-                let var = self.variable(nid, path.span);\n-                self.acc(ln, var, acc);\n-            }\n-            ln\n+            self.access_var(id, nid, succ, acc, path.span)\n           }\n           _ => succ\n         }\n@@ -1397,8 +1419,8 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprRet(..) |\n       hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |\n       hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n-      hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprClosure(..) | hir::ExprPath(_) |\n+      hir::ExprStruct(..) | hir::ExprRepeat(..) | hir::ExprImplArg(_) |\n+      hir::ExprClosure(..) | hir::ExprPath(_) | hir::ExprSuspend(..) |\n       hir::ExprBox(..) | hir::ExprType(..) => {\n         intravisit::walk_expr(this, expr);\n       }\n@@ -1420,6 +1442,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n                 }\n             }\n+            hir::ExprImplArg(_) => bug!(),\n             _ => {\n                 // For other kinds of lvalues, no checks are required,\n                 // and any embedded expressions are actually rvalues"}, {"sha": "bf5263e75da28cea47a63d504d5e738e70c5d5b0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -602,14 +602,25 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n+          hir::ExprImplArg(id) => {\n+            Ok(Rc::new(cmt_ {\n+                id: expr.id,\n+                span: expr.span,\n+                cat: Categorization::Local(id),\n+                mutbl: MutabilityCategory::McDeclared,\n+                ty: expr_ty,\n+                note: NoteNone\n+            }))\n+          },\n+\n           hir::ExprType(ref e, _) => {\n             self.cat_expr(&e)\n           }\n \n           hir::ExprAddrOf(..) | hir::ExprCall(..) |\n           hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n           hir::ExprClosure(..) | hir::ExprRet(..) |\n-          hir::ExprUnary(..) |\n+          hir::ExprUnary(..) | hir::ExprSuspend(..) |\n           hir::ExprMethodCall(..) | hir::ExprCast(..) |\n           hir::ExprArray(..) | hir::ExprTup(..) | hir::ExprIf(..) |\n           hir::ExprBinary(..) | hir::ExprWhile(..) |\n@@ -703,7 +714,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         let kind = match self.tables.closure_kinds.get(&fn_node_id) {\n             Some(&(kind, _)) => kind,\n-            None => span_bug!(span, \"missing closure kind\")\n+            None => {\n+                let ty = self.node_ty(fn_node_id)?;\n+                match ty.sty {\n+                    ty::TyGenerator(..) => ty::ClosureKind::FnOnce,\n+                    _ => span_bug!(span, \"missing closure kind\"),\n+                }\n+            }\n         };\n \n         let upvar_id = ty::UpvarId { var_id,"}, {"sha": "2e4d7b3b722da543eb77917ca961356450aebebb", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -32,6 +32,7 @@ use hir;\n use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n+use hir::map::Node;\n use mir::transform::MirSource;\n \n /// CodeExtent represents a statically-describable extent that can be\n@@ -789,7 +790,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n     match expr.node {\n         // Manually recurse over closures, because they are the only\n         // case of nested bodies that share the parent environment.\n-        hir::ExprClosure(.., body, _) => {\n+        hir::ExprClosure(.., body, _, _) => {\n             let body = visitor.tcx.hir.body(body);\n             visitor.visit_body(body);\n         }\n@@ -1071,7 +1072,10 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n         for argument in &body.arguments {\n             self.visit_pat(&argument.pat);\n         }\n-\n+        if let Some(ref impl_arg) = body.impl_arg {\n+            record_var_lifetime(self, impl_arg.id, impl_arg.span);\n+        }\n+        \n         // The body of the every fn is a root scope.\n         self.cx.parent = self.cx.var_parent;\n         self.visit_expr(&body.value);\n@@ -1142,6 +1146,66 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     Rc::new(maps)\n }\n \n+struct YieldFinder(bool);\n+\n+impl<'tcx> Visitor<'tcx> for YieldFinder {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_body(&mut self, _body: &'tcx hir::Body) {\n+        // Closures don't execute\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        if let hir::ExprSuspend(..) = expr.node {\n+            self.0 = true;\n+        }\n+        \n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+pub fn extent_has_yield<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(tcx: TyCtxt<'a, 'gcx, 'tcx>, extent: CodeExtent) -> bool {\n+    let mut finder = YieldFinder(false);\n+\n+    match extent {\n+        CodeExtent::DestructionScope(node_id) |\n+        CodeExtent::Misc(node_id) => {\n+            match tcx.hir.get(node_id) {\n+                Node::NodeItem(_) |\n+                Node::NodeTraitItem(_) |\n+                Node::NodeImplItem(_) => {\n+                    let body = tcx.hir.body(tcx.hir.body_owned_by(node_id));\n+                    intravisit::walk_body(&mut finder, body);\n+                }\n+                Node::NodeExpr(expr) => intravisit::walk_expr(&mut finder, expr),\n+                Node::NodeStmt(stmt) => intravisit::walk_stmt(&mut finder, stmt),\n+                Node::NodeBlock(block) => intravisit::walk_block(&mut finder, block), \n+                _ => bug!(),\n+            }\n+        }\n+\n+        CodeExtent::CallSiteScope(body_id) |\n+        CodeExtent::ParameterScope(body_id) => {\n+            intravisit::walk_body(&mut finder, tcx.hir.body(body_id))\n+        }\n+\n+        CodeExtent::Remainder(r) => {\n+            if let Node::NodeBlock(block) = tcx.hir.get(r.block) {\n+                for stmt in &block.stmts[(r.first_statement_index as usize + 1)..] {\n+                    intravisit::walk_stmt(&mut finder, stmt);\n+                }\n+                block.expr.as_ref().map(|e| intravisit::walk_expr(&mut finder, e));\n+            } else {\n+                bug!()\n+            }\n+        }\n+    }\n+\n+    finder.0\n+}\n+\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         region_maps,"}, {"sha": "fe85bb1b6f782dea980d99d91fd6e1ccec395814", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 125, "deletions": 7, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -104,6 +104,15 @@ pub struct Mir<'tcx> {\n     /// Return type of the function.\n     pub return_ty: Ty<'tcx>,\n \n+    /// Suspend type of the function, if it is a generator.\n+    pub suspend_ty: Option<Ty<'tcx>>,\n+\n+    /// Generator drop glue\n+    pub generator_drop: Option<Box<Mir<'tcx>>>,\n+\n+    /// The layout of a generator. Produced by the state transformation.\n+    pub generator_layout: Option<GeneratorLayout<'tcx>>,\n+\n     /// Declarations of locals.\n     ///\n     /// The first local is the return value pointer, followed by `arg_count`\n@@ -144,6 +153,7 @@ impl<'tcx> Mir<'tcx> {\n                visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n                promoted: IndexVec<Promoted, Mir<'tcx>>,\n                return_ty: Ty<'tcx>,\n+               suspend_ty: Option<Ty<'tcx>>,\n                local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n                arg_count: usize,\n                upvar_decls: Vec<UpvarDecl>,\n@@ -159,6 +169,9 @@ impl<'tcx> Mir<'tcx> {\n             visibility_scopes,\n             promoted,\n             return_ty,\n+            suspend_ty,\n+            generator_drop: None,\n+            generator_layout: None,\n             local_decls,\n             arg_count,\n             upvar_decls,\n@@ -168,6 +181,10 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n+    pub fn impl_arg_lvalue() -> Lvalue<'tcx> {\n+        Lvalue::Local(Local::new(1))\n+    }\n+\n     #[inline]\n     pub fn basic_blocks(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n         &self.basic_blocks\n@@ -270,6 +287,9 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     visibility_scopes,\n     promoted,\n     return_ty,\n+    suspend_ty,\n+    generator_drop,\n+    generator_layout,\n     local_decls,\n     arg_count,\n     upvar_decls,\n@@ -567,7 +587,20 @@ pub enum TerminatorKind<'tcx> {\n         msg: AssertMessage<'tcx>,\n         target: BasicBlock,\n         cleanup: Option<BasicBlock>\n-    }\n+    },\n+\n+    /// A suspend point\n+    Suspend {\n+        /// The value to return\n+        value: Operand<'tcx>,\n+        /// Where to resume to\n+        resume: BasicBlock,\n+        /// Cleanup to be done if the generator is dropped at this suspend point\n+        drop: Option<BasicBlock>,\n+    },\n+\n+    /// Indicates the end of the dropping of a generator\n+    GeneratorDrop,\n }\n \n impl<'tcx> Terminator<'tcx> {\n@@ -597,14 +630,16 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Goto { target: ref b } => slice::ref_slice(b).into_cow(),\n             SwitchInt { targets: ref b, .. } => b[..].into_cow(),\n-            Resume => (&[]).into_cow(),\n+            Resume | GeneratorDrop => (&[]).into_cow(),\n             Return => (&[]).into_cow(),\n             Unreachable => (&[]).into_cow(),\n             Call { destination: Some((_, t)), cleanup: Some(c), .. } => vec![t, c].into_cow(),\n             Call { destination: Some((_, ref t)), cleanup: None, .. } =>\n                 slice::ref_slice(t).into_cow(),\n             Call { destination: None, cleanup: Some(ref c), .. } => slice::ref_slice(c).into_cow(),\n             Call { destination: None, cleanup: None, .. } => (&[]).into_cow(),\n+            Suspend { resume: t, drop: Some(c), .. } => vec![t, c].into_cow(),\n+            Suspend { resume: ref t, drop: None, .. } => slice::ref_slice(t).into_cow(),\n             DropAndReplace { target, unwind: Some(unwind), .. } |\n             Drop { target, unwind: Some(unwind), .. } => {\n                 vec![target, unwind].into_cow()\n@@ -625,13 +660,15 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Goto { target: ref mut b } => vec![b],\n             SwitchInt { targets: ref mut b, .. } => b.iter_mut().collect(),\n-            Resume => Vec::new(),\n+            Resume | GeneratorDrop => Vec::new(),\n             Return => Vec::new(),\n             Unreachable => Vec::new(),\n             Call { destination: Some((_, ref mut t)), cleanup: Some(ref mut c), .. } => vec![t, c],\n             Call { destination: Some((_, ref mut t)), cleanup: None, .. } => vec![t],\n             Call { destination: None, cleanup: Some(ref mut c), .. } => vec![c],\n             Call { destination: None, cleanup: None, .. } => vec![],\n+            Suspend { resume: ref mut t, drop: Some(ref mut c), .. } => vec![t, c],\n+            Suspend { resume: ref mut t, drop: None, .. } => vec![t],\n             DropAndReplace { ref mut target, unwind: Some(ref mut unwind), .. } |\n             Drop { ref mut target, unwind: Some(ref mut unwind), .. } => vec![target, unwind],\n             DropAndReplace { ref mut target, unwind: None, .. } |\n@@ -664,6 +701,14 @@ impl<'tcx> BasicBlockData<'tcx> {\n     pub fn terminator_mut(&mut self) -> &mut Terminator<'tcx> {\n         self.terminator.as_mut().expect(\"invalid terminator state\")\n     }\n+\n+    pub fn retain_statements<F>(&mut self, mut f: F) where F: FnMut(&mut Statement) -> bool {\n+        for s in &mut self.statements {\n+            if !f(s) {\n+                s.kind = StatementKind::Nop;\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> Debug for TerminatorKind<'tcx> {\n@@ -703,7 +748,9 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Goto { .. } => write!(fmt, \"goto\"),\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n             Return => write!(fmt, \"return\"),\n+            GeneratorDrop => write!(fmt, \"generator_drop\"),\n             Resume => write!(fmt, \"resume\"),\n+            Suspend { ref value, .. } => write!(fmt, \"_1 = suspend({:?})\", value),\n             Unreachable => write!(fmt, \"unreachable\"),\n             Drop { ref location, .. } => write!(fmt, \"drop({:?})\", location),\n             DropAndReplace { ref location, ref value, .. } =>\n@@ -737,6 +784,12 @@ impl<'tcx> TerminatorKind<'tcx> {\n                     AssertMessage::Math(ref err) => {\n                         write!(fmt, \"{:?}\", err.description())?;\n                     }\n+                    AssertMessage::GeneratorResumedAfterReturn => {\n+                        write!(fmt, \"{:?}\", \"generator resumed after completion\")?;\n+                    }\n+                    AssertMessage::GeneratorResumedAfterPanic => {\n+                        write!(fmt, \"{:?}\", \"generator resumed after panicking\")?;\n+                    }\n                 }\n \n                 write!(fmt, \")\")\n@@ -748,7 +801,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n     pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n         use self::TerminatorKind::*;\n         match *self {\n-            Return | Resume | Unreachable => vec![],\n+            Return | Resume | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n             SwitchInt { ref values, .. } => {\n                 values.iter()\n@@ -765,6 +818,9 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into_cow()],\n             Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into_cow()],\n             Call { destination: None, cleanup: None, .. } => vec![],\n+            Suspend { drop: Some(_), .. } =>\n+                vec![\"resume\".into_cow(), \"drop\".into_cow()],\n+            Suspend { drop: None, .. } => vec![\"resume\".into_cow()],\n             DropAndReplace { unwind: None, .. } |\n             Drop { unwind: None, .. } => vec![\"return\".into_cow()],\n             DropAndReplace { unwind: Some(_), .. } |\n@@ -784,7 +840,9 @@ pub enum AssertMessage<'tcx> {\n         len: Operand<'tcx>,\n         index: Operand<'tcx>\n     },\n-    Math(ConstMathErr)\n+    Math(ConstMathErr),\n+    GeneratorResumedAfterReturn,\n+    GeneratorResumedAfterPanic,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -1120,6 +1178,7 @@ pub enum AggregateKind<'tcx> {\n     /// number and is present only for union expressions.\n     Adt(&'tcx AdtDef, usize, &'tcx Substs<'tcx>, Option<usize>),\n     Closure(DefId, ClosureSubsts<'tcx>),\n+    Generator(DefId, ClosureSubsts<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n@@ -1281,6 +1340,30 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             write!(fmt, \"[closure]\")\n                         }\n                     }),\n+\n+                    AggregateKind::Generator(def_id, _) => ty::tls::with(|tcx| {\n+                        if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+                            let name = format!(\"[generator@{:?}]\", tcx.hir.span(node_id));\n+                            let mut struct_fmt = fmt.debug_struct(&name);\n+\n+                            tcx.with_freevars(node_id, |freevars| {\n+                                for (freevar, lv) in freevars.iter().zip(lvs) {\n+                                    let def_id = freevar.def.def_id();\n+                                    let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+                                    let var_name = tcx.local_var_name_str(var_id);\n+                                    struct_fmt.field(&var_name, lv);\n+                                }\n+                                struct_fmt.field(\"$state\", &lvs[freevars.len()]);\n+                                for i in (freevars.len() + 1)..lvs.len() {\n+                                    struct_fmt.field(&format!(\"${}\", i - freevars.len() - 1), &lvs[i]);\n+                                }\n+                            });\n+\n+                            struct_fmt.finish()\n+                        } else {\n+                            write!(fmt, \"[generator]\")\n+                        }\n+                    }),\n                 }\n             }\n         }\n@@ -1425,6 +1508,11 @@ impl Location {\n     }\n }\n \n+/// The layout of generator state\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct GeneratorLayout<'tcx> {\n+    pub fields: Vec<LocalDecl<'tcx>>,\n+}\n \n /*\n  * TypeFoldable implementations for MIR types\n@@ -1437,6 +1525,9 @@ impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n             visibility_scopes: self.visibility_scopes.clone(),\n             promoted: self.promoted.fold_with(folder),\n             return_ty: self.return_ty.fold_with(folder),\n+            suspend_ty: self.suspend_ty.fold_with(folder),\n+            generator_drop: self.generator_drop.fold_with(folder),\n+            generator_layout: self.generator_layout.fold_with(folder),\n             local_decls: self.local_decls.fold_with(folder),\n             arg_count: self.arg_count,\n             upvar_decls: self.upvar_decls.clone(),\n@@ -1448,12 +1539,27 @@ impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.basic_blocks.visit_with(visitor) ||\n+        self.generator_drop.visit_with(visitor) ||\n+        self.generator_layout.visit_with(visitor) ||\n+        self.suspend_ty.visit_with(visitor) ||\n         self.promoted.visit_with(visitor)     ||\n         self.return_ty.visit_with(visitor)    ||\n         self.local_decls.visit_with(visitor)\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for GeneratorLayout<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        GeneratorLayout {\n+            fields: self.fields.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.fields.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for LocalDecl<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         LocalDecl {\n@@ -1558,6 +1664,11 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 target,\n                 unwind,\n             },\n+            Suspend { ref value, resume, drop } => Suspend {\n+                value: value.fold_with(folder),\n+                resume: resume,\n+                drop: drop,\n+            },\n             Call { ref func, ref args, ref destination, cleanup } => {\n                 let dest = destination.as_ref().map(|&(ref loc, dest)| {\n                     (loc.fold_with(folder), dest)\n@@ -1587,6 +1698,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                     cleanup,\n                 }\n             },\n+            GeneratorDrop => GeneratorDrop,\n             Resume => Resume,\n             Return => Return,\n             Unreachable => Unreachable,\n@@ -1606,6 +1718,8 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             Drop { ref location, ..} => location.visit_with(visitor),\n             DropAndReplace { ref location, ref value, ..} =>\n                 location.visit_with(visitor) || value.visit_with(visitor),\n+            Suspend { ref value, ..} =>\n+                value.visit_with(visitor),\n             Call { ref func, ref args, ref destination, .. } => {\n                 let dest = if let Some((ref loc, _)) = *destination {\n                     loc.visit_with(visitor)\n@@ -1626,6 +1740,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n             Goto { .. } |\n             Resume |\n             Return |\n+            GeneratorDrop |\n             Unreachable => false\n         }\n     }\n@@ -1671,7 +1786,9 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                     AggregateKind::Adt(def, v, substs, n) =>\n                         AggregateKind::Adt(def, v, substs.fold_with(folder), n),\n                     AggregateKind::Closure(id, substs) =>\n-                        AggregateKind::Closure(id, substs.fold_with(folder))\n+                        AggregateKind::Closure(id, substs.fold_with(folder)),\n+                    AggregateKind::Generator(id, substs) =>\n+                        AggregateKind::Generator(id, substs.fold_with(folder)),\n                 };\n                 Aggregate(kind, fields.fold_with(folder))\n             }\n@@ -1697,7 +1814,8 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                     AggregateKind::Array(ty) => ty.visit_with(visitor),\n                     AggregateKind::Tuple => false,\n                     AggregateKind::Adt(_, _, substs, _) => substs.visit_with(visitor),\n-                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor)\n+                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n+                    AggregateKind::Generator(_, substs) => substs.visit_with(visitor),\n                 }) || fields.visit_with(visitor)\n             }\n         }"}, {"sha": "252cf3e4f8064717f90780d33bd94b4f41234139", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -202,6 +202,11 @@ impl<'tcx> Rvalue<'tcx> {\n                     AggregateKind::Closure(did, substs) => {\n                         tcx.mk_closure_from_closure_substs(did, substs)\n                     }\n+                    AggregateKind::Generator(did, substs) => {\n+                        let node_id = tcx.hir.as_local_node_id(did).unwrap();\n+                        let interior = *tcx.typeck_tables_of(did).generator_interiors.get(&node_id).unwrap();\n+                        tcx.mk_generator(did, substs, interior.subst(tcx, substs.substs))\n+                    }\n                 }\n             }\n         }"}, {"sha": "f29405e6650518bced752cc45950d6699cdf61d7", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -33,7 +33,10 @@ pub enum MirSource {\n     Static(NodeId, hir::Mutability),\n \n     /// Promoted rvalues within a function.\n-    Promoted(NodeId, Promoted)\n+    Promoted(NodeId, Promoted),\n+\n+    /// Drop glue for a generator.\n+    GeneratorDrop(NodeId),\n }\n \n impl<'a, 'tcx> MirSource {\n@@ -70,6 +73,7 @@ impl<'a, 'tcx> MirSource {\n         match *self {\n             MirSource::Fn(id) |\n             MirSource::Const(id) |\n+            MirSource::GeneratorDrop(id) |\n             MirSource::Static(id, _) |\n             MirSource::Promoted(id, _) => id\n         }"}, {"sha": "6032dad46eb03e9d29c97c31178b6a1fd55cb655", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -247,6 +247,10 @@ macro_rules! make_mir_visitor {\n                 self.super_local_decl(local_decl);\n             }\n \n+            fn visit_local(&mut self,\n+                                _local: & $($mutability)* Local) {\n+            }\n+\n             fn visit_visibility_scope(&mut self,\n                                       scope: & $($mutability)* VisibilityScope) {\n                 self.super_visibility_scope(scope);\n@@ -395,7 +399,8 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     TerminatorKind::Resume |\n-                    TerminatorKind::Return |\n+                    TerminatorKind::Return | \n+                    TerminatorKind::GeneratorDrop |\n                     TerminatorKind::Unreachable => {\n                     }\n \n@@ -442,6 +447,15 @@ macro_rules! make_mir_visitor {\n                         self.visit_branch(block, target);\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n+\n+                    TerminatorKind::Suspend { ref $($mutability)* value,\n+                                              resume,\n+                                              drop } => {\n+                        self.visit_operand(value, source_location);\n+                        self.visit_branch(block, resume);\n+                        drop.map(|t| self.visit_branch(block, t));\n+                    }\n+\n                 }\n             }\n \n@@ -456,7 +470,9 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(len, location);\n                         self.visit_operand(index, location);\n                     }\n-                    AssertMessage::Math(_) => {}\n+                    AssertMessage::Math(_) => {},\n+                    AssertMessage::GeneratorResumedAfterReturn => {},\n+                    AssertMessage::GeneratorResumedAfterPanic => {},\n                 }\n             }\n \n@@ -534,6 +550,11 @@ macro_rules! make_mir_visitor {\n                                 self.visit_def_id(def_id, location);\n                                 self.visit_closure_substs(closure_substs);\n                             }\n+                            AggregateKind::Generator(ref $($mutability)* def_id,\n+                                                   ref $($mutability)* closure_substs) => {\n+                                self.visit_def_id(def_id, location);\n+                                self.visit_closure_substs(closure_substs);\n+                            }\n                         }\n \n                         for operand in operands {\n@@ -561,7 +582,8 @@ macro_rules! make_mir_visitor {\n                             context: LvalueContext<'tcx>,\n                             location: Location) {\n                 match *lvalue {\n-                    Lvalue::Local(_) => {\n+                    Lvalue::Local(ref $($mutability)* local) => {\n+                        self.visit_local(local);\n                     }\n                     Lvalue::Static(ref $($mutability)* static_) => {\n                         self.visit_static(static_, context, location);"}, {"sha": "431bd8ee88f709883aa72813689aa76cee731c72", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -301,7 +301,7 @@ fn ty_is_local_constructor(ty: Ty, infer_is_local: InferIsLocal)-> bool {\n             true\n         }\n \n-        ty::TyClosure(..) | ty::TyAnon(..) => {\n+        ty::TyClosure(..) | ty::TyGenerator(..) | ty::TyAnon(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "524840591386903211886e731e50d25b06b7998f", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -251,6 +251,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     AdtKind::Union => Some(16),\n                     AdtKind::Enum => Some(17),\n                 },\n+                ty::TyGenerator(..) => Some(18),\n                 ty::TyInfer(..) | ty::TyError => None\n             }\n         }"}, {"sha": "e13e25250a135ca9d6bd8b34d526d5729c32d8bf", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -310,6 +310,9 @@ pub enum Vtable<'tcx, N> {\n \n     /// Same as above, but for a fn pointer type with the given signature.\n     VtableFnPointer(VtableFnPointerData<'tcx, N>),\n+\n+    /// Vtable automatically generated for a generator\n+    VtableGenerator(VtableGeneratorData<'tcx, N>),\n }\n \n /// Identifies a particular impl in the source, along with a set of\n@@ -329,6 +332,15 @@ pub struct VtableImplData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n+#[derive(Clone, PartialEq, Eq)]\n+pub struct VtableGeneratorData<'tcx, N> {\n+    pub closure_def_id: DefId,\n+    pub substs: ty::ClosureSubsts<'tcx>,\n+    /// Nested obligations. This can be non-empty if the generator\n+    /// signature contains associated types.\n+    pub nested: Vec<N>\n+}\n+\n #[derive(Clone, PartialEq, Eq)]\n pub struct VtableClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n@@ -743,6 +755,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableBuiltin(i) => i.nested,\n             VtableDefaultImpl(d) => d.nested,\n             VtableClosure(c) => c.nested,\n+            VtableGenerator(c) => c.nested,\n             VtableObject(d) => d.nested,\n             VtableFnPointer(d) => d.nested,\n         }\n@@ -754,6 +767,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             &mut VtableParam(ref mut n) => n,\n             &mut VtableBuiltin(ref mut i) => &mut i.nested,\n             &mut VtableDefaultImpl(ref mut d) => &mut d.nested,\n+            &mut VtableGenerator(ref mut c) => &mut c.nested,\n             &mut VtableClosure(ref mut c) => &mut c.nested,\n             &mut VtableObject(ref mut d) => &mut d.nested,\n             &mut VtableFnPointer(ref mut d) => &mut d.nested,\n@@ -784,6 +798,11 @@ impl<'tcx, N> Vtable<'tcx, N> {\n                 fn_ty: p.fn_ty,\n                 nested: p.nested.into_iter().map(f).collect(),\n             }),\n+            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n+                closure_def_id: c.closure_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n             VtableClosure(c) => VtableClosure(VtableClosureData {\n                 closure_def_id: c.closure_def_id,\n                 substs: c.substs,"}, {"sha": "35b8b935815515c4a37b7645a70e369dc0e7038c", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -19,6 +19,7 @@ use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableClosureData;\n+use super::VtableGeneratorData;\n use super::VtableFnPointerData;\n use super::VtableImplData;\n use super::util;\n@@ -884,6 +885,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n \n         match vtable {\n             super::VtableClosure(_) |\n+            super::VtableGenerator(_) |\n             super::VtableFnPointer(_) |\n             super::VtableObject(_) => {\n                 debug!(\"assemble_candidates_from_impls: vtable={:?}\",\n@@ -1043,6 +1045,8 @@ fn confirm_select_candidate<'cx, 'gcx, 'tcx>(\n     match vtable {\n         super::VtableImpl(data) =>\n             confirm_impl_candidate(selcx, obligation, data),\n+        super::VtableGenerator(data) =>\n+            confirm_generator_candidate(selcx, obligation, data),\n         super::VtableClosure(data) =>\n             confirm_closure_candidate(selcx, obligation, data),\n         super::VtableFnPointer(data) =>\n@@ -1125,6 +1129,60 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     confirm_param_env_candidate(selcx, obligation, env_predicate)\n }\n \n+fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>)\n+    -> Progress<'tcx>\n+{\n+    let gen_sig = selcx.infcx().generator_sig(vtable.closure_def_id).unwrap()\n+        .subst(selcx.tcx(), vtable.substs.substs);\n+    let Normalized {\n+        value: gen_sig,\n+        obligations\n+    } = normalize_with_depth(selcx,\n+                             obligation.param_env,\n+                             obligation.cause.clone(),\n+                             obligation.recursion_depth+1,\n+                             &gen_sig);\n+\n+    debug!(\"confirm_generator_candidate: obligation={:?},gen_sig={:?},obligations={:?}\",\n+           obligation,\n+           gen_sig,\n+           obligations);\n+\n+    let tcx = selcx.tcx();\n+\n+    let gen_def_id = tcx.lang_items.gen_trait().unwrap();\n+\n+    // Note: we unwrap the binder here but re-create it below (1)\n+    let ty::Binder((trait_ref, suspend_ty, return_ty)) =\n+        tcx.generator_trait_ref_and_outputs(gen_def_id,\n+                                            obligation.predicate.trait_ref.self_ty(),\n+                                            gen_sig);\n+\n+    let name = obligation.predicate.item_name(tcx);\n+    let ty = if name == Symbol::intern(\"Return\") {\n+        return_ty\n+    } else if name == Symbol::intern(\"Yield\") {\n+        suspend_ty\n+    } else {\n+        bug!()\n+    };\n+\n+    let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n+        projection_ty: ty::ProjectionTy {\n+            trait_ref: trait_ref,\n+            item_def_id: obligation.predicate.item_def_id,\n+        },\n+        ty: ty\n+    });\n+\n+    confirm_param_env_candidate(selcx, obligation, predicate)\n+        .with_addl_obligations(vtable.nested)\n+        .with_addl_obligations(obligations)\n+}\n+\n fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,"}, {"sha": "dc12bf100ecd65b457c51bd96d715347f9f06487", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 126, "deletions": 4, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -24,9 +24,9 @@ use super::{ObjectCastObligation, Obligation};\n use super::TraitNotObjectSafe;\n use super::Selection;\n use super::SelectionResult;\n-use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n+use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure, VtableGenerator,\n             VtableFnPointer, VtableObject, VtableDefaultImpl};\n-use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n+use super::{VtableImplData, VtableObjectData, VtableBuiltinData, VtableGeneratorData,\n             VtableClosureData, VtableDefaultImplData, VtableFnPointerData};\n use super::util;\n \n@@ -43,6 +43,7 @@ use middle::lang_items;\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n+use std::iter;\n use std::cell::RefCell;\n use std::cmp;\n use std::fmt;\n@@ -197,6 +198,10 @@ enum SelectionCandidate<'tcx> {\n     /// confirmation step what ClosureKind obligation to emit.\n     ClosureCandidate(/* closure */ DefId, ty::ClosureSubsts<'tcx>, ty::ClosureKind),\n \n+    /// Implementation of a `Generator` trait by one of the anonymous types\n+    /// generated for a generator.\n+    GeneratorCandidate(/* function / closure */ DefId, ty::ClosureSubsts<'tcx>),\n+\n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n     FnPointerCandidate,\n@@ -228,6 +233,11 @@ impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n             ParamCandidate(ref trait_ref) => {\n                 return tcx.lift(trait_ref).map(ParamCandidate);\n             }\n+            GeneratorCandidate(def_id, ref substs) => {\n+                return tcx.lift(substs).map(|substs| {\n+                    GeneratorCandidate(def_id, substs)\n+                });\n+            }\n             ClosureCandidate(def_id, ref substs, kind) => {\n                 return tcx.lift(substs).map(|substs| {\n                     ClosureCandidate(def_id, substs, kind)\n@@ -1295,6 +1305,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                    &mut candidates)?;\n          } else if self.tcx().lang_items.unsize_trait() == Some(def_id) {\n              self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+         } else if self.tcx().lang_items.gen_trait() == Some(def_id) {\n+             self.assemble_generator_candidates(obligation, &mut candidates)?;\n          } else {\n              self.assemble_closure_candidates(obligation, &mut candidates)?;\n              self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n@@ -1480,6 +1492,31 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         })\n     }\n \n+    fn assemble_generator_candidates(&mut self,\n+                                   obligation: &TraitObligation<'tcx>,\n+                                   candidates: &mut SelectionCandidateSet<'tcx>)\n+                                   -> Result<(),SelectionError<'tcx>>\n+    {\n+        let self_ty = *obligation.self_ty().skip_binder();\n+        let (closure_def_id, substs) = match self_ty.sty {\n+            ty::TyGenerator(id, substs, _) => (id, substs),\n+            ty::TyInfer(ty::TyVar(_)) => {\n+                debug!(\"assemble_generator_candidates: ambiguous self-type\");\n+                candidates.ambiguous = true;\n+                return Ok(());\n+            }\n+            _ => { return Ok(()); }\n+        };\n+\n+        debug!(\"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n+               self_ty,\n+               obligation);\n+\n+        candidates.vec.push(GeneratorCandidate(closure_def_id, substs));\n+\n+        Ok(())\n+    }\n+\n     /// Check for the artificial impl that the compiler will create for an obligation like `X :\n     /// FnMut<..>` where `X` is a closure type.\n     ///\n@@ -1848,6 +1885,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }\n                 ImplCandidate(..) |\n                 ClosureCandidate(..) |\n+                GeneratorCandidate(..) |\n                 FnPointerCandidate |\n                 BuiltinObjectCandidate |\n                 BuiltinUnsizeCandidate |\n@@ -1928,7 +1966,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n             ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n-            ty::TyChar | ty::TyRef(..) |\n+            ty::TyChar | ty::TyRef(..) | ty::TyGenerator(..) |\n             ty::TyArray(..) | ty::TyClosure(..) | ty::TyNever |\n             ty::TyError => {\n                 // safe for everything\n@@ -1980,7 +2018,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n-            ty::TyClosure(..) |\n+            ty::TyClosure(..) | ty::TyGenerator(..) |\n             ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 Never\n             }\n@@ -2081,6 +2119,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 substs.upvar_tys(def_id, self.tcx()).collect()\n             }\n \n+            ty::TyGenerator(def_id, ref substs, interior) => {\n+                let witness = iter::once(interior.witness());\n+                substs.upvar_tys(def_id, self.tcx()).chain(witness).collect()\n+            }\n+\n             // for `PhantomData<T>`, we pass `T`\n             ty::TyAdt(def, substs) if def.is_phantom_data() => {\n                 substs.types().collect()\n@@ -2190,6 +2233,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ok(VtableClosure(vtable_closure))\n             }\n \n+            GeneratorCandidate(closure_def_id, substs) => {\n+                let vtable_generator =\n+                    self.confirm_generator_candidate(obligation, closure_def_id, substs)?;\n+                Ok(VtableGenerator(vtable_generator))\n+            }\n+\n             BuiltinObjectCandidate => {\n                 // This indicates something like `(Trait+Send) :\n                 // Send`. In this case, we know that this holds\n@@ -2518,6 +2567,40 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         Ok(VtableFnPointerData { fn_ty: self_ty, nested: obligations })\n     }\n \n+    fn confirm_generator_candidate(&mut self,\n+                                 obligation: &TraitObligation<'tcx>,\n+                                 closure_def_id: DefId,\n+                                 substs: ty::ClosureSubsts<'tcx>)\n+                                 -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n+                                           SelectionError<'tcx>>\n+    {\n+        debug!(\"confirm_generator_candidate({:?},{:?},{:?})\",\n+               obligation,\n+               closure_def_id,\n+               substs);\n+\n+        let Normalized {\n+            value: trait_ref,\n+            obligations\n+        } = self.generator_trait_ref(obligation, closure_def_id, substs);\n+        \n+        debug!(\"confirm_generator_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n+               closure_def_id,\n+               trait_ref,\n+               obligations);\n+\n+        self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                     obligation.param_env,\n+                                     obligation.predicate.to_poly_trait_ref(),\n+                                     trait_ref)?;\n+\n+        Ok(VtableGeneratorData {\n+            closure_def_id: closure_def_id,\n+            substs: substs.clone(),\n+            nested: obligations\n+        })\n+    }\n+\n     fn confirm_closure_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n                                  closure_def_id: DefId,\n@@ -3019,6 +3102,45 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                              &trait_ref)\n     }\n \n+    fn generator_trait_ref_unnormalized(&mut self,\n+                                      obligation: &TraitObligation<'tcx>,\n+                                      closure_def_id: DefId,\n+                                      substs: ty::ClosureSubsts<'tcx>)\n+                                      -> ty::PolyTraitRef<'tcx>\n+    {\n+        let gen_sig = self.infcx.generator_sig(closure_def_id).unwrap()\n+            .subst(self.tcx(), substs.substs);\n+        let ty::Binder((trait_ref, ..)) =\n+            self.tcx().generator_trait_ref_and_outputs(obligation.predicate.def_id(),\n+                                                       obligation.predicate.0.self_ty(), // (1)\n+                                                       gen_sig);\n+        // (1) Feels icky to skip the binder here, but OTOH we know\n+        // that the self-type is an generator type and hence is\n+        // in fact unparameterized (or at least does not reference any\n+        // regions bound in the obligation). Still probably some\n+        // refactoring could make this nicer.\n+\n+        ty::Binder(trait_ref)\n+    }\n+\n+    fn generator_trait_ref(&mut self,\n+                         obligation: &TraitObligation<'tcx>,\n+                         closure_def_id: DefId,\n+                         substs: ty::ClosureSubsts<'tcx>)\n+                         -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n+    {\n+        let trait_ref = self.generator_trait_ref_unnormalized(\n+            obligation, closure_def_id, substs);\n+\n+        // A generator signature can contain associated types which\n+        // must be normalized.\n+        normalize_with_depth(self,\n+                             obligation.param_env,\n+                             obligation.cause.clone(),\n+                             obligation.recursion_depth+1,\n+                             &trait_ref)\n+    }\n+\n     /// Returns the obligations that are implied by instantiating an\n     /// impl or trait. The obligations are substituted and fully\n     /// normalized. This is used when confirming an impl or default"}, {"sha": "93994329178e75b9715348fbcbefc769c05ab36a", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -53,6 +53,9 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n             super::VtableClosure(ref d) =>\n                 write!(f, \"{:?}\", d),\n \n+            super::VtableGenerator(ref d) =>\n+                write!(f, \"{:?}\", d),\n+\n             super::VtableFnPointer(ref d) =>\n                 write!(f, \"VtableFnPointer({:?})\", d),\n \n@@ -77,6 +80,15 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n     }\n }\n \n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableGenerator(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+               self.closure_def_id,\n+               self.substs,\n+               self.nested)\n+    }\n+}\n+\n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n@@ -278,6 +290,19 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                 })\n             }\n             traits::VtableDefaultImpl(t) => Some(traits::VtableDefaultImpl(t)),\n+            traits::VtableGenerator(traits::VtableGeneratorData {\n+                closure_def_id,\n+                substs,\n+                nested\n+            }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableGenerator(traits::VtableGeneratorData {\n+                        closure_def_id: closure_def_id,\n+                        substs: substs,\n+                        nested: nested\n+                    })\n+                })\n+            }\n             traits::VtableClosure(traits::VtableClosureData {\n                 closure_def_id,\n                 substs,\n@@ -351,6 +376,20 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<\n     }\n }\n \n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableGeneratorData<'tcx, N> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::VtableGeneratorData {\n+            closure_def_id: self.closure_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.substs.visit_with(visitor) || self.nested.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableClosureData {\n@@ -422,6 +461,9 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n             traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n+            traits::VtableGenerator(ref d) => {\n+                traits::VtableGenerator(d.fold_with(folder))\n+            }\n             traits::VtableClosure(ref d) => {\n                 traits::VtableClosure(d.fold_with(folder))\n             }\n@@ -438,6 +480,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n         match *self {\n             traits::VtableImpl(ref v) => v.visit_with(visitor),\n             traits::VtableDefaultImpl(ref t) => t.visit_with(visitor),\n+            traits::VtableGenerator(ref d) => d.visit_with(visitor),\n             traits::VtableClosure(ref d) => d.visit_with(visitor),\n             traits::VtableFnPointer(ref d) => d.visit_with(visitor),\n             traits::VtableParam(ref n) => n.visit_with(visitor),"}, {"sha": "957e6e9bc5ec7ab813ca7c79adc058deb50cc3dd", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -513,6 +513,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         ty::Binder((trait_ref, sig.skip_binder().output()))\n     }\n \n+    pub fn generator_trait_ref_and_outputs(self,\n+        fn_trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        sig: ty::PolyGenSig<'tcx>)\n+        -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)>\n+    {\n+        let trait_ref = ty::TraitRef {\n+            def_id: fn_trait_def_id,\n+            substs: self.mk_substs_trait(self_ty, &[sig.skip_binder().impl_arg_ty]),\n+        };\n+        ty::Binder((trait_ref, sig.skip_binder().suspend_ty, sig.skip_binder().return_ty))\n+    }\n+    \n     pub fn impl_is_default(self, node_item_def_id: DefId) -> bool {\n         match self.hir.as_local_node_id(node_item_def_id) {\n             Some(node_id) => {"}, {"sha": "6f276afc1025be3b481aed8123d1997751a3c436", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -30,7 +30,7 @@ use ty::ReprOptions;\n use traits;\n use ty::{self, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n-use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n+use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region};\n use hir::FreevarMap;\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n@@ -233,6 +233,10 @@ pub struct TypeckTables<'tcx> {\n     /// that caused the closure to be this kind.\n     pub closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n \n+    pub generator_sigs: NodeMap<Option<ty::GenSig<'tcx>>>,\n+\n+    pub generator_interiors: NodeMap<ty::GeneratorInterior<'tcx>>,\n+\n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n     /// (including late-bound regions) are replaced with free\n@@ -275,6 +279,8 @@ impl<'tcx> TypeckTables<'tcx> {\n             node_substs: NodeMap(),\n             adjustments: NodeMap(),\n             upvar_capture_map: FxHashMap(),\n+            generator_sigs: NodeMap(),\n+            generator_interiors: NodeMap(),\n             closure_tys: NodeMap(),\n             closure_kinds: NodeMap(),\n             liberated_fn_sigs: NodeMap(),\n@@ -1040,7 +1046,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n-            TyAdt, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n+            TyAdt, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr, TyGenerator,\n             TyDynamic, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n@@ -1395,6 +1401,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyClosure(closure_id, closure_substs))\n     }\n \n+    pub fn mk_generator(self, \n+                        id: DefId,\n+                        closure_substs: ClosureSubsts<'tcx>,\n+                        interior: GeneratorInterior<'tcx>)\n+                        -> Ty<'tcx> {\n+        self.mk_ty(TyGenerator(id, closure_substs, interior))\n+    }\n+\n     pub fn mk_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_infer(TyVar(v))\n     }"}, {"sha": "695c9427001a42ce28fb46c3feac601cb4646fe0", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -213,6 +213,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                     |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())))\n             }\n             ty::TyClosure(..) => \"closure\".to_string(),\n+            ty::TyGenerator(..) => \"generator\".to_string(),\n             ty::TyTuple(..) => \"tuple\".to_string(),\n             ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),\n             ty::TyInfer(ty::IntVar(_)) => \"integral variable\".to_string(),"}, {"sha": "353a1cd5355b9b14ca427f16fc65e5930e09bb3b", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -30,6 +30,7 @@ pub enum SimplifiedType {\n     TupleSimplifiedType(usize),\n     TraitSimplifiedType(DefId),\n     ClosureSimplifiedType(DefId),\n+    GeneratorSimplifiedType(DefId),\n     AnonSimplifiedType(DefId),\n     FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n@@ -72,6 +73,9 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n+        ty::TyGenerator(def_id, _, _) => {\n+            Some(GeneratorSimplifiedType(def_id))\n+        }\n         ty::TyNever => Some(NeverSimplifiedType),\n         ty::TyTuple(ref tys, _) => {\n             Some(TupleSimplifiedType(tys.len()))"}, {"sha": "72e4e20d70b4c4fe8970e0c2191eb3041ce6b6a2", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -85,6 +85,15 @@ impl FlagComputation {\n                 }\n             }\n \n+            &ty::TyGenerator(_, ref substs, ref interior) => {\n+                // FIXME: Find out why TyClosure has HAS_TY_CLOSURE\n+                // and see if the same reason applies here\n+                self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n+                self.add_substs(&substs.substs);\n+                self.add_ty(interior.witness());\n+            }\n+\n             &ty::TyClosure(_, ref substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);"}, {"sha": "01640712a38b8259aa461776dfd774b773552d9b", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -350,6 +350,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n \n         ty::TyFnDef(def_id, _) |\n         ty::TyClosure(def_id, _) => Some(def_id),\n+        ty::TyGenerator(def_id, _, _) => Some(def_id),\n \n         ty::TyBool |\n         ty::TyChar |"}, {"sha": "df6fa05a962f7557c605af265781e7e44444d4ab", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -1226,7 +1226,17 @@ impl<'a, 'tcx> Layout {\n                 Univariant { variant: unit, non_zero: false }\n             }\n \n-            // Tuples and closures.\n+            // Tuples, generators and closures.\n+            ty::TyGenerator(def_id, ref substs, _) => {\n+                let tys = substs.field_tys(def_id, tcx);\n+                let st = Struct::new(dl,\n+                    &tys.map(|ty| ty.layout(tcx, param_env))\n+                      .collect::<Result<Vec<_>, _>>()?,\n+                    &ReprOptions::default(),\n+                    StructKind::AlwaysSizedUnivariant, ty)?;\n+                Univariant { variant: st, non_zero: false }\n+            }\n+\n             ty::TyClosure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n                 let st = Struct::new(dl,\n@@ -2240,11 +2250,15 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n             ty::TySlice(element) => element,\n             ty::TyStr => tcx.types.u8,\n \n-            // Tuples and closures.\n+            // Tuples, generators and closures.\n             ty::TyClosure(def_id, ref substs) => {\n                 substs.upvar_tys(def_id, tcx).nth(i).unwrap()\n             }\n \n+            ty::TyGenerator(def_id, ref substs, _) => {\n+                substs.field_tys(def_id, tcx).nth(i).unwrap()\n+            }\n+\n             ty::TyTuple(tys, _) => tys[i],\n \n             // SIMD vector types."}, {"sha": "1d436834b22e5219a4eeedb4ee157e83e278256f", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -540,8 +540,13 @@ macro_rules! define_maps {\n \n         impl<$tcx> Query<$tcx> {\n             pub fn describe(&self, tcx: TyCtxt) -> String {\n-                match *self {\n-                    $(Query::$name(key) => queries::$name::describe(tcx, key)),*\n+                let (r, name) = match *self {\n+                    $(Query::$name(key) => (queries::$name::describe(tcx, key), stringify!($name))),*\n+                };\n+                if tcx.sess.verbose() {\n+                    format!(\"{} [{}]\", r, name)\n+                } else {\n+                    r\n                 }\n             }\n         }\n@@ -909,6 +914,10 @@ define_maps! { <'tcx>\n     /// The signature of functions and closures.\n     [] fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n+    /// Records the signature of each generator. The def ID is the ID of the\n+    /// expression defining the closure.\n+    [] generator_sig: TypeckTables(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n+\n     /// Caches CoerceUnsized kinds for impls on custom types.\n     [] coerce_unsized_info: CoerceUnsizedInfo(DefId)\n         -> ty::adjustment::CoerceUnsizedInfo,"}, {"sha": "cfcb0c062ad22bd9068854904e8706cf7f265d30", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -25,6 +25,7 @@ use middle::privacy::AccessLevels;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n use middle::region::CodeExtent;\n use mir::Mir;\n+use mir::GeneratorLayout;\n use traits;\n use ty;\n use ty::subst::{Subst, Substs};\n@@ -59,9 +60,9 @@ use rustc_data_structures::transitive_relation::TransitiveRelation;\n use hir;\n \n pub use self::sty::{Binder, DebruijnIndex};\n-pub use self::sty::{FnSig, PolyFnSig};\n+pub use self::sty::{FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n-pub use self::sty::{ClosureSubsts, TypeAndMut};\n+pub use self::sty::{ClosureSubsts, GeneratorInterior, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n@@ -1699,7 +1700,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         let result = match ty.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n             TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyArray(..) | TyClosure(..) | TyNever => {\n+            TyArray(..) | TyClosure(..) | TyGenerator(..) | TyNever => {\n                 vec![]\n             }\n \n@@ -1976,6 +1977,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     },\n                 }\n             },\n+            Some(hir_map::NodeImplArg(_)) => Symbol::intern(\"impl arg\").as_str(),\n             r => bug!(\"Variable id {} maps to {:?}, not local\", id, r),\n         }\n     }\n@@ -1996,6 +1998,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprUnary(hir::UnDeref, _) |\n             hir::ExprField(..) |\n             hir::ExprTupField(..) |\n+            hir::ExprImplArg(_) |\n             hir::ExprIndex(..) => {\n                 true\n             }\n@@ -2027,6 +2030,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprBox(..) |\n             hir::ExprAddrOf(..) |\n             hir::ExprBinary(..) |\n+            hir::ExprSuspend(..) |\n             hir::ExprCast(..) => {\n                 false\n             }\n@@ -2258,6 +2262,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.trait_def(trait_def_id).has_default_impl\n     }\n \n+    pub fn generator_layout(self, def_id: DefId) -> &'tcx GeneratorLayout<'tcx> {\n+        self.optimized_mir(def_id).generator_layout.as_ref().unwrap()\n+    }\n+\n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n     /// If it implements no trait, return `None`.\n     pub fn trait_id_of_impl(self, def_id: DefId) -> Option<DefId> {"}, {"sha": "3549a7706439edf287e0c37b4a35546da6094a01", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -115,6 +115,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            ty::TyGenerator(def_id, ref substs, ref interior) => {\n+                // Same as the closure case\n+                for upvar_ty in substs.upvar_tys(def_id, *self) {\n+                    self.compute_components(upvar_ty, out);\n+                }\n+\n+                // But generators can have additional interior types\n+                self.compute_components(interior.witness(), out);\n+            }\n+\n             // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n             // is implied by the environment is done in regionck.\n             ty::TyParam(p) => {"}, {"sha": "437f511cb3d0ea7c92ebf89dfceb7d516b438f7d", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -389,6 +389,18 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound))\n         }\n \n+        (&ty::TyGenerator(a_id, a_substs, a_interior),\n+         &ty::TyGenerator(b_id, b_substs, b_interior))\n+            if a_id == b_id =>\n+        {\n+            // All TyGenerator types with the same id represent\n+            // the (anonymous) type of the same generator expression. So\n+            // all of their regions should be equated.\n+            let substs = relation.relate(&a_substs, &b_substs)?;\n+            let interior = relation.relate(&a_interior, &b_interior)?;\n+            Ok(tcx.mk_generator(a_id, substs, interior))\n+        }\n+\n         (&ty::TyClosure(a_id, a_substs),\n          &ty::TyClosure(b_id, b_substs))\n             if a_id == b_id =>\n@@ -512,6 +524,18 @@ impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ty::GeneratorInterior<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::GeneratorInterior<'tcx>,\n+                           b: &ty::GeneratorInterior<'tcx>)\n+                           -> RelateResult<'tcx, ty::GeneratorInterior<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    {\n+        let interior = relation.relate(&a.witness(), &b.witness())?;\n+        Ok(ty::GeneratorInterior::new(interior))\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for &'tcx Substs<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &&'tcx Substs<'tcx>,"}, {"sha": "63a09435feaa9229cae54e5619b0c22907a29678", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -29,6 +29,15 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     }\n }\n \n+impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C) {\n+    type Lifted = (A::Lifted, B::Lifted, C::Lifted);\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.0).and_then(|a| {\n+            tcx.lift(&self.1).and_then(|b| tcx.lift(&self.2).map(|c| (a, b, c)))\n+        })\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n     type Lifted = Option<T::Lifted>;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -220,6 +229,15 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorInterior<'a> {\n+    type Lifted = ty::GeneratorInterior<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.witness()).map(|witness| {\n+            ty::GeneratorInterior(witness)\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n     type Lifted = ty::adjustment::Adjustment<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -283,6 +301,19 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n+    type Lifted = ty::GenSig<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.impl_arg_ty, self.suspend_ty, self.return_ty)).map(|(impl_arg_ty, suspend_ty, return_ty)| {\n+            ty::GenSig {\n+                impl_arg_ty,\n+                suspend_ty,\n+                return_ty,\n+            }\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -541,6 +572,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyRef(ref r, tm) => {\n                 ty::TyRef(r.fold_with(folder), tm.fold_with(folder))\n             }\n+            ty::TyGenerator(did, substs, interior) => ty::TyGenerator(did, substs.fold_with(folder), interior.fold_with(folder)),\n             ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n             ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n             ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n@@ -572,6 +604,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyFnDef(_, substs) => substs.visit_with(visitor),\n             ty::TyFnPtr(ref f) => f.visit_with(visitor),\n             ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n+            ty::TyGenerator(_did, ref substs, ref interior) => substs.visit_with(visitor) || interior.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyProjection(ref data) => data.visit_with(visitor),\n             ty::TyAnon(_, ref substs) => substs.visit_with(visitor),\n@@ -596,6 +629,22 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::GenSig<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::GenSig {\n+            impl_arg_ty: self.impl_arg_ty.fold_with(folder),\n+            suspend_ty: self.suspend_ty.fold_with(folder),\n+            return_ty: self.return_ty.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.impl_arg_ty.visit_with(visitor) ||\n+        self.suspend_ty.visit_with(visitor) ||\n+        self.return_ty.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let inputs_and_output = self.inputs_and_output.fold_with(folder);\n@@ -686,6 +735,16 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::GeneratorInterior<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::GeneratorInterior(self.0.fold_with(folder))\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.0.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::Adjustment<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::adjustment::Adjustment {"}, {"sha": "7d703ebc8541fadbbaa214d9f2cc1f0b47051319", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -149,6 +149,9 @@ pub enum TypeVariants<'tcx> {\n     /// `|a| a`.\n     TyClosure(DefId, ClosureSubsts<'tcx>),\n \n+    /// The anonymous type of a generator. Pairs with a TyClosure for closure generators.\n+    TyGenerator(DefId, ClosureSubsts<'tcx>, GeneratorInterior<'tcx>),\n+\n     /// The never type `!`\n     TyNever,\n \n@@ -275,6 +278,50 @@ impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> ClosureSubsts<'tcx> {\n+    pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n+        impl Iterator<Item=Ty<'tcx>> + 'tcx\n+    {\n+        let state = tcx.generator_layout(def_id).fields.iter();\n+        let state: Vec<_> = state.map(|d| d.ty.subst(tcx, self.substs)).collect();\n+        state.into_iter()\n+    }\n+\n+    pub fn field_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n+        impl Iterator<Item=Ty<'tcx>> + 'tcx\n+    {\n+        let upvars = self.upvar_tys(def_id, tcx);\n+        let state = self.state_tys(def_id, tcx);\n+        let tys: Vec<_> = upvars.chain(iter::once(tcx.types.u32)).chain(state).collect();\n+        tys.into_iter()\n+    }\n+}\n+\n+/// This describes the types that can be contained in a generator.\n+/// It will be a type variable initially and unified in the last stages of typeck of a body.\n+/// It contains a tuple of all the types that could end up on a generator frame.\n+/// The state transformation MIR pass may only produce layouts which mention types in this tuple.\n+/// Upvars are not counted here.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct GeneratorInterior<'tcx>(pub Ty<'tcx>);\n+\n+impl<'tcx> GeneratorInterior<'tcx> {\n+    pub fn new(witness: Ty<'tcx>) -> GeneratorInterior<'tcx> {\n+        GeneratorInterior(witness)\n+    }\n+\n+    pub fn witness(&self) -> Ty<'tcx> {\n+        self.0\n+    }\n+\n+    pub fn as_slice(&self) -> &'tcx Slice<Ty<'tcx>> {\n+        match self.0.sty {\n+            ty::TyTuple(s, _) => s,\n+            _ => bug!(),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum ExistentialPredicate<'tcx> {\n     /// e.g. Iterator\n@@ -593,6 +640,25 @@ impl<'a, 'tcx> ProjectionTy<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct GenSig<'tcx> {\n+    pub impl_arg_ty: Ty<'tcx>,\n+    pub suspend_ty: Ty<'tcx>,\n+    pub return_ty: Ty<'tcx>,\n+}\n+\n+#[allow(warnings)]\n+pub type PolyGenSig<'tcx> = Binder<GenSig<'tcx>>;\n+\n+#[allow(warnings)]\n+impl<'tcx> PolyGenSig<'tcx> {\n+    pub fn suspend_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+        self.map_bound_ref(|sig| sig.suspend_ty)\n+    }\n+    pub fn return_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+        self.map_bound_ref(|sig| sig.return_ty)\n+    }\n+}\n \n /// Signature of a function type, which I have arbitrarily\n /// decided to use to refer to the input/output types.\n@@ -1393,7 +1459,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TyAdt(_, substs) | TyAnon(_, substs) => {\n                 substs.regions().collect()\n             }\n-            TyClosure(_, ref substs) => {\n+            TyClosure(_, ref substs) | TyGenerator(_, ref substs, _) => {\n                 substs.substs.regions().collect()\n             }\n             TyProjection(ref data) => {"}, {"sha": "6bbcc674ef408609c88b40c7988c2045a91c156c", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -27,6 +27,7 @@ use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n use rustc_data_structures::fx::FxHashMap;\n use std::cmp;\n+use std::iter;\n use std::hash::Hash;\n use std::intrinsics;\n use syntax::ast::{self, Name};\n@@ -568,6 +569,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }).collect()\n             }\n \n+            ty::TyGenerator(def_id, substs, interior) => {\n+                substs.upvar_tys(def_id, self).chain(iter::once(interior.witness())).map(|ty| {\n+                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n+                }).collect()\n+            }\n+\n             ty::TyAdt(def, substs) => {\n                 let ty::DtorckConstraint {\n                     dtorck_types, outlives\n@@ -689,6 +696,7 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n+            TyGenerator(def_id, _, _) |\n             TyAnon(def_id, _) |\n             TyFnDef(def_id, _) => self.def_id(def_id),\n             TyAdt(d, _) => self.def_id(d.did),\n@@ -1111,6 +1119,8 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         ty::TyClosure(def_id, ref substs) => substs.upvar_tys(def_id, tcx).any(needs_drop),\n \n+        ty::TyGenerator(..) => true,\n+\n         ty::TyTuple(ref tys, _) => tys.iter().cloned().any(needs_drop),\n \n         // unions don't have destructors regardless of the child types"}, {"sha": "a2087b0b2f1bf185c7c6bedc77b14667f5c99aa3", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -112,6 +112,10 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::TyClosure(_, ref substs) => {\n             stack.extend(substs.substs.types().rev());\n         }\n+        ty::TyGenerator(_, ref substs, ref interior) => {\n+            stack.extend(substs.substs.types().rev());\n+            stack.push(interior.witness());\n+        }\n         ty::TyTuple(ts, _) => {\n             stack.extend(ts.iter().cloned().rev());\n         }"}, {"sha": "e2abd16d001bcdae344aa290fc1c97f5345c1db0", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -239,8 +239,8 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::TyClosure(..) => {\n-                    // the types in a closure are always the types of\n+                ty::TyGenerator(..) | ty::TyClosure(..) => {\n+                    // the types in a closure or generator are always the types of\n                     // local variables (or possibly references to local\n                     // variables), we'll walk those.\n                     //"}, {"sha": "33ab83d236f7ca509d4136b9ae2b4f2e393b50f6", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -17,7 +17,7 @@ use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n-use ty::{TyClosure, TyProjection, TyAnon};\n+use ty::{TyClosure, TyGenerator, TyProjection, TyAnon};\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n@@ -715,6 +715,12 @@ impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Display for ty::GeneratorInterior<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.0)\n+    }\n+}\n+\n impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -813,6 +819,41 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 })\n             }\n             TyStr => write!(f, \"str\"),\n+            TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n+                let upvar_tys = substs.upvar_tys(did, tcx);\n+                write!(f, \"[generator\")?;\n+\n+                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+                    write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n+                    let mut sep = \" \";\n+                    tcx.with_freevars(node_id, |freevars| {\n+                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n+                            let def_id = freevar.def.def_id();\n+                            let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+                            write!(f,\n+                                        \"{}{}:{}\",\n+                                        sep,\n+                                        tcx.local_var_name_str(node_id),\n+                                        upvar_ty)?;\n+                            sep = \", \";\n+                        }\n+                        Ok(())\n+                    })?\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in trans bug reports, I imagine.\n+                    write!(f, \"@{:?}\", did)?;\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n+                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n+                        sep = \", \";\n+                    }\n+                }\n+\n+                write!(f, \" {}\", interior)?;\n+\n+                write!(f, \"]\")\n+            }),\n             TyClosure(did, substs) => ty::tls::with(|tcx| {\n                 let upvar_tys = substs.upvar_tys(did, tcx);\n                 write!(f, \"[closure\")?;"}, {"sha": "6fbe954b9c64e5e601a1a49a2611fba1ced12dab", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -21,6 +21,7 @@ use borrowck::move_data::MoveData;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n+use rustc::middle::region::extent_has_yield;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n \n@@ -36,19 +37,20 @@ mod gather_moves;\n mod move_error;\n \n pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    body: hir::BodyId)\n+                                    body_id: hir::BodyId)\n                                     -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>) {\n-    let def_id = bccx.tcx.hir.body_owner_def_id(body);\n+    let def_id = bccx.tcx.hir.body_owner_def_id(body_id);\n     let param_env = bccx.tcx.param_env(def_id);\n+    let body = bccx.tcx.hir.body(body_id);\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         all_loans: Vec::new(),\n-        item_ub: region::CodeExtent::Misc(body.node_id),\n+        item_ub: region::CodeExtent::Misc(body_id.node_id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n+        generator: body.is_generator(),\n     };\n \n-    let body = glcx.bccx.tcx.hir.body(body);\n     euv::ExprUseVisitor::new(&mut glcx, bccx.tcx, param_env, &bccx.region_maps, bccx.tables)\n         .consume_body(body);\n \n@@ -65,6 +67,7 @@ struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     /// `item_ub` is used as an upper-bound on the lifetime whenever we\n     /// ask for the scope of an expression categorized as an upvar.\n     item_ub: region::CodeExtent,\n+    generator: bool,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n@@ -134,6 +137,21 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n+         let borrows_impl_arg = match cmt.cat {\n+             Categorization::Local(id) => match self.bccx.tcx.hir.find(id) {\n+                 Some(hir::map::NodeImplArg(..)) => true,\n+                 _ => false,\n+             },\n+             _ => false,\n+         };\n+ \n+         if borrows_impl_arg {\n+             span_err!(self.bccx.tcx.sess,\n+                borrow_span,\n+                E0805,\n+                \"cannot borrow the implicit argument of a generator\");\n+         }\n+\n         self.guarantee_valid(borrow_id,\n                              borrow_span,\n                              cmt,\n@@ -201,6 +219,19 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     }\n }\n \n+fn check_yields<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                          borrow_span: Span,\n+                          loan_region: ty::Region<'tcx>) {\n+    if let &ty::RegionKind::ReScope(extent) = loan_region {\n+        if extent_has_yield(bccx.tcx, extent) {\n+             span_err!(bccx.tcx.sess,\n+                borrow_span,\n+                E0806,\n+                \"cannot borrow this value across the suspend point of a generator\");\n+        }\n+    }\n+}\n+\n /// Implements the M-* rules in README.md.\n fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                               borrow_span: Span,\n@@ -312,6 +343,11 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             return;\n         }\n \n+        // Check that the region has no yields if this is in a generator\n+        if self.generator {\n+            check_yields(self.bccx, borrow_span, loan_region);\n+        }\n+\n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n         if lifetime::guarantee_lifetime(self.bccx, self.item_ub,"}, {"sha": "a0c9a311e05e57bc9267a65e446c21c456c69be2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -306,7 +306,7 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                         tcx: TyCtxt) -> ast::NodeId {\n     match tcx.hir.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n-            hir::ExprClosure(.., body_id, _) => {\n+            hir::ExprClosure(.., body_id, _, _) => {\n                 body_id.node_id\n             }\n             _ => {\n@@ -609,7 +609,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n             move_data::Captured =>\n                 (match self.tcx.hir.expect_expr(the_move.id).node {\n-                    hir::ExprClosure(.., fn_decl_span) => fn_decl_span,\n+                    hir::ExprClosure(.., fn_decl_span, _) => fn_decl_span,\n                     ref r => bug!(\"Captured({}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n                 }, \" (into closure)\"),"}, {"sha": "415b633a623a21a1759b3007ffdf9a4eafffebda", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -1191,4 +1191,6 @@ register_diagnostics! {\n     E0594, // cannot assign to {}\n     E0595, // closure cannot assign to {}\n     E0598, // lifetime of {} is too short to guarantee its contents can be...\n+    E0805, // borrow of the implicit argument of a generator\n+    E0806, // borrow across a suspend point\n }"}, {"sha": "821e2b01431c575bd666cabe98ec0466a07b65a5", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -21,6 +21,7 @@ use indexed_vec::Idx;\n ///\n /// In other words, `T` is the type used to index into the bitvector\n /// this type uses to represent the set of object it holds.\n+#[derive(Eq, PartialEq)]\n pub struct IdxSetBuf<T: Idx> {\n     _pd: PhantomData<fn(&T)>,\n     bits: Vec<Word>,\n@@ -109,6 +110,13 @@ impl<T: Idx> IdxSet<T> {\n         }\n     }\n \n+    /// Removes all elements\n+    pub fn clear(&mut self) {\n+        for b in &mut self.bits {\n+            *b = 0;\n+        }\n+    }\n+\n     /// Removes `elem` from the set `self`; returns true iff this changed `self`.\n     pub fn remove(&mut self, elem: &T) -> bool {\n         self.bits.clear_bit(elem.index())"}, {"sha": "8e2a759b46794c50493d2cd4087e8b584b7baa51", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -38,7 +38,7 @@ impl Idx for u32 {\n     fn index(self) -> usize { self as usize }\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, PartialEq, Eq)]\n pub struct IndexVec<I: Idx, T> {\n     pub raw: Vec<T>,\n     _marker: PhantomData<Fn(&I)>"}, {"sha": "866261b4f63dd4600d0a7a3f0a87e8ce80a6d79a", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -292,6 +292,15 @@ impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n     }\n }\n \n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Box<T> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (**self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ::std::rc::Rc<T> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "704d3568ca3cd9c9273f5ac75960defc985fada7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -957,6 +957,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::deaggregator::Deaggregator);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::copy_prop::CopyPropagation);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyLocals);\n+\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::generator::StateTransform);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n+\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AddCallGuards);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::dump_mir::Marker(\"PreTrans\"));\n "}, {"sha": "31aa8c0316aac78e4f8e7aaf5b93f4456c9f4374", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -607,6 +607,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::TyInfer(..) |\n             ty::TyError |\n             ty::TyClosure(..) |\n+            ty::TyGenerator(..) |\n             ty::TyProjection(..) |\n             ty::TyAnon(..) |\n             ty::TyFnDef(..) => bug!(\"Unexpected type in foreign function\"),"}, {"sha": "4c883f3e014f1fdc7447ef0a9c8764c157a228ba", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -104,6 +104,7 @@ provide! { <'tcx> tcx, def_id, cdata,\n \n         mir\n     }\n+    generator_sig => { cdata.generator_sig(def_id.index, tcx) }\n     mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n     typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }"}, {"sha": "2ee5b07347fb31b538113f6889479c6da9dca2f1", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -438,6 +438,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Impl(_) |\n             EntryKind::DefaultImpl(_) |\n             EntryKind::Field |\n+            EntryKind::Generator(_) |\n             EntryKind::Closure(_) => return None,\n         })\n     }\n@@ -1100,6 +1101,23 @@ impl<'a, 'tcx> CrateMetadata {\n         sig.decode((self, tcx))\n     }\n \n+    fn get_generator_data(&self,\n+                      id: DefIndex,\n+                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                      -> Option<GeneratorData<'tcx>> {\n+        match self.entry(id).kind {\n+            EntryKind::Generator(data) => Some(data.decode((self, tcx))),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn generator_sig(&self,\n+                      id: DefIndex,\n+                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                      -> Option<ty::PolyGenSig<'tcx>> {\n+        self.get_generator_data(id, tcx).map(|d| d.sig)\n+    }\n+\n     #[inline]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n         self.def_path_table.def_key(index)"}, {"sha": "d29c2746092c99a47668dc0eefd62d4d652f722b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -1213,13 +1213,23 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_closure({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let data = ClosureData {\n-            kind: tcx.closure_kind(def_id),\n-            sig: self.lazy(&tcx.fn_sig(def_id)),\n+        let kind = if let Some(sig) = self.tcx.generator_sig(def_id) {\n+            let layout = self.tcx.generator_layout(def_id);\n+            let data = GeneratorData {\n+                sig,\n+                layout: layout.clone(),\n+            };\n+            EntryKind::Generator(self.lazy(&data))\n+        } else {\n+            let data = ClosureData {\n+                kind: tcx.closure_kind(def_id),\n+                sig: self.lazy(&tcx.fn_sig(def_id)),\n+            };\n+            EntryKind::Closure(self.lazy(&data))\n         };\n \n         Entry {\n-            kind: EntryKind::Closure(self.lazy(&data)),\n+            kind,\n             visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: self.encode_attributes(&tcx.get_attrs(def_id)),"}, {"sha": "567da85b61c3a59d1b21df9463649655c0f3c404", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -353,6 +353,7 @@ pub enum EntryKind<'tcx> {\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n     Closure(Lazy<ClosureData<'tcx>>),\n+    Generator(Lazy<GeneratorData<'tcx>>),\n     Trait(Lazy<TraitData<'tcx>>),\n     Impl(Lazy<ImplData<'tcx>>),\n     DefaultImpl(Lazy<ImplData<'tcx>>),\n@@ -401,6 +402,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for EntryK\n             EntryKind::MacroDef(ref macro_def) => {\n                 macro_def.hash_stable(hcx, hasher);\n             }\n+            EntryKind::Generator(data) => {\n+                data.hash_stable(hcx, hasher);\n+            }\n             EntryKind::Closure(closure_data) => {\n                 closure_data.hash_stable(hcx, hasher);\n             }\n@@ -564,3 +568,10 @@ pub struct ClosureData<'tcx> {\n     pub sig: Lazy<ty::PolyFnSig<'tcx>>,\n }\n impl_stable_hash_for!(struct ClosureData<'tcx> { kind, sig });\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct GeneratorData<'tcx> {\n+    pub sig: ty::PolyGenSig<'tcx>,\n+    pub layout: mir::GeneratorLayout<'tcx>,\n+}\n+impl_stable_hash_for!(struct GeneratorData<'tcx> { sig, layout });"}, {"sha": "78175e0535101000b888188e64340d6ba88419e2", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -80,6 +80,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 success.and(slice.index(idx))\n             }\n             ExprKind::SelfRef => {\n+                block.and(Lvalue::Local(Local::new(this.arg_offset + 1)))\n+            }\n+            ExprKind::ImplArg => {\n                 block.and(Lvalue::Local(Local::new(1)))\n             }\n             ExprKind::VarRef { id } => {\n@@ -118,6 +121,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Return { .. } |\n             ExprKind::Literal { .. } |\n             ExprKind::InlineAsm { .. } |\n+            ExprKind::Suspend { .. } |\n             ExprKind::Call { .. } => {\n                 // these are not lvalues, so we need to make a temporary.\n                 debug_assert!(match Category::of(&expr.kind) {"}, {"sha": "6af7bd056b4a3180b78e68f2d0b0256dee33a800", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -179,12 +179,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n             }\n-            ExprKind::Closure { closure_id, substs, upvars } => { // see (*) above\n-                let upvars =\n+            ExprKind::Closure { closure_id, substs, upvars, generator } => { // see (*) above\n+                let mut operands: Vec<_> =\n                     upvars.into_iter()\n                           .map(|upvar| unpack!(block = this.as_operand(block, scope, upvar)))\n                           .collect();\n-                block.and(Rvalue::Aggregate(box AggregateKind::Closure(closure_id, substs), upvars))\n+                let result = if generator {\n+                    // Add the state operand\n+                    operands.push(Operand::Constant(box Constant {\n+                        span: expr_span,\n+                        ty: this.hir.tcx().types.u32,\n+                        literal: Literal::Value {\n+                            value: ConstVal::Integral(ConstInt::U32(0)),\n+                        },\n+                    }));\n+                    box AggregateKind::Generator(closure_id, substs)\n+                } else {\n+                    box AggregateKind::Closure(closure_id, substs)\n+                };\n+                block.and(Rvalue::Aggregate(result, operands))\n             }\n             ExprKind::Adt {\n                 adt_def, variant_index, substs, fields, base\n@@ -226,6 +239,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block = unpack!(this.stmt_expr(block, expr));\n                 block.and(this.unit_rvalue())\n             }\n+            ExprKind::Suspend { value } => {\n+                let value = unpack!(block = this.as_operand(block, scope, value));\n+                let impl_arg_ty = this.impl_arg_ty.unwrap();\n+                block = unpack!(this.build_drop(block,\n+                    expr_span,\n+                    Lvalue::Local(Local::new(1)),\n+                    impl_arg_ty));\n+                let resume = this.cfg.start_new_block();\n+                let cleanup = this.generator_drop_cleanup(expr_span);\n+                this.cfg.terminate(block, source_info, TerminatorKind::Suspend {\n+                    value: value,\n+                    resume: resume,\n+                    drop: cleanup,\n+                });\n+                resume.and(this.unit_rvalue())\n+            }\n             ExprKind::Literal { .. } |\n             ExprKind::Block { .. } |\n             ExprKind::Match { .. } |\n@@ -243,6 +272,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Continue { .. } |\n             ExprKind::Return { .. } |\n             ExprKind::InlineAsm { .. } |\n+            ExprKind::ImplArg |\n             ExprKind::StaticRef { .. } => {\n                 // these do not have corresponding `Rvalue` variants,\n                 // so make an operand and then return that"}, {"sha": "041e8fe475d0028643ed48a80f33820439e77251", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // anything because no values with a destructor can be created in\n         // a constant at this time, even if the type may need dropping.\n         if let Some(temp_lifetime) = temp_lifetime {\n-            this.schedule_drop(expr_span, temp_lifetime, &temp, expr_ty);\n+            this.schedule_drop(expr_span, temp_lifetime, &temp, expr_ty, false);\n         }\n \n         block.and(temp)"}, {"sha": "0208dbf70349f689ddb76b9256e8def91af0f4e9", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -50,6 +50,7 @@ impl Category {\n             ExprKind::Index { .. } |\n             ExprKind::SelfRef |\n             ExprKind::VarRef { .. } |\n+            ExprKind::ImplArg |\n             ExprKind::StaticRef { .. } =>\n                 Some(Category::Lvalue),\n \n@@ -77,6 +78,7 @@ impl Category {\n             ExprKind::Borrow { .. } |\n             ExprKind::Assign { .. } |\n             ExprKind::AssignOp { .. } |\n+            ExprKind::Suspend { .. } |\n             ExprKind::InlineAsm { .. } =>\n                 Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n "}, {"sha": "ee5b04d03be317f6fbadd4590f8ccd90a5595ad5", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -284,6 +284,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Index { .. } |\n             ExprKind::Deref { .. } |\n             ExprKind::Literal { .. } |\n+            ExprKind::Suspend { .. } |\n+            ExprKind::ImplArg |\n             ExprKind::Field { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n                     Category::Rvalue(RvalueFunc::Into) => false,"}, {"sha": "9e96ae474d0a8b39f38e4ed37b0ba5cc6fcc5f44", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -203,7 +203,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let local_id = self.var_indices[&var];\n         let var_ty = self.local_decls[local_id].ty;\n         let extent = self.hir.region_maps.var_scope(var);\n-        self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty);\n+        self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty, false);\n     }\n \n     pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, mut f: &mut F)"}, {"sha": "09e891021b1c1dd8fb5896ac2d39911c124015a5", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 67, "deletions": 20, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -71,7 +71,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             // Assume that everything other than closures\n             // is a constant \"initializer\" expression.\n             match expr.node {\n-                hir::ExprClosure(_, _, body, _) => body,\n+                hir::ExprClosure(_, _, body, _, _) => body,\n                 _ => hir::BodyId { node_id: expr.id }\n             }\n         }\n@@ -94,13 +94,18 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n             let ty = tcx.type_of(tcx.hir.local_def_id(id));\n             let mut abi = fn_sig.abi;\n-            let implicit_argument = if let ty::TyClosure(..) = ty.sty {\n-                // HACK(eddyb) Avoid having RustCall on closures,\n-                // as it adds unnecessary (and wrong) auto-tupling.\n-                abi = Abi::Rust;\n-                Some((closure_self_ty(tcx, id, body_id), None))\n-            } else {\n-                None\n+            let implicit_argument = match ty.sty {\n+                ty::TyClosure(..) => {\n+                    // HACK(eddyb) Avoid having RustCall on closures,\n+                    // as it adds unnecessary (and wrong) auto-tupling.\n+                    abi = Abi::Rust;\n+                    Some((closure_self_ty(tcx, id, body_id), None))\n+                }\n+                ty::TyGenerator(..) => {\n+                    let gen_ty =  tcx.body_tables(body_id).node_id_to_type(id);\n+                    Some((gen_ty, None))\n+                }\n+                _ => None,\n             };\n \n             let body = tcx.hir.body(body_id);\n@@ -113,7 +118,15 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     });\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n-            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n+            \n+            let (suspend_ty, impl_arg_ty, return_ty) = if body.is_generator() {\n+                let gen_sig = cx.tables().generator_sigs[&id].clone().unwrap();\n+                (Some(gen_sig.suspend_ty), Some(gen_sig.impl_arg_ty), gen_sig.return_ty)\n+            } else {\n+                (None, None, fn_sig.output())\n+            };\n+            \n+            build::construct_fn(cx, id, arguments, abi, return_ty, suspend_ty, impl_arg_ty, body)\n         } else {\n             build::construct_const(cx, body_id)\n         };\n@@ -198,7 +211,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: hir::BodyId)\n                              -> Ty<'tcx> {\n@@ -231,6 +244,9 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     fn_span: Span,\n     arg_count: usize,\n+    arg_offset: usize,\n+\n+    impl_arg_ty: Option<Ty<'tcx>>,\n \n     /// the current set of scopes, updated as we traverse;\n     /// see the `scope` module for more details\n@@ -326,6 +342,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    arguments: A,\n                                    abi: Abi,\n                                    return_ty: Ty<'gcx>,\n+                                   suspend_ty: Option<Ty<'gcx>>,\n+                                   impl_arg_ty: Option<Ty<'gcx>>,\n                                    body: &'gcx hir::Body)\n                                    -> Mir<'tcx>\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n@@ -334,15 +352,21 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let tcx = hir.tcx();\n     let span = tcx.hir.span(fn_id);\n-    let mut builder = Builder::new(hir.clone(), span, arguments.len(), return_ty);\n+    let arg_offset = if impl_arg_ty.is_some() { 1 } else { 0 };\n+    let mut builder = Builder::new(hir.clone(),\n+        span,\n+        arguments.len() + arg_offset,\n+        arg_offset,\n+        impl_arg_ty,\n+        return_ty);\n \n     let call_site_extent = CodeExtent::CallSiteScope(body.id());\n     let arg_extent = CodeExtent::ParameterScope(body.id());\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n     unpack!(block = builder.in_scope((call_site_extent, source_info), block, |builder| {\n         unpack!(block = builder.in_scope((arg_extent, source_info), block, |builder| {\n-            builder.args_and_body(block, &arguments, arg_extent, &body.value)\n+            builder.args_and_body(block, &arguments, arg_extent, impl_arg_ty, &body.value)\n         }));\n         // Attribute epilogue to function's closing brace\n         let fn_end = Span { lo: span.hi, ..span };\n@@ -387,7 +411,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         }).collect()\n     });\n \n-    let mut mir = builder.finish(upvar_decls, return_ty);\n+    let mut mir = builder.finish(upvar_decls, return_ty, suspend_ty);\n     mir.spread_arg = spread_arg;\n     mir\n }\n@@ -400,7 +424,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n     let owner_id = tcx.hir.body_owner(body_id);\n     let span = tcx.hir.span(owner_id);\n-    let mut builder = Builder::new(hir.clone(), span, 0, ty);\n+    let mut builder = Builder::new(hir.clone(), span, 0, 0, None, ty);\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n@@ -412,31 +436,35 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     // Constants can't `return` so a return block should not be created.\n     assert_eq!(builder.cached_return_block, None);\n \n-    builder.finish(vec![], ty)\n+    builder.finish(vec![], ty, None)\n }\n \n fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        body_id: hir::BodyId)\n                                        -> Mir<'tcx> {\n     let span = hir.tcx().hir.span(hir.tcx().hir.body_owner(body_id));\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, ty);\n+    let mut builder = Builder::new(hir, span, 0, 0, None, ty);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n-    builder.finish(vec![], ty)\n+    builder.finish(vec![], ty, None)\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn new(hir: Cx<'a, 'gcx, 'tcx>,\n            span: Span,\n            arg_count: usize,\n+           arg_offset: usize,\n+           impl_arg_ty: Option<Ty<'tcx>>,\n            return_ty: Ty<'tcx>)\n            -> Builder<'a, 'gcx, 'tcx> {\n         let mut builder = Builder {\n             hir: hir,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,\n             arg_count: arg_count,\n+            arg_offset,\n+            impl_arg_ty,\n             scopes: vec![],\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n@@ -458,7 +486,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn finish(self,\n               upvar_decls: Vec<UpvarDecl>,\n-              return_ty: Ty<'tcx>)\n+              return_ty: Ty<'tcx>,\n+              suspend_ty: Option<Ty<'tcx>>)\n               -> Mir<'tcx> {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n             if block.terminator.is_none() {\n@@ -470,6 +499,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                  self.visibility_scopes,\n                  IndexVec::new(),\n                  return_ty,\n+                 suspend_ty,\n                  self.local_decls,\n                  self.arg_count,\n                  upvar_decls,\n@@ -481,9 +511,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      mut block: BasicBlock,\n                      arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n                      argument_extent: CodeExtent,\n+                     impl_arg_ty: Option<Ty<'gcx>>,\n                      ast_body: &'gcx hir::Expr)\n                      -> BlockAnd<()>\n     {\n+        if let Some(impl_arg_ty) = impl_arg_ty {\n+            self.local_decls.push(LocalDecl {\n+                mutability: Mutability::Mut,\n+                ty: impl_arg_ty,\n+                is_user_variable: false,\n+                source_info:  SourceInfo {\n+                    scope: ARGUMENT_VISIBILITY_SCOPE,\n+                    span: self.fn_span,\n+                },\n+                name: None,\n+            });\n+            let lvalue = Lvalue::Local(Local::new(1));\n+            // Make sure we drop the argument on completion\n+            self.schedule_drop(ast_body.span, argument_extent, &lvalue, impl_arg_ty, true);\n+        };\n+\n         // Allocate locals for the function arguments\n         for &(ty, pattern) in arguments.iter() {\n             // If this is a simple binding pattern, give the local a nice name for debuginfo.\n@@ -510,7 +557,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // Bind the argument patterns\n         for (index, &(ty, pattern)) in arguments.iter().enumerate() {\n             // Function arguments always get the first Local indices after the return pointer\n-            let lvalue = Lvalue::Local(Local::new(index + 1));\n+            let lvalue = Lvalue::Local(Local::new(self.arg_offset + index + 1));\n \n             if let Some(pattern) = pattern {\n                 let pattern = Pattern::from_hir(self.hir.tcx().global_tcx(),\n@@ -523,7 +570,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(pattern.as_ref().map_or(ast_body.span, |pat| pat.span),\n-                               argument_extent, &lvalue, ty);\n+                               argument_extent, &lvalue, ty, false);\n \n         }\n "}, {"sha": "3ee33fbe162605ac33ee22c81a3d9e9c265dd2aa", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 164, "deletions": 30, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -124,6 +124,9 @@ pub struct Scope<'tcx> {\n     /// end of the vector (top of the stack) first.\n     drops: Vec<DropData<'tcx>>,\n \n+    /// Is the first drop the drop of the implicit argument?\n+    impl_arg_drop: bool,\n+\n     /// A scope may only have one associated free, because:\n     ///\n     /// 1. We require a `free` to only be scheduled in the scope of\n@@ -141,6 +144,9 @@ pub struct Scope<'tcx> {\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n     cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n+\n+    /// The cache for drop chain on \"generator drop\" exit.\n+    cached_generator_drop: Option<BasicBlock>,\n }\n \n #[derive(Debug)]\n@@ -155,14 +161,22 @@ struct DropData<'tcx> {\n     kind: DropKind\n }\n \n+#[derive(Debug, Default, Clone, Copy)]\n+struct CachedBlock {\n+    /// The cached block for the cleanups-on-diverge path. This block\n+    /// contains code to run the current drop and all the preceding\n+    /// drops (i.e. those having lower index in Drop\u2019s Scope drop\n+    /// array)\n+    unwind: Option<BasicBlock>,\n+\n+    /// The cached block for unwinds during cleanups-on-generator-drop path\n+    generator_drop: Option<BasicBlock>,\n+}\n+\n #[derive(Debug)]\n enum DropKind {\n     Value {\n-        /// The cached block for the cleanups-on-diverge path. This block\n-        /// contains code to run the current drop and all the preceding\n-        /// drops (i.e. those having lower index in Drop\u2019s Scope drop\n-        /// array)\n-        cached_block: Option<BasicBlock>\n+        cached_block: CachedBlock,\n     },\n     Storage\n }\n@@ -180,7 +194,7 @@ struct FreeData<'tcx> {\n \n     /// The cached block containing code to run the free. The block will also execute all the drops\n     /// in the scope.\n-    cached_block: Option<BasicBlock>\n+    cached_block: CachedBlock,\n }\n \n #[derive(Clone, Debug)]\n@@ -197,6 +211,29 @@ pub struct BreakableScope<'tcx> {\n     pub break_destination: Lvalue<'tcx>,\n }\n \n+impl CachedBlock {\n+    fn invalidate(&mut self) {\n+        self.generator_drop = None;\n+        self.unwind = None;\n+    }\n+\n+    fn get(&self, generator_drop: bool) -> Option<BasicBlock> {\n+        if generator_drop {\n+            self.generator_drop\n+        } else {\n+            self.unwind\n+        }\n+    }\n+\n+    fn ref_mut(&mut self, generator_drop: bool) -> &mut Option<BasicBlock> {\n+        if generator_drop {\n+            &mut self.generator_drop\n+        } else {\n+            &mut self.unwind\n+        }\n+    }\n+}\n+\n impl<'tcx> Scope<'tcx> {\n     /// Invalidate all the cached blocks in the scope.\n     ///\n@@ -209,29 +246,47 @@ impl<'tcx> Scope<'tcx> {\n         if !unwind { return; }\n         for dropdata in &mut self.drops {\n             if let DropKind::Value { ref mut cached_block } = dropdata.kind {\n-                *cached_block = None;\n+                cached_block.invalidate();\n             }\n         }\n         if let Some(ref mut freedata) = self.free {\n-            freedata.cached_block = None;\n+            freedata.cached_block.invalidate();\n+        }\n+    }\n+\n+    fn drops(&self, generator_drop: bool) -> &[DropData<'tcx>] {\n+        if self.impl_arg_drop && generator_drop {\n+            &self.drops[1..]\n+        } else {\n+            &self.drops[..]\n+        }\n+    }\n+\n+    fn drops_mut(&mut self, generator_drop: bool) -> &mut [DropData<'tcx>] {\n+        if self.impl_arg_drop && generator_drop {\n+            &mut self.drops[1..]\n+        } else {\n+            &mut self.drops[..]\n         }\n     }\n \n     /// Returns the cached entrypoint for diverging exit from this scope.\n     ///\n     /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n     /// this method to work correctly.\n-    fn cached_block(&self) -> Option<BasicBlock> {\n-        let mut drops = self.drops.iter().rev().filter_map(|data| {\n+    fn cached_block(&self, generator_drop: bool) -> Option<BasicBlock> {\n+        let mut drops = self.drops(generator_drop).iter().rev().filter_map(|data| {\n             match data.kind {\n-                DropKind::Value { cached_block } => Some(cached_block),\n+                DropKind::Value { cached_block } => {\n+                    Some(cached_block.get(generator_drop))\n+                }\n                 DropKind::Storage => None\n             }\n         });\n         if let Some(cached_block) = drops.next() {\n             Some(cached_block.expect(\"drop cache is not filled\"))\n         } else if let Some(ref data) = self.free {\n-            Some(data.cached_block.expect(\"free cache is not filled\"))\n+            Some(data.cached_block.get(generator_drop).expect(\"free cache is not filled\"))\n         } else {\n             None\n         }\n@@ -320,7 +375,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             extent: extent,\n             needs_cleanup: false,\n             drops: vec![],\n+            impl_arg_drop: false,\n             free: None,\n+            cached_generator_drop: None,\n             cached_exits: FxHashMap()\n         });\n     }\n@@ -342,7 +399,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                           &scope,\n                                           &self.scopes,\n                                           block,\n-                                          self.arg_count));\n+                                          self.arg_count,\n+                                          false));\n \n         self.cfg.push_end_region(block, extent.1, scope.extent);\n         block.unit()\n@@ -385,15 +443,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                               scope,\n                                               rest,\n                                               block,\n-                                              self.arg_count));\n+                                              self.arg_count,\n+                                              false));\n \n             // End all regions for scopes out of which we are breaking.\n             self.cfg.push_end_region(block, extent.1, scope.extent);\n \n             if let Some(ref free_data) = scope.free {\n                 let next = self.cfg.start_new_block();\n                 let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n-                self.cfg.terminate(block, scope.source_info(span), free);\n+                self.cfg.terminate(block, scope.source_info(free_data.span), free);\n                 block = next;\n             }\n         }\n@@ -403,6 +462,63 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                            TerminatorKind::Goto { target: target });\n     }\n \n+    /// Creates a path that performs all required cleanup for dropping a generator.\n+    ///\n+    /// This path terminates in GeneratorDrop. Returns the start of the path.\n+    /// None indicates there\u2019s no cleanup to do at this point.\n+    pub fn generator_drop_cleanup(&mut self, span: Span) -> Option<BasicBlock> {\n+        if !self.scopes.iter().any(|scope| scope.needs_cleanup) {\n+            return None;\n+        }\n+\n+        // Fill in the cache\n+        self.diverge_cleanup_gen(span, true);\n+\n+        let src_info = self.scopes[0].source_info(self.fn_span);\n+        let tmp = self.get_unit_temp();\n+        let mut block = self.cfg.start_new_block();\n+        let result = block;\n+        let mut rest = &mut self.scopes[..];\n+\n+        while let Some((scope, rest_)) = {rest}.split_last_mut() {\n+            rest = rest_;\n+            if !scope.needs_cleanup {\n+                continue;\n+            }\n+            block = if let Some(b) = scope.cached_generator_drop {\n+                self.cfg.terminate(block, src_info,\n+                                   TerminatorKind::Goto { target: b });\n+                return Some(result);\n+            } else {\n+                let b = self.cfg.start_new_block();\n+                scope.cached_generator_drop = Some(b);\n+                self.cfg.terminate(block, src_info,\n+                                   TerminatorKind::Goto { target: b });\n+                b\n+            };\n+            unpack!(block = build_scope_drops(&mut self.cfg,\n+                                              scope,\n+                                              rest,\n+                                              block,\n+                                              self.arg_count,\n+                                              true));\n+            \n+            // End all regions for scopes out of which we are breaking.\n+            self.cfg.push_end_region(block, src_info, scope.extent);\n+\n+            if let Some(ref free_data) = scope.free {\n+                let next = self.cfg.start_new_block();\n+                let free = build_free(self.hir.tcx(), &tmp, free_data, next);\n+                self.cfg.terminate(block, scope.source_info(free_data.span), free);\n+                block = next;\n+            }\n+        }\n+        \n+        self.cfg.terminate(block, src_info, TerminatorKind::GeneratorDrop);\n+\n+        Some(result)\n+    }\n+\n     /// Creates a new visibility scope, nested in the current one.\n     pub fn new_visibility_scope(&mut self, span: Span) -> VisibilityScope {\n         let parent = self.visibility_scope;\n@@ -487,7 +603,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 None,\n             MirSource::Fn(_) =>\n                 Some(self.topmost_scope()),\n-            MirSource::Promoted(..) =>\n+            MirSource::Promoted(..) |\n+            MirSource::GeneratorDrop(..) =>\n                 bug!(),\n         }\n     }\n@@ -500,10 +617,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                          span: Span,\n                          extent: CodeExtent,\n                          lvalue: &Lvalue<'tcx>,\n-                         lvalue_ty: Ty<'tcx>) {\n+                         lvalue_ty: Ty<'tcx>,\n+                         impl_arg: bool) {\n         let needs_drop = self.hir.needs_drop(lvalue_ty);\n         let drop_kind = if needs_drop {\n-            DropKind::Value { cached_block: None }\n+            DropKind::Value { cached_block: CachedBlock::default() }\n         } else {\n             // Only temps and vars need their storage dead.\n             match *lvalue {\n@@ -570,6 +688,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let extent_span = extent.span(&tcx.hir).unwrap();\n                 // Attribute scope exit drops to scope's closing brace\n                 let scope_end = Span { lo: extent_span.hi, .. extent_span};\n+                if impl_arg {\n+                    assert!(scope.drops.is_empty());\n+                    scope.impl_arg_drop = true;\n+                }\n                 scope.drops.push(DropData {\n                     span: scope_end,\n                     location: lvalue.clone(),\n@@ -603,7 +725,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     span: span,\n                     value: value.clone(),\n                     item_ty: item_ty,\n-                    cached_block: None\n+                    cached_block: CachedBlock::default(),\n                 });\n                 return;\n             }\n@@ -619,6 +741,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// See module comment for more details. None indicates there\u2019s no\n     /// cleanup to do at this point.\n     pub fn diverge_cleanup(&mut self, span: Span) -> Option<BasicBlock> {\n+        self.diverge_cleanup_gen(span, false)\n+    }\n+\n+    fn diverge_cleanup_gen(&mut self, span: Span, generator_drop: bool) -> Option<BasicBlock> {\n         if !self.scopes.iter().any(|scope| scope.needs_cleanup) {\n             return None;\n         }\n@@ -652,7 +778,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         for scope in scopes.iter_mut() {\n-            target = build_diverge_scope(hir.tcx(), cfg, &unit_temp, span, scope, target);\n+            target = build_diverge_scope(hir.tcx(), cfg, &unit_temp, span, scope, target, generator_drop);\n         }\n         Some(target)\n     }\n@@ -729,24 +855,26 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n                            scope: &Scope<'tcx>,\n                            earlier_scopes: &[Scope<'tcx>],\n                            mut block: BasicBlock,\n-                           arg_count: usize)\n+                           arg_count: usize,\n+                           generator_drop: bool)\n                            -> BlockAnd<()> {\n-    let mut iter = scope.drops.iter().rev().peekable();\n+    \n+    let mut iter = scope.drops(generator_drop).iter().rev().peekable();\n     while let Some(drop_data) = iter.next() {\n         let source_info = scope.source_info(drop_data.span);\n         if let DropKind::Value { .. } = drop_data.kind {\n             // Try to find the next block with its cached block\n             // for us to diverge into in case the drop panics.\n             let on_diverge = iter.peek().iter().filter_map(|dd| {\n                 match dd.kind {\n-                    DropKind::Value { cached_block } => cached_block,\n+                    DropKind::Value { cached_block } => cached_block.get(generator_drop),\n                     DropKind::Storage => None\n                 }\n             }).next();\n             // If there\u2019s no `cached_block`s within current scope,\n             // we must look for one in the enclosing scope.\n             let on_diverge = on_diverge.or_else(||{\n-                earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n+                earlier_scopes.iter().rev().flat_map(|s| s.cached_block(generator_drop)).next()\n             });\n             let next = cfg.start_new_block();\n             cfg.terminate(block, source_info, TerminatorKind::Drop {\n@@ -759,6 +887,11 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n         match drop_data.kind {\n             DropKind::Value { .. } |\n             DropKind::Storage => {\n+                // We do not need to emit these for generator drops\n+                if generator_drop {\n+                    continue\n+                }\n+\n                 // Only temps and vars need their storage dead.\n                 match drop_data.location {\n                     Lvalue::Local(index) if index.index() > arg_count => {}\n@@ -780,7 +913,8 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                        unit_temp: &Lvalue<'tcx>,\n                                        span: Span,\n                                        scope: &mut Scope<'tcx>,\n-                                       mut target: BasicBlock)\n+                                       mut target: BasicBlock,\n+                                       generator_drop: bool)\n                                        -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n@@ -794,7 +928,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     // The code in this function reads from right to left. At each\n     // point, we check for cached blocks representing the\n     // remainder. If everything is cached, we'll just walk right to\n-    // left reading the cached results but never created anything.\n+    // left reading the cached results but never create anything.\n \n     let visibility_scope = scope.visibility_scope;\n     let source_info = |span| SourceInfo {\n@@ -804,21 +938,21 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     // Next, build up any free.\n     if let Some(ref mut free_data) = scope.free {\n-        target = if let Some(cached_block) = free_data.cached_block {\n+        target = if let Some(cached_block) = free_data.cached_block.get(generator_drop) {\n             cached_block\n         } else {\n             let into = cfg.start_new_cleanup_block();\n             cfg.terminate(into, source_info(free_data.span),\n                           build_free(tcx, unit_temp, free_data, target));\n-            free_data.cached_block = Some(into);\n+            *free_data.cached_block.ref_mut(generator_drop) = Some(into);\n             into\n         };\n     }\n \n     // Next, build up the drops. Here we iterate the vector in\n     // *forward* order, so that we generate drops[0] first (right to\n     // left in diagram above).\n-    for (j, drop_data) in scope.drops.iter_mut().enumerate() {\n+    for (j, drop_data) in scope.drops_mut(generator_drop).iter_mut().enumerate() {\n         debug!(\"build_diverge_scope drop_data[{}]: {:?}\", j, drop_data);\n         // Only full value drops are emitted in the diverging path,\n         // not StorageDead.\n@@ -829,7 +963,7 @@ fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         // match the behavior of clang, but on inspection eddyb says\n         // this is not what clang does.\n         let cached_block = match drop_data.kind {\n-            DropKind::Value { ref mut cached_block } => cached_block,\n+            DropKind::Value { ref mut cached_block } => cached_block.ref_mut(generator_drop),\n             DropKind::Storage => continue\n         };\n         target = if let Some(cached_block) = *cached_block {"}, {"sha": "2f8e932a7382a741ea88370d32c4c4a2d2779a09", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -299,6 +299,11 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n                                           move_data.rev_lookup.find(location),\n                                           |moi| callback(moi, DropFlagState::Present))\n                 }\n+                mir::TerminatorKind::Suspend { .. } => {\n+                    on_lookup_result_bits(tcx, mir, move_data,\n+                                          move_data.rev_lookup.find(&Mir::impl_arg_lvalue()),\n+                                          |moi| callback(moi, DropFlagState::Present))\n+                }\n                 _ => {\n                     // other terminators do not contain move-ins\n                 }"}, {"sha": "6eebe9da9f08036fd674365f82c365863c73702e", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -452,15 +452,21 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n         match bb_data.terminator().kind {\n             mir::TerminatorKind::Return |\n             mir::TerminatorKind::Resume |\n+            mir::TerminatorKind::GeneratorDrop |\n             mir::TerminatorKind::Unreachable => {}\n             mir::TerminatorKind::Goto { ref target } |\n             mir::TerminatorKind::Assert { ref target, cleanup: None, .. } |\n+            mir::TerminatorKind::Suspend { resume: ref target, drop: None, .. } |\n             mir::TerminatorKind::Drop { ref target, location: _, unwind: None } |\n             mir::TerminatorKind::DropAndReplace {\n                 ref target, value: _, location: _, unwind: None\n             } => {\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n             }\n+            mir::TerminatorKind::Suspend { resume: ref target, drop: Some(ref drop), .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                self.propagate_bits_into_entry_set_for(in_out, changed, drop);\n+            }\n             mir::TerminatorKind::Assert { ref target, cleanup: Some(ref unwind), .. } |\n             mir::TerminatorKind::Drop { ref target, location: _, unwind: Some(ref unwind) } |\n             mir::TerminatorKind::DropAndReplace {"}, {"sha": "cc12ae6abfc14e3a34ca9a8f898fb6136fb064e6", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -462,6 +462,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n         match term.kind {\n             TerminatorKind::Goto { target: _ } |\n             TerminatorKind::Resume |\n+            TerminatorKind::GeneratorDrop |\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n@@ -473,6 +474,11 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 // branching terminators - these don't move anything\n             }\n \n+            TerminatorKind::Suspend { ref value,  .. } => {\n+                self.create_move_path(&Mir::impl_arg_lvalue());\n+                self.gather_operand(loc, value);\n+            }\n+\n             TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n                 self.gather_move(loc, location);\n             }"}, {"sha": "ca634ffef54465b826a979aaa001da5dee1e5e75", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -428,10 +428,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprClosure(..) => {\n+        hir::ExprClosure(.., gen) => {\n             let closure_ty = cx.tables().expr_ty(expr);\n             let (def_id, substs) = match closure_ty.sty {\n-                ty::TyClosure(def_id, substs) => (def_id, substs),\n+                ty::TyClosure(def_id, substs) |\n+                ty::TyGenerator(def_id, substs, _) => (def_id, substs),\n                 _ => {\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n@@ -446,6 +447,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 closure_id: def_id,\n                 substs: substs,\n                 upvars: upvars,\n+                generator: gen.is_some(),\n             }\n         }\n \n@@ -564,6 +566,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprArray(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n         hir::ExprTup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n+\n+        hir::ExprImplArg(_) => ExprKind::ImplArg,\n+        hir::ExprSuspend(ref v) => ExprKind::Suspend { value: v.to_ref() },\n     };\n \n     Expr {\n@@ -698,7 +703,8 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             });\n             let region = cx.tcx.mk_region(region);\n \n-            let self_expr = match cx.tcx.closure_kind(closure_def_id) {\n+            let self_expr = if let ty::TyClosure(..) = closure_ty.sty {\n+            match cx.tcx.closure_kind(closure_def_id) {\n                 ty::ClosureKind::Fn => {\n                     let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                        ty::TypeAndMut {\n@@ -748,6 +754,14 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         kind: ExprKind::SelfRef,\n                     }\n                 }\n+            }\n+            } else {\n+                Expr {\n+                    ty: closure_ty,\n+                    temp_lifetime: temp_lifetime,\n+                    span: expr.span,\n+                    kind: ExprKind::SelfRef,\n+                }\n             };\n \n             // at this point we have `self.n`, which loads up the upvar"}, {"sha": "46df40e42871db1f5f6f47623e6612832d71922c", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -61,6 +61,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let constness = match src {\n             MirSource::Const(_) |\n             MirSource::Static(..) => hir::Constness::Const,\n+            MirSource::GeneratorDrop(..) => hir::Constness::NotConst,\n             MirSource::Fn(id) => {\n                 let fn_like = FnLikeNode::from_node(infcx.tcx.hir.get(id));\n                 fn_like.map_or(hir::Constness::NotConst, |f| f.constness())"}, {"sha": "dece9a974f172027b689e8963fd3d0113ed0a899", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -239,6 +239,7 @@ pub enum ExprKind<'tcx> {\n         closure_id: DefId,\n         substs: ClosureSubsts<'tcx>,\n         upvars: Vec<ExprRef<'tcx>>,\n+        generator: bool,\n     },\n     Literal {\n         literal: Literal<'tcx>,\n@@ -248,6 +249,10 @@ pub enum ExprKind<'tcx> {\n         outputs: Vec<ExprRef<'tcx>>,\n         inputs: Vec<ExprRef<'tcx>>\n     },\n+    ImplArg,\n+    Suspend {\n+        value: ExprRef<'tcx>,\n+    },\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "bc04be18ac65638b48d021ccca9d449a44bd5c1c", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -148,6 +148,12 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n {\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n+    // Check if this is a generator, if so, return the drop glue for it\n+    if let Some(&ty::TyS { sty: ty::TyGenerator(gen_def_id, substs, _), .. }) = ty {\n+        let mir = &**tcx.optimized_mir(gen_def_id).generator_drop.as_ref().unwrap();\n+        return mir.subst(tcx, substs.substs);\n+    }\n+\n     let substs = if let Some(ty) = ty {\n         tcx.mk_substs(iter::once(Kind::from(ty)))\n     } else {\n@@ -178,6 +184,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         ),\n         IndexVec::new(),\n         sig.output(),\n+        None,\n         local_decls_for_sig(&sig, span),\n         sig.inputs().len(),\n         vec![],\n@@ -213,10 +220,10 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub struct DropShimElaborator<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n-    patch: MirPatch<'tcx>,\n-    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+    pub mir: &'a Mir<'tcx>,\n+    pub patch: MirPatch<'tcx>,\n+    pub tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'a, 'tcx> fmt::Debug for DropShimElaborator<'a, 'tcx> {\n@@ -390,6 +397,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         ),\n         IndexVec::new(),\n         sig.output(),\n+        None,\n         local_decls,\n         sig.inputs().len(),\n         vec![],\n@@ -461,6 +469,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         ),\n         IndexVec::new(),\n         sig.output(),\n+        None,\n         local_decls,\n         sig.inputs().len(),\n         vec![],"}, {"sha": "d3bbd4d78ed385cccd083c9311f7eab430c712ef", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -60,6 +60,7 @@ impl MirPass for CopyPropagation {\n                     return\n                 }\n             }\n+            MirSource::GeneratorDrop(_) => (),\n         }\n \n         // We only run when the MIR optimization level is > 1."}, {"sha": "387d769e01f67eec8d242260defffd5baa4b4b4a", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -96,15 +96,20 @@ fn find_dead_unwinds<'a, 'tcx>(\n                            MaybeInitializedLvals::new(tcx, mir, &env),\n                            |bd, p| &bd.move_data().move_paths[p]);\n     for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n-        match bb_data.terminator().kind {\n+        let impl_arg = Mir::impl_arg_lvalue();\n+        let location = match bb_data.terminator().kind {\n             TerminatorKind::Drop { ref location, unwind: Some(_), .. } |\n-            TerminatorKind::DropAndReplace { ref location, unwind: Some(_), .. } => {\n+            TerminatorKind::DropAndReplace { ref location, unwind: Some(_), .. } => location,\n+            TerminatorKind::Suspend { .. } => &impl_arg,\n+            _ => continue,\n+        };\n+\n                 let mut init_data = InitializationData {\n                     live: flow_inits.sets().on_entry_set_for(bb.index()).to_owned(),\n                     dead: IdxSetBuf::new_empty(env.move_data.move_paths.len()),\n                 };\n                 debug!(\"find_dead_unwinds @ {:?}: {:?}; init_data={:?}\",\n-                       bb, bb_data, init_data.live);\n+                        bb, bb_data, init_data.live);\n                 for stmt in 0..bb_data.statements.len() {\n                     let loc = Location { block: bb, statement_index: stmt };\n                     init_data.apply_location(tcx, mir, env, loc);\n@@ -130,9 +135,6 @@ fn find_dead_unwinds<'a, 'tcx>(\n                 if !maybe_live {\n                     dead_unwinds.add(&bb);\n                 }\n-            }\n-            _ => {}\n-        }\n     }\n \n     dead_unwinds\n@@ -342,9 +344,11 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     {\n         for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n             let terminator = data.terminator();\n+            let impl_arg = Mir::impl_arg_lvalue();\n             let location = match terminator.kind {\n                 TerminatorKind::Drop { ref location, .. } |\n                 TerminatorKind::DropAndReplace { ref location, .. } => location,\n+                TerminatorKind::Suspend { .. } => &impl_arg,\n                 _ => continue\n             };\n "}, {"sha": "5f77096e0c36128a6d77bedcfee6d848e42200d1", "filename": "src/librustc_mir/transform/generator.rs", "status": "added", "additions": 739, "deletions": 0, "changes": 739, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -0,0 +1,739 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Transforming generator bodies into a state machines\n+\n+#![allow(warnings)]\n+\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::middle::const_val::ConstVal;\n+use rustc::mir::*;\n+use rustc::mir::transform::{MirPass, MirSource};\n+use rustc::mir::visit::{LvalueContext, MutVisitor};\n+use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n+use rustc::ty::subst::{Kind, Substs};\n+use util::dump_mir;\n+use util::liveness;\n+use rustc_const_math::ConstInt;\n+use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::collections::HashMap;\n+use std::borrow::Cow;\n+use std::iter::once;\n+use syntax::ast::NodeId;\n+use transform::simplify;\n+\n+pub struct StateTransform;\n+\n+struct RenameLocalVisitor {\n+    from: Local,\n+    to: Local,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n+    fn visit_local(&mut self,\n+                        local: &mut Local) {\n+        if *local == self.from {\n+            *local = self.to;\n+        }\n+    }\n+}\n+\n+struct SwapLocalVisitor {\n+    a: Local,\n+    b: Local,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for SwapLocalVisitor {\n+    fn visit_local(&mut self,\n+                        local: &mut Local) {\n+        if *local == self.a {\n+            *local = self.b;\n+        } else if *local == self.b {\n+            *local = self.a;\n+        }\n+    }\n+}\n+\n+struct InsertLocalVisitor {\n+    local: Local,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for InsertLocalVisitor {\n+    fn visit_local(&mut self,\n+                        local: &mut Local) {\n+        if local.index() >= self.local.index() {\n+            *local = Local::new(local.index() + 1);\n+        }\n+    }\n+}\n+\n+struct DerefArgVisitor;\n+\n+impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        if *lvalue == Lvalue::Local(Local::new(2)) {\n+            *lvalue = Lvalue::Projection(Box::new(Projection {\n+                base: lvalue.clone(),\n+                elem: ProjectionElem::Deref,\n+            }));\n+        } else {\n+            self.super_lvalue(lvalue, context, location);\n+        }\n+    }\n+}\n+\n+struct TransformVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    state_adt_ref: &'tcx AdtDef,\n+    state_substs: &'tcx Substs<'tcx>,\n+    remap: HashMap<Local, (Ty<'tcx>, usize)>,\n+    bb_target_count: u32,\n+    bb_targets: HashMap<(BasicBlock, Option<BasicBlock>), u32>,\n+    new_ret_local: Local,\n+    return_block: BasicBlock,\n+    state_field: usize,\n+}\n+\n+impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n+    fn make_state(&self, idx: usize, val: Operand<'tcx>) -> Rvalue<'tcx> {\n+        let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None);\n+        Rvalue::Aggregate(box adt, vec![val])\n+    }\n+\n+    fn make_field(&self, idx: usize, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n+        let base = Lvalue::Local(Local::new(1));\n+        let base = Lvalue::Projection(Box::new(Projection {\n+            base: base,\n+            elem: ProjectionElem::Deref,\n+        }));\n+        let field = Projection {\n+            base: base,\n+            elem: ProjectionElem::Field(Field::new(idx), ty),\n+        };\n+        Lvalue::Projection(Box::new(field))\n+    }\n+\n+    fn set_state(&self, state_disc: u32, source_info: SourceInfo) -> Statement<'tcx> {\n+        let state = self.make_field(self.state_field, self.tcx.types.u32);\n+        let val = Operand::Constant(box Constant {\n+            span: source_info.span,\n+            ty: self.tcx.types.u32,\n+            literal: Literal::Value {\n+                value: ConstVal::Integral(ConstInt::U32(state_disc)),\n+            },\n+        });\n+        Statement {\n+            source_info,\n+            kind: StatementKind::Assign(state, Rvalue::Use(val)),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        if let Lvalue::Local(l) = *lvalue {\n+            if let Some(&(ty, idx)) = self.remap.get(&l) {\n+                *lvalue = self.make_field(idx, ty);\n+            }\n+        } else {\n+            self.super_lvalue(lvalue, context, location);\n+        }\n+    }\n+\n+    fn visit_basic_block_data(&mut self,\n+                              block: BasicBlock,\n+                              data: &mut BasicBlockData<'tcx>) {\n+        let ret_val = match data.terminator().kind {\n+            TerminatorKind::Return => Some((1,\n+                self.return_block,\n+                Operand::Consume(Lvalue::Local(self.new_ret_local)),\n+                None)),\n+            TerminatorKind::Suspend { ref value, resume, drop } => Some((0,\n+                resume,\n+                value.clone(),\n+                drop)),\n+            _ => None\n+        };\n+\n+        data.retain_statements(|s| {\n+            match s.kind {\n+                StatementKind::StorageLive(ref l) | StatementKind::StorageDead(ref l) => {\n+                    if let Lvalue::Local(l) = *l {\n+                        !self.remap.contains_key(&l)\n+                    } else {\n+                        true\n+                    }\n+                }\n+                _ => true\n+            }\n+        });\n+\n+        ret_val.map(|(state_idx, resume, v, drop)| {\n+            let bb_idx = {\n+                let bb_targets = &mut self.bb_targets;\n+                let bb_target = &mut self.bb_target_count;\n+                *bb_targets.entry((resume, drop)).or_insert_with(|| {\n+                    let target = *bb_target;\n+                    *bb_target = target.checked_add(1).unwrap();\n+                    target\n+                })\n+            };\n+            let source_info = data.terminator().source_info;\n+            data.statements.push(self.set_state(bb_idx, source_info));\n+            data.statements.push(Statement {\n+                source_info,\n+                kind: StatementKind::Assign(Lvalue::Local(RETURN_POINTER),\n+                    self.make_state(state_idx, v)),\n+            });\n+            data.terminator.as_mut().unwrap().kind = TerminatorKind::Return;\n+        });\n+\n+        self.super_basic_block_data(block, data);\n+    }\n+}\n+\n+fn get_body_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: NodeId) -> (bool, hir::BodyId) {\n+    // Figure out what primary body this item has.\n+    match tcx.hir.get(node_id) {\n+        hir::map::NodeItem(item) => {\n+            match item.node {\n+                hir::ItemConst(_, body) |\n+                hir::ItemStatic(_, _, body) |\n+                hir::ItemFn(.., body) => (false, body),\n+                _ => bug!(),\n+            }\n+        }\n+        hir::map::NodeTraitItem(item) => {\n+            match item.node {\n+                hir::TraitItemKind::Const(_, Some(body)) |\n+                hir::TraitItemKind::Method(_,\n+                    hir::TraitMethod::Provided(body)) => (false, body),\n+                _ => bug!(),\n+            }\n+        }\n+        hir::map::NodeImplItem(item) => {\n+            match item.node {\n+                hir::ImplItemKind::Const(_, body) |\n+                hir::ImplItemKind::Method(_, body) => (false, body),\n+                _ => bug!(),\n+            }\n+        }\n+        hir::map::NodeExpr(expr) => {\n+            // FIXME(eddyb) Closures should have separate\n+            // function definition IDs and expression IDs.\n+            // Type-checking should not let closures get\n+            // this far in a constant position.\n+            // Assume that everything other than closures\n+            // is a constant \"initializer\" expression.\n+            match expr.node {\n+                hir::ExprClosure(_, _, body, _, _) => (true, body),\n+                _ => (false, hir::BodyId { node_id: expr.id })\n+            }\n+        }\n+        _ => bug!(),\n+    }\n+}\n+\n+fn ensure_generator_state_argument<'a, 'tcx>(\n+                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                node_id: NodeId,\n+                def_id: DefId,\n+                mir: &mut Mir<'tcx>) -> (Ty<'tcx>, GeneratorInterior<'tcx>) {\n+    let interior = *tcx.typeck_tables_of(def_id).generator_interiors.get(&node_id).unwrap();\n+\n+    let gen_ty = mir.local_decls.raw[2].ty;\n+\n+    let region = ty::ReFree(ty::FreeRegion {\n+        scope: def_id,\n+        bound_region: ty::BoundRegion::BrEnv,\n+    });\n+\n+    let region = tcx.mk_region(region);\n+\n+    let ref_gen_ty = tcx.mk_ref(region, ty::TypeAndMut {\n+        ty: gen_ty,\n+        mutbl: hir::MutMutable\n+    });\n+\n+    // Replace the by value generator argument\n+    mir.local_decls.raw[2].ty = ref_gen_ty;\n+\n+    // Add a deref to accesses of the generator state for upvars\n+    DerefArgVisitor.visit_mir(mir);\n+\n+    // Swap generator and implicit argument\n+    SwapLocalVisitor {\n+        a: Local::new(1),\n+        b: Local::new(2),\n+    }.visit_mir(mir);\n+\n+    mir.local_decls.raw[..].swap(1, 2);\n+\n+    (gen_ty, interior)\n+}\n+\n+fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n+                            mir: &mut Mir<'tcx>) -> Local {\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    let new_ret = LocalDecl {\n+        mutability: Mutability::Mut,\n+        ty: ret_ty,\n+        name: None,\n+        source_info,\n+        is_user_variable: false,\n+    };\n+    let new_ret_local = Local::new(mir.local_decls.len());\n+    mir.local_decls.push(new_ret);\n+    mir.local_decls.swap(0, new_ret_local.index());\n+\n+    RenameLocalVisitor {\n+        from: RETURN_POINTER,\n+        to: new_ret_local,\n+    }.visit_mir(mir);\n+\n+    new_ret_local\n+}\n+\n+fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               mir: &Mir<'tcx>,\n+                                               source: MirSource) -> liveness::LocalSet {\n+    use rustc_data_structures::indexed_set::IdxSetBuf;\n+    let mut set = liveness::LocalSet::new_empty(mir.local_decls.len());\n+    let result = liveness::liveness_of_locals(mir);\n+    liveness::dump_mir(tcx, \"generator_liveness\", source, mir, &result);\n+\n+    for (block, data) in mir.basic_blocks().iter_enumerated() {\n+        if let TerminatorKind::Suspend { .. } = data.terminator().kind {\n+            set.union(&result.outs[block]);\n+        }\n+    }\n+\n+    // The implicit argument is defined after each suspend point so it can never be live in a suspend point.\n+    set.remove(&Local::new(2));\n+\n+    // The generator argument is ignored\n+    set.remove(&Local::new(1));\n+\n+    set\n+}\n+\n+fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            def_id: DefId,\n+                            source: MirSource,\n+                            interior: GeneratorInterior<'tcx>,\n+                            mir: &mut Mir<'tcx>) -> (HashMap<Local, (Ty<'tcx>, usize)>, GeneratorLayout<'tcx>) {\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    let mut live_locals = locals_live_across_suspend_points(tcx, mir, source);\n+\n+    let allowed = tcx.erase_regions(&interior.as_slice());\n+    \n+    for (local, decl) in mir.local_decls.iter_enumerated() {\n+        if !live_locals.contains(&local) {\n+            continue;\n+        }\n+        if !allowed.contains(&decl.ty) {\n+            tcx.sess.span_warn(mir.span,\n+                &format!(\"generator contains type {} in MIR, but typeck only knows about {}\",\n+                    decl.ty,\n+                    interior));\n+        }\n+    }\n+\n+    let upvar_len = mir.upvar_decls.len();\n+    let live_decls : Vec<_> = mir.local_decls.iter_enumerated_mut().filter(|&(local, _)| live_locals.contains(&local)).collect();\n+\n+    let mut remap = HashMap::new();\n+    let unit = tcx.mk_nil();\n+    let mut vars: Vec<_> = live_decls.into_iter().enumerate().map(|(idx, (local, decl))| {\n+        let var = decl.clone();\n+        *decl = LocalDecl {\n+            mutability: Mutability::Mut,\n+            ty: unit,\n+            name: None,\n+            source_info,\n+            is_user_variable: false,\n+        };\n+        remap.insert(local, (var.ty, upvar_len + 1 + idx));\n+        var\n+    }).collect();\n+\n+    let layout = GeneratorLayout {\n+        fields: vars\n+    };\n+    \n+    (remap, layout)\n+}\n+\n+fn insert_entry_point<'tcx>(mir: &mut Mir<'tcx>,\n+                            block: BasicBlockData<'tcx>) {\n+    mir.basic_blocks_mut().raw.insert(0, block);\n+\n+    let blocks = mir.basic_blocks_mut().iter_mut();\n+\n+    for target in blocks.flat_map(|b| b.terminator_mut().successors_mut()) {\n+        *target = BasicBlock::new(target.index() + 1);\n+    }\n+}\n+\n+fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      def_id: DefId,\n+                                      mir: &mut Mir<'tcx>) {\n+    use util::elaborate_drops::{elaborate_drop, Unwind, DropElaborator, DropStyle, DropFlagMode};\n+    use util::patch::MirPatch;\n+    use shim::DropShimElaborator;\n+\n+    let param_env = tcx.param_env(def_id);\n+    let gen = Local::new(2);\n+\n+    for block in mir.basic_blocks().indices() {\n+        let (target, unwind, source_info) = match mir.basic_blocks()[block].terminator() {\n+            &Terminator {\n+                source_info,\n+                kind: TerminatorKind::Drop {\n+                    location: Lvalue::Local(local),\n+                    target,\n+                    unwind\n+                }\n+            } if local == gen => (target, unwind, source_info),\n+            _ => continue,\n+        };\n+        let unwind = if let Some(unwind) = unwind {\n+            Unwind::To(unwind) \n+        } else {\n+            Unwind::InCleanup\n+        };\n+        let patch = {\n+            let mut elaborator = DropShimElaborator {\n+                mir: &mir,\n+                patch: MirPatch::new(mir),\n+                tcx,\n+                param_env\n+            };\n+            elaborate_drop(\n+                &mut elaborator,\n+                source_info,\n+                &Lvalue::Local(gen),\n+                (),\n+                target,\n+                unwind,\n+                block\n+            );\n+            elaborator.patch\n+        };\n+        patch.apply(mir);\n+    }\n+}\n+\n+fn generate_drop<'a, 'tcx>(\n+                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                transform: &TransformVisitor<'a, 'tcx>,\n+                node_id: NodeId,\n+                def_id: DefId,\n+                source: MirSource,\n+                gen_ty: Ty<'tcx>,\n+                mir: &mut Mir<'tcx>) {\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: TerminatorKind::Return,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    let cases: Vec<_> = transform.bb_targets.iter().filter_map(|(&(r, u), &s)| {\n+        u.map(|d| (s, d))\n+    }).collect();\n+\n+    // The poisoned state 1 falls through to the default case which is just to return\n+\n+    let switch = TerminatorKind::SwitchInt {\n+        discr: Operand::Consume(transform.make_field(transform.state_field, tcx.types.u32)),\n+        switch_ty: tcx.types.u32,\n+        values: Cow::from(cases.iter().map(|&(i, _)| {\n+                ConstInt::U32(i)\n+            }).collect::<Vec<_>>()),\n+        targets: cases.iter().map(|&(_, d)| d).chain(once(transform.return_block)).collect(),\n+    };\n+\n+    insert_entry_point(mir, BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: switch,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    for block in mir.basic_blocks_mut() {\n+        let kind = &mut block.terminator_mut().kind;\n+        if let TerminatorKind::GeneratorDrop = *kind {\n+            *kind = TerminatorKind::Return;\n+        }\n+    }\n+\n+    // Remove the implicit argument\n+    mir.arg_count = 1;\n+    mir.local_decls.raw.pop();\n+    \n+    // Replace the return variable\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    mir.return_ty = tcx.mk_nil();\n+    mir.local_decls[RETURN_POINTER] = LocalDecl {\n+        mutability: Mutability::Mut,\n+        ty: tcx.mk_nil(),\n+        name: None,\n+        source_info,\n+        is_user_variable: false,\n+    };\n+\n+    // Change the generator argument from &mut to *mut\n+    mir.local_decls[Local::new(1)] = LocalDecl {\n+        mutability: Mutability::Mut,\n+        ty: tcx.mk_ptr(ty::TypeAndMut {\n+            ty: gen_ty,\n+            mutbl: hir::Mutability::MutMutable, \n+        }),\n+        name: None,\n+        source_info,\n+        is_user_variable: false,\n+    };\n+\n+    // Make sure we remove dead blocks to remove\n+    // unrelated code from the resume part of the function\n+    simplify::remove_dead_blocks(mir);\n+\n+    dump_mir(tcx, None, \"generator_drop\", &0, source, mir);\n+}\n+\n+fn generate_resume<'a, 'tcx>(\n+                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                mut transform: TransformVisitor<'a, 'tcx>,\n+                node_id: NodeId,\n+                def_id: DefId,\n+                source: MirSource,\n+                mir: &mut Mir<'tcx>) {\n+    // Poison the generator when it unwinds\n+    for block in mir.basic_blocks_mut() {\n+        let source_info = block.terminator().source_info;\n+        if let &TerminatorKind::Resume = &block.terminator().kind {\n+            block.statements.push(transform.set_state(1, source_info));\n+        }\n+    }\n+\n+    let drop_arg = mir.local_decls.raw[2].ty.needs_drop(tcx, tcx.param_env(def_id));\n+\n+    let cleanup = if drop_arg {\n+        Some(BasicBlock::new(mir.basic_blocks().len() + 1))\n+    } else {\n+        None\n+    };\n+\n+    let term = TerminatorKind::Assert {\n+        cond: Operand::Constant(box Constant {\n+            span: mir.span,\n+            ty: tcx.types.bool,\n+            literal: Literal::Value {\n+                value: ConstVal::Bool(false),\n+            },\n+        }),\n+        expected: true,\n+        msg: AssertMessage::GeneratorResumedAfterReturn,\n+        target: transform.return_block,\n+        cleanup: cleanup,\n+    };\n+\n+    let source_info = SourceInfo {\n+        span: mir.span,\n+        scope: ARGUMENT_VISIBILITY_SCOPE,\n+    };\n+\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: term,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    if drop_arg {\n+        let resume_block = BasicBlock::new(mir.basic_blocks().len() + 1);\n+\n+        let term = TerminatorKind::Drop {\n+            location: Lvalue::Local(Local::new(2)),\n+            target: resume_block,\n+            unwind: None,\n+        };\n+\n+        mir.basic_blocks_mut().push(BasicBlockData {\n+            statements: Vec::new(),\n+            terminator: Some(Terminator {\n+                source_info,\n+                kind: term,\n+            }),\n+            is_cleanup: true,\n+        });\n+\n+        mir.basic_blocks_mut().push(BasicBlockData {\n+            statements: Vec::new(),\n+            terminator: Some(Terminator {\n+                source_info,\n+                kind: TerminatorKind::Resume,\n+            }),\n+            is_cleanup: true,\n+        });\n+    }\n+\n+    let poisoned_block = BasicBlock::new(mir.basic_blocks().len());\n+\n+    let term = TerminatorKind::Assert {\n+        cond: Operand::Constant(box Constant {\n+            span: mir.span,\n+            ty: tcx.types.bool,\n+            literal: Literal::Value {\n+                value: ConstVal::Bool(false),\n+            },\n+        }),\n+        expected: true,\n+        msg: AssertMessage::GeneratorResumedAfterPanic,\n+        target: transform.return_block,\n+        cleanup: cleanup,\n+    };\n+\n+    mir.basic_blocks_mut().push(BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: term,\n+        }),\n+        is_cleanup: false,\n+    });\n+\n+    transform.bb_targets.insert((poisoned_block, None), 1);\n+\n+    let switch = TerminatorKind::SwitchInt {\n+        discr: Operand::Consume(transform.make_field(transform.state_field, tcx.types.u32)),\n+        switch_ty: tcx.types.u32,\n+        values: Cow::from(transform.bb_targets.values().map(|&i| {\n+                ConstInt::U32(i)\n+            }).collect::<Vec<_>>()),\n+        targets: transform.bb_targets.keys().map(|&(k, _)| k).chain(once(transform.return_block)).collect(),\n+    };\n+\n+    insert_entry_point(mir, BasicBlockData {\n+        statements: Vec::new(),\n+        terminator: Some(Terminator {\n+            source_info,\n+            kind: switch,\n+        }),\n+        is_cleanup: false,\n+    });\n+    \n+    // Make sure we remove dead blocks to remove\n+    // unrelated code from the drop part of the function\n+    simplify::remove_dead_blocks(mir);\n+\n+    dump_mir(tcx, None, \"generator_resume\", &0, source, mir);\n+}\n+\n+impl MirPass for StateTransform {\n+    fn run_pass<'a, 'tcx>(&self,\n+                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    source: MirSource,\n+                    mir: &mut Mir<'tcx>) {\n+        let suspend_ty = if let Some(suspend_ty) = mir.suspend_ty {\n+            suspend_ty\n+        } else {\n+            // This only applies to generators\n+            return\n+        };\n+\n+        assert!(mir.generator_drop.is_none());\n+\n+        let node_id = source.item_id();\n+        let def_id = tcx.hir.local_def_id(source.item_id());\n+\n+        elaborate_generator_drops(tcx, def_id, mir);\n+\n+        let (gen_ty, interior) = ensure_generator_state_argument(tcx, node_id, def_id, mir);\n+\n+        let state_did = tcx.lang_items.gen_state().unwrap();\n+        let state_adt_ref = tcx.adt_def(state_did);\n+        let state_substs = tcx.mk_substs([Kind::from(suspend_ty),\n+            Kind::from(mir.return_ty)].iter());\n+        let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+\n+        let new_ret_local = replace_result_variable(ret_ty, mir);\n+\n+        let (remap, layout) = compute_layout(tcx, def_id, source, interior, mir);\n+\n+        let return_block = BasicBlock::new(mir.basic_blocks().len());\n+\n+        let state_field = mir.upvar_decls.len();\n+\n+        let mut bb_targets = HashMap::new();\n+        bb_targets.insert((BasicBlock::new(0), None), 0);\n+\n+        let mut transform = TransformVisitor {\n+            tcx,\n+            state_adt_ref,\n+            state_substs,\n+            remap,\n+            bb_target_count: 2,\n+            bb_targets,\n+            new_ret_local,\n+            return_block,\n+            state_field,\n+        };\n+        transform.visit_mir(mir);\n+\n+        mir.return_ty = ret_ty;\n+        mir.suspend_ty = None;\n+        mir.arg_count = 2;\n+        mir.spread_arg = None;\n+        mir.generator_layout = Some(layout);\n+\n+        dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir);\n+\n+        let mut drop_impl = mir.clone();\n+\n+        generate_drop(tcx, &transform, node_id, def_id, source, gen_ty, &mut drop_impl);\n+\n+        mir.generator_drop = Some(box drop_impl);\n+\n+        generate_resume(tcx, transform, node_id, def_id, source, mir);\n+    }\n+}"}, {"sha": "1353be0046de34850ee960eb0534cdb3071ab5a7", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -175,6 +175,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             return false;\n         }\n \n+        // Cannot inline generators which haven't been transformed yet\n+        if callee_mir.suspend_ty.is_some() {\n+            return false;\n+        }\n \n         let attrs = tcx.get_attrs(callsite.callee);\n         let hint = attr::find_inline_attr(None, &attrs[..]);\n@@ -652,6 +656,8 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         self.super_terminator_kind(block, kind, loc);\n \n         match *kind {\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::Suspend { .. } => bug!(),\n             TerminatorKind::Goto { ref mut target} => {\n                 *target = self.update_target(*target);\n             }"}, {"sha": "159d3a1f8eba97696eaa479cb4e5948ef0f079f8", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -39,6 +39,7 @@ pub mod dump_mir;\n pub mod deaggregator;\n pub mod instcombine;\n pub mod copy_prop;\n+pub mod generator;\n pub mod inline;\n pub mod nll;\n "}, {"sha": "d68d702696f513b1dc935c5d87c9dec4fa6406bc", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -43,6 +43,8 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n             TerminatorKind::Resume |\n             TerminatorKind::Return |\n             TerminatorKind::Unreachable |\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::Suspend { .. } |\n             TerminatorKind::SwitchInt { .. } => {\n                 /* nothing to do */\n             },"}, {"sha": "f46a9a1a6fa9fe5ccea9f2c3afdd3d60de1671f1", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -392,6 +392,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 }).into_iter().collect(),\n                 IndexVec::new(),\n                 ty,\n+                None,\n                 initial_locals,\n                 0,\n                 vec![],"}, {"sha": "cb75dd9a5299970069088a6e6b57eb663c93d9d1", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -376,6 +376,8 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 TerminatorKind::SwitchInt {..} |\n                 TerminatorKind::DropAndReplace { .. } |\n                 TerminatorKind::Resume |\n+                TerminatorKind::GeneratorDrop |\n+                TerminatorKind::Suspend { .. } |\n                 TerminatorKind::Unreachable => None,\n \n                 TerminatorKind::Return => {\n@@ -966,6 +968,7 @@ impl MirPass for QualifyAndPromoteConstants {\n             }\n             MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n             MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n+            MirSource::GeneratorDrop(_) |\n             MirSource::Const(_) |\n             MirSource::Promoted(..) => return\n         };"}, {"sha": "b3cbe62321a150b29841bffa278ac1cff8a88c04", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -34,7 +34,7 @@ fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n         mirbug($context.tcx(), $context.last_span,\n-               &format!(\"broken MIR ({:?}): {}\", $elem, format!($($message)*)))\n+               &format!(\"broken MIR in {:?} ({:?}): {}\", $context.body_id, $elem, format!($($message)*)))\n     })\n }\n \n@@ -60,6 +60,7 @@ struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     last_span: Span,\n+    body_id: ast::NodeId,\n     errors_reported: bool\n }\n \n@@ -108,6 +109,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n         TypeVerifier {\n+            body_id: cx.body_id,\n             cx: cx,\n             mir: mir,\n             last_span: mir.span,\n@@ -297,6 +299,19 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         })\n                     }\n                 }\n+                ty::TyGenerator(def_id, substs, _) => {\n+                    // Try upvars first. `field_tys` requires final optimized MIR.\n+                    if let Some(ty) = substs.upvar_tys(def_id, tcx).nth(field.index()) {\n+                        return Ok(ty);\n+                    }\n+\n+                    return match substs.field_tys(def_id, tcx).nth(field.index()) {\n+                        Some(ty) => Ok(ty),\n+                        None => Err(FieldAccessError::OutOfRange {\n+                            field_count: substs.field_tys(def_id, tcx).count() + 1\n+                        })\n+                    }\n+                }\n                 ty::TyTuple(tys, _) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),\n@@ -427,6 +442,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             TerminatorKind::Goto { .. } |\n             TerminatorKind::Resume |\n             TerminatorKind::Return |\n+            TerminatorKind::GeneratorDrop |\n             TerminatorKind::Unreachable |\n             TerminatorKind::Drop { .. } => {\n                 // no checks needed for these\n@@ -493,6 +509,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+            TerminatorKind::Suspend { ref value, .. } => {\n+                let value_ty = value.ty(mir, tcx);\n+                match mir.suspend_ty {\n+                    None => span_mirbug!(self, term, \"suspend in non-generator\"),\n+                    Some(ty) if ty != value_ty => {\n+                        span_mirbug!(self,\n+                            term,\n+                            \"type of suspend value is ({:?}, but the suspend type is ({:?}\",\n+                            value_ty,\n+                            ty);\n+                    }\n+                    _ => (),\n+                }\n+            }\n         }\n     }\n \n@@ -619,6 +649,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     span_mirbug!(self, block, \"return on cleanup block\")\n                 }\n             }\n+            TerminatorKind::GeneratorDrop { .. } => {\n+                if is_cleanup {\n+                    span_mirbug!(self, block, \"generator_drop in cleanup block\")\n+                }\n+            }\n+            TerminatorKind::Suspend { resume, drop, .. } => {\n+                if is_cleanup {\n+                    span_mirbug!(self, block, \"suspend in cleanup block\")\n+                }\n+                self.assert_iscleanup(mir, block, resume, is_cleanup);\n+                if let Some(drop) = drop {\n+                    self.assert_iscleanup(mir, block, drop, is_cleanup);\n+                }\n+            }\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::Drop { target, unwind, .. } |\n             TerminatorKind::DropAndReplace { target, unwind, .. } |"}, {"sha": "203bda16a5c66c10eed429c0797e59f59a8cf662", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -752,7 +752,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn open_drop<'a>(&mut self) -> BasicBlock {\n         let ty = self.lvalue_ty(self.lvalue);\n         match ty.sty {\n-            ty::TyClosure(def_id, substs) => {\n+            ty::TyClosure(def_id, substs) |\n+            ty::TyGenerator(def_id, substs, _) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)\n             }"}, {"sha": "be13472dba32aa417fbe6fd6fee6b220dc3e6e2b", "filename": "src/librustc_mir/util/liveness.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -0,0 +1,205 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Liveness analysis.\n+\n+// FIXME: Make sure this analysis uses proper MIR semantics. Also find out what the MIR semantics are.\n+\n+use rustc::mir::*;\n+use rustc::mir::visit::{LvalueContext, Visitor};\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_data_structures::indexed_set::IdxSetBuf;\n+use util::pretty::{write_basic_block, dump_enabled, write_mir_intro};\n+use rustc::mir::transform::MirSource;\n+use rustc::ty::item_path;\n+use std::path::{PathBuf, Path};\n+use std::fs;\n+use rustc::ty::TyCtxt;\n+use std::io::{self, Write};\n+\n+pub type LocalSet = IdxSetBuf<Local>;\n+\n+#[derive(Eq, PartialEq, Clone)]\n+struct BlockInfo {\n+    defs: LocalSet,\n+    uses: LocalSet,\n+}\n+\n+struct BlockInfoVisitor {\n+    pre_defs: LocalSet,\n+    defs: LocalSet,\n+    uses: LocalSet,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for BlockInfoVisitor {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        if let Lvalue::Local(local) = *lvalue {\n+            match context {\n+                LvalueContext::Store | LvalueContext::Call => {\n+                    self.defs.add(&local);\n+                }\n+                LvalueContext::Projection(..) |\n+                LvalueContext::Borrow { .. } |\n+                LvalueContext::Inspect |\n+                LvalueContext::Consume |\n+                LvalueContext::Drop => {\n+                    // Ignore uses which are already defined in this block\n+                    if !self.pre_defs.contains(&local) {\n+                        self.uses.add(&local);\n+                    }\n+                }\n+                LvalueContext::StorageLive | LvalueContext::StorageDead => (),\n+            }\n+        }\n+\n+        self.super_lvalue(lvalue, context, location)\n+    }\n+}\n+\n+fn block<'tcx>(b: &BasicBlockData<'tcx>, locals: usize) -> BlockInfo {\n+    let mut visitor = BlockInfoVisitor {\n+        pre_defs: LocalSet::new_empty(locals),\n+        defs: LocalSet::new_empty(locals),\n+        uses: LocalSet::new_empty(locals),\n+    };\n+\n+    let dummy_location = Location { block: BasicBlock::new(0), statement_index: 0 };\n+\n+    for statement in &b.statements {\n+        visitor.visit_statement(BasicBlock::new(0), statement, dummy_location);\n+        visitor.pre_defs.union(&visitor.defs);\n+    }\n+    visitor.visit_terminator(BasicBlock::new(0), b.terminator(), dummy_location);\n+\n+    BlockInfo {\n+        defs: visitor.defs,\n+        uses: visitor.uses,\n+    }\n+}\n+\n+pub struct LivenessResult {\n+    pub ins: IndexVec<BasicBlock, LocalSet>,\n+    pub outs: IndexVec<BasicBlock, LocalSet>,\n+}\n+\n+pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>) -> LivenessResult {\n+    let locals = mir.local_decls.len();\n+    let def_use: IndexVec<_, _> = mir.basic_blocks().iter().map(|b| {\n+        block(b, locals)\n+    }).collect();\n+\n+    let copy = |from: &IndexVec<BasicBlock, LocalSet>, to: &mut IndexVec<BasicBlock, LocalSet>| {\n+        for (i, set) in to.iter_enumerated_mut() {\n+            set.clone_from(&from[i]);\n+        }\n+    };\n+\n+    let mut ins: IndexVec<_, _> = mir.basic_blocks()\n+        .indices()\n+        .map(|_| LocalSet::new_empty(locals)).collect();\n+    let mut outs = ins.clone();\n+\n+    let mut ins_ = ins.clone();\n+    let mut outs_ = outs.clone();\n+\n+    loop {\n+        copy(&ins, &mut ins_);\n+        copy(&outs, &mut outs_);\n+\n+        for b in mir.basic_blocks().indices().rev() {\n+            // out = \u222a {ins of successors}\n+            outs[b].clear();\n+            for &successor in mir.basic_blocks()[b].terminator().successors().into_iter() {\n+                outs[b].union(&ins[successor]);\n+            }\n+\n+            // in = use \u222a (out - def)\n+            ins[b].clone_from(&outs[b]);\n+            ins[b].subtract(&def_use[b].defs);\n+            ins[b].union(&def_use[b].uses);\n+        }\n+\n+        if ins_ == ins && outs_ == outs {\n+            break;\n+        }\n+    }\n+\n+    LivenessResult {\n+        ins,\n+        outs,\n+    }\n+}\n+\n+pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          pass_name: &str,\n+                          source: MirSource,\n+                          mir: &Mir<'tcx>,\n+                          result: &LivenessResult) {\n+    if !dump_enabled(tcx, pass_name, source) {\n+        return;\n+    }\n+    let node_path = item_path::with_forced_impl_filename_line(|| { // see notes on #41697 below\n+        tcx.item_path_str(tcx.hir.local_def_id(source.item_id()))\n+    });\n+    dump_matched_mir_node(tcx, pass_name, &node_path,\n+                          source, mir, result);\n+}\n+\n+fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   pass_name: &str,\n+                                   node_path: &str,\n+                                   source: MirSource,\n+                                   mir: &Mir<'tcx>,\n+                                   result: &LivenessResult) {\n+    let mut file_path = PathBuf::new();\n+    if let Some(ref file_dir) = tcx.sess.opts.debugging_opts.dump_mir_dir {\n+        let p = Path::new(file_dir);\n+        file_path.push(p);\n+    };\n+    let file_name = format!(\"rustc.node{}{}-liveness.mir\",\n+                            source.item_id(), pass_name);\n+    file_path.push(&file_name);\n+    let _ = fs::File::create(&file_path).and_then(|mut file| {\n+        writeln!(file, \"// MIR local liveness analysis for `{}`\", node_path)?;\n+        writeln!(file, \"// source = {:?}\", source)?;\n+        writeln!(file, \"// pass_name = {}\", pass_name)?;\n+        writeln!(file, \"\")?;\n+        write_mir_fn(tcx, source, mir, &mut file, result)?;\n+        Ok(())\n+    });\n+}\n+\n+pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              src: MirSource,\n+                              mir: &Mir<'tcx>,\n+                              w: &mut Write,\n+                              result: &LivenessResult)\n+                              -> io::Result<()> {\n+    write_mir_intro(tcx, src, mir, w)?;\n+    for block in mir.basic_blocks().indices() {\n+        let print = |w: &mut Write, prefix, result: &IndexVec<BasicBlock, LocalSet>| {\n+            let live: Vec<String> = mir.local_decls.indices().filter(|i| result[block].contains(i)).map(|i| format!(\"{:?}\", i)).collect();\n+            writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))\n+        };\n+        print(w, \"   \", &result.ins)?;\n+        write_basic_block(tcx, block, mir, w)?;\n+        print(w, \"   \", &result.outs)?;\n+        if block.index() + 1 != mir.basic_blocks().len() {\n+            writeln!(w, \"\")?;\n+        }\n+    }\n+\n+    writeln!(w, \"}}\")?;\n+    Ok(())\n+}\n+"}, {"sha": "b03fd0196a369dc9fba5711e76139866f2dba91f", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -14,6 +14,7 @@ pub mod patch;\n \n mod graphviz;\n mod pretty;\n+pub mod liveness;\n \n pub use self::pretty::{dump_enabled, dump_mir, write_mir_pretty};\n pub use self::graphviz::{write_mir_graphviz};"}, {"sha": "e3087efbfe6263a22d61e8ba95a23a78b881c672", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -94,6 +94,7 @@ fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    mir: &Mir<'tcx>) {\n     let promotion_id = match source {\n         MirSource::Promoted(_, id) => format!(\"-{:?}\", id),\n+        MirSource::GeneratorDrop(_) => format!(\"-drop\"),\n         _ => String::new()\n     };\n \n@@ -120,6 +121,9 @@ fn dump_matched_mir_node<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n+        if let Some(ref layout) = mir.generator_layout {\n+            writeln!(file, \"// generator_layout = {:?}\", layout)?;\n+        }\n         writeln!(file, \"\")?;\n         write_mir_fn(tcx, source, mir, &mut file)?;\n         Ok(())\n@@ -176,7 +180,7 @@ pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-fn write_basic_block(tcx: TyCtxt,\n+pub fn write_basic_block(tcx: TyCtxt,\n                      block: BasicBlock,\n                      mir: &Mir,\n                      w: &mut Write)\n@@ -274,7 +278,7 @@ fn write_scope_tree(tcx: TyCtxt,\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              src: MirSource,\n                              mir: &Mir,\n                              w: &mut Write)\n@@ -322,28 +326,32 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n         MirSource::Const(_) => write!(w, \"const\")?,\n         MirSource::Static(_, hir::MutImmutable) => write!(w, \"static\")?,\n         MirSource::Static(_, hir::MutMutable) => write!(w, \"static mut\")?,\n-        MirSource::Promoted(_, i) => write!(w, \"{:?} in\", i)?\n+        MirSource::Promoted(_, i) => write!(w, \"{:?} in\", i)?,\n+        MirSource::GeneratorDrop(_) => write!(w, \"drop_glue\")?,\n     }\n \n     item_path::with_forced_impl_filename_line(|| { // see notes on #41697 elsewhere\n         write!(w, \" {}\", tcx.node_path_str(src.item_id()))\n     })?;\n \n-    if let MirSource::Fn(_) = src {\n-        write!(w, \"(\")?;\n-\n-        // fn argument types.\n-        for (i, arg) in mir.args_iter().enumerate() {\n-            if i != 0 {\n-                write!(w, \", \")?;\n+    match src {\n+        MirSource::Fn(_) | MirSource::GeneratorDrop(_) => {\n+            write!(w, \"(\")?;\n+\n+            // fn argument types.\n+            for (i, arg) in mir.args_iter().enumerate() {\n+                if i != 0 {\n+                    write!(w, \", \")?;\n+                }\n+                write!(w, \"{:?}: {}\", Lvalue::Local(arg), mir.local_decls[arg].ty)?;\n             }\n-            write!(w, \"{:?}: {}\", Lvalue::Local(arg), mir.local_decls[arg].ty)?;\n-        }\n \n-        write!(w, \") -> {}\", mir.return_ty)\n-    } else {\n-        assert_eq!(mir.arg_count, 0);\n-        write!(w, \": {} =\", mir.return_ty)\n+            write!(w, \") -> {}\", mir.return_ty)\n+        }\n+        _ => {\n+            assert_eq!(mir.arg_count, 0);\n+            write!(w, \": {} =\", mir.return_ty)\n+        }\n     }\n }\n "}, {"sha": "e3d665c4bcb1bf4532ac47c14952973a1c4e910a", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -435,6 +435,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprAgain(_) |\n         hir::ExprRet(_) |\n \n+        // Generator expressions\n+        hir::ExprSuspend(_) |\n+        hir::ExprImplArg(_) |\n+\n         // Expressions with side-effects.\n         hir::ExprAssign(..) |\n         hir::ExprAssignOp(..) |"}, {"sha": "8b6aeabcc12efe3867dabfb5dbbe2d9cc5f1efee", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -81,7 +81,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             hir::ExprLoop(ref b, _, source) => {\n                 self.with_context(Loop(LoopKind::Loop(source)), |v| v.visit_block(&b));\n             }\n-            hir::ExprClosure(.., b, _) => {\n+            hir::ExprClosure(.., b, _, _) => {\n                 self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {"}, {"sha": "8df4559a01f31cf010a27afd306c79460c9dab3d", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -158,6 +158,8 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             TerminatorKind::DropAndReplace { .. } => \"TerminatorKind::DropAndReplace\",\n             TerminatorKind::Call { .. } => \"TerminatorKind::Call\",\n             TerminatorKind::Assert { .. } => \"TerminatorKind::Assert\",\n+            TerminatorKind::GeneratorDrop => \"TerminatorKind::GeneratorDrop\",\n+            TerminatorKind::Suspend { .. } => \"TerminatorKind::Suspend\",\n         }, kind);\n         self.super_terminator_kind(block, kind, location);\n     }\n@@ -169,6 +171,8 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.record(match *msg {\n             AssertMessage::BoundsCheck { .. } => \"AssertMessage::BoundsCheck\",\n             AssertMessage::Math(..) => \"AssertMessage::Math\",\n+            AssertMessage::GeneratorResumedAfterReturn => \"AssertMessage::GeneratorResumedAfterReturn\",\n+            AssertMessage::GeneratorResumedAfterPanic => \"AssertMessage::GeneratorResumedAfterPanic\",\n         }, msg);\n         self.super_assert_message(msg, location);\n     }\n@@ -196,6 +200,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n                     AggregateKind::Tuple => \"AggregateKind::Tuple\",\n                     AggregateKind::Adt(..) => \"AggregateKind::Adt\",\n                     AggregateKind::Closure(..) => \"AggregateKind::Closure\",\n+                    AggregateKind::Generator(..) => \"AggregateKind::Generator\",\n                 }, kind);\n \n                 \"Rvalue::Aggregate\""}, {"sha": "11db23732fba3e2dd5f5ed5abd31d66c95f3f089", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -77,6 +77,12 @@ pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n             if variant_index > 0 { bug!(\"{} is a closure, which only has one variant\", t);}\n             substs.upvar_tys(def_id, cx.tcx()).collect()\n         },\n+        ty::TyGenerator(def_id, substs, _) => {\n+            if variant_index > 0 { bug!(\"{} is a generator, which only has one variant\", t);}\n+            substs.field_tys(def_id, cx.tcx()).map(|t| {\n+                cx.tcx().normalize_associated_type(&t)\n+            }).collect()\n+        },\n         _ => bug!(\"{} is not a type that can have fields.\", t)\n     }\n }"}, {"sha": "d646b515bf41e89bd8be81196f27b7b2d6db381d", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -287,7 +287,9 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n \n     let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n \n-    SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id)).finish(hash)\n+    let buffer = SymbolPathBuffer::from_interned(tcx.def_symbol_name(def_id));\n+\n+    buffer.finish(hash)\n }\n \n // Follow C++ namespace-mangling style, see"}, {"sha": "57edb14a42d4145b09b3f6699c55628e4558eea7", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -629,6 +629,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::TerminatorKind::Return |\n             mir::TerminatorKind::Unreachable |\n             mir::TerminatorKind::Assert { .. } => {}\n+            mir::TerminatorKind::GeneratorDrop |\n+            mir::TerminatorKind::Suspend { .. } => bug!(),\n         }\n \n         self.super_terminator_kind(block, kind, location);"}, {"sha": "ebadba51bcf28e0b342b358324d02d8f7acb7dca", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -28,12 +28,13 @@ use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{Layout, LayoutTyper};\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::hir;\n \n use libc::{c_uint, c_char};\n use std::iter;\n \n+use syntax::abi::Abi;\n use syntax::attr;\n use syntax::symbol::InternedString;\n use syntax_pos::Span;\n@@ -91,6 +92,16 @@ pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                 }\n             }))\n         }\n+        ty::TyGenerator(def_id, substs, _) => {\n+            let mut tys = substs.field_tys(def_id, ccx.tcx());\n+            tys.next().and_then(|first_ty| tys.next().and_then(|second_ty| {\n+                if tys.next().is_some() {\n+                    None\n+                } else {\n+                    Some([first_ty, second_ty])\n+                }\n+            }))\n+        }\n         ty::TyTuple(tys, _) => {\n             if tys.len() != 2 {\n                 return None;\n@@ -517,6 +528,28 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 sig.abi\n             ))\n         }\n+        ty::TyGenerator(def_id, substs, _) => {\n+            let tcx = ccx.tcx();\n+            let sig = tcx.generator_sig(def_id).unwrap().subst(tcx, substs.substs);\n+\n+            let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n+            let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n+\n+            sig.map_bound(|sig| {\n+                let state_did = tcx.lang_items.gen_state().unwrap();\n+                let state_adt_ref = tcx.adt_def(state_did);\n+                let state_substs = tcx.mk_substs([Kind::from(sig.suspend_ty),\n+                    Kind::from(sig.return_ty)].iter());\n+                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+\n+                tcx.mk_fn_sig(iter::once(env_ty).chain(iter::once(sig.impl_arg_ty)),\n+                    ret_ty,\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    Abi::Rust\n+                )\n+            })\n+        }\n         _ => bug!(\"unexpected type {:?} to ty_fn_sig\", ty)\n     }\n }"}, {"sha": "399176461dfae2c348d00829a81b98dd3547b9df", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -580,6 +580,16 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n+        ty::TyGenerator(def_id, substs, _) => {\n+            let upvar_tys : Vec<_> = substs.field_tys(def_id, cx.tcx()).map(|t| {\n+                cx.tcx().normalize_associated_type(&t)\n+            }).collect();\n+            prepare_tuple_metadata(cx,\n+                                   t,\n+                                   &upvar_tys,\n+                                   unique_type_id,\n+                                   usage_site_span).finalize(cx)\n+        }\n         ty::TyAdt(def, ..) => match def.adt_kind() {\n             AdtKind::Struct => {\n                 prepare_struct_metadata(cx,"}, {"sha": "826b4c09cc2d3714be97c5ac9e840d0b98cff0a1", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -165,6 +165,9 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyClosure(..) => {\n             output.push_str(\"closure\");\n         }\n+        ty::TyGenerator(..) => {\n+            output.push_str(\"generator\");\n+        }\n         ty::TyError |\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |"}, {"sha": "54f2af3c179bd767ba61f33d9e588d948be862c4", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -215,8 +215,10 @@ pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock\n                 TerminatorKind::Goto { .. } |\n                 TerminatorKind::Resume |\n                 TerminatorKind::Return |\n+                TerminatorKind::GeneratorDrop |\n                 TerminatorKind::Unreachable |\n-                TerminatorKind::SwitchInt { .. } => {\n+                TerminatorKind::SwitchInt { .. } |\n+                TerminatorKind::Suspend { .. }  => {\n                     /* nothing to do */\n                 }\n                 TerminatorKind::Call { cleanup: unwind, .. } |"}, {"sha": "a0369b80df0d83c79ea499a0d4208ab7d38ac2c0", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -374,6 +374,27 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                          vec![msg_file_line_col],\n                          Some(ErrKind::Math(err.clone())))\n                     }\n+                    mir::AssertMessage::GeneratorResumedAfterReturn |\n+                    mir::AssertMessage::GeneratorResumedAfterPanic => {\n+                        let str = if let mir::AssertMessage::GeneratorResumedAfterReturn = *msg {\n+                            \"generator resumed after completion\"\n+                        } else {\n+                            \"generator resumed after panicking\"\n+                        };\n+                        let msg_str = Symbol::intern(str).as_str();\n+                        let msg_str = C_str_slice(bcx.ccx, msg_str);\n+                        let msg_file_line = C_struct(bcx.ccx,\n+                                                     &[msg_str, filename, line],\n+                                                     false);\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line));\n+                        let msg_file_line = consts::addr_of(bcx.ccx,\n+                                                            msg_file_line,\n+                                                            align,\n+                                                            \"panic_loc\");\n+                        (lang_items::PanicFnLangItem,\n+                         vec![msg_file_line],\n+                         None)\n+                    }\n                 };\n \n                 // If we know we always panic, and the error message\n@@ -557,6 +578,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         destination.as_ref().map(|&(_, target)| (ret_dest, sig.output(), target)),\n                         cleanup);\n             }\n+            mir::TerminatorKind::GeneratorDrop |\n+            mir::TerminatorKind::Suspend { .. } => bug!(\"generator ops in trans\"),\n         }\n     }\n "}, {"sha": "6f03a806a414888e77b781be4defe19fe96732dc", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -322,6 +322,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             mir::AssertMessage::Math(ref err) => {\n                                 ErrKind::Math(err.clone())\n                             }\n+                            mir::AssertMessage::GeneratorResumedAfterReturn |\n+                            mir::AssertMessage::GeneratorResumedAfterPanic => \n+                                span_bug!(span, \"{:?} should not appear in constants?\", msg),\n                         };\n \n                         let err = ConstEvalErr { span: span, kind: err };\n@@ -565,6 +568,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     }\n                     mir::AggregateKind::Adt(..) |\n                     mir::AggregateKind::Closure(..) |\n+                    mir::AggregateKind::Generator(..) |\n                     mir::AggregateKind::Tuple => {\n                         Const::new(trans_const(self.ccx, dest_ty, kind, &fields), dest_ty)\n                     }"}, {"sha": "ba27f684ab3f30c5cceb8162ec89eeddca731985", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -524,15 +524,15 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             }\n \n             // Or is it the closure environment?\n-            let (closure_ty, env_ref) = if let ty::TyRef(_, mt) = arg_ty.sty {\n-                (mt.ty, true)\n-            } else {\n-                (arg_ty, false)\n+            let (closure_ty, env_ref) = match arg_ty.sty {\n+                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (mt.ty, true),\n+                _ => (arg_ty, false)\n             };\n-            let upvar_tys = if let ty::TyClosure(def_id, substs) = closure_ty.sty {\n-                substs.upvar_tys(def_id, tcx)\n-            } else {\n-                bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_ty);\n+            \n+            let upvar_tys = match closure_ty.sty {\n+                ty::TyClosure(def_id, substs) |\n+                ty::TyGenerator(def_id, substs, _) => substs.upvar_tys(def_id, tcx),\n+                _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_ty)\n             };\n \n             // Store the pointer to closure data in an alloca for debuginfo"}, {"sha": "94612ef652331addbcd86ff82fd7377c57f9bf7f", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -125,6 +125,12 @@ fn resolve_associated_item<'a, 'tcx>(\n             let substs = tcx.erase_regions(&substs);\n             ty::Instance::new(def_id, substs)\n         }\n+        traits::VtableGenerator(closure_data) => {\n+            Instance {\n+                def: ty::InstanceDef::Item(closure_data.closure_def_id),\n+                substs: closure_data.substs.substs\n+            }\n+        }\n         traits::VtableClosure(closure_data) => {\n             let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n             resolve_closure(scx, closure_data.closure_def_id, closure_data.substs,"}, {"sha": "3841e9bfeb7230bc3aa379b521ffe07e23d01cd5", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -504,6 +504,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                     self.push_type_name(sig.output(), output);\n                 }\n             },\n+            ty::TyGenerator(def_id, ref closure_substs, _) |\n             ty::TyClosure(def_id, ref closure_substs) => {\n                 self.push_def_path(def_id, output);\n                 let generics = self.tcx.generics_of(self.tcx.closure_base_def_id(def_id));"}, {"sha": "38c49833e0d75e305521e4a09e42a32ee436ee0a", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -133,6 +133,11 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           // fill it in *after* placing it into the type cache.\n           adt::incomplete_type_of(cx, t, \"closure\")\n       }\n+      ty::TyGenerator(..) => {\n+          // Only create the named struct, but don't fill it in. We\n+          // fill it in *after* placing it into the type cache.\n+          adt::incomplete_type_of(cx, t, \"generator\")\n+      }\n \n       ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n       ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n@@ -197,7 +202,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n-        ty::TyAdt(..) | ty::TyClosure(..) if !t.is_simd() && !t.is_box() => {\n+        ty::TyAdt(..) | ty::TyClosure(..) | ty::TyGenerator(..) if !t.is_simd() && !t.is_box() => {\n             adt::finish_type_of(cx, t, &mut llty);\n         }\n         _ => ()"}, {"sha": "4884c811a1b3c7cfdeb7cb6358f9d82fcb065aad", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -32,7 +32,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n                expr,\n                expected);\n-\n+        // FIXME: See if expected_kind here can impact generators\n+        \n         // It's always helpful for inference if we know the kind of\n         // closure sooner rather than later, so first examine the expected\n         // type, and see if can glean a closure kind from there.\n@@ -70,22 +71,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // inference phase (`upvar.rs`).\n         let base_substs = Substs::identity_for_item(self.tcx,\n             self.tcx.closure_base_def_id(expr_def_id));\n-        let closure_type = self.tcx.mk_closure(expr_def_id,\n-            base_substs.extend_to(self.tcx, expr_def_id,\n+        let substs = base_substs.extend_to(self.tcx, expr_def_id,\n                 |_, _| span_bug!(expr.span, \"closure has region param\"),\n                 |_, _| self.infcx.next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n-            )\n         );\n \n-        debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n-\n         let fn_sig = self.liberate_late_bound_regions(expr_def_id, &sig);\n         let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n                                                             body.value.id,\n                                                             self.param_env,\n                                                             &fn_sig);\n \n-        check_fn(self, self.param_env, fn_sig, decl, expr.id, body);\n+        let interior = check_fn(self, self.param_env, fn_sig, decl, expr.id, body).1;\n+\n+        if let Some(interior) = interior {\n+            let closure_substs = ty::ClosureSubsts {\n+                substs: substs,\n+            };\n+            return self.tcx.mk_generator(expr_def_id, closure_substs, interior);\n+        }\n+\n+        let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n+\n+        debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table."}, {"sha": "3b6708470a1420e1c2bd746223343c614fb67965", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::hir::{self, Body, Pat, PatKind, Expr};\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::Ty;\n+use rustc::middle::region::{RegionMaps, CodeExtent, extent_has_yield};\n+use util::nodemap::FxHashSet;\n+use std::rc::Rc;\n+use super::FnCtxt;\n+\n+struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+    types: FxHashSet<Ty<'tcx>>,\n+    region_maps: Rc<RegionMaps>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n+    fn record(&mut self, ty: Ty<'tcx>, scope: Option<CodeExtent>, expr: Option<&'tcx Expr>) {\n+        use syntax_pos::DUMMY_SP;\n+\n+        if scope.map(|s| extent_has_yield(self.fcx.tcx, s)).unwrap_or(true) {\n+            if self.fcx.tcx.sess.verbose() {\n+                if let Some(s) = scope {\n+                    self.fcx.tcx.sess.span_warn(s.span(&self.fcx.tcx.hir).unwrap_or(DUMMY_SP),\n+                        &format!(\"type in generator with scope = {:?}, type = {:?}\", scope, self.fcx.resolve_type_vars_if_possible(&ty)));\n+                } else {\n+                    self.fcx.tcx.sess.span_warn(DUMMY_SP,\n+                        &format!(\"type in generator WITHOUT scope, type = {:?}\", self.fcx.resolve_type_vars_if_possible(&ty)));\n+                }\n+                if let Some(e) = expr {\n+                    self.fcx.tcx.sess.span_warn(e.span,\n+                        &format!(\"type from expression: {:?}\", e));\n+                }\n+            }\n+            self.types.insert(ty);\n+        } else if self.fcx.tcx.sess.verbose() {\n+            if let Some(e) = expr {\n+                self.fcx.tcx.sess.span_warn(e.span,\n+                    &format!(\"NO type from expression: {:?}\", e));\n+            }\n+        }\n+    }\n+}\n+\n+pub fn find_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>, def_id: DefId, body_id: hir::BodyId, witness: Ty<'tcx>) {\n+    let body = fcx.tcx.hir.body(body_id);\n+    let mut visitor = InteriorVisitor {\n+        fcx,\n+        types: FxHashSet(),\n+        region_maps: fcx.tcx.region_maps(def_id),\n+    };\n+    intravisit::walk_body(&mut visitor, body);\n+\n+    // FIXME: Drop elaboration can insert bool types in the generator\n+    visitor.types.insert(fcx.tcx.types.bool);\n+\n+    // Deduplicate types\n+    let set: FxHashSet<_> = visitor.types.into_iter().map(|t| fcx.resolve_type_vars_if_possible(&t)).collect();\n+    let types: Vec<_> = set.into_iter().collect();\n+\n+    let tuple = fcx.tcx.intern_tup(&types, false);\n+\n+    if fcx.tcx.sess.verbose() {\n+        fcx.tcx.sess.span_warn(body.value.span,\n+            &format!(\"Types in generator {:?}\", tuple));\n+    }\n+\n+    // Unify the tuple with the witness\n+    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(witness, tuple) {\n+        Ok(ok) => fcx.register_infer_ok_obligations(ok),\n+        _ => bug!(),\n+   }\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_body(&mut self, _body: &'tcx Body) {\n+        // Closures inside are not considered part of the generator interior\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx Pat) {\n+        if let PatKind::Binding(..) = pat.node {\n+            let scope = self.region_maps.var_scope(pat.id);\n+            let ty = self.fcx.tables.borrow().pat_ty(pat);\n+            self.record(ty, Some(scope), None);\n+        }\n+\n+        intravisit::walk_pat(self, pat);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        let scope = self.region_maps.temporary_scope(expr.id);\n+        let ty = self.fcx.tables.borrow().expr_ty_adjusted(expr);\n+        self.record(ty, scope, Some(expr));\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}"}, {"sha": "ae1724549d9fd3b42843a5142e9a9bcdf67d7d49", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -706,6 +706,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             self.assemble_closure_candidates(import_id, trait_def_id, item.clone())?;\n \n+            self.assemble_generator_candidates(import_id, trait_def_id, item.clone())?;\n+\n             self.assemble_projection_candidates(import_id, trait_def_id, item.clone());\n \n             self.assemble_where_clause_candidates(import_id, trait_def_id, item.clone());\n@@ -847,6 +849,48 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n+    fn assemble_generator_candidates(&mut self,\n+                                   import_id: Option<ast::NodeId>,\n+                                   trait_def_id: DefId,\n+                                   item: ty::AssociatedItem)\n+                                   -> Result<(), MethodError<'tcx>> {\n+        // Check if this is the Generator trait.\n+        let tcx = self.tcx;\n+        if Some(trait_def_id) != tcx.lang_items.gen_trait() {\n+            return Ok(());\n+        }\n+\n+        // Check if there is an generator self-type in the list of receivers.\n+        // If so, add \"synthetic impls\".\n+        let steps = self.steps.clone();\n+        for step in steps.iter() {\n+            match step.self_ty.sty {\n+                ty::TyGenerator(..) => (),\n+                _ => continue,\n+            };\n+\n+            // create some substitutions for the argument/return type;\n+            // for the purposes of our method lookup, we only take\n+            // receiver type into account, so we can just substitute\n+            // fresh types here to use during substitution and subtyping.\n+            let substs = Substs::for_item(self.tcx,\n+                                          trait_def_id,\n+                                          |def, _| self.region_var_for_def(self.span, def),\n+                                          |def, substs| {\n+                if def.index == 0 {\n+                    step.self_ty\n+                } else {\n+                    self.type_var_for_def(self.span, def, substs)\n+                }\n+            });\n+\n+            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n+            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n+        }\n+\n+        Ok(())\n+    }\n+\n     fn assemble_projection_candidates(&mut self,\n                                       import_id: Option<ast::NodeId>,\n                                       trait_def_id: DefId,"}, {"sha": "c763639d6057ac12c63974bf2502c8ca646b99d6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 122, "deletions": 32, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -146,6 +146,7 @@ mod cast;\n mod closure;\n mod callee;\n mod compare_method;\n+mod generator_interior;\n mod intrinsic;\n mod op;\n \n@@ -205,6 +206,8 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n \n+    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>)>>,\n+\n     // Anonymized types found in explicit return types and their\n     // associated fresh inference variable. Writeback resolves these\n     // variables to get the concrete type, which can be used to\n@@ -503,6 +506,9 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     ret_coercion: Option<RefCell<DynamicCoerceMany<'gcx, 'tcx>>>,\n \n+    suspend_ty: Option<Ty<'tcx>>,\n+    impl_arg_ty: Option<Ty<'tcx>>,\n+\n     ps: RefCell<UnsafetyState>,\n \n     /// Whether the last checked node generates a divergence (e.g.,\n@@ -606,6 +612,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             locals: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n+            deferred_generator_interiors: RefCell::new(Vec::new()),\n             anon_types: RefCell::new(NodeMap()),\n             implicit_region_bound,\n             body_id,\n@@ -726,11 +733,19 @@ pub fn provide(providers: &mut Providers) {\n         typeck_tables_of,\n         has_typeck_tables,\n         closure_kind,\n+        generator_sig,\n         adt_destructor,\n         ..*providers\n     };\n }\n \n+fn generator_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          def_id: DefId)\n+                          -> Option<ty::PolyGenSig<'tcx>> {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    tcx.typeck_tables_of(def_id).generator_sigs[&node_id].map(|s| ty::Binder(s))\n+}\n+\n fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::ClosureKind {\n@@ -856,7 +871,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   param_env,\n                                                   &fn_sig);\n \n-            check_fn(&inh, param_env, fn_sig, decl, id, body)\n+            check_fn(&inh, param_env, fn_sig, decl, id, body).0\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.id);\n             let expected_type = tcx.type_of(def_id);\n@@ -878,6 +893,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fcx.closure_analyze(body);\n         fcx.select_obligations_where_possible();\n         fcx.check_casts();\n+        fcx.find_generator_interiors(def_id);\n         fcx.select_all_obligations_or_error();\n \n         if fn_decl.is_some() {\n@@ -972,7 +988,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             decl: &'gcx hir::FnDecl,\n                             fn_id: ast::NodeId,\n                             body: &'gcx hir::Body)\n-                            -> FnCtxt<'a, 'gcx, 'tcx>\n+                            -> (FnCtxt<'a, 'gcx, 'tcx>, Option<ty::GeneratorInterior<'tcx>>)\n {\n     let mut fn_sig = fn_sig.clone();\n \n@@ -995,6 +1011,27 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fn_sig.abi\n     );\n \n+    let def_id = fcx.tcx.hir.local_def_id(fn_id);\n+    let span = body.value.span;\n+\n+    if let Some(ref impl_arg) = body.impl_arg {\n+        let impl_arg_ty = fcx.infcx.type_var_for_impl_arg(span, def_id);\n+\n+        // Require impl_arg: 'static\n+        let cause = traits::ObligationCause::new(span, body.value.id, traits::MiscObligation);;\n+        fcx.fulfillment_cx.borrow_mut()\n+                          .register_region_obligation(impl_arg_ty,\n+                                                      fcx.tcx.types.re_static,\n+                                                      cause);\n+\n+        fcx.impl_arg_ty = Some(impl_arg_ty);\n+\n+        // Write the type to the impl arg id\n+        fcx.write_ty(impl_arg.id, impl_arg_ty);\n+\n+        fcx.suspend_ty = Some(fcx.next_ty_var(TypeVariableOrigin::TypeInference(span)));\n+    }\n+\n     GatherLocalsVisitor { fcx: &fcx, }.visit_body(body);\n \n     // Add formal parameters.\n@@ -1013,6 +1050,25 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.write_ty(arg.id, arg_ty);\n     }\n \n+    let gen_ty = if body.is_generator() {\n+        let gen_sig = ty::GenSig {\n+            impl_arg_ty: fcx.impl_arg_ty.unwrap(),\n+            suspend_ty: fcx.suspend_ty.unwrap(),\n+            return_ty: ret_ty,\n+        };\n+        inherited.tables.borrow_mut().generator_sigs.insert(fn_id, Some(gen_sig));\n+\n+        let witness = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n+        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), witness));\n+        let interior = ty::GeneratorInterior::new(witness);\n+\n+        inherited.tables.borrow_mut().generator_interiors.insert(fn_id, interior);\n+\n+        Some(interior)\n+    } else {\n+        inherited.tables.borrow_mut().generator_sigs.insert(fn_id, None);\n+        None\n+    };\n     inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n \n     fcx.check_return_expr(&body.value);\n@@ -1044,11 +1100,11 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let mut actual_return_ty = coercion.complete(&fcx);\n     if actual_return_ty.is_never() {\n         actual_return_ty = fcx.next_diverging_ty_var(\n-            TypeVariableOrigin::DivergingFn(body.value.span));\n+            TypeVariableOrigin::DivergingFn(span));\n     }\n-    fcx.demand_suptype(body.value.span, ret_ty, actual_return_ty);\n+    fcx.demand_suptype(span, ret_ty, actual_return_ty);\n \n-    fcx\n+    (fcx, gen_ty)\n }\n \n fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1685,6 +1741,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n+            suspend_ty: None,\n+            impl_arg_ty: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n                                                      ast::CRATE_NODE_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n@@ -2066,6 +2124,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn find_generator_interiors(&self, def_id: DefId) {\n+        let mut deferred_generator_interiors = self.deferred_generator_interiors.borrow_mut();\n+        for (body_id, witness) in deferred_generator_interiors.drain(..) {\n+            generator_interior::find_interior(self, def_id, body_id, witness);\n+        }\n+    }\n+\n     /// Apply \"fallbacks\" to some types\n     /// unconstrained types get replaced with ! or  () (depending on whether\n     /// feature(never_type) is enabled), unconstrained ints with i32, and\n@@ -2502,7 +2567,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 let is_closure = match arg.node {\n-                    hir::ExprClosure(..) => true,\n+                    // TODO: Should this be applied for generators?\n+                    hir::ExprClosure(.., None) => true,\n                     _ => false\n                 };\n \n@@ -2629,8 +2695,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_expr_has_type_or_error(&self,\n-                                        expr: &'gcx hir::Expr,\n-                                        expected: Ty<'tcx>) -> Ty<'tcx> {\n+                               expr: &'gcx hir::Expr,\n+                               expected: Ty<'tcx>) -> Ty<'tcx> {\n         self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected))\n     }\n \n@@ -3063,13 +3129,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return field_ty;\n         }\n \n-        if tuple_like {\n+                if tuple_like {\n             type_error_struct!(self.tcx().sess, expr.span, expr_t, E0612,\n                                \"attempted out-of-bounds tuple index `{}` on type `{}`\",\n                                idx.node, expr_t).emit();\n-        } else {\n+                } else {\n             self.no_such_field_err(expr.span, idx.node, expr_t).emit();\n-        }\n+                }\n \n         self.tcx().types.err\n     }\n@@ -3135,7 +3201,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let adt_ty_hint =\n             self.expected_inputs_for_expected_output(span, expected, adt_ty, &[adt_ty])\n-            .get(0).cloned().unwrap_or(adt_ty);\n+                .get(0).cloned().unwrap_or(adt_ty);\n         // re-link the regions that EIfEO can erase.\n         self.demand_eqtype(span, adt_ty_hint, adt_ty);\n \n@@ -3173,10 +3239,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 error_happened = true;\n                 if let Some(_) = variant.find_field_named(field.name.node) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n-                                                   field.name.span,\n-                                                   E0062,\n-                                                   \"field `{}` specified more than once\",\n-                                                   field.name.node);\n+                                                field.name.span,\n+                                                E0062,\n+                                                \"field `{}` specified more than once\",\n+                                                field.name.node);\n \n                     err.span_label(field.name.span, \"used more than once\");\n \n@@ -3224,15 +3290,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         .join(\", \");\n \n             struct_span_err!(tcx.sess, span, E0063,\n-                             \"missing field{} {}{} in initializer of `{}`\",\n+                        \"missing field{} {}{} in initializer of `{}`\",\n                              if remaining_fields.len() == 1 { \"\" } else { \"s\" },\n-                             remaining_fields_names,\n-                             truncated_fields_error,\n-                             adt_ty)\n-                            .span_label(span, format!(\"missing {}{}\",\n-                                        remaining_fields_names,\n-                                        truncated_fields_error))\n-                            .emit();\n+                        remaining_fields_names,\n+                        truncated_fields_error,\n+                        adt_ty)\n+                        .span_label(span, format!(\"missing {}{}\",\n+                            remaining_fields_names,\n+                            truncated_fields_error))\n+                        .emit();\n         }\n     }\n \n@@ -3649,14 +3715,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Only check this if not in an `if` condition, as the\n                     // mistyped comparison help is more appropriate.\n                     if !self.tcx.expr_is_lval(&lhs) {\n-                        struct_span_err!(\n+                struct_span_err!(\n                             self.tcx.sess, expr.span, E0070,\n-                            \"invalid left-hand side expression\")\n-                        .span_label(\n-                            expr.span,\n-                            \"left-hand of expression not valid\")\n-                        .emit();\n-                    }\n+                    \"invalid left-hand side expression\")\n+                .span_label(\n+                    expr.span,\n+                    \"left-hand of expression not valid\")\n+                .emit();\n+            }\n                 }\n             }\n \n@@ -3730,7 +3796,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n             self.check_match(expr, &discrim, arms, expected, match_src)\n           }\n-          hir::ExprClosure(capture, ref decl, body_id, _) => {\n+          hir::ExprClosure(capture, ref decl, body_id, _, _) => {\n               self.check_expr_closure(expr, capture, &decl, body_id, expected)\n           }\n           hir::ExprBlock(ref body) => {\n@@ -3921,6 +3987,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   }\n               }\n            }\n+          hir::ExprImplArg(_) => {\n+            match self.impl_arg_ty {\n+                Some(ty) => {\n+                    ty\n+                }\n+                None => {\n+                    struct_span_err!(self.tcx.sess, expr.span, E0803,\n+                                 \"impl arg expression outside of function body\").emit();\n+                    tcx.types.err\n+                }\n+            }\n+          }\n+          hir::ExprSuspend(ref value) => {\n+            match self.suspend_ty {\n+                Some(ty) => {\n+                    self.check_expr_coercable_to_type(&value, ty);\n+                }\n+                None => {\n+                    struct_span_err!(self.tcx.sess, expr.span, E0802,\n+                                 \"yield statement outside of function body\").emit();\n+                }\n+            }\n+            tcx.mk_nil()\n+          }\n         }\n     }\n "}, {"sha": "3413144b4fe78d8e487ff5f3b8321be01cc4b1d6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -823,7 +823,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprClosure(.., body_id, _) => {\n+            hir::ExprClosure(.., body_id, _, _) => {\n                 self.check_expr_fn_block(expr, body_id);\n             }\n "}, {"sha": "bf7bbfa16b2d1a3179b156cd29d7484618b5814b", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -75,10 +75,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n         match expr.node {\n-            hir::ExprClosure(cc, _, body_id, _) => {\n+            hir::ExprClosure(cc, _, body_id, _, gen) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n-                self.fcx.analyze_closure(expr.id, expr.span, body, cc);\n+                self.fcx.analyze_closure(expr.id, expr.span, body, cc, gen.is_some());\n             }\n \n             _ => { }\n@@ -93,19 +93,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        id: ast::NodeId,\n                        span: Span,\n                        body: &hir::Body,\n-                       capture_clause: hir::CaptureClause) {\n+                       capture_clause: hir::CaptureClause,\n+                       gen: bool) {\n         /*!\n          * Analysis starting point.\n          */\n \n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n \n-        let infer_kind = match self.tables.borrow_mut().closure_kinds.entry(id) {\n-            Entry::Occupied(_) => false,\n-            Entry::Vacant(entry) => {\n-                debug!(\"check_closure: adding closure {:?} as Fn\", id);\n-                entry.insert((ty::ClosureKind::Fn, None));\n-                true\n+        let infer_kind = if gen { false } else {\n+            match self.tables.borrow_mut().closure_kinds.entry(id) {\n+                Entry::Occupied(_) => false,\n+                Entry::Vacant(entry) => {\n+                    debug!(\"check_closure: adding closure {:?} as Fn\", id);\n+                    entry.insert((ty::ClosureKind::Fn, None));\n+                    true\n+                }\n             }\n         };\n \n@@ -173,7 +176,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Extract the type variables UV0...UVn.\n         let (def_id, closure_substs) = match self.node_ty(id).sty {\n-            ty::TyClosure(def_id, substs) => (def_id, substs),\n+            ty::TyClosure(def_id, substs) |\n+            ty::TyGenerator(def_id, substs, _) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n                     span,"}, {"sha": "2b166d2418b742839be2dd4f2f9b4fd9969a0062", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -36,6 +36,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         for arg in &body.arguments {\n             wbcx.visit_node_id(arg.pat.span, arg.id);\n         }\n+        if let Some(ref impl_arg) = body.impl_arg {\n+            wbcx.visit_node_id(impl_arg.span, impl_arg.id);\n+        }\n         wbcx.visit_body(body);\n         wbcx.visit_upvar_borrow_map();\n         wbcx.visit_closures();\n@@ -45,6 +48,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_cast_types();\n         wbcx.visit_lints();\n         wbcx.visit_free_region_map();\n+        wbcx.visit_generator_sigs();\n+        wbcx.visit_generator_interiors();\n \n         let used_trait_imports = mem::replace(&mut self.tables.borrow_mut().used_trait_imports,\n                                               DefIdSet());\n@@ -160,8 +165,9 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n         self.visit_node_id(e.span, e.id);\n \n-        if let hir::ExprClosure(_, _, body, _) = e.node {\n+        if let hir::ExprClosure(_, _, body, _, _) = e.node {\n             let body = self.fcx.tcx.hir.body(body);\n+            // FIXME: Why visit the args here?\n             for arg in &body.arguments {\n                 self.visit_node_id(e.span, arg.id);\n             }\n@@ -312,6 +318,24 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_generator_interiors(&mut self) {\n+        for (&node_id, interior) in self.fcx.tables.borrow().generator_interiors.iter() {\n+            let interior = self.resolve(interior, &node_id);\n+            self.tables.generator_interiors.insert(node_id, interior);\n+        }\n+    }\n+\n+    fn visit_generator_sigs(&mut self) {\n+        for (&node_id, gen_sig) in self.fcx.tables.borrow().generator_sigs.iter() {\n+            let gen_sig = gen_sig.map(|s| ty::GenSig {\n+                impl_arg_ty: self.resolve(&s.impl_arg_ty, &node_id),\n+                suspend_ty: self.resolve(&s.suspend_ty, &node_id),\n+                return_ty: self.resolve(&s.return_ty, &node_id),\n+            });\n+            self.tables.generator_sigs.insert(node_id, gen_sig);\n+        }\n+    }\n+\n     fn visit_liberated_fn_sigs(&mut self) {\n         for (&node_id, fn_sig) in self.fcx.tables.borrow().liberated_fn_sigs.iter() {\n             let fn_sig = self.resolve(fn_sig, &node_id);"}, {"sha": "581a62d377de026fdb97e7ed62b1c46241f22fa5", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -1155,7 +1155,11 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeField(field) => icx.to_ty(&field.ty),\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(.., gen), .. }) => {\n+            if gen.is_some() {\n+                return tcx.typeck_tables_of(def_id).node_id_to_type(node_id);\n+            }\n+            \n             tcx.mk_closure(def_id, Substs::for_item(\n                 tcx, def_id,\n                 |def, _| {"}, {"sha": "4313aa59202f9c5996461a771d9e4612ca35821a", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -4667,4 +4667,8 @@ register_diagnostics! {\n     E0588, // packed struct cannot transitively contain a `[repr(align)]` struct\n     E0592, // duplicate definitions with name `{}`\n //  E0613, // Removed (merged with E0609)\n+    E0801, // unexpected generator return\n+    E0802, // yield statement outside of function body\n+    E0803, // impl arg expression outside of function body\n+    E0804, // cannot determine the type for the implicit argument of this generator\n }"}, {"sha": "6e9e6137b444391d9193e41670565cf208d541ee", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -149,11 +149,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         //\n         // See README.md for a detailed discussion\n         // on dep-graph management.\n-        let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-        tcx.dep_graph.with_task(dep_node,\n-                                AssertDepGraphSafe(self),\n-                                def_id,\n-                                visit_item_task);\n+                let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+                tcx.dep_graph.with_task(dep_node,\n+                                        AssertDepGraphSafe(self),\n+                                        def_id,\n+                                        visit_item_task);\n \n         fn visit_item_task<'a, 'tcx>(ccx: AssertDepGraphSafe<&mut ConstraintContext<'a, 'tcx>>,\n                                      def_id: DefId)\n@@ -202,9 +202,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             _ => {\n                 span_bug!(tcx.def_span(def_id),\n                           \"`build_constraints_for_item` unsupported for this item\");\n-            }\n         }\n     }\n+    }\n \n     fn add_constraint(&mut self,\n                       current: &CurrentItem,\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let variance_i = self.invariant(variance);\n         for ty in substs.types() {\n             self.add_constraints_from_ty(current, ty, variance_i);\n-        }\n+    }\n \n         for region in substs.regions() {\n             self.add_constraints_from_region(current, region, variance_i);\n@@ -294,6 +294,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyFnDef(..) |\n+            ty::TyGenerator(..) |\n             ty::TyClosure(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n@@ -349,7 +350,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyParam(ref data) => {\n                 self.add_constraint(current, data.idx, variance);\n-            }\n+                }\n \n             ty::TyFnPtr(sig) => {\n                 self.add_constraints_from_sig(current, sig, variance);\n@@ -418,7 +419,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_region(current, r, variance_i);\n             } else {\n                 bug!();\n-            }\n+        }\n         }\n     }\n \n@@ -444,7 +445,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n                 self.add_constraint(current, data.index, variance);\n-            }\n+                }\n \n             ty::ReStatic => {}\n "}, {"sha": "d8364a24dec7a08389182288df804000d62b46d6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -1935,7 +1935,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 }).collect())\n             }\n \n-            ty::TyClosure(..) => Tuple(vec![]), // FIXME(pcwalton)\n+            ty::TyClosure(..) | ty::TyGenerator(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::TyInfer(..) => panic!(\"TyInfer\"),\n             ty::TyError => panic!(\"TyError\"),"}, {"sha": "1a2299bcf1f57e36c9c63e6c4ce4a017a10452e3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -981,6 +981,12 @@ pub enum ExprKind {\n \n     /// `expr?`\n     Try(P<Expr>),\n+\n+    /// A `yield`, with an optional value to be yielded\n+    Yield(Option<P<Expr>>),\n+\n+    /// A reference to the implicit argument of a generator\n+    ImplArg,\n }\n \n /// The explicit Self type in a \"qualified path\". The actual"}, {"sha": "0f99761968ad7582a3d0021fe16c909312ba7140", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -361,6 +361,10 @@ declare_features! (\n     // Allows unsized tuple coercion.\n     (active, unsized_tuple_coercion, \"1.20.0\", Some(42877)),\n \n+    // Generators\n+    (active, generators, \"1.21.0\", None),\n+\n+\n     // global allocators and their internals\n     (active, global_allocator, \"1.20.0\", None),\n     (active, allocator_internals, \"1.20.0\", None),\n@@ -1326,6 +1330,16 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::InPlace(..) => {\n                 gate_feature_post!(&self, placement_in_syntax, e.span, EXPLAIN_PLACEMENT_IN);\n             }\n+            ast::ExprKind::Yield(..) => {\n+                gate_feature_post!(&self, generators,\n+                                  e.span,\n+                                  \"yield syntax is experimental\");\n+            }\n+            ast::ExprKind::ImplArg => {\n+                gate_feature_post!(&self, generators,\n+                                  e.span,\n+                                  \"gen arg syntax is experimental\");\n+            }\n             ast::ExprKind::Lit(ref lit) => {\n                 if let ast::LitKind::Int(_, ref ty) = lit.node {\n                     match *ty {"}, {"sha": "4a86008bb336c120dddb58a5f73b29cf2f2cbb11", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -1303,6 +1303,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                     attrs: fold_attrs(attrs.into(), folder).into(),\n                 };\n             }\n+            ExprKind::Yield(ex) => ExprKind::Yield(ex.map(|x| folder.fold_expr(x))),\n+            ExprKind::ImplArg => ExprKind::ImplArg,\n             ExprKind::Try(ex) => ExprKind::Try(folder.fold_expr(ex)),\n             ExprKind::Catch(body) => ExprKind::Catch(folder.fold_block(body)),\n         },"}, {"sha": "c377a77d87fa94b4512ad33936ebbb4597e18048", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -2146,6 +2146,12 @@ impl<'a> Parser<'a> {\n                     assert!(self.eat_keyword(keywords::Catch));\n                     return self.parse_catch_expr(lo, attrs);\n                 }\n+                if self.is_gen_arg() {\n+                    assert!(self.eat_keyword(keywords::Gen));\n+                    assert!(self.eat_keyword(keywords::Arg));\n+                    let hi = self.prev_span;\n+                    return Ok(self.mk_expr(lo.to(hi), ExprKind::ImplArg, attrs));\n+                }\n                 if self.eat_keyword(keywords::Return) {\n                     if self.token.can_begin_expr() {\n                         let e = self.parse_expr()?;\n@@ -2175,6 +2181,14 @@ impl<'a> Parser<'a> {\n                     };\n                     ex = ExprKind::Break(lt, e);\n                     hi = self.prev_span;\n+                } else if self.eat_keyword(keywords::Yield) {\n+                    if self.token.can_begin_expr() {\n+                        let e = self.parse_expr()?;\n+                        hi = e.span;\n+                        ex = ExprKind::Yield(Some(e));\n+                    } else {\n+                        ex = ExprKind::Yield(None);\n+                    }\n                 } else if self.token.is_keyword(keywords::Let) {\n                     // Catch this syntax error here, instead of in `parse_ident`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n@@ -3696,6 +3710,11 @@ impl<'a> Parser<'a> {\n         self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n     }\n \n+    fn is_gen_arg(&self) -> bool {\n+        self.token.is_keyword(keywords::Gen) &&\n+        self.look_ahead(1, |t| t.is_keyword(keywords::Arg))\n+    }\n+    \n     fn is_defaultness(&self) -> bool {\n         // `pub` is included for better error messages\n         self.token.is_keyword(keywords::Default) &&\n@@ -3799,7 +3818,8 @@ impl<'a> Parser<'a> {\n         // Starts like a simple path, but not a union item.\n         } else if self.token.is_path_start() &&\n                   !self.token.is_qpath_start() &&\n-                  !self.is_union_item() {\n+                  !self.is_union_item() &&\n+                  !self.is_gen_arg() {\n             let pth = self.parse_path(PathStyle::Expr)?;\n \n             if !self.eat(&token::Not) {"}, {"sha": "d39f11bc3eef163af0a1e5484332f53802101f41", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -106,6 +106,7 @@ fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n         keywords::True.name(),\n         keywords::Unsafe.name(),\n         keywords::While.name(),\n+        keywords::Yield.name(),\n     ].contains(&ident.name)\n }\n "}, {"sha": "114cabe26d1507bfa797ed1ae361f84df0dfc516", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -2280,6 +2280,21 @@ impl<'a> State<'a> {\n                 self.print_expr(e)?;\n                 self.pclose()?;\n             },\n+            ast::ExprKind::Yield(ref e) => {\n+                word(&mut self.s, \"yield\")?;\n+                match *e {\n+                    Some(ref expr) => {\n+                        word(&mut self.s, \" \")?;\n+                        self.print_expr(&expr)?;\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            ast::ExprKind::ImplArg => {\n+                word(&mut self.s, \"impl\")?;\n+                space(&mut self.s)?;\n+                word(&mut self.s, \"arg\")?;\n+            }\n             ast::ExprKind::Try(ref e) => {\n                 self.print_expr(e)?;\n                 self.s.word(\"?\")?"}, {"sha": "cd8a2f1534b9377fe8c3db44fd24b40f9f387a93", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -784,6 +784,10 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n                 visitor.visit_expr(&output.expr)\n             }\n         }\n+        ExprKind::Yield(ref optional_expression) => {\n+            walk_list!(visitor, visit_expr, optional_expression);\n+        }\n+        ExprKind::ImplArg => (),\n         ExprKind::Try(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }"}, {"sha": "1123c33c0c28b1eebaed2d97feae35ce10d366b1", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -307,6 +307,8 @@ declare_keywords! {\n     (56, StaticLifetime, \"'static\")\n     (57, Union,          \"union\")\n     (58, Catch,          \"catch\")\n+    (59, Arg,            \"arg\")\n+    (60, Gen,            \"gen\")\n }\n \n // If an interner exists in TLS, return it. Otherwise, prepare a fresh one."}, {"sha": "8371ff4f57918884a45b62009ec83fbd210b9ea6", "filename": "src/test/compile-fail/feature-gate-generators.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Ftest%2Fcompile-fail%2Ffeature-gate-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Ftest%2Fcompile-fail%2Ffeature-gate-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-generators.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    yield true; //~ ERROR yield syntax is experimental\n+    gen arg;  //~ ERROR gen arg syntax is experimental\n+}"}, {"sha": "fa99e8553a0b4cbc56b2fd30a73861550416290d", "filename": "src/test/compile-fail/generator/const-yield.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Ftest%2Fcompile-fail%2Fgenerator%2Fconst-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Ftest%2Fcompile-fail%2Fgenerator%2Fconst-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgenerator%2Fconst-yield.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+const A: u8 = { yield 3u8; 3u8}; //~ ERROR yield statement outside of function body\n+static B: u8 = { yield 3u8; 3u8}; //~ ERROR yield statement outside of function body\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "e33924c28949d8760b8381388868b54ee6e8ebf7", "filename": "src/test/compile-fail/generator/generator-not-fnmut.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Ftest%2Fcompile-fail%2Fgenerator%2Fgenerator-not-fnmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Ftest%2Fcompile-fail%2Fgenerator%2Fgenerator-not-fnmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgenerator%2Fgenerator-not-fnmut.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn main() {\n+\tlet mut a = Vec::<bool>::new();\n+\n+\tlet mut test = || {\n+\t\tlet _: () = gen arg;\n+\t\tyield 3;\n+\t\ta.push(true);\n+\t\t2\n+\t};\n+\n+\tlet a1 = test();\n+\tlet a2 = test(); //~ ERROR use of moved value\n+}"}, {"sha": "39a43690d943d2bce1df59ecb5f8eb87dceda537", "filename": "src/test/run-pass/generator/iterator-count.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Ftest%2Frun-pass%2Fgenerator%2Fiterator-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d861982ca6a1fa5773373362771aa08b9f732de0/src%2Ftest%2Frun-pass%2Fgenerator%2Fiterator-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fiterator-count.rs?ref=d861982ca6a1fa5773373362771aa08b9f732de0", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators, generator_trait, conservative_impl_trait)]\n+\n+use std::ops::{State, Generator};\n+\n+struct W<T>(T);\n+\n+impl<T: Generator<Return = ()>> Iterator for W<T> {\n+    type Item = T::Yield;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.0.resume(()) {\n+            State::Complete(..) => None,\n+            State::Yielded(v) => Some(v),\n+        }\n+    }\n+}\n+\n+fn test() -> impl Generator<Return=(), Yield=u8> {\n+\tfor i in 1..6 {\n+\t\tyield i\n+\t}\n+}\n+\n+fn main() {\n+\tlet end = 11;\n+\n+\tlet closure_test = |start| {\n+\t\tfor i in start..end {\n+\t\t\tyield i\n+\t\t}\n+\t};\n+\n+\tassert!(W(test()).chain(W(closure_test(6))).eq(1..11));\n+}"}]}