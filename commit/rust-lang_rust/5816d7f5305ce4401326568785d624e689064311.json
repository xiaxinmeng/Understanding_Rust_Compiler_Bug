{"sha": "5816d7f5305ce4401326568785d624e689064311", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MTZkN2Y1MzA1Y2U0NDAxMzI2NTY4Nzg1ZDYyNGU2ODkwNjQzMTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-26T19:17:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-27T02:10:57Z"}, "message": "More test fixes and rebase conflicts!", "tree": {"sha": "755e6d6f67ea238da49c5a697375b20b2513bc66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/755e6d6f67ea238da49c5a697375b20b2513bc66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5816d7f5305ce4401326568785d624e689064311", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5816d7f5305ce4401326568785d624e689064311", "html_url": "https://github.com/rust-lang/rust/commit/5816d7f5305ce4401326568785d624e689064311", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5816d7f5305ce4401326568785d624e689064311/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8d743ec1d0a23b0da41f8d79d18b45932a6dd5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8d743ec1d0a23b0da41f8d79d18b45932a6dd5a", "html_url": "https://github.com/rust-lang/rust/commit/e8d743ec1d0a23b0da41f8d79d18b45932a6dd5a"}], "stats": {"total": 247, "additions": 128, "deletions": 119}, "files": [{"sha": "cbf45ee36a3d8e30c8c60776c2cc62ae7306f3e8", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5816d7f5305ce4401326568785d624e689064311/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5816d7f5305ce4401326568785d624e689064311/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=5816d7f5305ce4401326568785d624e689064311", "patch": "@@ -572,7 +572,7 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n     fn next_back(&mut self) -> Option<(&'a T)> { self.iter.next_back() }\n }\n \n-impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n pub struct MoveItems<T> {"}, {"sha": "e11ba35367e2eb56770887eb8e3ea9cdb9f18af6", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5816d7f5305ce4401326568785d624e689064311/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5816d7f5305ce4401326568785d624e689064311/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=5816d7f5305ce4401326568785d624e689064311", "patch": "@@ -797,7 +797,7 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n }\n \n \n-impl<T> ExactSize<T> for MoveItems<T> {}\n+impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n \n impl<A: PartialEq> PartialEq for RingBuf<A> {\n     fn eq(&self, other: &RingBuf<A>) -> bool {"}, {"sha": "81209763a0c5aed06a7bb37ea7d40b4b9debf40d", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5816d7f5305ce4401326568785d624e689064311/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5816d7f5305ce4401326568785d624e689064311/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=5816d7f5305ce4401326568785d624e689064311", "patch": "@@ -147,5 +147,6 @@ register_diagnostics!(\n     E0168,\n     E0169,\n     E0170,\n-    E0171\n+    E0171,\n+    E0172\n )"}, {"sha": "cd7260b1812a33f9e5a4965e2ef18e20ebcdef0c", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5816d7f5305ce4401326568785d624e689064311/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5816d7f5305ce4401326568785d624e689064311/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=5816d7f5305ce4401326568785d624e689064311", "patch": "@@ -42,18 +42,19 @@ pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n                               trait_ref: Rc<ty::TraitRef<'tcx>>)\n                               -> Supertraits<'cx, 'tcx>\n {\n-    /// Returns an iterator over the trait reference `T` and all of its supertrait references. May\n-    /// contain duplicates. In general the ordering is not defined.\n-    ///\n-    /// Example:\n-    ///\n-    /// ```\n-    /// trait Foo { ... }\n-    /// trait Bar : Foo { ... }\n-    /// trait Baz : Bar+Foo { ... }\n-    /// ```\n-    ///\n-    /// `supertraits(Baz)` yields `[Baz, Bar, Foo, Foo]` in some order.\n+    //! Returns an iterator over the trait reference `T` and all of its supertrait references. May\n+    //! contain duplicates. In general the ordering is not defined.\n+    //!\n+    //! Example:\n+    //!\n+    //! ```\n+    //! trait Foo { ... }\n+    //! trait Bar : Foo { ... }\n+    //! trait Baz : Bar+Foo { ... }\n+    //! ```\n+    //!\n+    //! `supertraits(Baz)` yields `[Baz, Bar, Foo, Foo]` in some order.\n+\n     transitive_bounds(tcx, &[trait_ref])\n }\n "}, {"sha": "89c004fc64596e0ab192b4c87d86b6c0c59fb28d", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5816d7f5305ce4401326568785d624e689064311/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5816d7f5305ce4401326568785d624e689064311/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5816d7f5305ce4401326568785d624e689064311", "patch": "@@ -703,7 +703,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                                     path));\n                 }\n                 _ => {\n-                    span_err!(this.tcx().sess, ty.span, E0170, \"expected a reference to a trait\");\n+                    span_err!(this.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n                     Err(ErrorReported)\n                 }\n             }"}, {"sha": "40a38d45fa0785beafb717c58d354986af4e05c6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5816d7f5305ce4401326568785d624e689064311/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5816d7f5305ce4401326568785d624e689064311/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5816d7f5305ce4401326568785d624e689064311", "patch": "@@ -1252,8 +1252,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                 -> bool\n     {\n \n-        */\n-\n         let trait_params = trait_generics.regions.get_slice(subst::FnSpace);\n         let impl_params = impl_generics.regions.get_slice(subst::FnSpace);\n "}, {"sha": "f0fd94958ee97a2d68d6c336b42e540fd5e98f41", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5816d7f5305ce4401326568785d624e689064311/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5816d7f5305ce4401326568785d624e689064311/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=5816d7f5305ce4401326568785d624e689064311", "patch": "@@ -552,7 +552,7 @@ impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n                 self.kind)\n     }\n \n-    //! See the `appropriate_rvalue_mode()` function\n+    /// See the `appropriate_rvalue_mode()` function\n     pub fn appropriate_rvalue_mode<'a>(&self, ccx: &CrateContext<'a, 'tcx>)\n                                        -> RvalueMode {\n         appropriate_rvalue_mode(ccx, self.ty)"}, {"sha": "7e1bfd704a9275af3bdde7e8314bb826fd224d82", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 108, "deletions": 99, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/5816d7f5305ce4401326568785d624e689064311/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5816d7f5305ce4401326568785d624e689064311/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=5816d7f5305ce4401326568785d624e689064311", "patch": "@@ -13,15 +13,15 @@\n //! Utilities for formatting and printing strings\n //!\n //! This module contains the runtime support for the `format!` syntax extension.\n-//! This macro is implemented in the compiler to emit calls to this module in order\n-//! to format arguments at runtime into strings and streams.\n+//! This macro is implemented in the compiler to emit calls to this module in\n+//! order to format arguments at runtime into strings and streams.\n //!\n-//! The functions contained in this module should not normally be used in everyday\n-//! use cases of `format!`. The assumptions made by these functions are unsafe for\n-//! all inputs, and the compiler performs a large amount of validation on the\n-//! arguments to `format!` in order to ensure safety at runtime. While it is\n-//! possible to call these functions directly, it is not recommended to do so in the\n-//! general case.\n+//! The functions contained in this module should not normally be used in\n+//! everyday use cases of `format!`. The assumptions made by these functions are\n+//! unsafe for all inputs, and the compiler performs a large amount of\n+//! validation on the arguments to `format!` in order to ensure safety at\n+//! runtime. While it is possible to call these functions directly, it is not\n+//! recommended to do so in the general case.\n //!\n //! ## Usage\n //!\n@@ -46,9 +46,9 @@\n //!\n //! From these, you can see that the first argument is a format string. It is\n //! required by the compiler for this to be a string literal; it cannot be a\n-//! variable passed in (in order to perform validity checking). The compiler will\n-//! then parse the format string and determine if the list of arguments provided is\n-//! suitable to pass to this format string.\n+//! variable passed in (in order to perform validity checking). The compiler\n+//! will then parse the format string and determine if the list of arguments\n+//! provided is suitable to pass to this format string.\n //!\n //! ### Positional parameters\n //!\n@@ -60,16 +60,16 @@\n //!\n //! Things can get a little tricky once you start intermingling the two types of\n //! positional specifiers. The \"next argument\" specifier can be thought of as an\n-//! iterator over the argument. Each time a \"next argument\" specifier is seen, the\n-//! iterator advances. This leads to behavior like this:\n+//! iterator over the argument. Each time a \"next argument\" specifier is seen,\n+//! the iterator advances. This leads to behavior like this:\n //!\n //! ```rust\n //! format!(\"{1} {} {0} {}\", 1i, 2i); // => \"2 1 1 2\"\n //! ```\n //!\n-//! The internal iterator over the argument has not been advanced by the time the\n-//! first `{}` is seen, so it prints the first argument. Then upon reaching the\n-//! second `{}`, the iterator has advanced forward to the second argument.\n+//! The internal iterator over the argument has not been advanced by the time\n+//! the first `{}` is seen, so it prints the first argument. Then upon reaching\n+//! the second `{}`, the iterator has advanced forward to the second argument.\n //! Essentially, parameters which explicitly name their argument do not affect\n //! parameters which do not name an argument in terms of positional specifiers.\n //!\n@@ -98,38 +98,41 @@\n //! # }\n //! ```\n //!\n-//! It is illegal to put positional parameters (those without names) after arguments\n-//! which have names. Like with positional parameters, it is illegal to provide\n-//! named parameters that are unused by the format string.\n+//! It is illegal to put positional parameters (those without names) after\n+//! arguments which have names. Like with positional parameters, it is illegal\n+//! to provide named parameters that are unused by the format string.\n //!\n //! ### Argument types\n //!\n-//! Each argument's type is dictated by the format string. It is a requirement that every argument is\n-//! only ever referred to by one type. For example, this is an invalid format string:\n+//! Each argument's type is dictated by the format string. It is a requirement\n+//! that every argument is only ever referred to by one type. For example, this\n+//! is an invalid format string:\n //!\n //! ```text\n //! {0:x} {0:o}\n //! ```\n //!\n-//! This is invalid because the first argument is both referred to as a hexidecimal as well as an\n+//! This is invalid because the first argument is both referred to as a\n+//! hexidecimal as well as an\n //! octal.\n //!\n-//! There are various parameters which do require a particular type, however. Namely if the syntax\n-//! `{:.*}` is used, then the number of characters to print precedes the actual object being formatted,\n-//! and the number of characters must have the type `uint`. Although a `uint` can be printed with\n-//! `{}`, it is illegal to reference an argument as such. For example this is another invalid\n-//! format string:\n+//! There are various parameters which do require a particular type, however.\n+//! Namely if the syntax `{:.*}` is used, then the number of characters to print\n+//! precedes the actual object being formatted, and the number of characters\n+//! must have the type `uint`. Although a `uint` can be printed with `{}`, it is\n+//! illegal to reference an argument as such. For example this is another\n+//! invalid format string:\n //!\n //! ```text\n //! {:.*} {0}\n //! ```\n //!\n //! ### Formatting traits\n //!\n-//! When requesting that an argument be formatted with a particular type, you are\n-//! actually requesting that an argument ascribes to a particular trait. This allows\n-//! multiple actual types to be formatted via `{:x}` (like `i8` as well as `int`).\n-//! The current mapping of types to traits is:\n+//! When requesting that an argument be formatted with a particular type, you\n+//! are actually requesting that an argument ascribes to a particular trait.\n+//! This allows multiple actual types to be formatted via `{:x}` (like `i8` as\n+//! well as `int`).  The current mapping of types to traits is:\n //!\n //! * *nothing* \u21d2 `Show`\n //! * `o` \u21d2 `Octal`\n@@ -141,14 +144,14 @@\n //! * `E` \u21d2 `UpperExp`\n //!\n //! What this means is that any type of argument which implements the\n-//! `std::fmt::Binary` trait can then be formatted with `{:b}`. Implementations are\n-//! provided for these traits for a number of primitive types by the standard\n-//! library as well. If no format is specified (as in `{}` or `{:6}`), then the\n-//! format trait used is the `Show` trait. This is one of the more commonly\n-//! implemented traits when formatting a custom type.\n+//! `std::fmt::Binary` trait can then be formatted with `{:b}`. Implementations\n+//! are provided for these traits for a number of primitive types by the\n+//! standard library as well. If no format is specified (as in `{}` or `{:6}`),\n+//! then the format trait used is the `Show` trait. This is one of the more\n+//! commonly implemented traits when formatting a custom type.\n //!\n-//! When implementing a format trait for your own type, you will have to implement a\n-//! method of the signature:\n+//! When implementing a format trait for your own type, you will have to\n+//! implement a method of the signature:\n //!\n //! ```rust\n //! # use std::fmt;\n@@ -159,17 +162,17 @@\n //! # } }\n //! ```\n //!\n-//! Your type will be passed as `self` by-reference, and then the function should\n-//! emit output into the `f.buf` stream. It is up to each format trait\n-//! implementation to correctly adhere to the requested formatting parameters. The\n-//! values of these parameters will be listed in the fields of the `Formatter`\n-//! struct. In order to help with this, the `Formatter` struct also provides some\n-//! helper methods.\n+//! Your type will be passed as `self` by-reference, and then the function\n+//! should emit output into the `f.buf` stream. It is up to each format trait\n+//! implementation to correctly adhere to the requested formatting parameters.\n+//! The values of these parameters will be listed in the fields of the\n+//! `Formatter` struct. In order to help with this, the `Formatter` struct also\n+//! provides some helper methods.\n //!\n //! Additionally, the return value of this function is `fmt::Result` which is a\n //! typedef to `Result<(), IoError>` (also known as `IoResult<()>`). Formatting\n-//! implementations should ensure that they return errors from `write!` correctly\n-//! (propagating errors upward).\n+//! implementations should ensure that they return errors from `write!`\n+//! correctly (propagating errors upward).\n //!\n //! An example of implementing the formatting traits would look\n //! like:\n@@ -193,8 +196,8 @@\n //!     }\n //! }\n //!\n-//! // Different traits allow different forms of output of a type. The meaning of\n-//! // this format is to print the magnitude of a vector.\n+//! // Different traits allow different forms of output of a type. The meaning\n+//! // of this format is to print the magnitude of a vector.\n //! impl fmt::Binary for Vector2D {\n //!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n //!         let magnitude = (self.x * self.x + self.y * self.y) as f64;\n@@ -219,8 +222,8 @@\n //!\n //! ### Related macros\n //!\n-//! There are a number of related macros in the `format!` family. The ones that are\n-//! currently implemented are:\n+//! There are a number of related macros in the `format!` family. The ones that\n+//! are currently implemented are:\n //!\n //! ```ignore\n //! format!      // described above\n@@ -233,10 +236,11 @@\n //!\n //! #### `write!`\n //!\n-//! This and `writeln` are two macros which are used to emit the format string to a\n-//! specified stream. This is used to prevent intermediate allocations of format\n-//! strings and instead directly write the output. Under the hood, this function is\n-//! actually invoking the `write` function defined in this module. Example usage is:\n+//! This and `writeln` are two macros which are used to emit the format string\n+//! to a specified stream. This is used to prevent intermediate allocations of\n+//! format strings and instead directly write the output. Under the hood, this\n+//! function is actually invoking the `write` function defined in this module.\n+//! Example usage is:\n //!\n //! ```rust\n //! # #![allow(unused_must_use)]\n@@ -248,9 +252,9 @@\n //!\n //! #### `print!`\n //!\n-//! This and `println` emit their output to stdout. Similarly to the `write!` macro,\n-//! the goal of these macros is to avoid intermediate allocations when printing\n-//! output. Example usage is:\n+//! This and `println` emit their output to stdout. Similarly to the `write!`\n+//! macro, the goal of these macros is to avoid intermediate allocations when\n+//! printing output. Example usage is:\n //!\n //! ```rust\n //! print!(\"Hello {}!\", \"world\");\n@@ -274,7 +278,8 @@\n //! format_args!(fmt::format, \"this returns {}\", \"String\");\n //!\n //! let some_writer: &mut io::Writer = &mut io::stdout();\n-//! format_args!(|args| { write!(some_writer, \"{}\", args) }, \"print with a {}\", \"closure\");\n+//! format_args!(|args| { write!(some_writer, \"{}\", args) },\n+//!              \"print with a {}\", \"closure\");\n //!\n //! fn my_fmt_fn(args: &fmt::Arguments) {\n //!     write!(&mut io::stdout(), \"{}\", args);\n@@ -283,28 +288,28 @@\n //! # }\n //! ```\n //!\n-//! The first argument of the `format_args!` macro is a function (or closure) which\n-//! takes one argument of type `&fmt::Arguments`. This structure can then be\n-//! passed to the `write` and `format` functions inside this module in order to\n-//! process the format string. The goal of this macro is to even further prevent\n-//! intermediate allocations when dealing formatting strings.\n+//! The first argument of the `format_args!` macro is a function (or closure)\n+//! which takes one argument of type `&fmt::Arguments`. This structure can then\n+//! be passed to the `write` and `format` functions inside this module in order\n+//! to process the format string. The goal of this macro is to even further\n+//! prevent intermediate allocations when dealing formatting strings.\n //!\n-//! For example, a logging library could use the standard formatting syntax, but it\n-//! would internally pass around this structure until it has been determined where\n-//! output should go to.\n+//! For example, a logging library could use the standard formatting syntax, but\n+//! it would internally pass around this structure until it has been determined\n+//! where output should go to.\n //!\n-//! It is unsafe to programmatically create an instance of `fmt::Arguments` because\n-//! the operations performed when executing a format string require the compile-time\n-//! checks provided by the compiler. The `format_args!` macro is the only method of\n-//! safely creating these structures, but they can be unsafely created with the\n-//! constructor provided.\n+//! It is unsafe to programmatically create an instance of `fmt::Arguments`\n+//! because the operations performed when executing a format string require the\n+//! compile-time checks provided by the compiler. The `format_args!` macro is\n+//! the only method of safely creating these structures, but they can be\n+//! unsafely created with the constructor provided.\n //!\n //! ## Syntax\n //!\n-//! The syntax for the formatting language used is drawn from other languages, so it\n-//! should not be too alien. Arguments are formatted with python-like syntax,\n-//! meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n-//! actual grammar for the formatting syntax is:\n+//! The syntax for the formatting language used is drawn from other languages,\n+//! so it should not be too alien. Arguments are formatted with python-like\n+//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n+//! `%`. The actual grammar for the formatting syntax is:\n //!\n //! ```text\n //! format_string := <text> [ format <text> ] *\n@@ -333,8 +338,9 @@\n //!\n //! The fill character is provided normally in conjunction with the `width`\n //! parameter. This indicates that if the value being formatted is smaller than\n-//! `width` some extra characters will be printed around it. The extra characters\n-//! are specified by `fill`, and the alignment can be one of two options:\n+//! `width` some extra characters will be printed around it. The extra\n+//! characters are specified by `fill`, and the alignment can be one of two\n+//! options:\n //!\n //! * `<` - the argument is left-aligned in `width` columns\n //! * `^` - the argument is center-aligned in `width` columns\n@@ -344,33 +350,36 @@\n //!\n //! These can all be interpreted as flags for a particular formatter.\n //!\n-//! * '+' - This is intended for numeric types and indicates that the sign should\n-//!         always be printed. Positive signs are never printed by default, and the\n-//!         negative sign is only printed by default for the `Signed` trait. This\n-//!         flag indicates that the correct sign (+ or -) should always be printed.\n+//! * '+' - This is intended for numeric types and indicates that the sign\n+//!         should always be printed. Positive signs are never printed by\n+//!         default, and the negative sign is only printed by default for the\n+//!         `Signed` trait. This flag indicates that the correct sign (+ or -)\n+//!         should always be printed.\n //! * '-' - Currently not used\n-//! * '#' - This flag is indicates that the \"alternate\" form of printing should be\n-//!         used. By default, this only applies to the integer formatting traits and\n-//!         performs like:\n+//! * '#' - This flag is indicates that the \"alternate\" form of printing should\n+//!         be used. By default, this only applies to the integer formatting\n+//!         traits and performs like:\n //!     * `x` - precedes the argument with a \"0x\"\n //!     * `X` - precedes the argument with a \"0x\"\n //!     * `t` - precedes the argument with a \"0b\"\n //!     * `o` - precedes the argument with a \"0o\"\n //! * '0' - This is used to indicate for integer formats that the padding should\n //!         both be done with a `0` character as well as be sign-aware. A format\n-//!         like `{:08d}` would yield `00000001` for the integer `1`, while the same\n-//!         format would yield `-0000001` for the integer `-1`. Notice that the\n-//!         negative version has one fewer zero than the positive version.\n+//!         like `{:08d}` would yield `00000001` for the integer `1`, while the\n+//!         same format would yield `-0000001` for the integer `-1`. Notice that\n+//!         the negative version has one fewer zero than the positive version.\n //!\n //! ### Width\n //!\n-//! This is a parameter for the \"minimum width\" that the format should take up. If\n-//! the value's string does not fill up this many characters, then the padding\n-//! specified by fill/alignment will be used to take up the required space.\n+//! This is a parameter for the \"minimum width\" that the format should take up.\n+//! If the value's string does not fill up this many characters, then the\n+//! padding specified by fill/alignment will be used to take up the required\n+//! space.\n //!\n //! The default fill/alignment for non-numerics is a space and left-aligned. The\n-//! defaults for numeric formatters is also a space but with right-alignment. If the\n-//! '0' flag is specified for numerics, then the implicit fill character is '0'.\n+//! defaults for numeric formatters is also a space but with right-alignment. If\n+//! the '0' flag is specified for numerics, then the implicit fill character is\n+//! '0'.\n //!\n //! The value for the width can also be provided as a `uint` in the list of\n //! parameters by using the `2$` syntax indicating that the second argument is a\n@@ -379,19 +388,19 @@\n //! ### Precision\n //!\n //! For non-numeric types, this can be considered a \"maximum width\". If the\n-//! resulting string is longer than this width, then it is truncated down to this\n-//! many characters and only those are emitted.\n+//! resulting string is longer than this width, then it is truncated down to\n+//! this many characters and only those are emitted.\n //!\n //! For integral types, this has no meaning currently.\n //!\n-//! For floating-point types, this indicates how many digits after the decimal point\n-//! should be printed.\n+//! For floating-point types, this indicates how many digits after the decimal\n+//! point should be printed.\n //!\n //! ## Escaping\n //!\n-//! The literal characters `{` and `}` may be included in a string by preceding them\n-//! with the same character. For example, the `{` character is escaped with `{{` and\n-//! the `}` character is escaped with `}}`.\n+//! The literal characters `{` and `}` may be included in a string by preceding\n+//! them with the same character. For example, the `{` character is escaped with\n+//! `{{` and the `}` character is escaped with `}}`.\n \n #![experimental]\n "}, {"sha": "f41c93764647e891cfadc5338eecfe9eb7c513d7", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5816d7f5305ce4401326568785d624e689064311/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5816d7f5305ce4401326568785d624e689064311/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=5816d7f5305ce4401326568785d624e689064311", "patch": "@@ -124,7 +124,7 @@ pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n #[cfg(windows)]\n /// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n /// opened.\n-pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send> + Send> {\n+pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     let ti = TerminfoTerminal::new(WriterWrapper {\n         wrapped: box std::io::stderr() as Box<Writer + Send>,\n     });"}]}