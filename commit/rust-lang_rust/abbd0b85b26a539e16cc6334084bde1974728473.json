{"sha": "abbd0b85b26a539e16cc6334084bde1974728473", "node_id": "C_kwDOAAsO6NoAKGFiYmQwYjg1YjI2YTUzOWUxNmNjNjMzNDA4NGJkZTE5NzQ3Mjg0NzM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-08T20:52:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-12T17:54:09Z"}, "message": "Move diagnostic methods to the dedicated module.", "tree": {"sha": "bb543eed8dbcf1868a2be2ceedc81f720a4be5c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb543eed8dbcf1868a2be2ceedc81f720a4be5c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abbd0b85b26a539e16cc6334084bde1974728473", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abbd0b85b26a539e16cc6334084bde1974728473", "html_url": "https://github.com/rust-lang/rust/commit/abbd0b85b26a539e16cc6334084bde1974728473", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abbd0b85b26a539e16cc6334084bde1974728473/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "944d852afe6c27b6207984b907d902565cf550d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/944d852afe6c27b6207984b907d902565cf550d6", "html_url": "https://github.com/rust-lang/rust/commit/944d852afe6c27b6207984b907d902565cf550d6"}], "stats": {"total": 949, "additions": 472, "deletions": 477}, "files": [{"sha": "1a03a65c18dcfc83215de5ae81606c4493a8d8e2", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 468, "deletions": 12, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/abbd0b85b26a539e16cc6334084bde1974728473/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abbd0b85b26a539e16cc6334084bde1974728473/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=abbd0b85b26a539e16cc6334084bde1974728473", "patch": "@@ -1,18 +1,22 @@\n use std::ptr;\n \n-use rustc_ast::{self as ast, Path};\n+use rustc_ast::ptr::P;\n+use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::{self as ast, Crate, ItemKind, ModKind, NodeId, Path, CRATE_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{\n-    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n-};\n+use rustc_errors::struct_span_err;\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n use rustc_middle::ty::DefIdTree;\n+use rustc_session::lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE;\n+use rustc_session::lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS;\n+use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n@@ -25,10 +29,11 @@ use tracing::debug;\n use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::late::Rib;\n use crate::path_names_to_string;\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Finalize};\n-use crate::{BindingError, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot};\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BindingError, Finalize};\n+use crate::{HasGenericParams, MacroRulesScope, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{LexicalScopeBinding, NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n-use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n+use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet};\n+use crate::{Segment, UseError};\n \n type Res = def::Res<ast::NodeId>;\n \n@@ -84,6 +89,390 @@ fn reduce_impl_span_to_impl_keyword(sm: &SourceMap, impl_span: Span) -> Span {\n }\n \n impl<'a> Resolver<'a> {\n+    crate fn report_errors(&mut self, krate: &Crate) {\n+        self.report_with_use_injections(krate);\n+\n+        for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n+            let msg = \"macro-expanded `macro_export` macros from the current crate \\\n+                       cannot be referred to by absolute paths\";\n+            self.lint_buffer.buffer_lint_with_diagnostic(\n+                MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n+                CRATE_NODE_ID,\n+                span_use,\n+                msg,\n+                BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(span_def),\n+            );\n+        }\n+\n+        for ambiguity_error in &self.ambiguity_errors {\n+            self.report_ambiguity_error(ambiguity_error);\n+        }\n+\n+        let mut reported_spans = FxHashSet::default();\n+        for error in &self.privacy_errors {\n+            if reported_spans.insert(error.dedup_span) {\n+                self.report_privacy_error(error);\n+            }\n+        }\n+    }\n+\n+    fn report_with_use_injections(&mut self, krate: &Crate) {\n+        for UseError { mut err, candidates, def_id, instead, suggestion } in\n+            self.use_injections.drain(..)\n+        {\n+            let (span, found_use) = if let Some(def_id) = def_id.as_local() {\n+                UsePlacementFinder::check(krate, self.def_id_to_node_id[def_id])\n+            } else {\n+                (None, false)\n+            };\n+            if !candidates.is_empty() {\n+                show_candidates(\n+                    &self.definitions,\n+                    self.session,\n+                    &mut err,\n+                    span,\n+                    &candidates,\n+                    instead,\n+                    found_use,\n+                );\n+            } else if let Some((span, msg, sugg, appl)) = suggestion {\n+                err.span_suggestion(span, msg, sugg, appl);\n+            }\n+            err.emit();\n+        }\n+    }\n+\n+    crate fn report_conflict<'b>(\n+        &mut self,\n+        parent: Module<'_>,\n+        ident: Ident,\n+        ns: Namespace,\n+        new_binding: &NameBinding<'b>,\n+        old_binding: &NameBinding<'b>,\n+    ) {\n+        // Error on the second of two conflicting names\n+        if old_binding.span.lo() > new_binding.span.lo() {\n+            return self.report_conflict(parent, ident, ns, old_binding, new_binding);\n+        }\n+\n+        let container = match parent.kind {\n+            ModuleKind::Def(kind, _, _) => kind.descr(parent.def_id()),\n+            ModuleKind::Block(..) => \"block\",\n+        };\n+\n+        let old_noun = match old_binding.is_import() {\n+            true => \"import\",\n+            false => \"definition\",\n+        };\n+\n+        let new_participle = match new_binding.is_import() {\n+            true => \"imported\",\n+            false => \"defined\",\n+        };\n+\n+        let (name, span) =\n+            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n+\n+        if let Some(s) = self.name_already_seen.get(&name) {\n+            if s == &span {\n+                return;\n+            }\n+        }\n+\n+        let old_kind = match (ns, old_binding.module()) {\n+            (ValueNS, _) => \"value\",\n+            (MacroNS, _) => \"macro\",\n+            (TypeNS, _) if old_binding.is_extern_crate() => \"extern crate\",\n+            (TypeNS, Some(module)) if module.is_normal() => \"module\",\n+            (TypeNS, Some(module)) if module.is_trait() => \"trait\",\n+            (TypeNS, _) => \"type\",\n+        };\n+\n+        let msg = format!(\"the name `{}` is defined multiple times\", name);\n+\n+        let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n+            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n+            (true, _) | (_, true) => match new_binding.is_import() && old_binding.is_import() {\n+                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n+                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n+            },\n+            _ => match (old_binding.is_import(), new_binding.is_import()) {\n+                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n+                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n+                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n+            },\n+        };\n+\n+        err.note(&format!(\n+            \"`{}` must be defined only once in the {} namespace of this {}\",\n+            name,\n+            ns.descr(),\n+            container\n+        ));\n+\n+        err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n+        err.span_label(\n+            self.session.source_map().guess_head_span(old_binding.span),\n+            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n+        );\n+\n+        // See https://github.com/rust-lang/rust/issues/32354\n+        use NameBindingKind::Import;\n+        let import = match (&new_binding.kind, &old_binding.kind) {\n+            // If there are two imports where one or both have attributes then prefer removing the\n+            // import without attributes.\n+            (Import { import: new, .. }, Import { import: old, .. })\n+                if {\n+                    !new_binding.span.is_dummy()\n+                        && !old_binding.span.is_dummy()\n+                        && (new.has_attributes || old.has_attributes)\n+                } =>\n+            {\n+                if old.has_attributes {\n+                    Some((new, new_binding.span, true))\n+                } else {\n+                    Some((old, old_binding.span, true))\n+                }\n+            }\n+            // Otherwise prioritize the new binding.\n+            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n+                Some((import, new_binding.span, other.is_import()))\n+            }\n+            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n+                Some((import, old_binding.span, other.is_import()))\n+            }\n+            _ => None,\n+        };\n+\n+        // Check if the target of the use for both bindings is the same.\n+        let duplicate = new_binding.res().opt_def_id() == old_binding.res().opt_def_id();\n+        let has_dummy_span = new_binding.span.is_dummy() || old_binding.span.is_dummy();\n+        let from_item =\n+            self.extern_prelude.get(&ident).map_or(true, |entry| entry.introduced_by_item);\n+        // Only suggest removing an import if both bindings are to the same def, if both spans\n+        // aren't dummy spans. Further, if both bindings are imports, then the ident must have\n+        // been introduced by an item.\n+        let should_remove_import = duplicate\n+            && !has_dummy_span\n+            && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n+\n+        match import {\n+            Some((import, span, true)) if should_remove_import && import.is_nested() => {\n+                self.add_suggestion_for_duplicate_nested_use(&mut err, import, span)\n+            }\n+            Some((import, _, true)) if should_remove_import && !import.is_glob() => {\n+                // Simple case - remove the entire import. Due to the above match arm, this can\n+                // only be a single use so just remove it entirely.\n+                err.tool_only_span_suggestion(\n+                    import.use_span_with_attributes,\n+                    \"remove unnecessary import\",\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            Some((import, span, _)) => {\n+                self.add_suggestion_for_rename_of_use(&mut err, name, import, span)\n+            }\n+            _ => {}\n+        }\n+\n+        err.emit();\n+        self.name_already_seen.insert(name, span);\n+    }\n+\n+    /// This function adds a suggestion to change the binding name of a new import that conflicts\n+    /// with an existing import.\n+    ///\n+    /// ```text,ignore (diagnostic)\n+    /// help: you can use `as` to change the binding name of the import\n+    ///    |\n+    /// LL | use foo::bar as other_bar;\n+    ///    |     ^^^^^^^^^^^^^^^^^^^^^\n+    /// ```\n+    fn add_suggestion_for_rename_of_use(\n+        &self,\n+        err: &mut Diagnostic,\n+        name: Symbol,\n+        import: &Import<'_>,\n+        binding_span: Span,\n+    ) {\n+        let suggested_name = if name.as_str().chars().next().unwrap().is_uppercase() {\n+            format!(\"Other{}\", name)\n+        } else {\n+            format!(\"other_{}\", name)\n+        };\n+\n+        let mut suggestion = None;\n+        match import.kind {\n+            ImportKind::Single { type_ns_only: true, .. } => {\n+                suggestion = Some(format!(\"self as {}\", suggested_name))\n+            }\n+            ImportKind::Single { source, .. } => {\n+                if let Some(pos) =\n+                    source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n+                {\n+                    if let Ok(snippet) = self.session.source_map().span_to_snippet(binding_span) {\n+                        if pos <= snippet.len() {\n+                            suggestion = Some(format!(\n+                                \"{} as {}{}\",\n+                                &snippet[..pos],\n+                                suggested_name,\n+                                if snippet.ends_with(';') { \";\" } else { \"\" }\n+                            ))\n+                        }\n+                    }\n+                }\n+            }\n+            ImportKind::ExternCrate { source, target } => {\n+                suggestion = Some(format!(\n+                    \"extern crate {} as {};\",\n+                    source.unwrap_or(target.name),\n+                    suggested_name,\n+                ))\n+            }\n+            _ => unreachable!(),\n+        }\n+\n+        let rename_msg = \"you can use `as` to change the binding name of the import\";\n+        if let Some(suggestion) = suggestion {\n+            err.span_suggestion(\n+                binding_span,\n+                rename_msg,\n+                suggestion,\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            err.span_label(binding_span, rename_msg);\n+        }\n+    }\n+\n+    /// This function adds a suggestion to remove an unnecessary binding from an import that is\n+    /// nested. In the following example, this function will be invoked to remove the `a` binding\n+    /// in the second use statement:\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// use issue_52891::a;\n+    /// use issue_52891::{d, a, e};\n+    /// ```\n+    ///\n+    /// The following suggestion will be added:\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// use issue_52891::{d, a, e};\n+    ///                      ^-- help: remove unnecessary import\n+    /// ```\n+    ///\n+    /// If the nested use contains only one import then the suggestion will remove the entire\n+    /// line.\n+    ///\n+    /// It is expected that the provided import is nested - this isn't checked by the\n+    /// function. If this invariant is not upheld, this function's behaviour will be unexpected\n+    /// as characters expected by span manipulations won't be present.\n+    fn add_suggestion_for_duplicate_nested_use(\n+        &self,\n+        err: &mut Diagnostic,\n+        import: &Import<'_>,\n+        binding_span: Span,\n+    ) {\n+        assert!(import.is_nested());\n+        let message = \"remove unnecessary import\";\n+\n+        // Two examples will be used to illustrate the span manipulations we're doing:\n+        //\n+        // - Given `use issue_52891::{d, a, e};` where `a` is a duplicate then `binding_span` is\n+        //   `a` and `import.use_span` is `issue_52891::{d, a, e};`.\n+        // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n+        //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n+\n+        let (found_closing_brace, span) =\n+            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n+\n+        // If there was a closing brace then identify the span to remove any trailing commas from\n+        // previous imports.\n+        if found_closing_brace {\n+            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n+                err.tool_only_span_suggestion(\n+                    span,\n+                    message,\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                // Remove the entire line if we cannot extend the span back, this indicates an\n+                // `issue_52891::{self}` case.\n+                err.span_suggestion(\n+                    import.use_span_with_attributes,\n+                    message,\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n+            return;\n+        }\n+\n+        err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);\n+    }\n+\n+    crate fn lint_if_path_starts_with_module(\n+        &mut self,\n+        finalize: Finalize,\n+        path: &[Segment],\n+        second_binding: Option<&NameBinding<'_>>,\n+    ) {\n+        let (diag_id, diag_span) = match finalize {\n+            Finalize::No => return,\n+            Finalize::SimplePath(id, path_span) => (id, path_span),\n+            Finalize::UsePath { root_id, root_span, .. } => (root_id, root_span),\n+            Finalize::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n+        };\n+\n+        let first_name = match path.get(0) {\n+            // In the 2018 edition this lint is a hard error, so nothing to do\n+            Some(seg) if seg.ident.span.rust_2015() && self.session.rust_2015() => seg.ident.name,\n+            _ => return,\n+        };\n+\n+        // We're only interested in `use` paths which should start with\n+        // `{{root}}` currently.\n+        if first_name != kw::PathRoot {\n+            return;\n+        }\n+\n+        match path.get(1) {\n+            // If this import looks like `crate::...` it's already good\n+            Some(Segment { ident, .. }) if ident.name == kw::Crate => return,\n+            // Otherwise go below to see if it's an extern crate\n+            Some(_) => {}\n+            // If the path has length one (and it's `PathRoot` most likely)\n+            // then we don't know whether we're gonna be importing a crate or an\n+            // item in our crate. Defer this lint to elsewhere\n+            None => return,\n+        }\n+\n+        // If the first element of our path was actually resolved to an\n+        // `ExternCrate` (also used for `crate::...`) then no need to issue a\n+        // warning, this looks all good!\n+        if let Some(binding) = second_binding {\n+            if let NameBindingKind::Import { import, .. } = binding.kind {\n+                // Careful: we still want to rewrite paths from renamed extern crates.\n+                if let ImportKind::ExternCrate { source: None, .. } = import.kind {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        let diag = BuiltinLintDiagnostics::AbsPathWithModule(diag_span);\n+        self.lint_buffer.buffer_lint_with_diagnostic(\n+            ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n+            diag_id,\n+            diag_span,\n+            \"absolute paths must start with `self`, `super`, \\\n+             `crate`, or an external crate name in the 2018 edition\",\n+            diag,\n+        );\n+    }\n+\n     crate fn add_module_candidates(\n         &mut self,\n         module: Module<'a>,\n@@ -1227,7 +1616,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n+    fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n         let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n         let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n             // We have to print the span-less alternative first, otherwise formatting looks bad.\n@@ -1293,7 +1682,7 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    crate fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n+    fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n         let PrivacyError { ident, binding, .. } = *privacy_error;\n \n         let res = binding.res();\n@@ -1859,7 +2248,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n /// use foo::{a, b, c};\n ///              ^^^\n /// ```\n-pub(crate) fn find_span_of_binding_until_next_binding(\n+fn find_span_of_binding_until_next_binding(\n     sess: &Session,\n     binding_span: Span,\n     use_span: Span,\n@@ -1910,7 +2299,7 @@ pub(crate) fn find_span_of_binding_until_next_binding(\n /// use foo::{a, b, c};\n ///           --- binding span\n /// ```\n-pub(crate) fn extend_span_to_previous_binding(sess: &Session, binding_span: Span) -> Option<Span> {\n+fn extend_span_to_previous_binding(sess: &Session, binding_span: Span) -> Option<Span> {\n     let source_map = sess.source_map();\n \n     // `prev_source` will contain all of the source that came before the span.\n@@ -1998,7 +2387,7 @@ fn find_span_immediately_after_crate_name(\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n-crate fn show_candidates(\n+fn show_candidates(\n     definitions: &rustc_hir::definitions::Definitions,\n     session: &Session,\n     err: &mut Diagnostic,\n@@ -2133,3 +2522,70 @@ crate fn show_candidates(\n         }\n     }\n }\n+\n+#[derive(Debug)]\n+struct UsePlacementFinder {\n+    target_module: NodeId,\n+    first_legal_span: Option<Span>,\n+    first_use_span: Option<Span>,\n+}\n+\n+impl UsePlacementFinder {\n+    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n+        let mut finder =\n+            UsePlacementFinder { target_module, first_legal_span: None, first_use_span: None };\n+        finder.visit_crate(krate);\n+        if let Some(use_span) = finder.first_use_span {\n+            (Some(use_span), true)\n+        } else {\n+            (finder.first_legal_span, false)\n+        }\n+    }\n+}\n+\n+impl<'tcx> visit::Visitor<'tcx> for UsePlacementFinder {\n+    fn visit_crate(&mut self, c: &Crate) {\n+        if self.target_module == CRATE_NODE_ID {\n+            let inject = c.spans.inject_use_span;\n+            if is_span_suitable_for_use_injection(inject) {\n+                self.first_legal_span = Some(inject);\n+            }\n+            self.first_use_span = search_for_any_use_in_items(&c.items);\n+            return;\n+        } else {\n+            visit::walk_crate(self, c);\n+        }\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx ast::Item) {\n+        if self.target_module == item.id {\n+            if let ItemKind::Mod(_, ModKind::Loaded(items, _inline, mod_spans)) = &item.kind {\n+                let inject = mod_spans.inject_use_span;\n+                if is_span_suitable_for_use_injection(inject) {\n+                    self.first_legal_span = Some(inject);\n+                }\n+                self.first_use_span = search_for_any_use_in_items(items);\n+                return;\n+            }\n+        } else {\n+            visit::walk_item(self, item);\n+        }\n+    }\n+}\n+\n+fn search_for_any_use_in_items(items: &[P<ast::Item>]) -> Option<Span> {\n+    for item in items {\n+        if let ItemKind::Use(..) = item.kind {\n+            if is_span_suitable_for_use_injection(item.span) {\n+                return Some(item.span.shrink_to_lo());\n+            }\n+        }\n+    }\n+    return None;\n+}\n+\n+fn is_span_suitable_for_use_injection(s: Span) -> bool {\n+    // don't suggest placing a use before the prelude\n+    // import or other generated ones\n+    !s.from_expansion()\n+}"}, {"sha": "b2c7a4d18de386c42a18ce55e126ee724c5bbd5e", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 465, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/abbd0b85b26a539e16cc6334084bde1974728473/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abbd0b85b26a539e16cc6334084bde1974728473/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=abbd0b85b26a539e16cc6334084bde1974728473", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! This crate is responsible for the part of name resolution that doesn't require type checker.\n //!\n //! Module structure of the crate is built here.\n@@ -28,19 +26,13 @@ pub use rustc_hir::def::{Namespace, PerNS};\n \n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n-use rustc_ast::ptr::P;\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{self as ast, NodeId};\n-use rustc_ast::{Crate, CRATE_NODE_ID};\n-use rustc_ast::{Expr, ExprKind, LitKind};\n-use rustc_ast::{ItemKind, ModKind, Path};\n+use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n+use rustc_ast::{Crate, Expr, ExprKind, LitKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{\n-    struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n-};\n+use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{self, CtorOf, DefKind, PartialRes};\n@@ -57,8 +49,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n-use rustc_session::lint;\n-use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n+use rustc_session::lint::LintBuffer;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n use rustc_span::source_map::Spanned;\n@@ -71,7 +62,6 @@ use std::collections::BTreeSet;\n use std::{cmp, fmt, mem, ptr};\n use tracing::debug;\n \n-use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_next_binding};\n use diagnostics::{ImportSuggestion, LabelSuggestion, Suggestion};\n use imports::{Import, ImportKind, ImportResolver, NameResolution};\n use late::{HasGenericParams, PathSource};\n@@ -312,73 +302,6 @@ impl<'a> From<&'a ast::PathSegment> for Segment {\n     }\n }\n \n-#[derive(Debug)]\n-struct UsePlacementFinder {\n-    target_module: NodeId,\n-    first_legal_span: Option<Span>,\n-    first_use_span: Option<Span>,\n-}\n-\n-impl UsePlacementFinder {\n-    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n-        let mut finder =\n-            UsePlacementFinder { target_module, first_legal_span: None, first_use_span: None };\n-        finder.visit_crate(krate);\n-        if let Some(use_span) = finder.first_use_span {\n-            (Some(use_span), true)\n-        } else {\n-            (finder.first_legal_span, false)\n-        }\n-    }\n-}\n-\n-fn is_span_suitable_for_use_injection(s: Span) -> bool {\n-    // don't suggest placing a use before the prelude\n-    // import or other generated ones\n-    !s.from_expansion()\n-}\n-\n-fn search_for_any_use_in_items(items: &[P<ast::Item>]) -> Option<Span> {\n-    for item in items {\n-        if let ItemKind::Use(..) = item.kind {\n-            if is_span_suitable_for_use_injection(item.span) {\n-                return Some(item.span.shrink_to_lo());\n-            }\n-        }\n-    }\n-    return None;\n-}\n-\n-impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n-    fn visit_crate(&mut self, c: &Crate) {\n-        if self.target_module == CRATE_NODE_ID {\n-            let inject = c.spans.inject_use_span;\n-            if is_span_suitable_for_use_injection(inject) {\n-                self.first_legal_span = Some(inject);\n-            }\n-            self.first_use_span = search_for_any_use_in_items(&c.items);\n-            return;\n-        } else {\n-            visit::walk_crate(self, c);\n-        }\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx ast::Item) {\n-        if self.target_module == item.id {\n-            if let ItemKind::Mod(_, ModKind::Loaded(items, _inline, mod_spans)) = &item.kind {\n-                let inject = mod_spans.inject_use_span;\n-                if is_span_suitable_for_use_injection(inject) {\n-                    self.first_legal_span = Some(inject);\n-                }\n-                self.first_use_span = search_for_any_use_in_items(items);\n-                return;\n-            }\n-        } else {\n-            visit::walk_item(self, item);\n-        }\n-    }\n-}\n-\n /// An intermediate resolution result.\n ///\n /// This refers to the thing referred by a name. The difference between `Res` and `Item` is that\n@@ -1800,65 +1723,6 @@ impl<'a> Resolver<'a> {\n         module\n     }\n \n-    fn lint_if_path_starts_with_module(\n-        &mut self,\n-        finalize: Finalize,\n-        path: &[Segment],\n-        second_binding: Option<&NameBinding<'_>>,\n-    ) {\n-        let (diag_id, diag_span) = match finalize {\n-            Finalize::No => return,\n-            Finalize::SimplePath(id, path_span) => (id, path_span),\n-            Finalize::UsePath { root_id, root_span, .. } => (root_id, root_span),\n-            Finalize::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n-        };\n-\n-        let first_name = match path.get(0) {\n-            // In the 2018 edition this lint is a hard error, so nothing to do\n-            Some(seg) if seg.ident.span.rust_2015() && self.session.rust_2015() => seg.ident.name,\n-            _ => return,\n-        };\n-\n-        // We're only interested in `use` paths which should start with\n-        // `{{root}}` currently.\n-        if first_name != kw::PathRoot {\n-            return;\n-        }\n-\n-        match path.get(1) {\n-            // If this import looks like `crate::...` it's already good\n-            Some(Segment { ident, .. }) if ident.name == kw::Crate => return,\n-            // Otherwise go below to see if it's an extern crate\n-            Some(_) => {}\n-            // If the path has length one (and it's `PathRoot` most likely)\n-            // then we don't know whether we're gonna be importing a crate or an\n-            // item in our crate. Defer this lint to elsewhere\n-            None => return,\n-        }\n-\n-        // If the first element of our path was actually resolved to an\n-        // `ExternCrate` (also used for `crate::...`) then no need to issue a\n-        // warning, this looks all good!\n-        if let Some(binding) = second_binding {\n-            if let NameBindingKind::Import { import, .. } = binding.kind {\n-                // Careful: we still want to rewrite paths from renamed extern crates.\n-                if let ImportKind::ExternCrate { source: None, .. } = import.kind {\n-                    return;\n-                }\n-            }\n-        }\n-\n-        let diag = BuiltinLintDiagnostics::AbsPathWithModule(diag_span);\n-        self.lint_buffer.buffer_lint_with_diagnostic(\n-            lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n-            diag_id,\n-            diag_span,\n-            \"absolute paths must start with `self`, `super`, \\\n-             `crate`, or an external crate name in the 2018 edition\",\n-            diag,\n-        );\n-    }\n-\n     fn record_partial_res(&mut self, node_id: NodeId, resolution: PartialRes) {\n         debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n         if let Some(prev_res) = self.partial_res_map.insert(node_id, resolution) {\n@@ -1905,331 +1769,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn report_errors(&mut self, krate: &Crate) {\n-        self.report_with_use_injections(krate);\n-\n-        for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n-            let msg = \"macro-expanded `macro_export` macros from the current crate \\\n-                       cannot be referred to by absolute paths\";\n-            self.lint_buffer.buffer_lint_with_diagnostic(\n-                lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n-                CRATE_NODE_ID,\n-                span_use,\n-                msg,\n-                BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(span_def),\n-            );\n-        }\n-\n-        for ambiguity_error in &self.ambiguity_errors {\n-            self.report_ambiguity_error(ambiguity_error);\n-        }\n-\n-        let mut reported_spans = FxHashSet::default();\n-        for error in &self.privacy_errors {\n-            if reported_spans.insert(error.dedup_span) {\n-                self.report_privacy_error(error);\n-            }\n-        }\n-    }\n-\n-    fn report_with_use_injections(&mut self, krate: &Crate) {\n-        for UseError { mut err, candidates, def_id, instead, suggestion } in\n-            self.use_injections.drain(..)\n-        {\n-            let (span, found_use) = if let Some(def_id) = def_id.as_local() {\n-                UsePlacementFinder::check(krate, self.def_id_to_node_id[def_id])\n-            } else {\n-                (None, false)\n-            };\n-            if !candidates.is_empty() {\n-                diagnostics::show_candidates(\n-                    &self.definitions,\n-                    self.session,\n-                    &mut err,\n-                    span,\n-                    &candidates,\n-                    instead,\n-                    found_use,\n-                );\n-            } else if let Some((span, msg, sugg, appl)) = suggestion {\n-                err.span_suggestion(span, msg, sugg, appl);\n-            }\n-            err.emit();\n-        }\n-    }\n-\n-    fn report_conflict<'b>(\n-        &mut self,\n-        parent: Module<'_>,\n-        ident: Ident,\n-        ns: Namespace,\n-        new_binding: &NameBinding<'b>,\n-        old_binding: &NameBinding<'b>,\n-    ) {\n-        // Error on the second of two conflicting names\n-        if old_binding.span.lo() > new_binding.span.lo() {\n-            return self.report_conflict(parent, ident, ns, old_binding, new_binding);\n-        }\n-\n-        let container = match parent.kind {\n-            ModuleKind::Def(kind, _, _) => kind.descr(parent.def_id()),\n-            ModuleKind::Block(..) => \"block\",\n-        };\n-\n-        let old_noun = match old_binding.is_import() {\n-            true => \"import\",\n-            false => \"definition\",\n-        };\n-\n-        let new_participle = match new_binding.is_import() {\n-            true => \"imported\",\n-            false => \"defined\",\n-        };\n-\n-        let (name, span) =\n-            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n-\n-        if let Some(s) = self.name_already_seen.get(&name) {\n-            if s == &span {\n-                return;\n-            }\n-        }\n-\n-        let old_kind = match (ns, old_binding.module()) {\n-            (ValueNS, _) => \"value\",\n-            (MacroNS, _) => \"macro\",\n-            (TypeNS, _) if old_binding.is_extern_crate() => \"extern crate\",\n-            (TypeNS, Some(module)) if module.is_normal() => \"module\",\n-            (TypeNS, Some(module)) if module.is_trait() => \"trait\",\n-            (TypeNS, _) => \"type\",\n-        };\n-\n-        let msg = format!(\"the name `{}` is defined multiple times\", name);\n-\n-        let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n-            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n-            (true, _) | (_, true) => match new_binding.is_import() && old_binding.is_import() {\n-                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n-                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n-            },\n-            _ => match (old_binding.is_import(), new_binding.is_import()) {\n-                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n-                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n-                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n-            },\n-        };\n-\n-        err.note(&format!(\n-            \"`{}` must be defined only once in the {} namespace of this {}\",\n-            name,\n-            ns.descr(),\n-            container\n-        ));\n-\n-        err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n-        err.span_label(\n-            self.session.source_map().guess_head_span(old_binding.span),\n-            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n-        );\n-\n-        // See https://github.com/rust-lang/rust/issues/32354\n-        use NameBindingKind::Import;\n-        let import = match (&new_binding.kind, &old_binding.kind) {\n-            // If there are two imports where one or both have attributes then prefer removing the\n-            // import without attributes.\n-            (Import { import: new, .. }, Import { import: old, .. })\n-                if {\n-                    !new_binding.span.is_dummy()\n-                        && !old_binding.span.is_dummy()\n-                        && (new.has_attributes || old.has_attributes)\n-                } =>\n-            {\n-                if old.has_attributes {\n-                    Some((new, new_binding.span, true))\n-                } else {\n-                    Some((old, old_binding.span, true))\n-                }\n-            }\n-            // Otherwise prioritize the new binding.\n-            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n-                Some((import, new_binding.span, other.is_import()))\n-            }\n-            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n-                Some((import, old_binding.span, other.is_import()))\n-            }\n-            _ => None,\n-        };\n-\n-        // Check if the target of the use for both bindings is the same.\n-        let duplicate = new_binding.res().opt_def_id() == old_binding.res().opt_def_id();\n-        let has_dummy_span = new_binding.span.is_dummy() || old_binding.span.is_dummy();\n-        let from_item =\n-            self.extern_prelude.get(&ident).map_or(true, |entry| entry.introduced_by_item);\n-        // Only suggest removing an import if both bindings are to the same def, if both spans\n-        // aren't dummy spans. Further, if both bindings are imports, then the ident must have\n-        // been introduced by an item.\n-        let should_remove_import = duplicate\n-            && !has_dummy_span\n-            && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n-\n-        match import {\n-            Some((import, span, true)) if should_remove_import && import.is_nested() => {\n-                self.add_suggestion_for_duplicate_nested_use(&mut err, import, span)\n-            }\n-            Some((import, _, true)) if should_remove_import && !import.is_glob() => {\n-                // Simple case - remove the entire import. Due to the above match arm, this can\n-                // only be a single use so just remove it entirely.\n-                err.tool_only_span_suggestion(\n-                    import.use_span_with_attributes,\n-                    \"remove unnecessary import\",\n-                    String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            Some((import, span, _)) => {\n-                self.add_suggestion_for_rename_of_use(&mut err, name, import, span)\n-            }\n-            _ => {}\n-        }\n-\n-        err.emit();\n-        self.name_already_seen.insert(name, span);\n-    }\n-\n-    /// This function adds a suggestion to change the binding name of a new import that conflicts\n-    /// with an existing import.\n-    ///\n-    /// ```text,ignore (diagnostic)\n-    /// help: you can use `as` to change the binding name of the import\n-    ///    |\n-    /// LL | use foo::bar as other_bar;\n-    ///    |     ^^^^^^^^^^^^^^^^^^^^^\n-    /// ```\n-    fn add_suggestion_for_rename_of_use(\n-        &self,\n-        err: &mut Diagnostic,\n-        name: Symbol,\n-        import: &Import<'_>,\n-        binding_span: Span,\n-    ) {\n-        let suggested_name = if name.as_str().chars().next().unwrap().is_uppercase() {\n-            format!(\"Other{}\", name)\n-        } else {\n-            format!(\"other_{}\", name)\n-        };\n-\n-        let mut suggestion = None;\n-        match import.kind {\n-            ImportKind::Single { type_ns_only: true, .. } => {\n-                suggestion = Some(format!(\"self as {}\", suggested_name))\n-            }\n-            ImportKind::Single { source, .. } => {\n-                if let Some(pos) =\n-                    source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n-                {\n-                    if let Ok(snippet) = self.session.source_map().span_to_snippet(binding_span) {\n-                        if pos <= snippet.len() {\n-                            suggestion = Some(format!(\n-                                \"{} as {}{}\",\n-                                &snippet[..pos],\n-                                suggested_name,\n-                                if snippet.ends_with(';') { \";\" } else { \"\" }\n-                            ))\n-                        }\n-                    }\n-                }\n-            }\n-            ImportKind::ExternCrate { source, target } => {\n-                suggestion = Some(format!(\n-                    \"extern crate {} as {};\",\n-                    source.unwrap_or(target.name),\n-                    suggested_name,\n-                ))\n-            }\n-            _ => unreachable!(),\n-        }\n-\n-        let rename_msg = \"you can use `as` to change the binding name of the import\";\n-        if let Some(suggestion) = suggestion {\n-            err.span_suggestion(\n-                binding_span,\n-                rename_msg,\n-                suggestion,\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            err.span_label(binding_span, rename_msg);\n-        }\n-    }\n-\n-    /// This function adds a suggestion to remove an unnecessary binding from an import that is\n-    /// nested. In the following example, this function will be invoked to remove the `a` binding\n-    /// in the second use statement:\n-    ///\n-    /// ```ignore (diagnostic)\n-    /// use issue_52891::a;\n-    /// use issue_52891::{d, a, e};\n-    /// ```\n-    ///\n-    /// The following suggestion will be added:\n-    ///\n-    /// ```ignore (diagnostic)\n-    /// use issue_52891::{d, a, e};\n-    ///                      ^-- help: remove unnecessary import\n-    /// ```\n-    ///\n-    /// If the nested use contains only one import then the suggestion will remove the entire\n-    /// line.\n-    ///\n-    /// It is expected that the provided import is nested - this isn't checked by the\n-    /// function. If this invariant is not upheld, this function's behaviour will be unexpected\n-    /// as characters expected by span manipulations won't be present.\n-    fn add_suggestion_for_duplicate_nested_use(\n-        &self,\n-        err: &mut Diagnostic,\n-        import: &Import<'_>,\n-        binding_span: Span,\n-    ) {\n-        assert!(import.is_nested());\n-        let message = \"remove unnecessary import\";\n-\n-        // Two examples will be used to illustrate the span manipulations we're doing:\n-        //\n-        // - Given `use issue_52891::{d, a, e};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `import.use_span` is `issue_52891::{d, a, e};`.\n-        // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n-\n-        let (found_closing_brace, span) =\n-            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n-\n-        // If there was a closing brace then identify the span to remove any trailing commas from\n-        // previous imports.\n-        if found_closing_brace {\n-            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n-                err.tool_only_span_suggestion(\n-                    span,\n-                    message,\n-                    String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                // Remove the entire line if we cannot extend the span back, this indicates an\n-                // `issue_52891::{self}` case.\n-                err.span_suggestion(\n-                    import.use_span_with_attributes,\n-                    message,\n-                    String::new(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-\n-            return;\n-        }\n-\n-        err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);\n-    }\n-\n     fn extern_prelude_get(&mut self, ident: Ident, finalize: bool) -> Option<&'a NameBinding<'a>> {\n         if ident.is_path_segment_keyword() {\n             // Make sure `self`, `super` etc produce an error when passed to here."}]}