{"sha": "6db1e5e771cb810b22f4ff26f1346e386ca7643f", "node_id": "C_kwDOAAsO6NoAKDZkYjFlNWU3NzFjYjgxMGIyMmY0ZmYyNmYxMzQ2ZTM4NmNhNzY0M2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-01T14:29:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-01T14:29:15Z"}, "message": "Auto merge of #111010 - scottmcm:mem-replace-simpler, r=WaffleLapkin\n\nMake `mem::replace` simpler in codegen\n\nSince they'd mentioned more intrinsics for simplifying stuff recently,\nr? `@WaffleLapkin`\n\nThis is a continuation of me looking at foundational stuff that ends up with more instructions than it really needs.  Specifically I noticed this one because `Range::next` isn't MIR-inlining, and one of the largest parts of it is a `replace::<usize>` that's a good dozen instructions instead of the two it could be.\n\nSo this means that `ptr::write` with a `Copy` type no longer generates worse IR than manually dereferencing (well, at least in LLVM -- MIR still has bonus pointer casts), and in doing so means that we're finally down to just the two essential `memcpy`s when emitting `mem::replace` for a large type, rather than the bonus-`alloca` and three `memcpy`s we emitted before this ([or the 6 we currently emit in 1.69 stable](https://rust.godbolt.org/z/67W8on6nP)).  That said, LLVM does _usually_ manage to optimize the extra code away.  But it's still nice for it not to have to do as much, thanks to (for example) not going through an `alloca` when `replace`ing a primitive like a `usize`.\n\n(This is a new intrinsic, but one that's immediately lowered to existing MIR constructs, so not anything that MIRI or the codegen backends or MIR semantics needs to do work to handle.)", "tree": {"sha": "34964f62804fb462b0c1cca97fa7ff357222a2ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34964f62804fb462b0c1cca97fa7ff357222a2ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6db1e5e771cb810b22f4ff26f1346e386ca7643f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6db1e5e771cb810b22f4ff26f1346e386ca7643f", "html_url": "https://github.com/rust-lang/rust/commit/6db1e5e771cb810b22f4ff26f1346e386ca7643f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6db1e5e771cb810b22f4ff26f1346e386ca7643f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7d8c88b64843d05761576aa093a34a8bc176817", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7d8c88b64843d05761576aa093a34a8bc176817", "html_url": "https://github.com/rust-lang/rust/commit/b7d8c88b64843d05761576aa093a34a8bc176817"}, {"sha": "3456f77241f618446e381cbeec7af74d1ebebba8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3456f77241f618446e381cbeec7af74d1ebebba8", "html_url": "https://github.com/rust-lang/rust/commit/3456f77241f618446e381cbeec7af74d1ebebba8"}], "stats": {"total": 292, "additions": 233, "deletions": 59}, "files": [{"sha": "6a10b50aa16eaa8a46f7128d9970d13001381cda", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -381,6 +381,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::unlikely => (0, vec![tcx.types.bool], tcx.types.bool),\n \n             sym::read_via_copy => (1, vec![tcx.mk_imm_ptr(param(0))], param(0)),\n+            sym::write_via_move => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n             sym::discriminant_value => {\n                 let assoc_items = tcx.associated_item_def_ids("}, {"sha": "69ba4840146ea795e56b53c2a38f09b5f15e52c3", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -179,6 +179,29 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             }\n                         }\n                     }\n+                    sym::write_via_move => {\n+                        let target = target.unwrap();\n+                        let Ok([ptr, val]) = <[_; 2]>::try_from(std::mem::take(args)) else {\n+                            span_bug!(\n+                                terminator.source_info.span,\n+                                \"Wrong number of arguments for write_via_move intrinsic\",\n+                            );\n+                        };\n+                        let derefed_place =\n+                            if let Some(place) = ptr.place() && let Some(local) = place.as_local() {\n+                                tcx.mk_place_deref(local.into())\n+                            } else {\n+                                span_bug!(terminator.source_info.span, \"Only passing a local is supported\");\n+                            };\n+                        block.statements.push(Statement {\n+                            source_info: terminator.source_info,\n+                            kind: StatementKind::Assign(Box::new((\n+                                derefed_place,\n+                                Rvalue::Use(val),\n+                            ))),\n+                        });\n+                        terminator.kind = TerminatorKind::Goto { target };\n+                    }\n                     sym::discriminant_value => {\n                         if let (Some(target), Some(arg)) = (*target, args[0].place()) {\n                             let arg = tcx.mk_place_deref(arg);"}, {"sha": "31bbdb2a3bc657e85bfe0425612a4acb07f67765", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -1636,6 +1636,7 @@ symbols! {\n         write_bytes,\n         write_macro,\n         write_str,\n+        write_via_move,\n         writeln_macro,\n         x87_reg,\n         xer,"}, {"sha": "077c0fdc380bc14fee87b93d2102568d03a7ddd4", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -2257,12 +2257,23 @@ extern \"rust-intrinsic\" {\n     /// This is an implementation detail of [`crate::ptr::read`] and should\n     /// not be used anywhere else.  See its comments for why this exists.\n     ///\n-    /// This intrinsic can *only* be called where the argument is a local without\n-    /// projections (`read_via_copy(p)`, not `read_via_copy(*p)`) so that it\n+    /// This intrinsic can *only* be called where the pointer is a local without\n+    /// projections (`read_via_copy(ptr)`, not `read_via_copy(*ptr)`) so that it\n     /// trivially obeys runtime-MIR rules about derefs in operands.\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n     #[rustc_nounwind]\n-    pub fn read_via_copy<T>(p: *const T) -> T;\n+    pub fn read_via_copy<T>(ptr: *const T) -> T;\n+\n+    /// This is an implementation detail of [`crate::ptr::write`] and should\n+    /// not be used anywhere else.  See its comments for why this exists.\n+    ///\n+    /// This intrinsic can *only* be called where the pointer is a local without\n+    /// projections (`write_via_move(ptr, x)`, not `write_via_move(*ptr, x)`) so\n+    /// that it trivially obeys runtime-MIR rules about derefs in operands.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n+    #[rustc_nounwind]\n+    pub fn write_via_move<T>(ptr: *mut T, value: T);\n \n     /// Returns the value of the discriminant for the variant in 'v';\n     /// if `T` has no discriminant, returns `0`.\n@@ -2828,3 +2839,16 @@ pub const unsafe fn transmute_unchecked<Src, Dst>(src: Src) -> Dst {\n     // SAFETY: It's a transmute -- the caller promised it's fine.\n     unsafe { transmute_copy(&ManuallyDrop::new(src)) }\n }\n+\n+/// Polyfill for bootstrap\n+#[cfg(bootstrap)]\n+pub const unsafe fn write_via_move<T>(ptr: *mut T, value: T) {\n+    use crate::mem::*;\n+    // SAFETY: the caller must guarantee that `dst` is valid for writes.\n+    // `dst` cannot overlap `src` because the caller has mutable access\n+    // to `dst` while `src` is owned by this function.\n+    unsafe {\n+        copy_nonoverlapping::<T>(&value, ptr, 1);\n+        forget(value);\n+    }\n+}"}, {"sha": "5f55f762ad555c7df6bd04afd216496113103d7a", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -1349,13 +1349,13 @@ pub const unsafe fn read_unaligned<T>(src: *const T) -> T {\n #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn write<T>(dst: *mut T, src: T) {\n-    // We are calling the intrinsics directly to avoid function calls in the generated code\n-    // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n-    extern \"rust-intrinsic\" {\n-        #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n-        #[rustc_nounwind]\n-        fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n-    }\n+    // Semantically, it would be fine for this to be implemented as a\n+    // `copy_nonoverlapping` and appropriate drop suppression of `src`.\n+\n+    // However, implementing via that currently produces more MIR than is ideal.\n+    // Using an intrinsic keeps it down to just the simple `*dst = move src` in\n+    // MIR (11 statements shorter, at the time of writing), and also allows\n+    // `src` to stay an SSA value in codegen_ssa, rather than a memory one.\n \n     // SAFETY: the caller must guarantee that `dst` is valid for writes.\n     // `dst` cannot overlap `src` because the caller has mutable access\n@@ -1365,8 +1365,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n             \"ptr::write requires that the pointer argument is aligned and non-null\",\n             [T](dst: *mut T) => is_aligned_and_not_null(dst)\n         );\n-        copy_nonoverlapping(&src as *const T, dst, 1);\n-        intrinsics::forget(src);\n+        intrinsics::write_via_move(dst, src)\n     }\n }\n "}, {"sha": "21344208130ea0723e0a4a207ce1366879f4e0f0", "filename": "src/tools/miri/tests/fail/dangling_pointers/null_pointer_write_zst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.rs?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -7,5 +7,5 @@ fn main() {\n     // Also not assigning directly as that's array initialization, not assignment.\n     let zst_val = [1u8; 0];\n     unsafe { std::ptr::null_mut::<[u8; 0]>().write(zst_val) };\n-    //~^ERROR: memory access failed: null pointer is a dangling pointer\n+    //~^ERROR: dereferencing pointer failed: null pointer is a dangling pointer\n }"}, {"sha": "a4e0ebe38f6a978b3d11a33366487e38c22951a8", "filename": "src/tools/miri/tests/fail/dangling_pointers/null_pointer_write_zst.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdangling_pointers%2Fnull_pointer_write_zst.stderr?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: memory access failed: null pointer is a dangling pointer (it has no provenance)\n+error: Undefined Behavior: dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n   --> $DIR/null_pointer_write_zst.rs:LL:CC\n    |\n LL |     unsafe { std::ptr::null_mut::<[u8; 0]>().write(zst_val) };\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is a dangling pointer (it has no provenance)\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "81e56b5490d642183e21dda39eae1252b84f44d8", "filename": "tests/codegen/mem-replace-big-type.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fcodegen%2Fmem-replace-big-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fcodegen%2Fmem-replace-big-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-big-type.rs?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -11,7 +11,9 @@\n #[repr(C, align(8))]\n pub struct Big([u64; 7]);\n pub fn replace_big(dst: &mut Big, src: Big) -> Big {\n-    // Before the `read_via_copy` intrinsic, this emitted six `memcpy`s.\n+    // Back in 1.68, this emitted six `memcpy`s.\n+    // `read_via_copy` in 1.69 got that down to three.\n+    // `write_via_move` has it down to just the two essential ones.\n     std::mem::replace(dst, src)\n }\n \n@@ -20,17 +22,13 @@ pub fn replace_big(dst: &mut Big, src: Big) -> Big {\n \n // CHECK-NOT: call void @llvm.memcpy\n \n-// For a large type, we expect exactly three `memcpy`s\n+// For a large type, we expect exactly two `memcpy`s\n // CHECK-LABEL: define internal void @{{.+}}mem{{.+}}replace{{.+}}sret(%Big)\n     // CHECK-NOT: alloca\n-    // CHECK: alloca %Big\n-    // CHECK-NOT: alloca\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n     // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %0, {{i8\\*|ptr}} align 8 %dest, i{{.*}} 56, i1 false)\n     // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %dest, {{i8\\*|ptr}} align 8 %src, i{{.*}} 56, i1 false)\n     // CHECK-NOT: call void @llvm.memcpy\n \n // CHECK-NOT: call void @llvm.memcpy"}, {"sha": "83babab4f847b150dc4d0e8301b13c7298e49e3a", "filename": "tests/codegen/mem-replace-direct-memcpy.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,33 +0,0 @@\n-// This test ensures that `mem::replace::<T>` only ever calls `@llvm.memcpy`\n-// with `size_of::<T>()` as the size, and never goes through any wrapper that\n-// may e.g. multiply `size_of::<T>()` with a variable \"count\" (which is only\n-// known to be `1` after inlining).\n-\n-// compile-flags: -C no-prepopulate-passes -Zinline-mir=no\n-// ignore-debug: the debug assertions get in the way\n-\n-#![crate_type = \"lib\"]\n-\n-pub fn replace_byte(dst: &mut u8, src: u8) -> u8 {\n-    std::mem::replace(dst, src)\n-}\n-\n-// NOTE(eddyb) the `CHECK-NOT`s ensure that the only calls of `@llvm.memcpy` in\n-// the entire output, are the direct calls we want, from `ptr::replace`.\n-\n-// CHECK-NOT: call void @llvm.memcpy\n-\n-// For a small type, we expect one each of `load`/`store`/`memcpy` instead\n-// CHECK-LABEL: define internal noundef i8 @{{.+}}mem{{.+}}replace\n-    // CHECK-NOT: alloca\n-    // CHECK: alloca i8\n-    // CHECK-NOT: alloca\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: load i8\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: store i8\n-    // CHECK-NOT: call void @llvm.memcpy\n-    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n-    // CHECK-NOT: call void @llvm.memcpy\n-\n-// CHECK-NOT: call void @llvm.memcpy"}, {"sha": "4253ef1366604a48c72cf2b6ca9d09d2f6b8f6c2", "filename": "tests/codegen/mem-replace-simple-type.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fcodegen%2Fmem-replace-simple-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fcodegen%2Fmem-replace-simple-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-simple-type.rs?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -0,0 +1,34 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+// min-llvm-version: 15.0 (for opaque pointers)\n+// only-x86_64 (to not worry about usize differing)\n+// ignore-debug (the debug assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+\n+#[no_mangle]\n+// CHECK-LABEL: @replace_usize(\n+pub fn replace_usize(r: &mut usize, v: usize) -> usize {\n+    // CHECK-NOT: alloca\n+    // CHECK: %[[R:.+]] = load i64, ptr %r\n+    // CHECK: store i64 %v, ptr %r\n+    // CHECK: ret i64 %[[R]]\n+    std::mem::replace(r, v)\n+}\n+\n+#[no_mangle]\n+// CHECK-LABEL: @replace_ref_str(\n+pub fn replace_ref_str<'a>(r: &mut &'a str, v: &'a str) -> &'a str {\n+    // CHECK-NOT: alloca\n+    // CHECK: %[[A:.+]] = load ptr\n+    // CHECK: %[[B:.+]] = load i64\n+    // CHECK-NOT: store\n+    // CHECK-NOT: load\n+    // CHECK: store ptr\n+    // CHECK: store i64\n+    // CHECK-NOT: load\n+    // CHECK-NOT: store\n+    // CHECK: %[[P1:.+]] = insertvalue { ptr, i64 } poison, ptr %[[A]], 0\n+    // CHECK: %[[P2:.+]] = insertvalue { ptr, i64 } %[[P1]], i64 %[[B]], 1\n+    // CHECK: ret { ptr, i64 } %[[P2]]\n+    std::mem::replace(r, v)\n+}"}, {"sha": "b022e2ba42bb8fb22ff2405be11f71e161c16dbd", "filename": "tests/mir-opt/lower_intrinsics.option_payload.LowerIntrinsics.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -24,7 +24,7 @@\n           _4 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n -         _3 = option_payload_ptr::<usize>(move _4) -> [return: bb1, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:132:18: 132:54\n+-                                          // + span: $DIR/lower_intrinsics.rs:137:18: 137:54\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<usize>) -> *const usize {option_payload_ptr::<usize>}, val: Value(<ZST>) }\n +         _3 = &raw const (((*_4) as Some).0: usize); // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n@@ -37,7 +37,7 @@\n           _6 = &raw const (*_2);           // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n -         _5 = option_payload_ptr::<String>(move _6) -> [return: bb2, unwind unreachable]; // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:133:18: 133:54\n+-                                          // + span: $DIR/lower_intrinsics.rs:138:18: 138:54\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<String>) -> *const String {option_payload_ptr::<String>}, val: Value(<ZST>) }\n +         _5 = &raw const (((*_6) as Some).0: std::string::String); // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n +         goto -> bb2;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57"}, {"sha": "60a1dd0ba7d09e4757e1861fdadbec56c0d02262", "filename": "tests/mir-opt/lower_intrinsics.ptr_offset.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Flower_intrinsics.ptr_offset.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Flower_intrinsics.ptr_offset.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.ptr_offset.LowerIntrinsics.diff?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -15,7 +15,7 @@\n           _4 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:33: +1:34\n -         _0 = offset::<*const i32, isize>(move _3, move _4) -> [return: bb1, unwind unreachable]; // scope 0 at $DIR/lower_intrinsics.rs:+1:5: +1:35\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:139:5: 139:29\n+-                                          // + span: $DIR/lower_intrinsics.rs:144:5: 144:29\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32, isize) -> *const i32 {offset::<*const i32, isize>}, val: Value(<ZST>) }\n +         _0 = Offset(move _3, move _4);   // scope 0 at $DIR/lower_intrinsics.rs:+1:5: +1:35\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:5: +1:35"}, {"sha": "0ca88a42e3fd05fef10c281bd6d618dd9cdf8ed1", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -124,6 +124,11 @@ pub fn read_via_copy_uninhabited(r: &Never) -> Never {\n     unsafe { core::intrinsics::read_via_copy(r) }\n }\n \n+// EMIT_MIR lower_intrinsics.write_via_move_string.LowerIntrinsics.diff\n+pub fn write_via_move_string(r: &mut String, v: String) {\n+    unsafe { core::intrinsics::write_via_move(r, v) }\n+}\n+\n pub enum Never {}\n \n // EMIT_MIR lower_intrinsics.option_payload.LowerIntrinsics.diff"}, {"sha": "38d99f661dc648337c8d94bee234dbb5f21451fc", "filename": "tests/mir-opt/lower_intrinsics.write_via_move_string.LowerIntrinsics.diff", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Flower_intrinsics.write_via_move_string.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Flower_intrinsics.write_via_move_string.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.write_via_move_string.LowerIntrinsics.diff?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -0,0 +1,36 @@\n+- // MIR for `write_via_move_string` before LowerIntrinsics\n++ // MIR for `write_via_move_string` after LowerIntrinsics\n+  \n+  fn write_via_move_string(_1: &mut String, _2: String) -> () {\n+      debug r => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:30: +0:31\n+      debug v => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:46: +0:47\n+      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:57: +0:57\n+      let mut _3: *mut std::string::String; // in scope 0 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+      let mut _4: std::string::String;     // in scope 0 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+          _3 = &raw mut (*_1);             // scope 1 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+          StorageLive(_4);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+          _4 = move _2;                    // scope 1 at $DIR/lower_intrinsics.rs:+1:50: +1:51\n+-         _0 = write_via_move::<String>(move _3, move _4) -> [return: bb1, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:52\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:129:14: 129:46\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*mut String, String) {write_via_move::<String>}, val: Value(<ZST>) }\n++         (*_3) = move _4;                 // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:52\n++         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:52\n+      }\n+  \n+      bb1: {\n+          StorageDead(_4);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:51: +1:52\n+          StorageDead(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:51: +1:52\n+          goto -> bb2;                     // scope 0 at $DIR/lower_intrinsics.rs:+2:1: +2:2\n+      }\n+  \n+      bb2: {\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "2b4971e2ef9191dd7b9e32cbd9ffd1aff3c5365e", "filename": "tests/mir-opt/pre-codegen/mem_replace.manual_replace.PreCodegen.after.mir", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.manual_replace.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.manual_replace.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.manual_replace.PreCodegen.after.mir?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -0,0 +1,16 @@\n+// MIR for `manual_replace` after PreCodegen\n+\n+fn manual_replace(_1: &mut u32, _2: u32) -> u32 {\n+    debug r => _1;                       // in scope 0 at $DIR/mem_replace.rs:+0:23: +0:24\n+    debug v => _2;                       // in scope 0 at $DIR/mem_replace.rs:+0:36: +0:37\n+    let mut _0: u32;                     // return place in scope 0 at $DIR/mem_replace.rs:+1:9: +1:13\n+    scope 1 {\n+        debug temp => _0;                // in scope 1 at $DIR/mem_replace.rs:+1:9: +1:13\n+    }\n+\n+    bb0: {\n+        _0 = (*_1);                      // scope 0 at $DIR/mem_replace.rs:+1:16: +1:18\n+        (*_1) = _2;                      // scope 1 at $DIR/mem_replace.rs:+2:5: +2:11\n+        return;                          // scope 0 at $DIR/mem_replace.rs:+4:2: +4:2\n+    }\n+}"}, {"sha": "50e0538c133684a4dddf1f59d0fe9d1f873f1afd", "filename": "tests/mir-opt/pre-codegen/mem_replace.mem_replace.PreCodegen.after.mir", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.mem_replace.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.mem_replace.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.mem_replace.PreCodegen.after.mir?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -0,0 +1,53 @@\n+// MIR for `mem_replace` after PreCodegen\n+\n+fn mem_replace(_1: &mut u32, _2: u32) -> u32 {\n+    debug r => _1;                       // in scope 0 at $DIR/mem_replace.rs:+0:20: +0:21\n+    debug v => _2;                       // in scope 0 at $DIR/mem_replace.rs:+0:33: +0:34\n+    let mut _0: u32;                     // return place in scope 0 at $DIR/mem_replace.rs:+0:44: +0:47\n+    scope 1 (inlined std::mem::replace::<u32>) { // at $DIR/mem_replace.rs:16:5: 16:28\n+        debug dest => _1;                // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        debug src => _2;                 // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        let mut _3: *const u32;          // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        let mut _4: *mut u32;            // in scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        scope 2 {\n+            scope 3 {\n+                debug result => _0;      // in scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+                scope 7 (inlined std::ptr::write::<u32>) { // at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+                    debug dst => _4;     // in scope 7 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                    debug src => _2;     // in scope 7 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                    let mut _6: *mut u32; // in scope 7 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                    scope 8 {\n+                        scope 9 (inlined std::ptr::write::runtime::<u32>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                            debug dst => _6; // in scope 9 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                        }\n+                    }\n+                }\n+            }\n+            scope 4 (inlined std::ptr::read::<u32>) { // at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+                debug src => _3;         // in scope 4 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+                let mut _5: *const u32;  // in scope 4 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                scope 5 {\n+                    scope 6 (inlined std::ptr::read::runtime::<u32>) { // at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                        debug src => _5; // in scope 6 at $SRC_DIR/core/src/intrinsics.rs:LL:COL\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_3);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        _3 = &raw const (*_1);           // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        StorageLive(_5);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        _0 = (*_3);                      // scope 5 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+        StorageDead(_5);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        StorageDead(_3);                 // scope 2 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        StorageLive(_4);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        _4 = &raw mut (*_1);             // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        (*_4) = _2;                      // scope 8 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+        StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        StorageDead(_4);                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+        return;                          // scope 0 at $DIR/mem_replace.rs:+2:2: +2:2\n+    }\n+}"}, {"sha": "e5066c38b9679f48adc4c10bd2d3c907d104ae97", "filename": "tests/mir-opt/pre-codegen/mem_replace.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db1e5e771cb810b22f4ff26f1346e386ca7643f/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpre-codegen%2Fmem_replace.rs?ref=6db1e5e771cb810b22f4ff26f1346e386ca7643f", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -O -C debuginfo=0 -Zmir-opt-level=2\n+// only-64bit\n+// ignore-debug\n+\n+#![crate_type = \"lib\"]\n+\n+// EMIT_MIR mem_replace.manual_replace.PreCodegen.after.mir\n+pub fn manual_replace(r: &mut u32, v: u32) -> u32 {\n+    let temp = *r;\n+    *r = v;\n+    temp\n+}\n+\n+// EMIT_MIR mem_replace.mem_replace.PreCodegen.after.mir\n+pub fn mem_replace(r: &mut u32, v: u32) -> u32 {\n+    std::mem::replace(r, v)\n+}"}]}