{"sha": "54fd8caddc980a6ad47069d9674b4f59b1cd7da0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZmQ4Y2FkZGM5ODBhNmFkNDcwNjlkOTY3NGI0ZjU5YjFjZDdkYTA=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2018-12-20T04:38:00Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-01-04T02:58:21Z"}, "message": "Remove extra recursion_depth tracking", "tree": {"sha": "70d395b5a0108863bbca665daf20fca1297cd1e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70d395b5a0108863bbca665daf20fca1297cd1e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54fd8caddc980a6ad47069d9674b4f59b1cd7da0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAlwuy80ACgkQtAh+UQ6Y\nsWQ0wA//ddDt0mMfjebgPGU6Q5Uu2z/vlfO6MilZvj6nbqzNe7P+F8E4xz/tu6VB\n8av2AfwW+PfSOr40kqnGyn+E1s8q2zryoc7do/i6yGLHohUF8+OgrpFNSAlHvQ8B\nhhKFuIsQXoQ8mulsfP9VXoreNWYY3OO64lOdB9rE3dMDK6Xvjd73m30Df89S6QEO\nl0QmrkPc6PpgS/cYxlYiDaxzAWYw4Ugp4k0fQibYDQsCZx7aOakvJo/CmK+qdhRR\nokiF+EtSsawIqoeSBby3cOBvRiZJTFaJzUqevmBRwRkp1SzA0EB09YTLIywX7d44\nx0AnLOXtYz6trgzZaei1qIwDPBZsYSKvRRgzcQ9cxAxDQ0U1NXrQTdenc5xNQQfZ\nmTUPfbEQ78irnBOwnnMW9+GUHRCNnJU2nbHtMTZEhf78GYmAxxqYUEAhXdvfyGYg\ns4Yhj3UtxI7O68bCE5MXcSmYUFlCMc34EbiJ6D7+G9Nsrh1rU3eAoCeb5VgeqWd5\nt/1M+IF6zF49v6E3k9E+2ou/7VBmsq1gQx3NxGkjR39JqTaxmixFZtgMGk7iBN54\nk3TenCpdhPcl+LTZi4mJv+OR7ZjtQvliTKHYaZis4kkZNXbUyTFiqdL34yKo0lM9\nORsoAFXvO9qNWF2QwXv66GPQdgwOr3Kc9w0mgjVyych/2WeZ3o0=\n=HDDc\n-----END PGP SIGNATURE-----", "payload": "tree 70d395b5a0108863bbca665daf20fca1297cd1e1\nparent c55c312c1721c80289915d8741d7f05d7c33de70\nauthor Aaron Hill <aa1ronham@gmail.com> 1545280680 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1546570701 -0500\n\nRemove extra recursion_depth tracking\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54fd8caddc980a6ad47069d9674b4f59b1cd7da0", "html_url": "https://github.com/rust-lang/rust/commit/54fd8caddc980a6ad47069d9674b4f59b1cd7da0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54fd8caddc980a6ad47069d9674b4f59b1cd7da0/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c55c312c1721c80289915d8741d7f05d7c33de70", "url": "https://api.github.com/repos/rust-lang/rust/commits/c55c312c1721c80289915d8741d7f05d7c33de70", "html_url": "https://github.com/rust-lang/rust/commit/c55c312c1721c80289915d8741d7f05d7c33de70"}], "stats": {"total": 104, "additions": 41, "deletions": 63}, "files": [{"sha": "7931943c90959ef359f3674169870abcbde2891d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 41, "deletions": 63, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/54fd8caddc980a6ad47069d9674b4f59b1cd7da0/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54fd8caddc980a6ad47069d9674b4f59b1cd7da0/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=54fd8caddc980a6ad47069d9674b4f59b1cd7da0", "patch": "@@ -42,7 +42,7 @@ use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n use std::cmp;\n-use std::fmt::{self, Display};\n+use std::fmt;\n use std::iter;\n use std::rc::Rc;\n use util::nodemap::{FxHashMap, FxHashSet};\n@@ -573,9 +573,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n \n-        // 'select' is an entry point into SelectionContext - we never call it recursively\n-        // from within SelectionContext. Therefore, we start our recursion depth at 0\n-        let candidate = match self.candidate_from_obligation(&stack, 0) {\n+        let candidate = match self.candidate_from_obligation(&stack) {\n             Err(SelectionError::Overflow) => {\n                 // In standard mode, overflow must have been caught and reported\n                 // earlier.\n@@ -631,9 +629,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.evaluation_probe(|this| {\n-            // Like 'select', 'evaluate_obligation_recursively' is an entry point into\n-            // SelectionContext, so our recursion depth is 0\n-            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation, 0)\n+            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation.clone())\n         })\n     }\n \n@@ -657,15 +653,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         stack: TraitObligationStackList<'o, 'tcx>,\n         predicates: I,\n-        recursion_depth: usize\n     ) -> Result<EvaluationResult, OverflowError>\n     where\n-        I: IntoIterator<Item = &'a PredicateObligation<'tcx>>,\n+        I: IntoIterator<Item = PredicateObligation<'tcx>>,\n         'tcx: 'a,\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n-            let eval = self.evaluate_predicate_recursively(stack, obligation, recursion_depth)?;\n+            let eval = self.evaluate_predicate_recursively(stack, obligation)?;\n             debug!(\n                 \"evaluate_predicate_recursively({:?}) = {:?}\",\n                 obligation, eval\n@@ -684,32 +679,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_predicate_recursively<'o>(\n         &mut self,\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n-        obligation: &PredicateObligation<'tcx>,\n-        mut recursion_depth: usize\n+        obligation: PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        debug!(\"evaluate_predicate_recursively({:?}, recursion_depth={:?})\", obligation,\n-            recursion_depth);\n-\n-        // We need to check for overflow here, since the normal\n-        // recursion check uses the obligation from the stack.\n-        // This is insufficient for two reasions:\n-        // 1. That recursion depth is only incremented when a candidate is confirmed\n-        //    Since evaluation skips candidate confirmation, this will never happen\n-        // 2. It relies on the trait obligation stack. However, it's possible for overflow\n-        //    to happen without involving the trait obligation stack. For example,\n-        //    we might end up trying to infinitely recurse with a projection predicate,\n-        //    which will never push anything onto the stack.\n-        self.check_recursion_limit(recursion_depth, obligation)?;\n-\n-        // Now that we know that the recursion check has passed, increment our depth\n-        recursion_depth += 1;\n+        debug!(\"evaluate_predicate_recursively({:?})\", obligation);\n+        self.check_recursion_limit(obligation)?;\n \n         match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n                 debug_assert!(!t.has_escaping_bound_vars());\n-                let obligation = obligation.with(t.clone());\n-                self.evaluate_trait_predicate_recursively(previous_stack, obligation,\n-                                                          recursion_depth)\n+                let mut obligation = obligation.with(t.clone());\n+                obligation.recursion_depth += 1\n+                self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n             ty::Predicate::Subtype(ref p) => {\n@@ -718,8 +698,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     .subtype_predicate(&obligation.cause, obligation.param_env, p)\n                 {\n                     Some(Ok(InferOk { obligations, .. })) => {\n-                        self.evaluate_predicates_recursively(previous_stack, &obligations,\n-                                                             recursion_depth)\n+                        for o in obligations.iter_mut() {\n+                            o.recursion_depth += 1\n+                        }\n+                        self.evaluate_predicates_recursively(previous_stack, obligation.into_iter())\n                     }\n                     Some(Err(_)) => Ok(EvaluatedToErr),\n                     None => Ok(EvaluatedToAmbig),\n@@ -734,8 +716,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 obligation.cause.span,\n             ) {\n                 Some(obligations) => {\n-                    self.evaluate_predicates_recursively(previous_stack, obligations.iter(),\n-                        recursion_depth)\n+                    for o in obligations.iter_mut() {\n+                        o.recursion_depth += 1\n+                    }\n+                    self.evaluate_predicates_recursively(previous_stack, obligations.iter())\n                 }\n                 None => Ok(EvaluatedToAmbig),\n             },\n@@ -758,10 +742,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let project_obligation = obligation.with(data.clone());\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n                     Ok(Some(subobligations)) => {\n+                        for o in subobligations.iter_mut() {\n+                            o.recursion_depth += 1\n+                        }\n                         let result = self.evaluate_predicates_recursively(\n                             previous_stack,\n-                            subobligations.iter(),\n-                            recursion_depth\n+                            subobligations.into_iter(),\n                         );\n                         if let Some(key) =\n                             ProjectionCacheKey::from_poly_projection_predicate(self, data)\n@@ -820,7 +806,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n         mut obligation: TraitObligation<'tcx>,\n-        recursion_depth: usize\n     ) -> Result<EvaluationResult, OverflowError> {\n         debug!(\"evaluate_trait_predicate_recursively({:?})\", obligation);\n \n@@ -848,7 +833,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(result);\n         }\n \n-        let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack, recursion_depth));\n+        let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n         let result = result?;\n \n         debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n@@ -860,7 +845,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_stack<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n-        recursion_depth: usize\n     ) -> Result<EvaluationResult, OverflowError> {\n         // In intercrate mode, whenever any of the types are unbound,\n         // there can always be an impl. Even if there are no impls in\n@@ -901,7 +885,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // Heuristics: show the diagnostics when there are no candidates in crate.\n             if self.intercrate_ambiguity_causes.is_some() {\n                 debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n-                if let Ok(candidate_set) = self.assemble_candidates(stack, recursion_depth) {\n+                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n                     if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n                         let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n                         let self_ty = trait_ref.self_ty();\n@@ -982,8 +966,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n         }\n \n-        match self.candidate_from_obligation(stack, recursion_depth) {\n-            Ok(Some(c)) => self.evaluate_candidate(stack, &c, recursion_depth),\n+        match self.candidate_from_obligation(stack) {\n+            Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n             Ok(None) => Ok(EvaluatedToAmbig),\n             Err(Overflow) => Err(OverflowError),\n             Err(..) => Ok(EvaluatedToErr),\n@@ -1022,7 +1006,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n         candidate: &SelectionCandidate<'tcx>,\n-        recursion_depth: usize\n     ) -> Result<EvaluationResult, OverflowError> {\n         debug!(\n             \"evaluate_candidate: depth={} candidate={:?}\",\n@@ -1034,7 +1017,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ok(selection) => this.evaluate_predicates_recursively(\n                     stack.list(),\n                     selection.nested_obligations().iter(),\n-                    recursion_depth\n                 ),\n                 Err(..) => Ok(EvaluatedToErr),\n             }\n@@ -1109,13 +1091,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .insert(trait_ref, WithDepNode::new(dep_node, result));\n     }\n \n+    // Check that the recursion limit has not been exceeded.\n+    //\n     // The weird return type of this function allows it to be used with the 'try' (?)\n     // operator within certain functions\n-    fn check_recursion_limit<T: Display + TypeFoldable<'tcx>>(&self, recursion_depth: usize,\n-                                                              obligation: &Obligation<'tcx, T>,\n+    fn check_recursion_limit<T: Display + TypeFoldable<'tcx>>(&self, obligation: &Obligation<'tcx, T>,\n     ) -> Result<(), OverflowError>  {\n         let recursion_limit = *self.infcx.tcx.sess.recursion_limit.get();\n-        if recursion_depth >= recursion_limit {\n+        if obligaton.recursion_depth >= recursion_limit {\n             match self.query_mode {\n                 TraitQueryMode::Standard => {\n                     self.infcx().report_overflow_error(obligation, true);\n@@ -1141,11 +1124,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn candidate_from_obligation<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n-        recursion_depth: usize\n     ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n         // Watch out for overflow. This intentionally bypasses (and does\n         // not update) the cache.\n-        self.check_recursion_limit(stack.obligation.recursion_depth, &stack.obligation)?;\n+        self.check_recursion_limit(&stack.obligation)?;\n+\n \n         // Check the cache. Note that we freshen the trait-ref\n         // separately rather than using `stack.fresh_trait_ref` --\n@@ -1167,7 +1150,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // If no match, compute result and insert into cache.\n         let (candidate, dep_node) =\n-            self.in_task(|this| this.candidate_from_obligation_no_cache(stack, recursion_depth));\n+            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n \n         debug!(\n             \"CACHE MISS: SELECT({:?})={:?}\",\n@@ -1211,7 +1194,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn candidate_from_obligation_no_cache<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n-        recursion_depth: usize\n     ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n         if stack.obligation.predicate.references_error() {\n             // If we encounter a `Error`, we generally prefer the\n@@ -1229,13 +1211,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             if self.intercrate_ambiguity_causes.is_some() {\n                 debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n                 // Heuristics: show the diagnostics when there are no candidates in crate.\n-                if let Ok(candidate_set) = self.assemble_candidates(stack, recursion_depth) {\n+                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n                     let mut no_candidates_apply = true;\n                     {\n                         let evaluated_candidates = candidate_set\n                             .vec\n                             .iter()\n-                            .map(|c| self.evaluate_candidate(stack, &c, recursion_depth));\n+                            .map(|c| self.evaluate_candidate(stack, &c));\n \n                         for ec in evaluated_candidates {\n                             match ec {\n@@ -1281,7 +1263,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(None);\n         }\n \n-        let candidate_set = self.assemble_candidates(stack, recursion_depth)?;\n+        let candidate_set = self.assemble_candidates(stack)?;\n \n         if candidate_set.ambiguous {\n             debug!(\"candidate set contains ambig\");\n@@ -1328,7 +1310,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // is needed for specialization. Propagate overflow if it occurs.\n         let mut candidates = candidates\n             .into_iter()\n-            .map(|c| match self.evaluate_candidate(stack, &c, recursion_depth) {\n+            .map(|c| match self.evaluate_candidate(stack, &c) {\n                 Ok(eval) if eval.may_apply() => Ok(Some(EvaluatedCandidate {\n                     candidate: c,\n                     evaluation: eval,\n@@ -1566,7 +1548,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn assemble_candidates<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n-        recursion_depth: usize\n     ) -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>> {\n         let TraitObligationStack { obligation, .. } = *stack;\n         let ref obligation = Obligation {\n@@ -1642,7 +1623,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n-        self.assemble_candidates_from_caller_bounds(stack, &mut candidates, recursion_depth)?;\n+        self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;\n         // Auto implementations have lower priority, so we only\n         // consider triggering a default if there is no other impl that can apply.\n         if candidates.vec.is_empty() {\n@@ -1775,7 +1756,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n-        recursion_depth: usize\n     ) -> Result<(), SelectionError<'tcx>> {\n         debug!(\n             \"assemble_candidates_from_caller_bounds({:?})\",\n@@ -1797,7 +1777,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // keep only those bounds which may apply, and propagate overflow if it occurs\n         let mut param_candidates = vec![];\n         for bound in matching_bounds {\n-            let wc = self.evaluate_where_clause(stack, bound.clone(), recursion_depth)?;\n+            let wc = self.evaluate_where_clause(stack, bound.clone())?;\n             if wc.may_apply() {\n                 param_candidates.push(ParamCandidate(bound));\n             }\n@@ -1812,13 +1792,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n         where_clause_trait_ref: ty::PolyTraitRef<'tcx>,\n-        recursion_depth: usize\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.evaluation_probe(|this| {\n             match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n-                    this.evaluate_predicates_recursively(stack.list(), obligations.iter(),\n-                        recursion_depth)\n+                    this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n                 Err(()) => Ok(EvaluatedToErr),\n             }"}]}