{"sha": "09f4008da5ecee74fe06d8fd78ac39064e300512", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZjQwMDhkYTVlY2VlNzRmZTA2ZDhmZDc4YWMzOTA2NGUzMDA1MTI=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-04-11T02:47:10Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-04-29T23:48:22Z"}, "message": "SGX target: implemented vectored I/O", "tree": {"sha": "48659169d808b9e5b7f8d95829466c790f46de68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48659169d808b9e5b7f8d95829466c790f46de68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09f4008da5ecee74fe06d8fd78ac39064e300512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09f4008da5ecee74fe06d8fd78ac39064e300512", "html_url": "https://github.com/rust-lang/rust/commit/09f4008da5ecee74fe06d8fd78ac39064e300512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09f4008da5ecee74fe06d8fd78ac39064e300512/comments", "author": null, "committer": null, "parents": [{"sha": "7e624ce2c2f5196a94178ce7dd62173526ff6839", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e624ce2c2f5196a94178ce7dd62173526ff6839", "html_url": "https://github.com/rust-lang/rust/commit/7e624ce2c2f5196a94178ce7dd62173526ff6839"}], "stats": {"total": 63, "additions": 50, "deletions": 13}, "files": [{"sha": "fca62e028deab9a91e779caa4f42b6b5497d6ca2", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/09f4008da5ecee74fe06d8fd78ac39064e300512/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4008da5ecee74fe06d8fd78ac39064e300512/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=09f4008da5ecee74fe06d8fd78ac39064e300512", "patch": "@@ -1,4 +1,5 @@\n-use crate::io::{Error as IoError, Result as IoResult};\n+use crate::cmp;\n+use crate::io::{Error as IoError, Result as IoResult, IoSlice, IoSliceMut};\n use crate::time::Duration;\n \n pub(crate) mod alloc;\n@@ -8,13 +9,27 @@ pub(crate) mod raw;\n use self::raw::*;\n \n /// Usercall `read`. See the ABI documentation for more information.\n+///\n+/// This will do a single `read` usercall and scatter the read data among\n+/// `bufs`. To read to a single buffer, just pass a slice of length one.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-pub fn read(fd: Fd, buf: &mut [u8]) -> IoResult<usize> {\n+pub fn read(fd: Fd, bufs: &mut [IoSliceMut<'_>]) -> IoResult<usize> {\n     unsafe {\n-        let mut userbuf = alloc::User::<[u8]>::uninitialized(buf.len());\n-        let len = raw::read(fd, userbuf.as_mut_ptr(), userbuf.len()).from_sgx_result()?;\n-        userbuf[..len].copy_to_enclave(&mut buf[..len]);\n-        Ok(len)\n+        let total_len = bufs.iter().fold(0usize, |sum, buf| sum.saturating_add(buf.len()));\n+        let mut userbuf = alloc::User::<[u8]>::uninitialized(total_len);\n+        let ret_len = raw::read(fd, userbuf.as_mut_ptr(), userbuf.len()).from_sgx_result()?;\n+        let userbuf = &userbuf[..ret_len];\n+        let mut index = 0;\n+        for buf in bufs {\n+            let end = cmp::min(index + buf.len(), userbuf.len());\n+            if let Some(buflen) = end.checked_sub(index) {\n+                userbuf[index..end].copy_to_enclave(&mut buf[..buflen]);\n+                index += buf.len();\n+            } else {\n+                break\n+            }\n+        }\n+        Ok(userbuf.len())\n     }\n }\n \n@@ -30,10 +45,24 @@ pub fn read_alloc(fd: Fd) -> IoResult<Vec<u8>> {\n }\n \n /// Usercall `write`. See the ABI documentation for more information.\n+///\n+/// This will do a single `write` usercall and gather the written data from\n+/// `bufs`. To write from a single buffer, just pass a slice of length one.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-pub fn write(fd: Fd, buf: &[u8]) -> IoResult<usize> {\n+pub fn write(fd: Fd, bufs: &[IoSlice<'_>]) -> IoResult<usize> {\n     unsafe {\n-        let userbuf = alloc::User::new_from_enclave(buf);\n+        let total_len = bufs.iter().fold(0usize, |sum, buf| sum.saturating_add(buf.len()));\n+        let mut userbuf = alloc::User::<[u8]>::uninitialized(total_len);\n+        let mut index = 0;\n+        for buf in bufs {\n+            let end = cmp::min(index + buf.len(), userbuf.len());\n+            if let Some(buflen) = end.checked_sub(index) {\n+                userbuf[index..end].copy_from_enclave(&buf[..buflen]);\n+                index += buf.len();\n+            } else {\n+                break\n+            }\n+        }\n         raw::write(fd, userbuf.as_ptr(), userbuf.len()).from_sgx_result()\n     }\n }"}, {"sha": "a1c4af81966b23c0d2daabda5d71d9a2cf92fd3d", "filename": "src/libstd/sys/sgx/fd.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09f4008da5ecee74fe06d8fd78ac39064e300512/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4008da5ecee74fe06d8fd78ac39064e300512/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs?ref=09f4008da5ecee74fe06d8fd78ac39064e300512", "patch": "@@ -1,6 +1,6 @@\n use fortanix_sgx_abi::Fd;\n \n-use crate::io;\n+use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::sys::{AsInner, FromInner, IntoInner};\n use super::abi::usercalls;\n@@ -25,11 +25,19 @@ impl FileDesc {\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        usercalls::read(self.fd, buf)\n+        usercalls::read(self.fd, &mut [IoSliceMut::new(buf)])\n+    }\n+\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        usercalls::read(self.fd, bufs)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        usercalls::write(self.fd, buf)\n+        usercalls::write(self.fd, &[IoSlice::new(buf)])\n+    }\n+\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        usercalls::write(self.fd, bufs)\n     }\n \n     pub fn flush(&self) -> io::Result<()> {"}, {"sha": "f9eca9f4cb3c1db7b1ecb58f29d906b8b9f6f58f", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09f4008da5ecee74fe06d8fd78ac39064e300512/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f4008da5ecee74fe06d8fd78ac39064e300512/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=09f4008da5ecee74fe06d8fd78ac39064e300512", "patch": "@@ -137,15 +137,15 @@ impl TcpStream {\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        io::default_read_vectored(|b| self.read(b), bufs)\n+        self.inner.inner.read_vectored(bufs)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.inner.write(buf)\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        io::default_write_vectored(|b| self.write(b), bufs)\n+        self.inner.inner.write_vectored(bufs)\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {"}]}