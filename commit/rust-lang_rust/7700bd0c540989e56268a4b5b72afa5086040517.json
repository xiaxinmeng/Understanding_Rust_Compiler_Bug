{"sha": "7700bd0c540989e56268a4b5b72afa5086040517", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MDBiZDBjNTQwOTg5ZTU2MjY4YTRiNWI3MmFmYTUwODYwNDA1MTc=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-08-02T07:30:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-02T07:30:14Z"}, "message": "Merge pull request #268 from oli-obk/upstream\n\nSplit up miri into the librustc_mir and bin parts", "tree": {"sha": "6e155a3d96271d00e67bb61cefc3de55464e13be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e155a3d96271d00e67bb61cefc3de55464e13be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7700bd0c540989e56268a4b5b72afa5086040517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7700bd0c540989e56268a4b5b72afa5086040517", "html_url": "https://github.com/rust-lang/rust/commit/7700bd0c540989e56268a4b5b72afa5086040517", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7700bd0c540989e56268a4b5b72afa5086040517/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d3c88c061d01a5bac016e261785ae39c65caa9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d3c88c061d01a5bac016e261785ae39c65caa9d", "html_url": "https://github.com/rust-lang/rust/commit/6d3c88c061d01a5bac016e261785ae39c65caa9d"}, {"sha": "d05784f23c09d50770bae400e7bd8fe51519af4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d05784f23c09d50770bae400e7bd8fe51519af4c", "html_url": "https://github.com/rust-lang/rust/commit/d05784f23c09d50770bae400e7bd8fe51519af4c"}], "stats": {"total": 3491, "additions": 2002, "deletions": 1489}, "files": [{"sha": "d9dd443d7ac1ac006f22b951b03ae1d2dc60a0e3", "filename": ".travis.yml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -15,10 +15,9 @@ script:\n   xargo/build.sh\n - |\n   # Test plain miri\n-  cd src/librustc_mir/ && cargo build &&\n+  cargo build &&\n   cargo test &&\n-  cargo install &&\n-  cd ../..\n+  cargo install\n - |\n   # Test cargo miri\n   cd cargo-miri-test &&\n@@ -27,7 +26,7 @@ script:\n   cd ..\n - |\n   # and run all tests with full mir\n-  cd src/librustc_mir/ && MIRI_SYSROOT=~/.xargo/HOST cargo test && cd ../..\n+  MIRI_SYSROOT=~/.xargo/HOST cargo test\n notifications:\n   email:\n     on_success: never"}, {"sha": "66295f0fbced7a8c7217fa163e0e31e45d816da6", "filename": "Cargo.lock", "status": "modified", "additions": 41, "deletions": 115, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -1,25 +1,14 @@\n [root]\n-name = \"miri\"\n+name = \"rustc_miri\"\n version = \"0.1.0\"\n dependencies = [\n- \"byteorder 1.0.0 (git+https://github.com/BurntSushi/byteorder)\",\n- \"cargo_metadata 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiletest_rs 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"aho-corasick\"\n-version = \"0.5.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"aho-corasick\"\n version = \"0.6.3\"\n@@ -30,16 +19,16 @@ dependencies = [\n \n [[package]]\n name = \"byteorder\"\n-version = \"1.0.0\"\n-source = \"git+https://github.com/BurntSushi/byteorder#f8e7685b3a81c52f5448fd77fb4e0535bc92f880\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"cargo_metadata\"\n-version = \"0.2.1\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -48,7 +37,7 @@ name = \"compiletest_rs\"\n version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -59,40 +48,31 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.3.5\"\n+version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"itoa\"\n version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"kernel32-sys\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"lazy_static\"\n version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.22\"\n+version = \"0.2.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"log\"\n-version = \"0.3.7\"\n+version = \"0.3.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -105,42 +85,35 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"0.1.11\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n-name = \"memchr\"\n-version = \"1.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+name = \"miri\"\n+version = \"0.1.0\"\n dependencies = [\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiletest_rs 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_miri 0.1.0\",\n ]\n \n [[package]]\n name = \"num-traits\"\n-version = \"0.1.37\"\n+version = \"0.1.40\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"quote\"\n version = \"0.3.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"regex\"\n-version = \"0.1.80\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"regex\"\n version = \"0.2.2\"\n@@ -153,11 +126,6 @@ dependencies = [\n  \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"regex-syntax\"\n-version = \"0.3.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"regex-syntax\"\n version = \"0.4.1\"\n@@ -170,22 +138,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.2\"\n+version = \"1.0.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.2\"\n+version = \"1.0.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive_internals 0.15.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_derive_internals\"\n-version = \"0.15.0\"\n+version = \"0.15.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -199,8 +167,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -221,23 +189,6 @@ dependencies = [\n  \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"thread-id\"\n-version = \"2.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"thread_local\"\n-version = \"0.2.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"thread_local\"\n version = \"0.3.4\"\n@@ -260,11 +211,6 @@ dependencies = [\n  \"void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"utf8-ranges\"\n-version = \"0.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"utf8-ranges\"\n version = \"1.0.0\"\n@@ -275,52 +221,32 @@ name = \"void\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"winapi\"\n-version = \"0.2.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi-build\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [metadata]\n-\"checksum aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca972c2ea5f742bfce5687b9aef75506a764f61d37f8f649047846a9686ddb66\"\n \"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n-\"checksum byteorder 1.0.0 (git+https://github.com/BurntSushi/byteorder)\" = \"<none>\"\n-\"checksum cargo_metadata 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d84cb53c78e573aa126a4b9f963fdb2629f8183b26e235da08bb36dc7381162\"\n+\"checksum byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff81738b726f5d099632ceaffe7fb65b90212e8dce59d518729e7e8634032d3d\"\n+\"checksum cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be1057b8462184f634c3a208ee35b0f935cfd94b694b26deadccd98732088d7b\"\n \"checksum compiletest_rs 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"617b23d0ed4f57b3bcff6b5fe0a78f0010f1efb636298317665a960b6dbc0533\"\n \"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n-\"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n+\"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n \"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n-\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n-\"checksum libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"babb8281da88cba992fa1f4ddec7d63ed96280a1a53ec9b919fd37b53d71e502\"\n-\"checksum log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5141eca02775a762cc6cd564d8d2c50f67c0ea3a372cbf1c51592b3e029e10ad\"\n+\"checksum libc 0.2.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb7b49972ee23d8aa1026c365a5b440ba08e35075f18c459980c7395c221ec48\"\n+\"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n \"checksum log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d382732ea0fbc09790c4899db3255bdea0fc78b54bf234bd18a63bb603915b6\"\n-\"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n-\"checksum num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1cbfa3781f3fe73dc05321bed52a06d2d491eaa764c52335cf4399f046ece99\"\n+\"checksum num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99843c856d68d8b4313b03a17e33c4bb42ae8f6610ea81b28abe076ac721b9b0\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n-\"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n \"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n-\"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n-\"checksum serde 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b46a59dd63931010fdb1d88538513f3279090d88b5c22ef4fe8440cfffcc6e3\"\n-\"checksum serde_derive 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6c06b68790963518008b8ae0152d48be4bbbe77015d2c717f6282eea1824be9a\"\n-\"checksum serde_derive_internals 0.15.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"021c338d22c7e30f957a6ab7e388cb6098499dda9fd4ba1661ee074ca7a180d1\"\n+\"checksum serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7726f29ddf9731b17ff113c461e362c381d9d69433f79de4f3dd572488823e9\"\n+\"checksum serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf823e706be268e73e7747b147aa31c8f633ab4ba31f115efb57e5047c3a76dd\"\n+\"checksum serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37aee4e0da52d801acfbc0cc219eb1eda7142112339726e427926a6f6ee65d3a\"\n \"checksum serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48b04779552e92037212c3615370f6bd57a40ebba7f20e554ff9f55e41a69a7b\"\n \"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n \"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n-\"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n-\"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\"\n \"checksum thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1697c4b57aeeb7a536b647165a2825faddffb1d3bad386d507709bd51a90bb14\"\n \"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\"\n \"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56\"\n-\"checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f\"\n \"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n-\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n-\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "e14937391743071fe71b1fb0bfa1aced38a98eae", "filename": "Cargo.toml", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -0,0 +1,37 @@\n+[package]\n+authors = [\"Scott Olson <scott@solson.me>\"]\n+description = \"An experimental interpreter for Rust MIR.\"\n+license = \"MIT/Apache-2.0\"\n+name = \"miri\"\n+repository = \"https://github.com/solson/miri\"\n+version = \"0.1.0\"\n+\n+[[bin]]\n+doc = false\n+name = \"miri\"\n+test = false\n+path = \"miri/bin/miri.rs\"\n+\n+[[bin]]\n+doc = false\n+name = \"cargo-miri\"\n+test = false\n+path = \"miri/bin/cargo-miri.rs\"\n+\n+[lib]\n+test = false\n+path = \"miri/lib.rs\"\n+\n+[dependencies]\n+byteorder = { version = \"1.1\", features = [\"i128\"]}\n+env_logger = \"0.4.3\"\n+log = \"0.3.6\"\n+log_settings = \"0.1.1\"\n+cargo_metadata = \"0.2\"\n+rustc_miri = { path = \"src/librustc_mir\" }\n+\n+[dev-dependencies]\n+compiletest_rs = \"0.2.6\"\n+\n+[workspace]\n+exclude = [\"xargo\", \"cargo-miri-test\"]"}, {"sha": "6eff6650fa9c41b2cab4bb0730a6462f8611a2b4", "filename": "miri/bin/cargo-miri.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fbin%2Fcargo-miri.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "previous_filename": "src/librustc_mir/interpret/bin/cargo-miri.rs"}, {"sha": "01a4a8656b40fd2c57d69e74d933a02796c6e498", "filename": "miri/bin/miri.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fbin%2Fmiri.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "previous_filename": "src/librustc_mir/interpret/bin/miri.rs"}, {"sha": "bef37c57981e20fd5aba5b343800176e160ffd29", "filename": "miri/fn_call.rs", "status": "added", "additions": 567, "deletions": 0, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -0,0 +1,567 @@\n+use rustc::ty::{self, Ty};\n+use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc::mir;\n+use syntax::attr;\n+use syntax::abi::Abi;\n+use syntax::codemap::Span;\n+\n+use std::mem;\n+\n+use rustc_miri::interpret::*;\n+\n+use super::{\n+    TlsKey,\n+    EvalContext,\n+};\n+\n+use tls::MemoryExt;\n+\n+use super::memory::Kind;\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn call_c_abi(\n+        &mut self,\n+        def_id: DefId,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        dest_block: mir::BasicBlock,\n+    ) -> EvalResult<'tcx>;\n+\n+    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>>;\n+\n+    fn call_missing_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx>;\n+\n+    fn eval_fn_call(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        span: Span,\n+        sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool>;\n+}\n+\n+impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n+    fn eval_fn_call(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        span: Span,\n+        sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        trace!(\"eval_fn_call: {:#?}, {:#?}\", instance, destination);\n+\n+        let mir = match self.load_mir(instance.def) {\n+            Ok(mir) => mir,\n+            Err(EvalError::NoMirFor(path)) => {\n+                self.call_missing_fn(instance, destination, arg_operands, sig, path)?;\n+                return Ok(true);\n+            },\n+            Err(other) => return Err(other),\n+        };\n+        \n+        let (return_lvalue, return_to_block) = match destination {\n+            Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n+            None => (Lvalue::undef(), StackPopCleanup::None),\n+        };\n+\n+        self.push_stack_frame(\n+            instance,\n+            span,\n+            mir,\n+            return_lvalue,\n+            return_to_block,\n+        )?;\n+\n+        Ok(false)\n+    }\n+\n+    fn call_c_abi(\n+        &mut self,\n+        def_id: DefId,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        dest_block: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        let name = self.tcx.item_name(def_id);\n+        let attrs = self.tcx.get_attrs(def_id);\n+        let link_name = attr::first_attr_value_str_by_name(&attrs, \"link_name\")\n+            .unwrap_or(name)\n+            .as_str();\n+\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        let usize = self.tcx.types.usize;\n+\n+        match &link_name[..] {\n+            \"malloc\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                if size == 0 {\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    let align = self.memory.pointer_size();\n+                    let ptr = self.memory.allocate(size, align, Kind::C.into())?;\n+                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                }\n+            }\n+\n+            \"free\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                if !ptr.is_null()? {\n+                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C.into())?;\n+                }\n+            }\n+\n+            \"syscall\" => {\n+                match self.value_to_primval(args[0], usize)?.to_u64()? {\n+                    511 => return Err(EvalError::Unimplemented(\"miri does not support random number generators\".to_owned())),\n+                    id => return Err(EvalError::Unimplemented(format!(\"miri does not support syscall id {}\", id))),\n+                }\n+            }\n+\n+            \"dlsym\" => {\n+                let _handle = args[0].into_ptr(&mut self.memory)?;\n+                let symbol = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let symbol_name = self.memory.read_c_str(symbol)?;\n+                let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n+                let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n+                return Err(EvalError::Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n+            }\n+\n+            \"__rust_maybe_catch_panic\" => {\n+                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n+                // We abort on panic, so not much is going on here, but we still have to call the closure\n+                let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+                let f = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let data = args[1].into_ptr(&mut self.memory)?;\n+                let f_instance = self.memory.get_fn(f)?;\n+                self.write_null(dest, dest_ty)?;\n+\n+                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n+                // and of course eval_main.\n+                let mir = self.load_mir(f_instance.def)?;\n+                self.push_stack_frame(\n+                    f_instance,\n+                    mir.span,\n+                    mir,\n+                    Lvalue::undef(),\n+                    StackPopCleanup::Goto(dest_block),\n+                )?;\n+\n+                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n+                let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n+\n+                // We ourselves return 0\n+                self.write_null(dest, dest_ty)?;\n+\n+                // Don't fall through\n+                return Ok(());\n+            }\n+\n+            \"__rust_start_panic\" => {\n+                return Err(EvalError::Panic);\n+            }\n+\n+            \"memcmp\" => {\n+                let left = args[0].into_ptr(&mut self.memory)?;\n+                let right = args[1].into_ptr(&mut self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+\n+                let result = {\n+                    let left_bytes = self.memory.read_bytes(left, n)?;\n+                    let right_bytes = self.memory.read_bytes(right, n)?;\n+\n+                    use std::cmp::Ordering::*;\n+                    match left_bytes.cmp(right_bytes) {\n+                        Less => -1i8,\n+                        Equal => 0,\n+                        Greater => 1,\n+                    }\n+                };\n+\n+                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n+            }\n+\n+            \"memrchr\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n+                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n+                } else {\n+                    self.write_null(dest, dest_ty)?;\n+                }\n+            }\n+\n+            \"memchr\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n+                    let new_ptr = ptr.offset(idx as u64, &self)?;\n+                    self.write_ptr(dest, new_ptr, dest_ty)?;\n+                } else {\n+                    self.write_null(dest, dest_ty)?;\n+                }\n+            }\n+\n+            \"getenv\" => {\n+                let result = {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let name = self.memory.read_c_str(name_ptr)?;\n+                    match self.machine_data.env_vars.get(name) {\n+                        Some(&var) => PrimVal::Ptr(var),\n+                        None => PrimVal::Bytes(0),\n+                    }\n+                };\n+                self.write_primval(dest, result, dest_ty)?;\n+            }\n+\n+            \"unsetenv\" => {\n+                let mut success = None;\n+                {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    if !name_ptr.is_null()? {\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        if !name.is_empty() && !name.contains(&b'=') {\n+                            success = Some(self.machine_data.env_vars.remove(name));\n+                        }\n+                    }\n+                }\n+                if let Some(old) = success {\n+                    if let Some(var) = old {\n+                        self.memory.deallocate(var, None, Kind::Env.into())?;\n+                    }\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                }\n+            }\n+\n+            \"setenv\" => {\n+                let mut new = None;\n+                {\n+                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    let value_ptr = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let value = self.memory.read_c_str(value_ptr)?;\n+                    if !name_ptr.is_null()? {\n+                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n+                        if !name.is_empty() && !name.contains(&b'=') {\n+                            new = Some((name.to_owned(), value.to_owned()));\n+                        }\n+                    }\n+                }\n+                if let Some((name, value)) = new {\n+                    // +1 for the null terminator\n+                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env.into())?;\n+                    self.memory.write_bytes(value_copy.into(), &value)?;\n+                    let trailing_zero_ptr = value_copy.offset(value.len() as u64, &self)?.into();\n+                    self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n+                    if let Some(var) = self.machine_data.env_vars.insert(name.to_owned(), value_copy) {\n+                        self.memory.deallocate(var, None, Kind::Env.into())?;\n+                    }\n+                    self.write_null(dest, dest_ty)?;\n+                } else {\n+                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                }\n+            }\n+\n+            \"write\" => {\n+                let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let buf = args[1].into_ptr(&mut self.memory)?;\n+                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n+                let result = if fd == 1 || fd == 2 { // stdout/stderr\n+                    use std::io::{self, Write};\n+                \n+                    let buf_cont = self.memory.read_bytes(buf, n)?;\n+                    let res = if fd == 1 { io::stdout().write(buf_cont) } else { io::stderr().write(buf_cont) };\n+                    match res { Ok(n) => n as isize, Err(_) => -1 }\n+                } else {\n+                    info!(\"Ignored output to FD {}\", fd);\n+                    n as isize // pretend it all went well\n+                }; // now result is the value we return back to the program\n+                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n+            }\n+\n+            \"strlen\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let n = self.memory.read_c_str(ptr)?.len();\n+                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n+            }\n+\n+            // Some things needed for sys::thread initialization to go through\n+            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+            }\n+\n+            \"sysconf\" => {\n+                let name = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                trace!(\"sysconf() called with name {}\", name);\n+                // cache the sysconf integers via miri's global cache\n+                let paths = &[\n+                    (&[\"libc\", \"_SC_PAGESIZE\"], PrimVal::Bytes(4096)),\n+                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], PrimVal::from_i128(-1)),\n+                ];\n+                let mut result = None;\n+                for &(path, path_value) in paths {\n+                    if let Ok(instance) = self.resolve_path(path) {\n+                        let cid = GlobalId { instance, promoted: None };\n+                        // compute global if not cached\n+                        let val = match self.globals.get(&cid).map(|glob| glob.value) {\n+                            Some(value) => self.value_to_primval(value, usize)?.to_u64()?,\n+                            None => eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n+                        };\n+                        if val == name {\n+                            result = Some(path_value);\n+                            break;\n+                        }\n+                    }\n+                }\n+                if let Some(result) = result {\n+                    self.write_primval(dest, result, dest_ty)?;\n+                } else {\n+                    return Err(EvalError::Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)));\n+                }\n+            }\n+\n+            // Hook pthread calls that go to the thread-local storage memory subsystem\n+            \"pthread_key_create\" => {\n+                let key_ptr = args[0].into_ptr(&mut self.memory)?;\n+\n+                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n+                let dtor = match args[1].into_ptr(&mut self.memory)?.into_inner_primval() {\n+                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n+                    PrimVal::Bytes(0) => None,\n+                    PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n+                    PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n+                };\n+\n+                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n+                let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                                   .ok_or(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                let key_size = {\n+                    let layout = self.type_layout(key_type)?;\n+                    layout.size(&self.tcx.data_layout)\n+                };\n+\n+                // Create key and write it into the memory where key_ptr wants it\n+                let key = self.memory.create_tls_key(dtor) as u128;\n+                if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n+                    return Err(EvalError::OutOfTls);\n+                }\n+                // TODO: Does this need checking for alignment?\n+                self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n+\n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+            \"pthread_key_delete\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                self.memory.delete_tls_key(key)?;\n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+            \"pthread_getspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let ptr = self.memory.load_tls(key)?;\n+                self.write_ptr(dest, ptr, dest_ty)?;\n+            }\n+            \"pthread_setspecific\" => {\n+                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n+                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let new_ptr = args[1].into_ptr(&mut self.memory)?;\n+                self.memory.store_tls(key, new_ptr)?;\n+                \n+                // Return success (0)\n+                self.write_null(dest, dest_ty)?;\n+            }\n+\n+            // Stub out all the other pthread calls to just return 0\n+            link_name if link_name.starts_with(\"pthread_\") => {\n+                warn!(\"ignoring C ABI call: {}\", link_name);\n+                self.write_null(dest, dest_ty)?;\n+            },\n+\n+            _ => {\n+                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n+            }\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n+        Ok(())\n+    }\n+\n+    /// Get an instance for a path.\n+    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+        let cstore = &self.tcx.sess.cstore;\n+\n+        let crates = cstore.crates();\n+        crates.iter()\n+            .find(|&&krate| cstore.crate_name(krate) == path[0])\n+            .and_then(|krate| {\n+                let krate = DefId {\n+                    krate: *krate,\n+                    index: CRATE_DEF_INDEX,\n+                };\n+                let mut items = cstore.item_children(krate, self.tcx.sess);\n+                let mut path_it = path.iter().skip(1).peekable();\n+\n+                while let Some(segment) = path_it.next() {\n+                    for item in &mem::replace(&mut items, vec![]) {\n+                        if item.ident.name == *segment {\n+                            if path_it.peek().is_none() {\n+                                return Some(ty::Instance::mono(self.tcx, item.def.def_id()));\n+                            }\n+\n+                            items = cstore.item_children(item.def.def_id(), self.tcx.sess);\n+                            break;\n+                        }\n+                    }\n+                }\n+                None\n+            })\n+            .ok_or_else(|| {\n+                let path = path.iter()\n+                    .map(|&s| s.to_owned())\n+                    .collect();\n+                EvalError::PathNotFound(path)\n+            })\n+    }\n+\n+    fn call_missing_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        sig: ty::FnSig<'tcx>,\n+        path: String,\n+    ) -> EvalResult<'tcx> {\n+        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n+        match &path[..] {\n+            \"std::panicking::rust_panic_with_hook\" |\n+            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n+            _ => {},\n+        }\n+\n+        let dest_ty = sig.output();\n+        let (dest, dest_block) = destination.ok_or_else(|| EvalError::NoMirFor(path.clone()))?;\n+\n+        if sig.abi == Abi::C {\n+            // An external C function\n+            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n+            // unify these two mechanisms for \"hooking into missing functions\".\n+            self.call_c_abi(instance.def_id(), arg_operands, dest, dest_ty, dest_block)?;\n+            return Ok(());\n+        }\n+\n+        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n+            .map(|arg| self.eval_operand(arg))\n+            .collect();\n+        let args = args_res?;\n+\n+        let usize = self.tcx.types.usize;\n+    \n+        match &path[..] {\n+            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n+            \"alloc::heap::::__rust_alloc\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align, Kind::Rust.into())?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_alloc_zeroed\" => {\n+                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                if size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                let ptr = self.memory.allocate(size, align, Kind::Rust.into())?;\n+                self.memory.write_repeat(ptr.into(), 0, size)?;\n+                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+            }\n+            \"alloc::heap::::__rust_dealloc\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                if old_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n+                }\n+                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust.into())?;\n+            }\n+            \"alloc::heap::::__rust_realloc\" => {\n+                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n+                let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n+                if old_size == 0 || new_size == 0 {\n+                    return Err(EvalError::HeapAllocZeroBytes);\n+                }\n+                if !old_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(old_align));\n+                }\n+                if !new_align.is_power_of_two() {\n+                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n+                }\n+                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust.into())?;\n+                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+            }\n+\n+            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n+            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n+            \"std::io::_print\" => {\n+                trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n+            }\n+            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n+            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n+            \"std::panicking::panicking\" |\n+            \"std::rt::panicking\" => {\n+                // we abort on panic -> `std::rt::panicking` always returns false\n+                let bool = self.tcx.types.bool;\n+                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n+            }\n+            _ => return Err(EvalError::NoMirFor(path)),\n+        }\n+\n+        // Since we pushed no stack frame, the main loop will act\n+        // as if the call just completed and it's returning to the\n+        // current frame.\n+        self.dump_local(dest);\n+        self.goto_block(dest_block);\n+        return Ok(());\n+    }\n+}"}, {"sha": "add6558bcc4440180e72b3e96c9db34dcee99c29", "filename": "miri/helpers.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fhelpers.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -0,0 +1,69 @@\n+use rustc_miri::interpret::{\n+    Pointer,\n+    EvalResult, EvalError,\n+    PrimVal,\n+    EvalContext,\n+};\n+\n+use rustc::ty::Ty;\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn wrapping_pointer_offset(\n+        &self,\n+        ptr: Pointer,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Pointer>;\n+\n+    fn pointer_offset(\n+        &self,\n+        ptr: Pointer,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Pointer>;\n+}\n+\n+impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n+    fn wrapping_pointer_offset(\n+        &self,\n+        ptr: Pointer,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Pointer> {\n+        // FIXME: assuming here that type size is < i64::max_value()\n+        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        let offset = offset.overflowing_mul(pointee_size).0;\n+        ptr.wrapping_signed_offset(offset, self)\n+    }\n+\n+    fn pointer_offset(\n+        &self,\n+        ptr: Pointer,\n+        pointee_ty: Ty<'tcx>,\n+        offset: i64,\n+    ) -> EvalResult<'tcx, Pointer> {\n+        // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n+        // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n+        // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n+        // allocation.\n+\n+        if ptr.is_null()? { // NULL pointers must only be offset by 0\n+            return if offset == 0 { Ok(ptr) } else { Err(EvalError::InvalidNullPointerUsage) };\n+        }\n+        // FIXME: assuming here that type size is < i64::max_value()\n+        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        return if let Some(offset) = offset.checked_mul(pointee_size) {\n+            let ptr = ptr.signed_offset(offset, self)?;\n+            // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n+            if let PrimVal::Ptr(ptr) = ptr.into_inner_primval() {\n+                self.memory.check_bounds(ptr, false)?;\n+            } else if ptr.is_null()? {\n+                // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n+                return Err(EvalError::InvalidNullPointerUsage);\n+            }\n+            Ok(ptr)\n+        } else {\n+            Err(EvalError::OverflowingMath)\n+        }\n+    }\n+}"}, {"sha": "73caf64dbde888cb1bd73e938ed00eca790b2898", "filename": "miri/intrinsic.rs", "status": "renamed", "additions": 25, "deletions": 101, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -1,17 +1,32 @@\n use rustc::mir;\n use rustc::traits::Reveal;\n-use rustc::ty::layout::{Layout, Size, Align};\n-use rustc::ty::subst::Substs;\n+use rustc::ty::layout::Layout;\n use rustc::ty::{self, Ty};\n \n-use error::{EvalError, EvalResult};\n-use eval_context::EvalContext;\n-use lvalue::{Lvalue, LvalueExtra};\n-use value::{PrimVal, PrimValKind, Value, Pointer};\n-use memory::HasMemory;\n+use rustc_miri::interpret::{\n+    EvalError, EvalResult,\n+    Lvalue, LvalueExtra,\n+    PrimVal, PrimValKind, Value, Pointer,\n+    HasMemory,\n+    EvalContext,\n+};\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub(super) fn call_intrinsic(\n+use helpers::EvalContextExt as HelperEvalContextExt;\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn call_intrinsic(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: Ty<'tcx>,\n+        dest_layout: &'tcx Layout,\n+        target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx>;\n+}\n+\n+impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n+    fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[mir::Operand<'tcx>],\n@@ -484,97 +499,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // current frame.\n         Ok(())\n     }\n-\n-    pub fn size_and_align_of_dst(\n-        &mut self,\n-        ty: ty::Ty<'tcx>,\n-        value: Value,\n-    ) -> EvalResult<'tcx, (u64, u64)> {\n-        if let Some(size) = self.type_size(ty)? {\n-            Ok((size as u64, self.type_align(ty)? as u64))\n-        } else {\n-            match ty.sty {\n-                ty::TyAdt(def, substs) => {\n-                    // First get the size of all statically known fields.\n-                    // Don't use type_of::sizing_type_of because that expects t to be sized,\n-                    // and it also rounds up to alignment, which we want to avoid,\n-                    // as the unsized field's alignment could be smaller.\n-                    assert!(!ty.is_simd());\n-                    let layout = self.type_layout(ty)?;\n-                    debug!(\"DST {} layout: {:?}\", ty, layout);\n-\n-                    let (sized_size, sized_align) = match *layout {\n-                        ty::layout::Layout::Univariant { ref variant, .. } => {\n-                            (variant.offsets.last().map_or(0, |o| o.bytes()), variant.align)\n-                        }\n-                        _ => {\n-                            bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n-                                 ty, layout);\n-                        }\n-                    };\n-                    debug!(\"DST {} statically sized prefix size: {} align: {:?}\",\n-                           ty, sized_size, sized_align);\n-\n-                    // Recurse to get the size of the dynamically sized field (must be\n-                    // the last field).\n-                    let last_field = def.struct_variant().fields.last().unwrap();\n-                    let field_ty = self.field_ty(substs, last_field);\n-                    let (unsized_size, unsized_align) = self.size_and_align_of_dst(field_ty, value)?;\n-\n-                    // FIXME (#26403, #27023): We should be adding padding\n-                    // to `sized_size` (to accommodate the `unsized_align`\n-                    // required of the unsized field that follows) before\n-                    // summing it with `sized_size`. (Note that since #26403\n-                    // is unfixed, we do not yet add the necessary padding\n-                    // here. But this is where the add would go.)\n-\n-                    // Return the sum of sizes and max of aligns.\n-                    let size = sized_size + unsized_size;\n-\n-                    // Choose max of two known alignments (combined value must\n-                    // be aligned according to more restrictive of the two).\n-                    let align = sized_align.max(Align::from_bytes(unsized_align, unsized_align).unwrap());\n-\n-                    // Issue #27023: must add any necessary padding to `size`\n-                    // (to make it a multiple of `align`) before returning it.\n-                    //\n-                    // Namely, the returned size should be, in C notation:\n-                    //\n-                    //   `size + ((size & (align-1)) ? align : 0)`\n-                    //\n-                    // emulated via the semi-standard fast bit trick:\n-                    //\n-                    //   `(size + (align-1)) & -align`\n-\n-                    let size = Size::from_bytes(size).abi_align(align).bytes();\n-                    Ok((size, align.abi()))\n-                }\n-                ty::TyDynamic(..) => {\n-                    let (_, vtable) = value.into_ptr_vtable_pair(&self.memory)?;\n-                    // the second entry in the vtable is the dynamic size of the object.\n-                    self.read_size_and_align_from_vtable(vtable)\n-                }\n-\n-                ty::TySlice(_) | ty::TyStr => {\n-                    let elem_ty = ty.sequence_element_type(self.tcx);\n-                    let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as u64;\n-                    let (_, len) = value.into_slice(&self.memory)?;\n-                    let align = self.type_align(elem_ty)?;\n-                    Ok((len * elem_size, align as u64))\n-                }\n-\n-                _ => bug!(\"size_of_val::<{:?}>\", ty),\n-            }\n-        }\n-    }\n-    /// Returns the normalized type of a struct field\n-    fn field_ty(\n-        &self,\n-        param_substs: &Substs<'tcx>,\n-        f: &ty::FieldDef,\n-    ) -> ty::Ty<'tcx> {\n-        self.tcx.normalize_associated_type(&f.ty(self.tcx, param_substs))\n-    }\n }\n \n fn numeric_intrinsic<'tcx>(\n@@ -584,7 +508,7 @@ fn numeric_intrinsic<'tcx>(\n ) -> EvalResult<'tcx, PrimVal> {\n     macro_rules! integer_intrinsic {\n         ($method:ident) => ({\n-            use value::PrimValKind::*;\n+            use rustc_miri::interpret::PrimValKind::*;\n             let result_bytes = match kind {\n                 I8 => (bytes as i8).$method() as u128,\n                 U8 => (bytes as u8).$method() as u128,", "previous_filename": "src/librustc_mir/interpret/terminator/intrinsic.rs"}, {"sha": "8f223851b357f1beb831088c3c1f8310caeb8de7", "filename": "miri/lib.rs", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -0,0 +1,224 @@\n+#![feature(\n+    i128_type,\n+    rustc_private,\n+)]\n+\n+// From rustc.\n+#[macro_use]\n+extern crate log;\n+extern crate log_settings;\n+#[macro_use]\n+extern crate rustc;\n+extern crate rustc_const_math;\n+extern crate rustc_data_structures;\n+extern crate syntax;\n+\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::layout::Layout;\n+use rustc::hir::def_id::DefId;\n+use rustc::mir;\n+\n+use syntax::codemap::Span;\n+\n+use std::collections::{\n+    HashMap,\n+    BTreeMap,\n+};\n+\n+extern crate rustc_miri;\n+pub use rustc_miri::interpret::*;\n+\n+mod fn_call;\n+mod operator;\n+mod intrinsic;\n+mod helpers;\n+mod memory;\n+mod tls;\n+\n+use fn_call::EvalContextExt as MissingFnsEvalContextExt;\n+use operator::EvalContextExt as OperatorEvalContextExt;\n+use intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n+use tls::EvalContextExt as TlsEvalContextExt;\n+\n+pub fn eval_main<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    main_id: DefId,\n+    start_wrapper: Option<DefId>,\n+    limits: ResourceLimits,\n+) {\n+    fn run_main<'a, 'tcx: 'a>(\n+        ecx: &mut rustc_miri::interpret::EvalContext<'a, 'tcx, Evaluator>,\n+        main_id: DefId,\n+        start_wrapper: Option<DefId>,\n+    ) -> EvalResult<'tcx> {\n+        let main_instance = ty::Instance::mono(ecx.tcx, main_id);\n+        let main_mir = ecx.load_mir(main_instance.def)?;\n+        let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n+\n+        if !main_mir.return_ty.is_nil() || main_mir.arg_count != 0 {\n+            return Err(EvalError::Unimplemented(\"miri does not support main functions without `fn()` type signatures\".to_owned()));\n+        }\n+\n+        if let Some(start_id) = start_wrapper {\n+            let start_instance = ty::Instance::mono(ecx.tcx, start_id);\n+            let start_mir = ecx.load_mir(start_instance.def)?;\n+\n+            if start_mir.arg_count != 3 {\n+                return Err(EvalError::AbiViolation(format!(\"'start' lang item should have three arguments, but has {}\", start_mir.arg_count)));\n+            }\n+\n+            // Return value\n+            let size = ecx.tcx.data_layout.pointer_size.bytes();\n+            let align = ecx.tcx.data_layout.pointer_align.abi();\n+            let ret_ptr = ecx.memory_mut().allocate(size, align, Kind::Stack)?;\n+            cleanup_ptr = Some(ret_ptr);\n+\n+            // Push our stack frame\n+            ecx.push_stack_frame(\n+                start_instance,\n+                start_mir.span,\n+                start_mir,\n+                Lvalue::from_ptr(ret_ptr),\n+                StackPopCleanup::None,\n+            )?;\n+\n+            let mut args = ecx.frame().mir.args_iter();\n+\n+            // First argument: pointer to main()\n+            let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let main_ty = main_instance.def.def_ty(ecx.tcx);\n+            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx));\n+            ecx.write_value(Value::ByVal(PrimVal::Ptr(main_ptr)), dest, main_ptr_ty)?;\n+\n+            // Second argument (argc): 0\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let ty = ecx.tcx.types.isize;\n+            ecx.write_null(dest, ty)?;\n+\n+            // Third argument (argv): 0\n+            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n+            let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n+            ecx.write_null(dest, ty)?;\n+        } else {\n+            ecx.push_stack_frame(\n+                main_instance,\n+                main_mir.span,\n+                main_mir,\n+                Lvalue::undef(),\n+                StackPopCleanup::None,\n+            )?;\n+        }\n+\n+        while ecx.step()? {}\n+        ecx.run_tls_dtors()?;\n+        if let Some(cleanup_ptr) = cleanup_ptr {\n+            ecx.memory_mut().deallocate(cleanup_ptr, None, Kind::Stack)?;\n+        }\n+        Ok(())\n+    }\n+\n+    let mut ecx = EvalContext::new(tcx, limits, Default::default(), Default::default());\n+    match run_main(&mut ecx, main_id, start_wrapper) {\n+        Ok(()) => {\n+            let leaks = ecx.memory().leak_report();\n+            if leaks != 0 {\n+                tcx.sess.err(\"the evaluated program leaked memory\");\n+            }\n+        }\n+        Err(e) => {\n+            ecx.report(&e);\n+        }\n+    }\n+}\n+\n+struct Evaluator;\n+#[derive(Default)]\n+struct EvaluatorData {\n+    /// Environment variables set by `setenv`\n+    /// Miri does not expose env vars from the host to the emulated program\n+    pub(crate) env_vars: HashMap<Vec<u8>, MemoryPointer>,\n+}\n+\n+pub type TlsKey = usize;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct TlsEntry<'tcx> {\n+    data: Pointer, // Will eventually become a map from thread IDs to `Pointer`s, if we ever support more than one thread.\n+    dtor: Option<ty::Instance<'tcx>>,\n+}\n+\n+#[derive(Default)]\n+struct MemoryData<'tcx> {\n+    /// The Key to use for the next thread-local allocation.\n+    next_thread_local: TlsKey,\n+\n+    /// pthreads-style thread-local storage.\n+    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n+}\n+\n+impl<'tcx> Machine<'tcx> for Evaluator {\n+    type Data = EvaluatorData;\n+    type MemoryData = MemoryData<'tcx>;\n+    type MemoryKinds = memory::Kind;\n+\n+    /// Returns Ok() when the function was handled, fail otherwise\n+    fn eval_fn_call<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        span: Span,\n+        sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        ecx.eval_fn_call(instance, destination, arg_operands, span, sig)\n+    }\n+\n+    fn call_intrinsic<'a>(\n+        ecx: &mut rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: ty::Ty<'tcx>,\n+        dest_layout: &'tcx Layout,\n+        target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        ecx.call_intrinsic(instance, args, dest, dest_ty, dest_layout, target)\n+    }\n+\n+    fn try_ptr_op<'a>(\n+        ecx: &rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n+        bin_op: mir::BinOp,\n+        left: PrimVal,\n+        left_ty: ty::Ty<'tcx>,\n+        right: PrimVal,\n+        right_ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n+        ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n+    }\n+\n+    fn mark_static_initialized(m: memory::Kind) -> EvalResult<'tcx> {\n+        use memory::Kind::*;\n+        match m {\n+            // FIXME: This could be allowed, but not for env vars set during miri execution\n+            Env => Err(EvalError::Unimplemented(\"statics can't refer to env vars\".to_owned())),\n+            _ => Ok(()),\n+        }\n+    }\n+\n+    fn box_alloc<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal> {\n+        // FIXME: call the `exchange_malloc` lang item if available\n+        let size = ecx.type_size(ty)?.expect(\"box only works with sized types\");\n+        let align = ecx.type_align(ty)?;\n+        if size == 0 {\n+            Ok(PrimVal::Bytes(align.into()))\n+        } else {\n+            ecx.memory\n+                .allocate(size, align, Kind::Machine(memory::Kind::Rust))\n+                .map(PrimVal::Ptr)\n+        }\n+    }\n+}"}, {"sha": "55e6026280ca5cd2a3805093203f86103512e63b", "filename": "miri/memory.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fmemory.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -0,0 +1,16 @@\n+\n+#[derive(Debug, PartialEq, Copy, Clone)]\n+pub enum Kind {\n+    /// Error if deallocated any other way than `rust_deallocate`\n+    Rust,\n+    /// Error if deallocated any other way than `free`\n+    C,\n+    /// Part of env var emulation\n+    Env,\n+}\n+\n+impl Into<::rustc_miri::interpret::Kind<Kind>> for Kind {\n+    fn into(self) -> ::rustc_miri::interpret::Kind<Kind> {\n+        ::rustc_miri::interpret::Kind::Machine(self)\n+    }\n+}"}, {"sha": "a01ba25cd75ea89e6fef24f7a5a42d8689e8b352", "filename": "miri/operator.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Foperator.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -0,0 +1,154 @@\n+use rustc::ty;\n+use rustc::mir;\n+\n+use rustc_miri::interpret::*;\n+\n+use helpers::EvalContextExt as HelperEvalContextExt;\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn ptr_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: PrimVal,\n+        left_ty: ty::Ty<'tcx>,\n+        right: PrimVal,\n+        right_ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n+\n+    fn ptr_int_arithmetic(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: MemoryPointer,\n+        right: i128,\n+        signed: bool,\n+    ) -> EvalResult<'tcx, (PrimVal, bool)>;\n+}\n+\n+impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator> {\n+    fn ptr_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: PrimVal,\n+        left_ty: ty::Ty<'tcx>,\n+        right: PrimVal,\n+        right_ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n+        use rustc_miri::interpret::PrimValKind::*;\n+        use rustc::mir::BinOp::*;\n+        let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n+        let isize = PrimValKind::from_int_size(self.memory.pointer_size());\n+        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n+        let right_kind = self.ty_to_primval_kind(right_ty)?;\n+        match bin_op {\n+            Offset if left_kind == Ptr && right_kind == usize => {\n+                let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n+                let ptr = self.pointer_offset(left.into(), pointee_ty, right.to_bytes()? as i64)?;\n+                Ok(Some((ptr.into_inner_primval(), false)))\n+            },\n+            // These work on anything\n+            Eq if left_kind == right_kind => {\n+                let result = match (left, right) {\n+                    (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left == right,\n+                    (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left == right,\n+                    (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n+                    _ => false,\n+                };\n+                Ok(Some((PrimVal::from_bool(result), false)))\n+            }\n+            Ne if left_kind == right_kind => {\n+                let result = match (left, right) {\n+                    (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left != right,\n+                    (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left != right,\n+                    (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n+                    _ => true,\n+                };\n+                Ok(Some((PrimVal::from_bool(result), false)))\n+            }\n+            // These need both pointers to be in the same allocation\n+            Lt | Le | Gt | Ge | Sub\n+            if left_kind == right_kind\n+            && (left_kind == Ptr || left_kind == usize || left_kind == isize)\n+            && left.is_ptr() && right.is_ptr() => {\n+                let left = left.to_ptr()?;\n+                let right = right.to_ptr()?;\n+                if left.alloc_id == right.alloc_id {\n+                    let res = match bin_op {\n+                        Lt => left.offset < right.offset,\n+                        Le => left.offset <= right.offset,\n+                        Gt => left.offset > right.offset,\n+                        Ge => left.offset >= right.offset,\n+                        Sub => return self.binary_op(\n+                            Sub,\n+                            PrimVal::Bytes(left.offset as u128),\n+                            self.tcx.types.usize,\n+                            PrimVal::Bytes(right.offset as u128),\n+                            self.tcx.types.usize,\n+                        ).map(Some),\n+                        _ => bug!(\"We already established it has to be one of these operators.\"),\n+                    };\n+                    Ok(Some((PrimVal::from_bool(res), false)))\n+                } else {\n+                    // Both are pointers, but from different allocations.\n+                    Err(EvalError::InvalidPointerMath)\n+                }\n+            }\n+            // These work if one operand is a pointer, the other an integer\n+            Add | BitAnd | Sub\n+            if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n+            && left.is_ptr() && right.is_bytes() => {\n+                // Cast to i128 is fine as we checked the kind to be ptr-sized\n+                self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize).map(Some)\n+            }\n+            Add | BitAnd\n+            if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n+            && left.is_bytes() && right.is_ptr() => {\n+                // This is a commutative operation, just swap the operands\n+                self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize).map(Some)\n+            }\n+            _ => Ok(None)\n+        }\n+    }\n+\n+    fn ptr_int_arithmetic(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: MemoryPointer,\n+        right: i128,\n+        signed: bool,\n+    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+        use rustc::mir::BinOp::*;\n+\n+        fn map_to_primval((res, over) : (MemoryPointer, bool)) -> (PrimVal, bool) {\n+            (PrimVal::Ptr(res), over)\n+        }\n+\n+        Ok(match bin_op {\n+            Sub =>\n+                // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n+                map_to_primval(left.overflowing_signed_offset(-right, self)),\n+            Add if signed =>\n+                map_to_primval(left.overflowing_signed_offset(right, self)),\n+            Add if !signed =>\n+                map_to_primval(left.overflowing_offset(right as u64, self)),\n+\n+            BitAnd if !signed => {\n+                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align - 1);\n+                let right = right as u64;\n+                if right & base_mask == base_mask {\n+                    // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n+                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, left.offset & right)), false)\n+                } else if right & base_mask == 0 {\n+                    // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n+                    (PrimVal::from_u128((left.offset & right) as u128), false)\n+                } else {\n+                    return Err(EvalError::ReadPointerAsBytes);\n+                }\n+            }\n+\n+            _ => {\n+                let msg = format!(\"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\", bin_op, left, right, if signed { \"signed\" } else { \"unsigned\" });\n+                return Err(EvalError::Unimplemented(msg));\n+            }\n+        })\n+    }\n+}"}, {"sha": "87620cd52b29f67938063da76a08a4d140ff437b", "filename": "miri/tls.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/miri%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ftls.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -0,0 +1,133 @@\n+use rustc::{ty, mir};\n+\n+use super::{\n+    TlsKey, TlsEntry,\n+    EvalResult, EvalError,\n+    Pointer,\n+    Memory,\n+    Evaluator,\n+    Lvalue,\n+    StackPopCleanup, EvalContext,\n+};\n+\n+pub trait MemoryExt<'tcx> {\n+    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey;\n+    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx>;\n+    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer>;\n+    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx>;\n+    fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>>;\n+}\n+\n+pub trait EvalContextExt<'tcx> {\n+    fn run_tls_dtors(&mut self) -> EvalResult<'tcx>;\n+}\n+\n+impl<'a, 'tcx: 'a> MemoryExt<'tcx> for Memory<'a, 'tcx, Evaluator> {\n+    fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n+        let new_key = self.data.next_thread_local;\n+        self.data.next_thread_local += 1;\n+        self.data.thread_local.insert(new_key, TlsEntry { data: Pointer::null(), dtor });\n+        trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n+        return new_key;\n+    }\n+\n+    fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n+        return match self.data.thread_local.remove(&key) {\n+            Some(_) => {\n+                trace!(\"TLS key {} removed\", key);\n+                Ok(())\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+\n+    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n+        return match self.data.thread_local.get(&key) {\n+            Some(&TlsEntry { data, .. }) => {\n+                trace!(\"TLS key {} loaded: {:?}\", key, data);\n+                Ok(data)\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+\n+    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n+        return match self.data.thread_local.get_mut(&key) {\n+            Some(&mut TlsEntry { ref mut data, .. }) => {\n+                trace!(\"TLS key {} stored: {:?}\", key, new_data);\n+                *data = new_data;\n+                Ok(())\n+            },\n+            None => Err(EvalError::TlsOutOfBounds)\n+        }\n+    }\n+    \n+    /// Returns a dtor, its argument and its index, if one is supposed to run\n+    ///\n+    /// An optional destructor function may be associated with each key value.\n+    /// At thread exit, if a key value has a non-NULL destructor pointer,\n+    /// and the thread has a non-NULL value associated with that key,\n+    /// the value of the key is set to NULL, and then the function pointed\n+    /// to is called with the previously associated value as its sole argument.\n+    /// The order of destructor calls is unspecified if more than one destructor\n+    /// exists for a thread when it exits.\n+    ///\n+    /// If, after all the destructors have been called for all non-NULL values\n+    /// with associated destructors, there are still some non-NULL values with\n+    /// associated destructors, then the process is repeated.\n+    /// If, after at least {PTHREAD_DESTRUCTOR_ITERATIONS} iterations of destructor\n+    /// calls for outstanding non-NULL values, there are still some non-NULL values\n+    /// with associated destructors, implementations may stop calling destructors,\n+    /// or they may continue calling destructors until no non-NULL values with\n+    /// associated destructors exist, even though this might result in an infinite loop.\n+    fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n+        use std::collections::Bound::*;\n+        let start = match key {\n+            Some(key) => Excluded(key),\n+            None => Unbounded,\n+        };\n+        for (&key, &mut TlsEntry { ref mut data, dtor }) in self.data.thread_local.range_mut((start, Unbounded)) {\n+            if !data.is_null()? {\n+                if let Some(dtor) = dtor {\n+                    let ret = Some((dtor, *data, key));\n+                    *data = Pointer::null();\n+                    return Ok(ret);\n+                }\n+            }\n+        }\n+        return Ok(None);\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, Evaluator> {\n+    fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n+        let mut dtor = self.memory.fetch_tls_dtor(None)?;\n+        // FIXME: replace loop by some structure that works with stepping\n+        while let Some((instance, ptr, key)) = dtor {\n+            trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n+            // TODO: Potentially, this has to support all the other possible instances?\n+            // See eval_fn_call in interpret/terminator/mod.rs\n+            let mir = self.load_mir(instance.def)?;\n+            self.push_stack_frame(\n+                instance,\n+                mir.span,\n+                mir,\n+                Lvalue::undef(),\n+                StackPopCleanup::None,\n+            )?;\n+            let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n+            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+            let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+            self.write_ptr(dest, ptr, ty)?;\n+\n+            // step until out of stackframes\n+            while self.step()? {}\n+\n+            dtor = match self.memory.fetch_tls_dtor(Some(key))? {\n+                dtor @ Some(_) => dtor,\n+                None => self.memory.fetch_tls_dtor(None)?,\n+            };\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "2199e1e0a5862d5890a6b00c4c7fde1dc89fd0e3", "filename": "rustc_tests/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/rustc_tests%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/rustc_tests%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2FCargo.toml?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -4,4 +4,4 @@ version = \"0.1.0\"\n authors = [\"Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\"]\n \n [dependencies]\n-miri = { path = \"..\" }\n+miri = { path = \"../miri\" }"}, {"sha": "78e8cbeecd78ff798501c8415ef00722ab8ba16d", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -2,38 +2,18 @@\n authors = [\"Scott Olson <scott@solson.me>\"]\n description = \"An experimental interpreter for Rust MIR.\"\n license = \"MIT/Apache-2.0\"\n-name = \"miri\"\n+name = \"rustc_miri\"\n repository = \"https://github.com/solson/miri\"\n version = \"0.1.0\"\n-\n-[[bin]]\n-doc = false\n-name = \"miri\"\n-path = \"interpret/bin/miri.rs\"\n-test = false\n-\n-[[bin]]\n-doc = false\n-name = \"cargo-miri\"\n-path = \"interpret/bin/cargo-miri.rs\"\n-test = false\n+workspace = \"../..\"\n \n [lib]\n test = false\n-path = \"interpret/mod.rs\"\n-\n-[[test]]\n-name = \"compiletest\"\n-path = \"../../tests/compiletest.rs\"\n+path = \"lib.rs\"\n \n [dependencies]\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n-env_logger = \"0.3.3\"\n log = \"0.3.6\"\n log_settings = \"0.1.1\"\n-cargo_metadata = \"0.2\"\n-regex = \"0.2.2\"\n lazy_static = \"0.2.8\"\n-\n-[dev-dependencies]\n-compiletest_rs = \"0.2.6\"\n+regex = \"0.2.2\""}, {"sha": "d69e09313c3fed44711f30740466c0f9e7a01793", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -1,12 +1,16 @@\n use rustc::ty::{self, Ty};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n-use error::{EvalResult, EvalError};\n-use eval_context::EvalContext;\n-use value::PrimVal;\n-use memory::{MemoryPointer, PointerArithmetic};\n-\n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+use super::{\n+    PrimVal,\n+    EvalContext,\n+    EvalResult,\n+    EvalError,\n+    MemoryPointer, PointerArithmetic,\n+    Machine,\n+};\n+\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(super) fn cast_primval(\n         &self,\n         val: PrimVal,\n@@ -19,7 +23,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             PrimVal::Undef => Ok(PrimVal::Undef),\n             PrimVal::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n             val @ PrimVal::Bytes(_) => {\n-                use value::PrimValKind::*;\n+                use super::PrimValKind::*;\n                 match src_kind {\n                     F32 => self.cast_from_float(val.to_f32()? as f64, dest_ty),\n                     F64 => self.cast_from_float(val.to_f64()?, dest_ty),"}, {"sha": "5a334b4db1db73e649515b754093c90ab0ea8617", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 138, "deletions": 9, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -1,22 +1,31 @@\n use rustc::traits::Reveal;\n-use rustc::ty::{self, TyCtxt, Ty, Instance};\n+use rustc::ty::{self, TyCtxt, Ty, Instance, layout};\n+use rustc::mir;\n+\n use syntax::ast::Mutability;\n+use syntax::codemap::Span;\n+\n+use super::{\n+    EvalResult, EvalError,\n+    Global, GlobalId, Lvalue,\n+    PrimVal,\n+    EvalContext, StackPopCleanup,\n+};\n \n-use error::{EvalError, EvalResult};\n-use lvalue::{Global, GlobalId, Lvalue};\n-use value::PrimVal;\n use rustc_const_math::ConstInt;\n-use eval_context::{EvalContext, StackPopCleanup};\n+\n+use std::fmt;\n+use std::error::Error;\n \n pub fn eval_body_as_primval<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n ) -> EvalResult<'tcx, (PrimVal, Ty<'tcx>)> {\n-    let limits = ::ResourceLimits::default();\n-    let mut ecx = EvalContext::new(tcx, limits);\n+    let limits = super::ResourceLimits::default();\n+    let mut ecx = EvalContext::<CompileTimeFunctionEvaluator>::new(tcx, limits, (), ());\n     let cid = GlobalId { instance, promoted: None };\n     if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n-        return Err(EvalError::NotConst(\"extern global\".to_string()));\n+        return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n     }\n     \n     let mir = ecx.load_mir(instance.def)?;\n@@ -70,6 +79,126 @@ pub fn eval_body_as_integer<'a, 'tcx>(\n         TyUint(UintTy::U64) => ConstInt::U64(prim as u64),\n         TyUint(UintTy::U128) => ConstInt::U128(prim),\n         TyUint(UintTy::Us) => ConstInt::Usize(ConstUsize::new(prim as u64, tcx.sess.target.uint_type).expect(\"miri should already have errored\")),\n-        _ => return Err(EvalError::NeedsRfc(\"evaluating anything other than isize/usize during typeck\".to_string())),\n+        _ => return Err(ConstEvalError::NeedsRfc(\"evaluating anything other than isize/usize during typeck\".to_string()).into()),\n     })\n }\n+\n+struct CompileTimeFunctionEvaluator;\n+\n+impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n+    fn into(self) -> EvalError<'tcx> {\n+        EvalError::MachineError(Box::new(self))\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+enum ConstEvalError {\n+    NeedsRfc(String),\n+    NotConst(String),\n+}\n+\n+impl fmt::Display for ConstEvalError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use self::ConstEvalError::*;\n+        match *self {\n+            NeedsRfc(ref msg) =>\n+                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg),\n+            NotConst(ref msg) =>\n+                write!(f, \"Cannot evaluate within constants: \\\"{}\\\"\", msg),\n+        }\n+    }\n+}\n+\n+impl Error for ConstEvalError {\n+    fn description(&self) -> &str {\n+        use self::ConstEvalError::*;\n+        match *self {\n+            NeedsRfc(_) =>\n+                \"this feature needs an rfc before being allowed inside constants\",\n+            NotConst(_) =>\n+                \"this feature is not compatible with constant evaluation\",\n+        }\n+    }\n+\n+    fn cause(&self) -> Option<&Error> {\n+        None\n+    }\n+}\n+\n+impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n+    type Data = ();\n+    type MemoryData = ();\n+    type MemoryKinds = !;\n+    fn eval_fn_call<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        _arg_operands: &[mir::Operand<'tcx>],\n+        span: Span,\n+        _sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        if !ecx.tcx.is_const_fn(instance.def_id()) {\n+            return Err(ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into());\n+        }\n+        let mir = match ecx.load_mir(instance.def) {\n+            Ok(mir) => mir,\n+            Err(EvalError::NoMirFor(path)) => {\n+                // some simple things like `malloc` might get accepted in the future\n+                return Err(ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)).into());\n+            },\n+            Err(other) => return Err(other),\n+        };\n+        let (return_lvalue, return_to_block) = match destination {\n+            Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n+            None => (Lvalue::undef(), StackPopCleanup::None),\n+        };\n+\n+        ecx.push_stack_frame(\n+            instance,\n+            span,\n+            mir,\n+            return_lvalue,\n+            return_to_block,\n+        )?;\n+\n+        Ok(false)\n+    }\n+\n+    fn call_intrinsic<'a>(\n+        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        _dest: Lvalue<'tcx>,\n+        _dest_ty: Ty<'tcx>,\n+        _dest_layout: &'tcx layout::Layout,\n+        _target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        Err(ConstEvalError::NeedsRfc(\"calling intrinsics\".to_string()).into())\n+    }\n+\n+    fn try_ptr_op<'a>(\n+        _ecx: &EvalContext<'a, 'tcx, Self>,\n+        _bin_op: mir::BinOp,\n+        left: PrimVal,\n+        _left_ty: Ty<'tcx>,\n+        right: PrimVal,\n+        _right_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n+        if left.is_bytes() && right.is_bytes() {\n+            Ok(None)\n+        } else {\n+            Err(ConstEvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()).into())\n+        }\n+    }\n+\n+    fn mark_static_initialized(m: !) -> EvalResult<'tcx> {\n+        m\n+    }\n+\n+    fn box_alloc<'a>(\n+        _ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        _ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal> {\n+        Err(ConstEvalError::NeedsRfc(\"Heap allocations via `box` keyword\".to_string()).into())\n+    }\n+}"}, {"sha": "7d62d59fcd79d2d0b038fc55820e27c83a3293ba", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -2,12 +2,19 @@ use std::error::Error;\n use std::fmt;\n use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n-use memory::{MemoryPointer, LockInfo, AccessKind, Kind};\n+\n+use super::{\n+    MemoryPointer, LockInfo, AccessKind\n+};\n+\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub enum EvalError<'tcx> {\n+    /// This variant is used by machines to signal their own errors that do not\n+    /// match an existing variant\n+    MachineError(Box<Error>),\n     FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n     NoMirFor(String),\n     UnterminatedCString(MemoryPointer),\n@@ -81,8 +88,8 @@ pub enum EvalError<'tcx> {\n     AssumptionNotHeld,\n     InlineAsm,\n     TypeNotPrimitive(Ty<'tcx>),\n-    ReallocatedWrongMemoryKind(Kind, Kind),\n-    DeallocatedWrongMemoryKind(Kind, Kind),\n+    ReallocatedWrongMemoryKind(String, String),\n+    DeallocatedWrongMemoryKind(String, String),\n     ReallocateNonBasePtr,\n     DeallocateNonBasePtr,\n     IncorrectAllocationInformation,\n@@ -91,8 +98,6 @@ pub enum EvalError<'tcx> {\n     HeapAllocNonPowerOfTwoAlignment(u64),\n     Unreachable,\n     Panic,\n-    NeedsRfc(String),\n-    NotConst(String),\n     ReadFromReturnPointer,\n     PathNotFound(Vec<String>),\n }\n@@ -101,8 +106,9 @@ pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n \n impl<'tcx> Error for EvalError<'tcx> {\n     fn description(&self) -> &str {\n-        use EvalError::*;\n+        use self::EvalError::*;\n         match *self {\n+            MachineError(ref inner) => inner.description(),\n             FunctionPointerTyMismatch(..) =>\n                 \"tried to call a function through a function pointer of a different type\",\n             InvalidMemoryAccess =>\n@@ -207,23 +213,25 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"entered unreachable code\",\n             Panic =>\n                 \"the evaluated program panicked\",\n-            NeedsRfc(_) =>\n-                \"this feature needs an rfc before being allowed inside constants\",\n-            NotConst(_) =>\n-                \"this feature is not compatible with constant evaluation\",\n             ReadFromReturnPointer =>\n                 \"tried to read from the return pointer\",\n             EvalError::PathNotFound(_) =>\n                 \"a path could not be resolved, maybe the crate is not loaded\",\n         }\n     }\n \n-    fn cause(&self) -> Option<&Error> { None }\n+    fn cause(&self) -> Option<&Error> {\n+        use self::EvalError::*;\n+        match *self {\n+            MachineError(ref inner) => Some(&**inner),\n+            _ => None,\n+        }\n+    }\n }\n \n impl<'tcx> fmt::Display for EvalError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        use EvalError::*;\n+        use self::EvalError::*;\n         match *self {\n             PointerOutOfBounds { ptr, access, allocation_size } => {\n                 write!(f, \"{} at offset {}, outside bounds of allocation {} which has size {}\",\n@@ -254,10 +262,10 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),\n             ArrayIndexOutOfBounds(span, len, index) =>\n                 write!(f, \"index out of bounds: the len is {} but the index is {} at {:?}\", len, index, span),\n-            ReallocatedWrongMemoryKind(old, new) =>\n-                write!(f, \"tried to reallocate memory from {:?} to {:?}\", old, new),\n-            DeallocatedWrongMemoryKind(old, new) =>\n-                write!(f, \"tried to deallocate {:?} memory but gave {:?} as the kind\", old, new),\n+            ReallocatedWrongMemoryKind(ref old, ref new) =>\n+                write!(f, \"tried to reallocate memory from {} to {}\", old, new),\n+            DeallocatedWrongMemoryKind(ref old, ref new) =>\n+                write!(f, \"tried to deallocate {} memory but gave {} as the kind\", old, new),\n             Math(span, ref err) =>\n                 write!(f, \"{:?} at {:?}\", err, span),\n             Intrinsic(ref err) =>\n@@ -274,12 +282,10 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"expected primitive type, got {}\", ty),\n             Layout(ref err) =>\n                 write!(f, \"rustc layout computation failed: {:?}\", err),\n-            NeedsRfc(ref msg) =>\n-                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg),\n-            NotConst(ref msg) =>\n-                write!(f, \"Cannot evaluate within constants: \\\"{}\\\"\", msg),\n-            EvalError::PathNotFound(ref path) =>\n+            PathNotFound(ref path) =>\n                 write!(f, \"Cannot find path {:?}\", path),\n+            MachineError(ref inner) =>\n+                write!(f, \"machine error: {}\", inner),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "277e6e99e752cf23579ecc81e90f759bbd0a4a69", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 165, "deletions": 238, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -7,7 +7,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n use rustc::mir;\n use rustc::traits::Reveal;\n-use rustc::ty::layout::{self, Layout, Size};\n+use rustc::ty::layout::{self, Layout, Size, Align};\n use rustc::ty::subst::{Subst, Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n use rustc::traits;\n@@ -16,28 +16,34 @@ use syntax::codemap::{self, DUMMY_SP, Span};\n use syntax::ast::{self, Mutability};\n use syntax::abi::Abi;\n \n-use error::{EvalError, EvalResult};\n-use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n-use memory::{Memory, MemoryPointer, TlsKey, HasMemory};\n-use memory::Kind as MemoryKind;\n-use operator;\n-use value::{PrimVal, PrimValKind, Value, Pointer};\n-use validation::ValidationQuery;\n+use super::{\n+    EvalError, EvalResult,\n+    Global, GlobalId, Lvalue, LvalueExtra,\n+    Memory, MemoryPointer, HasMemory,\n+    Kind as MemoryKind,\n+    operator,\n+    PrimVal, PrimValKind, Value, Pointer,\n+    ValidationQuery,\n+    Machine,\n+};\n+\n+pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n+    /// Stores data required by the `Machine`\n+    pub machine_data: M::Data,\n \n-pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n-    pub(crate) tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// The virtual memory system.\n-    pub(crate) memory: Memory<'a, 'tcx>,\n+    pub memory: Memory<'a, 'tcx, M>,\n \n     #[allow(dead_code)]\n     // FIXME(@RalfJung): validation branch\n     /// Lvalues that were suspended by the validation subsystem, and will be recovered later\n     pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n \n     /// Precomputed statics, constants and promoteds.\n-    pub(crate) globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n+    pub globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'tcx>>,\n@@ -49,10 +55,6 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     /// This prevents infinite loops and huge computations from freezing up const eval.\n     /// Remove once halting problem is solved.\n     pub(crate) steps_remaining: u64,\n-\n-    /// Environment variables set by `setenv`\n-    /// Miri does not expose env vars from the host to the emulated program\n-    pub(crate) env_vars: HashMap<Vec<u8>, MemoryPointer>,\n }\n \n /// A stack frame.\n@@ -110,11 +112,6 @@ pub enum StackPopCleanup {\n     /// A regular stackframe added due to a function call will need to get forwarded to the next\n     /// block\n     Goto(mir::BasicBlock),\n-    /// After finishing a tls destructor, find the next one instead of starting from the beginning\n-    /// and thus just rerunning the first one until its `data` argument is null\n-    ///\n-    /// The index is the current tls destructor's index\n-    Tls(Option<TlsKey>),\n     /// The main function and diverging functions have nowhere to return to\n     None,\n }\n@@ -148,17 +145,22 @@ pub struct TyAndPacked<'tcx> {\n     pub packed: bool,\n }\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, limits: ResourceLimits) -> Self {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+    pub fn new(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        limits: ResourceLimits,\n+        machine_data: M::Data,\n+        memory_data: M::MemoryData,\n+    ) -> Self {\n         EvalContext {\n+            machine_data,\n             tcx,\n-            memory: Memory::new(&tcx.data_layout, limits.memory_size),\n+            memory: Memory::new(&tcx.data_layout, limits.memory_size, memory_data),\n             suspended: HashMap::new(),\n             globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: limits.stack_limit,\n             steps_remaining: limits.step_limit,\n-            env_vars: HashMap::new(),\n         }\n     }\n \n@@ -177,11 +179,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.memory.allocate(size, align, MemoryKind::Stack)\n     }\n \n-    pub fn memory(&self) -> &Memory<'a, 'tcx> {\n+    pub fn memory(&self) -> &Memory<'a, 'tcx, M> {\n         &self.memory\n     }\n \n-    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n+    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n         &mut self.memory\n     }\n \n@@ -209,7 +211,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         false\n     }\n \n-    pub(crate) fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n+    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         let ptr = self.memory.allocate_cached(s.as_bytes())?;\n         Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u128(s.len() as u128)))\n     }\n@@ -275,11 +277,103 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.erase_regions(&value)\n     }\n \n-    pub(super) fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n+    pub fn size_and_align_of_dst(\n+        &mut self,\n+        ty: ty::Ty<'tcx>,\n+        value: Value,\n+    ) -> EvalResult<'tcx, (u64, u64)> {\n+        if let Some(size) = self.type_size(ty)? {\n+            Ok((size as u64, self.type_align(ty)? as u64))\n+        } else {\n+            match ty.sty {\n+                ty::TyAdt(def, substs) => {\n+                    // First get the size of all statically known fields.\n+                    // Don't use type_of::sizing_type_of because that expects t to be sized,\n+                    // and it also rounds up to alignment, which we want to avoid,\n+                    // as the unsized field's alignment could be smaller.\n+                    assert!(!ty.is_simd());\n+                    let layout = self.type_layout(ty)?;\n+                    debug!(\"DST {} layout: {:?}\", ty, layout);\n+\n+                    let (sized_size, sized_align) = match *layout {\n+                        ty::layout::Layout::Univariant { ref variant, .. } => {\n+                            (variant.offsets.last().map_or(0, |o| o.bytes()), variant.align)\n+                        }\n+                        _ => {\n+                            bug!(\"size_and_align_of_dst: expcted Univariant for `{}`, found {:#?}\",\n+                                 ty, layout);\n+                        }\n+                    };\n+                    debug!(\"DST {} statically sized prefix size: {} align: {:?}\",\n+                           ty, sized_size, sized_align);\n+\n+                    // Recurse to get the size of the dynamically sized field (must be\n+                    // the last field).\n+                    let last_field = def.struct_variant().fields.last().unwrap();\n+                    let field_ty = self.field_ty(substs, last_field);\n+                    let (unsized_size, unsized_align) = self.size_and_align_of_dst(field_ty, value)?;\n+\n+                    // FIXME (#26403, #27023): We should be adding padding\n+                    // to `sized_size` (to accommodate the `unsized_align`\n+                    // required of the unsized field that follows) before\n+                    // summing it with `sized_size`. (Note that since #26403\n+                    // is unfixed, we do not yet add the necessary padding\n+                    // here. But this is where the add would go.)\n+\n+                    // Return the sum of sizes and max of aligns.\n+                    let size = sized_size + unsized_size;\n+\n+                    // Choose max of two known alignments (combined value must\n+                    // be aligned according to more restrictive of the two).\n+                    let align = sized_align.max(Align::from_bytes(unsized_align, unsized_align).unwrap());\n+\n+                    // Issue #27023: must add any necessary padding to `size`\n+                    // (to make it a multiple of `align`) before returning it.\n+                    //\n+                    // Namely, the returned size should be, in C notation:\n+                    //\n+                    //   `size + ((size & (align-1)) ? align : 0)`\n+                    //\n+                    // emulated via the semi-standard fast bit trick:\n+                    //\n+                    //   `(size + (align-1)) & -align`\n+\n+                    let size = Size::from_bytes(size).abi_align(align).bytes();\n+                    Ok((size, align.abi()))\n+                }\n+                ty::TyDynamic(..) => {\n+                    let (_, vtable) = value.into_ptr_vtable_pair(&mut self.memory)?;\n+                    // the second entry in the vtable is the dynamic size of the object.\n+                    self.read_size_and_align_from_vtable(vtable)\n+                }\n+\n+                ty::TySlice(_) | ty::TyStr => {\n+                    let elem_ty = ty.sequence_element_type(self.tcx);\n+                    let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as u64;\n+                    let (_, len) = value.into_slice(&mut self.memory)?;\n+                    let align = self.type_align(elem_ty)?;\n+                    Ok((len * elem_size, align as u64))\n+                }\n+\n+                _ => bug!(\"size_of_val::<{:?}>\", ty),\n+            }\n+        }\n+    }\n+\n+    /// Returns the normalized type of a struct field\n+    fn field_ty(\n+        &self,\n+        param_substs: &Substs<'tcx>,\n+        f: &ty::FieldDef,\n+    ) -> ty::Ty<'tcx> {\n+        self.tcx.normalize_associated_type(&f.ty(self.tcx, param_substs))\n+    }\n+\n+    pub fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n \n-    pub(super) fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n+    pub fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n         self.type_align_with_substs(ty, self.substs())\n     }\n \n@@ -300,7 +394,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.type_layout_with_substs(ty, substs).map(|layout| layout.align(&self.tcx.data_layout).abi())\n     }\n \n-    pub(super) fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n+    pub fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n         self.type_layout_with_substs(ty, self.substs())\n     }\n \n@@ -412,29 +506,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             },\n             StackPopCleanup::Goto(target) => self.goto_block(target),\n             StackPopCleanup::None => {},\n-            StackPopCleanup::Tls(key) => {\n-                // either fetch the next dtor or start new from the beginning, if any are left with a non-null data\n-                let dtor = match self.memory.fetch_tls_dtor(key)? {\n-                    dtor @ Some(_) => dtor,\n-                    None => self.memory.fetch_tls_dtor(None)?,\n-                };\n-                if let Some((instance, ptr, key)) = dtor {\n-                    trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n-                    // TODO: Potentially, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n-                    let mir = self.load_mir(instance.def)?;\n-                    self.push_stack_frame(\n-                        instance,\n-                        mir.span,\n-                        mir,\n-                        Lvalue::undef(),\n-                        StackPopCleanup::Tls(Some(key)),\n-                    )?;\n-                    let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()))?;\n-                    let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                    let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                    self.write_ptr(dest, ptr, ty)?;\n-                }\n-            }\n         }\n         // deallocate all locals that are backed by an allocation\n         for local in frame.locals {\n@@ -687,9 +758,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Len(ref lvalue) => {\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(\"computing the length of arrays\".to_string()));\n-                }\n+                // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_lvalue(lvalue)?;\n                 let ty = self.lvalue_ty(lvalue);\n                 let (_, len) = src.elem_ty_and_len(ty);\n@@ -713,25 +782,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             NullaryOp(mir::NullOp::Box, ty) => {\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(\"\\\"heap\\\" allocations\".to_string()));\n-                }\n-                // FIXME: call the `exchange_malloc` lang item if available\n-                let size = self.type_size(ty)?.expect(\"box only works with sized types\");\n-                if size == 0 {\n-                    let align = self.type_align(ty)?;\n-                    self.write_primval(dest, PrimVal::Bytes(align.into()), dest_ty)?;\n-                } else {\n-                    let align = self.type_align(ty)?;\n-                    let ptr = self.memory.allocate(size, align, MemoryKind::Rust)?;\n-                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-                }\n+                let ptr = M::box_alloc(self, ty)?;\n+                self.write_primval(dest, ptr, dest_ty)?;\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(\"computing the size of types (size_of)\".to_string()));\n-                }\n                 let size = self.type_size(ty)?.expect(\"SizeOf nullary MIR operator called for unsized type\");\n                 self.write_primval(dest, PrimVal::from_u128(size as u128), dest_ty)?;\n             }\n@@ -958,46 +1013,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn wrapping_pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n-        // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n-        let offset = offset.overflowing_mul(pointee_size).0;\n-        ptr.wrapping_signed_offset(offset, self)\n-    }\n-\n-    pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n-        // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n-        // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n-        // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n-        // allocation.\n-\n-        if ptr.is_null()? { // NULL pointers must only be offset by 0\n-            return if offset == 0 { Ok(ptr) } else { Err(EvalError::InvalidNullPointerUsage) };\n-        }\n-        // FIXME: assuming here that type size is < i64::max_value()\n-        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n-        return if let Some(offset) = offset.checked_mul(pointee_size) {\n-            let ptr = ptr.signed_offset(offset, self)?;\n-            // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n-            if let PrimVal::Ptr(ptr) = ptr.into_inner_primval() {\n-                self.memory.check_bounds(ptr, false)?;\n-            } else if ptr.is_null()? {\n-                // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n-                return Err(EvalError::InvalidNullPointerUsage);\n-            }\n-            Ok(ptr)\n-        } else {\n-            Err(EvalError::OverflowingMath)\n-        }\n-    }\n-\n     pub(super) fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         let value = self.eval_operand(op)?;\n         let ty = self.operand_ty(op);\n         self.value_to_primval(value, ty)\n     }\n \n-    pub(super) fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::mir::Operand::*;\n         match *op {\n             Consume(ref lvalue) => self.eval_and_read_lvalue(lvalue),\n@@ -1028,7 +1050,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n+    pub fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n \n@@ -1039,7 +1061,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub(super) fn force_allocation(\n+    pub fn force_allocation(\n         &mut self,\n         lvalue: Lvalue<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n@@ -1099,7 +1121,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    pub fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match self.follow_by_ref_value(value, ty)? {\n             Value::ByRef{..} => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n@@ -1112,15 +1134,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn write_null(\n+    pub fn write_null(\n         &mut self,\n         dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         self.write_primval(dest, PrimVal::Bytes(0), dest_ty)\n     }\n \n-    pub(super) fn write_ptr(\n+    pub fn write_ptr(\n         &mut self,\n         dest: Lvalue<'tcx>,\n         val: Pointer,\n@@ -1129,7 +1151,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.write_value(val.to_value(), dest, dest_ty)\n     }\n \n-    pub(super) fn write_primval(\n+    pub fn write_primval(\n         &mut self,\n         dest: Lvalue<'tcx>,\n         val: PrimVal,\n@@ -1138,7 +1160,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.write_value(Value::ByVal(val), dest, dest_ty)\n     }\n \n-    pub(super) fn write_value(\n+    pub fn write_value(\n         &mut self,\n         src_val: Value,\n         dest: Lvalue<'tcx>,\n@@ -1233,7 +1255,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub(super) fn write_value_to_ptr(\n+    pub fn write_value_to_ptr(\n         &mut self,\n         value: Value,\n         dest: Pointer,\n@@ -1251,7 +1273,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn write_pair_to_ptr(\n+    pub fn write_pair_to_ptr(\n         &mut self,\n         a: PrimVal,\n         b: PrimVal,\n@@ -1381,7 +1403,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, ty)? {\n             Ok(val)\n         } else {\n@@ -1487,7 +1509,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Some(Value::ByVal(val)))\n     }\n \n-    pub(super) fn frame(&self) -> &Frame<'tcx> {\n+    pub fn frame(&self) -> &Frame<'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n@@ -1584,8 +1606,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let dest = self.force_allocation(dest)?.to_ptr()?;\n                 let iter = src_fields.zip(dst_fields).enumerate();\n                 for (i, (src_f, dst_f)) in iter {\n-                    let src_fty = monomorphize_field_ty(self.tcx, src_f, substs_a);\n-                    let dst_fty = monomorphize_field_ty(self.tcx, dst_f, substs_b);\n+                    let src_fty = self.field_ty(substs_a, src_f);\n+                    let dst_fty = self.field_ty(substs_b, dst_f);\n                     if self.type_size(dst_fty)? == Some(0) {\n                         continue;\n                     }\n@@ -1605,7 +1627,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n+    pub fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n         // Debug output\n         if let Lvalue::Local { frame, local } = lvalue {\n             let mut allocs = Vec::new();\n@@ -1676,6 +1698,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // }\n         Ok(())\n     }\n+\n+    pub fn report(&self, e: &EvalError) {\n+        if let Some(frame) = self.stack().last() {\n+            let block = &frame.mir.basic_blocks()[frame.block];\n+            let span = if frame.stmt < block.statements.len() {\n+                block.statements[frame.stmt].source_info.span\n+            } else {\n+                block.terminator().source_info.span\n+            };\n+            let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n+            for &Frame { instance, span, .. } in self.stack().iter().rev() {\n+                if self.tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+                    err.span_note(span, \"inside call to closure\");\n+                    continue;\n+                }\n+                err.span_note(span, &format!(\"inside call to {}\", instance));\n+            }\n+            err.emit();\n+        } else {\n+            self.tcx.sess.err(&e.to_string());\n+        }\n+    }\n }\n \n impl<'tcx> Frame<'tcx> {\n@@ -1713,117 +1757,6 @@ impl<'tcx> Frame<'tcx> {\n     }\n }\n \n-pub fn eval_main<'a, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    main_id: DefId,\n-    start_wrapper: Option<DefId>,\n-    limits: ResourceLimits,\n-) {\n-    fn run_main<'a, 'tcx: 'a>(\n-        ecx: &mut EvalContext<'a, 'tcx>,\n-        main_id: DefId,\n-        start_wrapper: Option<DefId>,\n-    ) -> EvalResult<'tcx> {\n-        let main_instance = ty::Instance::mono(ecx.tcx, main_id);\n-        let main_mir = ecx.load_mir(main_instance.def)?;\n-        let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n-\n-        if !main_mir.return_ty.is_nil() || main_mir.arg_count != 0 {\n-            return Err(EvalError::Unimplemented(\"miri does not support main functions without `fn()` type signatures\".to_owned()));\n-        }\n-\n-        if let Some(start_id) = start_wrapper {\n-            let start_instance = ty::Instance::mono(ecx.tcx, start_id);\n-            let start_mir = ecx.load_mir(start_instance.def)?;\n-\n-            if start_mir.arg_count != 3 {\n-                return Err(EvalError::AbiViolation(format!(\"'start' lang item should have three arguments, but has {}\", start_mir.arg_count)));\n-            }\n-\n-            // Return value\n-            let ret_ptr = ecx.memory.allocate(ecx.tcx.data_layout.pointer_size.bytes(), ecx.tcx.data_layout.pointer_align.abi(), MemoryKind::Stack)?;\n-            cleanup_ptr = Some(ret_ptr);\n-\n-            // Push our stack frame\n-            ecx.push_stack_frame(\n-                start_instance,\n-                start_mir.span,\n-                start_mir,\n-                Lvalue::from_ptr(ret_ptr),\n-                StackPopCleanup::Tls(None),\n-            )?;\n-\n-            let mut args = ecx.frame().mir.args_iter();\n-\n-            // First argument: pointer to main()\n-            let main_ptr = ecx.memory.create_fn_alloc(main_instance);\n-            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-            let main_ty = main_instance.def.def_ty(ecx.tcx);\n-            let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx));\n-            ecx.write_value(Value::ByVal(PrimVal::Ptr(main_ptr)), dest, main_ptr_ty)?;\n-\n-            // Second argument (argc): 0\n-            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-            let ty = ecx.tcx.types.isize;\n-            ecx.write_null(dest, ty)?;\n-\n-            // Third argument (argv): 0\n-            let dest = ecx.eval_lvalue(&mir::Lvalue::Local(args.next().unwrap()))?;\n-            let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n-            ecx.write_null(dest, ty)?;\n-        } else {\n-            ecx.push_stack_frame(\n-                main_instance,\n-                main_mir.span,\n-                main_mir,\n-                Lvalue::undef(),\n-                StackPopCleanup::Tls(None),\n-            )?;\n-        }\n-\n-        while ecx.step()? {}\n-        if let Some(cleanup_ptr) = cleanup_ptr {\n-            ecx.memory.deallocate(cleanup_ptr, None, MemoryKind::Stack)?;\n-        }\n-        return Ok(());\n-    }\n-\n-    let mut ecx = EvalContext::new(tcx, limits);\n-    match run_main(&mut ecx, main_id, start_wrapper) {\n-        Ok(()) => {\n-            let leaks = ecx.memory.leak_report();\n-            if leaks != 0 {\n-                tcx.sess.err(\"the evaluated program leaked memory\");\n-            }\n-        }\n-        Err(e) => {\n-            report(tcx, &ecx, &e);\n-        }\n-    }\n-}\n-\n-fn report(tcx: TyCtxt, ecx: &EvalContext, e: &EvalError) {\n-    if let Some(frame) = ecx.stack().last() {\n-        let block = &frame.mir.basic_blocks()[frame.block];\n-        let span = if frame.stmt < block.statements.len() {\n-            block.statements[frame.stmt].source_info.span\n-        } else {\n-            block.terminator().source_info.span\n-        };\n-        let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n-        for &Frame { instance, span, .. } in ecx.stack().iter().rev() {\n-            if tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n-                err.span_note(span, \"inside call to closure\");\n-                continue;\n-            }\n-            err.span_note(span, &format!(\"inside call to {}\", instance));\n-        }\n-        err.emit();\n-    } else {\n-        tcx.sess.err(&e.to_string());\n-    }\n-}\n-\n // TODO(solson): Upstream these methods into rustc::ty::layout.\n \n pub(super) trait IntegerExt {\n@@ -1843,12 +1776,6 @@ impl IntegerExt for layout::Integer {\n     }\n }\n \n-\n-pub fn monomorphize_field_ty<'a, 'tcx:'a >(tcx: TyCtxt<'a, 'tcx, 'tcx>, f: &ty::FieldDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n-    let substituted = f.ty(tcx, substs);\n-    tcx.normalize_associated_type(&substituted)\n-}\n-\n pub fn is_inhabited<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.uninhabited_from(&mut HashMap::default(), tcx).is_empty()\n }"}, {"sha": "5c10d2c19528293edcd0715fd2c43635d0bb7081", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -4,10 +4,13 @@ use rustc::ty::{self, Ty};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::ast::Mutability;\n \n-use error::{EvalError, EvalResult};\n-use eval_context::EvalContext;\n-use memory::MemoryPointer;\n-use value::{PrimVal, Pointer, Value};\n+use super::{\n+    EvalError, EvalResult,\n+    EvalContext,\n+    MemoryPointer,\n+    PrimVal, Value, Pointer,\n+    Machine,\n+};\n \n #[derive(Copy, Clone, Debug)]\n pub enum Lvalue<'tcx> {\n@@ -46,15 +49,15 @@ pub enum LvalueExtra {\n pub struct GlobalId<'tcx> {\n     /// For a constant or static, the `Instance` of the item itself.\n     /// For a promoted global, the `Instance` of the function they belong to.\n-    pub(super) instance: ty::Instance<'tcx>,\n+    pub instance: ty::Instance<'tcx>,\n \n     /// The index for promoted globals within their function's `Mir`.\n-    pub(super) promoted: Option<mir::Promoted>,\n+    pub promoted: Option<mir::Promoted>,\n }\n \n #[derive(Clone, Debug)]\n pub struct Global<'tcx> {\n-    pub(super) value: Value,\n+    pub value: Value,\n     /// Only used in `force_allocation` to ensure we don't mark the memory\n     /// before the static is initialized. It is possible to convert a\n     /// global which initially is `Value::ByVal(PrimVal::Undef)` and gets\n@@ -70,11 +73,11 @@ impl<'tcx> Lvalue<'tcx> {\n         Self::from_primval_ptr(PrimVal::Undef.into())\n     }\n \n-    pub(crate) fn from_primval_ptr(ptr: Pointer) -> Self {\n+    pub fn from_primval_ptr(ptr: Pointer) -> Self {\n         Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true }\n     }\n \n-    pub(crate) fn from_ptr(ptr: MemoryPointer) -> Self {\n+    pub fn from_ptr(ptr: MemoryPointer) -> Self {\n         Self::from_primval_ptr(ptr.into())\n     }\n \n@@ -86,7 +89,7 @@ impl<'tcx> Lvalue<'tcx> {\n         }\n     }\n \n-    pub(super) fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n         let (ptr, extra, _aligned) = self.to_ptr_extra_aligned();\n         // At this point, we forget about the alignment information -- the lvalue has been turned into a reference,\n         // and no matter where it came from, it now must be aligned.\n@@ -130,7 +133,7 @@ impl<'tcx> Global<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     /// Reads a value from the lvalue without going through the intermediate step of obtaining\n     /// a `miri::Lvalue`\n     pub fn try_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n@@ -207,7 +210,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,"}, {"sha": "0150a6c836d683058c19e1272d705a7e38bbaa15", "filename": "src/librustc_mir/interpret/machine.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -0,0 +1,79 @@\n+//! This module contains everything needed to instantiate an interpreter.\n+//! This separation exists to ensure that no fancy miri features like\n+//! interpreting common C functions leak into CTFE.\n+\n+use super::{\n+    EvalResult,\n+    EvalContext,\n+    Lvalue,\n+    PrimVal\n+};\n+\n+use rustc::{mir, ty};\n+use syntax::codemap::Span;\n+\n+/// Methods of this trait signifies a point where CTFE evaluation would fail\n+/// and some use case dependent behaviour can instead be applied\n+pub trait Machine<'tcx>: Sized {\n+    /// Additional data that can be accessed via the EvalContext\n+    type Data;\n+\n+    /// Additional data that can be accessed via the Memory\n+    type MemoryData;\n+\n+    /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n+    type MemoryKinds: ::std::fmt::Debug + PartialEq + Copy + Clone;\n+\n+    /// Entry point to all function calls.\n+    ///\n+    /// Returns Ok(true) when the function was handled completely\n+    /// e.g. due to missing mir\n+    ///\n+    /// Returns Ok(false) if a new stack frame was pushed\n+    fn eval_fn_call<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n+        arg_operands: &[mir::Operand<'tcx>],\n+        span: Span,\n+        sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool>;\n+\n+    /// directly process an intrinsic without pushing a stack frame.\n+    fn call_intrinsic<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        dest: Lvalue<'tcx>,\n+        dest_ty: ty::Ty<'tcx>,\n+        dest_layout: &'tcx ty::layout::Layout,\n+        target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx>;\n+\n+    /// Called for all binary operations except on float types.\n+    ///\n+    /// Returns `None` if the operation should be handled by the integer\n+    /// op code in order to share more code between machines\n+    ///\n+    /// Returns a (value, overflowed) pair if the operation succeeded\n+    fn try_ptr_op<'a>(\n+        ecx: &EvalContext<'a, 'tcx, Self>,\n+        bin_op: mir::BinOp,\n+        left: PrimVal,\n+        left_ty: ty::Ty<'tcx>,\n+        right: PrimVal,\n+        right_ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n+\n+    /// Called when trying to mark machine defined `MemoryKinds` as static\n+    fn mark_static_initialized(m: Self::MemoryKinds) -> EvalResult<'tcx>;\n+\n+    /// Heap allocations via the `box` keyword\n+    ///\n+    /// Returns a pointer to the allocated memory\n+    fn box_alloc<'a>(\n+        ecx: &mut EvalContext<'a, 'tcx, Self>,\n+        ty: ty::Ty<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal>;\n+}\n+"}, {"sha": "31e47e706ad33cc6e27a050402616809eb1a965e", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 75, "deletions": 152, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -8,9 +8,12 @@ use rustc::ty::layout::{self, TargetDataLayout, HasDataLayout};\n use syntax::ast::Mutability;\n use rustc::middle::region::CodeExtent;\n \n-use error::{EvalError, EvalResult};\n-use value::{PrimVal, Pointer};\n-use eval_context::{EvalContext, DynamicLifetime};\n+use super::{\n+    EvalError, EvalResult,\n+    PrimVal, Pointer,\n+    EvalContext, DynamicLifetime,\n+    Machine,\n+};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Locks\n@@ -113,7 +116,7 @@ impl fmt::Display for AllocId {\n }\n \n #[derive(Debug)]\n-pub struct Allocation {\n+pub struct Allocation<M> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer\n     pub bytes: Vec<u8>,\n@@ -129,12 +132,12 @@ pub struct Allocation {\n     /// Use the `mark_static_initalized` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified or deallocated in the future.\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n-    pub kind: Kind,\n+    pub kind: Kind<M>,\n     /// Memory regions that are locked by some function\n     locks: BTreeMap<MemoryRange, LockInfo>,\n }\n \n-impl Allocation {\n+impl<M> Allocation<M> {\n     fn iter_locks<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a LockInfo)> + 'a {\n         self.locks.range(MemoryRange::range(offset, len))\n             .filter(move |&(range, _)| range.overlaps(offset, len))\n@@ -162,11 +165,7 @@ impl Allocation {\n }\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n-pub enum Kind {\n-    /// Error if deallocated any other way than `rust_deallocate`\n-    Rust,\n-    /// Error if deallocated any other way than `free`\n-    C,\n+pub enum Kind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n     /// Static in the process of being initialized.\n@@ -176,8 +175,8 @@ pub enum Kind {\n     UninitializedStatic,\n     /// May never be deallocated\n     Static,\n-    /// Part of env var emulation\n-    Env,\n+    /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n+    Machine(T),\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -195,7 +194,7 @@ impl<'tcx> MemoryPointer {\n         MemoryPointer::new(self.alloc_id, cx.data_layout().wrapping_signed_offset(self.offset, i))\n     }\n \n-    pub(crate) fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n+    pub fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset, i);\n         (MemoryPointer::new(self.alloc_id, res), over)\n     }\n@@ -204,12 +203,12 @@ impl<'tcx> MemoryPointer {\n         Ok(MemoryPointer::new(self.alloc_id, cx.data_layout().signed_offset(self.offset, i)?))\n     }\n \n-    pub(crate) fn overflowing_offset<C: HasDataLayout>(self, i: u64, cx: C) -> (Self, bool) {\n+    pub fn overflowing_offset<C: HasDataLayout>(self, i: u64, cx: C) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_offset(self.offset, i);\n         (MemoryPointer::new(self.alloc_id, res), over)\n     }\n \n-    pub(crate) fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n         Ok(MemoryPointer::new(self.alloc_id, cx.data_layout().offset(self.offset, i)?))\n     }\n }\n@@ -218,17 +217,12 @@ impl<'tcx> MemoryPointer {\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub type TlsKey = usize;\n+pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n+    /// Additional data required by the Machine\n+    pub data: M::MemoryData,\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct TlsEntry<'tcx> {\n-    data: Pointer, // Will eventually become a map from thread IDs to `Pointer`s, if we ever support more than one thread.\n-    dtor: Option<ty::Instance<'tcx>>,\n-}\n-\n-pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: HashMap<AllocId, Allocation>,\n+    alloc_map: HashMap<AllocId, Allocation<M::MemoryKinds>>,\n \n     /// The AllocId to assign to the next new allocation. Always incremented, never gets smaller.\n     next_id: AllocId,\n@@ -259,12 +253,6 @@ pub struct Memory<'a, 'tcx> {\n     /// allocations for string and bytestring literals.\n     literal_alloc_cache: HashMap<Vec<u8>, AllocId>,\n \n-    /// pthreads-style thread-local storage.\n-    thread_local: BTreeMap<TlsKey, TlsEntry<'tcx>>,\n-\n-    /// The Key to use for the next thread-local allocation.\n-    next_thread_local: TlsKey,\n-\n     /// To avoid having to pass flags to every single memory access, we have some global state saying whether\n     /// alignment checking is currently enforced for read and/or write accesses.\n     reads_are_aligned: Cell<bool>,\n@@ -274,9 +262,10 @@ pub struct Memory<'a, 'tcx> {\n     cur_frame: usize,\n }\n \n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn new(layout: &'a TargetDataLayout, max_memory: u64) -> Self {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+    pub fn new(layout: &'a TargetDataLayout, max_memory: u64, data: M::MemoryData) -> Self {\n         Memory {\n+            data,\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n             function_alloc_cache: HashMap::new(),\n@@ -286,15 +275,13 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             memory_usage: 0,\n             static_alloc: HashSet::new(),\n             literal_alloc_cache: HashMap::new(),\n-            thread_local: BTreeMap::new(),\n-            next_thread_local: 0,\n             reads_are_aligned: Cell::new(true),\n             writes_are_aligned: Cell::new(true),\n             cur_frame: usize::max_value(),\n         }\n     }\n \n-    pub fn allocations(&self) -> ::std::collections::hash_map::Iter<AllocId, Allocation> {\n+    pub fn allocations(&self) -> ::std::collections::hash_map::Iter<AllocId, Allocation<M::MemoryKinds>> {\n         self.alloc_map.iter()\n     }\n \n@@ -322,7 +309,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(ptr)\n     }\n \n-    pub fn allocate(&mut self, size: u64, align: u64, kind: Kind) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn allocate(\n+        &mut self,\n+        size: u64,\n+        align: u64,\n+        kind: Kind<M::MemoryKinds>,\n+    ) -> EvalResult<'tcx, MemoryPointer> {\n         assert_ne!(align, 0);\n         assert!(align.is_power_of_two());\n \n@@ -350,15 +342,23 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(MemoryPointer::new(id, 0))\n     }\n \n-    pub fn reallocate(&mut self, ptr: MemoryPointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64, kind: Kind) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn reallocate(\n+        &mut self,\n+        ptr: MemoryPointer,\n+        old_size: u64,\n+        old_align: u64,\n+        new_size: u64,\n+        new_align: u64,\n+        kind: Kind<M::MemoryKinds>,\n+    ) -> EvalResult<'tcx, MemoryPointer> {\n         use std::cmp::min;\n \n         if ptr.offset != 0 {\n             return Err(EvalError::ReallocateNonBasePtr);\n         }\n         if let Ok(alloc) = self.get(ptr.alloc_id) {\n             if alloc.kind != kind {\n-                return Err(EvalError::ReallocatedWrongMemoryKind(alloc.kind, kind));\n+                return Err(EvalError::ReallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n             }\n         }\n \n@@ -370,7 +370,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(new_ptr)\n     }\n \n-    pub fn deallocate(&mut self, ptr: MemoryPointer, size_and_align: Option<(u64, u64)>, kind: Kind) -> EvalResult<'tcx> {\n+    pub fn deallocate(\n+        &mut self,\n+        ptr: MemoryPointer,\n+        size_and_align: Option<(u64, u64)>,\n+        kind: Kind<M::MemoryKinds>,\n+    ) -> EvalResult<'tcx> {\n         if ptr.offset != 0 {\n             return Err(EvalError::DeallocateNonBasePtr);\n         }\n@@ -389,7 +394,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             .map_err(|lock| EvalError::DeallocatedLockedMemory { ptr, lock })?;\n \n         if alloc.kind != kind {\n-            return Err(EvalError::DeallocatedWrongMemoryKind(alloc.kind, kind));\n+            return Err(EvalError::DeallocatedWrongMemoryKind(format!(\"{:?}\", alloc.kind), format!(\"{:?}\", kind)));\n         }\n         if let Some((size, align)) = size_and_align {\n             if size != alloc.bytes.len() as u64 || align != alloc.align {\n@@ -443,7 +448,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn check_bounds(&self, ptr: MemoryPointer, access: bool) -> EvalResult<'tcx> {\n+    pub fn check_bounds(&self, ptr: MemoryPointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset > allocation_size {\n@@ -455,85 +460,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub(crate) fn set_cur_frame(&mut self, cur_frame: usize) {\n         self.cur_frame = cur_frame;\n     }\n-\n-    pub(crate) fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n-        let new_key = self.next_thread_local;\n-        self.next_thread_local += 1;\n-        self.thread_local.insert(new_key, TlsEntry { data: Pointer::null(), dtor });\n-        trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n-        return new_key;\n-    }\n-\n-    pub(crate) fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n-        return match self.thread_local.remove(&key) {\n-            Some(_) => {\n-                trace!(\"TLS key {} removed\", key);\n-                Ok(())\n-            },\n-            None => Err(EvalError::TlsOutOfBounds)\n-        }\n-    }\n-\n-    pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n-        return match self.thread_local.get(&key) {\n-            Some(&TlsEntry { data, .. }) => {\n-                trace!(\"TLS key {} loaded: {:?}\", key, data);\n-                Ok(data)\n-            },\n-            None => Err(EvalError::TlsOutOfBounds)\n-        }\n-    }\n-\n-    pub(crate) fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n-        return match self.thread_local.get_mut(&key) {\n-            Some(&mut TlsEntry { ref mut data, .. }) => {\n-                trace!(\"TLS key {} stored: {:?}\", key, new_data);\n-                *data = new_data;\n-                Ok(())\n-            },\n-            None => Err(EvalError::TlsOutOfBounds)\n-        }\n-    }\n-    \n-    /// Returns a dtor, its argument and its index, if one is supposed to run\n-    ///\n-    /// An optional destructor function may be associated with each key value.\n-    /// At thread exit, if a key value has a non-NULL destructor pointer,\n-    /// and the thread has a non-NULL value associated with that key,\n-    /// the value of the key is set to NULL, and then the function pointed\n-    /// to is called with the previously associated value as its sole argument.\n-    /// The order of destructor calls is unspecified if more than one destructor\n-    /// exists for a thread when it exits.\n-    ///\n-    /// If, after all the destructors have been called for all non-NULL values\n-    /// with associated destructors, there are still some non-NULL values with\n-    /// associated destructors, then the process is repeated.\n-    /// If, after at least {PTHREAD_DESTRUCTOR_ITERATIONS} iterations of destructor\n-    /// calls for outstanding non-NULL values, there are still some non-NULL values\n-    /// with associated destructors, implementations may stop calling destructors,\n-    /// or they may continue calling destructors until no non-NULL values with\n-    /// associated destructors exist, even though this might result in an infinite loop.\n-    pub(crate) fn fetch_tls_dtor(&mut self, key: Option<TlsKey>) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n-        use std::collections::Bound::*;\n-        let start = match key {\n-            Some(key) => Excluded(key),\n-            None => Unbounded,\n-        };\n-        for (&key, &mut TlsEntry { ref mut data, dtor }) in self.thread_local.range_mut((start, Unbounded)) {\n-            if !data.is_null()? {\n-                if let Some(dtor) = dtor {\n-                    let ret = Some((dtor, *data, key));\n-                    *data = Pointer::null();\n-                    return Ok(ret);\n-                }\n-            }\n-        }\n-        return Ok(None);\n-    }\n }\n \n /// Locking\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub(crate) fn check_locks(&self, ptr: MemoryPointer, len: u64, access: AccessKind) -> EvalResult<'tcx> {\n         if len == 0 {\n             return Ok(())\n@@ -656,8 +586,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n }\n \n /// Allocation accessors\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n+    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::MemoryKinds>> {\n         match self.alloc_map.get(&id) {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n@@ -667,7 +597,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n     \n-    fn get_mut_unchecked(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n+    fn get_mut_unchecked(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n         match self.alloc_map.get_mut(&id) {\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n@@ -677,7 +607,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n+    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n         let alloc = self.get_mut_unchecked(id)?;\n         if alloc.mutable == Mutability::Mutable {\n             Ok(alloc)\n@@ -747,13 +677,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             }\n \n             let immutable = match (alloc.kind, alloc.mutable) {\n-                (Kind::UninitializedStatic, _) => \" (static in the process of initialization)\",\n-                (Kind::Static, Mutability::Mutable) => \" (static mut)\",\n-                (Kind::Static, Mutability::Immutable) => \" (immutable)\",\n-                (Kind::Env, _) => \" (env var)\",\n-                (Kind::C, _) => \" (malloc)\",\n-                (Kind::Rust, _) => \" (heap)\",\n-                (Kind::Stack, _) => \" (stack)\",\n+                (Kind::UninitializedStatic, _) => \" (static in the process of initialization)\".to_owned(),\n+                (Kind::Static, Mutability::Mutable) => \" (static mut)\".to_owned(),\n+                (Kind::Static, Mutability::Immutable) => \" (immutable)\".to_owned(),\n+                (Kind::Machine(m), _) => format!(\" ({:?})\", m),\n+                (Kind::Stack, _) => \" (stack)\".to_owned(),\n             };\n             trace!(\"{}({} bytes, alignment {}){}\", msg, alloc.bytes.len(), alloc.align, immutable);\n \n@@ -794,7 +722,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n }\n \n /// Byte accessors\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     fn get_bytes_unchecked(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n         if self.reads_are_aligned.get() {\n@@ -847,7 +775,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n }\n \n /// Reading and writing\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     /// mark an allocation as being the entry point to a static (see `static_alloc` field)\n     pub fn mark_static(&mut self, alloc_id: AllocId) {\n         trace!(\"mark_static: {:?}\", alloc_id);\n@@ -877,17 +805,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                     // E.g. `const Foo: &u32 = &1;` refers to the temp local that stores the `1`\n                     Kind::Stack |\n                     // The entire point of this function\n-                    Kind::UninitializedStatic |\n-                    // In the future const eval will allow heap allocations so we'll need to protect them\n-                    // from deallocation, too\n-                    Kind::Rust |\n-                    Kind::C => {},\n+                    Kind::UninitializedStatic => {},\n+                    Kind::Machine(m) => M::mark_static_initialized(m)?,\n                     Kind::Static => {\n                         trace!(\"mark_static_initalized: skipping already initialized static referred to by static currently being initialized\");\n                         return Ok(());\n                     },\n-                    // FIXME: This could be allowed, but not for env vars set during miri execution\n-                    Kind::Env => return Err(EvalError::Unimplemented(\"statics can't refer to env vars\".to_owned())),\n                 }\n                 *kind = Kind::Static;\n                 *mutable = mutability;\n@@ -1157,7 +1080,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n }\n \n /// Relocations\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     fn relocations(&self, ptr: MemoryPointer, size: u64)\n         -> EvalResult<'tcx, btree_map::Range<u64, AllocId>>\n     {\n@@ -1212,7 +1135,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n }\n \n /// Undefined bytes\n-impl<'a, 'tcx> Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     // FIXME(solson): This is a very naive, slow version.\n     fn copy_undef_mask(&mut self, src: MemoryPointer, dest: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n@@ -1395,9 +1318,9 @@ fn bit_index(bits: u64) -> (usize, usize) {\n // Unaligned accesses\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub(crate) trait HasMemory<'a, 'tcx> {\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx>;\n-    fn memory(&self) -> &Memory<'a, 'tcx>;\n+pub trait HasMemory<'a, 'tcx, M: Machine<'tcx>> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M>;\n+    fn memory(&self) -> &Memory<'a, 'tcx, M>;\n \n     // These are not supposed to be overriden.\n     fn read_maybe_aligned<F, T>(&self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n@@ -1434,26 +1357,26 @@ pub(crate) trait HasMemory<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HasMemory<'a, 'tcx> for Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for Memory<'a, 'tcx, M> {\n     #[inline]\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n         self\n     }\n \n     #[inline]\n-    fn memory(&self) -> &Memory<'a, 'tcx> {\n+    fn memory(&self) -> &Memory<'a, 'tcx, M> {\n         self\n     }\n }\n \n-impl<'a, 'tcx> HasMemory<'a, 'tcx> for EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> HasMemory<'a, 'tcx, M> for EvalContext<'a, 'tcx, M> {\n     #[inline]\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx, M> {\n         &mut self.memory\n     }\n \n     #[inline]\n-    fn memory(&self) -> &Memory<'a, 'tcx> {\n+    fn memory(&self) -> &Memory<'a, 'tcx, M> {\n         &self.memory\n     }\n }\n@@ -1515,20 +1438,20 @@ pub trait PointerArithmetic : layout::HasDataLayout {\n \n impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n \n-impl<'a, 'tcx> layout::HasDataLayout for &'a Memory<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'a Memory<'a, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.layout\n     }\n }\n-impl<'a, 'tcx> layout::HasDataLayout for &'a EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'a EvalContext<'a, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.memory().layout\n     }\n }\n \n-impl<'c, 'b, 'a, 'tcx> layout::HasDataLayout for &'c &'b mut EvalContext<'a, 'tcx> {\n+impl<'c, 'b, 'a, 'tcx, M: Machine<'tcx>> layout::HasDataLayout for &'c &'b mut EvalContext<'a, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.memory().layout"}, {"sha": "236e708d96fb8729b41ae604ed9dafb130c5a001", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -1,69 +1,70 @@\n-#![feature(\n-    i128_type,\n-    rustc_private,\n-    conservative_impl_trait,\n-)]\n-\n-// From rustc.\n-#[macro_use]\n-extern crate log;\n-extern crate log_settings;\n-#[macro_use]\n-extern crate rustc;\n-extern crate rustc_const_math;\n-extern crate rustc_data_structures;\n-extern crate syntax;\n-\n-// From crates.io.\n-extern crate byteorder;\n-#[macro_use]\n-extern crate lazy_static;\n-extern crate regex;\n+//! An interpreter for MIR used in CTFE and by miri\n \n mod cast;\n mod const_eval;\n mod error;\n mod eval_context;\n mod lvalue;\n mod validation;\n+mod machine;\n mod memory;\n mod operator;\n mod step;\n mod terminator;\n mod traits;\n mod value;\n \n-pub use error::{\n+pub use self::error::{\n     EvalError,\n     EvalResult,\n };\n \n-pub use eval_context::{\n+pub use self::eval_context::{\n     EvalContext,\n     Frame,\n     ResourceLimits,\n     StackPopCleanup,\n-    eval_main,\n+    DynamicLifetime,\n+    TyAndPacked,\n };\n \n-pub use lvalue::{\n+pub use self::lvalue::{\n     Lvalue,\n     LvalueExtra,\n+    Global,\n+    GlobalId,\n };\n \n-pub use memory::{\n+pub use self::memory::{\n     AllocId,\n     Memory,\n     MemoryPointer,\n+    Kind,\n+    HasMemory,\n+};\n+\n+use self::memory::{\n+    PointerArithmetic,\n+    LockInfo,\n+    AccessKind,\n };\n \n-pub use value::{\n+pub use self::value::{\n     PrimVal,\n     PrimValKind,\n     Value,\n     Pointer,\n };\n \n-pub use const_eval::{\n+pub use self::const_eval::{\n     eval_body_as_integer,\n+    eval_body_as_primval,\n+};\n+\n+pub use self::machine::{\n+    Machine,\n+};\n+\n+pub use self::validation::{\n+    ValidationQuery,\n };"}, {"sha": "c4c0055d2012016b49de5a9c6cba143fdf7be02c", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 21, "deletions": 124, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -1,11 +1,14 @@\n use rustc::mir;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::Ty;\n \n-use error::{EvalError, EvalResult};\n-use eval_context::EvalContext;\n-use memory::MemoryPointer;\n-use lvalue::Lvalue;\n-use value::{\n+use super::{\n+    EvalError, EvalResult,\n+    EvalContext,\n+    Lvalue,\n+    Machine,\n+};\n+\n+use super::value::{\n     PrimVal,\n     PrimValKind,\n     Value,\n@@ -15,7 +18,7 @@ use value::{\n     f64_to_bytes,\n };\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n@@ -31,7 +34,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n-    pub(super) fn intrinsic_with_overflow(\n+    pub fn intrinsic_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n@@ -46,7 +49,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     /// Applies the binary operation `op` to the arguments and writes the result to the\n     /// destination. Returns `true` if the operation overflowed.\n-    pub(super) fn intrinsic_overflowing(\n+    pub fn intrinsic_overflowing(\n         &mut self,\n         op: mir::BinOp,\n         left: &mir::Operand<'tcx>,\n@@ -72,7 +75,7 @@ macro_rules! int_arithmetic {\n     ($kind:expr, $int_op:ident, $l:expr, $r:expr) => ({\n         let l = $l;\n         let r = $r;\n-        use value::PrimValKind::*;\n+        use super::PrimValKind::*;\n         match $kind {\n             I8  => overflow!($int_op, l as i8,  r as i8),\n             I16 => overflow!($int_op, l as i16, r as i16),\n@@ -131,7 +134,7 @@ macro_rules! f64_arithmetic {\n     )\n }\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     /// Returns the result of the specified operation and whether it overflowed.\n     pub fn binary_op(\n         &self,\n@@ -142,82 +145,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         right_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         use rustc::mir::BinOp::*;\n-        use value::PrimValKind::*;\n+        use super::PrimValKind::*;\n \n         let left_kind  = self.ty_to_primval_kind(left_ty)?;\n         let right_kind = self.ty_to_primval_kind(right_ty)?;\n         //trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n \n         // I: Handle operations that support pointers\n-        let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n-        let isize = PrimValKind::from_int_size(self.memory.pointer_size());\n         if !left_kind.is_float() && !right_kind.is_float() {\n-            if (!left.is_bytes() && !right.is_bytes()) && self.const_env() {\n-                return Err(EvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()));\n-            }\n-            match bin_op {\n-                Offset if left_kind == Ptr && right_kind == usize => {\n-                    let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-                    let ptr = self.pointer_offset(left.into(), pointee_ty, right.to_bytes()? as i64)?;\n-                    return Ok((ptr.into_inner_primval(), false));\n-                },\n-                // These work on anything\n-                Eq if left_kind == right_kind => {\n-                    let result = match (left, right) {\n-                        (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left == right,\n-                        (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left == right,\n-                        (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n-                        _ => false,\n-                    };\n-                    return Ok((PrimVal::from_bool(result), false));\n-                }\n-                Ne if left_kind == right_kind => {\n-                    let result = match (left, right) {\n-                        (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left != right,\n-                        (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left != right,\n-                        (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n-                        _ => true,\n-                    };\n-                    return Ok((PrimVal::from_bool(result), false));\n-                }\n-                // These need both pointers to be in the same allocation\n-                Lt | Le | Gt | Ge | Sub\n-                if left_kind == right_kind\n-                && (left_kind == Ptr || left_kind == usize || left_kind == isize)\n-                && left.is_ptr() && right.is_ptr() => {\n-                    let left = left.to_ptr()?;\n-                    let right = right.to_ptr()?;\n-                    if left.alloc_id == right.alloc_id {\n-                        let res = match bin_op {\n-                            Lt => left.offset < right.offset,\n-                            Le => left.offset <= right.offset,\n-                            Gt => left.offset > right.offset,\n-                            Ge => left.offset >= right.offset,\n-                            Sub => {\n-                                return int_arithmetic!(left_kind, overflowing_sub, left.offset, right.offset);\n-                            }\n-                            _ => bug!(\"We already established it has to be one of these operators.\"),\n-                        };\n-                        return Ok((PrimVal::from_bool(res), false));\n-                    } else {\n-                        // Both are pointers, but from different allocations.\n-                        return Err(EvalError::InvalidPointerMath);\n-                    }\n-                }\n-                // These work if one operand is a pointer, the other an integer\n-                Add | BitAnd | Sub\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n-                && left.is_ptr() && right.is_bytes() => {\n-                    // Cast to i128 is fine as we checked the kind to be ptr-sized\n-                    return self.ptr_int_arithmetic(bin_op, left.to_ptr()?, right.to_bytes()? as i128, left_kind == isize);\n-                }\n-                Add | BitAnd\n-                if left_kind == right_kind && (left_kind == usize || left_kind == isize)\n-                && left.is_bytes() && right.is_ptr() => {\n-                    // This is a commutative operation, just swap the operands\n-                    return self.ptr_int_arithmetic(bin_op, right.to_ptr()?, left.to_bytes()? as i128, left_kind == isize);\n-                }\n-                _ => {}\n+            if let Some(handled) = M::try_ptr_op(self, bin_op, left, left_ty, right, right_ty)? {\n+                return Ok(handled);\n             }\n         }\n \n@@ -266,6 +203,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (Div, F64) => f64_arithmetic!(/, l, r),\n             (Rem, F64) => f64_arithmetic!(%, l, r),\n \n+            (Eq, _) => PrimVal::from_bool(l == r),\n+            (Ne, _) => PrimVal::from_bool(l != r),\n+\n             (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n             (Lt, _) => PrimVal::from_bool(l <  r),\n             (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n@@ -293,49 +233,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         Ok((val, false))\n     }\n-\n-    fn ptr_int_arithmetic(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: MemoryPointer,\n-        right: i128,\n-        signed: bool,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n-        use rustc::mir::BinOp::*;\n-\n-        fn map_to_primval((res, over) : (MemoryPointer, bool)) -> (PrimVal, bool) {\n-            (PrimVal::Ptr(res), over)\n-        }\n-\n-        Ok(match bin_op {\n-            Sub =>\n-                // The only way this can overflow is by underflowing, so signdeness of the right operands does not matter\n-                map_to_primval(left.overflowing_signed_offset(-right, self)),\n-            Add if signed =>\n-                map_to_primval(left.overflowing_signed_offset(right, self)),\n-            Add if !signed =>\n-                map_to_primval(left.overflowing_offset(right as u64, self)),\n-\n-            BitAnd if !signed => {\n-                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align - 1);\n-                let right = right as u64;\n-                if right & base_mask == base_mask {\n-                    // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n-                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, left.offset & right)), false)\n-                } else if right & base_mask == 0 {\n-                    // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n-                    (PrimVal::from_u128((left.offset & right) as u128), false)\n-                } else {\n-                    return Err(EvalError::ReadPointerAsBytes);\n-                }\n-            }\n-\n-            _ => {\n-                let msg = format!(\"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\", bin_op, left, right, if signed { \"signed\" } else { \"unsigned\" });\n-                return Err(EvalError::Unimplemented(msg));\n-            }\n-        })\n-    }\n }\n \n pub fn unary_op<'tcx>(\n@@ -344,7 +241,7 @@ pub fn unary_op<'tcx>(\n     val_kind: PrimValKind,\n ) -> EvalResult<'tcx, PrimVal> {\n     use rustc::mir::UnOp::*;\n-    use value::PrimValKind::*;\n+    use super::PrimValKind::*;\n \n     let bytes = val.to_bytes()?;\n "}, {"sha": "06d9d8b07fa3ff9421b67cf7eb4c7da53e08b1af", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 74, "deletions": 64, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -11,16 +11,19 @@ use rustc::ty;\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n \n+use super::{\n+    EvalResult, EvalError,\n+    EvalContext, StackPopCleanup, TyAndPacked,\n+    Global, GlobalId, Lvalue,\n+    Value, PrimVal,\n+    HasMemory,\n+    Machine,\n+};\n+\n use syntax::codemap::Span;\n use syntax::ast::Mutability;\n \n-use error::{EvalResult, EvalError};\n-use eval_context::{EvalContext, StackPopCleanup, TyAndPacked};\n-use lvalue::{Global, GlobalId, Lvalue};\n-use value::{Value, PrimVal};\n-use memory::HasMemory;\n-\n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx> {\n         self.steps_remaining = self.steps_remaining.saturating_sub(n);\n         if self.steps_remaining > 0 {\n@@ -152,83 +155,89 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n         Ok(())\n     }\n-}\n \n-// WARNING: make sure that any methods implemented on this type don't ever access ecx.stack\n-// this includes any method that might access the stack\n-// basically don't call anything other than `load_mir`, `alloc_ptr`, `push_stack_frame`\n-// The reason for this is, that `push_stack_frame` modifies the stack out of obvious reasons\n-struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n-    span: Span,\n-    ecx: &'a mut EvalContext<'b, 'tcx>,\n-    mir: &'tcx mir::Mir<'tcx>,\n-    instance: ty::Instance<'tcx>,\n-    new_constants: &'a mut EvalResult<'tcx, u64>,\n-}\n-\n-impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n+    /// returns `true` if a stackframe was pushed\n     fn global_item(\n         &mut self,\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         span: Span,\n         mutability: Mutability,\n-    ) {\n-        let instance = self.ecx.resolve_associated_const(def_id, substs);\n+    ) -> EvalResult<'tcx, bool> {\n+        let instance = self.resolve_associated_const(def_id, substs);\n         let cid = GlobalId { instance, promoted: None };\n-        if self.ecx.globals.contains_key(&cid) {\n-            return;\n+        if self.globals.contains_key(&cid) {\n+            return Ok(false);\n         }\n-        if self.ecx.tcx.has_attr(def_id, \"linkage\") {\n+        if self.tcx.has_attr(def_id, \"linkage\") {\n+            // FIXME: check that it's `#[linkage = \"extern_weak\"]`\n             trace!(\"Initializing an extern global with NULL\");\n-            self.ecx.globals.insert(cid, Global::initialized(self.ecx.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), mutability));\n-            return;\n+            self.globals.insert(cid, Global::initialized(self.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), mutability));\n+            return Ok(false);\n         }\n-        self.try(|this| {\n-            let mir = this.ecx.load_mir(instance.def)?;\n-            this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n-            let internally_mutable = !mir.return_ty.is_freeze(\n-                    this.ecx.tcx,\n-                    ty::ParamEnv::empty(Reveal::All),\n-                    span);\n-            let mutability = if mutability == Mutability::Mutable || internally_mutable {\n-                Mutability::Mutable\n-            } else {\n-                Mutability::Immutable\n-            };\n-            let cleanup = StackPopCleanup::MarkStatic(mutability);\n-            let name = ty::tls::with(|tcx| tcx.item_path_str(def_id));\n-            trace!(\"pushing stack frame for global: {}\", name);\n-            this.ecx.push_stack_frame(\n-                instance,\n-                span,\n-                mir,\n-                Lvalue::Global(cid),\n-                cleanup,\n-            )\n-        });\n+        let mir = self.load_mir(instance.def)?;\n+        self.globals.insert(cid, Global::uninitialized(mir.return_ty));\n+        let internally_mutable = !mir.return_ty.is_freeze(\n+                self.tcx,\n+                ty::ParamEnv::empty(Reveal::All),\n+                span);\n+        let mutability = if mutability == Mutability::Mutable || internally_mutable {\n+            Mutability::Mutable\n+        } else {\n+            Mutability::Immutable\n+        };\n+        let cleanup = StackPopCleanup::MarkStatic(mutability);\n+        let name = ty::tls::with(|tcx| tcx.item_path_str(def_id));\n+        trace!(\"pushing stack frame for global: {}\", name);\n+        self.push_stack_frame(\n+            instance,\n+            span,\n+            mir,\n+            Lvalue::Global(cid),\n+            cleanup,\n+        )?;\n+        Ok(true)\n     }\n+}\n \n-    fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx>>(&mut self, f: F) {\n-        if let Ok(ref mut n) = *self.new_constants {\n-            *n += 1;\n-        } else {\n-            return;\n-        }\n-        if let Err(e) = f(self) {\n-            *self.new_constants = Err(e);\n+// WARNING: make sure that any methods implemented on this type don't ever access ecx.stack\n+// this includes any method that might access the stack\n+// basically don't call anything other than `load_mir`, `alloc_ptr`, `push_stack_frame`\n+// The reason for this is, that `push_stack_frame` modifies the stack out of obvious reasons\n+struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b, M: Machine<'tcx> + 'a> {\n+    span: Span,\n+    ecx: &'a mut EvalContext<'b, 'tcx, M>,\n+    mir: &'tcx mir::Mir<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    new_constants: &'a mut EvalResult<'tcx, u64>,\n+}\n+\n+impl<'a, 'b, 'tcx, M: Machine<'tcx>> ConstantExtractor<'a, 'b, 'tcx, M> {\n+    fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, bool>>(&mut self, f: F) {\n+        // previous constant errored\n+        let n = match *self.new_constants {\n+            Ok(n) => n,\n+            Err(_) => return,\n+        };\n+        match f(self) {\n+            // everything ok + a new stackframe\n+            Ok(true) => *self.new_constants = Ok(n + 1),\n+            // constant correctly evaluated, but no new stackframe\n+            Ok(false) => {},\n+            // constant eval errored\n+            Err(err) => *self.new_constants = Err(err),\n         }\n     }\n }\n \n-impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx, M> {\n     fn visit_constant(&mut self, constant: &mir::Constant<'tcx>, location: mir::Location) {\n         self.super_constant(constant, location);\n         match constant.literal {\n             // already computed by rustc\n             mir::Literal::Value { .. } => {}\n             mir::Literal::Item { def_id, substs } => {\n-                self.global_item(def_id, substs, constant.span, Mutability::Immutable);\n+                self.try(|this| this.ecx.global_item(def_id, substs, constant.span, Mutability::Immutable));\n             },\n             mir::Literal::Promoted { index } => {\n                 let cid = GlobalId {\n@@ -248,7 +257,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                                               mir,\n                                               Lvalue::Global(cid),\n                                               StackPopCleanup::MarkStatic(Mutability::Immutable),\n-                    )\n+                    )?;\n+                    Ok(true)\n                 });\n             }\n         }\n@@ -268,7 +278,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             if let Some(node_item) = self.ecx.tcx.hir.get_if_local(def_id) {\n                 if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = node_item {\n                     if let hir::ItemStatic(_, m, _) = *node {\n-                        self.global_item(def_id, substs, span, if m == hir::MutMutable { Mutability::Mutable } else { Mutability::Immutable });\n+                        self.try(|this| this.ecx.global_item(def_id, substs, span, if m == hir::MutMutable { Mutability::Mutable } else { Mutability::Immutable }));\n                         return;\n                     } else {\n                         bug!(\"static def id doesn't point to static\");\n@@ -279,7 +289,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             } else {\n                 let def = self.ecx.tcx.describe_def(def_id).expect(\"static not found\");\n                 if let hir::def::Def::Static(_, mutable) = def {\n-                    self.global_item(def_id, substs, span, if mutable { Mutability::Mutable } else { Mutability::Immutable });\n+                    self.try(|this| this.ecx.global_item(def_id, substs, span, if mutable { Mutability::Mutable } else { Mutability::Immutable }));\n                 } else {\n                     bug!(\"static found but isn't a static: {:?}\", def);\n                 }"}, {"sha": "5f4bc0b1bd9d5258e42dc3e6b0c11a17278b691d", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -2,13 +2,15 @@ use rustc::mir;\n use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n \n-use error::EvalResult;\n-use eval_context::{EvalContext, StackPopCleanup};\n-use lvalue::{Lvalue, LvalueExtra};\n-use value::PrimVal;\n-use value::Value;\n+use interpret::{\n+    EvalResult,\n+    EvalContext, StackPopCleanup,\n+    Lvalue, LvalueExtra,\n+    PrimVal, Value,\n+    Machine,\n+};\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n         trace!(\"drop_lvalue: {:#?}\", lval);\n         // We take the address of the object.  This may well be unaligned, which is fine for us here."}, {"sha": "3ccc2ee0fb4a32a43310e89fd61f66be7c32729b", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 23, "deletions": 551, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -1,26 +1,26 @@\n-use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n use rustc::ty::{self, TypeVariants, Ty};\n use rustc::ty::layout::Layout;\n use syntax::codemap::Span;\n-use syntax::attr;\n use syntax::abi::Abi;\n \n-use error::{EvalError, EvalResult};\n-use eval_context::{EvalContext, IntegerExt, StackPopCleanup, TyAndPacked, is_inhabited, self};\n-use lvalue::Lvalue;\n-use memory::{MemoryPointer, TlsKey, Kind, HasMemory};\n-use value::{PrimVal, Value};\n-use rustc_data_structures::indexed_vec::Idx;\n-use const_eval;\n+use super::{\n+    EvalError, EvalResult,\n+    EvalContext, eval_context, TyAndPacked,\n+    Lvalue,\n+    MemoryPointer,\n+    PrimVal, Value,\n+    Machine,\n+    HasMemory,\n+};\n+use super::eval_context::IntegerExt;\n \n-use std::mem;\n+use rustc_data_structures::indexed_vec::Idx;\n \n mod drop;\n-mod intrinsic;\n \n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub(super) fn goto_block(&mut self, target: mir::BasicBlock) {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+    pub fn goto_block(&mut self, target: mir::BasicBlock) {\n         self.frame_mut().block = target;\n         self.frame_mut().stmt = 0;\n     }\n@@ -39,9 +39,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Goto { target } => self.goto_block(target),\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(\"branching (if, match, loop, ...)\".to_string()));\n-                }\n+                // FIXME(CTFE): forbid branching\n                 let discr_val = self.eval_operand(discr)?;\n                 let discr_ty = self.operand_ty(discr);\n                 let discr_prim = self.value_to_primval(discr_val, discr_ty)?;\n@@ -99,9 +97,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Drop { ref location, target, .. } => {\n                 trace!(\"TerminatorKind::drop: {:?}, {:?}\", location, self.substs());\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(\"invoking `Drop::drop`\".to_string()));\n-                }\n+                // FIXME(CTFE): forbid drop in const eval\n                 let lval = self.eval_lvalue(location)?;\n                 let ty = self.lvalue_ty(location);\n                 self.goto_block(target);\n@@ -221,11 +217,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => return Err(EvalError::Unreachable),\n                 };\n                 let ty = sig.output();\n-                if !is_inhabited(self.tcx, ty) {\n+                if !eval_context::is_inhabited(self.tcx, ty) {\n                     return Err(EvalError::Unreachable);\n                 }\n                 let layout = self.type_layout(ty)?;\n-                self.call_intrinsic(instance, arg_operands, ret, ty, layout, target)?;\n+                M::call_intrinsic(self, instance, arg_operands, ret, ty, layout, target)?;\n                 self.dump_local(ret);\n                 Ok(())\n             },\n@@ -236,7 +232,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n-                if self.eval_fn_call_inner(\n+                if M::eval_fn_call(\n+                    self,\n                     instance,\n                     destination,\n                     arg_operands,\n@@ -279,7 +276,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n \n                 // Push the stack frame, and potentially be entirely done if the call got hooked\n-                if self.eval_fn_call_inner(\n+                if M::eval_fn_call(\n+                    self,\n                     instance,\n                     destination,\n                     arg_operands,\n@@ -372,7 +370,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let arg_ty = self.operand_ty(arg);\n                     args.push((arg_val, arg_ty));\n                 }\n-                if self.eval_fn_call_inner(\n+                if M::eval_fn_call(\n+                    self,\n                     instance,\n                     destination,\n                     arg_operands,\n@@ -419,51 +418,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    /// Returns Ok(true) when the function was handled completely due to mir not being available\n-    fn eval_fn_call_inner(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n-        span: Span,\n-        sig: ty::FnSig<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        trace!(\"eval_fn_call_inner: {:#?}, {:#?}\", instance, destination);\n-\n-        // Only trait methods can have a Self parameter.\n-\n-        let mir = match self.load_mir(instance.def) {\n-            Ok(mir) => mir,\n-            Err(EvalError::NoMirFor(path)) => {\n-                if self.const_env() {\n-                    return Err(EvalError::NeedsRfc(format!(\"calling extern function `{}`\", path)));\n-                }\n-                self.call_missing_fn(instance, destination, arg_operands, sig, path)?;\n-                return Ok(true);\n-            },\n-            Err(other) => return Err(other),\n-        };\n-\n-        if self.const_env() && !self.tcx.is_const_fn(instance.def_id()) {\n-            return Err(EvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)));\n-        }\n-        \n-        let (return_lvalue, return_to_block) = match destination {\n-            Some((lvalue, block)) => (lvalue, StackPopCleanup::Goto(block)),\n-            None => (Lvalue::undef(), StackPopCleanup::None),\n-        };\n-\n-        self.push_stack_frame(\n-            instance,\n-            span,\n-            mir,\n-            return_lvalue,\n-            return_to_block,\n-        )?;\n-\n-        Ok(false)\n-    }\n-\n     pub fn read_discriminant_value(&self, adt_ptr: MemoryPointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty)?;\n@@ -514,486 +468,4 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         assert!(nndiscr == 0 || nndiscr == 1);\n         Ok(if not_null { nndiscr } else { 1 - nndiscr })\n     }\n-    \n-    /// Returns Ok() when the function was handled, fail otherwise\n-    fn call_missing_fn(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        destination: Option<(Lvalue<'tcx>, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n-        sig: ty::FnSig<'tcx>,\n-        path: String,\n-    ) -> EvalResult<'tcx> {\n-        // In some cases in non-MIR libstd-mode, not having a destination is legit.  Handle these early.\n-        match &path[..] {\n-            \"std::panicking::rust_panic_with_hook\" |\n-            \"std::rt::begin_panic_fmt\" => return Err(EvalError::Panic),\n-            _ => {},\n-        }\n-\n-        let dest_ty = sig.output();\n-        let (dest, dest_block) = destination.ok_or_else(|| EvalError::NoMirFor(path.clone()))?;\n-\n-        if sig.abi == Abi::C {\n-            // An external C function\n-            // TODO: That functions actually has a similar preamble to what follows here.  May make sense to\n-            // unify these two mechanisms for \"hooking into missing functions\".\n-            self.call_c_abi(instance.def_id(), arg_operands, dest, dest_ty, dest_block)?;\n-            return Ok(());\n-        }\n-\n-        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n-        let args = args_res?;\n-\n-        let usize = self.tcx.types.usize;\n-    \n-        match &path[..] {\n-            // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n-            \"alloc::heap::::__rust_alloc\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::heap::::__rust_alloc_zeroed\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                if size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                let ptr = self.memory.allocate(size, align, Kind::Rust)?;\n-                self.memory.write_repeat(ptr.into(), 0, size)?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-            }\n-            \"alloc::heap::::__rust_dealloc\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if old_size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(align));\n-                }\n-                self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n-            }\n-            \"alloc::heap::::__rust_realloc\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n-                let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n-                if old_size == 0 || new_size == 0 {\n-                    return Err(EvalError::HeapAllocZeroBytes);\n-                }\n-                if !old_align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(old_align));\n-                }\n-                if !new_align.is_power_of_two() {\n-                    return Err(EvalError::HeapAllocNonPowerOfTwoAlignment(new_align));\n-                }\n-                let new_ptr = self.memory.reallocate(ptr, old_size, old_align, new_size, new_align, Kind::Rust)?;\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n-            }\n-\n-            // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n-            // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n-            \"std::io::_print\" => {\n-                trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n-            }\n-            \"std::thread::Builder::new\" => return Err(EvalError::Unimplemented(\"miri does not support threading\".to_owned())),\n-            \"std::env::args\" => return Err(EvalError::Unimplemented(\"miri does not support program arguments\".to_owned())),\n-            \"std::panicking::panicking\" |\n-            \"std::rt::panicking\" => {\n-                // we abort on panic -> `std::rt::panicking` always returns false\n-                let bool = self.tcx.types.bool;\n-                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n-            }\n-            _ => return Err(EvalError::NoMirFor(path)),\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        self.dump_local(dest);\n-        self.goto_block(dest_block);\n-        return Ok(());\n-    }\n-\n-    fn call_c_abi(\n-        &mut self,\n-        def_id: DefId,\n-        arg_operands: &[mir::Operand<'tcx>],\n-        dest: Lvalue<'tcx>,\n-        dest_ty: Ty<'tcx>,\n-        dest_block: mir::BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        let name = self.tcx.item_name(def_id);\n-        let attrs = self.tcx.get_attrs(def_id);\n-        let link_name = attr::first_attr_value_str_by_name(&attrs, \"link_name\")\n-            .unwrap_or(name)\n-            .as_str();\n-\n-        let args_res: EvalResult<Vec<Value>> = arg_operands.iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n-        let args = args_res?;\n-\n-        let usize = self.tcx.types.usize;\n-\n-        match &link_name[..] {\n-            \"malloc\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                if size == 0 {\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    let align = self.memory.pointer_size();\n-                    let ptr = self.memory.allocate(size, align, Kind::C)?;\n-                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n-                }\n-            }\n-\n-            \"free\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                if !ptr.is_null()? {\n-                    self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n-                }\n-            }\n-\n-            \"syscall\" => {\n-                match self.value_to_primval(args[0], usize)?.to_u64()? {\n-                    511 => return Err(EvalError::Unimplemented(\"miri does not support random number generators\".to_owned())),\n-                    id => return Err(EvalError::Unimplemented(format!(\"miri does not support syscall id {}\", id))),\n-                }\n-            }\n-\n-            \"dlsym\" => {\n-                let _handle = args[0].into_ptr(&self.memory)?;\n-                let symbol = args[1].into_ptr(&self.memory)?.to_ptr()?;\n-                let symbol_name = self.memory.read_c_str(symbol)?;\n-                let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n-                let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n-                return Err(EvalError::Unimplemented(format!(\"miri does not support dynamically loading libraries (requested symbol: {})\", symbol_name)));\n-            }\n-\n-            \"__rust_maybe_catch_panic\" => {\n-                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n-                // We abort on panic, so not much is going on here, but we still have to call the closure\n-                let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                let f = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                let data = args[1].into_ptr(&self.memory)?;\n-                let f_instance = self.memory.get_fn(f)?;\n-                self.write_null(dest, dest_ty)?;\n-\n-                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n-                // and of course eval_main.\n-                let mir = self.load_mir(f_instance.def)?;\n-                self.push_stack_frame(\n-                    f_instance,\n-                    mir.span,\n-                    mir,\n-                    Lvalue::undef(),\n-                    StackPopCleanup::Goto(dest_block),\n-                )?;\n-\n-                let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n-                let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                self.write_ptr(arg_dest, data, u8_ptr_ty)?;\n-\n-                // We ourselves return 0\n-                self.write_null(dest, dest_ty)?;\n-\n-                // Don't fall through\n-                return Ok(());\n-            }\n-\n-            \"__rust_start_panic\" => {\n-                return Err(EvalError::Panic);\n-            }\n-\n-            \"memcmp\" => {\n-                let left = args[0].into_ptr(&self.memory)?;\n-                let right = args[1].into_ptr(&self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n-\n-                let result = {\n-                    let left_bytes = self.memory.read_bytes(left, n)?;\n-                    let right_bytes = self.memory.read_bytes(right, n)?;\n-\n-                    use std::cmp::Ordering::*;\n-                    match left_bytes.cmp(right_bytes) {\n-                        Less => -1i8,\n-                        Equal => 0,\n-                        Greater => 1,\n-                    }\n-                };\n-\n-                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n-            }\n-\n-            \"memrchr\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(num - idx as u64 - 1, &self)?;\n-                    self.write_ptr(dest, new_ptr, dest_ty)?;\n-                } else {\n-                    self.write_null(dest, dest_ty)?;\n-                }\n-            }\n-\n-            \"memchr\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?;\n-                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n-                    let new_ptr = ptr.offset(idx as u64, &self)?;\n-                    self.write_ptr(dest, new_ptr, dest_ty)?;\n-                } else {\n-                    self.write_null(dest, dest_ty)?;\n-                }\n-            }\n-\n-            \"getenv\" => {\n-                let result = {\n-                    let name_ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                    let name = self.memory.read_c_str(name_ptr)?;\n-                    match self.env_vars.get(name) {\n-                        Some(&var) => PrimVal::Ptr(var),\n-                        None => PrimVal::Bytes(0),\n-                    }\n-                };\n-                self.write_primval(dest, result, dest_ty)?;\n-            }\n-\n-            \"unsetenv\" => {\n-                let mut success = None;\n-                {\n-                    let name_ptr = args[0].into_ptr(&self.memory)?;\n-                    if !name_ptr.is_null()? {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            success = Some(self.env_vars.remove(name));\n-                        }\n-                    }\n-                }\n-                if let Some(old) = success {\n-                    if let Some(var) = old {\n-                        self.memory.deallocate(var, None, Kind::Env)?;\n-                    }\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n-                }\n-            }\n-\n-            \"setenv\" => {\n-                let mut new = None;\n-                {\n-                    let name_ptr = args[0].into_ptr(&self.memory)?;\n-                    let value_ptr = args[1].into_ptr(&self.memory)?.to_ptr()?;\n-                    let value = self.memory.read_c_str(value_ptr)?;\n-                    if !name_ptr.is_null()? {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n-                        if !name.is_empty() && !name.contains(&b'=') {\n-                            new = Some((name.to_owned(), value.to_owned()));\n-                        }\n-                    }\n-                }\n-                if let Some((name, value)) = new {\n-                    // +1 for the null terminator\n-                    let value_copy = self.memory.allocate((value.len() + 1) as u64, 1, Kind::Env)?;\n-                    self.memory.write_bytes(value_copy.into(), &value)?;\n-                    let trailing_null = value_copy.offset(value.len() as u64, &self)?.into();\n-                    self.memory.write_bytes(trailing_null, &[0])?;\n-                    if let Some(var) = self.env_vars.insert(name.to_owned(), value_copy) {\n-                        self.memory.deallocate(var, None, Kind::Env)?;\n-                    }\n-                    self.write_null(dest, dest_ty)?;\n-                } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n-                }\n-            }\n-\n-            \"write\" => {\n-                let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let buf = args[1].into_ptr(&self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n-                let result = if fd == 1 || fd == 2 { // stdout/stderr\n-                    use std::io::{self, Write};\n-                \n-                    let buf_cont = self.memory.read_bytes(buf, n)?;\n-                    let res = if fd == 1 { io::stdout().write(buf_cont) } else { io::stderr().write(buf_cont) };\n-                    match res { Ok(n) => n as isize, Err(_) => -1 }\n-                } else {\n-                    info!(\"Ignored output to FD {}\", fd);\n-                    n as isize // pretend it all went well\n-                }; // now result is the value we return back to the program\n-                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n-            }\n-\n-            \"strlen\" => {\n-                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n-                let n = self.memory.read_c_str(ptr)?.len();\n-                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n-            }\n-\n-            // Some things needed for sys::thread initialization to go through\n-            \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n-            }\n-\n-            \"sysconf\" => {\n-                let name = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                trace!(\"sysconf() called with name {}\", name);\n-                // cache the sysconf integers via miri's global cache\n-                let paths = &[\n-                    (&[\"libc\", \"_SC_PAGESIZE\"], PrimVal::Bytes(4096)),\n-                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], PrimVal::from_i128(-1)),\n-                ];\n-                let mut result = None;\n-                for &(path, path_value) in paths {\n-                    if let Ok(instance) = self.resolve_path(path) {\n-                        use lvalue::GlobalId;\n-                        let cid = GlobalId { instance, promoted: None };\n-                        // compute global if not cached\n-                        let val = match self.globals.get(&cid).map(|glob| glob.value) {\n-                            Some(value) => self.value_to_primval(value, usize)?.to_u64()?,\n-                            None => const_eval::eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n-                        };\n-                        if val == name {\n-                            result = Some(path_value);\n-                            break;\n-                        }\n-                    }\n-                }\n-                if let Some(result) = result {\n-                    self.write_primval(dest, result, dest_ty)?;\n-                } else {\n-                    return Err(EvalError::Unimplemented(format!(\"Unimplemented sysconf name: {}\", name)));\n-                }\n-            }\n-\n-            // Hook pthread calls that go to the thread-local storage memory subsystem\n-            \"pthread_key_create\" => {\n-                let key_ptr = args[0].into_ptr(&self.memory)?;\n-\n-                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match args[1].into_ptr(&self.memory)?.into_inner_primval() {\n-                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n-                    PrimVal::Bytes(0) => None,\n-                    PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n-                    PrimVal::Undef => return Err(EvalError::ReadUndefBytes),\n-                };\n-\n-                // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n-                                   .ok_or(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n-                let key_size = {\n-                    let layout = self.type_layout(key_type)?;\n-                    layout.size(&self.tcx.data_layout)\n-                };\n-\n-                // Create key and write it into the memory where key_ptr wants it\n-                let key = self.memory.create_tls_key(dtor) as u128;\n-                if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n-                    return Err(EvalError::OutOfTls);\n-                }\n-                // TODO: Does this need checking for alignment?\n-                self.memory.write_uint(key_ptr.to_ptr()?, key, key_size.bytes())?;\n-\n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-            \"pthread_key_delete\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                self.memory.delete_tls_key(key)?;\n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-            \"pthread_getspecific\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                let ptr = self.memory.load_tls(key)?;\n-                self.write_ptr(dest, ptr, dest_ty)?;\n-            }\n-            \"pthread_setspecific\" => {\n-                // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                let new_ptr = args[1].into_ptr(&self.memory)?;\n-                self.memory.store_tls(key, new_ptr)?;\n-                \n-                // Return success (0)\n-                self.write_null(dest, dest_ty)?;\n-            }\n-\n-            // Stub out all the other pthread calls to just return 0\n-            link_name if link_name.starts_with(\"pthread_\") => {\n-                warn!(\"ignoring C ABI call: {}\", link_name);\n-                self.write_null(dest, dest_ty)?;\n-            },\n-\n-            _ => {\n-                return Err(EvalError::Unimplemented(format!(\"can't call C ABI function: {}\", link_name)));\n-            }\n-        }\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        self.dump_local(dest);\n-        self.goto_block(dest_block);\n-        Ok(())\n-    }\n-\n-    /// Get an instance for a path.\n-    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n-        let cstore = &self.tcx.sess.cstore;\n-\n-        let crates = cstore.crates();\n-        crates.iter()\n-            .find(|&&krate| cstore.crate_name(krate) == path[0])\n-            .and_then(|krate| {\n-                let krate = DefId {\n-                    krate: *krate,\n-                    index: CRATE_DEF_INDEX,\n-                };\n-                let mut items = cstore.item_children(krate, self.tcx.sess);\n-                let mut path_it = path.iter().skip(1).peekable();\n-\n-                while let Some(segment) = path_it.next() {\n-                    for item in &mem::replace(&mut items, vec![]) {\n-                        if item.ident.name == *segment {\n-                            if path_it.peek().is_none() {\n-                                return Some(ty::Instance::mono(self.tcx, item.def.def_id()));\n-                            }\n-\n-                            items = cstore.item_children(item.def.def_id(), self.tcx.sess);\n-                            break;\n-                        }\n-                    }\n-                }\n-                None\n-            })\n-            .ok_or_else(|| {\n-                let path = path.iter()\n-                    .map(|&s| s.to_owned())\n-                    .collect();\n-                EvalError::PathNotFound(path)\n-            })\n-    }\n }"}, {"sha": "903a3040fea3d53ea680aa8ca0717d31d3117f96", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -1,19 +1,19 @@\n use rustc::traits::{self, Reveal};\n-\n-use eval_context::{EvalContext, self};\n-use memory::{MemoryPointer, Kind};\n-use value::{Value, PrimVal};\n-\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n use syntax::codemap::DUMMY_SP;\n use syntax::ast::{self, Mutability};\n \n-use error::{EvalResult, EvalError};\n-\n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+use super::{\n+    EvalResult, EvalError,\n+    EvalContext, eval_context,\n+    MemoryPointer, Kind,\n+    Value, PrimVal,\n+    Machine,\n+};\n \n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn fulfill_obligation(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> traits::Vtable<'tcx, ()> {\n         // Do the initial selection for the obligation. This yields the shallow result we are\n         // looking for -- that is, what specific impl."}, {"sha": "7a2f4c796d30adef740db7e8d61a3ca47ace6f4c", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -10,11 +10,14 @@ use rustc::traits::Reveal;\n use rustc::infer::TransNormalize;\n use rustc::middle::region::CodeExtent;\n \n-use error::{EvalError, EvalResult};\n-use eval_context::{EvalContext, DynamicLifetime};\n-use memory::{AccessKind, LockInfo};\n-use value::{PrimVal, Value};\n-use lvalue::{Lvalue, LvalueExtra};\n+use super::{\n+    EvalError, EvalResult,\n+    EvalContext, DynamicLifetime,\n+    AccessKind, LockInfo,\n+    PrimVal, Value,\n+    Lvalue, LvalueExtra,\n+    Machine,\n+};\n \n // FIXME remove this once it lands in rustc\n #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -54,7 +57,7 @@ impl ValidationMode {\n }\n \n // Validity checks\n-impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn validation_op(&mut self, op: ValidationOp, operand: &ValidationOperand<'tcx, mir::Lvalue<'tcx>>) -> EvalResult<'tcx> {\n         // HACK: Determine if this method is whitelisted and hence we do not perform any validation.\n         {"}, {"sha": "c88d1c22dc9f365e6f7a1e20baf249542296f74d", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -1,10 +1,14 @@\n #![allow(unknown_lints)]\n #![allow(float_cmp)]\n \n-use error::{EvalError, EvalResult};\n-use memory::{Memory, MemoryPointer, HasMemory, PointerArithmetic};\n use rustc::ty::layout::HasDataLayout;\n \n+use super::{\n+    EvalError, EvalResult,\n+    Memory, MemoryPointer, HasMemory, PointerArithmetic,\n+    Machine,\n+};\n+\n pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n     f32::from_bits(bytes as u32)\n }\n@@ -60,7 +64,7 @@ impl<'tcx> Pointer {\n         self.primval\n     }\n \n-    pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self.primval {\n             PrimVal::Bytes(b) => {\n@@ -72,7 +76,7 @@ impl<'tcx> Pointer {\n         }\n     }\n \n-    pub(crate) fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn offset<C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self.primval {\n             PrimVal::Bytes(b) => {\n@@ -84,7 +88,7 @@ impl<'tcx> Pointer {\n         }\n     }\n \n-    pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self.primval {\n             PrimVal::Bytes(b) => {\n@@ -161,13 +165,13 @@ pub enum PrimValKind {\n \n impl<'a, 'tcx: 'a> Value {\n     #[inline]\n-    pub(super) fn by_ref(ptr: Pointer) -> Self {\n+    pub fn by_ref(ptr: Pointer) -> Self {\n         Value::ByRef { ptr, aligned: true }\n     }\n \n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n-    pub(super) fn into_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub fn into_ptr<M: Machine<'tcx>>(&self, mem: &Memory<'a, 'tcx, M>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef { ptr, aligned } => {\n@@ -177,9 +181,9 @@ impl<'a, 'tcx: 'a> Value {\n         }\n     }\n \n-    pub(super) fn into_ptr_vtable_pair(\n+    pub(super) fn into_ptr_vtable_pair<M: Machine<'tcx>>(\n         &self,\n-        mem: &Memory<'a, 'tcx>\n+        mem: &Memory<'a, 'tcx, M>\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n@@ -197,7 +201,7 @@ impl<'a, 'tcx: 'a> Value {\n         }\n     }\n \n-    pub(super) fn into_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n+    pub(super) fn into_slice<M: Machine<'tcx>>(&self, mem: &Memory<'a, 'tcx, M>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n             ByRef { ptr: ref_ptr, aligned } => {"}, {"sha": "960b73ee6b243c1fef4d1912fadf9dd8cd640e3a", "filename": "src/librustc_mir/lib.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -0,0 +1,24 @@\n+#![feature(\n+    i128_type,\n+    rustc_private,\n+    conservative_impl_trait,\n+    never_type,\n+)]\n+\n+// From rustc.\n+#[macro_use]\n+extern crate log;\n+extern crate log_settings;\n+#[macro_use]\n+extern crate rustc;\n+extern crate rustc_const_math;\n+extern crate rustc_data_structures;\n+extern crate syntax;\n+\n+// From crates.io.\n+extern crate byteorder;\n+#[macro_use]\n+extern crate lazy_static;\n+extern crate regex;\n+\n+pub mod interpret;"}, {"sha": "96006c884e5806b085aafc46e7fff5691108149b", "filename": "tests/compile-fail/stack_free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/tests%2Fcompile-fail%2Fstack_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/tests%2Fcompile-fail%2Fstack_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstack_free.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: tried to deallocate Stack memory but gave Rust as the kind\n+// error-pattern: tried to deallocate Stack memory but gave Machine(Rust) as the kind\n \n fn main() {\n     let x = 42;"}, {"sha": "7b3ad7d8b78a6ddae24e60e6916b27ade91eba72", "filename": "tests/compiletest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7700bd0c540989e56268a4b5b72afa5086040517/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7700bd0c540989e56268a4b5b72afa5086040517/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=7700bd0c540989e56268a4b5b72afa5086040517", "patch": "@@ -130,16 +130,16 @@ fn run_pass_miri() {\n \n     for &opt in [false, true].iter() {\n         for_all_targets(&sysroot, |target| {\n-            miri_pass(\"../../tests/run-pass\", &target, &host, false, opt);\n+            miri_pass(\"tests/run-pass\", &target, &host, false, opt);\n         });\n-        miri_pass(\"../../tests/run-pass-fullmir\", &host, &host, true, opt);\n+        miri_pass(\"tests/run-pass-fullmir\", &host, &host, true, opt);\n     }\n }\n \n #[test]\n fn run_pass_rustc() {\n-    run_pass(\"../../tests/run-pass\");\n-    run_pass(\"../../tests/run-pass-fullmir\");\n+    run_pass(\"tests/run-pass\");\n+    run_pass(\"tests/run-pass-fullmir\");\n }\n \n #[test]\n@@ -148,7 +148,7 @@ fn compile_fail_miri() {\n     let host = get_host();\n \n     for_all_targets(&sysroot, |target| {\n-        compile_fail(&sysroot, \"../../tests/compile-fail\", &target, &host, false);\n+        compile_fail(&sysroot, \"tests/compile-fail\", &target, &host, false);\n     });\n-    compile_fail(&sysroot, \"../../tests/compile-fail-fullmir\", &host, &host, true);\n+    compile_fail(&sysroot, \"tests/compile-fail-fullmir\", &host, &host, true);\n }"}]}