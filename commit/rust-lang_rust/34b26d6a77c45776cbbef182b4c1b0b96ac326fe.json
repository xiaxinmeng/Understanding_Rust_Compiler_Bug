{"sha": "34b26d6a77c45776cbbef182b4c1b0b96ac326fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YjI2ZDZhNzdjNDU3NzZjYmJlZjE4MmI0YzFiMGI5NmFjMzI2ZmU=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-07-30T19:25:39Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-07-30T19:25:39Z"}, "message": "Rust function-level coverage now works on external crates\n\nFixed a known issue in the coverage map where some regions had\nnonsensical source code locations. External crate functions are already\nincluded in their own coverage maps, per library, and don't need to also\nbe added to the importing crate's coverage map. (In fact, their source\nstart and end byte positions are not relevant to the importing crate's\nSourceMap.)\n\nThe fix was to simply skip trying to add imported coverage info to the\ncoverage map if the instrumented function is not \"local\".\n\nThe injected counters are still relevant, however, and the LLVM\n`instrprof.increment` intrinsic call parameters will map those counters\nto the external crates' coverage maps, when generating runtime coverage\ndata.", "tree": {"sha": "043861595ab0039a459b1d42e651ea83714c4db4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/043861595ab0039a459b1d42e651ea83714c4db4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34b26d6a77c45776cbbef182b4c1b0b96ac326fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34b26d6a77c45776cbbef182b4c1b0b96ac326fe", "html_url": "https://github.com/rust-lang/rust/commit/34b26d6a77c45776cbbef182b4c1b0b96ac326fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34b26d6a77c45776cbbef182b4c1b0b96ac326fe/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b09c37ddc240e25748e53d7a8f81f252def6dee", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b09c37ddc240e25748e53d7a8f81f252def6dee", "html_url": "https://github.com/rust-lang/rust/commit/6b09c37ddc240e25748e53d7a8f81f252def6dee"}], "stats": {"total": 115, "additions": 62, "deletions": 53}, "files": [{"sha": "728af7b0a8cd177323e7def9bd8db33893379b75", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 57, "deletions": 52, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/34b26d6a77c45776cbbef182b4c1b0b96ac326fe/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b26d6a77c45776cbbef182b4c1b0b96ac326fe/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=34b26d6a77c45776cbbef182b4c1b0b96ac326fe", "patch": "@@ -90,64 +90,69 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &Vec<Operand<'tcx>>,\n         caller_instance: ty::Instance<'tcx>,\n     ) -> bool {\n+        let mut is_codegen_intrinsic = true;\n+        // Set `is_codegen_intrinsic` to `false` to bypass `codegen_intrinsic_call()`.\n+\n         if self.tcx.sess.opts.debugging_opts.instrument_coverage {\n-            // Add the coverage information from the MIR to the Codegen context. Some coverage\n-            // intrinsics are used only to pass along the coverage information (returns `false`\n-            // for `is_codegen_intrinsic()`), but `count_code_region` is also converted into an\n-            // LLVM intrinsic to increment a coverage counter.\n-            match intrinsic {\n-                sym::count_code_region => {\n-                    use coverage::count_code_region_args::*;\n-                    self.add_counter_region(\n-                        caller_instance,\n-                        op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n-                        op_to_u32(&args[COUNTER_ID]),\n-                        op_to_u32(&args[START_BYTE_POS]),\n-                        op_to_u32(&args[END_BYTE_POS]),\n-                    );\n-                    return true; // Also inject the counter increment in the backend\n-                }\n-                sym::coverage_counter_add | sym::coverage_counter_subtract => {\n-                    use coverage::coverage_counter_expression_args::*;\n-                    self.add_counter_expression_region(\n-                        caller_instance,\n-                        op_to_u32(&args[EXPRESSION_ID]),\n-                        op_to_u32(&args[LEFT_ID]),\n-                        if intrinsic == sym::coverage_counter_add {\n-                            ExprKind::Add\n-                        } else {\n-                            ExprKind::Subtract\n-                        },\n-                        op_to_u32(&args[RIGHT_ID]),\n-                        op_to_u32(&args[START_BYTE_POS]),\n-                        op_to_u32(&args[END_BYTE_POS]),\n-                    );\n-                    return false; // Does not inject backend code\n+            // If the intrinsic is from the local MIR, add the coverage information to the Codegen\n+            // context, to be encoded into the local crate's coverage map.\n+            if caller_instance.def_id().is_local() {\n+                // FIXME(richkadel): Make sure to add coverage analysis tests on a crate with\n+                // external crate dependencies, where:\n+                //   1. Both binary and dependent crates are compiled with `-Zinstrument-coverage`\n+                //   2. Only binary is compiled with `-Zinstrument-coverage`\n+                //   3. Only dependent crates are compiled with `-Zinstrument-coverage`\n+                match intrinsic {\n+                    sym::count_code_region => {\n+                        use coverage::count_code_region_args::*;\n+                        self.add_counter_region(\n+                            caller_instance,\n+                            op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n+                            op_to_u32(&args[COUNTER_ID]),\n+                            op_to_u32(&args[START_BYTE_POS]),\n+                            op_to_u32(&args[END_BYTE_POS]),\n+                        );\n+                    }\n+                    sym::coverage_counter_add | sym::coverage_counter_subtract => {\n+                        use coverage::coverage_counter_expression_args::*;\n+                        self.add_counter_expression_region(\n+                            caller_instance,\n+                            op_to_u32(&args[EXPRESSION_ID]),\n+                            op_to_u32(&args[LEFT_ID]),\n+                            if intrinsic == sym::coverage_counter_add {\n+                                ExprKind::Add\n+                            } else {\n+                                ExprKind::Subtract\n+                            },\n+                            op_to_u32(&args[RIGHT_ID]),\n+                            op_to_u32(&args[START_BYTE_POS]),\n+                            op_to_u32(&args[END_BYTE_POS]),\n+                        );\n+                    }\n+                    sym::coverage_unreachable => {\n+                        use coverage::coverage_unreachable_args::*;\n+                        self.add_unreachable_region(\n+                            caller_instance,\n+                            op_to_u32(&args[START_BYTE_POS]),\n+                            op_to_u32(&args[END_BYTE_POS]),\n+                        );\n+                    }\n+                    _ => {}\n                 }\n-                sym::coverage_unreachable => {\n-                    use coverage::coverage_unreachable_args::*;\n-                    self.add_unreachable_region(\n-                        caller_instance,\n-                        op_to_u32(&args[START_BYTE_POS]),\n-                        op_to_u32(&args[END_BYTE_POS]),\n-                    );\n-                    return false; // Does not inject backend code\n+            }\n+\n+            // Only the `count_code_region` coverage intrinsic is translated into an actual LLVM\n+            // intrinsic call (local or not); otherwise, set `is_codegen_intrinsic` to `false`.\n+            match intrinsic {\n+                sym::coverage_counter_add\n+                | sym::coverage_counter_subtract\n+                | sym::coverage_unreachable => {\n+                    is_codegen_intrinsic = false;\n                 }\n                 _ => {}\n             }\n-        } else {\n-            // NOT self.tcx.sess.opts.debugging_opts.instrument_coverage\n-            if intrinsic == sym::count_code_region {\n-                // An external crate may have been pre-compiled with coverage instrumentation, and\n-                // some references from the current crate to the external crate might carry along\n-                // the call terminators to coverage intrinsics, like `count_code_region` (for\n-                // example, when instantiating a generic function). If the current crate has\n-                // `instrument_coverage` disabled, the `count_code_region` call terminators should\n-                // be ignored.\n-                return false; // Do not inject coverage counters inlined from external crates\n-            }\n         }\n-        true // Unhandled intrinsics should be passed to `codegen_intrinsic_call()`\n+        is_codegen_intrinsic\n     }\n \n     fn codegen_intrinsic_call("}, {"sha": "72138065a90ba965d1eb64419603216d02125fc0", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34b26d6a77c45776cbbef182b4c1b0b96ac326fe/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b26d6a77c45776cbbef182b4c1b0b96ac326fe/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=34b26d6a77c45776cbbef182b4c1b0b96ac326fe", "patch": "@@ -86,7 +86,11 @@ impl Region {\n     pub fn new(source_map: &SourceMap, start_byte_pos: u32, end_byte_pos: u32) -> Self {\n         let start = source_map.lookup_char_pos(BytePos::from_u32(start_byte_pos));\n         let end = source_map.lookup_char_pos(BytePos::from_u32(end_byte_pos));\n-        assert_eq!(start.file.name, end.file.name);\n+        assert_eq!(\n+            start.file.name, end.file.name,\n+            \"Region start ({} -> {:?}) and end ({} -> {:?}) don't come from the same source file!\",\n+            start_byte_pos, start, end_byte_pos, end\n+        );\n         Self { start, end }\n     }\n "}]}