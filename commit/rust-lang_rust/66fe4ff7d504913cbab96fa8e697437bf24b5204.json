{"sha": "66fe4ff7d504913cbab96fa8e697437bf24b5204", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZmU0ZmY3ZDUwNDkxM2NiYWI5NmZhOGU2OTc0MzdiZjI0YjUyMDQ=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-02-26T22:41:38Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-04-17T17:44:17Z"}, "message": "Move unroll_place to Place::unroll", "tree": {"sha": "d86fcb03f712842bfecc01acdebdb64b1f47f31e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d86fcb03f712842bfecc01acdebdb64b1f47f31e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66fe4ff7d504913cbab96fa8e697437bf24b5204", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66fe4ff7d504913cbab96fa8e697437bf24b5204", "html_url": "https://github.com/rust-lang/rust/commit/66fe4ff7d504913cbab96fa8e697437bf24b5204", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66fe4ff7d504913cbab96fa8e697437bf24b5204/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ed6f1461dd0d89c85a334f8d8ce7957611f2dfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ed6f1461dd0d89c85a334f8d8ce7957611f2dfe", "html_url": "https://github.com/rust-lang/rust/commit/6ed6f1461dd0d89c85a334f8d8ce7957611f2dfe"}], "stats": {"total": 159, "additions": 80, "deletions": 79}, "files": [{"sha": "6289b78af9b9b57afe991a4a0462e7bb3fc01108", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/66fe4ff7d504913cbab96fa8e697437bf24b5204/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66fe4ff7d504913cbab96fa8e697437bf24b5204/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=66fe4ff7d504913cbab96fa8e697437bf24b5204", "patch": "@@ -2058,6 +2058,81 @@ impl<'tcx> Place<'tcx> {\n             Place::Base(PlaceBase::Static(..)) => None,\n         }\n     }\n+\n+    /// Recursively \"unroll\" a place into a `PlaceComponents` list,\n+    /// invoking `op` with a `PlaceComponentsIter`.\n+    pub fn unroll<R>(\n+        &self,\n+        next: Option<&PlaceComponents<'_, 'tcx>>,\n+        op: impl FnOnce(PlaceComponentsIter<'_, 'tcx>) -> R,\n+    ) -> R {\n+        match self {\n+            Place::Projection(interior) => interior.base.unroll(\n+                Some(&PlaceComponents {\n+                    component: self,\n+                    next,\n+                }),\n+                op,\n+            ),\n+\n+            Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n+                let list = PlaceComponents {\n+                    component: self,\n+                    next,\n+                };\n+                op(list.iter())\n+            }\n+        }\n+    }\n+}\n+\n+/// A linked list of places running up the stack; begins with the\n+/// innermost place and extends to projections (e.g., `a.b` would have\n+/// the place `a` with a \"next\" pointer to `a.b`). Created by\n+/// `Place::unroll`.\n+///\n+/// N.B., this particular impl strategy is not the most obvious. It was\n+/// chosen because it makes a measurable difference to NLL\n+/// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n+pub struct PlaceComponents<'p, 'tcx: 'p> {\n+    pub component: &'p Place<'tcx>,\n+    pub next: Option<&'p PlaceComponents<'p, 'tcx>>,\n+}\n+\n+impl<'p, 'tcx> PlaceComponents<'p, 'tcx> {\n+    /// Converts a list of `Place` components into an iterator; this\n+    /// iterator yields up a never-ending stream of `Option<&Place>`.\n+    /// These begin with the \"innermost\" place and then with each\n+    /// projection therefrom. So given a place like `a.b.c` it would\n+    /// yield up:\n+    ///\n+    /// ```notrust\n+    /// Some(`a`), Some(`a.b`), Some(`a.b.c`), None, None, ...\n+    /// ```\n+    fn iter(&self) -> PlaceComponentsIter<'_, 'tcx> {\n+        PlaceComponentsIter { value: Some(self) }\n+    }\n+}\n+\n+/// Iterator over components; see `PlaceComponents::iter` for more\n+/// information.\n+///\n+/// N.B., this is not a *true* Rust iterator -- the code above just\n+/// manually invokes `next`. This is because we (sometimes) want to\n+/// keep executing even after `None` has been returned.\n+pub struct PlaceComponentsIter<'p, 'tcx: 'p> {\n+    pub value: Option<&'p PlaceComponents<'p, 'tcx>>,\n+}\n+\n+impl<'p, 'tcx> PlaceComponentsIter<'p, 'tcx> {\n+    pub fn next(&mut self) -> Option<&'p Place<'tcx>> {\n+        if let Some(&PlaceComponents { component, next }) = self.value {\n+            self.value = next;\n+            Some(component)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n impl<'tcx> Debug for Place<'tcx> {"}, {"sha": "4f1fbea983290c414417edcade448bba3dd7164c", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 5, "deletions": 79, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/66fe4ff7d504913cbab96fa8e697437bf24b5204/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66fe4ff7d504913cbab96fa8e697437bf24b5204/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=66fe4ff7d504913cbab96fa8e697437bf24b5204", "patch": "@@ -2,7 +2,9 @@ use crate::borrow_check::ArtificialField;\n use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n-use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem, StaticKind};\n+use rustc::mir::{\n+    BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem, PlaceComponentsIter, StaticKind\n+};\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n \n@@ -65,8 +67,8 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n         }\n     }\n \n-    unroll_place(borrow_place, None, |borrow_components| {\n-        unroll_place(access_place, None, |access_components| {\n+    borrow_place.unroll(None, |borrow_components| {\n+        access_place.unroll(None, |access_components| {\n             place_components_conflict(\n                 tcx,\n                 mir,\n@@ -272,82 +274,6 @@ fn place_components_conflict<'gcx, 'tcx>(\n     }\n }\n \n-/// A linked list of places running up the stack; begins with the\n-/// innermost place and extends to projections (e.g., `a.b` would have\n-/// the place `a` with a \"next\" pointer to `a.b`). Created by\n-/// `unroll_place`.\n-///\n-/// N.B., this particular impl strategy is not the most obvious. It was\n-/// chosen because it makes a measurable difference to NLL\n-/// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n-struct PlaceComponents<'p, 'tcx: 'p> {\n-    component: &'p Place<'tcx>,\n-    next: Option<&'p PlaceComponents<'p, 'tcx>>,\n-}\n-\n-impl<'p, 'tcx> PlaceComponents<'p, 'tcx> {\n-    /// Converts a list of `Place` components into an iterator; this\n-    /// iterator yields up a never-ending stream of `Option<&Place>`.\n-    /// These begin with the \"innermost\" place and then with each\n-    /// projection therefrom. So given a place like `a.b.c` it would\n-    /// yield up:\n-    ///\n-    /// ```notrust\n-    /// Some(`a`), Some(`a.b`), Some(`a.b.c`), None, None, ...\n-    /// ```\n-    fn iter(&self) -> PlaceComponentsIter<'_, 'tcx> {\n-        PlaceComponentsIter { value: Some(self) }\n-    }\n-}\n-\n-/// Iterator over components; see `PlaceComponents::iter` for more\n-/// information.\n-///\n-/// N.B., this is not a *true* Rust iterator -- the code above just\n-/// manually invokes `next`. This is because we (sometimes) want to\n-/// keep executing even after `None` has been returned.\n-struct PlaceComponentsIter<'p, 'tcx: 'p> {\n-    value: Option<&'p PlaceComponents<'p, 'tcx>>,\n-}\n-\n-impl<'p, 'tcx> PlaceComponentsIter<'p, 'tcx> {\n-    fn next(&mut self) -> Option<&'p Place<'tcx>> {\n-        if let Some(&PlaceComponents { component, next }) = self.value {\n-            self.value = next;\n-            Some(component)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Recursively \"unroll\" a place into a `PlaceComponents` list,\n-/// invoking `op` with a `PlaceComponentsIter`.\n-fn unroll_place<'tcx, R>(\n-    place: &Place<'tcx>,\n-    next: Option<&PlaceComponents<'_, 'tcx>>,\n-    op: impl FnOnce(PlaceComponentsIter<'_, 'tcx>) -> R,\n-) -> R {\n-    match place {\n-        Place::Projection(interior) => unroll_place(\n-            &interior.base,\n-            Some(&PlaceComponents {\n-                component: place,\n-                next,\n-            }),\n-            op,\n-        ),\n-\n-        Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n-            let list = PlaceComponents {\n-                component: place,\n-                next,\n-            };\n-            op(list.iter())\n-        }\n-    }\n-}\n-\n // Given that the bases of `elem1` and `elem2` are always either equal\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`."}]}