{"sha": "6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "node_id": "C_kwDOAAsO6NoAKDZhYzQzZWNmMTdkMzI4NjM1MDIyMzg2MGNjNzdhM2U1YWU2YTBkNDU", "commit": {"author": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-11-25T11:57:38Z"}, "committer": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-11-25T11:57:38Z"}, "message": "Merge commit '31519bb39' into HEAD", "tree": {"sha": "f8b9ee85a58ec07da651ed57b7eab1da622bd44c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8b9ee85a58ec07da651ed57b7eab1da622bd44c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "html_url": "https://github.com/rust-lang/rust/commit/6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/comments", "author": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "797ee293ed18904eea04ce81b86587ac70c03582", "url": "https://api.github.com/repos/rust-lang/rust/commits/797ee293ed18904eea04ce81b86587ac70c03582", "html_url": "https://github.com/rust-lang/rust/commit/797ee293ed18904eea04ce81b86587ac70c03582"}, {"sha": "31519bb394b609b12dc9a214284c8436e842c91c", "url": "https://api.github.com/repos/rust-lang/rust/commits/31519bb394b609b12dc9a214284c8436e842c91c", "html_url": "https://github.com/rust-lang/rust/commit/31519bb394b609b12dc9a214284c8436e842c91c"}], "stats": {"total": 2718, "additions": 2092, "deletions": 626}, "files": [{"sha": "b2e5db6f689b518e5b6cfdfbe11a7b79294bdbb1", "filename": ".github/workflows/release.yaml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frelease.yaml?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -31,13 +31,13 @@ jobs:\n           - os: windows-latest\n             target: aarch64-pc-windows-msvc\n             code-target: win32-arm64\n-          - os: ubuntu-18.04\n+          - os: ubuntu-20.04\n             target: x86_64-unknown-linux-gnu\n             code-target: linux-x64\n-          - os: ubuntu-18.04\n+          - os: ubuntu-20.04\n             target: aarch64-unknown-linux-gnu\n             code-target: linux-arm64\n-          - os: ubuntu-18.04\n+          - os: ubuntu-20.04\n             target: arm-unknown-linux-gnueabihf\n             code-target: linux-armhf\n           - os: macos-11"}, {"sha": "8a61ea1c9241422451a8a3ea1a0b1145159c50c4", "filename": "Cargo.lock", "status": "modified", "additions": 79, "deletions": 88, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -37,9 +37,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.58\"\n+version = \"1.0.62\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb07d2053ccdbe10e2af2995a2f116c1330396493dc1269f6a91d0ae82e19704\"\n+checksum = \"1485d4d2cc45e7b201ee3767015c96faa5904387c9d87c6efdd0fb511f12d305\"\n \n [[package]]\n name = \"anymap\"\n@@ -78,16 +78,16 @@ checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.65\"\n+version = \"0.3.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"11a17d453482a265fd5f8479f2a3f405566e6ca627837aaddb85af8b1ab8ef61\"\n+checksum = \"cab84319d616cfb654d03394f38ab7e6f0919e181b1b57e1fd15e7fb4077d9a7\"\n dependencies = [\n  \"addr2line\",\n  \"cc\",\n  \"cfg-if\",\n  \"libc\",\n  \"miniz_oxide\",\n- \"object 0.28.4\",\n+ \"object\",\n  \"rustc-demangle\",\n ]\n \n@@ -114,9 +114,9 @@ checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"camino\"\n-version = \"1.0.9\"\n+version = \"1.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"869119e97797867fd90f5e22af7d0bd274bd4635ebb9eb68c04f3f513ae6c412\"\n+checksum = \"88ad0e1e3e88dd237a156ab9f571021b8a158caa0ae44b1968a241efb5144c1e\"\n dependencies = [\n  \"serde\",\n ]\n@@ -171,9 +171,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.83.0\"\n+version = \"0.84.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"83553c2ef7717e58aecdf42dd9e3c876229f5a1f35a16435b5ddc4addef81827\"\n+checksum = \"cf29c109d57f8d57b0e7675391be37a9285d86dd93278bd5f14a0ad3c447a6c2\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -183,9 +183,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.83.0\"\n+version = \"0.84.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2dd42107d579d8ec2a5af20a8de62a37524a67bf6a4c0ff08a950068f0bfea91\"\n+checksum = \"d391763027b5e50a5e15caf6d2857ec585fd68160367bbeac9e1804209620918\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -194,9 +194,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.83.0\"\n+version = \"0.84.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c444031541a76c13c145e76d91f1548e9feb2240e7f0c3e77879ceb694994f2d\"\n+checksum = \"afafd92dcdc7fe0ea940ee94bdd8cc5bd18f4a4a84c593d6d7025fe16c150478\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -207,9 +207,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.83.0\"\n+version = \"0.84.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c76f2db19c5e8a3d42340cf5b4d90b8c218750536fca35e2bb285ab6653c0bc8\"\n+checksum = \"3af1d111f11c91c48ace02e93e470c5bae6d2631bd112e4545317da53660d7fc\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -249,9 +249,9 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam\"\n-version = \"0.8.1\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ae5588f6b3c3cb05239e90bd110f257254aecd01e4635400391aeae07497845\"\n+checksum = \"2801af0d36612ae591caa9568261fddce32ce6e08a7275ea334a06a4ad021a2c\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-channel\",\n@@ -263,19 +263,19 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-channel\"\n-version = \"0.5.5\"\n+version = \"0.5.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c02a4d71819009c192cf4872265391563fd6a84c81ff2c0f2a7026ca4c1d85c\"\n+checksum = \"c2dd04ddaf88237dc3b8d8f9a3c1004b506b54b3313403944054d23c0870c521\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils\",\n ]\n \n [[package]]\n name = \"crossbeam-deque\"\n-version = \"0.8.1\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6455c0ca19f0d2fbf751b908d5c55c1f5cbc65e03c4225427254b46890bdde1e\"\n+checksum = \"715e8152b692bba2d374b53d4875445368fdf21a94751410af607a5ac677d1fc\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-epoch\",\n@@ -284,9 +284,9 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-epoch\"\n-version = \"0.9.9\"\n+version = \"0.9.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"07db9d94cbd326813772c968ccd25999e5f8ae22f4f8d1b11effa37ef6ce281d\"\n+checksum = \"045ebe27666471bb549370b4b0b3e51b07f56325befa4284db65fc89c02511b1\"\n dependencies = [\n  \"autocfg\",\n  \"cfg-if\",\n@@ -298,19 +298,19 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-queue\"\n-version = \"0.3.5\"\n+version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1f25d8400f4a7a5778f0e4e52384a48cbd9b5c495d110786187fc750075277a2\"\n+checksum = \"1cd42583b04998a5363558e5f9291ee5a5ff6b49944332103f251e7479a82aa7\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils\",\n ]\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.8.10\"\n+version = \"0.8.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7d82ee10ce34d7bc12c2122495e7593a9c41347ecdd64185af4ecf72cb1a7f83\"\n+checksum = \"51887d4adc7b564537b15adcfb307936f8075dfcd5f00dde9a9f1d29383682bc\"\n dependencies = [\n  \"cfg-if\",\n  \"once_cell\",\n@@ -359,9 +359,9 @@ checksum = \"9bda8e21c04aca2ae33ffc2fd8c23134f3cac46db123ba97bd9d3f3b8a4a85e1\"\n \n [[package]]\n name = \"either\"\n-version = \"1.7.0\"\n+version = \"1.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f107b87b6afc2a64fd13cac55fe06d6c8859f12d4b14cbcdd2c67d0976781be\"\n+checksum = \"90e5c1c8368803113bf0c9584fc495a58b86dc8a29edbf8fe877d21d9507e797\"\n \n [[package]]\n name = \"ena\"\n@@ -458,15 +458,15 @@ checksum = \"7ab85b9b05e3978cc9a9cf8fea7f01b494e1a09ed3037e16ba39edc7a29eb61a\"\n \n [[package]]\n name = \"gimli\"\n-version = \"0.26.1\"\n+version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n+checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.12.1\"\n+version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"db0d4cf898abf0081f964436dc980e96670a0f36863e4b83aaacdb65c9d7ccc3\"\n+checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n \n [[package]]\n name = \"heck\"\n@@ -794,9 +794,9 @@ dependencies = [\n \n [[package]]\n name = \"itoa\"\n-version = \"1.0.2\"\n+version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n+checksum = \"6c8af84674fe1f223a982c933a0ee1086ac4d4052aa0fb8060c12c6ad838e754\"\n \n [[package]]\n name = \"jod-thread\"\n@@ -836,9 +836,9 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.126\"\n+version = \"0.2.132\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n+checksum = \"8371e4e5341c3a96db127eb2465ac681ced4c433e01dd0e938adbef26ba93ba5\"\n \n [[package]]\n name = \"libloading\"\n@@ -944,9 +944,9 @@ checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n \n [[package]]\n name = \"memmap2\"\n-version = \"0.5.4\"\n+version = \"0.5.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d5172b50c23043ff43dd53e51392f36519d9b35a8f3a410d30ece5d1aedd58ae\"\n+checksum = \"95af15f345b17af2efc8ead6080fb8bc376f8cec1b35277b935637595fe77498\"\n dependencies = [\n  \"libc\",\n ]\n@@ -1001,9 +1001,9 @@ dependencies = [\n \n [[package]]\n name = \"notify\"\n-version = \"5.0.0-pre.15\"\n+version = \"5.0.0-pre.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"553f9844ad0b0824605c20fb55a661679782680410abfb1a8144c2e7e437e7a7\"\n+checksum = \"530f6314d6904508082f4ea424a0275cf62d341e118b313663f266429cb19693\"\n dependencies = [\n  \"bitflags\",\n  \"crossbeam-channel\",\n@@ -1027,15 +1027,6 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"object\"\n-version = \"0.28.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424\"\n-dependencies = [\n- \"memchr\",\n-]\n-\n [[package]]\n name = \"object\"\n version = \"0.29.0\"\n@@ -1047,9 +1038,9 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.13.0\"\n+version = \"1.13.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18a6dbe30758c9f83eb00cbea4ac95966305f5a7772f3f42ebfc7fc7eddbd8e1\"\n+checksum = \"074864da206b4973b84eb91683020dbefd6a8c3f0f38e054d93954e891935e4e\"\n \n [[package]]\n name = \"oorandom\"\n@@ -1118,9 +1109,9 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"1.0.7\"\n+version = \"1.0.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0c520e05135d6e763148b6426a837e239041653ba7becd2e538c076c738025fc\"\n+checksum = \"9423e2b32f7a043629287a536f21951e8c6a82482d0acb1eeebfc90bc2225b22\"\n \n [[package]]\n name = \"paths\"\n@@ -1172,7 +1163,7 @@ name = \"proc-macro-api\"\n version = \"0.0.0\"\n dependencies = [\n  \"memmap2\",\n- \"object 0.29.0\",\n+ \"object\",\n  \"paths\",\n  \"profile\",\n  \"serde\",\n@@ -1192,7 +1183,7 @@ dependencies = [\n  \"libloading\",\n  \"mbe\",\n  \"memmap2\",\n- \"object 0.29.0\",\n+ \"object\",\n  \"paths\",\n  \"proc-macro-api\",\n  \"proc-macro-test\",\n@@ -1221,9 +1212,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.40\"\n+version = \"1.0.43\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dd96a1e8ed2596c337f8eae5f24924ec83f5ad5ab21ea8e455d3566c69fbcaf7\"\n+checksum = \"0a2ca2c61bc9f3d74d2886294ab7b9853abd9c1ad903a3ac7815c58989bb7bab\"\n dependencies = [\n  \"unicode-ident\",\n ]\n@@ -1265,9 +1256,9 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.9.1\"\n+version = \"0.9.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34f197a544b0c9ab3ae46c359a7ec9cbbb5c7bf97054266fecb7ead794a181d6\"\n+checksum = \"2d9cc634bc78768157b5cbfe988ffcd1dcba95cd2b2f03a88316c08c6d00ed63\"\n dependencies = [\n  \"bitflags\",\n  \"memchr\",\n@@ -1285,9 +1276,9 @@ dependencies = [\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.20\"\n+version = \"1.0.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3bcdf212e9776fbcb2d23ab029360416bb1706b1aea2d1a5ba002727cbcab804\"\n+checksum = \"bbe448f377a7d6961e30f5955f9b8d106c3f5e449d493ee1b125c1d43c2b5179\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -1318,18 +1309,18 @@ dependencies = [\n \n [[package]]\n name = \"redox_syscall\"\n-version = \"0.2.13\"\n+version = \"0.2.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"62f25bc4c7e55e0b0b7a1d43fb893f4fa1361d0abe38b9ce4f323c2adfe6ef42\"\n+checksum = \"fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a\"\n dependencies = [\n  \"bitflags\",\n ]\n \n [[package]]\n name = \"regex\"\n-version = \"1.5.6\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d83f127d94bdbcda4c8cc2e50f6f84f4b611f69c902699ca385a39c3a75f9ff1\"\n+checksum = \"4c4eb3267174b8c6c2f654116623910a0fef09c4753f8dd83db29c48a0df988b\"\n dependencies = [\n  \"regex-syntax\",\n ]\n@@ -1345,9 +1336,9 @@ dependencies = [\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.6.26\"\n+version = \"0.6.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"49b3de9ec5dc0a3417da371aab17d729997c15010e7fd24ff707773a33bddb64\"\n+checksum = \"a3f87b73ce11b1619a3c6332f45341e0047173771e8b8b73f87bfeefb7b56244\"\n \n [[package]]\n name = \"rowan\"\n@@ -1438,9 +1429,9 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n \n [[package]]\n name = \"ryu\"\n-version = \"1.0.10\"\n+version = \"1.0.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f3f6f92acf49d1b98f7a81226834412ada05458b7364277387724a237f062695\"\n+checksum = \"4501abdff3ae82a1c1b477a17252eb69cee9e66eb915c1abaa4f44d873df9f09\"\n \n [[package]]\n name = \"salsa\"\n@@ -1494,27 +1485,27 @@ checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n [[package]]\n name = \"semver\"\n-version = \"1.0.12\"\n+version = \"1.0.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2333e6df6d6598f2b1974829f853c2b4c5f4a6e503c10af918081aa6f8564e1\"\n+checksum = \"93f6841e709003d68bb2deee8c343572bf446003ec20a583e76f7b15cebf3711\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.138\"\n+version = \"1.0.143\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1578c6245786b9d168c5447eeacfb96856573ca56c9d68fdcf394be134882a47\"\n+checksum = \"53e8e5d5b70924f74ff5c6d64d9a5acd91422117c60f48c4e07855238a254553\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.138\"\n+version = \"1.0.143\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"023e9b1467aef8a10fb88f25611870ada9800ef7e22afce356bb0d2387b6f27c\"\n+checksum = \"d3d8e8de557aee63c26b85b947f5e59b690d0454c753f3adeb5cd7835ab88391\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1523,9 +1514,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.82\"\n+version = \"1.0.83\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"82c2c1fdcd807d1098552c5b9a36e425e42e9fbd7c6a37a8425f390f781f7fa7\"\n+checksum = \"38dd04e3c8279e75b31ef29dbdceebfe5ad89f4d0937213c53f7d49d01b3d5a7\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\",\n@@ -1535,9 +1526,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_repr\"\n-version = \"0.1.8\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2ad84e47328a31223de7fed7a4f5087f2d6ddfe586cf3ca25b7a165bc0a5aed\"\n+checksum = \"1fe39d9fbb0ebf5eb2c7cb7e2a47e4f462fad1379f1166b8ae49ad9eae89a7ca\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1594,9 +1585,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.98\"\n+version = \"1.0.99\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c50aef8a904de4c23c788f104b7dddc7d6f79c647c7c8ce4cc8f73eb0ca773dd\"\n+checksum = \"58dbef6ec655055e20b86b15a8cc6d439cca19b667537ac6a1369572d151ab13\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1739,9 +1730,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing\"\n-version = \"0.1.35\"\n+version = \"0.1.36\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a400e31aa60b9d44a52a8ee0343b5b18566b03a8321e0d321f695cf56e940160\"\n+checksum = \"2fce9567bd60a67d08a16488756721ba392f24f29006402881e43b19aac64307\"\n dependencies = [\n  \"cfg-if\",\n  \"pin-project-lite\",\n@@ -1762,9 +1753,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-core\"\n-version = \"0.1.28\"\n+version = \"0.1.29\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7b7358be39f2f274f322d2aaed611acc57f382e8eb1e5b48cb9ae30933495ce7\"\n+checksum = \"5aeea4303076558a00714b823f9ad67d58a3bbda1df83d8827d21193156e22f7\"\n dependencies = [\n  \"once_cell\",\n  \"valuable\",\n@@ -1783,9 +1774,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-subscriber\"\n-version = \"0.3.14\"\n+version = \"0.3.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a713421342a5a666b7577783721d3117f1b69a393df803ee17bb73b1e122a59\"\n+checksum = \"60db860322da191b40952ad9affe65ea23e7dd6a5c442c2c42865810c6ab8e6b\"\n dependencies = [\n  \"matchers\",\n  \"once_cell\","}, {"sha": "764893daa12ad88affa9438271f46ceacc5e3561", "filename": "bench_data/glorious_old_parser", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/bench_data%2Fglorious_old_parser", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/bench_data%2Fglorious_old_parser", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bench_data%2Fglorious_old_parser?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -1988,7 +1988,7 @@ impl<'a> Parser<'a> {\n                     err.span_suggestion(\n                         span,\n                         \"declare the type after the parameter binding\",\n-                        String::from(\"<identifier>: <type>\"),\n+                        \"<identifier>: <type>\",\n                         Applicability::HasPlaceholders,\n                     );\n                 } else if require_name && is_trait_item {"}, {"sha": "c22945c81fcb93b1971721c6d5f6446cf950142c", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -77,8 +77,13 @@ impl FlycheckHandle {\n     }\n \n     /// Schedule a re-start of the cargo check worker.\n-    pub fn update(&self) {\n-        self.sender.send(Restart).unwrap();\n+    pub fn restart(&self) {\n+        self.sender.send(Restart::Yes).unwrap();\n+    }\n+\n+    /// Stop this cargo check worker.\n+    pub fn cancel(&self) {\n+        self.sender.send(Restart::No).unwrap();\n     }\n \n     pub fn id(&self) -> usize {\n@@ -122,7 +127,10 @@ pub enum Progress {\n     DidCancel,\n }\n \n-struct Restart;\n+enum Restart {\n+    Yes,\n+    No,\n+}\n \n struct FlycheckActor {\n     id: usize,\n@@ -149,6 +157,7 @@ impl FlycheckActor {\n         config: FlycheckConfig,\n         workspace_root: AbsPathBuf,\n     ) -> FlycheckActor {\n+        tracing::info!(%id, ?workspace_root, \"Spawning flycheck\");\n         FlycheckActor { id, sender, config, workspace_root, cargo_handle: None }\n     }\n     fn progress(&self, progress: Progress) {\n@@ -164,10 +173,13 @@ impl FlycheckActor {\n     fn run(mut self, inbox: Receiver<Restart>) {\n         while let Some(event) = self.next_event(&inbox) {\n             match event {\n-                Event::Restart(Restart) => {\n+                Event::Restart(Restart::No) => {\n+                    self.cancel_check_process();\n+                }\n+                Event::Restart(Restart::Yes) => {\n                     // Cancel the previously spawned process\n                     self.cancel_check_process();\n-                    while let Ok(Restart) = inbox.recv_timeout(Duration::from_millis(50)) {}\n+                    while let Ok(_) = inbox.recv_timeout(Duration::from_millis(50)) {}\n \n                     let command = self.check_command();\n                     tracing::debug!(?command, \"will restart flycheck\");\n@@ -223,6 +235,10 @@ impl FlycheckActor {\n \n     fn cancel_check_process(&mut self) {\n         if let Some(cargo_handle) = self.cargo_handle.take() {\n+            tracing::debug!(\n+                command = ?self.check_command(),\n+                \"did  cancel flycheck\"\n+            );\n             cargo_handle.cancel();\n             self.progress(Progress::DidCancel);\n         }\n@@ -345,7 +361,7 @@ impl CargoActor {\n         //\n         // Because cargo only outputs one JSON object per line, we can\n         // simply skip a line if it doesn't parse, which just ignores any\n-        // erroneus output.\n+        // erroneous output.\n \n         let mut error = String::new();\n         let mut read_at_least_one_message = false;"}, {"sha": "1d818d96267c177223985d6588e138556227e9c2", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -4,6 +4,7 @@ mod lower;\n #[cfg(test)]\n mod tests;\n pub mod scope;\n+mod pretty;\n \n use std::{ops::Index, sync::Arc};\n \n@@ -352,6 +353,10 @@ impl Body {\n         }\n     }\n \n+    pub fn pretty_print(&self, db: &dyn DefDatabase, owner: DefWithBodyId) -> String {\n+        pretty::print_body_hir(db, self, owner)\n+    }\n+\n     fn new(\n         db: &dyn DefDatabase,\n         expander: Expander,"}, {"sha": "f6ec8bf7e9e0b4475302dfb6ed17b3c0e8c44d88", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -551,9 +551,17 @@ impl ExprCollector<'_> {\n                 }\n             }\n             ast::Expr::MacroStmts(e) => {\n-                let statements = e.statements().filter_map(|s| self.collect_stmt(s)).collect();\n+                let statements: Box<[_]> =\n+                    e.statements().filter_map(|s| self.collect_stmt(s)).collect();\n                 let tail = e.expr().map(|e| self.collect_expr(e));\n \n+                if e.syntax().children().next().is_none() {\n+                    // HACK: make sure that macros that expand to nothing aren't treated as a `()`\n+                    // expression when used in block tail position.\n+                    cov_mark::hit!(empty_macro_in_trailing_position_is_removed);\n+                    return None;\n+                }\n+\n                 self.alloc_expr(Expr::MacroStmts { tail, statements }, syntax_ptr)\n             }\n             ast::Expr::UnderscoreExpr(_) => self.alloc_expr(Expr::Underscore, syntax_ptr),"}, {"sha": "ddd476efe5c4d764dabd4ff597e732d902fb3dec", "filename": "crates/hir-def/src/body/pretty.rs", "status": "added", "additions": 621, "deletions": 0, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -0,0 +1,621 @@\n+//! A pretty-printer for HIR.\n+\n+use std::fmt::{self, Write};\n+\n+use crate::{\n+    expr::{Array, BindingAnnotation, Literal, Statement},\n+    pretty::{print_generic_args, print_path, print_type_ref},\n+    type_ref::TypeRef,\n+};\n+\n+use super::*;\n+\n+pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBodyId) -> String {\n+    let needs_semi;\n+    let header = match owner {\n+        DefWithBodyId::FunctionId(it) => {\n+            needs_semi = false;\n+            let item_tree_id = it.lookup(db).id;\n+            format!(\"fn {}(\u2026) \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n+        }\n+        DefWithBodyId::StaticId(it) => {\n+            needs_semi = true;\n+            let item_tree_id = it.lookup(db).id;\n+            format!(\"static {} = \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n+        }\n+        DefWithBodyId::ConstId(it) => {\n+            needs_semi = true;\n+            let item_tree_id = it.lookup(db).id;\n+            let name = match &item_tree_id.item_tree(db)[item_tree_id.value].name {\n+                Some(name) => name.to_string(),\n+                None => \"_\".to_string(),\n+            };\n+            format!(\"const {} = \", name)\n+        }\n+    };\n+\n+    let mut p = Printer { body, buf: header, indent_level: 0, needs_indent: false };\n+    p.print_expr(body.body_expr);\n+    if needs_semi {\n+        p.buf.push(';');\n+    }\n+    p.buf\n+}\n+\n+macro_rules! w {\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = write!($dst, $($arg)*); }\n+    };\n+}\n+\n+macro_rules! wln {\n+    ($dst:expr) => {\n+        { let _ = writeln!($dst); }\n+    };\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = writeln!($dst, $($arg)*); }\n+    };\n+}\n+\n+struct Printer<'a> {\n+    body: &'a Body,\n+    buf: String,\n+    indent_level: usize,\n+    needs_indent: bool,\n+}\n+\n+impl<'a> Write for Printer<'a> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        for line in s.split_inclusive('\\n') {\n+            if self.needs_indent {\n+                match self.buf.chars().rev().skip_while(|ch| *ch == ' ').next() {\n+                    Some('\\n') | None => {}\n+                    _ => self.buf.push('\\n'),\n+                }\n+                self.buf.push_str(&\"    \".repeat(self.indent_level));\n+                self.needs_indent = false;\n+            }\n+\n+            self.buf.push_str(line);\n+            self.needs_indent = line.ends_with('\\n');\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<'a> Printer<'a> {\n+    fn indented(&mut self, f: impl FnOnce(&mut Self)) {\n+        self.indent_level += 1;\n+        wln!(self);\n+        f(self);\n+        self.indent_level -= 1;\n+        self.buf = self.buf.trim_end_matches('\\n').to_string();\n+    }\n+\n+    fn whitespace(&mut self) {\n+        match self.buf.chars().next_back() {\n+            None | Some('\\n' | ' ') => {}\n+            _ => self.buf.push(' '),\n+        }\n+    }\n+\n+    fn newline(&mut self) {\n+        match self.buf.chars().rev().skip_while(|ch| *ch == ' ').next() {\n+            Some('\\n') | None => {}\n+            _ => writeln!(self).unwrap(),\n+        }\n+    }\n+\n+    fn print_expr(&mut self, expr: ExprId) {\n+        let expr = &self.body[expr];\n+\n+        match expr {\n+            Expr::Missing => w!(self, \"\ufffd\"),\n+            Expr::Underscore => w!(self, \"_\"),\n+            Expr::Path(path) => self.print_path(path),\n+            Expr::If { condition, then_branch, else_branch } => {\n+                w!(self, \"if \");\n+                self.print_expr(*condition);\n+                w!(self, \" \");\n+                self.print_expr(*then_branch);\n+                if let Some(els) = *else_branch {\n+                    w!(self, \" else \");\n+                    self.print_expr(els);\n+                }\n+            }\n+            Expr::Let { pat, expr } => {\n+                w!(self, \"let \");\n+                self.print_pat(*pat);\n+                w!(self, \" = \");\n+                self.print_expr(*expr);\n+            }\n+            Expr::Loop { body, label } => {\n+                if let Some(lbl) = label {\n+                    w!(self, \"{}: \", self.body[*lbl].name);\n+                }\n+                w!(self, \"loop \");\n+                self.print_expr(*body);\n+            }\n+            Expr::While { condition, body, label } => {\n+                if let Some(lbl) = label {\n+                    w!(self, \"{}: \", self.body[*lbl].name);\n+                }\n+                w!(self, \"while \");\n+                self.print_expr(*condition);\n+                self.print_expr(*body);\n+            }\n+            Expr::For { iterable, pat, body, label } => {\n+                if let Some(lbl) = label {\n+                    w!(self, \"{}: \", self.body[*lbl].name);\n+                }\n+                w!(self, \"for \");\n+                self.print_pat(*pat);\n+                w!(self, \" in \");\n+                self.print_expr(*iterable);\n+                self.print_expr(*body);\n+            }\n+            Expr::Call { callee, args, is_assignee_expr: _ } => {\n+                self.print_expr(*callee);\n+                w!(self, \"(\");\n+                if !args.is_empty() {\n+                    self.indented(|p| {\n+                        for arg in &**args {\n+                            p.print_expr(*arg);\n+                            wln!(p, \",\");\n+                        }\n+                    });\n+                }\n+                w!(self, \")\");\n+            }\n+            Expr::MethodCall { receiver, method_name, args, generic_args } => {\n+                self.print_expr(*receiver);\n+                w!(self, \".{}\", method_name);\n+                if let Some(args) = generic_args {\n+                    w!(self, \"::<\");\n+                    print_generic_args(args, self).unwrap();\n+                    w!(self, \">\");\n+                }\n+                w!(self, \"(\");\n+                if !args.is_empty() {\n+                    self.indented(|p| {\n+                        for arg in &**args {\n+                            p.print_expr(*arg);\n+                            wln!(p, \",\");\n+                        }\n+                    });\n+                }\n+                w!(self, \")\");\n+            }\n+            Expr::Match { expr, arms } => {\n+                w!(self, \"match \");\n+                self.print_expr(*expr);\n+                w!(self, \" {{\");\n+                self.indented(|p| {\n+                    for arm in &**arms {\n+                        p.print_pat(arm.pat);\n+                        if let Some(guard) = arm.guard {\n+                            w!(p, \" if \");\n+                            p.print_expr(guard);\n+                        }\n+                        w!(p, \" => \");\n+                        p.print_expr(arm.expr);\n+                        wln!(p, \",\");\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            Expr::Continue { label } => {\n+                w!(self, \"continue\");\n+                if let Some(label) = label {\n+                    w!(self, \" {}\", label);\n+                }\n+            }\n+            Expr::Break { expr, label } => {\n+                w!(self, \"break\");\n+                if let Some(label) = label {\n+                    w!(self, \" {}\", label);\n+                }\n+                if let Some(expr) = expr {\n+                    self.whitespace();\n+                    self.print_expr(*expr);\n+                }\n+            }\n+            Expr::Return { expr } => {\n+                w!(self, \"return\");\n+                if let Some(expr) = expr {\n+                    self.whitespace();\n+                    self.print_expr(*expr);\n+                }\n+            }\n+            Expr::Yield { expr } => {\n+                w!(self, \"yield\");\n+                if let Some(expr) = expr {\n+                    self.whitespace();\n+                    self.print_expr(*expr);\n+                }\n+            }\n+            Expr::RecordLit { path, fields, spread, ellipsis, is_assignee_expr: _ } => {\n+                match path {\n+                    Some(path) => self.print_path(path),\n+                    None => w!(self, \"\ufffd\"),\n+                }\n+\n+                w!(self, \"{{\");\n+                self.indented(|p| {\n+                    for field in &**fields {\n+                        w!(p, \"{}: \", field.name);\n+                        p.print_expr(field.expr);\n+                        wln!(p, \",\");\n+                    }\n+                    if let Some(spread) = spread {\n+                        w!(p, \"..\");\n+                        p.print_expr(*spread);\n+                        wln!(p);\n+                    }\n+                    if *ellipsis {\n+                        wln!(p, \"..\");\n+                    }\n+                });\n+                w!(self, \"}}\");\n+            }\n+            Expr::Field { expr, name } => {\n+                self.print_expr(*expr);\n+                w!(self, \".{}\", name);\n+            }\n+            Expr::Await { expr } => {\n+                self.print_expr(*expr);\n+                w!(self, \".await\");\n+            }\n+            Expr::Try { expr } => {\n+                self.print_expr(*expr);\n+                w!(self, \"?\");\n+            }\n+            Expr::TryBlock { body } => {\n+                w!(self, \"try \");\n+                self.print_expr(*body);\n+            }\n+            Expr::Async { body } => {\n+                w!(self, \"async \");\n+                self.print_expr(*body);\n+            }\n+            Expr::Const { body } => {\n+                w!(self, \"const \");\n+                self.print_expr(*body);\n+            }\n+            Expr::Cast { expr, type_ref } => {\n+                self.print_expr(*expr);\n+                w!(self, \" as \");\n+                self.print_type_ref(type_ref);\n+            }\n+            Expr::Ref { expr, rawness, mutability } => {\n+                w!(self, \"&\");\n+                if rawness.is_raw() {\n+                    w!(self, \"raw \");\n+                }\n+                if mutability.is_mut() {\n+                    w!(self, \"mut \");\n+                }\n+                self.print_expr(*expr);\n+            }\n+            Expr::Box { expr } => {\n+                w!(self, \"box \");\n+                self.print_expr(*expr);\n+            }\n+            Expr::UnaryOp { expr, op } => {\n+                let op = match op {\n+                    ast::UnaryOp::Deref => \"*\",\n+                    ast::UnaryOp::Not => \"!\",\n+                    ast::UnaryOp::Neg => \"-\",\n+                };\n+                w!(self, \"{}\", op);\n+                self.print_expr(*expr);\n+            }\n+            Expr::BinaryOp { lhs, rhs, op } => {\n+                let (bra, ket) = match op {\n+                    None | Some(ast::BinaryOp::Assignment { .. }) => (\"\", \"\"),\n+                    _ => (\"(\", \")\"),\n+                };\n+                w!(self, \"{}\", bra);\n+                self.print_expr(*lhs);\n+                w!(self, \"{} \", ket);\n+                match op {\n+                    Some(op) => w!(self, \"{}\", op),\n+                    None => w!(self, \"\ufffd\"), // :)\n+                }\n+                w!(self, \" {}\", bra);\n+                self.print_expr(*rhs);\n+                w!(self, \"{}\", ket);\n+            }\n+            Expr::Range { lhs, rhs, range_type } => {\n+                if let Some(lhs) = lhs {\n+                    w!(self, \"(\");\n+                    self.print_expr(*lhs);\n+                    w!(self, \") \");\n+                }\n+                let range = match range_type {\n+                    ast::RangeOp::Exclusive => \"..\",\n+                    ast::RangeOp::Inclusive => \"..=\",\n+                };\n+                w!(self, \"{}\", range);\n+                if let Some(rhs) = rhs {\n+                    w!(self, \"(\");\n+                    self.print_expr(*rhs);\n+                    w!(self, \") \");\n+                }\n+            }\n+            Expr::Index { base, index } => {\n+                self.print_expr(*base);\n+                w!(self, \"[\");\n+                self.print_expr(*index);\n+                w!(self, \"]\");\n+            }\n+            Expr::Closure { args, arg_types, ret_type, body } => {\n+                w!(self, \"|\");\n+                for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    self.print_pat(*pat);\n+                    if let Some(ty) = ty {\n+                        w!(self, \": \");\n+                        self.print_type_ref(ty);\n+                    }\n+                }\n+                w!(self, \"|\");\n+                if let Some(ret_ty) = ret_type {\n+                    w!(self, \" -> \");\n+                    self.print_type_ref(ret_ty);\n+                }\n+                self.whitespace();\n+                self.print_expr(*body);\n+            }\n+            Expr::Tuple { exprs, is_assignee_expr: _ } => {\n+                w!(self, \"(\");\n+                for expr in exprs.iter() {\n+                    self.print_expr(*expr);\n+                    w!(self, \", \");\n+                }\n+                w!(self, \")\");\n+            }\n+            Expr::Unsafe { body } => {\n+                w!(self, \"unsafe \");\n+                self.print_expr(*body);\n+            }\n+            Expr::Array(arr) => {\n+                w!(self, \"[\");\n+                if !matches!(arr, Array::ElementList { elements, .. } if elements.is_empty()) {\n+                    self.indented(|p| match arr {\n+                        Array::ElementList { elements, is_assignee_expr: _ } => {\n+                            for elem in elements.iter() {\n+                                p.print_expr(*elem);\n+                                w!(p, \", \");\n+                            }\n+                        }\n+                        Array::Repeat { initializer, repeat } => {\n+                            p.print_expr(*initializer);\n+                            w!(p, \"; \");\n+                            p.print_expr(*repeat);\n+                        }\n+                    });\n+                    self.newline();\n+                }\n+                w!(self, \"]\");\n+            }\n+            Expr::Literal(lit) => self.print_literal(lit),\n+            Expr::Block { id: _, statements, tail, label } => {\n+                self.whitespace();\n+                if let Some(lbl) = label {\n+                    w!(self, \"{}: \", self.body[*lbl].name);\n+                }\n+                w!(self, \"{{\");\n+                if !statements.is_empty() || tail.is_some() {\n+                    self.indented(|p| {\n+                        for stmt in &**statements {\n+                            p.print_stmt(stmt);\n+                        }\n+                        if let Some(tail) = tail {\n+                            p.print_expr(*tail);\n+                        }\n+                        p.newline();\n+                    });\n+                }\n+                w!(self, \"}}\");\n+            }\n+            Expr::MacroStmts { statements, tail } => {\n+                w!(self, \"{{ // macro statements\");\n+                self.indented(|p| {\n+                    for stmt in statements.iter() {\n+                        p.print_stmt(stmt);\n+                    }\n+                    if let Some(tail) = tail {\n+                        p.print_expr(*tail);\n+                    }\n+                });\n+                self.newline();\n+                w!(self, \"}}\");\n+            }\n+        }\n+    }\n+\n+    fn print_pat(&mut self, pat: PatId) {\n+        let pat = &self.body[pat];\n+\n+        match pat {\n+            Pat::Missing => w!(self, \"\ufffd\"),\n+            Pat::Wild => w!(self, \"_\"),\n+            Pat::Tuple { args, ellipsis } => {\n+                w!(self, \"(\");\n+                for (i, pat) in args.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    if *ellipsis == Some(i) {\n+                        w!(self, \".., \");\n+                    }\n+                    self.print_pat(*pat);\n+                }\n+                w!(self, \")\");\n+            }\n+            Pat::Or(pats) => {\n+                for (i, pat) in pats.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \" | \");\n+                    }\n+                    self.print_pat(*pat);\n+                }\n+            }\n+            Pat::Record { path, args, ellipsis } => {\n+                match path {\n+                    Some(path) => self.print_path(path),\n+                    None => w!(self, \"\ufffd\"),\n+                }\n+\n+                w!(self, \" {{\");\n+                self.indented(|p| {\n+                    for arg in args.iter() {\n+                        w!(p, \"{}: \", arg.name);\n+                        p.print_pat(arg.pat);\n+                        wln!(p, \",\");\n+                    }\n+                    if *ellipsis {\n+                        wln!(p, \"..\");\n+                    }\n+                });\n+                w!(self, \"}}\");\n+            }\n+            Pat::Range { start, end } => {\n+                self.print_expr(*start);\n+                w!(self, \"...\");\n+                self.print_expr(*end);\n+            }\n+            Pat::Slice { prefix, slice, suffix } => {\n+                w!(self, \"[\");\n+                for pat in prefix.iter() {\n+                    self.print_pat(*pat);\n+                    w!(self, \", \");\n+                }\n+                if let Some(pat) = slice {\n+                    self.print_pat(*pat);\n+                    w!(self, \", \");\n+                }\n+                for pat in suffix.iter() {\n+                    self.print_pat(*pat);\n+                    w!(self, \", \");\n+                }\n+                w!(self, \"]\");\n+            }\n+            Pat::Path(path) => self.print_path(path),\n+            Pat::Lit(expr) => self.print_expr(*expr),\n+            Pat::Bind { mode, name, subpat } => {\n+                let mode = match mode {\n+                    BindingAnnotation::Unannotated => \"\",\n+                    BindingAnnotation::Mutable => \"mut \",\n+                    BindingAnnotation::Ref => \"ref \",\n+                    BindingAnnotation::RefMut => \"ref mut \",\n+                };\n+                w!(self, \"{}{}\", mode, name);\n+                if let Some(pat) = subpat {\n+                    self.whitespace();\n+                    self.print_pat(*pat);\n+                }\n+            }\n+            Pat::TupleStruct { path, args, ellipsis } => {\n+                match path {\n+                    Some(path) => self.print_path(path),\n+                    None => w!(self, \"\ufffd\"),\n+                }\n+                w!(self, \"(\");\n+                for (i, arg) in args.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    if *ellipsis == Some(i) {\n+                        w!(self, \", ..\");\n+                    }\n+                    self.print_pat(*arg);\n+                }\n+                w!(self, \")\");\n+            }\n+            Pat::Ref { pat, mutability } => {\n+                w!(self, \"&\");\n+                if mutability.is_mut() {\n+                    w!(self, \"mut \");\n+                }\n+                self.print_pat(*pat);\n+            }\n+            Pat::Box { inner } => {\n+                w!(self, \"box \");\n+                self.print_pat(*inner);\n+            }\n+            Pat::ConstBlock(c) => {\n+                w!(self, \"const \");\n+                self.print_expr(*c);\n+            }\n+        }\n+    }\n+\n+    fn print_stmt(&mut self, stmt: &Statement) {\n+        match stmt {\n+            Statement::Let { pat, type_ref, initializer, else_branch } => {\n+                w!(self, \"let \");\n+                self.print_pat(*pat);\n+                if let Some(ty) = type_ref {\n+                    w!(self, \": \");\n+                    self.print_type_ref(ty);\n+                }\n+                if let Some(init) = initializer {\n+                    w!(self, \" = \");\n+                    self.print_expr(*init);\n+                }\n+                if let Some(els) = else_branch {\n+                    w!(self, \" else \");\n+                    self.print_expr(*els);\n+                }\n+                wln!(self, \";\");\n+            }\n+            Statement::Expr { expr, has_semi } => {\n+                self.print_expr(*expr);\n+                if *has_semi {\n+                    w!(self, \";\");\n+                }\n+                wln!(self);\n+            }\n+        }\n+    }\n+\n+    fn print_literal(&mut self, literal: &Literal) {\n+        match literal {\n+            Literal::String(it) => w!(self, \"{:?}\", it),\n+            Literal::ByteString(it) => w!(self, \"\\\"{}\\\"\", it.escape_ascii()),\n+            Literal::Char(it) => w!(self, \"'{}'\", it.escape_debug()),\n+            Literal::Bool(it) => w!(self, \"{}\", it),\n+            Literal::Int(i, suffix) => {\n+                w!(self, \"{}\", i);\n+                if let Some(suffix) = suffix {\n+                    w!(self, \"{}\", suffix);\n+                }\n+            }\n+            Literal::Uint(i, suffix) => {\n+                w!(self, \"{}\", i);\n+                if let Some(suffix) = suffix {\n+                    w!(self, \"{}\", suffix);\n+                }\n+            }\n+            Literal::Float(f, suffix) => {\n+                w!(self, \"{}\", f);\n+                if let Some(suffix) = suffix {\n+                    w!(self, \"{}\", suffix);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn print_type_ref(&mut self, ty: &TypeRef) {\n+        print_type_ref(ty, self).unwrap();\n+    }\n+\n+    fn print_path(&mut self, path: &Path) {\n+        print_path(path, self).unwrap();\n+    }\n+}"}, {"sha": "dd69c3ab4731519ff08c60b2696f0773906edcd7", "filename": "crates/hir-def/src/builtin_type.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -156,3 +156,38 @@ impl BuiltinFloat {\n         Some(res)\n     }\n }\n+\n+impl fmt::Display for BuiltinInt {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            BuiltinInt::Isize => \"isize\",\n+            BuiltinInt::I8 => \"i8\",\n+            BuiltinInt::I16 => \"i16\",\n+            BuiltinInt::I32 => \"i32\",\n+            BuiltinInt::I64 => \"i64\",\n+            BuiltinInt::I128 => \"i128\",\n+        })\n+    }\n+}\n+\n+impl fmt::Display for BuiltinUint {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            BuiltinUint::Usize => \"usize\",\n+            BuiltinUint::U8 => \"u8\",\n+            BuiltinUint::U16 => \"u16\",\n+            BuiltinUint::U32 => \"u32\",\n+            BuiltinUint::U64 => \"u64\",\n+            BuiltinUint::U128 => \"u128\",\n+        })\n+    }\n+}\n+\n+impl fmt::Display for BuiltinFloat {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            BuiltinFloat::F32 => \"f32\",\n+            BuiltinFloat::F64 => \"f64\",\n+        })\n+    }\n+}"}, {"sha": "4381b43c258bfe90a9387e10f7608981090105f8", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -12,6 +12,8 @@\n //!\n //! See also a neighboring `body` module.\n \n+use std::fmt;\n+\n use hir_expand::name::Name;\n use la_arena::{Idx, RawIdx};\n \n@@ -52,8 +54,8 @@ impl FloatTypeWrapper {\n     }\n }\n \n-impl std::fmt::Display for FloatTypeWrapper {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+impl fmt::Display for FloatTypeWrapper {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?}\", f64::from_bits(self.0))\n     }\n }"}, {"sha": "34dd817fd130ce555c85bff6de7544949664ceb6", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 4, "deletions": 175, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -2,13 +2,10 @@\n \n use std::fmt::{self, Write};\n \n-use itertools::Itertools;\n-\n use crate::{\n     attr::RawAttrs,\n     generics::{TypeOrConstParamData, WherePredicate, WherePredicateTypeTarget},\n-    path::GenericArg,\n-    type_ref::TraitBoundModifier,\n+    pretty::{print_path, print_type_bounds, print_type_ref},\n     visibility::RawVisibility,\n };\n \n@@ -464,183 +461,15 @@ impl<'a> Printer<'a> {\n     }\n \n     fn print_type_ref(&mut self, type_ref: &TypeRef) {\n-        // FIXME: deduplicate with `HirDisplay` impl\n-        match type_ref {\n-            TypeRef::Never => w!(self, \"!\"),\n-            TypeRef::Placeholder => w!(self, \"_\"),\n-            TypeRef::Tuple(fields) => {\n-                w!(self, \"(\");\n-                for (i, field) in fields.iter().enumerate() {\n-                    if i != 0 {\n-                        w!(self, \", \");\n-                    }\n-                    self.print_type_ref(field);\n-                }\n-                w!(self, \")\");\n-            }\n-            TypeRef::Path(path) => self.print_path(path),\n-            TypeRef::RawPtr(pointee, mtbl) => {\n-                let mtbl = match mtbl {\n-                    Mutability::Shared => \"*const\",\n-                    Mutability::Mut => \"*mut\",\n-                };\n-                w!(self, \"{} \", mtbl);\n-                self.print_type_ref(pointee);\n-            }\n-            TypeRef::Reference(pointee, lt, mtbl) => {\n-                let mtbl = match mtbl {\n-                    Mutability::Shared => \"\",\n-                    Mutability::Mut => \"mut \",\n-                };\n-                w!(self, \"&\");\n-                if let Some(lt) = lt {\n-                    w!(self, \"{} \", lt.name);\n-                }\n-                w!(self, \"{}\", mtbl);\n-                self.print_type_ref(pointee);\n-            }\n-            TypeRef::Array(elem, len) => {\n-                w!(self, \"[\");\n-                self.print_type_ref(elem);\n-                w!(self, \"; {}]\", len);\n-            }\n-            TypeRef::Slice(elem) => {\n-                w!(self, \"[\");\n-                self.print_type_ref(elem);\n-                w!(self, \"]\");\n-            }\n-            TypeRef::Fn(args_and_ret, varargs) => {\n-                let ((_, return_type), args) =\n-                    args_and_ret.split_last().expect(\"TypeRef::Fn is missing return type\");\n-                w!(self, \"fn(\");\n-                for (i, (_, typeref)) in args.iter().enumerate() {\n-                    if i != 0 {\n-                        w!(self, \", \");\n-                    }\n-                    self.print_type_ref(typeref);\n-                }\n-                if *varargs {\n-                    if !args.is_empty() {\n-                        w!(self, \", \");\n-                    }\n-                    w!(self, \"...\");\n-                }\n-                w!(self, \") -> \");\n-                self.print_type_ref(return_type);\n-            }\n-            TypeRef::Macro(_ast_id) => {\n-                w!(self, \"<macro>\");\n-            }\n-            TypeRef::Error => w!(self, \"{{unknown}}\"),\n-            TypeRef::ImplTrait(bounds) => {\n-                w!(self, \"impl \");\n-                self.print_type_bounds(bounds);\n-            }\n-            TypeRef::DynTrait(bounds) => {\n-                w!(self, \"dyn \");\n-                self.print_type_bounds(bounds);\n-            }\n-        }\n+        print_type_ref(type_ref, self).unwrap();\n     }\n \n     fn print_type_bounds(&mut self, bounds: &[Interned<TypeBound>]) {\n-        for (i, bound) in bounds.iter().enumerate() {\n-            if i != 0 {\n-                w!(self, \" + \");\n-            }\n-\n-            match bound.as_ref() {\n-                TypeBound::Path(path, modifier) => {\n-                    match modifier {\n-                        TraitBoundModifier::None => (),\n-                        TraitBoundModifier::Maybe => w!(self, \"?\"),\n-                    }\n-                    self.print_path(path)\n-                }\n-                TypeBound::ForLifetime(lifetimes, path) => {\n-                    w!(self, \"for<{}> \", lifetimes.iter().format(\", \"));\n-                    self.print_path(path);\n-                }\n-                TypeBound::Lifetime(lt) => w!(self, \"{}\", lt.name),\n-                TypeBound::Error => w!(self, \"{{unknown}}\"),\n-            }\n-        }\n+        print_type_bounds(bounds, self).unwrap();\n     }\n \n     fn print_path(&mut self, path: &Path) {\n-        match path.type_anchor() {\n-            Some(anchor) => {\n-                w!(self, \"<\");\n-                self.print_type_ref(anchor);\n-                w!(self, \">::\");\n-            }\n-            None => match path.kind() {\n-                PathKind::Plain => {}\n-                PathKind::Super(0) => w!(self, \"self::\"),\n-                PathKind::Super(n) => {\n-                    for _ in 0..*n {\n-                        w!(self, \"super::\");\n-                    }\n-                }\n-                PathKind::Crate => w!(self, \"crate::\"),\n-                PathKind::Abs => w!(self, \"::\"),\n-                PathKind::DollarCrate(_) => w!(self, \"$crate::\"),\n-            },\n-        }\n-\n-        for (i, segment) in path.segments().iter().enumerate() {\n-            if i != 0 {\n-                w!(self, \"::\");\n-            }\n-\n-            w!(self, \"{}\", segment.name);\n-            if let Some(generics) = segment.args_and_bindings {\n-                // NB: these are all in type position, so `::<` turbofish syntax is not necessary\n-                w!(self, \"<\");\n-                let mut first = true;\n-                let args = if generics.has_self_type {\n-                    let (self_ty, args) = generics.args.split_first().unwrap();\n-                    w!(self, \"Self=\");\n-                    self.print_generic_arg(self_ty);\n-                    first = false;\n-                    args\n-                } else {\n-                    &generics.args\n-                };\n-                for arg in args {\n-                    if !first {\n-                        w!(self, \", \");\n-                    }\n-                    first = false;\n-                    self.print_generic_arg(arg);\n-                }\n-                for binding in &generics.bindings {\n-                    if !first {\n-                        w!(self, \", \");\n-                    }\n-                    first = false;\n-                    w!(self, \"{}\", binding.name);\n-                    if !binding.bounds.is_empty() {\n-                        w!(self, \": \");\n-                        self.print_type_bounds(&binding.bounds);\n-                    }\n-                    if let Some(ty) = &binding.type_ref {\n-                        w!(self, \" = \");\n-                        self.print_type_ref(ty);\n-                    }\n-                }\n-\n-                w!(self, \">\");\n-            }\n-        }\n-    }\n-\n-    fn print_generic_arg(&mut self, arg: &GenericArg) {\n-        match arg {\n-            GenericArg::Type(ty) => self.print_type_ref(ty),\n-            GenericArg::Const(c) => w!(self, \"{}\", c),\n-            GenericArg::Lifetime(lt) => w!(self, \"{}\", lt.name),\n-        }\n+        print_path(path, self).unwrap();\n     }\n \n     fn print_generic_params(&mut self, params: &GenericParams) {"}, {"sha": "e30d9652bb5dde974f65e5955ba36f68d0c75305", "filename": "crates/hir-def/src/item_tree/tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -283,10 +283,10 @@ struct S {\n         \"#,\n         expect![[r#\"\n             pub(self) struct S {\n-                pub(self) a: Mixed<'a, T, Item = (), OtherItem = u8>,\n-                pub(self) b: Qualified<Self=Fully>::Syntax,\n-                pub(self) c: <TypeAnchored>::Path<'a>,\n-                pub(self) d: dyn for<'a> Trait<'a>,\n+                pub(self) a: Mixed::<'a, T, Item = (), OtherItem = u8>,\n+                pub(self) b: Qualified::<Self=Fully>::Syntax,\n+                pub(self) c: <TypeAnchored>::Path::<'a>,\n+                pub(self) d: dyn for<'a> Trait::<'a>,\n             }\n         \"#]],\n     )\n@@ -329,7 +329,7 @@ trait Tr<'a, T: 'a>: Super where Self: for<'a> Tr<'a, T> {}\n                 T: Copy,\n                 U: ?Sized;\n \n-            impl<'a, 'b, T, const K: u8> S<'a, 'b, T, K>\n+            impl<'a, 'b, T, const K: u8> S::<'a, 'b, T, K>\n             where\n                 T: Copy,\n                 T: 'a,\n@@ -352,7 +352,7 @@ trait Tr<'a, T: 'a>: Super where Self: for<'a> Tr<'a, T> {}\n             where\n                 Self: Super,\n                 T: 'a,\n-                Self: for<'a> Tr<'a, T>\n+                Self: for<'a> Tr::<'a, T>\n             {\n             }\n         \"#]],"}, {"sha": "32ebfda4fd926d475ec1b595bd0c7b01c698372f", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -53,6 +53,7 @@ pub mod import_map;\n mod test_db;\n #[cfg(test)]\n mod macro_expansion_tests;\n+mod pretty;\n \n use std::{\n     hash::{Hash, Hasher},"}, {"sha": "8dfda6df64e7c5579bfa48c908ac7c7a82a52124", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -399,35 +399,35 @@ impl DefMap {\n                 Some(_) | None => from_scope.or(from_builtin),\n             },\n         };\n-        let from_extern_prelude = self\n-            .extern_prelude\n-            .get(name)\n-            .map_or(PerNs::none(), |&it| PerNs::types(it.into(), Visibility::Public));\n \n-        let from_prelude = self.resolve_in_prelude(db, name);\n+        let extern_prelude = || {\n+            self.extern_prelude\n+                .get(name)\n+                .map_or(PerNs::none(), |&it| PerNs::types(it.into(), Visibility::Public))\n+        };\n+        let prelude = || self.resolve_in_prelude(db, name);\n \n-        from_legacy_macro.or(from_scope_or_builtin).or(from_extern_prelude).or(from_prelude)\n+        from_legacy_macro.or(from_scope_or_builtin).or_else(extern_prelude).or_else(prelude)\n     }\n \n     fn resolve_name_in_crate_root_or_extern_prelude(\n         &self,\n         db: &dyn DefDatabase,\n         name: &Name,\n     ) -> PerNs {\n-        let arc;\n-        let crate_def_map = match self.block {\n+        let from_crate_root = match self.block {\n             Some(_) => {\n-                arc = self.crate_root(db).def_map(db);\n-                &arc\n+                let def_map = self.crate_root(db).def_map(db);\n+                def_map[def_map.root].scope.get(name)\n             }\n-            None => self,\n+            None => self[self.root].scope.get(name),\n+        };\n+        let from_extern_prelude = || {\n+            self.resolve_name_in_extern_prelude(db, name)\n+                .map_or(PerNs::none(), |it| PerNs::types(it.into(), Visibility::Public))\n         };\n-        let from_crate_root = crate_def_map[crate_def_map.root].scope.get(name);\n-        let from_extern_prelude = self\n-            .resolve_name_in_extern_prelude(db, name)\n-            .map_or(PerNs::none(), |it| PerNs::types(it.into(), Visibility::Public));\n \n-        from_crate_root.or(from_extern_prelude)\n+        from_crate_root.or_else(from_extern_prelude)\n     }\n \n     fn resolve_in_prelude(&self, db: &dyn DefDatabase, name: &Name) -> PerNs {"}, {"sha": "52b79cd0fdda2f5cf0d4a61c5f349717ea7f2744", "filename": "crates/hir-def/src/nameres/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -45,7 +45,7 @@ impl Attrs {\n                     kind: ProcMacroKind::CustomDerive { helpers: Box::new([]) },\n                 }),\n \n-                // `#[proc_macro_derive(Trait, attibutes(helper1, helper2, ...))]`\n+                // `#[proc_macro_derive(Trait, attributes(helper1, helper2, ...))]`\n                 [\n                     TokenTree::Leaf(Leaf::Ident(trait_name)),\n                     TokenTree::Leaf(Leaf::Punct(comma)),"}, {"sha": "2bc1f8e926e97f04db9936a0862d36c36a7b255e", "filename": "crates/hir-def/src/per_ns.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fper_ns.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -43,6 +43,10 @@ impl PerNs {\n         self.types.is_none() && self.values.is_none() && self.macros.is_none()\n     }\n \n+    pub fn is_full(&self) -> bool {\n+        self.types.is_some() && self.values.is_some() && self.macros.is_some()\n+    }\n+\n     pub fn take_types(self) -> Option<ModuleDefId> {\n         self.types.map(|it| it.0)\n     }\n@@ -84,6 +88,14 @@ impl PerNs {\n         }\n     }\n \n+    pub fn or_else(self, f: impl FnOnce() -> PerNs) -> PerNs {\n+        if self.is_full() {\n+            self\n+        } else {\n+            self.or(f())\n+        }\n+    }\n+\n     pub fn iter_items(self) -> impl Iterator<Item = ItemInNs> {\n         let _p = profile::span(\"PerNs::iter_items\");\n         self.types"}, {"sha": "6636c8a23ca5fea4e31eef52f1d9d86ab0292359", "filename": "crates/hir-def/src/pretty.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -0,0 +1,209 @@\n+//! Display and pretty printing routines.\n+\n+use std::fmt::{self, Write};\n+\n+use hir_expand::mod_path::PathKind;\n+use itertools::Itertools;\n+\n+use crate::{\n+    intern::Interned,\n+    path::{GenericArg, GenericArgs, Path},\n+    type_ref::{Mutability, TraitBoundModifier, TypeBound, TypeRef},\n+};\n+\n+pub(crate) fn print_path(path: &Path, buf: &mut dyn Write) -> fmt::Result {\n+    match path.type_anchor() {\n+        Some(anchor) => {\n+            write!(buf, \"<\")?;\n+            print_type_ref(anchor, buf)?;\n+            write!(buf, \">::\")?;\n+        }\n+        None => match path.kind() {\n+            PathKind::Plain => {}\n+            PathKind::Super(0) => write!(buf, \"self\")?,\n+            PathKind::Super(n) => {\n+                for i in 0..*n {\n+                    if i == 0 {\n+                        buf.write_str(\"super\")?;\n+                    } else {\n+                        buf.write_str(\"::super\")?;\n+                    }\n+                }\n+            }\n+            PathKind::Crate => write!(buf, \"crate\")?,\n+            PathKind::Abs => {}\n+            PathKind::DollarCrate(_) => write!(buf, \"$crate\")?,\n+        },\n+    }\n+\n+    for (i, segment) in path.segments().iter().enumerate() {\n+        if i != 0 || !matches!(path.kind(), PathKind::Plain) {\n+            write!(buf, \"::\")?;\n+        }\n+\n+        write!(buf, \"{}\", segment.name)?;\n+        if let Some(generics) = segment.args_and_bindings {\n+            write!(buf, \"::<\")?;\n+            print_generic_args(generics, buf)?;\n+\n+            write!(buf, \">\")?;\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+pub(crate) fn print_generic_args(generics: &GenericArgs, buf: &mut dyn Write) -> fmt::Result {\n+    let mut first = true;\n+    let args = if generics.has_self_type {\n+        let (self_ty, args) = generics.args.split_first().unwrap();\n+        write!(buf, \"Self=\")?;\n+        print_generic_arg(self_ty, buf)?;\n+        first = false;\n+        args\n+    } else {\n+        &generics.args\n+    };\n+    for arg in args {\n+        if !first {\n+            write!(buf, \", \")?;\n+        }\n+        first = false;\n+        print_generic_arg(arg, buf)?;\n+    }\n+    for binding in &generics.bindings {\n+        if !first {\n+            write!(buf, \", \")?;\n+        }\n+        first = false;\n+        write!(buf, \"{}\", binding.name)?;\n+        if !binding.bounds.is_empty() {\n+            write!(buf, \": \")?;\n+            print_type_bounds(&binding.bounds, buf)?;\n+        }\n+        if let Some(ty) = &binding.type_ref {\n+            write!(buf, \" = \")?;\n+            print_type_ref(ty, buf)?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n+pub(crate) fn print_generic_arg(arg: &GenericArg, buf: &mut dyn Write) -> fmt::Result {\n+    match arg {\n+        GenericArg::Type(ty) => print_type_ref(ty, buf),\n+        GenericArg::Const(c) => write!(buf, \"{}\", c),\n+        GenericArg::Lifetime(lt) => write!(buf, \"{}\", lt.name),\n+    }\n+}\n+\n+pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Result {\n+    // FIXME: deduplicate with `HirDisplay` impl\n+    match type_ref {\n+        TypeRef::Never => write!(buf, \"!\")?,\n+        TypeRef::Placeholder => write!(buf, \"_\")?,\n+        TypeRef::Tuple(fields) => {\n+            write!(buf, \"(\")?;\n+            for (i, field) in fields.iter().enumerate() {\n+                if i != 0 {\n+                    write!(buf, \", \")?;\n+                }\n+                print_type_ref(field, buf)?;\n+            }\n+            write!(buf, \")\")?;\n+        }\n+        TypeRef::Path(path) => print_path(path, buf)?,\n+        TypeRef::RawPtr(pointee, mtbl) => {\n+            let mtbl = match mtbl {\n+                Mutability::Shared => \"*const\",\n+                Mutability::Mut => \"*mut\",\n+            };\n+            write!(buf, \"{} \", mtbl)?;\n+            print_type_ref(pointee, buf)?;\n+        }\n+        TypeRef::Reference(pointee, lt, mtbl) => {\n+            let mtbl = match mtbl {\n+                Mutability::Shared => \"\",\n+                Mutability::Mut => \"mut \",\n+            };\n+            write!(buf, \"&\")?;\n+            if let Some(lt) = lt {\n+                write!(buf, \"{} \", lt.name)?;\n+            }\n+            write!(buf, \"{}\", mtbl)?;\n+            print_type_ref(pointee, buf)?;\n+        }\n+        TypeRef::Array(elem, len) => {\n+            write!(buf, \"[\")?;\n+            print_type_ref(elem, buf)?;\n+            write!(buf, \"; {}]\", len)?;\n+        }\n+        TypeRef::Slice(elem) => {\n+            write!(buf, \"[\")?;\n+            print_type_ref(elem, buf)?;\n+            write!(buf, \"]\")?;\n+        }\n+        TypeRef::Fn(args_and_ret, varargs) => {\n+            let ((_, return_type), args) =\n+                args_and_ret.split_last().expect(\"TypeRef::Fn is missing return type\");\n+            write!(buf, \"fn(\")?;\n+            for (i, (_, typeref)) in args.iter().enumerate() {\n+                if i != 0 {\n+                    write!(buf, \", \")?;\n+                }\n+                print_type_ref(typeref, buf)?;\n+            }\n+            if *varargs {\n+                if !args.is_empty() {\n+                    write!(buf, \", \")?;\n+                }\n+                write!(buf, \"...\")?;\n+            }\n+            write!(buf, \") -> \")?;\n+            print_type_ref(return_type, buf)?;\n+        }\n+        TypeRef::Macro(_ast_id) => {\n+            write!(buf, \"<macro>\")?;\n+        }\n+        TypeRef::Error => write!(buf, \"{{unknown}}\")?,\n+        TypeRef::ImplTrait(bounds) => {\n+            write!(buf, \"impl \")?;\n+            print_type_bounds(bounds, buf)?;\n+        }\n+        TypeRef::DynTrait(bounds) => {\n+            write!(buf, \"dyn \")?;\n+            print_type_bounds(bounds, buf)?;\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+pub(crate) fn print_type_bounds(\n+    bounds: &[Interned<TypeBound>],\n+    buf: &mut dyn Write,\n+) -> fmt::Result {\n+    for (i, bound) in bounds.iter().enumerate() {\n+        if i != 0 {\n+            write!(buf, \" + \")?;\n+        }\n+\n+        match bound.as_ref() {\n+            TypeBound::Path(path, modifier) => {\n+                match modifier {\n+                    TraitBoundModifier::None => (),\n+                    TraitBoundModifier::Maybe => write!(buf, \"?\")?,\n+                }\n+                print_path(path, buf)?;\n+            }\n+            TypeBound::ForLifetime(lifetimes, path) => {\n+                write!(buf, \"for<{}> \", lifetimes.iter().format(\", \"))?;\n+                print_path(path, buf)?;\n+            }\n+            TypeBound::Lifetime(lt) => write!(buf, \"{}\", lt.name)?,\n+            TypeBound::Error => write!(buf, \"{{unknown}}\")?,\n+        }\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "5b4c71be7fb837eb688529d7d6ab976445655979", "filename": "crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -77,6 +77,10 @@ impl Rawness {\n             Rawness::Ref\n         }\n     }\n+\n+    pub fn is_raw(&self) -> bool {\n+        matches!(self, Self::RawPtr)\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "11c0a6764e9d89b745325a63537dd4dda1c10628", "filename": "crates/hir-expand/src/ast_id_map.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fast_id_map.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -15,7 +15,7 @@ use std::{\n use la_arena::{Arena, Idx};\n use profile::Count;\n use rustc_hash::FxHasher;\n-use syntax::{ast, match_ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr};\n+use syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr};\n \n /// `AstId` points to an AST node in a specific file.\n pub struct FileAstId<N: AstNode> {\n@@ -92,18 +92,12 @@ impl AstIdMap {\n         // change parent's id. This means that, say, adding a new function to a\n         // trait does not change ids of top-level items, which helps caching.\n         bdfs(node, |it| {\n-            match_ast! {\n-                match it {\n-                    ast::Item(module_item) => {\n-                        res.alloc(module_item.syntax());\n-                        true\n-                    },\n-                    ast::BlockExpr(block) => {\n-                        res.alloc(block.syntax());\n-                        true\n-                    },\n-                    _ => false,\n-                }\n+            let kind = it.kind();\n+            if ast::Item::can_cast(kind) || ast::BlockExpr::can_cast(kind) {\n+                res.alloc(&it);\n+                true\n+            } else {\n+                false\n             }\n         });\n         res.map = hashbrown::HashMap::with_capacity_and_hasher(res.arena.len(), ());\n@@ -123,6 +117,7 @@ impl AstIdMap {\n         let raw = self.erased_ast_id(item.syntax());\n         FileAstId { raw, _ty: PhantomData }\n     }\n+\n     fn erased_ast_id(&self, item: &SyntaxNode) -> ErasedFileAstId {\n         let ptr = SyntaxNodePtr::new(item);\n         let hash = hash_ptr(&ptr);"}, {"sha": "bc97ee15c7d3030be56a04047cbace837f8261a6", "filename": "crates/hir-expand/src/db.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -321,7 +321,11 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n                 ast::Item::cast(node.clone())?\n                     .attrs()\n                     .take(derive_attr_index as usize + 1)\n-                    // FIXME\n+                    // FIXME, this resolution should not be done syntactically\n+                    // derive is a proper macro now, no longer builtin\n+                    // But we do not have resolution at this stage, this means\n+                    // we need to know about all macro calls for the given ast item here\n+                    // so we require some kind of mapping...\n                     .filter(|attr| attr.simple_name().as_deref() == Some(\"derive\"))\n                     .map(|it| it.syntax().clone())\n                     .collect()"}, {"sha": "d753d88470c442cb3c372494c2fc38720eb91573", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -130,7 +130,6 @@ pub struct MacroDefId {\n pub enum MacroDefKind {\n     Declarative(AstId<ast::Macro>),\n     BuiltIn(BuiltinFnLikeExpander, AstId<ast::Macro>),\n-    // FIXME: maybe just Builtin and rename BuiltinFnLikeExpander to BuiltinExpander\n     BuiltInAttr(BuiltinAttrExpander, AstId<ast::Macro>),\n     BuiltInDerive(BuiltinDeriveExpander, AstId<ast::Macro>),\n     BuiltInEager(EagerExpander, AstId<ast::Macro>),\n@@ -617,7 +616,7 @@ impl ExpansionInfo {\n \n         let token_id = match token_id_in_attr_input {\n             Some(token_id) => token_id,\n-            // the token is not inside an attribute's input so do the lookup in the macro_arg as ususal\n+            // the token is not inside an attribute's input so do the lookup in the macro_arg as usual\n             None => {\n                 let relative_range =\n                     token.value.text_range().checked_sub(self.arg.value.text_range().start())?;"}, {"sha": "d7586d129b768b1e639b915df81f51aa4a5c89b5", "filename": "crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -257,6 +257,7 @@ macro_rules! __known_path {\n     (core::ops::RangeToInclusive) => {};\n     (core::ops::RangeInclusive) => {};\n     (core::future::Future) => {};\n+    (core::future::IntoFuture) => {};\n     (core::ops::Try) => {};\n     ($path:path) => {\n         compile_error!(\"Please register your known path in the path module\")"}, {"sha": "2b859f775095beb0e005fb1657e59d001e933408", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -90,10 +90,16 @@ impl Name {\n \n     /// Resolve a name from the text of token.\n     fn resolve(raw_text: &str) -> Name {\n-        // When `raw_text` starts with \"r#\" but the name does not coincide with any\n-        // keyword, we never need the prefix so we strip it.\n         match raw_text.strip_prefix(\"r#\") {\n+            // When `raw_text` starts with \"r#\" but the name does not coincide with any\n+            // keyword, we never need the prefix so we strip it.\n             Some(text) if !is_raw_identifier(text) => Name::new_text(SmolStr::new(text)),\n+            // Keywords (in the current edition) *can* be used as a name in earlier editions of\n+            // Rust, e.g. \"try\" in Rust 2015. Even in such cases, we keep track of them in their\n+            // escaped form.\n+            None if is_raw_identifier(raw_text) => {\n+                Name::new_text(SmolStr::from_iter([\"r#\", raw_text]))\n+            }\n             _ => Name::new_text(raw_text.into()),\n         }\n     }\n@@ -260,6 +266,7 @@ pub mod known {\n         Try,\n         Ok,\n         Future,\n+        IntoFuture,\n         Result,\n         Option,\n         Output,\n@@ -393,6 +400,7 @@ pub mod known {\n         future_trait,\n         index,\n         index_mut,\n+        into_future,\n         mul_assign,\n         mul,\n         neg,"}, {"sha": "7f143f396c765055c0a9b54702129d163866194d", "filename": "crates/hir-ty/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2FCargo.toml?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -18,9 +18,9 @@ ena = \"0.14.0\"\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1.0.0\"\n-chalk-solve = { version = \"0.83.0\", default-features = false }\n-chalk-ir = \"0.83.0\"\n-chalk-recursive = { version = \"0.83.0\", default-features = false }\n+chalk-solve = { version = \"0.84.0\", default-features = false }\n+chalk-ir = \"0.84.0\"\n+chalk-recursive = { version = \"0.84.0\", default-features = false }\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.12.0\"\n typed-arena = \"2.0.1\""}, {"sha": "5df48e5fdcbaf40502d0aa11f3b9bd666132b771", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -734,6 +734,7 @@ impl<'a> InferenceContext<'a> {\n                         let ty = self.insert_type_vars(ty.substitute(Interner, &substs));\n                         return (ty, Some(strukt.into()));\n                     }\n+                    ValueNs::ImplSelf(impl_id) => (TypeNs::SelfType(impl_id), None),\n                     _ => return (self.err_ty(), None),\n                 },\n                 Some(ResolveValueResult::Partial(typens, unresolved)) => (typens, Some(unresolved)),\n@@ -875,7 +876,10 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(name![future_trait])?.as_trait()?;\n+        let trait_ = self\n+            .resolver\n+            .resolve_known_trait(self.db.upcast(), &path![core::future::IntoFuture])\n+            .or_else(|| self.resolve_lang_item(name![future_trait])?.as_trait())?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n "}, {"sha": "ae115c8c0da85ad7afa7a84dd4fbee7fbd01cc47", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -238,18 +238,7 @@ impl<'a> TyLoweringContext<'a> {\n                 })\n                 .intern(Interner)\n             }\n-            TypeRef::DynTrait(bounds) => {\n-                let self_ty =\n-                    TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(Interner);\n-                let bounds = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-                    QuantifiedWhereClauses::from_iter(\n-                        Interner,\n-                        bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)),\n-                    )\n-                });\n-                let bounds = crate::make_single_type_binders(bounds);\n-                TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(Interner)\n-            }\n+            TypeRef::DynTrait(bounds) => self.lower_dyn_trait(bounds),\n             TypeRef::ImplTrait(bounds) => {\n                 match self.impl_trait_mode {\n                     ImplTraitLoweringMode::Opaque => {\n@@ -468,29 +457,10 @@ impl<'a> TyLoweringContext<'a> {\n                         }\n                     }\n                     0 => {\n-                        let self_ty = Some(\n-                            TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n-                                .intern(Interner),\n-                        );\n-                        let trait_ref = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-                            ctx.lower_trait_ref_from_resolved_path(\n-                                trait_,\n-                                resolved_segment,\n-                                self_ty,\n-                            )\n-                        });\n-                        let dyn_ty = DynTy {\n-                            bounds: crate::make_single_type_binders(\n-                                QuantifiedWhereClauses::from_iter(\n-                                    Interner,\n-                                    Some(crate::wrap_empty_binders(WhereClause::Implemented(\n-                                        trait_ref,\n-                                    ))),\n-                                ),\n-                            ),\n-                            lifetime: static_lifetime(),\n-                        };\n-                        TyKind::Dyn(dyn_ty).intern(Interner)\n+                        // Trait object type without dyn; this should be handled in upstream. See\n+                        // `lower_path()`.\n+                        stdx::never!(\"unexpected fully resolved trait path\");\n+                        TyKind::Error.intern(Interner)\n                     }\n                     _ => {\n                         // FIXME report error (ambiguous associated type)\n@@ -555,11 +525,20 @@ impl<'a> TyLoweringContext<'a> {\n             let (ty, res) = self.lower_ty_ext(type_ref);\n             return self.lower_ty_relative_path(ty, res, path.segments());\n         }\n+\n         let (resolution, remaining_index) =\n             match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n                 Some(it) => it,\n                 None => return (TyKind::Error.intern(Interner), None),\n             };\n+\n+        if matches!(resolution, TypeNs::TraitId(_)) && remaining_index.is_none() {\n+            // trait object type without dyn\n+            let bound = TypeBound::Path(path.clone(), TraitBoundModifier::None);\n+            let ty = self.lower_dyn_trait(&[Interned::new(bound)]);\n+            return (ty, None);\n+        }\n+\n         let (resolved_segment, remaining_segments) = match remaining_index {\n             None => (\n                 path.segments().last().expect(\"resolved path has at least one element\"),\n@@ -987,6 +966,18 @@ impl<'a> TyLoweringContext<'a> {\n             })\n     }\n \n+    fn lower_dyn_trait(&self, bounds: &[Interned<TypeBound>]) -> Ty {\n+        let self_ty = TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(Interner);\n+        let bounds = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n+            QuantifiedWhereClauses::from_iter(\n+                Interner,\n+                bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)),\n+            )\n+        });\n+        let bounds = crate::make_single_type_binders(bounds);\n+        TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(Interner)\n+    }\n+\n     fn lower_impl_trait(\n         &self,\n         bounds: &[Interned<TypeBound>],"}, {"sha": "9a63d5013b4671274e8c93747049a5aa11fd33c7", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 97, "deletions": 45, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -1064,6 +1064,14 @@ pub fn resolve_indexing_op(\n     None\n }\n \n+macro_rules! check_that {\n+    ($cond:expr) => {\n+        if !$cond {\n+            return false;\n+        }\n+    };\n+}\n+\n fn is_valid_candidate(\n     table: &mut InferenceTable<'_>,\n     name: Option<&Name>,\n@@ -1072,54 +1080,10 @@ fn is_valid_candidate(\n     self_ty: &Ty,\n     visible_from_module: Option<ModuleId>,\n ) -> bool {\n-    macro_rules! check_that {\n-        ($cond:expr) => {\n-            if !$cond {\n-                return false;\n-            }\n-        };\n-    }\n-\n     let db = table.db;\n     match item {\n         AssocItemId::FunctionId(m) => {\n-            let data = db.function_data(m);\n-\n-            check_that!(name.map_or(true, |n| n == &data.name));\n-            check_that!(visible_from_module.map_or(true, |from_module| {\n-                let v = db.function_visibility(m).is_visible_from(db.upcast(), from_module);\n-                if !v {\n-                    cov_mark::hit!(autoderef_candidate_not_visible);\n-                }\n-                v\n-            }));\n-\n-            table.run_in_snapshot(|table| {\n-                let subst = TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n-                let expect_self_ty = match m.lookup(db.upcast()).container {\n-                    ItemContainerId::TraitId(_) => {\n-                        subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n-                    }\n-                    ItemContainerId::ImplId(impl_id) => {\n-                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n-                    }\n-                    // We should only get called for associated items (impl/trait)\n-                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                        unreachable!()\n-                    }\n-                };\n-                check_that!(table.unify(&expect_self_ty, self_ty));\n-                if let Some(receiver_ty) = receiver_ty {\n-                    check_that!(data.has_self_param());\n-\n-                    let sig = db.callable_item_signature(m.into());\n-                    let expected_receiver =\n-                        sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n-\n-                    check_that!(table.unify(&receiver_ty, &expected_receiver));\n-                }\n-                true\n-            })\n+            is_valid_fn_candidate(table, m, name, receiver_ty, self_ty, visible_from_module)\n         }\n         AssocItemId::ConstId(c) => {\n             let data = db.const_data(c);\n@@ -1152,6 +1116,94 @@ fn is_valid_candidate(\n     }\n }\n \n+fn is_valid_fn_candidate(\n+    table: &mut InferenceTable<'_>,\n+    fn_id: FunctionId,\n+    name: Option<&Name>,\n+    receiver_ty: Option<&Ty>,\n+    self_ty: &Ty,\n+    visible_from_module: Option<ModuleId>,\n+) -> bool {\n+    let db = table.db;\n+    let data = db.function_data(fn_id);\n+\n+    check_that!(name.map_or(true, |n| n == &data.name));\n+    check_that!(visible_from_module.map_or(true, |from_module| {\n+        let v = db.function_visibility(fn_id).is_visible_from(db.upcast(), from_module);\n+        if !v {\n+            cov_mark::hit!(autoderef_candidate_not_visible);\n+        }\n+        v\n+    }));\n+\n+    table.run_in_snapshot(|table| {\n+        let container = fn_id.lookup(db.upcast()).container;\n+        let impl_subst = match container {\n+            ItemContainerId::ImplId(it) => {\n+                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+            }\n+            ItemContainerId::TraitId(it) => {\n+                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        let fn_subst = TyBuilder::subst_for_def(db, fn_id)\n+            .use_parent_substs(&impl_subst)\n+            .fill_with_inference_vars(table)\n+            .build();\n+\n+        let expect_self_ty = match container {\n+            ItemContainerId::TraitId(_) => fn_subst.at(Interner, 0).assert_ty_ref(Interner).clone(),\n+            ItemContainerId::ImplId(impl_id) => {\n+                fn_subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n+            }\n+            // We should only get called for associated items (impl/trait)\n+            ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                unreachable!()\n+            }\n+        };\n+        check_that!(table.unify(&expect_self_ty, self_ty));\n+\n+        if let Some(receiver_ty) = receiver_ty {\n+            check_that!(data.has_self_param());\n+\n+            let sig = db.callable_item_signature(fn_id.into());\n+            let expected_receiver =\n+                sig.map(|s| s.params()[0].clone()).substitute(Interner, &fn_subst);\n+\n+            check_that!(table.unify(&receiver_ty, &expected_receiver));\n+        }\n+\n+        if let ItemContainerId::ImplId(impl_id) = container {\n+            // We need to consider the bounds on the impl to distinguish functions of the same name\n+            // for a type.\n+            let predicates = db.generic_predicates(impl_id.into());\n+            predicates\n+                .iter()\n+                .map(|predicate| {\n+                    let (p, b) = predicate\n+                        .clone()\n+                        .substitute(Interner, &impl_subst)\n+                        // Skipping the inner binders is ok, as we don't handle quantified where\n+                        // clauses yet.\n+                        .into_value_and_skipped_binders();\n+                    stdx::always!(b.len(Interner) == 0);\n+                    p\n+                })\n+                // It's ok to get ambiguity here, as we may not have enough information to prove\n+                // obligations. We'll check if the user is calling the selected method properly\n+                // later anyway.\n+                .all(|p| table.try_obligation(p.cast(Interner)).is_some())\n+        } else {\n+            // For `ItemContainerId::TraitId`, we check if `self_ty` implements the trait in\n+            // `iterate_trait_method_candidates()`.\n+            // For others, this function shouldn't be called.\n+            true\n+        }\n+    })\n+}\n+\n pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,"}, {"sha": "81588a7c4ffd668bb6ccfb92f65e3628b09cb5a7", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -1790,3 +1790,46 @@ impl u16 {\n         \"#,\n     )\n }\n+\n+#[test]\n+fn with_impl_bounds() {\n+    check_types(\n+        r#\"\n+trait Trait {}\n+struct Foo<T>(T);\n+impl Trait for isize {}\n+\n+impl<T: Trait> Foo<T> {\n+  fn foo() -> isize { 0 }\n+  fn bar(&self) -> isize { 0 }\n+}\n+\n+impl Foo<()> {\n+  fn foo() {}\n+  fn bar(&self) {}\n+}\n+\n+fn f() {\n+  let _ = Foo::<isize>::foo();\n+    //^isize\n+  let _ = Foo(0isize).bar();\n+    //^isize\n+  let _ = Foo::<()>::foo();\n+    //^()\n+  let _ = Foo(()).bar();\n+    //^()\n+  let _ = Foo::<usize>::foo();\n+    //^{unknown}\n+  let _ = Foo(0usize).bar();\n+    //^{unknown}\n+}\n+\n+fn g<T: Trait>(a: T) {\n+    let _ = Foo::<T>::foo();\n+      //^isize\n+    let _ = Foo(a).bar();\n+      //^isize\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "eb04bf87783b40dc8a0c9ef78b7b42044b407a7e", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -488,6 +488,42 @@ fn infer_adt_pattern() {\n     );\n }\n \n+#[test]\n+fn tuple_struct_destructured_with_self() {\n+    check_infer(\n+        r#\"\n+struct Foo(usize,);\n+impl Foo {\n+    fn f() {\n+        let Self(s,) = &Foo(0,);\n+        let Self(s,) = &mut Foo(0,);\n+        let Self(s,) = Foo(0,);\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            42..151 '{     ...     }': ()\n+            56..64 'Self(s,)': Foo\n+            61..62 's': &usize\n+            67..75 '&Foo(0,)': &Foo\n+            68..71 'Foo': Foo(usize) -> Foo\n+            68..75 'Foo(0,)': Foo\n+            72..73 '0': usize\n+            89..97 'Self(s,)': Foo\n+            94..95 's': &mut usize\n+            100..112 '&mut Foo(0,)': &mut Foo\n+            105..108 'Foo': Foo(usize) -> Foo\n+            105..112 'Foo(0,)': Foo\n+            109..110 '0': usize\n+            126..134 'Self(s,)': Foo\n+            131..132 's': usize\n+            137..140 'Foo': Foo(usize) -> Foo\n+            137..144 'Foo(0,)': Foo\n+            141..142 '0': usize\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn enum_variant_through_self_in_pattern() {\n     check_infer("}, {"sha": "1b5ed0603bfd137696aeb4fd7c79cf86bf8cb46f", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -1648,3 +1648,20 @@ fn main() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn trailing_empty_macro() {\n+    cov_mark::check!(empty_macro_in_trailing_position_is_removed);\n+    check_no_mismatches(\n+        r#\"\n+macro_rules! m2 {\n+    ($($t:tt)*) => {$($t)*};\n+}\n+\n+fn macrostmts() -> u8 {\n+    m2! { 0 }\n+    m2! {}\n+}\n+    \"#,\n+    );\n+}"}, {"sha": "0f37970e2b38d7fe678e101b19873789b2fbdd7e", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -137,6 +137,31 @@ fn not_send() -> Box<dyn Future<Output = ()> + 'static> {\n     );\n }\n \n+#[test]\n+fn into_future_trait() {\n+    check_types(\n+        r#\"\n+//- minicore: future\n+struct Futurable;\n+impl core::future::IntoFuture for Futurable {\n+    type Output = u64;\n+    type IntoFuture = IntFuture;\n+}\n+\n+struct IntFuture;\n+impl core::future::Future for IntFuture {\n+    type Output = u64;\n+}\n+\n+fn test() {\n+    let r = Futurable;\n+    let v = r.await;\n+    v;\n+} //^ u64\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_try() {\n     check_types(\n@@ -1476,6 +1501,34 @@ fn test(x: Trait, y: &Trait) -> u64 {\n             165..172 'z.foo()': u64\n         \"#]],\n     );\n+\n+    check_infer_with_mismatches(\n+        r#\"\n+//- minicore: fn, coerce_unsized\n+struct S;\n+impl S {\n+    fn foo(&self) {}\n+}\n+fn f(_: &Fn(S)) {}\n+fn main() {\n+    f(&|number| number.foo());\n+}\n+        \"#,\n+        expect![[r#\"\n+            31..35 'self': &S\n+            37..39 '{}': ()\n+            47..48 '_': &dyn Fn(S)\n+            58..60 '{}': ()\n+            71..105 '{     ...()); }': ()\n+            77..78 'f': fn f(&dyn Fn(S))\n+            77..102 'f(&|nu...foo())': ()\n+            79..101 '&|numb....foo()': &|S| -> ()\n+            80..101 '|numbe....foo()': |S| -> ()\n+            81..87 'number': S\n+            89..95 'number': S\n+            89..101 'number.foo()': ()\n+        \"#]],\n+    )\n }\n \n #[test]"}, {"sha": "aa019ca48381adc9230359094bdf6e69f23701f9", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -72,7 +72,7 @@ use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n use once_cell::unsync::Lazy;\n use rustc_hash::FxHashSet;\n-use stdx::{format_to, impl_from, never};\n+use stdx::{impl_from, never};\n use syntax::{\n     ast::{self, HasAttrs as _, HasDocComments, HasName},\n     AstNode, AstPtr, SmolStr, SyntaxNodePtr, TextRange, T,\n@@ -1136,6 +1136,20 @@ impl DefWithBody {\n         }\n     }\n \n+    fn id(&self) -> DefWithBodyId {\n+        match self {\n+            DefWithBody::Function(it) => it.id.into(),\n+            DefWithBody::Static(it) => it.id.into(),\n+            DefWithBody::Const(it) => it.id.into(),\n+        }\n+    }\n+\n+    /// A textual representation of the HIR of this def's body for debugging purposes.\n+    pub fn debug_hir(self, db: &dyn HirDatabase) -> String {\n+        let body = db.body(self.id());\n+        body.pretty_print(db.upcast(), self.id())\n+    }\n+\n     pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let krate = self.module(db).id.krate();\n \n@@ -1470,19 +1484,6 @@ impl Function {\n         let def_map = db.crate_def_map(loc.krate(db).into());\n         def_map.fn_as_proc_macro(self.id).map(|id| Macro { id: id.into() })\n     }\n-\n-    /// A textual representation of the HIR of this function for debugging purposes.\n-    pub fn debug_hir(self, db: &dyn HirDatabase) -> String {\n-        let body = db.body(self.id.into());\n-\n-        let mut result = String::new();\n-        format_to!(result, \"HIR expressions in the body of `{}`:\\n\", self.name(db));\n-        for (id, expr) in body.exprs.iter() {\n-            format_to!(result, \"{:?}: {:?}\\n\", id, expr);\n-        }\n-\n-        result\n-    }\n }\n \n // Note: logically, this belongs to `hir_ty`, but we are not using it there yet.\n@@ -2777,20 +2778,32 @@ impl Type {\n         self.ty.is_unknown()\n     }\n \n-    /// Checks that particular type `ty` implements `std::future::Future`.\n+    /// Checks that particular type `ty` implements `std::future::IntoFuture` or\n+    /// `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n-    pub fn impls_future(&self, db: &dyn HirDatabase) -> bool {\n-        let std_future_trait = db\n-            .lang_item(self.env.krate, SmolStr::new_inline(\"future_trait\"))\n-            .and_then(|it| it.as_trait());\n-        let std_future_trait = match std_future_trait {\n+    pub fn impls_into_future(&self, db: &dyn HirDatabase) -> bool {\n+        let trait_ = db\n+            .lang_item(self.env.krate, SmolStr::new_inline(\"into_future\"))\n+            .and_then(|it| {\n+                let into_future_fn = it.as_function()?;\n+                let assoc_item = as_assoc_item(db, AssocItem::Function, into_future_fn)?;\n+                let into_future_trait = assoc_item.containing_trait_or_trait_impl(db)?;\n+                Some(into_future_trait.id)\n+            })\n+            .or_else(|| {\n+                let future_trait =\n+                    db.lang_item(self.env.krate, SmolStr::new_inline(\"future_trait\"))?;\n+                future_trait.as_trait()\n+            });\n+\n+        let trait_ = match trait_ {\n             Some(it) => it,\n             None => return false,\n         };\n \n         let canonical_ty =\n             Canonical { value: self.ty.clone(), binders: CanonicalVarKinds::empty(Interner) };\n-        method_resolution::implements_trait(&canonical_ty, db, self.env.clone(), std_future_trait)\n+        method_resolution::implements_trait(&canonical_ty, db, self.env.clone(), trait_)\n     }\n \n     /// Checks that particular type `ty` implements `std::ops::FnOnce`."}, {"sha": "bd35af06e23eb0ccbbd29146b61ca99394db1bfa", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -27,6 +27,7 @@ use hir_def::{\n use hir_expand::{\n     builtin_fn_macro::BuiltinFnLikeExpander,\n     hygiene::Hygiene,\n+    mod_path::path,\n     name,\n     name::{AsName, Name},\n     HirFileId, InFile,\n@@ -269,14 +270,35 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         await_expr: &ast::AwaitExpr,\n     ) -> Option<FunctionId> {\n-        let ty = self.ty_of_expr(db, &await_expr.expr()?.into())?;\n+        let mut ty = self.ty_of_expr(db, &await_expr.expr()?.into())?.clone();\n+\n+        let into_future_trait = self\n+            .resolver\n+            .resolve_known_trait(db.upcast(), &path![core::future::IntoFuture])\n+            .map(Trait::from);\n+\n+        if let Some(into_future_trait) = into_future_trait {\n+            let type_ = Type::new_with_resolver(db, &self.resolver, ty.clone());\n+            if type_.impls_trait(db, into_future_trait, &[]) {\n+                let items = into_future_trait.items(db);\n+                let into_future_type = items.into_iter().find_map(|item| match item {\n+                    AssocItem::TypeAlias(alias)\n+                        if alias.name(db) == hir_expand::name![IntoFuture] =>\n+                    {\n+                        Some(alias)\n+                    }\n+                    _ => None,\n+                })?;\n+                let future_trait = type_.normalize_trait_assoc_type(db, &[], into_future_type)?;\n+                ty = future_trait.ty;\n+            }\n+        }\n \n-        let op_fn = db\n+        let poll_fn = db\n             .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n             .as_function()?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n-\n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, poll_fn).push(ty.clone()).build();\n+        Some(self.resolve_impl_method_or_trait_def(db, poll_fn, &substs))\n     }\n \n     pub(crate) fn resolve_prefix_expr("}, {"sha": "897980c6650497132360baa4833ee68bcb5858a1", "filename": "crates/ide-assists/src/handlers/extract_module.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -29,7 +29,7 @@ use super::remove_unused_param::range_to_remove;\n \n // Assist: extract_module\n //\n-// Extracts a selected region as seperate module. All the references, visibility and imports are\n+// Extracts a selected region as separate module. All the references, visibility and imports are\n // resolved.\n //\n // ```\n@@ -105,7 +105,7 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n             //\n             //- Thirdly, resolving all the imports this includes removing paths from imports\n             //  outside the module, shifting/cloning them inside new module, or shifting the imports, or making\n-            //  new import statemnts\n+            //  new import statements\n \n             //We are getting item usages and record_fields together, record_fields\n             //for change_visibility and usages for first point mentioned above in the process\n@@ -661,7 +661,7 @@ fn check_intersection_and_push(\n     import_path: TextRange,\n ) {\n     if import_paths_to_be_removed.len() > 0 {\n-        // Text ranges recieved here for imports are extended to the\n+        // Text ranges received here for imports are extended to the\n         // next/previous comma which can cause intersections among them\n         // and later deletion of these can cause panics similar\n         // to reported in #11766. So to mitigate it, we"}, {"sha": "e26c76da1891649c0a035706e5eb278aa325b99e", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 106, "deletions": 36, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -61,56 +61,72 @@ fn gen_fn(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     }\n \n     let fn_name = &*name_ref.text();\n-    let target_module;\n-    let mut adt_name = None;\n+    let TargetInfo { target_module, adt_name, target, file, insert_offset } =\n+        fn_target_info(ctx, path, &call, fn_name)?;\n+    let function_builder = FunctionBuilder::from_call(ctx, &call, fn_name, target_module, target)?;\n+    let text_range = call.syntax().text_range();\n+    let label = format!(\"Generate {} function\", function_builder.fn_name);\n+    add_func_to_accumulator(\n+        acc,\n+        ctx,\n+        text_range,\n+        function_builder,\n+        insert_offset,\n+        file,\n+        adt_name,\n+        label,\n+    )\n+}\n+\n+struct TargetInfo {\n+    target_module: Option<Module>,\n+    adt_name: Option<hir::Name>,\n+    target: GeneratedFunctionTarget,\n+    file: FileId,\n+    insert_offset: TextSize,\n+}\n \n-    let (target, file, insert_offset) = match path.qualifier() {\n+impl TargetInfo {\n+    fn new(\n+        target_module: Option<Module>,\n+        adt_name: Option<hir::Name>,\n+        target: GeneratedFunctionTarget,\n+        file: FileId,\n+        insert_offset: TextSize,\n+    ) -> Self {\n+        Self { target_module, adt_name, target, file, insert_offset }\n+    }\n+}\n+\n+fn fn_target_info(\n+    ctx: &AssistContext<'_>,\n+    path: ast::Path,\n+    call: &CallExpr,\n+    fn_name: &str,\n+) -> Option<TargetInfo> {\n+    match path.qualifier() {\n         Some(qualifier) => match ctx.sema.resolve_path(&qualifier) {\n             Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => {\n-                target_module = Some(module);\n-                get_fn_target(ctx, &target_module, call.clone())?\n+                get_fn_target_info(ctx, &Some(module), call.clone())\n             }\n             Some(hir::PathResolution::Def(hir::ModuleDef::Adt(adt))) => {\n                 if let hir::Adt::Enum(_) = adt {\n                     // Don't suggest generating function if the name starts with an uppercase letter\n-                    if name_ref.text().starts_with(char::is_uppercase) {\n+                    if fn_name.starts_with(char::is_uppercase) {\n                         return None;\n                     }\n                 }\n \n-                let current_module = ctx.sema.scope(call.syntax())?.module();\n-                let module = adt.module(ctx.sema.db);\n-                target_module = if current_module == module { None } else { Some(module) };\n-                if current_module.krate() != module.krate() {\n-                    return None;\n-                }\n-                let (impl_, file) = get_adt_source(ctx, &adt, fn_name)?;\n-                let (target, insert_offset) = get_method_target(ctx, &module, &impl_)?;\n-                adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n-                (target, file, insert_offset)\n+                assoc_fn_target_info(ctx, call, adt, fn_name)\n             }\n-            _ => {\n-                return None;\n+            Some(hir::PathResolution::SelfType(impl_)) => {\n+                let adt = impl_.self_ty(ctx.db()).as_adt()?;\n+                assoc_fn_target_info(ctx, call, adt, fn_name)\n             }\n+            _ => None,\n         },\n-        _ => {\n-            target_module = None;\n-            get_fn_target(ctx, &target_module, call.clone())?\n-        }\n-    };\n-    let function_builder = FunctionBuilder::from_call(ctx, &call, fn_name, target_module, target)?;\n-    let text_range = call.syntax().text_range();\n-    let label = format!(\"Generate {} function\", function_builder.fn_name);\n-    add_func_to_accumulator(\n-        acc,\n-        ctx,\n-        text_range,\n-        function_builder,\n-        insert_offset,\n-        file,\n-        adt_name,\n-        label,\n-    )\n+        _ => get_fn_target_info(ctx, &None, call.clone()),\n+    }\n }\n \n fn gen_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n@@ -366,6 +382,15 @@ fn make_return_type(\n     (ret_type, should_focus_return_type)\n }\n \n+fn get_fn_target_info(\n+    ctx: &AssistContext<'_>,\n+    target_module: &Option<Module>,\n+    call: CallExpr,\n+) -> Option<TargetInfo> {\n+    let (target, file, insert_offset) = get_fn_target(ctx, target_module, call)?;\n+    Some(TargetInfo::new(*target_module, None, target, file, insert_offset))\n+}\n+\n fn get_fn_target(\n     ctx: &AssistContext<'_>,\n     target_module: &Option<Module>,\n@@ -399,6 +424,24 @@ fn get_method_target(\n     Some((target.clone(), get_insert_offset(&target)))\n }\n \n+fn assoc_fn_target_info(\n+    ctx: &AssistContext<'_>,\n+    call: &CallExpr,\n+    adt: hir::Adt,\n+    fn_name: &str,\n+) -> Option<TargetInfo> {\n+    let current_module = ctx.sema.scope(call.syntax())?.module();\n+    let module = adt.module(ctx.sema.db);\n+    let target_module = if current_module == module { None } else { Some(module) };\n+    if current_module.krate() != module.krate() {\n+        return None;\n+    }\n+    let (impl_, file) = get_adt_source(ctx, &adt, fn_name)?;\n+    let (target, insert_offset) = get_method_target(ctx, &module, &impl_)?;\n+    let adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n+    Some(TargetInfo::new(target_module, adt_name, target, file, insert_offset))\n+}\n+\n fn get_insert_offset(target: &GeneratedFunctionTarget) -> TextSize {\n     match &target {\n         GeneratedFunctionTarget::BehindItem(it) => it.text_range().end(),\n@@ -1633,6 +1676,33 @@ fn bar() ${0:-> _} {\n         )\n     }\n \n+    #[test]\n+    fn create_static_method_within_an_impl_with_self_syntax() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+struct S;\n+impl S {\n+    fn foo(&self) {\n+        Self::bar$0();\n+    }\n+}\n+\",\n+            r\"\n+struct S;\n+impl S {\n+    fn foo(&self) {\n+        Self::bar();\n+    }\n+\n+    fn bar() ${0:-> _} {\n+        todo!()\n+    }\n+}\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn no_panic_on_invalid_global_path() {\n         check_assist("}, {"sha": "b5d092e39b02972b24da8cdfaedf9432e8e42691", "filename": "crates/ide-assists/src/handlers/inline_call.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -13,7 +13,7 @@ use ide_db::{\n use itertools::{izip, Itertools};\n use syntax::{\n     ast::{self, edit_in_place::Indent, HasArgList, PathExpr},\n-    ted, AstNode,\n+    ted, AstNode, NodeOrToken, SyntaxKind,\n };\n \n use crate::{\n@@ -311,6 +311,13 @@ fn inline(\n     } else {\n         fn_body.clone_for_update()\n     };\n+    if let Some(t) = body.syntax().ancestors().find_map(ast::Impl::cast).and_then(|i| i.self_ty()) {\n+        body.syntax()\n+            .descendants_with_tokens()\n+            .filter_map(NodeOrToken::into_token)\n+            .filter(|tok| tok.kind() == SyntaxKind::SELF_TYPE_KW)\n+            .for_each(|tok| ted::replace(tok, t.syntax()));\n+    }\n     let usages_for_locals = |local| {\n         Definition::Local(local)\n             .usages(sema)\n@@ -345,6 +352,7 @@ fn inline(\n             }\n         })\n         .collect();\n+\n     if function.self_param(sema.db).is_some() {\n         let this = || make::name_ref(\"this\").syntax().clone_for_update();\n         if let Some(self_local) = params[0].2.as_local(sema.db) {\n@@ -1188,6 +1196,31 @@ fn bar() -> u32 {\n       x\n     }\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn inline_call_with_self_type() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+struct A(u32);\n+impl A {\n+    fn f() -> Self { Self(114514) }\n+}\n+fn main() {\n+    A::f$0();\n+}\n+\"#,\n+            r#\"\n+struct A(u32);\n+impl A {\n+    fn f() -> Self { Self(114514) }\n+}\n+fn main() {\n+    A(114514);\n+}\n \"#,\n         )\n     }"}, {"sha": "9adf6381c1cbcf752b41b1852706043d71150050", "filename": "crates/ide-assists/src/handlers/inline_type_alias.rs", "status": "modified", "additions": 196, "deletions": 33, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -1,9 +1,9 @@\n // Some ideas for future improvements:\n // - Support replacing aliases which are used in expressions, e.g. `A::new()`.\n-// - \"inline_alias_to_users\" assist #10881.\n // - Remove unused aliases if there are no longer any users, see inline_call.rs.\n \n use hir::{HasSource, PathResolution};\n+use ide_db::{defs::Definition, search::FileReference};\n use itertools::Itertools;\n use std::collections::HashMap;\n use syntax::{\n@@ -16,6 +16,78 @@ use crate::{\n     AssistId, AssistKind,\n };\n \n+// Assist: inline_type_alias_uses\n+//\n+// Inline a type alias into all of its uses where possible.\n+//\n+// ```\n+// type $0A = i32;\n+// fn id(x: A) -> A {\n+//     x\n+// };\n+// fn foo() {\n+//     let _: A = 3;\n+// }\n+// ```\n+// ->\n+// ```\n+// type A = i32;\n+// fn id(x: i32) -> i32 {\n+//     x\n+// };\n+// fn foo() {\n+//     let _: i32 = 3;\n+// }\n+pub(crate) fn inline_type_alias_uses(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let name = ctx.find_node_at_offset::<ast::Name>()?;\n+    let ast_alias = name.syntax().parent().and_then(ast::TypeAlias::cast)?;\n+\n+    let hir_alias = ctx.sema.to_def(&ast_alias)?;\n+    let concrete_type = ast_alias.ty()?;\n+\n+    let usages = Definition::TypeAlias(hir_alias).usages(&ctx.sema);\n+    if !usages.at_least_one() {\n+        return None;\n+    }\n+\n+    // until this is ok\n+\n+    acc.add(\n+        AssistId(\"inline_type_alias_uses\", AssistKind::RefactorInline),\n+        \"Inline type alias into all uses\",\n+        name.syntax().text_range(),\n+        |builder| {\n+            let usages = usages.all();\n+\n+            let mut inline_refs_for_file = |file_id, refs: Vec<FileReference>| {\n+                builder.edit_file(file_id);\n+\n+                let path_types: Vec<ast::PathType> = refs\n+                    .into_iter()\n+                    .filter_map(|file_ref| match file_ref.name {\n+                        ast::NameLike::NameRef(path_type) => {\n+                            path_type.syntax().ancestors().nth(3).and_then(ast::PathType::cast)\n+                        }\n+                        _ => None,\n+                    })\n+                    .collect();\n+\n+                for (target, replacement) in path_types.into_iter().filter_map(|path_type| {\n+                    let replacement = inline(&ast_alias, &path_type)?.to_text(&concrete_type);\n+                    let target = path_type.syntax().text_range();\n+                    Some((target, replacement))\n+                }) {\n+                    builder.replace(target, replacement);\n+                }\n+            };\n+\n+            for (file_id, refs) in usages.into_iter() {\n+                inline_refs_for_file(file_id, refs);\n+            }\n+        },\n+    )\n+}\n+\n // Assist: inline_type_alias\n //\n // Replace a type alias with its concrete type.\n@@ -36,11 +108,6 @@ use crate::{\n // }\n // ```\n pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    enum Replacement {\n-        Generic { lifetime_map: LifetimeMap, const_and_type_map: ConstAndTypeMap },\n-        Plain,\n-    }\n-\n     let alias_instance = ctx.find_node_at_offset::<ast::PathType>()?;\n     let concrete_type;\n     let replacement;\n@@ -59,23 +126,7 @@ pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n         _ => {\n             let alias = get_type_alias(&ctx, &alias_instance)?;\n             concrete_type = alias.ty()?;\n-\n-            replacement = if let Some(alias_generics) = alias.generic_param_list() {\n-                if alias_generics.generic_params().next().is_none() {\n-                    cov_mark::hit!(no_generics_params);\n-                    return None;\n-                }\n-\n-                let instance_args =\n-                    alias_instance.syntax().descendants().find_map(ast::GenericArgList::cast);\n-\n-                Replacement::Generic {\n-                    lifetime_map: LifetimeMap::new(&instance_args, &alias_generics)?,\n-                    const_and_type_map: ConstAndTypeMap::new(&instance_args, &alias_generics)?,\n-                }\n-            } else {\n-                Replacement::Plain\n-            };\n+            replacement = inline(&alias, &alias_instance)?;\n         }\n     }\n \n@@ -85,19 +136,45 @@ pub(crate) fn inline_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n         AssistId(\"inline_type_alias\", AssistKind::RefactorInline),\n         \"Inline type alias\",\n         target,\n-        |builder| {\n-            let replacement_text = match replacement {\n-                Replacement::Generic { lifetime_map, const_and_type_map } => {\n-                    create_replacement(&lifetime_map, &const_and_type_map, &concrete_type)\n-                }\n-                Replacement::Plain => concrete_type.to_string(),\n-            };\n-\n-            builder.replace(target, replacement_text);\n-        },\n+        |builder| builder.replace(target, replacement.to_text(&concrete_type)),\n     )\n }\n \n+impl Replacement {\n+    fn to_text(&self, concrete_type: &ast::Type) -> String {\n+        match self {\n+            Replacement::Generic { lifetime_map, const_and_type_map } => {\n+                create_replacement(&lifetime_map, &const_and_type_map, &concrete_type)\n+            }\n+            Replacement::Plain => concrete_type.to_string(),\n+        }\n+    }\n+}\n+\n+enum Replacement {\n+    Generic { lifetime_map: LifetimeMap, const_and_type_map: ConstAndTypeMap },\n+    Plain,\n+}\n+\n+fn inline(alias_def: &ast::TypeAlias, alias_instance: &ast::PathType) -> Option<Replacement> {\n+    let repl = if let Some(alias_generics) = alias_def.generic_param_list() {\n+        if alias_generics.generic_params().next().is_none() {\n+            cov_mark::hit!(no_generics_params);\n+            return None;\n+        }\n+        let instance_args =\n+            alias_instance.syntax().descendants().find_map(ast::GenericArgList::cast);\n+\n+        Replacement::Generic {\n+            lifetime_map: LifetimeMap::new(&instance_args, &alias_generics)?,\n+            const_and_type_map: ConstAndTypeMap::new(&instance_args, &alias_generics)?,\n+        }\n+    } else {\n+        Replacement::Plain\n+    };\n+    Some(repl)\n+}\n+\n struct LifetimeMap(HashMap<String, ast::Lifetime>);\n \n impl LifetimeMap {\n@@ -835,4 +912,90 @@ trait Tr {\n \"#,\n         );\n     }\n+\n+    mod inline_type_alias_uses {\n+        use crate::{handlers::inline_type_alias::inline_type_alias_uses, tests::check_assist};\n+\n+        #[test]\n+        fn inline_uses() {\n+            check_assist(\n+                inline_type_alias_uses,\n+                r#\"\n+type $0A = u32;\n+\n+fn foo() {\n+    let _: A = 3;\n+    let _: A = 4;\n+}\n+\"#,\n+                r#\"\n+type A = u32;\n+\n+fn foo() {\n+    let _: u32 = 3;\n+    let _: u32 = 4;\n+}\n+\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn inline_uses_across_files() {\n+            check_assist(\n+                inline_type_alias_uses,\n+                r#\"\n+//- /lib.rs\n+mod foo;\n+type $0T<E> = Vec<E>;\n+fn f() -> T<&str> {\n+    vec![\"hello\"]\n+}\n+\n+//- /foo.rs\n+use super::T;\n+fn foo() {\n+    let _: T<i8> = Vec::new();\n+}\n+\"#,\n+                r#\"\n+//- /lib.rs\n+mod foo;\n+type T<E> = Vec<E>;\n+fn f() -> Vec<&str> {\n+    vec![\"hello\"]\n+}\n+\n+//- /foo.rs\n+use super::T;\n+fn foo() {\n+    let _: Vec<i8> = Vec::new();\n+}\n+\"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn inline_uses_across_files_2() {\n+            check_assist(\n+                inline_type_alias_uses,\n+                r#\"\n+//- /lib.rs\n+mod foo;\n+type $0I = i32;\n+\n+//- /foo.rs\n+use super::I;\n+fn foo() {\n+    let _: I = 0;\n+}\n+\"#,\n+                r#\"\n+use super::I;\n+fn foo() {\n+    let _: i32 = 0;\n+}\n+\"#,\n+            );\n+        }\n+    }\n }"}, {"sha": "5242f3b5100cfa9357d322ac8f2cc647def5385f", "filename": "crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -88,7 +88,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n             },\n         );\n     } else if let Some(InferType(t)) = let_stmt.ty() {\n-        // If there's a type inferrence underscore, we can offer to replace it with the type in\n+        // If there's a type inference underscore, we can offer to replace it with the type in\n         // the turbofish.\n         // let x: _ = fn::<...>();\n         let underscore_range = t.syntax().text_range();"}, {"sha": "7fb35143fa2ff1303459cedde3579f16221d7fa7", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -243,6 +243,7 @@ mod handlers {\n             inline_call::inline_into_callers,\n             inline_local_variable::inline_local_variable,\n             inline_type_alias::inline_type_alias,\n+            inline_type_alias::inline_type_alias_uses,\n             introduce_named_generic::introduce_named_generic,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,"}, {"sha": "22319f36134fb6b6d0ee259ae1f2245754d36917", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -1356,6 +1356,31 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_inline_type_alias_uses() {\n+    check_doc_test(\n+        \"inline_type_alias_uses\",\n+        r#####\"\n+type $0A = i32;\n+fn id(x: A) -> A {\n+    x\n+};\n+fn foo() {\n+    let _: A = 3;\n+}\n+\"#####,\n+        r#####\"\n+type A = i32;\n+fn id(x: i32) -> i32 {\n+    x\n+};\n+fn foo() {\n+    let _: i32 = 3;\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_introduce_named_generic() {\n     check_doc_test("}, {"sha": "c521a10fccfc314942ce4baf642be6eecf6c36f8", "filename": "crates/ide-assists/src/utils/suggest_name.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -55,6 +55,7 @@ const USELESS_METHODS: &[&str] = &[\n     \"iter\",\n     \"into_iter\",\n     \"iter_mut\",\n+    \"into_future\",\n ];\n \n pub(crate) fn for_generic_parameter(ty: &ast::ImplTraitType) -> SmolStr {\n@@ -75,7 +76,7 @@ pub(crate) fn for_generic_parameter(ty: &ast::ImplTraitType) -> SmolStr {\n /// In current implementation, the function tries to get the name from\n /// the following sources:\n ///\n-/// * if expr is an argument to function/method, use paramter name\n+/// * if expr is an argument to function/method, use parameter name\n /// * if expr is a function/method call, use function name\n /// * expression type name if it exists (E.g. `()`, `fn() -> ()` or `!` do not have names)\n /// * fallback: `var_name`\n@@ -85,7 +86,7 @@ pub(crate) fn for_generic_parameter(ty: &ast::ImplTraitType) -> SmolStr {\n /// Currently it sticks to the first name found.\n // FIXME: Microoptimize and return a `SmolStr` here.\n pub(crate) fn for_variable(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> String {\n-    // `from_param` does not benifit from stripping\n+    // `from_param` does not benefit from stripping\n     // it need the largest context possible\n     // so we check firstmost\n     if let Some(name) = from_param(expr, sema) {"}, {"sha": "02004ff7b686876e2a699cb51f0c61ca90a3b06a", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -19,7 +19,7 @@ pub(crate) fn complete_dot(\n     };\n \n     // Suggest .await syntax for types that implement Future trait\n-    if receiver_ty.impls_future(ctx.db) {\n+    if receiver_ty.impls_into_future(ctx.db) {\n         let mut item =\n             CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), \"await\");\n         item.detail(\"expr.await\");"}, {"sha": "1d03c8cc5ca6d4f9b630b08ee2dc99d622dc9aec", "filename": "crates/ide-completion/src/completions/keyword.rs", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -75,16 +75,17 @@ impl Future for A {}\n fn foo(a: A) { a.$0 }\n \"#,\n             expect![[r#\"\n-                kw await expr.await\n-                sn box   Box::new(expr)\n-                sn call  function(expr)\n-                sn dbg   dbg!(expr)\n-                sn dbgr  dbg!(&expr)\n-                sn let   let\n-                sn letm  let mut\n-                sn match match expr {}\n-                sn ref   &expr\n-                sn refm  &mut expr\n+                kw await                  expr.await\n+                me into_future() (as IntoFuture) fn(self) -> <Self as IntoFuture>::IntoFuture\n+                sn box                    Box::new(expr)\n+                sn call                   function(expr)\n+                sn dbg                    dbg!(expr)\n+                sn dbgr                   dbg!(&expr)\n+                sn let                    let\n+                sn letm                   let mut\n+                sn match                  match expr {}\n+                sn ref                    &expr\n+                sn refm                   &mut expr\n             \"#]],\n         );\n \n@@ -98,18 +99,45 @@ fn foo() {\n }\n \"#,\n             expect![[r#\"\n-                kw await expr.await\n-                sn box   Box::new(expr)\n-                sn call  function(expr)\n-                sn dbg   dbg!(expr)\n-                sn dbgr  dbg!(&expr)\n-                sn let   let\n-                sn letm  let mut\n-                sn match match expr {}\n-                sn ref   &expr\n-                sn refm  &mut expr\n+                kw await                  expr.await\n+                me into_future() (use core::future::IntoFuture) fn(self) -> <Self as IntoFuture>::IntoFuture\n+                sn box                    Box::new(expr)\n+                sn call                   function(expr)\n+                sn dbg                    dbg!(expr)\n+                sn dbgr                   dbg!(&expr)\n+                sn let                    let\n+                sn letm                   let mut\n+                sn match                  match expr {}\n+                sn ref                    &expr\n+                sn refm                   &mut expr\n             \"#]],\n-        )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_await_impls_into_future() {\n+        check(\n+            r#\"\n+//- minicore: future\n+use core::future::*;\n+struct A {}\n+impl IntoFuture for A {}\n+fn foo(a: A) { a.$0 }\n+\"#,\n+            expect![[r#\"\n+                kw await                  expr.await\n+                me into_future() (as IntoFuture) fn(self) -> <Self as IntoFuture>::IntoFuture\n+                sn box                    Box::new(expr)\n+                sn call                   function(expr)\n+                sn dbg                    dbg!(expr)\n+                sn dbgr                   dbg!(&expr)\n+                sn let                    let\n+                sn letm                   let mut\n+                sn match                  match expr {}\n+                sn ref                    &expr\n+                sn refm                   &mut expr\n+            \"#]],\n+        );\n     }\n \n     #[test]"}, {"sha": "b273a4cb53ba1da2631b42798f5ecd86c11c1805", "filename": "crates/ide-completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -173,7 +173,7 @@ impl FormatStrParser {\n                     }\n                 }\n                 (State::Expr, ':') if chars.peek().copied() == Some(':') => {\n-                    // path seperator\n+                    // path separator\n                     current_expr.push_str(\"::\");\n                     chars.next();\n                 }\n@@ -185,7 +185,7 @@ impl FormatStrParser {\n                         current_expr = String::new();\n                         self.state = State::FormatOpts;\n                     } else {\n-                        // We're inside of braced expression, assume that it's a struct field name/value delimeter.\n+                        // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n                         current_expr.push(chr);\n                     }\n                 }"}, {"sha": "5d96fbd30a81d1c4dd02f8a38e68b00602096c61", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -129,7 +129,7 @@ mod tests {\n     #[test]\n     fn literal_struct_completion_edit() {\n         check_edit(\n-            \"FooDesc {\u2026}\",\n+            \"FooDesc{}\",\n             r#\"\n struct FooDesc { pub bar: bool }\n \n@@ -154,7 +154,7 @@ fn baz() {\n     #[test]\n     fn literal_struct_impl_self_completion() {\n         check_edit(\n-            \"Self {\u2026}\",\n+            \"Self{}\",\n             r#\"\n struct Foo {\n     bar: u64,\n@@ -180,7 +180,7 @@ impl Foo {\n         );\n \n         check_edit(\n-            \"Self(\u2026)\",\n+            \"Self()\",\n             r#\"\n mod submod {\n     pub struct Foo(pub u64);\n@@ -209,7 +209,7 @@ impl submod::Foo {\n     #[test]\n     fn literal_struct_completion_from_sub_modules() {\n         check_edit(\n-            \"submod::Struct {\u2026}\",\n+            \"submod::Struct{}\",\n             r#\"\n mod submod {\n     pub struct Struct {\n@@ -238,7 +238,7 @@ fn f() -> submod::Struct {\n     #[test]\n     fn literal_struct_complexion_module() {\n         check_edit(\n-            \"FooDesc {\u2026}\",\n+            \"FooDesc{}\",\n             r#\"\n mod _69latrick {\n     pub struct FooDesc { pub six: bool, pub neuf: Vec<String>, pub bar: bool }"}, {"sha": "a2cf6d68e5b3a08529ece70ce8b455a232cf5010", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -565,6 +565,7 @@ fn main() { Foo::Fo$0 }\n                         kind: SymbolKind(\n                             Variant,\n                         ),\n+                        lookup: \"Foo{}\",\n                         detail: \"Foo { x: i32, y: i32 }\",\n                     },\n                 ]\n@@ -591,6 +592,7 @@ fn main() { Foo::Fo$0 }\n                         kind: SymbolKind(\n                             Variant,\n                         ),\n+                        lookup: \"Foo()\",\n                         detail: \"Foo(i32, i32)\",\n                     },\n                 ]\n@@ -707,7 +709,7 @@ fn main() { let _: m::Spam = S$0 }\n                         kind: SymbolKind(\n                             Variant,\n                         ),\n-                        lookup: \"Spam::Bar(\u2026)\",\n+                        lookup: \"Spam::Bar()\",\n                         detail: \"m::Spam::Bar(i32)\",\n                         relevance: CompletionRelevance {\n                             exact_name_match: false,"}, {"sha": "af9c88a7e0a6cc87cbcb1f11ea22e9f4c207238b", "filename": "crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -10,8 +10,8 @@ use crate::{\n     render::{\n         compute_ref_match, compute_type_match,\n         variant::{\n-            format_literal_label, render_record_lit, render_tuple_lit, visible_fields,\n-            RenderedLiteral,\n+            format_literal_label, format_literal_lookup, render_record_lit, render_tuple_lit,\n+            visible_fields, RenderedLiteral,\n         },\n         RenderContext,\n     },\n@@ -97,23 +97,27 @@ fn render(\n     if !should_add_parens {\n         kind = StructKind::Unit;\n     }\n+    let label = format_literal_label(&qualified_name, kind);\n+    let lookup = if qualified {\n+        format_literal_lookup(&short_qualified_name.to_string(), kind)\n+    } else {\n+        format_literal_lookup(&qualified_name, kind)\n+    };\n \n     let mut item = CompletionItem::new(\n         CompletionItemKind::SymbolKind(thing.symbol_kind()),\n         ctx.source_range(),\n-        format_literal_label(&qualified_name, kind),\n+        label,\n     );\n \n+    item.lookup_by(lookup);\n     item.detail(rendered.detail);\n \n     match snippet_cap {\n         Some(snippet_cap) => item.insert_snippet(snippet_cap, rendered.literal),\n         None => item.insert_text(rendered.literal),\n     };\n \n-    if qualified {\n-        item.lookup_by(format_literal_label(&short_qualified_name.to_string(), kind));\n-    }\n     item.set_documentation(thing.docs(db)).set_deprecated(thing.is_deprecated(&ctx));\n \n     let ty = thing.ty(db);"}, {"sha": "c845ff21aaba401045cbef14c30c12ea74a3857f", "filename": "crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -8,7 +8,7 @@ use syntax::SmolStr;\n use crate::{\n     context::{ParamContext, ParamKind, PathCompletionCtx, PatternContext},\n     render::{\n-        variant::{format_literal_label, visible_fields},\n+        variant::{format_literal_label, format_literal_lookup, visible_fields},\n         RenderContext,\n     },\n     CompletionItem, CompletionItemKind,\n@@ -34,9 +34,10 @@ pub(crate) fn render_struct_pat(\n     let (name, escaped_name) = (name.unescaped().to_smol_str(), name.to_smol_str());\n     let kind = strukt.kind(ctx.db());\n     let label = format_literal_label(name.as_str(), kind);\n+    let lookup = format_literal_lookup(name.as_str(), kind);\n     let pat = render_pat(&ctx, pattern_ctx, &escaped_name, kind, &visible_fields, fields_omitted)?;\n \n-    Some(build_completion(ctx, label, pat, strukt))\n+    Some(build_completion(ctx, label, lookup, pat, strukt))\n }\n \n pub(crate) fn render_variant_pat(\n@@ -60,11 +61,14 @@ pub(crate) fn render_variant_pat(\n         }\n     };\n \n-    let (label, pat) = match path_ctx {\n-        Some(PathCompletionCtx { has_call_parens: true, .. }) => (name, escaped_name.to_string()),\n+    let (label, lookup, pat) = match path_ctx {\n+        Some(PathCompletionCtx { has_call_parens: true, .. }) => {\n+            (name.clone(), name, escaped_name.to_string())\n+        }\n         _ => {\n             let kind = variant.kind(ctx.db());\n             let label = format_literal_label(name.as_str(), kind);\n+            let lookup = format_literal_lookup(name.as_str(), kind);\n             let pat = render_pat(\n                 &ctx,\n                 pattern_ctx,\n@@ -73,23 +77,25 @@ pub(crate) fn render_variant_pat(\n                 &visible_fields,\n                 fields_omitted,\n             )?;\n-            (label, pat)\n+            (label, lookup, pat)\n         }\n     };\n \n-    Some(build_completion(ctx, label, pat, variant))\n+    Some(build_completion(ctx, label, lookup, pat, variant))\n }\n \n fn build_completion(\n     ctx: RenderContext<'_>,\n     label: SmolStr,\n+    lookup: SmolStr,\n     pat: String,\n     def: impl HasAttrs + Copy,\n ) -> CompletionItem {\n     let mut item = CompletionItem::new(CompletionItemKind::Binding, ctx.source_range(), label);\n     item.set_documentation(ctx.docs(def))\n         .set_deprecated(ctx.is_deprecated(def))\n         .detail(&pat)\n+        .lookup_by(lookup)\n         .set_relevance(ctx.completion_relevance());\n     match ctx.snippet_cap() {\n         Some(snippet_cap) => item.insert_snippet(snippet_cap, pat),"}, {"sha": "54e97dd57ba82280074c27635f675d57fef6fa7c", "filename": "crates/ide-completion/src/render/union_literal.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -6,7 +6,7 @@ use itertools::Itertools;\n \n use crate::{\n     render::{\n-        variant::{format_literal_label, visible_fields},\n+        variant::{format_literal_label, format_literal_lookup, visible_fields},\n         RenderContext,\n     },\n     CompletionItem, CompletionItemKind,\n@@ -24,13 +24,16 @@ pub(crate) fn render_union_literal(\n         Some(p) => (p.unescaped().to_string(), p.to_string()),\n         None => (name.unescaped().to_string(), name.to_string()),\n     };\n-\n+    let label = format_literal_label(&name.to_smol_str(), StructKind::Record);\n+    let lookup = format_literal_lookup(&name.to_smol_str(), StructKind::Record);\n     let mut item = CompletionItem::new(\n         CompletionItemKind::SymbolKind(SymbolKind::Union),\n         ctx.source_range(),\n-        format_literal_label(&name.to_smol_str(), StructKind::Record),\n+        label,\n     );\n \n+    item.lookup_by(lookup);\n+\n     let fields = un.fields(ctx.db());\n     let (fields, fields_omitted) = visible_fields(ctx.completion, &fields, un)?;\n "}, {"sha": "24e6abdc9ad60918472e7508cad3b8c4f3cc5eef", "filename": "crates/ide-completion/src/render/variant.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -94,3 +94,12 @@ pub(crate) fn format_literal_label(name: &str, kind: StructKind) -> SmolStr {\n         StructKind::Unit => name.into(),\n     }\n }\n+\n+/// Format a struct, etc. literal option for lookup used in completions filtering.\n+pub(crate) fn format_literal_lookup(name: &str, kind: StructKind) -> SmolStr {\n+    match kind {\n+        StructKind::Tuple => SmolStr::from_iter([name, \"()\"]),\n+        StructKind::Record => SmolStr::from_iter([name, \"{}\"]),\n+        StructKind::Unit => name.into(),\n+    }\n+}"}, {"sha": "a63ef006875bc9962ac460e3885e5acf42478d74", "filename": "crates/ide-completion/src/tests/flyimport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -159,7 +159,7 @@ pub mod some_module {\n     pub struct ThiiiiiirdStruct;\n     // contains all letters from the query, but not in the beginning, displayed second\n     pub struct AfterThirdStruct;\n-    // contains all letters from the query in the begginning, displayed first\n+    // contains all letters from the query in the beginning, displayed first\n     pub struct ThirdStruct;\n }\n "}, {"sha": "85c4dbd6625dfcfc891a073c885eab6eec98780b", "filename": "crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -467,7 +467,7 @@ fn foo() {\n fn completes_enum_variant_pat() {\n     cov_mark::check!(enum_variant_pattern_path);\n     check_edit(\n-        \"RecordVariant {\u2026}\",\n+        \"RecordVariant{}\",\n         r#\"\n enum Enum {\n     RecordVariant { field: u32 }"}, {"sha": "b1ee9b58d5ba16d4e06bdcc457748b9046bca50b", "filename": "crates/ide-db/src/apply_change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fapply_change.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -20,7 +20,7 @@ impl RootDatabase {\n     pub fn apply_change(&mut self, change: Change) {\n         let _p = profile::span(\"RootDatabase::apply_change\");\n         self.request_cancellation();\n-        tracing::info!(\"apply_change {:?}\", change);\n+        tracing::trace!(\"apply_change {:?}\", change);\n         if let Some(roots) = &change.roots {\n             let mut local_roots = FxHashSet::default();\n             let mut library_roots = FxHashSet::default();"}, {"sha": "49b81265ea5be22649f65103a517d583390f27a2", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -82,7 +82,7 @@ impl Definition {\n     }\n \n     /// Textual range of the identifier which will change when renaming this\n-    /// `Definition`. Note that some definitions, like buitin types, can't be\n+    /// `Definition`. Note that some definitions, like builtin types, can't be\n     /// renamed.\n     pub fn range_for_rename(self, sema: &Semantics<'_, RootDatabase>) -> Option<FileRange> {\n         let res = match self {"}, {"sha": "2f4aa113170a6f6865a3b6e560db8aa2727cfcce", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -402,7 +402,9 @@ impl<'a> FindUsages<'a> {\n                             .or_else(|| ty.as_builtin().map(|builtin| builtin.name()))\n                     })\n                 };\n-                self.def.name(sema.db).or_else(self_kw_refs).map(|it| it.to_smol_str())\n+                // We need to unescape the name in case it is written without \"r#\" in earlier\n+                // editions of Rust where it isn't a keyword.\n+                self.def.name(sema.db).or_else(self_kw_refs).map(|it| it.unescaped().to_smol_str())\n             }\n         };\n         let name = match &name {"}, {"sha": "5fcaf405b14b94887cc6e81c1dd05db061eac143", "filename": "crates/ide-diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -750,7 +750,7 @@ fn main() {\n enum Foo { A }\n fn main() {\n     // FIXME: this should not bail out but current behavior is such as the old algorithm.\n-    // ExprValidator::validate_match(..) checks types of top level patterns incorrecly.\n+    // ExprValidator::validate_match(..) checks types of top level patterns incorrectly.\n     match Foo::A {\n         ref _x => {}\n         Foo::A => {}"}, {"sha": "36a648fe4a8ea3eb8a3519f9ae189c0b30c26e18", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -1664,6 +1664,40 @@ fn f() {\n         );\n     }\n \n+    #[test]\n+    fn goto_await_into_future_poll() {\n+        check(\n+            r#\"\n+//- minicore: future\n+\n+struct Futurable;\n+\n+impl core::future::IntoFuture for Futurable {\n+    type IntoFuture = MyFut;\n+}\n+\n+struct MyFut;\n+\n+impl core::future::Future for MyFut {\n+    type Output = ();\n+\n+    fn poll(\n+     //^^^^\n+        self: std::pin::Pin<&mut Self>,\n+        cx: &mut std::task::Context<'_>\n+    ) -> std::task::Poll<Self::Output>\n+    {\n+        ()\n+    }\n+}\n+\n+fn f() {\n+    Futurable.await$0;\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn goto_try_op() {\n         check("}, {"sha": "3687b597fc642f6ad17cd8b9443341192cd8d28b", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -27,6 +27,7 @@ use crate::{\n pub struct HoverConfig {\n     pub links_in_hover: bool,\n     pub documentation: Option<HoverDocFormat>,\n+    pub keywords: bool,\n }\n \n impl HoverConfig {\n@@ -119,6 +120,8 @@ pub(crate) fn hover(\n     }\n \n     let in_attr = matches!(original_token.parent().and_then(ast::TokenTree::cast), Some(tt) if tt.syntax().ancestors().any(|it| ast::Meta::can_cast(it.kind())));\n+    // prefer descending the same token kind in attribute expansions, in normal macros text\n+    // equivalency is more important\n     let descended = if in_attr {\n         [sema.descend_into_macros_with_kind_preference(original_token.clone())].into()\n     } else {"}, {"sha": "d52adaee535f99371b3ca9547ef380fb9cfa65d6", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -230,7 +230,7 @@ pub(super) fn keyword(\n     config: &HoverConfig,\n     token: &SyntaxToken,\n ) -> Option<HoverResult> {\n-    if !token.kind().is_keyword() || !config.documentation.is_some() {\n+    if !token.kind().is_keyword() || !config.documentation.is_some() || !config.keywords {\n         return None;\n     }\n     let parent = token.parent()?;"}, {"sha": "685eb4521ebdaf7f10ee93be5f92d346d76f2c1d", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -8,7 +8,11 @@ fn check_hover_no_result(ra_fixture: &str) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig { links_in_hover: true, documentation: Some(HoverDocFormat::Markdown) },\n+            &HoverConfig {\n+                links_in_hover: true,\n+                documentation: Some(HoverDocFormat::Markdown),\n+                keywords: true,\n+            },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap();\n@@ -20,7 +24,11 @@ fn check(ra_fixture: &str, expect: Expect) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig { links_in_hover: true, documentation: Some(HoverDocFormat::Markdown) },\n+            &HoverConfig {\n+                links_in_hover: true,\n+                documentation: Some(HoverDocFormat::Markdown),\n+                keywords: true,\n+            },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap()\n@@ -37,7 +45,11 @@ fn check_hover_no_links(ra_fixture: &str, expect: Expect) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig { links_in_hover: false, documentation: Some(HoverDocFormat::Markdown) },\n+            &HoverConfig {\n+                links_in_hover: false,\n+                documentation: Some(HoverDocFormat::Markdown),\n+                keywords: true,\n+            },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap()\n@@ -54,7 +66,11 @@ fn check_hover_no_markdown(ra_fixture: &str, expect: Expect) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig { links_in_hover: true, documentation: Some(HoverDocFormat::PlainText) },\n+            &HoverConfig {\n+                links_in_hover: true,\n+                documentation: Some(HoverDocFormat::PlainText),\n+                keywords: true,\n+            },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap()\n@@ -71,7 +87,11 @@ fn check_actions(ra_fixture: &str, expect: Expect) {\n     let (analysis, file_id, position) = fixture::range_or_position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig { links_in_hover: true, documentation: Some(HoverDocFormat::Markdown) },\n+            &HoverConfig {\n+                links_in_hover: true,\n+                documentation: Some(HoverDocFormat::Markdown),\n+                keywords: true,\n+            },\n             FileRange { file_id, range: position.range_or_empty() },\n         )\n         .unwrap()\n@@ -83,7 +103,11 @@ fn check_hover_range(ra_fixture: &str, expect: Expect) {\n     let (analysis, range) = fixture::range(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig { links_in_hover: false, documentation: Some(HoverDocFormat::Markdown) },\n+            &HoverConfig {\n+                links_in_hover: false,\n+                documentation: Some(HoverDocFormat::Markdown),\n+                keywords: true,\n+            },\n             range,\n         )\n         .unwrap()\n@@ -95,7 +119,11 @@ fn check_hover_range_no_results(ra_fixture: &str) {\n     let (analysis, range) = fixture::range(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig { links_in_hover: false, documentation: Some(HoverDocFormat::Markdown) },\n+            &HoverConfig {\n+                links_in_hover: false,\n+                documentation: Some(HoverDocFormat::Markdown),\n+                keywords: true,\n+            },\n             range,\n         )\n         .unwrap();"}, {"sha": "9e5eb909508f624e051042623de24232070a78ed", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -130,8 +130,11 @@ impl StaticIndex<'_> {\n             syntax::NodeOrToken::Node(_) => None,\n             syntax::NodeOrToken::Token(x) => Some(x),\n         });\n-        let hover_config =\n-            HoverConfig { links_in_hover: true, documentation: Some(HoverDocFormat::Markdown) };\n+        let hover_config = HoverConfig {\n+            links_in_hover: true,\n+            documentation: Some(HoverDocFormat::Markdown),\n+            keywords: true,\n+        };\n         let tokens = tokens.filter(|token| {\n             matches!(\n                 token.kind(),"}, {"sha": "d2bbbf6d26ab4cc9e23893fdad52de346ba88dac", "filename": "crates/ide/src/view_hir.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fview_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fide%2Fsrc%2Fview_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fview_hir.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -1,4 +1,4 @@\n-use hir::{Function, Semantics};\n+use hir::{DefWithBody, Semantics};\n use ide_db::base_db::FilePosition;\n use ide_db::RootDatabase;\n use syntax::{algo::find_node_at_offset, ast, AstNode};\n@@ -19,8 +19,12 @@ fn body_hir(db: &RootDatabase, position: FilePosition) -> Option<String> {\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(position.file_id);\n \n-    let function = find_node_at_offset::<ast::Fn>(source_file.syntax(), position.offset)?;\n-\n-    let function: Function = sema.to_def(&function)?;\n-    Some(function.debug_hir(db))\n+    let item = find_node_at_offset::<ast::Item>(source_file.syntax(), position.offset)?;\n+    let def: DefWithBody = match item {\n+        ast::Item::Fn(it) => sema.to_def(&it)?.into(),\n+        ast::Item::Const(it) => sema.to_def(&it)?.into(),\n+        ast::Item::Static(it) => sema.to_def(&it)?.into(),\n+        _ => return None,\n+    };\n+    Some(def.debug_hir(db))\n }"}, {"sha": "c1aa14d6b7e74d715920d9a2dea2992bd0cbf4e3", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -321,7 +321,7 @@ struct MatchState<'t> {\n     /// The KleeneOp of this sequence if we are in a repetition.\n     sep_kind: Option<RepeatKind>,\n \n-    /// Number of tokens of seperator parsed\n+    /// Number of tokens of separator parsed\n     sep_parsed: Option<usize>,\n \n     /// Matched meta variables bindings"}, {"sha": "b81b7432f6554f255743a85b38696a83dfc0fc53", "filename": "crates/project-model/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fproject-model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fproject-model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Flib.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -3,7 +3,7 @@\n //!\n //! Pure model is represented by the [`base_db::CrateGraph`] from another crate.\n //!\n-//! In this crate, we are conserned with \"real world\" project models.\n+//! In this crate, we are concerned with \"real world\" project models.\n //!\n //! Specifically, here we have a representation for a Cargo project\n //! ([`CargoWorkspace`]) and for manually specified layout ([`ProjectJson`])."}, {"sha": "8d6f50f5587c5ad0e8248702e66ba69c9187eced", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -770,7 +770,7 @@ fn handle_rustc_crates(\n         queue.push_back(root_pkg);\n         while let Some(pkg) = queue.pop_front() {\n             // Don't duplicate packages if they are dependended on a diamond pattern\n-            // N.B. if this line is ommitted, we try to analyse over 4_800_000 crates\n+            // N.B. if this line is omitted, we try to analyse over 4_800_000 crates\n             // which is not ideal\n             if rustc_pkg_crates.contains_key(&pkg) {\n                 continue;"}, {"sha": "298814af5a465679eaf033982061c9f8da010b9f", "filename": "crates/rust-analyzer/src/bin/logger.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Flogger.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -52,7 +52,7 @@ impl Logger {\n         // merge chalk filter to our main filter (from RA_LOG env).\n         //\n         // The acceptable syntax of CHALK_DEBUG is `target[span{field=value}]=level`.\n-        // As the value should only affect chalk crates, we'd better mannually\n+        // As the value should only affect chalk crates, we'd better manually\n         // specify the target. And for simplicity, CHALK_DEBUG only accept the value\n         // that specify level.\n         let chalk_level_dir = std::env::var(\"CHALK_DEBUG\")"}, {"sha": "6649f42b4ef9e6cade85b71105ecda9b535dda32", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -45,7 +45,8 @@ mod patch_old_style;\n //  - foo_command = overrides the subcommand, foo_overrideCommand allows full overwriting, extra args only applies for foo_command\n \n // Defines the server-side configuration of the rust-analyzer. We generate\n-// *parts* of VS Code's `package.json` config from this.\n+// *parts* of VS Code's `package.json` config from this. Run `cargo test` to\n+// re-generate that file.\n //\n // However, editor specific config, which the server doesn't know about, should\n // be specified directly in `package.json`.\n@@ -120,6 +121,10 @@ config_data! {\n         /// Cargo, you might also want to change\n         /// `#rust-analyzer.cargo.buildScripts.overrideCommand#`.\n         ///\n+        /// If there are multiple linked projects, this command is invoked for\n+        /// each of them, with the working directory being the project root\n+        /// (i.e., the folder containing the `Cargo.toml`).\n+        ///\n         /// An example command would be:\n         ///\n         /// ```bash\n@@ -243,7 +248,10 @@ config_data! {\n         hover_actions_run_enable: bool             = \"true\",\n \n         /// Whether to show documentation on hover.\n-        hover_documentation_enable: bool       = \"true\",\n+        hover_documentation_enable: bool           = \"true\",\n+        /// Whether to show keyword hover popups. Only applies when\n+        /// `#rust-analyzer.hover.documentation.enable#` is set.\n+        hover_documentation_keywords_enable: bool  = \"true\",\n         /// Use markdown syntax for links in hover.\n         hover_links_enable: bool = \"true\",\n \n@@ -1187,6 +1195,7 @@ impl Config {\n                     HoverDocFormat::PlainText\n                 }\n             }),\n+            keywords: self.data.hover_documentation_keywords_enable,\n         }\n     }\n "}, {"sha": "c55bbbbe6ef7c2c442e8593179daebe778e70303", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -8,7 +8,7 @@ use std::{sync::Arc, time::Instant};\n use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::FlycheckHandle;\n use ide::{Analysis, AnalysisHost, Cancellable, Change, FileId};\n-use ide_db::base_db::{CrateId, FileLoader, SourceDatabase, SourceDatabaseExt};\n+use ide_db::base_db::{CrateId, FileLoader, SourceDatabase};\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n use proc_macro_api::ProcMacroServer;\n@@ -176,9 +176,9 @@ impl GlobalState {\n \n     pub(crate) fn process_changes(&mut self) -> bool {\n         let _p = profile::span(\"GlobalState::process_changes\");\n-        let mut fs_refresh_changes = Vec::new();\n         // A file was added or deleted\n         let mut has_structure_changes = false;\n+        let mut workspace_structure_change = None;\n \n         let (change, changed_files) = {\n             let mut change = Change::new();\n@@ -192,7 +192,7 @@ impl GlobalState {\n                 if let Some(path) = vfs.file_path(file.file_id).as_path() {\n                     let path = path.to_path_buf();\n                     if reload::should_refresh_for_change(&path, file.change_kind) {\n-                        fs_refresh_changes.push((path, file.file_id));\n+                        workspace_structure_change = Some(path);\n                     }\n                     if file.is_created_or_deleted() {\n                         has_structure_changes = true;\n@@ -227,11 +227,10 @@ impl GlobalState {\n \n         {\n             let raw_database = self.analysis_host.raw_database();\n-            let workspace_structure_change =\n-                fs_refresh_changes.into_iter().find(|&(_, file_id)| {\n-                    !raw_database.source_root(raw_database.file_source_root(file_id)).is_library\n-                });\n-            if let Some((path, _)) = workspace_structure_change {\n+            // FIXME: ideally we should only trigger a workspace fetch for non-library changes\n+            // but somethings going wrong with the source root business when we add a new local\n+            // crate see https://github.com/rust-lang/rust-analyzer/issues/13029\n+            if let Some(path) = workspace_structure_change {\n                 self.fetch_workspaces_queue\n                     .request_op(format!(\"workspace vfs file change: {}\", path.display()));\n             }"}, {"sha": "e0bcc80b31cb9893192d53408f31b08f3fb34c8e", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -51,6 +51,12 @@ pub(crate) fn handle_workspace_reload(state: &mut GlobalState, _: ()) -> Result<\n     Ok(())\n }\n \n+pub(crate) fn handle_cancel_flycheck(state: &mut GlobalState, _: ()) -> Result<()> {\n+    let _p = profile::span(\"handle_stop_flycheck\");\n+    state.flycheck.iter().for_each(|flycheck| flycheck.cancel());\n+    Ok(())\n+}\n+\n pub(crate) fn handle_analyzer_status(\n     snap: GlobalStateSnapshot,\n     params: lsp_ext::AnalyzerStatusParams,\n@@ -703,10 +709,8 @@ pub(crate) fn handle_runnables(\n \n     let mut res = Vec::new();\n     for runnable in snap.analysis.runnables(file_id)? {\n-        if let Some(offset) = offset {\n-            if !runnable.nav.full_range.contains_inclusive(offset) {\n-                continue;\n-            }\n+        if should_skip_for_offset(&runnable, offset) {\n+            continue;\n         }\n         if should_skip_target(&runnable, cargo_spec.as_ref()) {\n             continue;\n@@ -772,6 +776,14 @@ pub(crate) fn handle_runnables(\n     Ok(res)\n }\n \n+fn should_skip_for_offset(runnable: &Runnable, offset: Option<TextSize>) -> bool {\n+    match offset {\n+        None => false,\n+        _ if matches!(&runnable.kind, RunnableKind::TestMod { .. }) => false,\n+        Some(offset) => !runnable.nav.full_range.contains_inclusive(offset),\n+    }\n+}\n+\n pub(crate) fn handle_related_tests(\n     snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n@@ -1765,7 +1777,7 @@ fn run_rustfmt(\n \n     let line_index = snap.file_line_index(file_id)?;\n \n-    let mut rustfmt = match snap.config.rustfmt() {\n+    let mut command = match snap.config.rustfmt() {\n         RustfmtConfig::Rustfmt { extra_args, enable_range_formatting } => {\n             let mut cmd = process::Command::new(toolchain::rustfmt());\n             cmd.args(extra_args);\n@@ -1830,12 +1842,12 @@ fn run_rustfmt(\n         }\n     };\n \n-    let mut rustfmt = rustfmt\n+    let mut rustfmt = command\n         .stdin(Stdio::piped())\n         .stdout(Stdio::piped())\n         .stderr(Stdio::piped())\n         .spawn()\n-        .context(format!(\"Failed to spawn {:?}\", rustfmt))?;\n+        .context(format!(\"Failed to spawn {:?}\", command))?;\n \n     rustfmt.stdin.as_mut().unwrap().write_all(file.as_bytes())?;\n \n@@ -1854,7 +1866,11 @@ fn run_rustfmt(\n                 // formatting because otherwise an error is surfaced to the user on top of the\n                 // syntax error diagnostics they're already receiving. This is especially jarring\n                 // if they have format on save enabled.\n-                tracing::info!(\"rustfmt exited with status 1, assuming parse error and ignoring\");\n+                tracing::warn!(\n+                    ?command,\n+                    %captured_stderr,\n+                    \"rustfmt exited with status 1\"\n+                );\n                 Ok(None)\n             }\n             _ => {"}, {"sha": "e61c8b643d2dee940af7ae4fdcad4c7974d3583b", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -129,6 +129,14 @@ pub struct ExpandedMacro {\n     pub expansion: String,\n }\n \n+pub enum CancelFlycheck {}\n+\n+impl Request for CancelFlycheck {\n+    type Params = ();\n+    type Result = ();\n+    const METHOD: &'static str = \"rust-analyzer/cancelFlycheck\";\n+}\n+\n pub enum MatchingBrace {}\n \n impl Request for MatchingBrace {"}, {"sha": "f187547019a13524416a7676c72c30e85fa748b9", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -288,7 +288,7 @@ impl GlobalState {\n \n             if became_quiescent {\n                 // Project has loaded properly, kick off initial flycheck\n-                self.flycheck.iter().for_each(FlycheckHandle::update);\n+                self.flycheck.iter().for_each(FlycheckHandle::restart);\n                 if self.config.prefill_caches() {\n                     self.prime_caches_queue.request_op(\"became quiescent\".to_string());\n                 }\n@@ -590,6 +590,7 @@ impl GlobalState {\n             .on_sync_mut::<lsp_ext::ReloadWorkspace>(handlers::handle_workspace_reload)\n             .on_sync_mut::<lsp_ext::MemoryUsage>(handlers::handle_memory_usage)\n             .on_sync_mut::<lsp_ext::ShuffleCrateGraph>(handlers::handle_shuffle_crate_graph)\n+            .on_sync_mut::<lsp_ext::CancelFlycheck>(handlers::handle_cancel_flycheck)\n             .on_sync::<lsp_ext::JoinLines>(handlers::handle_join_lines)\n             .on_sync::<lsp_ext::OnEnter>(handlers::handle_on_enter)\n             .on_sync::<lsp_types::request::SelectionRangeRequest>(handlers::handle_selection_range)\n@@ -779,7 +780,7 @@ impl GlobalState {\n                             for (id, _) in workspace_ids.clone() {\n                                 if id == flycheck.id() {\n                                     updated = true;\n-                                    flycheck.update();\n+                                    flycheck.restart();\n                                     continue;\n                                 }\n                             }\n@@ -798,7 +799,7 @@ impl GlobalState {\n                 // No specific flycheck was triggered, so let's trigger all of them.\n                 if !updated {\n                     for flycheck in &this.flycheck {\n-                        flycheck.update();\n+                        flycheck.restart();\n                     }\n                 }\n                 Ok(())"}, {"sha": "ec3d3d444c365822f5c9d7efea9e8268f1bb36b1", "filename": "crates/syntax/src/hacks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fsyntax%2Fsrc%2Fhacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fsyntax%2Fsrc%2Fhacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fhacks.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -1,4 +1,4 @@\n-//! Things which exist to solve practial issues, but which shouldn't exist.\n+//! Things which exist to solve practical issues, but which shouldn't exist.\n //!\n //! Please avoid adding new usages of the functions in this module\n "}, {"sha": "6df29db4745d37840acc569b2e934b15fd06155f", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -471,6 +471,21 @@ pub mod future {\n         #[lang = \"poll\"]\n         fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n     }\n+\n+    pub trait IntoFuture {\n+        type Output;\n+        type IntoFuture: Future<Output = Self::Output>;\n+        #[lang = \"into_future\"]\n+        fn into_future(self) -> Self::IntoFuture;\n+    }\n+\n+    impl<F: Future> IntoFuture for F {\n+        type Output = F::Output;\n+        type IntoFuture = F;\n+        fn into_future(self) -> F {\n+            self\n+        }\n+    }\n }\n pub mod task {\n     pub enum Poll<T> {"}, {"sha": "fcc693a7ddac16908a14beaf99c946e9553462cf", "filename": "crates/vfs-notify/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fvfs-notify%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fvfs-notify%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2FCargo.toml?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -14,7 +14,7 @@ tracing = \"0.1.35\"\n jod-thread = \"0.1.2\"\n walkdir = \"2.3.2\"\n crossbeam-channel = \"0.5.5\"\n-notify = \"=5.0.0-pre.15\"\n+notify = \"=5.0.0-pre.16\"\n \n vfs = { path = \"../vfs\", version = \"0.0.0\" }\n paths = { path = \"../paths\", version = \"0.0.0\" }"}, {"sha": "c95304e55ac105e7e4264c9d58a6b689063fd226", "filename": "crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -12,7 +12,7 @@\n use std::fs;\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n-use notify::{RecommendedWatcher, RecursiveMode, Watcher};\n+use notify::{Config, RecommendedWatcher, RecursiveMode, Watcher};\n use paths::{AbsPath, AbsPathBuf};\n use vfs::loader;\n use walkdir::WalkDir;\n@@ -91,9 +91,12 @@ impl NotifyActor {\n                         self.watcher = None;\n                         if !config.watch.is_empty() {\n                             let (watcher_sender, watcher_receiver) = unbounded();\n-                            let watcher = log_notify_error(RecommendedWatcher::new(move |event| {\n-                                watcher_sender.send(event).unwrap();\n-                            }));\n+                            let watcher = log_notify_error(RecommendedWatcher::new(\n+                                move |event| {\n+                                    watcher_sender.send(event).unwrap();\n+                                },\n+                                Config::default(),\n+                            ));\n                             self.watcher = watcher.map(|it| (it, watcher_receiver));\n                         }\n "}, {"sha": "7badb1c363b44b46cfa0b74766a6fd74eae9d878", "filename": "crates/vfs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fvfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/crates%2Fvfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Flib.rs?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -64,7 +64,7 @@ pub struct FileId(pub u32);\n \n /// Storage for all files read by rust-analyzer.\n ///\n-/// For more informations see the [crate-level](crate) documentation.\n+/// For more information see the [crate-level](crate) documentation.\n #[derive(Default)]\n pub struct Vfs {\n     interner: PathInterner,"}, {"sha": "c173a239feab361b0a99d0fbab1a3e88cab4b62d", "filename": "docs/dev/architecture.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/docs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/docs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Farchitecture.md?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -485,7 +485,7 @@ Mind the code--architecture gap: at the moment, we are using fewer feature flags\n ### Serialization\n \n In Rust, it is easy (often too easy) to add serialization to any type by adding `#[derive(Serialize)]`.\n-This easiness is misleading -- serializable types impose significant backwards compatability constraints.\n+This easiness is misleading -- serializable types impose significant backwards compatibility constraints.\n If a type is serializable, then it is a part of some IPC boundary.\n You often don't control the other side of this boundary, so changing serializable types is hard.\n "}, {"sha": "6d2c7d7b06349aa0ac63493351107cfe350303dc", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: 2a188defec26cc7c\n+lsp_ext.rs hash: 7b710095d773b978\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:"}, {"sha": "751ec79af0fd4f2bcb644017d6209eaecde5e4fb", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -118,6 +118,10 @@ If you're changing this because you're using some tool wrapping\n Cargo, you might also want to change\n `#rust-analyzer.cargo.buildScripts.overrideCommand#`.\n \n+If there are multiple linked projects, this command is invoked for\n+each of them, with the working directory being the project root\n+(i.e., the folder containing the `Cargo.toml`).\n+\n An example command would be:\n \n ```bash\n@@ -318,6 +322,12 @@ Whether to show `Run` action. Only applies when\n --\n Whether to show documentation on hover.\n --\n+[[rust-analyzer.hover.documentation.keywords.enable]]rust-analyzer.hover.documentation.keywords.enable (default: `true`)::\n++\n+--\n+Whether to show keyword hover popups. Only applies when\n+`#rust-analyzer.hover.documentation.enable#` is set.\n+--\n [[rust-analyzer.hover.links.enable]]rust-analyzer.hover.links.enable (default: `true`)::\n +\n --"}, {"sha": "67eabc313c832b75478a5d303e57104f21df50a8", "filename": "editors/code/package.json", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -235,6 +235,11 @@\n                 \"command\": \"rust-analyzer.moveItemDown\",\n                 \"title\": \"Move item down\",\n                 \"category\": \"rust-analyzer\"\n+            },\n+            {\n+                \"command\": \"rust-analyzer.cancelFlycheck\",\n+                \"title\": \"Cancel running flychecks\",\n+                \"category\": \"rust-analyzer\"\n             }\n         ],\n         \"keybindings\": [\n@@ -542,7 +547,7 @@\n                     ]\n                 },\n                 \"rust-analyzer.checkOnSave.overrideCommand\": {\n-                    \"markdownDescription\": \"Override the command rust-analyzer uses instead of `cargo check` for\\ndiagnostics on save. The command is required to output json and\\nshould therefor include `--message-format=json` or a similar option.\\n\\nIf you're changing this because you're using some tool wrapping\\nCargo, you might also want to change\\n`#rust-analyzer.cargo.buildScripts.overrideCommand#`.\\n\\nAn example command would be:\\n\\n```bash\\ncargo check --workspace --message-format=json --all-targets\\n```\\n.\",\n+                    \"markdownDescription\": \"Override the command rust-analyzer uses instead of `cargo check` for\\ndiagnostics on save. The command is required to output json and\\nshould therefor include `--message-format=json` or a similar option.\\n\\nIf you're changing this because you're using some tool wrapping\\nCargo, you might also want to change\\n`#rust-analyzer.cargo.buildScripts.overrideCommand#`.\\n\\nIf there are multiple linked projects, this command is invoked for\\neach of them, with the working directory being the project root\\n(i.e., the folder containing the `Cargo.toml`).\\n\\nAn example command would be:\\n\\n```bash\\ncargo check --workspace --message-format=json --all-targets\\n```\\n.\",\n                     \"default\": null,\n                     \"type\": [\n                         \"null\",\n@@ -756,6 +761,11 @@\n                     \"default\": true,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.hover.documentation.keywords.enable\": {\n+                    \"markdownDescription\": \"Whether to show keyword hover popups. Only applies when\\n`#rust-analyzer.hover.documentation.enable#` is set.\",\n+                    \"default\": true,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.hover.links.enable\": {\n                     \"markdownDescription\": \"Use markdown syntax for links in hover.\",\n                     \"default\": true,"}, {"sha": "a21b304bbdaa0d92242924779cdc99ee995b4e27", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -433,7 +433,7 @@ export function syntaxTree(ctx: Ctx): Cmd {\n // The contents of the file come from the `TextDocumentContentProvider`\n export function viewHir(ctx: Ctx): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n-        readonly uri = vscode.Uri.parse(\"rust-analyzer-hir://viewHir/hir.txt\");\n+        readonly uri = vscode.Uri.parse(\"rust-analyzer-hir://viewHir/hir.rs\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n         constructor() {\n             vscode.workspace.onDidChangeTextDocument(\n@@ -655,7 +655,7 @@ function crateGraph(ctx: Ctx, full: boolean): Cmd {\n                     html, body { margin:0; padding:0; overflow:hidden }\n                     svg { position:fixed; top:0; left:0; height:100%; width:100% }\n \n-                    /* Disable the graphviz backgroud and fill the polygons */\n+                    /* Disable the graphviz background and fill the polygons */\n                     .graph > polygon { display:none; }\n                     :is(.node,.edge) polygon { fill: white; }\n \n@@ -817,6 +817,12 @@ export function openDocs(ctx: Ctx): Cmd {\n     };\n }\n \n+export function cancelFlycheck(ctx: Ctx): Cmd {\n+    return async () => {\n+        await ctx.client.sendRequest(ra.cancelFlycheck);\n+    };\n+}\n+\n export function resolveCodeAction(ctx: Ctx): Cmd {\n     const client = ctx.client;\n     return async (params: lc.CodeAction) => {"}, {"sha": "b83582a344a9841ae61063a88f0cbde0864ef4e9", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -5,8 +5,6 @@ import { log } from \"./util\";\n \n export type UpdatesChannel = \"stable\" | \"nightly\";\n \n-const NIGHTLY_TAG = \"nightly\";\n-\n export type RunnableEnvCfg =\n     | undefined\n     | Record<string, string>\n@@ -175,10 +173,6 @@ export class Config {\n             gotoTypeDef: this.get<boolean>(\"hover.actions.gotoTypeDef.enable\"),\n         };\n     }\n-\n-    get currentExtensionIsNightly() {\n-        return this.package.releaseTag === NIGHTLY_TAG;\n-    }\n }\n \n export async function updateConfig(config: vscode.WorkspaceConfiguration) {"}, {"sha": "875261c48a60e4f4c22c7b35865267aa5de5f8f4", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -75,6 +75,23 @@ export const expandMacro = new lc.RequestType<ExpandMacroParams, ExpandedMacro |\n     \"rust-analyzer/expandMacro\"\n );\n \n+export const relatedTests = new lc.RequestType<lc.TextDocumentPositionParams, TestInfo[], void>(\n+    \"rust-analyzer/relatedTests\"\n+);\n+\n+export const cancelFlycheck = new lc.RequestType0<void, void>(\"rust-analyzer/cancelFlycheck\");\n+\n+// Experimental extensions\n+\n+export interface SsrParams {\n+    query: string;\n+    parseOnly: boolean;\n+    textDocument: lc.TextDocumentIdentifier;\n+    position: lc.Position;\n+    selections: readonly lc.Range[];\n+}\n+export const ssr = new lc.RequestType<SsrParams, lc.WorkspaceEdit, void>(\"experimental/ssr\");\n+\n export interface MatchingBraceParams {\n     textDocument: lc.TextDocumentIdentifier;\n     positions: lc.Position[];\n@@ -127,19 +144,6 @@ export interface TestInfo {\n     runnable: Runnable;\n }\n \n-export const relatedTests = new lc.RequestType<lc.TextDocumentPositionParams, TestInfo[], void>(\n-    \"rust-analyzer/relatedTests\"\n-);\n-\n-export interface SsrParams {\n-    query: string;\n-    parseOnly: boolean;\n-    textDocument: lc.TextDocumentIdentifier;\n-    position: lc.Position;\n-    selections: readonly lc.Range[];\n-}\n-export const ssr = new lc.RequestType<SsrParams, lc.WorkspaceEdit, void>(\"experimental/ssr\");\n-\n export interface CommandLink extends lc.Command {\n     /**\n      * A tooltip for the command, when represented in the UI."}, {"sha": "a9847dd2a6521ba013d76b4c7562ff89334397c9", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -163,6 +163,7 @@ async function initCommonContext(context: vscode.ExtensionContext, ctx: Ctx) {\n     ctx.registerCommand(\"peekTests\", commands.peekTests);\n     ctx.registerCommand(\"moveItemUp\", commands.moveItemUp);\n     ctx.registerCommand(\"moveItemDown\", commands.moveItemDown);\n+    ctx.registerCommand(\"cancelFlycheck\", commands.cancelFlycheck);\n \n     defaultOnEnter.dispose();\n     ctx.registerCommand(\"onEnter\", commands.onEnter);"}, {"sha": "e1ca495428024ace9a3a5f0ae86595b8c84377ae", "filename": "editors/code/src/toolchain.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fsrc%2Ftoolchain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/6ac43ecf17d3286350223860cc77a3e5ae6a0d45/editors%2Fcode%2Fsrc%2Ftoolchain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftoolchain.ts?ref=6ac43ecf17d3286350223860cc77a3e5ae6a0d45", "patch": "@@ -158,7 +158,7 @@ export const getPathForExecutable = memoizeAsync(\n \n         try {\n             // hmm, `os.homedir()` seems to be infallible\n-            // it is not mentioned in docs and cannot be infered by the type signature...\n+            // it is not mentioned in docs and cannot be inferred by the type signature...\n             const standardPath = vscode.Uri.joinPath(\n                 vscode.Uri.file(os.homedir()),\n                 \".cargo\","}]}