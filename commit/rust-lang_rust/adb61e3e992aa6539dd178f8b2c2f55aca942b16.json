{"sha": "adb61e3e992aa6539dd178f8b2c2f55aca942b16", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYjYxZTNlOTkyYWE2NTM5ZGQxNzhmOGIyYzJmNTVhY2E5NDJiMTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-15T03:32:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-15T20:38:16Z"}, "message": "get preservation of boxes working, at least in simple cases", "tree": {"sha": "2ce30cb2ad86e65f4e5e67e89b1b900a83b154ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ce30cb2ad86e65f4e5e67e89b1b900a83b154ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adb61e3e992aa6539dd178f8b2c2f55aca942b16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adb61e3e992aa6539dd178f8b2c2f55aca942b16", "html_url": "https://github.com/rust-lang/rust/commit/adb61e3e992aa6539dd178f8b2c2f55aca942b16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adb61e3e992aa6539dd178f8b2c2f55aca942b16/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c7be32606f023c5a9f298d43a0b6617147cafa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c7be32606f023c5a9f298d43a0b6617147cafa8", "html_url": "https://github.com/rust-lang/rust/commit/4c7be32606f023c5a9f298d43a0b6617147cafa8"}], "stats": {"total": 829, "additions": 523, "deletions": 306}, "files": [{"sha": "20b608a7060a9dc5e4ff50dedaa64fb2c83a71fc", "filename": "src/rt/boxed_region.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frt%2Fboxed_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frt%2Fboxed_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.cpp?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -54,7 +54,6 @@ void boxed_region::free(rust_opaque_box *box) {\n \n     if (env->poison_on_free) {\n         memset(box_body(box), 0xab, box->td->size);\n-        return;\n     }\n \n     box->prev = NULL;"}, {"sha": "cfd314e1d2cdf46cf9b5d2ac28436cd570cabb98", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -190,7 +190,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n          bind middle::check_self::check_crate(ty_cx, crate));\n     time(time_passes, \"typestate checking\",\n          bind middle::tstate::ck::check_crate(ty_cx, crate));\n-    let (_root_map, mutbl_map) = time(\n+    let (root_map, mutbl_map) = time(\n         time_passes, \"borrow checking\",\n         bind middle::borrowck::check_crate(ty_cx, method_map, crate));\n     time(time_passes, \"region checking\",\n@@ -208,10 +208,10 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     if upto == cu_no_trans { ret {crate: crate, tcx: some(ty_cx)}; }\n     let outputs = option::get(outputs);\n \n-    let maps = {mutbl_map: mutbl_map, copy_map: copy_map,\n-                last_uses: last_uses, impl_map: impl_map,\n-                method_map: method_map, vtable_map: vtable_map,\n-                spill_map: spill_map};\n+    let maps = {mutbl_map: mutbl_map, root_map: root_map,\n+                copy_map: copy_map, last_uses: last_uses,\n+                impl_map: impl_map, method_map: method_map,\n+                vtable_map: vtable_map, spill_map: spill_map};\n \n     let (llmod, link_meta) =\n         time(time_passes, \"translation\","}, {"sha": "6f55cf0ca69d8f8f81ed455d696948daa2c0aed1", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -49,6 +49,7 @@ export decode_inlined_item;\n // Auxiliary maps of things to be encoded\n type maps = {\n     mutbl_map: middle::borrowck::mutbl_map,\n+    root_map: middle::borrowck::root_map,\n     copy_map: middle::alias::copy_map,\n     last_uses: middle::last_use::last_uses,\n     impl_map: middle::resolve::impl_map,"}, {"sha": "b9076cc435c5e0886f166c2b944a872412e15d3a", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -27,7 +27,7 @@ fn check_crate(tcx: ty::ctxt,\n     let bccx = @{tcx: tcx,\n                  method_map: method_map,\n                  msg_level: msg_level,\n-                 root_map: int_hash(),\n+                 root_map: root_map(),\n                  mutbl_map: int_hash()};\n \n     let req_loan_map = if msg_level > 0u {\n@@ -53,7 +53,14 @@ type borrowck_ctxt = @{tcx: ty::ctxt,\n // a map mapping id's of expressions of task-local type (@T, []/@, etc) where\n // the box needs to be kept live to the id of the scope for which they must\n // stay live.\n-type root_map = hashmap<ast::node_id, ast::node_id>;\n+type root_map = hashmap<root_map_key, ast::node_id>;\n+\n+// the keys to the root map combine the `id` of the expression with\n+// the number of types that it is autodereferenced.  So, for example,\n+// if you have an expression `x.f` and x has type ~@T, we could add an\n+// entry {id:x, derefs:0} to refer to `x` itself, `{id:x, derefs:1}`\n+// to refer to the deref of the unique pointer, and so on.\n+type root_map_key = {id: ast::node_id, derefs: uint};\n \n // set of ids of local vars / formal arguments that are modified / moved.\n // this is used in trans for optimization purposes.\n@@ -71,13 +78,13 @@ type bckerr = {cmt: cmt, code: bckerr_code};\n type bckres<T> = result<T, bckerr>;\n \n enum categorization {\n-    cat_rvalue,                 // result of eval'ing some misc expr\n-    cat_special(special_kind),  //\n-    cat_local(ast::node_id),    // local variable\n-    cat_arg(ast::node_id),      // formal argument\n-    cat_stack_upvar(cmt),       // upvar in stack closure\n-    cat_deref(cmt, ptr_kind),   // deref of a ptr\n-    cat_comp(cmt, comp_kind),   // adjust to locate an internal component\n+    cat_rvalue,                     // result of eval'ing some misc expr\n+    cat_special(special_kind),      //\n+    cat_local(ast::node_id),        // local variable\n+    cat_arg(ast::node_id),          // formal argument\n+    cat_stack_upvar(cmt),           // upvar in stack closure\n+    cat_deref(cmt, uint, ptr_kind), // deref of a ptr\n+    cat_comp(cmt, comp_kind),       // adjust to locate an internal component\n }\n \n // different kinds of pointers:\n@@ -156,6 +163,18 @@ fn save_and_restore<T:copy,U>(&t: T, f: fn() -> U) -> U {\n     ret u;\n }\n \n+fn root_map() -> root_map {\n+    ret hashmap(root_map_key_hash, root_map_key_eq);\n+\n+    fn root_map_key_eq(k1: root_map_key, k2: root_map_key) -> bool {\n+        k1.id == k2.id && k1.derefs == k2.derefs\n+    }\n+\n+    fn root_map_key_hash(k: root_map_key) -> uint {\n+        (k.id << 4) as uint | k.derefs\n+    }\n+}\n+\n // ----------------------------------------------------------------------\n // Gathering loans\n //\n@@ -374,7 +393,7 @@ impl methods for gather_loan_ctxt {\n \n           ast::pat_box(subpat) | ast::pat_uniq(subpat) {\n             // @p1, ~p1\n-            alt self.bccx.cat_deref(pat, cmt, true) {\n+            alt self.bccx.cat_deref(pat, cmt, 0u, true) {\n               some(subcmt) { self.gather_pat(subcmt, subpat, alt_id); }\n               none { tcx.sess.span_bug(pat.span, \"Non derefable type\"); }\n             }\n@@ -915,7 +934,7 @@ impl categorize_methods for borrowck_ctxt {\n \n           ty::ty_uniq(*) | ty::ty_box(*) | ty::ty_rptr(*) {\n             let cmt = self.cat_expr(expr);\n-            self.cat_deref(expr, cmt, true).get()\n+            self.cat_deref(expr, cmt, 0u, true).get()\n           }\n \n           _ {\n@@ -943,7 +962,7 @@ impl categorize_methods for borrowck_ctxt {\n         alt expr.node {\n           ast::expr_unary(ast::deref, e_base) {\n             let base_cmt = self.cat_expr(e_base);\n-            alt self.cat_deref(expr, base_cmt, true) {\n+            alt self.cat_deref(expr, base_cmt, 0u, true) {\n               some(cmt) { ret cmt; }\n               none {\n                 tcx.sess.span_bug(\n@@ -955,7 +974,7 @@ impl categorize_methods for borrowck_ctxt {\n           }\n \n           ast::expr_field(base, f_name, _) {\n-            let base_cmt = self.cat_autoderef(expr, base);\n+            let base_cmt = self.cat_autoderef(base);\n             self.cat_field(expr, base_cmt, f_name, expr_ty)\n           }\n \n@@ -1010,7 +1029,7 @@ impl categorize_methods for borrowck_ctxt {\n           mutbl: m, ty: f_ty}\n     }\n \n-    fn cat_deref<N:ast_node>(node: N, base_cmt: cmt,\n+    fn cat_deref<N:ast_node>(node: N, base_cmt: cmt, derefs: uint,\n                              expl: bool) -> option<cmt> {\n         ty::deref(self.tcx, base_cmt.ty, expl).map { |mt|\n             alt deref_kind(self.tcx, base_cmt.ty) {\n@@ -1027,7 +1046,7 @@ impl categorize_methods for borrowck_ctxt {\n                     }\n                 };\n                 @{id:node.id(), span:node.span(),\n-                  cat:cat_deref(base_cmt, ptr), lp:lp,\n+                  cat:cat_deref(base_cmt, derefs, ptr), lp:lp,\n                   mutbl:mt.mutbl, ty:mt.ty}\n               }\n \n@@ -1041,7 +1060,7 @@ impl categorize_methods for borrowck_ctxt {\n         }\n     }\n \n-    fn cat_autoderef(expr: @ast::expr, base: @ast::expr) -> cmt {\n+    fn cat_autoderef(base: @ast::expr) -> cmt {\n         // Creates a string of implicit derefences so long as base is\n         // dereferencable.  n.b., it is important that these dereferences are\n         // associated with the field/index that caused the autoderef (expr).\n@@ -1050,16 +1069,18 @@ impl categorize_methods for borrowck_ctxt {\n         // Given something like base.f where base has type @m1 @m2 T, we want\n         // to yield the equivalent categories to (**base).f.\n         let mut cmt = self.cat_expr(base);\n+        let mut ctr = 0u;\n         loop {\n-            alt self.cat_deref(expr, cmt, false) {\n+            ctr += 1u;\n+            alt self.cat_deref(base, cmt, ctr, false) {\n               none { ret cmt; }\n               some(cmt1) { cmt = cmt1; }\n             }\n         }\n     }\n \n     fn cat_index(expr: @ast::expr, base: @ast::expr) -> cmt {\n-        let base_cmt = self.cat_autoderef(expr, base);\n+        let base_cmt = self.cat_autoderef(base);\n \n         let mt = alt ty::index(self.tcx, base_cmt.ty) {\n           some(mt) { mt }\n@@ -1084,7 +1105,7 @@ impl categorize_methods for borrowck_ctxt {\n         // the head of this section\n         let deref_lp = base_cmt.lp.map { |lp| @lp_deref(lp, ptr) };\n         let deref_cmt = @{id:expr.id, span:expr.span,\n-                          cat:cat_deref(base_cmt, ptr), lp:deref_lp,\n+                          cat:cat_deref(base_cmt, 0u, ptr), lp:deref_lp,\n                           mutbl:mt.mutbl, ty:mt.ty};\n         let comp = comp_index(base_cmt.ty);\n         let index_lp = deref_lp.map { |lp| @lp_comp(lp, comp) };\n@@ -1211,8 +1232,9 @@ impl categorize_methods for borrowck_ctxt {\n           cat_rvalue { \"rvalue\" }\n           cat_local(node_id) { #fmt[\"local(%d)\", node_id] }\n           cat_arg(node_id) { #fmt[\"arg(%d)\", node_id] }\n-          cat_deref(cmt, ptr) {\n-            #fmt[\"%s->(%s)\", self.cat_to_repr(cmt.cat), self.ptr_sigil(ptr)]\n+          cat_deref(cmt, derefs, ptr) {\n+            #fmt[\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n+                 self.ptr_sigil(ptr), derefs]\n           }\n           cat_comp(cmt, comp) {\n             #fmt[\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp)]\n@@ -1285,7 +1307,7 @@ impl categorize_methods for borrowck_ctxt {\n           cat_rvalue { \"non-lvalue\" }\n           cat_local(_) { mut_str + \" local variable\" }\n           cat_arg(_) { mut_str + \" argument\" }\n-          cat_deref(_, _) { \"dereference of \" + mut_str + \" pointer\" }\n+          cat_deref(*) { \"dereference of \" + mut_str + \" pointer\" }\n           cat_stack_upvar(_) { mut_str + \" upvar\" }\n           cat_comp(_, comp_field(_)) { mut_str + \" field\" }\n           cat_comp(_, comp_tuple) { \"tuple content\" }\n@@ -1446,26 +1468,31 @@ impl preserve_methods for preserve_ctxt {\n           cat_comp(cmt1, comp_variant) {\n             self.require_imm(cmt, cmt1, err_mut_variant)\n           }\n-          cat_deref(cmt1, uniq_ptr) {\n+          cat_deref(cmt1, _, uniq_ptr) {\n             self.require_imm(cmt, cmt1, err_mut_uniq)\n           }\n-          cat_deref(_, region_ptr) {\n+          cat_deref(_, _, region_ptr) {\n             // References are always \"stable\" by induction (when the\n             // reference of type &MT was created, the memory must have\n             // been stable)\n             ok(())\n           }\n-          cat_deref(_, unsafe_ptr) {\n+          cat_deref(_, _, unsafe_ptr) {\n             // Unsafe pointers are the user's problem\n             ok(())\n           }\n-          cat_deref(_, gc_ptr) {\n+          cat_deref(_, derefs, gc_ptr) {\n             // GC'd pointers of type @MT: always stable because we can inc\n             // the ref count or keep a GC root as necessary.  We need to\n             // insert this id into the root_map, however.\n             alt self.opt_scope_id {\n               some(scope_id) {\n-                self.bccx.root_map.insert(cmt.id, scope_id);\n+                #debug[\"Inserting root map entry for %s: \\\n+                        node %d:%u -> scope %d\",\n+                       self.bccx.cmt_to_repr(cmt), cmt.id,\n+                       derefs, scope_id];\n+                let rk = {id: cmt.id, derefs: derefs};\n+                self.bccx.root_map.insert(rk, scope_id);\n                 ok(())\n               }\n               none {\n@@ -1562,7 +1589,7 @@ impl loan_methods for loan_ctxt {\n             }\n           }\n           cat_comp(cmt1, comp_variant) |\n-          cat_deref(cmt1, uniq_ptr) {\n+          cat_deref(cmt1, _, uniq_ptr) {\n             // Variant components: the base must be immutable, because\n             // if it is overwritten, the types of the embedded data\n             // could change.\n@@ -1573,9 +1600,9 @@ impl loan_methods for loan_ctxt {\n                 self.ok_with_loan_of(cmt, req_mutbl)\n             }\n           }\n-          cat_deref(cmt1, unsafe_ptr) |\n-          cat_deref(cmt1, gc_ptr) |\n-          cat_deref(cmt1, region_ptr) {\n+          cat_deref(cmt1, _, unsafe_ptr) |\n+          cat_deref(cmt1, _, gc_ptr) |\n+          cat_deref(cmt1, _, region_ptr) {\n             // Aliased data is simply not lendable.\n             self.bccx.tcx.sess.span_bug(\n                 cmt.span,"}, {"sha": "43dfda534844c4d38aa0f22b916db11717024fb5", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 388, "deletions": 264, "changes": 652, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -1641,12 +1641,34 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n                           save_in(lhs_res.val));\n }\n \n-fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n+fn autoderef(cx: block, e_id: ast::node_id,\n+             v: ValueRef, t: ty::t) -> result_t {\n     let _icx = cx.insn_ctxt(\"autoderef\");\n     let mut v1: ValueRef = v;\n     let mut t1: ty::t = t;\n     let ccx = cx.ccx();\n+    let mut derefs = 0u;\n     loop {\n+        #debug[\"autoderef(e_id=%d, v1=%s, t1=%s, derefs=%u)\",\n+               e_id, val_str(ccx.tn, v1), ty_to_str(ccx.tcx, t1),\n+               derefs];\n+\n+        // check if the result of this autoderef must be preserved\n+        derefs += 1u;\n+        alt cx.ccx().maps.root_map.find({id:e_id, derefs:derefs}) {\n+          none {}\n+          some(scope_id) {\n+            if !cx.sess().opts.no_asm_comments {\n+                add_comment(cx, #fmt[\"preserving until end of scope %d\",\n+                                     scope_id]);\n+            }\n+            let root_loc = alloca(cx, type_of(cx.ccx(), t1));\n+            Store(cx, v1, root_loc);\n+            take_ty(cx, root_loc, t1);\n+            add_root_cleanup(cx, scope_id, root_loc, t1);\n+          }\n+        }\n+\n         alt ty::get(t1).struct {\n           ty::ty_box(mt) {\n             let body = GEPi(cx, v1, [0u, abi::box_field_body]);\n@@ -1677,8 +1699,7 @@ fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n             if (*variants).len() != 1u || variants[0].args.len() != 1u {\n                 break;\n             }\n-            t1 =\n-                ty::subst(ccx.tcx, substs, variants[0].args[0]);\n+            t1 = ty::subst(ccx.tcx, substs, variants[0].args[0]);\n             v1 = PointerCast(cx, v1, T_ptr(type_of(ccx, t1)));\n           }\n           _ { break; }\n@@ -2313,7 +2334,7 @@ fn trans_rec_field(bcx: block, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n     let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n     let {bcx, val} = trans_temp_expr(bcx, base);\n-    let {bcx, val, ty} = autoderef(bcx, val, expr_ty(bcx, base));\n+    let {bcx, val, ty} = autoderef(bcx, base.id, val, expr_ty(bcx, base));\n     trans_rec_field_inner(bcx, val, ty, field, base.span)\n }\n \n@@ -2338,7 +2359,7 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     let _icx = cx.insn_ctxt(\"trans_index\");\n     let base_ty = expr_ty(cx, base);\n     let exp = trans_temp_expr(cx, base);\n-    let lv = autoderef(exp.bcx, exp.val, base_ty);\n+    let lv = autoderef(exp.bcx, base.id, exp.val, base_ty);\n     let ix = trans_temp_expr(lv.bcx, idx);\n     let v = lv.val;\n     let bcx = ix.bcx;\n@@ -2417,40 +2438,64 @@ fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n-    let _icx = cx.insn_ctxt(\"trans_lval\");\n-    alt e.node {\n-      ast::expr_path(_) {\n-        let v = trans_path(cx, e.id);\n-        ret lval_maybe_callee_to_lval(v, expr_ty(cx, e));\n-      }\n-      ast::expr_field(base, ident, _) {\n-        ret trans_rec_field(cx, base, ident);\n-      }\n-      ast::expr_index(base, idx) {\n-        ret trans_index(cx, e, base, idx);\n+    ret alt cx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n+      // No need to root this lvalue.\n+      none { unrooted(cx, e) }\n+\n+      // Lvalue must remain rooted until exit of `scope_id`.  See\n+      // add_root_cleanup() for comments on why this works the way it does.\n+      some(scope_id) {\n+        let lv = unrooted(cx, e);\n+\n+        if !cx.sess().opts.no_asm_comments {\n+            add_comment(cx, #fmt[\"preserving until end of scope %d\",\n+                                 scope_id]);\n+        }\n+\n+        let ty = expr_ty(lv.bcx, e);\n+        let root_loc = alloca(lv.bcx, type_of(cx.ccx(), ty));\n+        let bcx = store_temp_expr(lv.bcx, INIT, root_loc, lv, ty, false);\n+        add_root_cleanup(bcx, scope_id, root_loc, ty);\n+        {bcx: bcx with lv}\n       }\n-      ast::expr_unary(ast::deref, base) {\n-        let ccx = cx.ccx();\n-        let sub = trans_temp_expr(cx, base);\n-        let t = expr_ty(cx, base);\n-        let val = alt check ty::get(t).struct {\n-          ty::ty_box(_) {\n-            let non_gc_val = non_gc_box_cast(sub.bcx, sub.val, t);\n-            GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n+    };\n+\n+    fn unrooted(cx: block, e: @ast::expr) -> lval_result {\n+        let _icx = cx.insn_ctxt(\"trans_lval\");\n+        alt e.node {\n+          ast::expr_path(_) {\n+            let v = trans_path(cx, e.id);\n+            ret lval_maybe_callee_to_lval(v, expr_ty(cx, e));\n           }\n-          ty::ty_res(_, _, _) {\n-            GEPi(sub.bcx, sub.val, [0u, 1u])\n+          ast::expr_field(base, ident, _) {\n+            ret trans_rec_field(cx, base, ident);\n           }\n-          ty::ty_enum(_, _) {\n-            let ety = expr_ty(cx, e);\n-            let ellty = T_ptr(type_of(ccx, ety));\n-            PointerCast(sub.bcx, sub.val, ellty)\n+          ast::expr_index(base, idx) {\n+            ret trans_index(cx, e, base, idx);\n           }\n-          ty::ty_ptr(_) | ty::ty_uniq(_) | ty::ty_rptr(_,_) { sub.val }\n-        };\n-        ret lval_owned(sub.bcx, val);\n-      }\n-      _ { cx.sess().span_bug(e.span, \"non-lval in trans_lval\"); }\n+          ast::expr_unary(ast::deref, base) {\n+            let ccx = cx.ccx();\n+            let sub = trans_temp_expr(cx, base);\n+            let t = expr_ty(cx, base);\n+            let val = alt check ty::get(t).struct {\n+              ty::ty_box(_) {\n+                let non_gc_val = non_gc_box_cast(sub.bcx, sub.val, t);\n+                GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n+              }\n+              ty::ty_res(_, _, _) {\n+                GEPi(sub.bcx, sub.val, [0u, 1u])\n+              }\n+              ty::ty_enum(_, _) {\n+                let ety = expr_ty(cx, e);\n+                let ellty = T_ptr(type_of(ccx, ety));\n+                PointerCast(sub.bcx, sub.val, ellty)\n+              }\n+              ty::ty_ptr(_) | ty::ty_uniq(_) | ty::ty_rptr(_,_) { sub.val }\n+            };\n+            ret lval_owned(sub.bcx, val);\n+          }\n+          _ { cx.sess().span_bug(e.span, \"non-lval in trans_lval\"); }\n+        }\n     }\n }\n \n@@ -2498,12 +2543,12 @@ fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n     let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n     let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n     ret if dstsz == srcsz {\n-            BitCast(bcx, llsrc, lldsttype)\n-        } else if srcsz > dstsz {\n-            TruncOrBitCast(bcx, llsrc, lldsttype)\n-        } else if signed {\n-            SExtOrBitCast(bcx, llsrc, lldsttype)\n-        } else { ZExtOrBitCast(bcx, llsrc, lldsttype) };\n+        BitCast(bcx, llsrc, lldsttype)\n+    } else if srcsz > dstsz {\n+        TruncOrBitCast(bcx, llsrc, lldsttype)\n+    } else if signed {\n+        SExtOrBitCast(bcx, llsrc, lldsttype)\n+    } else { ZExtOrBitCast(bcx, llsrc, lldsttype) };\n }\n \n fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n@@ -2512,14 +2557,14 @@ fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n     let srcsz = lib::llvm::float_width(llsrctype);\n     let dstsz = lib::llvm::float_width(lldsttype);\n     ret if dstsz > srcsz {\n-            FPExt(bcx, llsrc, lldsttype)\n-        } else if srcsz > dstsz {\n-            FPTrunc(bcx, llsrc, lldsttype)\n-        } else { llsrc };\n+        FPExt(bcx, llsrc, lldsttype)\n+    } else if srcsz > dstsz {\n+        FPTrunc(bcx, llsrc, lldsttype)\n+    } else { llsrc };\n }\n \n enum cast_kind { cast_pointer, cast_integral, cast_float,\n-                 cast_enum, cast_other, }\n+                cast_enum, cast_other, }\n fn cast_type_kind(t: ty::t) -> cast_kind {\n     if ty::type_is_fp(t) { cast_float }\n     else if ty::type_is_unsafe_ptr(t) { cast_pointer }\n@@ -2694,6 +2739,14 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     ret rslt(bcx, val);\n }\n \n+fn load_value_from_lval_result(lv: lval_result) -> ValueRef {\n+    alt lv.kind {\n+      temporary { lv.val }\n+      owned { Load(lv.bcx, lv.val) }\n+      owned_imm { lv.val }\n+    }\n+}\n+\n fn adapt_borrowed_value(lv: lval_result, _arg: ty::arg,\n                         e: @ast::expr) -> lval_result {\n     let bcx = lv.bcx;\n@@ -2702,13 +2755,7 @@ fn adapt_borrowed_value(lv: lval_result, _arg: ty::arg,\n     let e_ty = expr_ty(bcx, e);\n     alt ty::get(e_ty).struct {\n       ty::ty_box(mt) {\n-        let box_ptr = {\n-            alt lv.kind {\n-              temporary { lv.val }\n-              owned { Load(bcx, lv.val) }\n-              owned_imm { lv.val }\n-            }\n-        };\n+        let box_ptr = load_value_from_lval_result(lv);\n         let body_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_body]);\n         ret lval_temp(bcx, body_ptr);\n       }\n@@ -2800,7 +2847,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n         vec::iteri(es) {|i, e|\n             let r = trans_arg_expr(bcx, arg_tys[i], llarg_tys[i],\n                                    e, temp_cleanups, if i == last { ret_flag }\n-                                                     else { none });\n+                                   else { none });\n             bcx = r.bcx;\n             llargs += [r.val];\n         }\n@@ -3180,234 +3227,307 @@ fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n     ret {bcx: bcx, val: val};\n }\n \n+// Arranges for the value found in `*root_loc` to be dropped once the scope\n+// associated with `scope_id` exits.  This is used to keep boxes live when\n+// there are extant region pointers pointing at the interior.\n+//\n+// Note that `root_loc` is not the value itself but rather a pointer to the\n+// value.  Generally it in alloca'd value.  The reason for this is that the\n+// value is initialized in an inner block but may be freed in some outer\n+// block, so an SSA value that is valid in the inner block may not be valid in\n+// the outer block.  In fact, the inner block may not even execute.  Rather\n+// than generate the full SSA form, we just use an alloca'd value.\n+fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n+                    root_loc: ValueRef, ty: ty::t) {\n+\n+    #debug[\"add_root_cleanup(bcx=%s, scope_id=%d, root_loc=%s, ty=%s)\",\n+           bcx.to_str(), scope_id, val_str(bcx.ccx().tn, root_loc),\n+           ty_to_str(bcx.ccx().tcx, ty)];\n+\n+    let bcx_scope = find_bcx_for_scope(bcx, scope_id);\n+    add_clean_temp_mem(bcx_scope, root_loc, ty);\n+\n+    fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n+        let mut bcx_sid = bcx;\n+        loop {\n+            bcx_sid = alt bcx_sid.node_info {\n+              some({id, _}) if id == scope_id { ret bcx_sid; }\n+              _ {\n+                alt bcx_sid.parent {\n+                  parent_none {\n+                    bcx.tcx().sess.bug(\n+                        #fmt[\"no enclosing scope with id %d\", scope_id]);\n+                  }\n+                  parent_some(bcx_par) { bcx_par }\n+                }\n+              }\n+            }\n+        }\n+    }\n+}\n+\n // Translate an expression, with the dest argument deciding what happens with\n // the result. Invariants:\n // - exprs returning nil or bot always get dest=ignore\n // - exprs with non-immediate type never get dest=by_val\n fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_expr\");\n-    let tcx = bcx.tcx();\n     debuginfo::update_source_pos(bcx, e.span);\n \n     if expr_is_lval(bcx, e) {\n         ret lval_to_dps(bcx, e, dest);\n     }\n \n-    alt e.node {\n-      ast::expr_if(cond, thn, els) | ast::expr_if_check(cond, thn, els) {\n-        ret trans_if(bcx, cond, thn, els, dest);\n-      }\n-      ast::expr_alt(expr, arms, mode) {\n-        ret alt::trans_alt(bcx, e, expr, arms, mode, dest);\n-      }\n-      ast::expr_block(blk) {\n-        ret with_scope(bcx, blk.info(), \"block-expr body\") {|bcx|\n-            trans_block(bcx, blk, dest)\n-        };\n-      }\n-      ast::expr_rec(args, base) {\n-        ret trans_rec(bcx, args, base, e.id, dest);\n-      }\n-      ast::expr_tup(args) { ret trans_tup(bcx, args, dest); }\n-      ast::expr_vstore(e, v) { ret tvec::trans_vstore(bcx, e, v, dest); }\n-      ast::expr_lit(lit) { ret trans_lit(bcx, *lit, dest); }\n-      ast::expr_vec(args, _) {\n-        ret tvec::trans_evec(bcx, args, ast::vstore_uniq, e.id, dest);\n-      }\n-      ast::expr_binary(op, lhs, rhs) {\n-        ret trans_binary(bcx, op, lhs, rhs, dest, e);\n-      }\n-      ast::expr_unary(op, x) {\n-        assert op != ast::deref; // lvals are handled above\n-        ret trans_unary(bcx, op, x, e, dest);\n-      }\n-      ast::expr_addr_of(_, x) { ret trans_addr_of(bcx, x, dest); }\n-      ast::expr_fn(proto, decl, body, cap_clause) {\n-        ret closure::trans_expr_fn(bcx, proto, decl, body, e.span, e.id,\n-                                   cap_clause, none, dest);\n-      }\n-      ast::expr_fn_block(decl, body, cap_clause) {\n-        alt check ty::get(expr_ty(bcx, e)).struct {\n-          ty::ty_fn({proto, _}) {\n-            #debug(\"translating fn_block %s with type %s\",\n-                   expr_to_str(e), ty_to_str(tcx, expr_ty(bcx, e)));\n-            ret closure::trans_expr_fn(bcx, proto, decl, body, e.span, e.id,\n-                                       cap_clause, none, dest);\n-          }\n-        }\n-      }\n-      ast::expr_loop_body(blk) {\n-        ret trans_loop_body(bcx, e, none, dest);\n-      }\n-      ast::expr_bind(f, args) {\n-        ret closure::trans_bind(\n-            bcx, f, args, e.id, dest);\n-      }\n-      ast::expr_copy(a) {\n-        if !expr_is_lval(bcx, a) {\n-            ret trans_expr(bcx, a, dest);\n-        }\n-        else { ret lval_to_dps(bcx, a, dest); }\n-      }\n-      ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n-      ast::expr_call(f, args, _) {\n-        ret trans_call(bcx, e, f, arg_exprs(args), e.id, dest);\n-      }\n-      ast::expr_field(base, _, _) {\n-        if dest == ignore { ret trans_expr(bcx, base, ignore); }\n-        let callee = trans_callee(bcx, e), ty = expr_ty(bcx, e);\n-        let lv = lval_maybe_callee_to_lval(callee, ty);\n-        revoke_clean(lv.bcx, lv.val);\n-        memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, ty);\n-        ret lv.bcx;\n-      }\n-      ast::expr_index(base, idx) {\n-        // If it is here, it's not an lval, so this is a user-defined index op\n-        let origin = bcx.ccx().maps.method_map.get(e.id);\n-        let callee_id = ast_util::op_expr_callee_id(e);\n-        let fty = node_id_type(bcx, callee_id);\n-        ret trans_call_inner(\n-            bcx, e.info(), fty,\n-            expr_ty(bcx, e),\n-            { |bcx|\n-                impl::trans_method_callee(bcx, callee_id, base, origin)\n-            },\n-            arg_exprs([idx]), dest);\n-      }\n-\n-      // These return nothing\n-      ast::expr_break {\n-        assert dest == ignore;\n-        ret trans_break(bcx);\n-      }\n-      ast::expr_cont {\n-        assert dest == ignore;\n-        ret trans_cont(bcx);\n-      }\n-      ast::expr_ret(ex) {\n-        assert dest == ignore;\n-        ret trans_ret(bcx, ex);\n-      }\n-      ast::expr_fail(expr) {\n-        assert dest == ignore;\n-        ret trans_fail_expr(bcx, some(e.span), expr);\n-      }\n-      ast::expr_log(_, lvl, a) {\n-        assert dest == ignore;\n-        ret trans_log(e, lvl, bcx, a);\n-      }\n-      ast::expr_assert(a) {\n-        assert dest == ignore;\n-        ret trans_check_expr(bcx, e, a, \"Assertion\");\n-      }\n-      ast::expr_check(ast::checked_expr, a) {\n-        assert dest == ignore;\n-        ret trans_check_expr(bcx, e, a, \"Predicate\");\n-      }\n-      ast::expr_check(ast::claimed_expr, a) {\n-        assert dest == ignore;\n-        /* Claims are turned on and off by a global variable\n-           that the RTS sets. This case generates code to\n-           check the value of that variable, doing nothing\n-           if it's set to false and acting like a check\n-           otherwise. */\n-        let c = get_extern_const(bcx.ccx().externs, bcx.ccx().llmod,\n-                                 \"check_claims\", T_bool());\n-        ret with_cond(bcx, Load(bcx, c)) {|bcx|\n-            trans_check_expr(bcx, e, a, \"Claim\")\n-        };\n-      }\n-      ast::expr_while(cond, body) {\n-        assert dest == ignore;\n-        ret trans_while(bcx, cond, body);\n-      }\n-      ast::expr_loop(body) {\n-        assert dest == ignore;\n-        ret trans_loop(bcx, body);\n-      }\n-      ast::expr_assign(dst, src) {\n-        assert dest == ignore;\n-        let src_r = trans_temp_lval(bcx, src);\n-        let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n-        assert kind == owned;\n-        ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n-                            expr_ty(bcx, src),\n-                            bcx.ccx().maps.last_uses.contains_key(src.id));\n-      }\n-      ast::expr_move(dst, src) {\n-        // FIXME: calculate copy init-ness in typestate.\n-        assert dest == ignore;\n-        let src_r = trans_temp_lval(bcx, src);\n-        let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n-        assert kind == owned;\n-        ret move_val(bcx, DROP_EXISTING, addr, src_r,\n-                     expr_ty(bcx, src));\n-      }\n-      ast::expr_swap(dst, src) {\n-        assert dest == ignore;\n-        let lhs_res = trans_lval(bcx, dst);\n-        assert lhs_res.kind == owned;\n-        let rhs_res = trans_lval(lhs_res.bcx, src);\n-        let t = expr_ty(bcx, src);\n-        let tmp_alloc = alloc_ty(rhs_res.bcx, t);\n-        // Swap through a temporary.\n-        let bcx = move_val(rhs_res.bcx, INIT, tmp_alloc, lhs_res, t);\n-        let bcx = move_val(bcx, INIT, lhs_res.val, rhs_res, t);\n-        ret move_val(bcx, INIT, rhs_res.val, lval_owned(bcx, tmp_alloc), t);\n-      }\n-      ast::expr_assign_op(op, dst, src) {\n-        assert dest == ignore;\n-        ret trans_assign_op(bcx, e, op, dst, src);\n-      }\n-      ast::expr_new(pool, alloc_id, val) {\n-        // First, call pool->alloc(sz, align) to get back a void*.  Then, cast\n-        // this memory to the required type and evaluate value into it.\n-        let ccx = bcx.ccx();\n+    ret alt bcx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n+      none { unrooted(bcx, e, dest) }\n+      some(scope_id) {\n+        #debug[\"expression %d found in root map with scope %d\",\n+               e.id, scope_id];\n \n-        // Allocate space for the ptr that will be returned from\n-        // `pool.alloc()`:\n-        let ptr_ty = expr_ty(bcx, e);\n-        let ptr_ptr_val = alloc_ty(bcx, ptr_ty);\n+        let ty = expr_ty(bcx, e);\n+        let root_loc = alloca(bcx, type_of(bcx.ccx(), ty));\n+        let bcx = unrooted(bcx, e, save_in(root_loc));\n \n-        #debug[\"ptr_ty = %s\", ty_to_str(tcx, ptr_ty)];\n-        #debug[\"ptr_ptr_val = %s\", val_str(ccx.tn, ptr_ptr_val)];\n+        if !bcx.sess().opts.no_asm_comments {\n+            add_comment(bcx, #fmt[\"preserving until end of scope %d\",\n+                                  scope_id]);\n+        }\n \n-        let void_ty = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx),\n-                                       mutbl: ast::m_imm});\n-        let voidval = {\n-            let llvoid_ty = type_of(ccx, void_ty);\n-            PointerCast(bcx, ptr_ptr_val, T_ptr(llvoid_ty))\n-        };\n+        add_root_cleanup(bcx, scope_id, root_loc, ty);\n+        let lv = {bcx: bcx, val: root_loc, kind: owned};\n+        lval_result_to_dps(lv, ty, false, dest)\n+      }\n+    };\n \n-        #debug[\"voidval = %s\", val_str(ccx.tn, voidval)];\n+    fn unrooted(bcx: block, e: @ast::expr, dest: dest) -> block {\n+        let tcx = bcx.tcx();\n+        alt e.node {\n+          ast::expr_if(cond, thn, els) | ast::expr_if_check(cond, thn, els) {\n+            ret trans_if(bcx, cond, thn, els, dest);\n+          }\n+          ast::expr_alt(expr, arms, mode) {\n+            ret alt::trans_alt(bcx, e, expr, arms, mode, dest);\n+          }\n+          ast::expr_block(blk) {\n+            ret with_scope(bcx, blk.info(), \"block-expr body\") {|bcx|\n+                trans_block(bcx, blk, dest)\n+            };\n+          }\n+          ast::expr_rec(args, base) {\n+            ret trans_rec(bcx, args, base, e.id, dest);\n+          }\n+          ast::expr_tup(args) { ret trans_tup(bcx, args, dest); }\n+          ast::expr_vstore(e, v) { ret tvec::trans_vstore(bcx, e, v, dest); }\n+          ast::expr_lit(lit) { ret trans_lit(bcx, *lit, dest); }\n+          ast::expr_vec(args, _) {\n+            ret tvec::trans_evec(bcx, args, ast::vstore_uniq, e.id, dest);\n+          }\n+          ast::expr_binary(op, lhs, rhs) {\n+            ret trans_binary(bcx, op, lhs, rhs, dest, e);\n+          }\n+          ast::expr_unary(op, x) {\n+            assert op != ast::deref; // lvals are handled above\n+            ret trans_unary(bcx, op, x, e, dest);\n+          }\n+          ast::expr_addr_of(_, x) { ret trans_addr_of(bcx, x, dest); }\n+          ast::expr_fn(proto, decl, body, cap_clause) {\n+            ret closure::trans_expr_fn(bcx, proto, decl, body, e.span, e.id,\n+                                       cap_clause, none, dest);\n+          }\n+          ast::expr_fn_block(decl, body, cap_clause) {\n+            alt check ty::get(expr_ty(bcx, e)).struct {\n+              ty::ty_fn({proto, _}) {\n+                #debug(\"translating fn_block %s with type %s\",\n+                       expr_to_str(e), ty_to_str(tcx, expr_ty(bcx, e)));\n+                ret closure::trans_expr_fn(bcx, proto, decl, body, e.span,\n+                                           e.id, cap_clause, none, dest);\n+              }\n+            }\n+          }\n+          ast::expr_loop_body(blk) {\n+            ret trans_loop_body(bcx, e, none, dest);\n+          }\n+          ast::expr_bind(f, args) {\n+            ret closure::trans_bind(\n+                bcx, f, args, e.id, dest);\n+          }\n+          ast::expr_copy(a) {\n+            if !expr_is_lval(bcx, a) {\n+                ret trans_expr(bcx, a, dest);\n+            }\n+            else { ret lval_to_dps(bcx, a, dest); }\n+          }\n+          ast::expr_cast(val, _) { ret trans_cast(bcx, val, e.id, dest); }\n+          ast::expr_call(f, args, _) {\n+            ret trans_call(bcx, e, f, arg_exprs(args), e.id, dest);\n+          }\n+          ast::expr_field(base, _, _) {\n+            if dest == ignore { ret trans_expr(bcx, base, ignore); }\n+            let callee = trans_callee(bcx, e), ty = expr_ty(bcx, e);\n+            let lv = lval_maybe_callee_to_lval(callee, ty);\n+            revoke_clean(lv.bcx, lv.val);\n+            memmove_ty(lv.bcx, get_dest_addr(dest), lv.val, ty);\n+            ret lv.bcx;\n+          }\n+          ast::expr_index(base, idx) {\n+            // If it is here, it's not an lval, so this is a user-defined\n+            // index op\n+            let origin = bcx.ccx().maps.method_map.get(e.id);\n+            let callee_id = ast_util::op_expr_callee_id(e);\n+            let fty = node_id_type(bcx, callee_id);\n+            ret trans_call_inner(\n+                bcx, e.info(), fty,\n+                expr_ty(bcx, e),\n+                { |bcx|\n+                    impl::trans_method_callee(bcx, callee_id, base, origin)\n+                },\n+                arg_exprs([idx]), dest);\n+          }\n \n-        let llval_ty = type_of(ccx, expr_ty(bcx, val));\n-        let args = [llsize_of(ccx, llval_ty), llalign_of(ccx, llval_ty)];\n-        let origin = bcx.ccx().maps.method_map.get(alloc_id);\n-        let bcx = trans_call_inner(\n-            bcx, e.info(), node_id_type(bcx, alloc_id), void_ty,\n-            {|bcx| impl::trans_method_callee(bcx, alloc_id, pool, origin) },\n-            arg_vals(args),\n-            save_in(voidval));\n+          // These return nothing\n+          ast::expr_break {\n+            assert dest == ignore;\n+            ret trans_break(bcx);\n+          }\n+          ast::expr_cont {\n+            assert dest == ignore;\n+            ret trans_cont(bcx);\n+          }\n+          ast::expr_ret(ex) {\n+            assert dest == ignore;\n+            ret trans_ret(bcx, ex);\n+          }\n+          ast::expr_fail(expr) {\n+            assert dest == ignore;\n+            ret trans_fail_expr(bcx, some(e.span), expr);\n+          }\n+          ast::expr_log(_, lvl, a) {\n+            assert dest == ignore;\n+            ret trans_log(e, lvl, bcx, a);\n+          }\n+          ast::expr_assert(a) {\n+            assert dest == ignore;\n+            ret trans_check_expr(bcx, e, a, \"Assertion\");\n+          }\n+          ast::expr_check(ast::checked_expr, a) {\n+            assert dest == ignore;\n+            ret trans_check_expr(bcx, e, a, \"Predicate\");\n+          }\n+          ast::expr_check(ast::claimed_expr, a) {\n+            assert dest == ignore;\n+            /* Claims are turned on and off by a global variable\n+            that the RTS sets. This case generates code to\n+            check the value of that variable, doing nothing\n+            if it's set to false and acting like a check\n+            otherwise. */\n+            let c = get_extern_const(bcx.ccx().externs, bcx.ccx().llmod,\n+                                     \"check_claims\", T_bool());\n+            ret with_cond(bcx, Load(bcx, c)) {|bcx|\n+                trans_check_expr(bcx, e, a, \"Claim\")\n+            };\n+          }\n+          ast::expr_while(cond, body) {\n+            assert dest == ignore;\n+            ret trans_while(bcx, cond, body);\n+          }\n+          ast::expr_loop(body) {\n+            assert dest == ignore;\n+            ret trans_loop(bcx, body);\n+          }\n+          ast::expr_assign(dst, src) {\n+            assert dest == ignore;\n+            let src_r = trans_temp_lval(bcx, src);\n+            let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n+            assert kind == owned;\n+            let is_last_use = bcx.ccx().maps.last_uses.contains_key(src.id);\n+            ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n+                                expr_ty(bcx, src), is_last_use);\n+          }\n+          ast::expr_move(dst, src) {\n+            // FIXME: calculate copy init-ness in typestate.\n+            assert dest == ignore;\n+            let src_r = trans_temp_lval(bcx, src);\n+            let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n+            assert kind == owned;\n+            ret move_val(bcx, DROP_EXISTING, addr, src_r,\n+                         expr_ty(bcx, src));\n+          }\n+          ast::expr_swap(dst, src) {\n+            assert dest == ignore;\n+            let lhs_res = trans_lval(bcx, dst);\n+            assert lhs_res.kind == owned;\n+            let rhs_res = trans_lval(lhs_res.bcx, src);\n+            let t = expr_ty(bcx, src);\n+            let tmp_alloc = alloc_ty(rhs_res.bcx, t);\n+            // Swap through a temporary.\n+            let bcx = move_val(rhs_res.bcx, INIT, tmp_alloc, lhs_res, t);\n+            let bcx = move_val(bcx, INIT, lhs_res.val, rhs_res, t);\n+            ret move_val(bcx, INIT, rhs_res.val,\n+                         lval_owned(bcx, tmp_alloc), t);\n+          }\n+          ast::expr_assign_op(op, dst, src) {\n+            assert dest == ignore;\n+            ret trans_assign_op(bcx, e, op, dst, src);\n+          }\n+          ast::expr_new(pool, alloc_id, val) {\n+            // First, call pool->alloc(sz, align) to get back a void*.  Then,\n+            // cast this memory to the required type and evaluate value into\n+            // it.\n+            let ccx = bcx.ccx();\n+\n+            // Allocate space for the ptr that will be returned from\n+            // `pool.alloc()`:\n+            let ptr_ty = expr_ty(bcx, e);\n+            let ptr_ptr_val = alloc_ty(bcx, ptr_ty);\n+\n+            #debug[\"ptr_ty = %s\", ty_to_str(tcx, ptr_ty)];\n+            #debug[\"ptr_ptr_val = %s\", val_str(ccx.tn, ptr_ptr_val)];\n+\n+            let void_ty = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx),\n+                                           mutbl: ast::m_imm});\n+            let voidval = {\n+                let llvoid_ty = type_of(ccx, void_ty);\n+                PointerCast(bcx, ptr_ptr_val, T_ptr(llvoid_ty))\n+            };\n \n-        #debug[\"dest = %s\", dest_str(ccx, dest)];\n-        let ptr_val = Load(bcx, ptr_ptr_val);\n-        #debug[\"ptr_val = %s\", val_str(ccx.tn, ptr_val)];\n-        let bcx = trans_expr(bcx, val, save_in(ptr_val));\n-        store_in_dest(bcx, ptr_val, dest)\n-      }\n-      _ {\n-        bcx.tcx().sess.span_bug(e.span, \"trans_expr reached \\\n-                                         fall-through case\");\n-      }\n+            #debug[\"voidval = %s\", val_str(ccx.tn, voidval)];\n+\n+            let llval_ty = type_of(ccx, expr_ty(bcx, val));\n+            let args = [llsize_of(ccx, llval_ty), llalign_of(ccx, llval_ty)];\n+            let origin = bcx.ccx().maps.method_map.get(alloc_id);\n+            let bcx = trans_call_inner(\n+                bcx, e.info(), node_id_type(bcx, alloc_id), void_ty,\n+                {|bcx| impl::trans_method_callee(bcx, alloc_id,\n+                                                 pool, origin) },\n+                arg_vals(args),\n+                save_in(voidval));\n+\n+            #debug[\"dest = %s\", dest_str(ccx, dest)];\n+            let ptr_val = Load(bcx, ptr_ptr_val);\n+            #debug[\"ptr_val = %s\", val_str(ccx.tn, ptr_val)];\n+            let bcx = trans_expr(bcx, val, save_in(ptr_val));\n+            store_in_dest(bcx, ptr_val, dest)\n+          }\n+          _ {\n+            bcx.tcx().sess.span_bug(e.span, \"trans_expr reached \\\n+                                             fall-through case\");\n+          }\n+        }\n     }\n }\n \n fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n-    let lv = trans_lval(bcx, e), ccx = bcx.ccx();\n-    let mut {bcx, val, kind} = lv;\n-    let last_use = kind == owned && ccx.maps.last_uses.contains_key(e.id);\n+    let last_uses = bcx.ccx().maps.last_uses;\n     let ty = expr_ty(bcx, e);\n+    let lv = trans_lval(bcx, e);\n+    let last_use = (lv.kind == owned && last_uses.contains_key(e.id));\n+    lval_result_to_dps(lv, ty, last_use, dest)\n+}\n+\n+fn lval_result_to_dps(lv: lval_result, ty: ty::t,\n+                      last_use: bool, dest: dest) -> block {\n+    let mut {bcx, val, kind} = lv;\n+    let ccx = bcx.ccx();\n     alt dest {\n       by_val(cell) {\n         if kind == temporary {\n@@ -3864,16 +3984,20 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n     let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx, bcx = bcx;\n     let is_lpad = leave == none;\n-    let mut done = false;\n     loop {\n+        #debug[\"cleanup_and_leave: leaving %s\", cur.to_str()];\n+\n+        if !bcx.sess().opts.no_asm_comments {\n+            add_comment(bcx, #fmt[\"cleanup_and_leave(%s)\", cur.to_str()]);\n+        }\n+\n         alt cur.kind {\n           block_scope(inf) if inf.cleanups.len() > 0u {\n-            option::iter(vec::find(inf.cleanup_paths,\n-                                             {|cp| cp.target == leave})) {|cp|\n+            for vec::find(inf.cleanup_paths,\n+                          {|cp| cp.target == leave}).each {|cp|\n                 Br(bcx, cp.dest);\n-                done = true;\n+                ret;\n             }\n-            if done { ret; }\n             let sub_cx = sub_block(bcx, \"cleanup\");\n             Br(bcx, sub_cx.llbb);\n             inf.cleanup_paths += [{target: leave, dest: sub_cx.llbb}];"}, {"sha": "7bf86b7068a9aeabcb38c8677d4f30076a639bcc", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -652,7 +652,7 @@ fn add_comment(bcx: block, text: str) {\n     let ccx = bcx.ccx();\n     if (!ccx.sess.opts.no_asm_comments) {\n         let sanitized = str::replace(text, \"$\", \"\");\n-        let comment_text = \"; \" + sanitized;\n+        let comment_text = \"# \" + sanitized;\n         let asm = str::as_c_str(comment_text, {|c|\n             str::as_c_str(\"\", {|e|\n                 count_insn(bcx, \"inlineasm\");"}, {"sha": "2ea0ff1f692e07f244f8977477b8cfb71c1cdef8", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -19,6 +19,7 @@ import lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n import lib::llvm::{True, False, Bool};\n import metadata::{csearch, encoder};\n import ast_map::path;\n+import util::ppaux::ty_to_str;\n \n type namegen = fn@(str) -> str;\n fn new_namegen() -> namegen {\n@@ -227,6 +228,9 @@ fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n \n fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n+    #debug[\"add_clean(%s, %s, %s)\",\n+           cx.to_str(), val_str(cx.ccx().tn, val),\n+           ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean(bind base::drop_ty(_, val, ty),\n@@ -236,6 +240,9 @@ fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n }\n fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n+    #debug[\"add_clean_temp(%s, %s, %s)\",\n+           cx.to_str(), val_str(cx.ccx().tn, val),\n+           ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     fn do_drop(bcx: block, val: ValueRef, ty: ty::t) ->\n        block {\n@@ -253,6 +260,9 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n }\n fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n+    #debug[\"add_clean_temp_mem(%s, %s, %s)\",\n+           cx.to_str(), val_str(cx.ccx().tn, val),\n+           ty_to_str(cx.ccx().tcx, ty)];\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean_temp(val, bind base::drop_ty(_, val, ty),\n@@ -408,10 +418,21 @@ fn block_parent(cx: block) -> block {\n \n // Accessors\n \n-impl bxc_cxs for block {\n+impl bcx_cxs for block {\n     fn ccx() -> @crate_ctxt { self.fcx.ccx }\n     fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n     fn sess() -> session { self.fcx.ccx.sess }\n+\n+    fn to_str() -> str {\n+        alt self.node_info {\n+          some(node_info) {\n+            #fmt[\"[block %d]\", node_info.id]\n+          }\n+          none {\n+            #fmt[\"[block %x]\", ptr::addr_of(*self) as uint]\n+          }\n+        }\n+    }\n }\n \n // LLVM type constructors."}, {"sha": "af6614549321032fdbcb391bbe650f4fd7217bcf", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -864,8 +864,9 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::native_item,\n                                                     some(sub_origins));\n                     {env: self_env(visitor, vp_ty, none) with lval}\n                 };\n-                bcx = trans_call_inner(bcx, none, mth_ty, ty::mk_bool(ccx.tcx),\n-                                       get_lval, arg_vals(args), ignore);\n+                bcx = trans_call_inner(\n+                    bcx, none, mth_ty, ty::mk_bool(ccx.tcx),\n+                    get_lval, arg_vals(args), ignore);\n             }\n           }\n "}, {"sha": "80f6897eca410fa6a7a458dfefc69ce5394a29c0", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -50,7 +50,7 @@ fn emit_calls_to_iface_visit_ty(bcx: block, t: ty::t,\n         let get_lval = {|bcx|\n             impl::trans_iface_callee(bcx, visitor_val, mth_ty, mth_idx)\n         };\n-        trans_call_inner(bcx, mth_ty, ty::mk_bool(tcx),\n+        trans_call_inner(bcx, none, mth_ty, ty::mk_bool(tcx),\n                          get_lval, arg_vals(args), ignore)\n     }\n }"}, {"sha": "68e8e3b14811f15a174d0ea6c1c355962290a140", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags:--borrowck=err\n+// exec-env:RUST_POISON_ON_FREE=1\n+\n+fn borrow(x: &int, f: fn(x: &int)) {\n+    let before = *x;\n+    f(x);\n+    let after = *x;\n+    assert before == after;\n+}\n+\n+fn main() {\n+    let mut x = @{f: ~3};\n+    borrow(x.f) {|b_x|\n+        assert *b_x == 3;\n+        assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n+        x = @{f: ~4};\n+\n+        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        assert *b_x == 3;\n+        assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "f86c9b0c6c125d569df73f083331a442c8383c7b", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb61e3e992aa6539dd178f8b2c2f55aca942b16/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=adb61e3e992aa6539dd178f8b2c2f55aca942b16", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags:--borrowck=err\n+// exec-env:RUST_POISON_ON_FREE=1\n+\n+fn borrow(x: &int, f: fn(x: &int)) {\n+    let before = *x;\n+    f(x);\n+    let after = *x;\n+    assert before == after;\n+}\n+\n+fn main() {\n+    let mut x = ~mut @{f: ~3};\n+    borrow(x.f) {|b_x|\n+        assert *b_x == 3;\n+        assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n+        *x = @{f: ~4};\n+\n+        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        assert *b_x == 3;\n+        assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n+    }\n+}\n\\ No newline at end of file"}]}