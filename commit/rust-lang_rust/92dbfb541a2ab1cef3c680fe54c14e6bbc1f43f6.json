{"sha": "92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZGJmYjU0MWEyYWIxY2VmM2M2ODBmZTU0YzE0ZTZiYmMxZjQzZjY=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-01-17T12:24:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-17T12:24:53Z"}, "message": "Rollup merge of #81064 - Mark-Simulacrum:support-stage1-check, r=jyn514\n\nSupport non-stage0 check\n\nSeems to work locally - a full stage 1 check succeeds, building std (because we can't get away with checking it), and then checking the compiler and other tools. This ran into the problem that a unconditional x.py check in stage 1 *both* checks and builds stage 1 std, and then has to clean up because for some reason the rmeta and rlib artifacts conflict (though I'm not actually entirely sure why, but it doesn't seem worth digging in in too much detail).\n\nIdeally we wouldn't be building and checking like that but it's a minor worry as checking std is pretty fast and you can avoid it if you're aiming for speed by passing the compiler (e.g., compiler/rustc) explicitly.\n\nr? ```@jyn514```", "tree": {"sha": "2dca202114db655411d6e2a29fac543d5eb03ed0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dca202114db655411d6e2a29fac543d5eb03ed0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgBCyVCRBK7hj4Ov3rIwAAdHIIAGQgalh/qQeBoieoEjEbJBwO\n8Z8WKO+jHTl96gz/WU//z/+fKmKiwTfTggusozQxu0MHVvPm8DlQwE8NU8Pusa4Z\nHz1jhaqOPgdzxguTwijQf2KDYfWUf4LVeJnWJcXQGpskgSwH54Mu1is8UPkCKzNA\n26JupYN8dALWQDHD/RRZFOuM+Txgy6vxYhEFr22HhoULXYMMMLE6KOyJ9uhBA7vB\ns9I9TnoL/UxO1rpFJMHgs4W+7dY8xe6tE6kbx+YnCaVjxuk15Mo67RhVoAQ+ejxH\nlA80cww3zlxVHuNcy+/EqUMnFwvecMX3GYKx6QqnFfU32rG/m12hVLAC/RalkF8=\n=Z/HC\n-----END PGP SIGNATURE-----\n", "payload": "tree 2dca202114db655411d6e2a29fac543d5eb03ed0\nparent 8f2ee879654fc601866c2de29f5f328b8c515811\nparent 53989e449d540ea0fbf9468bb133502835e07125\nauthor Mara Bos <m-ou.se@m-ou.se> 1610886293 +0000\ncommitter GitHub <noreply@github.com> 1610886293 +0000\n\nRollup merge of #81064 - Mark-Simulacrum:support-stage1-check, r=jyn514\n\nSupport non-stage0 check\n\nSeems to work locally - a full stage 1 check succeeds, building std (because we can't get away with checking it), and then checking the compiler and other tools. This ran into the problem that a unconditional x.py check in stage 1 *both* checks and builds stage 1 std, and then has to clean up because for some reason the rmeta and rlib artifacts conflict (though I'm not actually entirely sure why, but it doesn't seem worth digging in in too much detail).\n\nIdeally we wouldn't be building and checking like that but it's a minor worry as checking std is pretty fast and you can avoid it if you're aiming for speed by passing the compiler (e.g., compiler/rustc) explicitly.\n\nr? ```@jyn514```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6", "html_url": "https://github.com/rust-lang/rust/commit/92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f2ee879654fc601866c2de29f5f328b8c515811", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f2ee879654fc601866c2de29f5f328b8c515811", "html_url": "https://github.com/rust-lang/rust/commit/8f2ee879654fc601866c2de29f5f328b8c515811"}, {"sha": "53989e449d540ea0fbf9468bb133502835e07125", "url": "https://api.github.com/repos/rust-lang/rust/commits/53989e449d540ea0fbf9468bb133502835e07125", "html_url": "https://github.com/rust-lang/rust/commit/53989e449d540ea0fbf9468bb133502835e07125"}], "stats": {"total": 60, "additions": 39, "deletions": 21}, "files": [{"sha": "c19bb536ce83c25c3397ed1235fd7fb6bc19cbc5", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6", "patch": "@@ -73,7 +73,7 @@ impl Step for Std {\n \n     fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n-        let compiler = builder.compiler(0, builder.config.build);\n+        let compiler = builder.compiler(builder.top_stage, builder.config.build);\n \n         let mut cargo = builder.cargo(\n             compiler,\n@@ -84,7 +84,10 @@ impl Step for Std {\n         );\n         std_cargo(builder, target, compiler.stage, &mut cargo);\n \n-        builder.info(&format!(\"Checking std artifacts ({} -> {})\", &compiler.host, target));\n+        builder.info(&format!(\n+            \"Checking stage{} std artifacts ({} -> {})\",\n+            builder.top_stage, &compiler.host, target\n+        ));\n         run_cargo(\n             builder,\n             cargo,\n@@ -94,9 +97,13 @@ impl Step for Std {\n             true,\n         );\n \n-        let libdir = builder.sysroot_libdir(compiler, target);\n-        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n-        add_to_sysroot(&builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n+        // We skip populating the sysroot in non-zero stage because that'll lead\n+        // to rlib/rmeta conflicts if std gets built during this session.\n+        if compiler.stage == 0 {\n+            let libdir = builder.sysroot_libdir(compiler, target);\n+            let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+            add_to_sysroot(&builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n+        }\n \n         // Then run cargo again, once we've put the rmeta files for the library\n         // crates into the sysroot. This is needed because e.g., core's tests\n@@ -124,8 +131,8 @@ impl Step for Std {\n             }\n \n             builder.info(&format!(\n-                \"Checking std test/bench/example targets ({} -> {})\",\n-                &compiler.host, target\n+                \"Checking stage{} std test/bench/example targets ({} -> {})\",\n+                builder.top_stage, &compiler.host, target\n             ));\n             run_cargo(\n                 builder,\n@@ -163,10 +170,20 @@ impl Step for Rustc {\n     /// the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n+        let compiler = builder.compiler(builder.top_stage, builder.config.build);\n         let target = self.target;\n \n-        builder.ensure(Std { target });\n+        if compiler.stage != 0 {\n+            // If we're not in stage 0, then we won't have a std from the beta\n+            // compiler around. That means we need to make sure there's one in\n+            // the sysroot for the compiler to find. Otherwise, we're going to\n+            // fail when building crates that need to generate code (e.g., build\n+            // scripts and their dependencies).\n+            builder.ensure(crate::compile::Std { target: compiler.host, compiler });\n+            builder.ensure(crate::compile::Std { target, compiler });\n+        } else {\n+            builder.ensure(Std { target });\n+        }\n \n         let mut cargo = builder.cargo(\n             compiler,\n@@ -187,7 +204,10 @@ impl Step for Rustc {\n             cargo.arg(\"-p\").arg(krate.name);\n         }\n \n-        builder.info(&format!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target));\n+        builder.info(&format!(\n+            \"Checking stage{} compiler artifacts ({} -> {})\",\n+            builder.top_stage, &compiler.host, target\n+        ));\n         run_cargo(\n             builder,\n             cargo,\n@@ -225,7 +245,7 @@ impl Step for CodegenBackend {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n+        let compiler = builder.compiler(builder.top_stage, builder.config.build);\n         let target = self.target;\n         let backend = self.backend;\n \n@@ -244,8 +264,8 @@ impl Step for CodegenBackend {\n         rustc_cargo_env(builder, &mut cargo, target);\n \n         builder.info(&format!(\n-            \"Checking {} artifacts ({} -> {})\",\n-            backend, &compiler.host.triple, target.triple\n+            \"Checking stage{} {} artifacts ({} -> {})\",\n+            builder.top_stage, backend, &compiler.host.triple, target.triple\n         ));\n \n         run_cargo(\n@@ -280,7 +300,7 @@ macro_rules! tool_check_step {\n             }\n \n             fn run(self, builder: &Builder<'_>) {\n-                let compiler = builder.compiler(0, builder.config.build);\n+                let compiler = builder.compiler(builder.top_stage, builder.config.build);\n                 let target = self.target;\n \n                 builder.ensure(Rustc { target });\n@@ -301,7 +321,8 @@ macro_rules! tool_check_step {\n                 }\n \n                 builder.info(&format!(\n-                    \"Checking {} artifacts ({} -> {})\",\n+                    \"Checking stage{} {} artifacts ({} -> {})\",\n+                    builder.top_stage,\n                     stringify!($name).to_lowercase(),\n                     &compiler.host.triple,\n                     target.triple"}, {"sha": "ec1308ab82b51ac21fe4fe2f6567b31e1d7541fa", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6", "patch": "@@ -377,6 +377,7 @@ struct Build {\n     configure_args: Option<Vec<String>>,\n     local_rebuild: Option<bool>,\n     print_step_timings: Option<bool>,\n+    check_stage: Option<u32>,\n     doc_stage: Option<u32>,\n     build_stage: Option<u32>,\n     test_stage: Option<u32>,\n@@ -676,6 +677,7 @@ impl Config {\n \n         // See https://github.com/rust-lang/compiler-team/issues/326\n         config.stage = match config.cmd {\n+            Subcommand::Check { .. } => flags.stage.or(build.check_stage).unwrap_or(0),\n             Subcommand::Doc { .. } => flags.stage.or(build.doc_stage).unwrap_or(0),\n             Subcommand::Build { .. } => flags.stage.or(build.build_stage).unwrap_or(1),\n             Subcommand::Test { .. } => flags.stage.or(build.test_stage).unwrap_or(1),\n@@ -685,7 +687,6 @@ impl Config {\n             // These are all bootstrap tools, which don't depend on the compiler.\n             // The stage we pass shouldn't matter, but use 0 just in case.\n             Subcommand::Clean { .. }\n-            | Subcommand::Check { .. }\n             | Subcommand::Clippy { .. }\n             | Subcommand::Fix { .. }\n             | Subcommand::Run { .. }"}, {"sha": "55062e11e029a75b7fee5e020cee491f5ed6e638", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=92dbfb541a2ab1cef3c680fe54c14e6bbc1f43f6", "patch": "@@ -614,14 +614,10 @@ Arguments:\n         };\n \n         if let Subcommand::Check { .. } = &cmd {\n-            if matches.opt_str(\"stage\").is_some() {\n-                println!(\"--stage not supported for x.py check, always treated as stage 0\");\n-                process::exit(1);\n-            }\n             if matches.opt_str(\"keep-stage\").is_some()\n                 || matches.opt_str(\"keep-stage-std\").is_some()\n             {\n-                println!(\"--keep-stage not supported for x.py check, only one stage available\");\n+                println!(\"--keep-stage not yet supported for x.py check\");\n                 process::exit(1);\n             }\n         }"}]}