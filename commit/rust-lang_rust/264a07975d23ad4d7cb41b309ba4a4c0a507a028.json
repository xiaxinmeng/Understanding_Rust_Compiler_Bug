{"sha": "264a07975d23ad4d7cb41b309ba4a4c0a507a028", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NGEwNzk3NWQyM2FkNGQ3Y2I0MWIzMDliYTRhNGMwYTUwN2EwMjg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-10-12T16:41:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-12T16:41:47Z"}, "message": "Merge #2004\n\n2004: Split up infer.rs further r=flodiebold a=flodiebold\n\n - coercion logic goes to `coerce.rs`\r\n - expression inference goes to `expr.rs`\r\n - pattern inference goes to `pat.rs`\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "9025efd452e137874b3b0655e4d5ba12ae44b146", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9025efd452e137874b3b0655e4d5ba12ae44b146"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/264a07975d23ad4d7cb41b309ba4a4c0a507a028", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdogJLCRBK7hj4Ov3rIwAAdHIIADYNYIKgDVXMxGQT3iCR4uyp\nVXqgYN0zFUQY+aDTYF+OD04FzKKNqhfy6ubhLD00fXF0loaYRphWX5mQb4JN3IRZ\nqd5eFF5rmYg8kyo5cbE/ZOmQunN6XgCzrYPP0lMKnwbFjLYY2ip0/Az21rHR3HHK\nLlSHV95mDtxUodzEuNNR9G8N6pnoAdXCrYxVVh5s3odeWoLBW8peT0JxF2ez8z48\nqO/+32lPlAOIbpPRyPH+lwPzBcrk353qSjyh/dYxEUqSRhdcFelOU5Ovw3xgdUMh\nsh5EJIloGrvxlidSVAqzyD7AxeGdg8B9NajPfNtcdMBHsWA9AUJI7olStOrpeAc=\n=E4oY\n-----END PGP SIGNATURE-----\n", "payload": "tree 9025efd452e137874b3b0655e4d5ba12ae44b146\nparent 0896ca04c4e6f88ae268a39472570df4b6d360b0\nparent 2955fbc7e1e49b96565505bf599e950b11d370ac\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1570898507 +0000\ncommitter GitHub <noreply@github.com> 1570898507 +0000\n\nMerge #2004\n\n2004: Split up infer.rs further r=flodiebold a=flodiebold\n\n - coercion logic goes to `coerce.rs`\r\n - expression inference goes to `expr.rs`\r\n - pattern inference goes to `pat.rs`\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/264a07975d23ad4d7cb41b309ba4a4c0a507a028", "html_url": "https://github.com/rust-lang/rust/commit/264a07975d23ad4d7cb41b309ba4a4c0a507a028", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/264a07975d23ad4d7cb41b309ba4a4c0a507a028/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0896ca04c4e6f88ae268a39472570df4b6d360b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0896ca04c4e6f88ae268a39472570df4b6d360b0", "html_url": "https://github.com/rust-lang/rust/commit/0896ca04c4e6f88ae268a39472570df4b6d360b0"}, {"sha": "2955fbc7e1e49b96565505bf599e950b11d370ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/2955fbc7e1e49b96565505bf599e950b11d370ac", "html_url": "https://github.com/rust-lang/rust/commit/2955fbc7e1e49b96565505bf599e950b11d370ac"}], "stats": {"total": 2327, "additions": 1192, "deletions": 1135}, "files": [{"sha": "cb28fc6bc0469174278930c2bb99c8dfca5fe972", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 18, "deletions": 1135, "changes": 1153, "blob_url": "https://github.com/rust-lang/rust/blob/264a07975d23ad4d7cb41b309ba4a4c0a507a028/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/264a07975d23ad4d7cb41b309ba4a4c0a507a028/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=264a07975d23ad4d7cb41b309ba4a4c0a507a028", "patch": "@@ -14,7 +14,6 @@\n //! the `ena` crate, which is extracted from rustc.\n \n use std::borrow::Cow;\n-use std::iter::{repeat, repeat_with};\n use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n@@ -27,33 +26,39 @@ use ra_prof::profile;\n use test_utils::tested_by;\n \n use super::{\n-    autoderef, lower, method_resolution, op, primitive,\n+    lower, primitive,\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, CallableDef, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef,\n-    Ty, TypableDef, TypeCtor, TypeWalk,\n+    ApplicationTy, InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypableDef,\n+    TypeCtor, TypeWalk,\n };\n use crate::{\n     adt::VariantDef,\n     code_model::TypeAlias,\n     db::HirDatabase,\n     diagnostics::DiagnosticSink,\n-    expr::{\n-        self, Array, BinaryOp, BindingAnnotation, Body, Expr, ExprId, Literal, Pat, PatId,\n-        RecordFieldPat, Statement, UnaryOp,\n-    },\n-    generics::{GenericParams, HasGenericParams},\n-    lang_item::LangItemTarget,\n+    expr::{BindingAnnotation, Body, ExprId, PatId},\n     name,\n-    nameres::Namespace,\n-    path::{known, GenericArg, GenericArgs},\n+    path::known,\n     resolve::{Resolver, TypeNs},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     type_ref::{Mutability, TypeRef},\n-    Adt, AssocItem, ConstData, DefWithBody, FnData, Function, HasBody, Name, Path, StructField,\n+    Adt, AssocItem, ConstData, DefWithBody, FnData, Function, HasBody, Path, StructField,\n };\n \n+macro_rules! ty_app {\n+    ($ctor:pat, $param:pat) => {\n+        crate::ty::Ty::Apply(crate::ty::ApplicationTy { ctor: $ctor, parameters: $param })\n+    };\n+    ($ctor:pat) => {\n+        ty_app!($ctor, _)\n+    };\n+}\n+\n mod unify;\n mod path;\n+mod expr;\n+mod pat;\n+mod coerce;\n \n /// The entry point of type inference.\n pub fn infer_query(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n@@ -197,15 +202,6 @@ struct InferenceContext<'a, D: HirDatabase> {\n     coerce_unsized_map: FxHashMap<(TypeCtor, TypeCtor), usize>,\n }\n \n-macro_rules! ty_app {\n-    ($ctor:pat, $param:pat) => {\n-        Ty::Apply(ApplicationTy { ctor: $ctor, parameters: $param })\n-    };\n-    ($ctor:pat) => {\n-        ty_app!($ctor, _)\n-    };\n-}\n-\n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(db: &'a D, body: Arc<Body>, resolver: Resolver) -> Self {\n         InferenceContext {\n@@ -221,45 +217,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n-    fn init_coerce_unsized_map(\n-        db: &'a D,\n-        resolver: &Resolver,\n-    ) -> FxHashMap<(TypeCtor, TypeCtor), usize> {\n-        let krate = resolver.krate().unwrap();\n-        let impls = match db.lang_item(krate, \"coerce_unsized\".into()) {\n-            Some(LangItemTarget::Trait(trait_)) => db.impls_for_trait(krate, trait_),\n-            _ => return FxHashMap::default(),\n-        };\n-\n-        impls\n-            .iter()\n-            .filter_map(|impl_block| {\n-                // `CoerseUnsized` has one generic parameter for the target type.\n-                let trait_ref = impl_block.target_trait_ref(db)?;\n-                let cur_from_ty = trait_ref.substs.0.get(0)?;\n-                let cur_to_ty = trait_ref.substs.0.get(1)?;\n-\n-                match (&cur_from_ty, cur_to_ty) {\n-                    (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => {\n-                        // FIXME: We return the first non-equal bound as the type parameter to coerce to unsized type.\n-                        // This works for smart-pointer-like coercion, which covers all impls from std.\n-                        st1.iter().zip(st2.iter()).enumerate().find_map(|(i, (ty1, ty2))| {\n-                            match (ty1, ty2) {\n-                                (Ty::Param { idx: p1, .. }, Ty::Param { idx: p2, .. })\n-                                    if p1 != p2 =>\n-                                {\n-                                    Some(((*ctor1, *ctor2), i))\n-                                }\n-                                _ => None,\n-                            }\n-                        })\n-                    }\n-                    _ => None,\n-                }\n-            })\n-            .collect()\n-    }\n-\n     fn resolve_all(mut self) -> InferenceResult {\n         // FIXME resolve obligations as well (use Guidance if necessary)\n         let mut result = mem::replace(&mut self.result, InferenceResult::default());\n@@ -595,1080 +552,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n \n-    fn infer_tuple_struct_pat(\n-        &mut self,\n-        path: Option<&Path>,\n-        subpats: &[PatId],\n-        expected: &Ty,\n-        default_bm: BindingMode,\n-    ) -> Ty {\n-        let (ty, def) = self.resolve_variant(path);\n-\n-        self.unify(&ty, expected);\n-\n-        let substs = ty.substs().unwrap_or_else(Substs::empty);\n-\n-        for (i, &subpat) in subpats.iter().enumerate() {\n-            let expected_ty = def\n-                .and_then(|d| d.field(self.db, &Name::new_tuple_field(i)))\n-                .map_or(Ty::Unknown, |field| field.ty(self.db))\n-                .subst(&substs);\n-            let expected_ty = self.normalize_associated_types_in(expected_ty);\n-            self.infer_pat(subpat, &expected_ty, default_bm);\n-        }\n-\n-        ty\n-    }\n-\n-    fn infer_record_pat(\n-        &mut self,\n-        path: Option<&Path>,\n-        subpats: &[RecordFieldPat],\n-        expected: &Ty,\n-        default_bm: BindingMode,\n-        id: PatId,\n-    ) -> Ty {\n-        let (ty, def) = self.resolve_variant(path);\n-        if let Some(variant) = def {\n-            self.write_variant_resolution(id.into(), variant);\n-        }\n-\n-        self.unify(&ty, expected);\n-\n-        let substs = ty.substs().unwrap_or_else(Substs::empty);\n-\n-        for subpat in subpats {\n-            let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n-            let expected_ty =\n-                matching_field.map_or(Ty::Unknown, |field| field.ty(self.db)).subst(&substs);\n-            let expected_ty = self.normalize_associated_types_in(expected_ty);\n-            self.infer_pat(subpat.pat, &expected_ty, default_bm);\n-        }\n-\n-        ty\n-    }\n-\n-    fn infer_pat(&mut self, pat: PatId, mut expected: &Ty, mut default_bm: BindingMode) -> Ty {\n-        let body = Arc::clone(&self.body); // avoid borrow checker problem\n-\n-        let is_non_ref_pat = match &body[pat] {\n-            Pat::Tuple(..)\n-            | Pat::TupleStruct { .. }\n-            | Pat::Record { .. }\n-            | Pat::Range { .. }\n-            | Pat::Slice { .. } => true,\n-            // FIXME: Path/Lit might actually evaluate to ref, but inference is unimplemented.\n-            Pat::Path(..) | Pat::Lit(..) => true,\n-            Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Missing => false,\n-        };\n-        if is_non_ref_pat {\n-            while let Some((inner, mutability)) = expected.as_reference() {\n-                expected = inner;\n-                default_bm = match default_bm {\n-                    BindingMode::Move => BindingMode::Ref(mutability),\n-                    BindingMode::Ref(Mutability::Shared) => BindingMode::Ref(Mutability::Shared),\n-                    BindingMode::Ref(Mutability::Mut) => BindingMode::Ref(mutability),\n-                }\n-            }\n-        } else if let Pat::Ref { .. } = &body[pat] {\n-            tested_by!(match_ergonomics_ref);\n-            // When you encounter a `&pat` pattern, reset to Move.\n-            // This is so that `w` is by value: `let (_, &w) = &(1, &2);`\n-            default_bm = BindingMode::Move;\n-        }\n-\n-        // Lose mutability.\n-        let default_bm = default_bm;\n-        let expected = expected;\n-\n-        let ty = match &body[pat] {\n-            Pat::Tuple(ref args) => {\n-                let expectations = match expected.as_tuple() {\n-                    Some(parameters) => &*parameters.0,\n-                    _ => &[],\n-                };\n-                let expectations_iter = expectations.iter().chain(repeat(&Ty::Unknown));\n-\n-                let inner_tys = args\n-                    .iter()\n-                    .zip(expectations_iter)\n-                    .map(|(&pat, ty)| self.infer_pat(pat, ty, default_bm))\n-                    .collect();\n-\n-                Ty::apply(TypeCtor::Tuple { cardinality: args.len() as u16 }, Substs(inner_tys))\n-            }\n-            Pat::Ref { pat, mutability } => {\n-                let expectation = match expected.as_reference() {\n-                    Some((inner_ty, exp_mut)) => {\n-                        if *mutability != exp_mut {\n-                            // FIXME: emit type error?\n-                        }\n-                        inner_ty\n-                    }\n-                    _ => &Ty::Unknown,\n-                };\n-                let subty = self.infer_pat(*pat, expectation, default_bm);\n-                Ty::apply_one(TypeCtor::Ref(*mutability), subty)\n-            }\n-            Pat::TupleStruct { path: p, args: subpats } => {\n-                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm)\n-            }\n-            Pat::Record { path: p, args: fields } => {\n-                self.infer_record_pat(p.as_ref(), fields, expected, default_bm, pat)\n-            }\n-            Pat::Path(path) => {\n-                // FIXME use correct resolver for the surrounding expression\n-                let resolver = self.resolver.clone();\n-                self.infer_path(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n-            }\n-            Pat::Bind { mode, name: _, subpat } => {\n-                let mode = if mode == &BindingAnnotation::Unannotated {\n-                    default_bm\n-                } else {\n-                    BindingMode::convert(*mode)\n-                };\n-                let inner_ty = if let Some(subpat) = subpat {\n-                    self.infer_pat(*subpat, expected, default_bm)\n-                } else {\n-                    expected.clone()\n-                };\n-                let inner_ty = self.insert_type_vars_shallow(inner_ty);\n-\n-                let bound_ty = match mode {\n-                    BindingMode::Ref(mutability) => {\n-                        Ty::apply_one(TypeCtor::Ref(mutability), inner_ty.clone())\n-                    }\n-                    BindingMode::Move => inner_ty.clone(),\n-                };\n-                let bound_ty = self.resolve_ty_as_possible(&mut vec![], bound_ty);\n-                self.write_pat_ty(pat, bound_ty);\n-                return inner_ty;\n-            }\n-            _ => Ty::Unknown,\n-        };\n-        // use a new type variable if we got Ty::Unknown here\n-        let ty = self.insert_type_vars_shallow(ty);\n-        self.unify(&ty, expected);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n-        self.write_pat_ty(pat, ty.clone());\n-        ty\n-    }\n-\n-    fn substs_for_method_call(\n-        &mut self,\n-        def_generics: Option<Arc<GenericParams>>,\n-        generic_args: Option<&GenericArgs>,\n-        receiver_ty: &Ty,\n-    ) -> Substs {\n-        let (parent_param_count, param_count) =\n-            def_generics.as_ref().map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n-        let mut substs = Vec::with_capacity(parent_param_count + param_count);\n-        // Parent arguments are unknown, except for the receiver type\n-        if let Some(parent_generics) = def_generics.and_then(|p| p.parent_params.clone()) {\n-            for param in &parent_generics.params {\n-                if param.name == name::SELF_TYPE {\n-                    substs.push(receiver_ty.clone());\n-                } else {\n-                    substs.push(Ty::Unknown);\n-                }\n-            }\n-        }\n-        // handle provided type arguments\n-        if let Some(generic_args) = generic_args {\n-            // if args are provided, it should be all of them, but we can't rely on that\n-            for arg in generic_args.args.iter().take(param_count) {\n-                match arg {\n-                    GenericArg::Type(type_ref) => {\n-                        let ty = self.make_ty(type_ref);\n-                        substs.push(ty);\n-                    }\n-                }\n-            }\n-        };\n-        let supplied_params = substs.len();\n-        for _ in supplied_params..parent_param_count + param_count {\n-            substs.push(Ty::Unknown);\n-        }\n-        assert_eq!(substs.len(), parent_param_count + param_count);\n-        Substs(substs.into())\n-    }\n-\n-    fn register_obligations_for_call(&mut self, callable_ty: &Ty) {\n-        if let Ty::Apply(a_ty) = callable_ty {\n-            if let TypeCtor::FnDef(def) = a_ty.ctor {\n-                let generic_predicates = self.db.generic_predicates(def.into());\n-                for predicate in generic_predicates.iter() {\n-                    let predicate = predicate.clone().subst(&a_ty.parameters);\n-                    if let Some(obligation) = Obligation::from_predicate(predicate) {\n-                        self.obligations.push(obligation);\n-                    }\n-                }\n-                // add obligation for trait implementation, if this is a trait method\n-                match def {\n-                    CallableDef::Function(f) => {\n-                        if let Some(trait_) = f.parent_trait(self.db) {\n-                            // construct a TraitDef\n-                            let substs = a_ty.parameters.prefix(\n-                                trait_.generic_params(self.db).count_params_including_parent(),\n-                            );\n-                            self.obligations.push(Obligation::Trait(TraitRef { trait_, substs }));\n-                        }\n-                    }\n-                    CallableDef::Struct(_) | CallableDef::EnumVariant(_) => {}\n-                }\n-            }\n-        }\n-    }\n-\n-    fn infer_method_call(\n-        &mut self,\n-        tgt_expr: ExprId,\n-        receiver: ExprId,\n-        args: &[ExprId],\n-        method_name: &Name,\n-        generic_args: Option<&GenericArgs>,\n-    ) -> Ty {\n-        let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n-        let canonicalized_receiver = self.canonicalizer().canonicalize_ty(receiver_ty.clone());\n-        let resolved = method_resolution::lookup_method(\n-            &canonicalized_receiver.value,\n-            self.db,\n-            method_name,\n-            &self.resolver,\n-        );\n-        let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n-            Some((ty, func)) => {\n-                let ty = canonicalized_receiver.decanonicalize_ty(ty);\n-                self.write_method_resolution(tgt_expr, func);\n-                (\n-                    ty,\n-                    self.db.type_for_def(func.into(), Namespace::Values),\n-                    Some(func.generic_params(self.db)),\n-                )\n-            }\n-            None => (receiver_ty, Ty::Unknown, None),\n-        };\n-        let substs = self.substs_for_method_call(def_generics, generic_args, &derefed_receiver_ty);\n-        let method_ty = method_ty.apply_substs(substs);\n-        let method_ty = self.insert_type_vars(method_ty);\n-        self.register_obligations_for_call(&method_ty);\n-        let (expected_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n-            Some(sig) => {\n-                if !sig.params().is_empty() {\n-                    (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())\n-                } else {\n-                    (Ty::Unknown, Vec::new(), sig.ret().clone())\n-                }\n-            }\n-            None => (Ty::Unknown, Vec::new(), Ty::Unknown),\n-        };\n-        // Apply autoref so the below unification works correctly\n-        // FIXME: return correct autorefs from lookup_method\n-        let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n-            Some((_, mutability)) => Ty::apply_one(TypeCtor::Ref(mutability), derefed_receiver_ty),\n-            _ => derefed_receiver_ty,\n-        };\n-        self.unify(&expected_receiver_ty, &actual_receiver_ty);\n-\n-        self.check_call_arguments(args, &param_tys);\n-        let ret_ty = self.normalize_associated_types_in(ret_ty);\n-        ret_ty\n-    }\n-\n-    /// Infer type of expression with possibly implicit coerce to the expected type.\n-    /// Return the type after possible coercion.\n-    fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n-        let ty = self.infer_expr_inner(expr, &expected);\n-        let ty = if !self.coerce(&ty, &expected.ty) {\n-            self.result\n-                .type_mismatches\n-                .insert(expr, TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() });\n-            // Return actual type when type mismatch.\n-            // This is needed for diagnostic when return type mismatch.\n-            ty\n-        } else if expected.ty == Ty::Unknown {\n-            ty\n-        } else {\n-            expected.ty.clone()\n-        };\n-\n-        self.resolve_ty_as_possible(&mut vec![], ty)\n-    }\n-\n-    /// Merge two types from different branches, with possible implicit coerce.\n-    ///\n-    /// Note that it is only possible that one type are coerced to another.\n-    /// Coercing both types to another least upper bound type is not possible in rustc,\n-    /// which will simply result in \"incompatible types\" error.\n-    fn coerce_merge_branch<'t>(&mut self, ty1: &Ty, ty2: &Ty) -> Ty {\n-        if self.coerce(ty1, ty2) {\n-            ty2.clone()\n-        } else if self.coerce(ty2, ty1) {\n-            ty1.clone()\n-        } else {\n-            tested_by!(coerce_merge_fail_fallback);\n-            // For incompatible types, we use the latter one as result\n-            // to be better recovery for `if` without `else`.\n-            ty2.clone()\n-        }\n-    }\n-\n-    /// Unify two types, but may coerce the first one to the second one\n-    /// using \"implicit coercion rules\" if needed.\n-    ///\n-    /// See: https://doc.rust-lang.org/nomicon/coercions.html\n-    fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n-        let from_ty = self.resolve_ty_shallow(from_ty).into_owned();\n-        let to_ty = self.resolve_ty_shallow(to_ty);\n-        self.coerce_inner(from_ty, &to_ty)\n-    }\n-\n-    fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n-        match (&from_ty, to_ty) {\n-            // Never type will make type variable to fallback to Never Type instead of Unknown.\n-            (ty_app!(TypeCtor::Never), Ty::Infer(InferTy::TypeVar(tv))) => {\n-                let var = self.new_maybe_never_type_var();\n-                self.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n-                return true;\n-            }\n-            (ty_app!(TypeCtor::Never), _) => return true,\n-\n-            // Trivial cases, this should go after `never` check to\n-            // avoid infer result type to be never\n-            _ => {\n-                if self.unify_inner_trivial(&from_ty, &to_ty) {\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        // Pointer weakening and function to pointer\n-        match (&mut from_ty, to_ty) {\n-            // `*mut T`, `&mut T, `&T`` -> `*const T`\n-            // `&mut T` -> `&T`\n-            // `&mut T` -> `*mut T`\n-            (ty_app!(c1@TypeCtor::RawPtr(_)), ty_app!(c2@TypeCtor::RawPtr(Mutability::Shared)))\n-            | (ty_app!(c1@TypeCtor::Ref(_)), ty_app!(c2@TypeCtor::RawPtr(Mutability::Shared)))\n-            | (ty_app!(c1@TypeCtor::Ref(_)), ty_app!(c2@TypeCtor::Ref(Mutability::Shared)))\n-            | (ty_app!(c1@TypeCtor::Ref(Mutability::Mut)), ty_app!(c2@TypeCtor::RawPtr(_))) => {\n-                *c1 = *c2;\n-            }\n-\n-            // Illegal mutablity conversion\n-            (\n-                ty_app!(TypeCtor::RawPtr(Mutability::Shared)),\n-                ty_app!(TypeCtor::RawPtr(Mutability::Mut)),\n-            )\n-            | (\n-                ty_app!(TypeCtor::Ref(Mutability::Shared)),\n-                ty_app!(TypeCtor::Ref(Mutability::Mut)),\n-            ) => return false,\n-\n-            // `{function_type}` -> `fn()`\n-            (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnPtr { .. })) => {\n-                match from_ty.callable_sig(self.db) {\n-                    None => return false,\n-                    Some(sig) => {\n-                        let num_args = sig.params_and_return.len() as u16 - 1;\n-                        from_ty =\n-                            Ty::apply(TypeCtor::FnPtr { num_args }, Substs(sig.params_and_return));\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n-        if let Some(ret) = self.try_coerce_unsized(&from_ty, &to_ty) {\n-            return ret;\n-        }\n-\n-        // Auto Deref if cannot coerce\n-        match (&from_ty, to_ty) {\n-            // FIXME: DerefMut\n-            (ty_app!(TypeCtor::Ref(_), st1), ty_app!(TypeCtor::Ref(_), st2)) => {\n-                self.unify_autoderef_behind_ref(&st1[0], &st2[0])\n-            }\n-\n-            // Otherwise, normal unify\n-            _ => self.unify(&from_ty, to_ty),\n-        }\n-    }\n-\n-    /// Coerce a type using `from_ty: CoerceUnsized<ty_ty>`\n-    ///\n-    /// See: https://doc.rust-lang.org/nightly/std/marker/trait.CoerceUnsized.html\n-    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> Option<bool> {\n-        let (ctor1, st1, ctor2, st2) = match (from_ty, to_ty) {\n-            (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => (ctor1, st1, ctor2, st2),\n-            _ => return None,\n-        };\n-\n-        let coerce_generic_index = *self.coerce_unsized_map.get(&(*ctor1, *ctor2))?;\n-\n-        // Check `Unsize` first\n-        match self.check_unsize_and_coerce(\n-            st1.0.get(coerce_generic_index)?,\n-            st2.0.get(coerce_generic_index)?,\n-            0,\n-        ) {\n-            Some(true) => {}\n-            ret => return ret,\n-        }\n-\n-        let ret = st1\n-            .iter()\n-            .zip(st2.iter())\n-            .enumerate()\n-            .filter(|&(idx, _)| idx != coerce_generic_index)\n-            .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n-\n-        Some(ret)\n-    }\n-\n-    /// Check if `from_ty: Unsize<to_ty>`, and coerce to `to_ty` if it holds.\n-    ///\n-    /// It should not be directly called. It is only used by `try_coerce_unsized`.\n-    ///\n-    /// See: https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html\n-    fn check_unsize_and_coerce(&mut self, from_ty: &Ty, to_ty: &Ty, depth: usize) -> Option<bool> {\n-        if depth > 1000 {\n-            panic!(\"Infinite recursion in coercion\");\n-        }\n-\n-        match (&from_ty, &to_ty) {\n-            // `[T; N]` -> `[T]`\n-            (ty_app!(TypeCtor::Array, st1), ty_app!(TypeCtor::Slice, st2)) => {\n-                Some(self.unify(&st1[0], &st2[0]))\n-            }\n-\n-            // `T` -> `dyn Trait` when `T: Trait`\n-            (_, Ty::Dyn(_)) => {\n-                // FIXME: Check predicates\n-                Some(true)\n-            }\n-\n-            // `(..., T)` -> `(..., U)` when `T: Unsize<U>`\n-            (\n-                ty_app!(TypeCtor::Tuple { cardinality: len1 }, st1),\n-                ty_app!(TypeCtor::Tuple { cardinality: len2 }, st2),\n-            ) => {\n-                if len1 != len2 || *len1 == 0 {\n-                    return None;\n-                }\n-\n-                match self.check_unsize_and_coerce(\n-                    st1.last().unwrap(),\n-                    st2.last().unwrap(),\n-                    depth + 1,\n-                ) {\n-                    Some(true) => {}\n-                    ret => return ret,\n-                }\n-\n-                let ret = st1[..st1.len() - 1]\n-                    .iter()\n-                    .zip(&st2[..st2.len() - 1])\n-                    .all(|(ty1, ty2)| self.unify(ty1, ty2));\n-\n-                Some(ret)\n-            }\n-\n-            // Foo<..., T, ...> is Unsize<Foo<..., U, ...>> if:\n-            // - T: Unsize<U>\n-            // - Foo is a struct\n-            // - Only the last field of Foo has a type involving T\n-            // - T is not part of the type of any other fields\n-            // - Bar<T>: Unsize<Bar<U>>, if the last field of Foo has type Bar<T>\n-            (\n-                ty_app!(TypeCtor::Adt(Adt::Struct(struct1)), st1),\n-                ty_app!(TypeCtor::Adt(Adt::Struct(struct2)), st2),\n-            ) if struct1 == struct2 => {\n-                let fields = struct1.fields(self.db);\n-                let (last_field, prev_fields) = fields.split_last()?;\n-\n-                // Get the generic parameter involved in the last field.\n-                let unsize_generic_index = {\n-                    let mut index = None;\n-                    let mut multiple_param = false;\n-                    last_field.ty(self.db).walk(&mut |ty| match ty {\n-                        &Ty::Param { idx, .. } => {\n-                            if index.is_none() {\n-                                index = Some(idx);\n-                            } else if Some(idx) != index {\n-                                multiple_param = true;\n-                            }\n-                        }\n-                        _ => {}\n-                    });\n-\n-                    if multiple_param {\n-                        return None;\n-                    }\n-                    index?\n-                };\n-\n-                // Check other fields do not involve it.\n-                let mut multiple_used = false;\n-                prev_fields.iter().for_each(|field| {\n-                    field.ty(self.db).walk(&mut |ty| match ty {\n-                        &Ty::Param { idx, .. } if idx == unsize_generic_index => {\n-                            multiple_used = true\n-                        }\n-                        _ => {}\n-                    })\n-                });\n-                if multiple_used {\n-                    return None;\n-                }\n-\n-                let unsize_generic_index = unsize_generic_index as usize;\n-\n-                // Check `Unsize` first\n-                match self.check_unsize_and_coerce(\n-                    st1.get(unsize_generic_index)?,\n-                    st2.get(unsize_generic_index)?,\n-                    depth + 1,\n-                ) {\n-                    Some(true) => {}\n-                    ret => return ret,\n-                }\n-\n-                // Then unify other parameters\n-                let ret = st1\n-                    .iter()\n-                    .zip(st2.iter())\n-                    .enumerate()\n-                    .filter(|&(idx, _)| idx != unsize_generic_index)\n-                    .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n-\n-                Some(ret)\n-            }\n-\n-            _ => None,\n-        }\n-    }\n-\n-    /// Unify `from_ty` to `to_ty` with optional auto Deref\n-    ///\n-    /// Note that the parameters are already stripped the outer reference.\n-    fn unify_autoderef_behind_ref(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n-        let canonicalized = self.canonicalizer().canonicalize_ty(from_ty.clone());\n-        let to_ty = self.resolve_ty_shallow(&to_ty);\n-        // FIXME: Auto DerefMut\n-        for derefed_ty in\n-            autoderef::autoderef(self.db, &self.resolver.clone(), canonicalized.value.clone())\n-        {\n-            let derefed_ty = canonicalized.decanonicalize_ty(derefed_ty.value);\n-            match (&*self.resolve_ty_shallow(&derefed_ty), &*to_ty) {\n-                // Stop when constructor matches.\n-                (ty_app!(from_ctor, st1), ty_app!(to_ctor, st2)) if from_ctor == to_ctor => {\n-                    // It will not recurse to `coerce`.\n-                    return self.unify_substs(st1, st2, 0);\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n-        let ty = self.infer_expr_inner(tgt_expr, expected);\n-        let could_unify = self.unify(&ty, &expected.ty);\n-        if !could_unify {\n-            self.result.type_mismatches.insert(\n-                tgt_expr,\n-                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n-            );\n-        }\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n-        ty\n-    }\n-\n-    fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n-        let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        let ty = match &body[tgt_expr] {\n-            Expr::Missing => Ty::Unknown,\n-            Expr::If { condition, then_branch, else_branch } => {\n-                // if let is desugared to match, so this is always simple if\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n-\n-                let then_ty = self.infer_expr_inner(*then_branch, &expected);\n-                let else_ty = match else_branch {\n-                    Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n-                    None => Ty::unit(),\n-                };\n-\n-                self.coerce_merge_branch(&then_ty, &else_ty)\n-            }\n-            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n-            Expr::TryBlock { body } => {\n-                let _inner = self.infer_expr(*body, expected);\n-                // FIXME should be std::result::Result<{inner}, _>\n-                Ty::Unknown\n-            }\n-            Expr::Loop { body } => {\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n-                // FIXME handle break with value\n-                Ty::simple(TypeCtor::Never)\n-            }\n-            Expr::While { condition, body } => {\n-                // while let is desugared to a match loop, so this is always simple while\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n-                Ty::unit()\n-            }\n-            Expr::For { iterable, body, pat } => {\n-                let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n-\n-                let pat_ty = match self.resolve_into_iter_item() {\n-                    Some(into_iter_item_alias) => {\n-                        let pat_ty = self.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: pat_ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: into_iter_item_alias,\n-                                parameters: Substs::single(iterable_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], pat_ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n-\n-                self.infer_pat(*pat, &pat_ty, BindingMode::default());\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n-                Ty::unit()\n-            }\n-            Expr::Lambda { body, args, arg_types } => {\n-                assert_eq!(args.len(), arg_types.len());\n-\n-                let mut sig_tys = Vec::new();\n-\n-                for (arg_pat, arg_type) in args.iter().zip(arg_types.iter()) {\n-                    let expected = if let Some(type_ref) = arg_type {\n-                        self.make_ty(type_ref)\n-                    } else {\n-                        Ty::Unknown\n-                    };\n-                    let arg_ty = self.infer_pat(*arg_pat, &expected, BindingMode::default());\n-                    sig_tys.push(arg_ty);\n-                }\n-\n-                // add return type\n-                let ret_ty = self.new_type_var();\n-                sig_tys.push(ret_ty.clone());\n-                let sig_ty = Ty::apply(\n-                    TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n-                    Substs(sig_tys.into()),\n-                );\n-                let closure_ty = Ty::apply_one(\n-                    TypeCtor::Closure { def: self.body.owner(), expr: tgt_expr },\n-                    sig_ty,\n-                );\n-\n-                // Eagerly try to relate the closure type with the expected\n-                // type, otherwise we often won't have enough information to\n-                // infer the body.\n-                self.coerce(&closure_ty, &expected.ty);\n-\n-                self.infer_expr(*body, &Expectation::has_type(ret_ty));\n-                closure_ty\n-            }\n-            Expr::Call { callee, args } => {\n-                let callee_ty = self.infer_expr(*callee, &Expectation::none());\n-                let (param_tys, ret_ty) = match callee_ty.callable_sig(self.db) {\n-                    Some(sig) => (sig.params().to_vec(), sig.ret().clone()),\n-                    None => {\n-                        // Not callable\n-                        // FIXME: report an error\n-                        (Vec::new(), Ty::Unknown)\n-                    }\n-                };\n-                self.register_obligations_for_call(&callee_ty);\n-                self.check_call_arguments(args, &param_tys);\n-                let ret_ty = self.normalize_associated_types_in(ret_ty);\n-                ret_ty\n-            }\n-            Expr::MethodCall { receiver, args, method_name, generic_args } => self\n-                .infer_method_call(tgt_expr, *receiver, &args, &method_name, generic_args.as_ref()),\n-            Expr::Match { expr, arms } => {\n-                let input_ty = self.infer_expr(*expr, &Expectation::none());\n-\n-                let mut result_ty = self.new_maybe_never_type_var();\n-\n-                for arm in arms {\n-                    for &pat in &arm.pats {\n-                        let _pat_ty = self.infer_pat(pat, &input_ty, BindingMode::default());\n-                    }\n-                    if let Some(guard_expr) = arm.guard {\n-                        self.infer_expr(\n-                            guard_expr,\n-                            &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n-                        );\n-                    }\n-\n-                    let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n-                    result_ty = self.coerce_merge_branch(&result_ty, &arm_ty);\n-                }\n-\n-                result_ty\n-            }\n-            Expr::Path(p) => {\n-                // FIXME this could be more efficient...\n-                let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n-                self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n-            }\n-            Expr::Continue => Ty::simple(TypeCtor::Never),\n-            Expr::Break { expr } => {\n-                if let Some(expr) = expr {\n-                    // FIXME handle break with value\n-                    self.infer_expr(*expr, &Expectation::none());\n-                }\n-                Ty::simple(TypeCtor::Never)\n-            }\n-            Expr::Return { expr } => {\n-                if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()));\n-                }\n-                Ty::simple(TypeCtor::Never)\n-            }\n-            Expr::RecordLit { path, fields, spread } => {\n-                let (ty, def_id) = self.resolve_variant(path.as_ref());\n-                if let Some(variant) = def_id {\n-                    self.write_variant_resolution(tgt_expr.into(), variant);\n-                }\n-\n-                self.unify(&ty, &expected.ty);\n-\n-                let substs = ty.substs().unwrap_or_else(Substs::empty);\n-                for (field_idx, field) in fields.iter().enumerate() {\n-                    let field_ty = def_id\n-                        .and_then(|it| match it.field(self.db, &field.name) {\n-                            Some(field) => Some(field),\n-                            None => {\n-                                self.push_diagnostic(InferenceDiagnostic::NoSuchField {\n-                                    expr: tgt_expr,\n-                                    field: field_idx,\n-                                });\n-                                None\n-                            }\n-                        })\n-                        .map_or(Ty::Unknown, |field| field.ty(self.db))\n-                        .subst(&substs);\n-                    self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n-                }\n-                if let Some(expr) = spread {\n-                    self.infer_expr(*expr, &Expectation::has_type(ty.clone()));\n-                }\n-                ty\n-            }\n-            Expr::Field { expr, name } => {\n-                let receiver_ty = self.infer_expr(*expr, &Expectation::none());\n-                let canonicalized = self.canonicalizer().canonicalize_ty(receiver_ty);\n-                let ty = autoderef::autoderef(\n-                    self.db,\n-                    &self.resolver.clone(),\n-                    canonicalized.value.clone(),\n-                )\n-                .find_map(|derefed_ty| match canonicalized.decanonicalize_ty(derefed_ty.value) {\n-                    Ty::Apply(a_ty) => match a_ty.ctor {\n-                        TypeCtor::Tuple { .. } => name\n-                            .as_tuple_index()\n-                            .and_then(|idx| a_ty.parameters.0.get(idx).cloned()),\n-                        TypeCtor::Adt(Adt::Struct(s)) => s.field(self.db, name).map(|field| {\n-                            self.write_field_resolution(tgt_expr, field);\n-                            field.ty(self.db).subst(&a_ty.parameters)\n-                        }),\n-                        _ => None,\n-                    },\n-                    _ => None,\n-                })\n-                .unwrap_or(Ty::Unknown);\n-                let ty = self.insert_type_vars(ty);\n-                self.normalize_associated_types_in(ty)\n-            }\n-            Expr::Await { expr } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                let ty = match self.resolve_future_future_output() {\n-                    Some(future_future_output_alias) => {\n-                        let ty = self.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: future_future_output_alias,\n-                                parameters: Substs::single(inner_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n-                ty\n-            }\n-            Expr::Try { expr } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                let ty = match self.resolve_ops_try_ok() {\n-                    Some(ops_try_ok_alias) => {\n-                        let ty = self.new_type_var();\n-                        let projection = ProjectionPredicate {\n-                            ty: ty.clone(),\n-                            projection_ty: ProjectionTy {\n-                                associated_ty: ops_try_ok_alias,\n-                                parameters: Substs::single(inner_ty),\n-                            },\n-                        };\n-                        self.obligations.push(Obligation::Projection(projection));\n-                        self.resolve_ty_as_possible(&mut vec![], ty)\n-                    }\n-                    None => Ty::Unknown,\n-                };\n-                ty\n-            }\n-            Expr::Cast { expr, type_ref } => {\n-                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                let cast_ty = self.make_ty(type_ref);\n-                // FIXME check the cast...\n-                cast_ty\n-            }\n-            Expr::Ref { expr, mutability } => {\n-                let expectation =\n-                    if let Some((exp_inner, exp_mutability)) = &expected.ty.as_reference() {\n-                        if *exp_mutability == Mutability::Mut && *mutability == Mutability::Shared {\n-                            // FIXME: throw type error - expected mut reference but found shared ref,\n-                            // which cannot be coerced\n-                        }\n-                        Expectation::has_type(Ty::clone(exp_inner))\n-                    } else {\n-                        Expectation::none()\n-                    };\n-                // FIXME reference coercions etc.\n-                let inner_ty = self.infer_expr(*expr, &expectation);\n-                Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n-            }\n-            Expr::Box { expr } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                if let Some(box_) = self.resolve_boxed_box() {\n-                    Ty::apply_one(TypeCtor::Adt(box_), inner_ty)\n-                } else {\n-                    Ty::Unknown\n-                }\n-            }\n-            Expr::UnaryOp { expr, op } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                match op {\n-                    UnaryOp::Deref => {\n-                        let canonicalized = self.canonicalizer().canonicalize_ty(inner_ty);\n-                        if let Some(derefed_ty) =\n-                            autoderef::deref(self.db, &self.resolver, &canonicalized.value)\n-                        {\n-                            canonicalized.decanonicalize_ty(derefed_ty.value)\n-                        } else {\n-                            Ty::Unknown\n-                        }\n-                    }\n-                    UnaryOp::Neg => {\n-                        match &inner_ty {\n-                            Ty::Apply(a_ty) => match a_ty.ctor {\n-                                TypeCtor::Int(primitive::UncertainIntTy::Unknown)\n-                                | TypeCtor::Int(primitive::UncertainIntTy::Known(\n-                                    primitive::IntTy {\n-                                        signedness: primitive::Signedness::Signed,\n-                                        ..\n-                                    },\n-                                ))\n-                                | TypeCtor::Float(..) => inner_ty,\n-                                _ => Ty::Unknown,\n-                            },\n-                            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => {\n-                                inner_ty\n-                            }\n-                            // FIXME: resolve ops::Neg trait\n-                            _ => Ty::Unknown,\n-                        }\n-                    }\n-                    UnaryOp::Not => {\n-                        match &inner_ty {\n-                            Ty::Apply(a_ty) => match a_ty.ctor {\n-                                TypeCtor::Bool | TypeCtor::Int(_) => inner_ty,\n-                                _ => Ty::Unknown,\n-                            },\n-                            Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n-                            // FIXME: resolve ops::Not trait for inner_ty\n-                            _ => Ty::Unknown,\n-                        }\n-                    }\n-                }\n-            }\n-            Expr::BinaryOp { lhs, rhs, op } => match op {\n-                Some(op) => {\n-                    let lhs_expectation = match op {\n-                        BinaryOp::LogicOp(..) => Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n-                        _ => Expectation::none(),\n-                    };\n-                    let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n-                    // FIXME: find implementation of trait corresponding to operation\n-                    // symbol and resolve associated `Output` type\n-                    let rhs_expectation = op::binary_op_rhs_expectation(*op, lhs_ty);\n-                    let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation));\n-\n-                    // FIXME: similar as above, return ty is often associated trait type\n-                    op::binary_op_return_ty(*op, rhs_ty)\n-                }\n-                _ => Ty::Unknown,\n-            },\n-            Expr::Index { base, index } => {\n-                let _base_ty = self.infer_expr(*base, &Expectation::none());\n-                let _index_ty = self.infer_expr(*index, &Expectation::none());\n-                // FIXME: use `std::ops::Index::Output` to figure out the real return type\n-                Ty::Unknown\n-            }\n-            Expr::Tuple { exprs } => {\n-                let mut tys = match &expected.ty {\n-                    ty_app!(TypeCtor::Tuple { .. }, st) => st\n-                        .iter()\n-                        .cloned()\n-                        .chain(repeat_with(|| self.new_type_var()))\n-                        .take(exprs.len())\n-                        .collect::<Vec<_>>(),\n-                    _ => (0..exprs.len()).map(|_| self.new_type_var()).collect(),\n-                };\n-\n-                for (expr, ty) in exprs.iter().zip(tys.iter_mut()) {\n-                    self.infer_expr_coerce(*expr, &Expectation::has_type(ty.clone()));\n-                }\n-\n-                Ty::apply(TypeCtor::Tuple { cardinality: tys.len() as u16 }, Substs(tys.into()))\n-            }\n-            Expr::Array(array) => {\n-                let elem_ty = match &expected.ty {\n-                    ty_app!(TypeCtor::Array, st) | ty_app!(TypeCtor::Slice, st) => {\n-                        st.as_single().clone()\n-                    }\n-                    _ => self.new_type_var(),\n-                };\n-\n-                match array {\n-                    Array::ElementList(items) => {\n-                        for expr in items.iter() {\n-                            self.infer_expr_coerce(*expr, &Expectation::has_type(elem_ty.clone()));\n-                        }\n-                    }\n-                    Array::Repeat { initializer, repeat } => {\n-                        self.infer_expr_coerce(\n-                            *initializer,\n-                            &Expectation::has_type(elem_ty.clone()),\n-                        );\n-                        self.infer_expr(\n-                            *repeat,\n-                            &Expectation::has_type(Ty::simple(TypeCtor::Int(\n-                                primitive::UncertainIntTy::Known(primitive::IntTy::usize()),\n-                            ))),\n-                        );\n-                    }\n-                }\n-\n-                Ty::apply_one(TypeCtor::Array, elem_ty)\n-            }\n-            Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => Ty::simple(TypeCtor::Bool),\n-                Literal::String(..) => {\n-                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), Ty::simple(TypeCtor::Str))\n-                }\n-                Literal::ByteString(..) => {\n-                    let byte_type = Ty::simple(TypeCtor::Int(primitive::UncertainIntTy::Known(\n-                        primitive::IntTy::u8(),\n-                    )));\n-                    let slice_type = Ty::apply_one(TypeCtor::Slice, byte_type);\n-                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), slice_type)\n-                }\n-                Literal::Char(..) => Ty::simple(TypeCtor::Char),\n-                Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int(*ty)),\n-                Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float(*ty)),\n-            },\n-        };\n-        // use a new type variable if we got Ty::Unknown here\n-        let ty = self.insert_type_vars_shallow(ty);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n-        self.write_expr_ty(tgt_expr, ty.clone());\n-        ty\n-    }\n-\n-    fn infer_block(\n-        &mut self,\n-        statements: &[Statement],\n-        tail: Option<ExprId>,\n-        expected: &Expectation,\n-    ) -> Ty {\n-        let mut diverges = false;\n-        for stmt in statements {\n-            match stmt {\n-                Statement::Let { pat, type_ref, initializer } => {\n-                    let decl_ty =\n-                        type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(Ty::Unknown);\n-\n-                    // Always use the declared type when specified\n-                    let mut ty = decl_ty.clone();\n-\n-                    if let Some(expr) = initializer {\n-                        let actual_ty =\n-                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()));\n-                        if decl_ty == Ty::Unknown {\n-                            ty = actual_ty;\n-                        }\n-                    }\n-\n-                    let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n-                    self.infer_pat(*pat, &ty, BindingMode::default());\n-                }\n-                Statement::Expr(expr) => {\n-                    if let ty_app!(TypeCtor::Never) = self.infer_expr(*expr, &Expectation::none()) {\n-                        diverges = true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        let ty = if let Some(expr) = tail {\n-            self.infer_expr_coerce(expr, expected)\n-        } else {\n-            self.coerce(&Ty::unit(), &expected.ty);\n-            Ty::unit()\n-        };\n-        if diverges {\n-            Ty::simple(TypeCtor::Never)\n-        } else {\n-            ty\n-        }\n-    }\n-\n-    fn check_call_arguments(&mut self, args: &[ExprId], param_tys: &[Ty]) {\n-        // Quoting https://github.com/rust-lang/rust/blob/6ef275e6c3cb1384ec78128eceeb4963ff788dca/src/librustc_typeck/check/mod.rs#L3325 --\n-        // We do this in a pretty awful way: first we type-check any arguments\n-        // that are not closures, then we type-check the closures. This is so\n-        // that we have more information about the types of arguments when we\n-        // type-check the functions. This isn't really the right way to do this.\n-        for &check_closures in &[false, true] {\n-            let param_iter = param_tys.iter().cloned().chain(repeat(Ty::Unknown));\n-            for (&arg, param_ty) in args.iter().zip(param_iter) {\n-                let is_closure = match &self.body[arg] {\n-                    Expr::Lambda { .. } => true,\n-                    _ => false,\n-                };\n-\n-                if is_closure != check_closures {\n-                    continue;\n-                }\n-\n-                let param_ty = self.normalize_associated_types_in(param_ty);\n-                self.infer_expr_coerce(arg, &Expectation::has_type(param_ty.clone()));\n-            }\n-        }\n-    }\n-\n     fn collect_const(&mut self, data: &ConstData) {\n         self.return_ty = self.make_ty(data.type_ref());\n     }"}, {"sha": "0429a986640ec7fa49c55b462e54d976bbedb08e", "filename": "crates/ra_hir/src/ty/infer/coerce.rs", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/264a07975d23ad4d7cb41b309ba4a4c0a507a028/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/264a07975d23ad4d7cb41b309ba4a4c0a507a028/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fcoerce.rs?ref=264a07975d23ad4d7cb41b309ba4a4c0a507a028", "patch": "@@ -0,0 +1,336 @@\n+//! Coercion logic. Coercions are certain type conversions that can implicitly\n+//! happen in certain places, e.g. weakening `&mut` to `&` or deref coercions\n+//! like going from `&Vec<T>` to `&[T]`.\n+//!\n+//! See: https://doc.rust-lang.org/nomicon/coercions.html\n+\n+use rustc_hash::FxHashMap;\n+\n+use test_utils::tested_by;\n+\n+use super::{InferTy, InferenceContext, TypeVarValue};\n+use crate::{\n+    db::HirDatabase,\n+    lang_item::LangItemTarget,\n+    resolve::Resolver,\n+    ty::{autoderef, Substs, Ty, TypeCtor, TypeWalk},\n+    type_ref::Mutability,\n+    Adt,\n+};\n+\n+impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+    /// Unify two types, but may coerce the first one to the second one\n+    /// using \"implicit coercion rules\" if needed.\n+    pub(super) fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n+        let from_ty = self.resolve_ty_shallow(from_ty).into_owned();\n+        let to_ty = self.resolve_ty_shallow(to_ty);\n+        self.coerce_inner(from_ty, &to_ty)\n+    }\n+\n+    /// Merge two types from different branches, with possible implicit coerce.\n+    ///\n+    /// Note that it is only possible that one type are coerced to another.\n+    /// Coercing both types to another least upper bound type is not possible in rustc,\n+    /// which will simply result in \"incompatible types\" error.\n+    pub(super) fn coerce_merge_branch<'t>(&mut self, ty1: &Ty, ty2: &Ty) -> Ty {\n+        if self.coerce(ty1, ty2) {\n+            ty2.clone()\n+        } else if self.coerce(ty2, ty1) {\n+            ty1.clone()\n+        } else {\n+            tested_by!(coerce_merge_fail_fallback);\n+            // For incompatible types, we use the latter one as result\n+            // to be better recovery for `if` without `else`.\n+            ty2.clone()\n+        }\n+    }\n+\n+    pub(super) fn init_coerce_unsized_map(\n+        db: &'a D,\n+        resolver: &Resolver,\n+    ) -> FxHashMap<(TypeCtor, TypeCtor), usize> {\n+        let krate = resolver.krate().unwrap();\n+        let impls = match db.lang_item(krate, \"coerce_unsized\".into()) {\n+            Some(LangItemTarget::Trait(trait_)) => db.impls_for_trait(krate, trait_),\n+            _ => return FxHashMap::default(),\n+        };\n+\n+        impls\n+            .iter()\n+            .filter_map(|impl_block| {\n+                // `CoerseUnsized` has one generic parameter for the target type.\n+                let trait_ref = impl_block.target_trait_ref(db)?;\n+                let cur_from_ty = trait_ref.substs.0.get(0)?;\n+                let cur_to_ty = trait_ref.substs.0.get(1)?;\n+\n+                match (&cur_from_ty, cur_to_ty) {\n+                    (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => {\n+                        // FIXME: We return the first non-equal bound as the type parameter to coerce to unsized type.\n+                        // This works for smart-pointer-like coercion, which covers all impls from std.\n+                        st1.iter().zip(st2.iter()).enumerate().find_map(|(i, (ty1, ty2))| {\n+                            match (ty1, ty2) {\n+                                (Ty::Param { idx: p1, .. }, Ty::Param { idx: p2, .. })\n+                                    if p1 != p2 =>\n+                                {\n+                                    Some(((*ctor1, *ctor2), i))\n+                                }\n+                                _ => None,\n+                            }\n+                        })\n+                    }\n+                    _ => None,\n+                }\n+            })\n+            .collect()\n+    }\n+\n+    fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n+        match (&from_ty, to_ty) {\n+            // Never type will make type variable to fallback to Never Type instead of Unknown.\n+            (ty_app!(TypeCtor::Never), Ty::Infer(InferTy::TypeVar(tv))) => {\n+                let var = self.new_maybe_never_type_var();\n+                self.var_unification_table.union_value(*tv, TypeVarValue::Known(var));\n+                return true;\n+            }\n+            (ty_app!(TypeCtor::Never), _) => return true,\n+\n+            // Trivial cases, this should go after `never` check to\n+            // avoid infer result type to be never\n+            _ => {\n+                if self.unify_inner_trivial(&from_ty, &to_ty) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        // Pointer weakening and function to pointer\n+        match (&mut from_ty, to_ty) {\n+            // `*mut T`, `&mut T, `&T`` -> `*const T`\n+            // `&mut T` -> `&T`\n+            // `&mut T` -> `*mut T`\n+            (ty_app!(c1@TypeCtor::RawPtr(_)), ty_app!(c2@TypeCtor::RawPtr(Mutability::Shared)))\n+            | (ty_app!(c1@TypeCtor::Ref(_)), ty_app!(c2@TypeCtor::RawPtr(Mutability::Shared)))\n+            | (ty_app!(c1@TypeCtor::Ref(_)), ty_app!(c2@TypeCtor::Ref(Mutability::Shared)))\n+            | (ty_app!(c1@TypeCtor::Ref(Mutability::Mut)), ty_app!(c2@TypeCtor::RawPtr(_))) => {\n+                *c1 = *c2;\n+            }\n+\n+            // Illegal mutablity conversion\n+            (\n+                ty_app!(TypeCtor::RawPtr(Mutability::Shared)),\n+                ty_app!(TypeCtor::RawPtr(Mutability::Mut)),\n+            )\n+            | (\n+                ty_app!(TypeCtor::Ref(Mutability::Shared)),\n+                ty_app!(TypeCtor::Ref(Mutability::Mut)),\n+            ) => return false,\n+\n+            // `{function_type}` -> `fn()`\n+            (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnPtr { .. })) => {\n+                match from_ty.callable_sig(self.db) {\n+                    None => return false,\n+                    Some(sig) => {\n+                        let num_args = sig.params_and_return.len() as u16 - 1;\n+                        from_ty =\n+                            Ty::apply(TypeCtor::FnPtr { num_args }, Substs(sig.params_and_return));\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        if let Some(ret) = self.try_coerce_unsized(&from_ty, &to_ty) {\n+            return ret;\n+        }\n+\n+        // Auto Deref if cannot coerce\n+        match (&from_ty, to_ty) {\n+            // FIXME: DerefMut\n+            (ty_app!(TypeCtor::Ref(_), st1), ty_app!(TypeCtor::Ref(_), st2)) => {\n+                self.unify_autoderef_behind_ref(&st1[0], &st2[0])\n+            }\n+\n+            // Otherwise, normal unify\n+            _ => self.unify(&from_ty, to_ty),\n+        }\n+    }\n+\n+    /// Coerce a type using `from_ty: CoerceUnsized<ty_ty>`\n+    ///\n+    /// See: https://doc.rust-lang.org/nightly/std/marker/trait.CoerceUnsized.html\n+    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty) -> Option<bool> {\n+        let (ctor1, st1, ctor2, st2) = match (from_ty, to_ty) {\n+            (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) => (ctor1, st1, ctor2, st2),\n+            _ => return None,\n+        };\n+\n+        let coerce_generic_index = *self.coerce_unsized_map.get(&(*ctor1, *ctor2))?;\n+\n+        // Check `Unsize` first\n+        match self.check_unsize_and_coerce(\n+            st1.0.get(coerce_generic_index)?,\n+            st2.0.get(coerce_generic_index)?,\n+            0,\n+        ) {\n+            Some(true) => {}\n+            ret => return ret,\n+        }\n+\n+        let ret = st1\n+            .iter()\n+            .zip(st2.iter())\n+            .enumerate()\n+            .filter(|&(idx, _)| idx != coerce_generic_index)\n+            .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n+\n+        Some(ret)\n+    }\n+\n+    /// Check if `from_ty: Unsize<to_ty>`, and coerce to `to_ty` if it holds.\n+    ///\n+    /// It should not be directly called. It is only used by `try_coerce_unsized`.\n+    ///\n+    /// See: https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html\n+    fn check_unsize_and_coerce(&mut self, from_ty: &Ty, to_ty: &Ty, depth: usize) -> Option<bool> {\n+        if depth > 1000 {\n+            panic!(\"Infinite recursion in coercion\");\n+        }\n+\n+        match (&from_ty, &to_ty) {\n+            // `[T; N]` -> `[T]`\n+            (ty_app!(TypeCtor::Array, st1), ty_app!(TypeCtor::Slice, st2)) => {\n+                Some(self.unify(&st1[0], &st2[0]))\n+            }\n+\n+            // `T` -> `dyn Trait` when `T: Trait`\n+            (_, Ty::Dyn(_)) => {\n+                // FIXME: Check predicates\n+                Some(true)\n+            }\n+\n+            // `(..., T)` -> `(..., U)` when `T: Unsize<U>`\n+            (\n+                ty_app!(TypeCtor::Tuple { cardinality: len1 }, st1),\n+                ty_app!(TypeCtor::Tuple { cardinality: len2 }, st2),\n+            ) => {\n+                if len1 != len2 || *len1 == 0 {\n+                    return None;\n+                }\n+\n+                match self.check_unsize_and_coerce(\n+                    st1.last().unwrap(),\n+                    st2.last().unwrap(),\n+                    depth + 1,\n+                ) {\n+                    Some(true) => {}\n+                    ret => return ret,\n+                }\n+\n+                let ret = st1[..st1.len() - 1]\n+                    .iter()\n+                    .zip(&st2[..st2.len() - 1])\n+                    .all(|(ty1, ty2)| self.unify(ty1, ty2));\n+\n+                Some(ret)\n+            }\n+\n+            // Foo<..., T, ...> is Unsize<Foo<..., U, ...>> if:\n+            // - T: Unsize<U>\n+            // - Foo is a struct\n+            // - Only the last field of Foo has a type involving T\n+            // - T is not part of the type of any other fields\n+            // - Bar<T>: Unsize<Bar<U>>, if the last field of Foo has type Bar<T>\n+            (\n+                ty_app!(TypeCtor::Adt(Adt::Struct(struct1)), st1),\n+                ty_app!(TypeCtor::Adt(Adt::Struct(struct2)), st2),\n+            ) if struct1 == struct2 => {\n+                let fields = struct1.fields(self.db);\n+                let (last_field, prev_fields) = fields.split_last()?;\n+\n+                // Get the generic parameter involved in the last field.\n+                let unsize_generic_index = {\n+                    let mut index = None;\n+                    let mut multiple_param = false;\n+                    last_field.ty(self.db).walk(&mut |ty| match ty {\n+                        &Ty::Param { idx, .. } => {\n+                            if index.is_none() {\n+                                index = Some(idx);\n+                            } else if Some(idx) != index {\n+                                multiple_param = true;\n+                            }\n+                        }\n+                        _ => {}\n+                    });\n+\n+                    if multiple_param {\n+                        return None;\n+                    }\n+                    index?\n+                };\n+\n+                // Check other fields do not involve it.\n+                let mut multiple_used = false;\n+                prev_fields.iter().for_each(|field| {\n+                    field.ty(self.db).walk(&mut |ty| match ty {\n+                        &Ty::Param { idx, .. } if idx == unsize_generic_index => {\n+                            multiple_used = true\n+                        }\n+                        _ => {}\n+                    })\n+                });\n+                if multiple_used {\n+                    return None;\n+                }\n+\n+                let unsize_generic_index = unsize_generic_index as usize;\n+\n+                // Check `Unsize` first\n+                match self.check_unsize_and_coerce(\n+                    st1.get(unsize_generic_index)?,\n+                    st2.get(unsize_generic_index)?,\n+                    depth + 1,\n+                ) {\n+                    Some(true) => {}\n+                    ret => return ret,\n+                }\n+\n+                // Then unify other parameters\n+                let ret = st1\n+                    .iter()\n+                    .zip(st2.iter())\n+                    .enumerate()\n+                    .filter(|&(idx, _)| idx != unsize_generic_index)\n+                    .all(|(_, (ty1, ty2))| self.unify(ty1, ty2));\n+\n+                Some(ret)\n+            }\n+\n+            _ => None,\n+        }\n+    }\n+\n+    /// Unify `from_ty` to `to_ty` with optional auto Deref\n+    ///\n+    /// Note that the parameters are already stripped the outer reference.\n+    fn unify_autoderef_behind_ref(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n+        let canonicalized = self.canonicalizer().canonicalize_ty(from_ty.clone());\n+        let to_ty = self.resolve_ty_shallow(&to_ty);\n+        // FIXME: Auto DerefMut\n+        for derefed_ty in\n+            autoderef::autoderef(self.db, &self.resolver.clone(), canonicalized.value.clone())\n+        {\n+            let derefed_ty = canonicalized.decanonicalize_ty(derefed_ty.value);\n+            match (&*self.resolve_ty_shallow(&derefed_ty), &*to_ty) {\n+                // Stop when constructor matches.\n+                (ty_app!(from_ctor, st1), ty_app!(to_ctor, st2)) if from_ctor == to_ctor => {\n+                    // It will not recurse to `coerce`.\n+                    return self.unify_substs(st1, st2, 0);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        false\n+    }\n+}"}, {"sha": "f8807c742881b8d3ee96b7562373d5685cdefa49", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "added", "additions": 658, "deletions": 0, "changes": 658, "blob_url": "https://github.com/rust-lang/rust/blob/264a07975d23ad4d7cb41b309ba4a4c0a507a028/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/264a07975d23ad4d7cb41b309ba4a4c0a507a028/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=264a07975d23ad4d7cb41b309ba4a4c0a507a028", "patch": "@@ -0,0 +1,658 @@\n+//! Type inference for expressions.\n+\n+use std::iter::{repeat, repeat_with};\n+use std::sync::Arc;\n+\n+use super::{BindingMode, Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch};\n+use crate::{\n+    db::HirDatabase,\n+    expr::{self, Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n+    generics::{GenericParams, HasGenericParams},\n+    name,\n+    nameres::Namespace,\n+    path::{GenericArg, GenericArgs},\n+    ty::{\n+        autoderef, method_resolution, op, primitive, CallableDef, InferTy, Mutability, Obligation,\n+        ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n+    },\n+    Adt, Name,\n+};\n+\n+impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+    pub(super) fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n+        let ty = self.infer_expr_inner(tgt_expr, expected);\n+        let could_unify = self.unify(&ty, &expected.ty);\n+        if !could_unify {\n+            self.result.type_mismatches.insert(\n+                tgt_expr,\n+                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n+            );\n+        }\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        ty\n+    }\n+\n+    /// Infer type of expression with possibly implicit coerce to the expected type.\n+    /// Return the type after possible coercion.\n+    fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n+        let ty = self.infer_expr_inner(expr, &expected);\n+        let ty = if !self.coerce(&ty, &expected.ty) {\n+            self.result\n+                .type_mismatches\n+                .insert(expr, TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() });\n+            // Return actual type when type mismatch.\n+            // This is needed for diagnostic when return type mismatch.\n+            ty\n+        } else if expected.ty == Ty::Unknown {\n+            ty\n+        } else {\n+            expected.ty.clone()\n+        };\n+\n+        self.resolve_ty_as_possible(&mut vec![], ty)\n+    }\n+\n+    fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n+        let body = Arc::clone(&self.body); // avoid borrow checker problem\n+        let ty = match &body[tgt_expr] {\n+            Expr::Missing => Ty::Unknown,\n+            Expr::If { condition, then_branch, else_branch } => {\n+                // if let is desugared to match, so this is always simple if\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n+\n+                let then_ty = self.infer_expr_inner(*then_branch, &expected);\n+                let else_ty = match else_branch {\n+                    Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n+                    None => Ty::unit(),\n+                };\n+\n+                self.coerce_merge_branch(&then_ty, &else_ty)\n+            }\n+            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n+            Expr::TryBlock { body } => {\n+                let _inner = self.infer_expr(*body, expected);\n+                // FIXME should be std::result::Result<{inner}, _>\n+                Ty::Unknown\n+            }\n+            Expr::Loop { body } => {\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                // FIXME handle break with value\n+                Ty::simple(TypeCtor::Never)\n+            }\n+            Expr::While { condition, body } => {\n+                // while let is desugared to a match loop, so this is always simple while\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                Ty::unit()\n+            }\n+            Expr::For { iterable, body, pat } => {\n+                let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n+\n+                let pat_ty = match self.resolve_into_iter_item() {\n+                    Some(into_iter_item_alias) => {\n+                        let pat_ty = self.new_type_var();\n+                        let projection = ProjectionPredicate {\n+                            ty: pat_ty.clone(),\n+                            projection_ty: ProjectionTy {\n+                                associated_ty: into_iter_item_alias,\n+                                parameters: Substs::single(iterable_ty),\n+                            },\n+                        };\n+                        self.obligations.push(Obligation::Projection(projection));\n+                        self.resolve_ty_as_possible(&mut vec![], pat_ty)\n+                    }\n+                    None => Ty::Unknown,\n+                };\n+\n+                self.infer_pat(*pat, &pat_ty, BindingMode::default());\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                Ty::unit()\n+            }\n+            Expr::Lambda { body, args, arg_types } => {\n+                assert_eq!(args.len(), arg_types.len());\n+\n+                let mut sig_tys = Vec::new();\n+\n+                for (arg_pat, arg_type) in args.iter().zip(arg_types.iter()) {\n+                    let expected = if let Some(type_ref) = arg_type {\n+                        self.make_ty(type_ref)\n+                    } else {\n+                        Ty::Unknown\n+                    };\n+                    let arg_ty = self.infer_pat(*arg_pat, &expected, BindingMode::default());\n+                    sig_tys.push(arg_ty);\n+                }\n+\n+                // add return type\n+                let ret_ty = self.new_type_var();\n+                sig_tys.push(ret_ty.clone());\n+                let sig_ty = Ty::apply(\n+                    TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n+                    Substs(sig_tys.into()),\n+                );\n+                let closure_ty = Ty::apply_one(\n+                    TypeCtor::Closure { def: self.body.owner(), expr: tgt_expr },\n+                    sig_ty,\n+                );\n+\n+                // Eagerly try to relate the closure type with the expected\n+                // type, otherwise we often won't have enough information to\n+                // infer the body.\n+                self.coerce(&closure_ty, &expected.ty);\n+\n+                self.infer_expr(*body, &Expectation::has_type(ret_ty));\n+                closure_ty\n+            }\n+            Expr::Call { callee, args } => {\n+                let callee_ty = self.infer_expr(*callee, &Expectation::none());\n+                let (param_tys, ret_ty) = match callee_ty.callable_sig(self.db) {\n+                    Some(sig) => (sig.params().to_vec(), sig.ret().clone()),\n+                    None => {\n+                        // Not callable\n+                        // FIXME: report an error\n+                        (Vec::new(), Ty::Unknown)\n+                    }\n+                };\n+                self.register_obligations_for_call(&callee_ty);\n+                self.check_call_arguments(args, &param_tys);\n+                let ret_ty = self.normalize_associated_types_in(ret_ty);\n+                ret_ty\n+            }\n+            Expr::MethodCall { receiver, args, method_name, generic_args } => self\n+                .infer_method_call(tgt_expr, *receiver, &args, &method_name, generic_args.as_ref()),\n+            Expr::Match { expr, arms } => {\n+                let input_ty = self.infer_expr(*expr, &Expectation::none());\n+\n+                let mut result_ty = self.new_maybe_never_type_var();\n+\n+                for arm in arms {\n+                    for &pat in &arm.pats {\n+                        let _pat_ty = self.infer_pat(pat, &input_ty, BindingMode::default());\n+                    }\n+                    if let Some(guard_expr) = arm.guard {\n+                        self.infer_expr(\n+                            guard_expr,\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n+                        );\n+                    }\n+\n+                    let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n+                    result_ty = self.coerce_merge_branch(&result_ty, &arm_ty);\n+                }\n+\n+                result_ty\n+            }\n+            Expr::Path(p) => {\n+                // FIXME this could be more efficient...\n+                let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n+                self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n+            }\n+            Expr::Continue => Ty::simple(TypeCtor::Never),\n+            Expr::Break { expr } => {\n+                if let Some(expr) = expr {\n+                    // FIXME handle break with value\n+                    self.infer_expr(*expr, &Expectation::none());\n+                }\n+                Ty::simple(TypeCtor::Never)\n+            }\n+            Expr::Return { expr } => {\n+                if let Some(expr) = expr {\n+                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()));\n+                }\n+                Ty::simple(TypeCtor::Never)\n+            }\n+            Expr::RecordLit { path, fields, spread } => {\n+                let (ty, def_id) = self.resolve_variant(path.as_ref());\n+                if let Some(variant) = def_id {\n+                    self.write_variant_resolution(tgt_expr.into(), variant);\n+                }\n+\n+                self.unify(&ty, &expected.ty);\n+\n+                let substs = ty.substs().unwrap_or_else(Substs::empty);\n+                for (field_idx, field) in fields.iter().enumerate() {\n+                    let field_ty = def_id\n+                        .and_then(|it| match it.field(self.db, &field.name) {\n+                            Some(field) => Some(field),\n+                            None => {\n+                                self.push_diagnostic(InferenceDiagnostic::NoSuchField {\n+                                    expr: tgt_expr,\n+                                    field: field_idx,\n+                                });\n+                                None\n+                            }\n+                        })\n+                        .map_or(Ty::Unknown, |field| field.ty(self.db))\n+                        .subst(&substs);\n+                    self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n+                }\n+                if let Some(expr) = spread {\n+                    self.infer_expr(*expr, &Expectation::has_type(ty.clone()));\n+                }\n+                ty\n+            }\n+            Expr::Field { expr, name } => {\n+                let receiver_ty = self.infer_expr(*expr, &Expectation::none());\n+                let canonicalized = self.canonicalizer().canonicalize_ty(receiver_ty);\n+                let ty = autoderef::autoderef(\n+                    self.db,\n+                    &self.resolver.clone(),\n+                    canonicalized.value.clone(),\n+                )\n+                .find_map(|derefed_ty| match canonicalized.decanonicalize_ty(derefed_ty.value) {\n+                    Ty::Apply(a_ty) => match a_ty.ctor {\n+                        TypeCtor::Tuple { .. } => name\n+                            .as_tuple_index()\n+                            .and_then(|idx| a_ty.parameters.0.get(idx).cloned()),\n+                        TypeCtor::Adt(Adt::Struct(s)) => s.field(self.db, name).map(|field| {\n+                            self.write_field_resolution(tgt_expr, field);\n+                            field.ty(self.db).subst(&a_ty.parameters)\n+                        }),\n+                        _ => None,\n+                    },\n+                    _ => None,\n+                })\n+                .unwrap_or(Ty::Unknown);\n+                let ty = self.insert_type_vars(ty);\n+                self.normalize_associated_types_in(ty)\n+            }\n+            Expr::Await { expr } => {\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let ty = match self.resolve_future_future_output() {\n+                    Some(future_future_output_alias) => {\n+                        let ty = self.new_type_var();\n+                        let projection = ProjectionPredicate {\n+                            ty: ty.clone(),\n+                            projection_ty: ProjectionTy {\n+                                associated_ty: future_future_output_alias,\n+                                parameters: Substs::single(inner_ty),\n+                            },\n+                        };\n+                        self.obligations.push(Obligation::Projection(projection));\n+                        self.resolve_ty_as_possible(&mut vec![], ty)\n+                    }\n+                    None => Ty::Unknown,\n+                };\n+                ty\n+            }\n+            Expr::Try { expr } => {\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let ty = match self.resolve_ops_try_ok() {\n+                    Some(ops_try_ok_alias) => {\n+                        let ty = self.new_type_var();\n+                        let projection = ProjectionPredicate {\n+                            ty: ty.clone(),\n+                            projection_ty: ProjectionTy {\n+                                associated_ty: ops_try_ok_alias,\n+                                parameters: Substs::single(inner_ty),\n+                            },\n+                        };\n+                        self.obligations.push(Obligation::Projection(projection));\n+                        self.resolve_ty_as_possible(&mut vec![], ty)\n+                    }\n+                    None => Ty::Unknown,\n+                };\n+                ty\n+            }\n+            Expr::Cast { expr, type_ref } => {\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let cast_ty = self.make_ty(type_ref);\n+                // FIXME check the cast...\n+                cast_ty\n+            }\n+            Expr::Ref { expr, mutability } => {\n+                let expectation =\n+                    if let Some((exp_inner, exp_mutability)) = &expected.ty.as_reference() {\n+                        if *exp_mutability == Mutability::Mut && *mutability == Mutability::Shared {\n+                            // FIXME: throw type error - expected mut reference but found shared ref,\n+                            // which cannot be coerced\n+                        }\n+                        Expectation::has_type(Ty::clone(exp_inner))\n+                    } else {\n+                        Expectation::none()\n+                    };\n+                // FIXME reference coercions etc.\n+                let inner_ty = self.infer_expr(*expr, &expectation);\n+                Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n+            }\n+            Expr::Box { expr } => {\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                if let Some(box_) = self.resolve_boxed_box() {\n+                    Ty::apply_one(TypeCtor::Adt(box_), inner_ty)\n+                } else {\n+                    Ty::Unknown\n+                }\n+            }\n+            Expr::UnaryOp { expr, op } => {\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                match op {\n+                    UnaryOp::Deref => {\n+                        let canonicalized = self.canonicalizer().canonicalize_ty(inner_ty);\n+                        if let Some(derefed_ty) =\n+                            autoderef::deref(self.db, &self.resolver, &canonicalized.value)\n+                        {\n+                            canonicalized.decanonicalize_ty(derefed_ty.value)\n+                        } else {\n+                            Ty::Unknown\n+                        }\n+                    }\n+                    UnaryOp::Neg => {\n+                        match &inner_ty {\n+                            Ty::Apply(a_ty) => match a_ty.ctor {\n+                                TypeCtor::Int(primitive::UncertainIntTy::Unknown)\n+                                | TypeCtor::Int(primitive::UncertainIntTy::Known(\n+                                    primitive::IntTy {\n+                                        signedness: primitive::Signedness::Signed,\n+                                        ..\n+                                    },\n+                                ))\n+                                | TypeCtor::Float(..) => inner_ty,\n+                                _ => Ty::Unknown,\n+                            },\n+                            Ty::Infer(InferTy::IntVar(..)) | Ty::Infer(InferTy::FloatVar(..)) => {\n+                                inner_ty\n+                            }\n+                            // FIXME: resolve ops::Neg trait\n+                            _ => Ty::Unknown,\n+                        }\n+                    }\n+                    UnaryOp::Not => {\n+                        match &inner_ty {\n+                            Ty::Apply(a_ty) => match a_ty.ctor {\n+                                TypeCtor::Bool | TypeCtor::Int(_) => inner_ty,\n+                                _ => Ty::Unknown,\n+                            },\n+                            Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n+                            // FIXME: resolve ops::Not trait for inner_ty\n+                            _ => Ty::Unknown,\n+                        }\n+                    }\n+                }\n+            }\n+            Expr::BinaryOp { lhs, rhs, op } => match op {\n+                Some(op) => {\n+                    let lhs_expectation = match op {\n+                        BinaryOp::LogicOp(..) => Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n+                        _ => Expectation::none(),\n+                    };\n+                    let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n+                    // FIXME: find implementation of trait corresponding to operation\n+                    // symbol and resolve associated `Output` type\n+                    let rhs_expectation = op::binary_op_rhs_expectation(*op, lhs_ty);\n+                    let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation));\n+\n+                    // FIXME: similar as above, return ty is often associated trait type\n+                    op::binary_op_return_ty(*op, rhs_ty)\n+                }\n+                _ => Ty::Unknown,\n+            },\n+            Expr::Index { base, index } => {\n+                let _base_ty = self.infer_expr(*base, &Expectation::none());\n+                let _index_ty = self.infer_expr(*index, &Expectation::none());\n+                // FIXME: use `std::ops::Index::Output` to figure out the real return type\n+                Ty::Unknown\n+            }\n+            Expr::Tuple { exprs } => {\n+                let mut tys = match &expected.ty {\n+                    ty_app!(TypeCtor::Tuple { .. }, st) => st\n+                        .iter()\n+                        .cloned()\n+                        .chain(repeat_with(|| self.new_type_var()))\n+                        .take(exprs.len())\n+                        .collect::<Vec<_>>(),\n+                    _ => (0..exprs.len()).map(|_| self.new_type_var()).collect(),\n+                };\n+\n+                for (expr, ty) in exprs.iter().zip(tys.iter_mut()) {\n+                    self.infer_expr_coerce(*expr, &Expectation::has_type(ty.clone()));\n+                }\n+\n+                Ty::apply(TypeCtor::Tuple { cardinality: tys.len() as u16 }, Substs(tys.into()))\n+            }\n+            Expr::Array(array) => {\n+                let elem_ty = match &expected.ty {\n+                    ty_app!(TypeCtor::Array, st) | ty_app!(TypeCtor::Slice, st) => {\n+                        st.as_single().clone()\n+                    }\n+                    _ => self.new_type_var(),\n+                };\n+\n+                match array {\n+                    Array::ElementList(items) => {\n+                        for expr in items.iter() {\n+                            self.infer_expr_coerce(*expr, &Expectation::has_type(elem_ty.clone()));\n+                        }\n+                    }\n+                    Array::Repeat { initializer, repeat } => {\n+                        self.infer_expr_coerce(\n+                            *initializer,\n+                            &Expectation::has_type(elem_ty.clone()),\n+                        );\n+                        self.infer_expr(\n+                            *repeat,\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Int(\n+                                primitive::UncertainIntTy::Known(primitive::IntTy::usize()),\n+                            ))),\n+                        );\n+                    }\n+                }\n+\n+                Ty::apply_one(TypeCtor::Array, elem_ty)\n+            }\n+            Expr::Literal(lit) => match lit {\n+                Literal::Bool(..) => Ty::simple(TypeCtor::Bool),\n+                Literal::String(..) => {\n+                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), Ty::simple(TypeCtor::Str))\n+                }\n+                Literal::ByteString(..) => {\n+                    let byte_type = Ty::simple(TypeCtor::Int(primitive::UncertainIntTy::Known(\n+                        primitive::IntTy::u8(),\n+                    )));\n+                    let slice_type = Ty::apply_one(TypeCtor::Slice, byte_type);\n+                    Ty::apply_one(TypeCtor::Ref(Mutability::Shared), slice_type)\n+                }\n+                Literal::Char(..) => Ty::simple(TypeCtor::Char),\n+                Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int(*ty)),\n+                Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float(*ty)),\n+            },\n+        };\n+        // use a new type variable if we got Ty::Unknown here\n+        let ty = self.insert_type_vars_shallow(ty);\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        self.write_expr_ty(tgt_expr, ty.clone());\n+        ty\n+    }\n+\n+    fn infer_block(\n+        &mut self,\n+        statements: &[Statement],\n+        tail: Option<ExprId>,\n+        expected: &Expectation,\n+    ) -> Ty {\n+        let mut diverges = false;\n+        for stmt in statements {\n+            match stmt {\n+                Statement::Let { pat, type_ref, initializer } => {\n+                    let decl_ty =\n+                        type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(Ty::Unknown);\n+\n+                    // Always use the declared type when specified\n+                    let mut ty = decl_ty.clone();\n+\n+                    if let Some(expr) = initializer {\n+                        let actual_ty =\n+                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()));\n+                        if decl_ty == Ty::Unknown {\n+                            ty = actual_ty;\n+                        }\n+                    }\n+\n+                    let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+                    self.infer_pat(*pat, &ty, BindingMode::default());\n+                }\n+                Statement::Expr(expr) => {\n+                    if let ty_app!(TypeCtor::Never) = self.infer_expr(*expr, &Expectation::none()) {\n+                        diverges = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let ty = if let Some(expr) = tail {\n+            self.infer_expr_coerce(expr, expected)\n+        } else {\n+            self.coerce(&Ty::unit(), &expected.ty);\n+            Ty::unit()\n+        };\n+        if diverges {\n+            Ty::simple(TypeCtor::Never)\n+        } else {\n+            ty\n+        }\n+    }\n+\n+    fn infer_method_call(\n+        &mut self,\n+        tgt_expr: ExprId,\n+        receiver: ExprId,\n+        args: &[ExprId],\n+        method_name: &Name,\n+        generic_args: Option<&GenericArgs>,\n+    ) -> Ty {\n+        let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n+        let canonicalized_receiver = self.canonicalizer().canonicalize_ty(receiver_ty.clone());\n+        let resolved = method_resolution::lookup_method(\n+            &canonicalized_receiver.value,\n+            self.db,\n+            method_name,\n+            &self.resolver,\n+        );\n+        let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n+            Some((ty, func)) => {\n+                let ty = canonicalized_receiver.decanonicalize_ty(ty);\n+                self.write_method_resolution(tgt_expr, func);\n+                (\n+                    ty,\n+                    self.db.type_for_def(func.into(), Namespace::Values),\n+                    Some(func.generic_params(self.db)),\n+                )\n+            }\n+            None => (receiver_ty, Ty::Unknown, None),\n+        };\n+        let substs = self.substs_for_method_call(def_generics, generic_args, &derefed_receiver_ty);\n+        let method_ty = method_ty.apply_substs(substs);\n+        let method_ty = self.insert_type_vars(method_ty);\n+        self.register_obligations_for_call(&method_ty);\n+        let (expected_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n+            Some(sig) => {\n+                if !sig.params().is_empty() {\n+                    (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())\n+                } else {\n+                    (Ty::Unknown, Vec::new(), sig.ret().clone())\n+                }\n+            }\n+            None => (Ty::Unknown, Vec::new(), Ty::Unknown),\n+        };\n+        // Apply autoref so the below unification works correctly\n+        // FIXME: return correct autorefs from lookup_method\n+        let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n+            Some((_, mutability)) => Ty::apply_one(TypeCtor::Ref(mutability), derefed_receiver_ty),\n+            _ => derefed_receiver_ty,\n+        };\n+        self.unify(&expected_receiver_ty, &actual_receiver_ty);\n+\n+        self.check_call_arguments(args, &param_tys);\n+        let ret_ty = self.normalize_associated_types_in(ret_ty);\n+        ret_ty\n+    }\n+\n+    fn check_call_arguments(&mut self, args: &[ExprId], param_tys: &[Ty]) {\n+        // Quoting https://github.com/rust-lang/rust/blob/6ef275e6c3cb1384ec78128eceeb4963ff788dca/src/librustc_typeck/check/mod.rs#L3325 --\n+        // We do this in a pretty awful way: first we type-check any arguments\n+        // that are not closures, then we type-check the closures. This is so\n+        // that we have more information about the types of arguments when we\n+        // type-check the functions. This isn't really the right way to do this.\n+        for &check_closures in &[false, true] {\n+            let param_iter = param_tys.iter().cloned().chain(repeat(Ty::Unknown));\n+            for (&arg, param_ty) in args.iter().zip(param_iter) {\n+                let is_closure = match &self.body[arg] {\n+                    Expr::Lambda { .. } => true,\n+                    _ => false,\n+                };\n+\n+                if is_closure != check_closures {\n+                    continue;\n+                }\n+\n+                let param_ty = self.normalize_associated_types_in(param_ty);\n+                self.infer_expr_coerce(arg, &Expectation::has_type(param_ty.clone()));\n+            }\n+        }\n+    }\n+\n+    fn substs_for_method_call(\n+        &mut self,\n+        def_generics: Option<Arc<GenericParams>>,\n+        generic_args: Option<&GenericArgs>,\n+        receiver_ty: &Ty,\n+    ) -> Substs {\n+        let (parent_param_count, param_count) =\n+            def_generics.as_ref().map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n+        let mut substs = Vec::with_capacity(parent_param_count + param_count);\n+        // Parent arguments are unknown, except for the receiver type\n+        if let Some(parent_generics) = def_generics.and_then(|p| p.parent_params.clone()) {\n+            for param in &parent_generics.params {\n+                if param.name == name::SELF_TYPE {\n+                    substs.push(receiver_ty.clone());\n+                } else {\n+                    substs.push(Ty::Unknown);\n+                }\n+            }\n+        }\n+        // handle provided type arguments\n+        if let Some(generic_args) = generic_args {\n+            // if args are provided, it should be all of them, but we can't rely on that\n+            for arg in generic_args.args.iter().take(param_count) {\n+                match arg {\n+                    GenericArg::Type(type_ref) => {\n+                        let ty = self.make_ty(type_ref);\n+                        substs.push(ty);\n+                    }\n+                }\n+            }\n+        };\n+        let supplied_params = substs.len();\n+        for _ in supplied_params..parent_param_count + param_count {\n+            substs.push(Ty::Unknown);\n+        }\n+        assert_eq!(substs.len(), parent_param_count + param_count);\n+        Substs(substs.into())\n+    }\n+\n+    fn register_obligations_for_call(&mut self, callable_ty: &Ty) {\n+        if let Ty::Apply(a_ty) = callable_ty {\n+            if let TypeCtor::FnDef(def) = a_ty.ctor {\n+                let generic_predicates = self.db.generic_predicates(def.into());\n+                for predicate in generic_predicates.iter() {\n+                    let predicate = predicate.clone().subst(&a_ty.parameters);\n+                    if let Some(obligation) = Obligation::from_predicate(predicate) {\n+                        self.obligations.push(obligation);\n+                    }\n+                }\n+                // add obligation for trait implementation, if this is a trait method\n+                match def {\n+                    CallableDef::Function(f) => {\n+                        if let Some(trait_) = f.parent_trait(self.db) {\n+                            // construct a TraitDef\n+                            let substs = a_ty.parameters.prefix(\n+                                trait_.generic_params(self.db).count_params_including_parent(),\n+                            );\n+                            self.obligations.push(Obligation::Trait(TraitRef { trait_, substs }));\n+                        }\n+                    }\n+                    CallableDef::Struct(_) | CallableDef::EnumVariant(_) => {}\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "c125ddfbc36918dbc4ae1c4ac5efb4544e4487fa", "filename": "crates/ra_hir/src/ty/infer/pat.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/264a07975d23ad4d7cb41b309ba4a4c0a507a028/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/264a07975d23ad4d7cb41b309ba4a4c0a507a028/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpat.rs?ref=264a07975d23ad4d7cb41b309ba4a4c0a507a028", "patch": "@@ -0,0 +1,180 @@\n+//! Type inference for patterns.\n+\n+use std::iter::repeat;\n+use std::sync::Arc;\n+\n+use test_utils::tested_by;\n+\n+use super::{BindingMode, InferenceContext};\n+use crate::{\n+    db::HirDatabase,\n+    expr::{BindingAnnotation, Pat, PatId, RecordFieldPat},\n+    ty::{Mutability, Substs, Ty, TypeCtor, TypeWalk},\n+    Name, Path,\n+};\n+\n+impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+    fn infer_tuple_struct_pat(\n+        &mut self,\n+        path: Option<&Path>,\n+        subpats: &[PatId],\n+        expected: &Ty,\n+        default_bm: BindingMode,\n+    ) -> Ty {\n+        let (ty, def) = self.resolve_variant(path);\n+\n+        self.unify(&ty, expected);\n+\n+        let substs = ty.substs().unwrap_or_else(Substs::empty);\n+\n+        for (i, &subpat) in subpats.iter().enumerate() {\n+            let expected_ty = def\n+                .and_then(|d| d.field(self.db, &Name::new_tuple_field(i)))\n+                .map_or(Ty::Unknown, |field| field.ty(self.db))\n+                .subst(&substs);\n+            let expected_ty = self.normalize_associated_types_in(expected_ty);\n+            self.infer_pat(subpat, &expected_ty, default_bm);\n+        }\n+\n+        ty\n+    }\n+\n+    fn infer_record_pat(\n+        &mut self,\n+        path: Option<&Path>,\n+        subpats: &[RecordFieldPat],\n+        expected: &Ty,\n+        default_bm: BindingMode,\n+        id: PatId,\n+    ) -> Ty {\n+        let (ty, def) = self.resolve_variant(path);\n+        if let Some(variant) = def {\n+            self.write_variant_resolution(id.into(), variant);\n+        }\n+\n+        self.unify(&ty, expected);\n+\n+        let substs = ty.substs().unwrap_or_else(Substs::empty);\n+\n+        for subpat in subpats {\n+            let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n+            let expected_ty =\n+                matching_field.map_or(Ty::Unknown, |field| field.ty(self.db)).subst(&substs);\n+            let expected_ty = self.normalize_associated_types_in(expected_ty);\n+            self.infer_pat(subpat.pat, &expected_ty, default_bm);\n+        }\n+\n+        ty\n+    }\n+\n+    pub(super) fn infer_pat(\n+        &mut self,\n+        pat: PatId,\n+        mut expected: &Ty,\n+        mut default_bm: BindingMode,\n+    ) -> Ty {\n+        let body = Arc::clone(&self.body); // avoid borrow checker problem\n+\n+        let is_non_ref_pat = match &body[pat] {\n+            Pat::Tuple(..)\n+            | Pat::TupleStruct { .. }\n+            | Pat::Record { .. }\n+            | Pat::Range { .. }\n+            | Pat::Slice { .. } => true,\n+            // FIXME: Path/Lit might actually evaluate to ref, but inference is unimplemented.\n+            Pat::Path(..) | Pat::Lit(..) => true,\n+            Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Missing => false,\n+        };\n+        if is_non_ref_pat {\n+            while let Some((inner, mutability)) = expected.as_reference() {\n+                expected = inner;\n+                default_bm = match default_bm {\n+                    BindingMode::Move => BindingMode::Ref(mutability),\n+                    BindingMode::Ref(Mutability::Shared) => BindingMode::Ref(Mutability::Shared),\n+                    BindingMode::Ref(Mutability::Mut) => BindingMode::Ref(mutability),\n+                }\n+            }\n+        } else if let Pat::Ref { .. } = &body[pat] {\n+            tested_by!(match_ergonomics_ref);\n+            // When you encounter a `&pat` pattern, reset to Move.\n+            // This is so that `w` is by value: `let (_, &w) = &(1, &2);`\n+            default_bm = BindingMode::Move;\n+        }\n+\n+        // Lose mutability.\n+        let default_bm = default_bm;\n+        let expected = expected;\n+\n+        let ty = match &body[pat] {\n+            Pat::Tuple(ref args) => {\n+                let expectations = match expected.as_tuple() {\n+                    Some(parameters) => &*parameters.0,\n+                    _ => &[],\n+                };\n+                let expectations_iter = expectations.iter().chain(repeat(&Ty::Unknown));\n+\n+                let inner_tys = args\n+                    .iter()\n+                    .zip(expectations_iter)\n+                    .map(|(&pat, ty)| self.infer_pat(pat, ty, default_bm))\n+                    .collect();\n+\n+                Ty::apply(TypeCtor::Tuple { cardinality: args.len() as u16 }, Substs(inner_tys))\n+            }\n+            Pat::Ref { pat, mutability } => {\n+                let expectation = match expected.as_reference() {\n+                    Some((inner_ty, exp_mut)) => {\n+                        if *mutability != exp_mut {\n+                            // FIXME: emit type error?\n+                        }\n+                        inner_ty\n+                    }\n+                    _ => &Ty::Unknown,\n+                };\n+                let subty = self.infer_pat(*pat, expectation, default_bm);\n+                Ty::apply_one(TypeCtor::Ref(*mutability), subty)\n+            }\n+            Pat::TupleStruct { path: p, args: subpats } => {\n+                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm)\n+            }\n+            Pat::Record { path: p, args: fields } => {\n+                self.infer_record_pat(p.as_ref(), fields, expected, default_bm, pat)\n+            }\n+            Pat::Path(path) => {\n+                // FIXME use correct resolver for the surrounding expression\n+                let resolver = self.resolver.clone();\n+                self.infer_path(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n+            }\n+            Pat::Bind { mode, name: _, subpat } => {\n+                let mode = if mode == &BindingAnnotation::Unannotated {\n+                    default_bm\n+                } else {\n+                    BindingMode::convert(*mode)\n+                };\n+                let inner_ty = if let Some(subpat) = subpat {\n+                    self.infer_pat(*subpat, expected, default_bm)\n+                } else {\n+                    expected.clone()\n+                };\n+                let inner_ty = self.insert_type_vars_shallow(inner_ty);\n+\n+                let bound_ty = match mode {\n+                    BindingMode::Ref(mutability) => {\n+                        Ty::apply_one(TypeCtor::Ref(mutability), inner_ty.clone())\n+                    }\n+                    BindingMode::Move => inner_ty.clone(),\n+                };\n+                let bound_ty = self.resolve_ty_as_possible(&mut vec![], bound_ty);\n+                self.write_pat_ty(pat, bound_ty);\n+                return inner_ty;\n+            }\n+            _ => Ty::Unknown,\n+        };\n+        // use a new type variable if we got Ty::Unknown here\n+        let ty = self.insert_type_vars_shallow(ty);\n+        self.unify(&ty, expected);\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        self.write_pat_ty(pat, ty.clone());\n+        ty\n+    }\n+}"}]}