{"sha": "b593359f7f90d7cb9ec71a4b99f9b1396603a8a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OTMzNTlmN2Y5MGQ3Y2I5ZWM3MWE0Yjk5ZjliMTM5NjYwM2E4YTg=", "commit": {"author": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2015-05-19T17:38:17Z"}, "committer": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2015-05-26T20:12:52Z"}, "message": "Add error explanations for E0055, E0089, E0192, E0261, E0262, E0263, E0318.", "tree": {"sha": "e712e819a33304afc8fdafecd3eb4a73eb535a81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e712e819a33304afc8fdafecd3eb4a73eb535a81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b593359f7f90d7cb9ec71a4b99f9b1396603a8a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b593359f7f90d7cb9ec71a4b99f9b1396603a8a8", "html_url": "https://github.com/rust-lang/rust/commit/b593359f7f90d7cb9ec71a4b99f9b1396603a8a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b593359f7f90d7cb9ec71a4b99f9b1396603a8a8/comments", "author": null, "committer": null, "parents": [{"sha": "6a003abc374c912b4890b6cc1c61b5b1bd1efe60", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a003abc374c912b4890b6cc1c61b5b1bd1efe60", "html_url": "https://github.com/rust-lang/rust/commit/6a003abc374c912b4890b6cc1c61b5b1bd1efe60"}], "stats": {"total": 123, "additions": 116, "deletions": 7}, "files": [{"sha": "0f950d7ceb3ab634cd9602e28310be45ac98daca", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b593359f7f90d7cb9ec71a4b99f9b1396603a8a8/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b593359f7f90d7cb9ec71a4b99f9b1396603a8a8/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=b593359f7f90d7cb9ec71a4b99f9b1396603a8a8", "patch": "@@ -396,6 +396,54 @@ enum Method { GET, POST }\n ```\n \"##,\n \n+E0261: r##\"\n+When using a lifetime like `'a` in a type, it must be declared before being\n+used.\n+\n+These two examples illustrate the problem:\n+\n+```\n+// error, use of undeclared lifetime name `'a`\n+fn foo(x: &'a str) { }\n+\n+struct Foo {\n+    // error, use of undeclared lifetime name `'a`\n+    x: &'a str,\n+}\n+```\n+\n+These can be fixed by declaring lifetime parameters:\n+\n+```\n+fn foo<'a>(x: &'a str) { }\n+\n+struct Foo<'a> {\n+    x: &'a str,\n+}\n+```\n+\"##,\n+\n+E0262: r##\"\n+Declaring certain lifetime names in parameters is disallowed. For example,\n+because the `'static` lifetime is a special built-in lifetime name denoting\n+the lifetime of the entire program, this is an error:\n+\n+```\n+// error, illegal lifetime parameter name `'static`\n+fn foo<'static>(x: &'static str) { }\n+```\n+\"##,\n+\n+E0263: r##\"\n+A lifetime name cannot be declared more than once in the same scope. For\n+example:\n+\n+```\n+// error, lifetime name `'a` declared twice in the same scope\n+fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { }\n+```\n+\"##,\n+\n E0265: r##\"\n This error indicates that a static or constant references itself.\n All statics and constants need to resolve to a value in an acyclic manner.\n@@ -814,9 +862,6 @@ register_diagnostics! {\n     E0136,\n     E0138,\n     E0139,\n-    E0261, // use of undeclared lifetime name\n-    E0262, // illegal lifetime parameter name\n-    E0263, // lifetime name declared twice in same scope\n     E0264, // unknown external lang item\n     E0266, // expected item\n     E0269, // not all control paths return a value"}, {"sha": "1c794e7f257ed94427e9da62a0803f5d8f44391f", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 68, "deletions": 4, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b593359f7f90d7cb9ec71a4b99f9b1396603a8a8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b593359f7f90d7cb9ec71a4b99f9b1396603a8a8/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b593359f7f90d7cb9ec71a4b99f9b1396603a8a8", "patch": "@@ -261,6 +261,37 @@ let x_is_nonzero = x as bool;\n ```\n \"##,\n \n+E0055: r##\"\n+During a method call, a value is automatically dereferenced as many times as\n+needed to make the value's type match the method's receiver. The catch is that\n+the compiler will only attempt to dereference a number of times up to the\n+recursion limit (which can be set via the `recursion_limit` attribute).\n+\n+For a somewhat artificial example:\n+\n+```\n+#![recursion_limit=\"2\"]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo;\n+    let ref_foo = &&Foo;\n+\n+    // error, reached the recursion limit while auto-dereferencing &&Foo\n+    ref_foo.foo();\n+}\n+```\n+\n+One fix may be to increase the recursion limit. Note that it is possible to\n+create an infinite recursion of dereferencing, in which case the only fix is to\n+somehow break the recursion.\n+\"##,\n+\n E0062: r##\"\n This error indicates that during an attempt to build a struct or struct-like\n enum variant, one of the fields was specified more than once. Each field should\n@@ -511,6 +542,31 @@ enum Empty {}\n ```\n \"##,\n \n+E0089: r##\"\n+Not enough type parameters were supplied for a function. For example:\n+\n+```\n+fn foo<T, U>() {}\n+\n+fn main() {\n+    foo::<f64>(); // error, expected 2 parameters, found 1 parameter\n+}\n+```\n+\n+Note that if a function takes multiple type parameters but you want the compiler\n+to infer some of them, you can use type placeholders:\n+\n+```\n+fn foo<T, U>(x: T) {}\n+\n+fn main() {\n+    let x: bool = true;\n+    foo::<f64>(x);    // error, expected 2 parameters, found 1 parameter\n+    foo::<_, f64>(x); // same as `foo::<bool, f64>(x)`\n+}\n+```\n+\"##,\n+\n E0106: r##\"\n This error indicates that a lifetime is missing from a type. If it is an error\n inside a function signature, the problem may be with failing to adhere to the\n@@ -707,6 +763,12 @@ impl Foo for Bar {\n }\n \"##,\n \n+E0192: r##\"\n+Negative impls are only allowed for traits with default impls. For more\n+information see the [opt-in builtin traits RFC](https://github.com/rust-lang/\n+rfcs/blob/master/text/0019-opt-in-builtin-traits.md).\n+\"##,\n+\n E0197: r##\"\n Inherent implementations (one that do not implement a trait but provide\n methods associated with a type) are always safe because they are not\n@@ -936,6 +998,12 @@ const C: [u32; u8::MAX + f64::EPSILON] = [];\n ```\n \"##,\n \n+E0318: r##\"\n+Default impls for a trait must be located in the same crate where the trait was\n+defined. For more information see the [opt-in builtin traits RFC](https://github\n+.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md).\n+\"##,\n+\n E0322: r##\"\n The `Sized` trait is a special trait built-in to the compiler for types with a\n constant size known at compile-time. This trait is automatically implemented\n@@ -1045,7 +1113,6 @@ register_diagnostics! {\n     E0040, // explicit use of destructor method\n     E0044, // foreign items may not have type parameters\n     E0045, // variadic function must have C calling convention\n-    E0055, // method has an incompatible type for trait\n     E0057, // method has an incompatible type for trait\n     E0059,\n     E0060,\n@@ -1060,7 +1127,6 @@ register_diagnostics! {\n     E0086,\n     E0087,\n     E0088,\n-    E0089,\n     E0090,\n     E0091,\n     E0092,\n@@ -1098,7 +1164,6 @@ register_diagnostics! {\n     E0189, // deprecated: can only cast a boxed pointer to a boxed object\n     E0190, // deprecated: can only cast a &-pointer to an &-object\n     E0191, // value of the associated type must be specified\n-    E0192, // negative impls are allowed just for `Send` and `Sync`\n     E0193, // cannot bound type where clause bounds may only be attached to types\n            // involving type parameters\n     E0194,\n@@ -1146,7 +1211,6 @@ register_diagnostics! {\n     E0246, // illegal recursive type\n     E0247, // found module name used as a type\n     E0248, // found value name used as a type\n-    E0318, // can't create default impls for traits outside their crates\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated"}]}