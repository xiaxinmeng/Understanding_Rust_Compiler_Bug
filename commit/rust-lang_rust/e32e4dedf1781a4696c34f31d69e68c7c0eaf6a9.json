{"sha": "e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMmU0ZGVkZjE3ODFhNDY5NmMzNGYzMWQ2OWU2OGM3YzBlYWY2YTk=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-02-02T03:26:20Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-02-04T08:26:43Z"}, "message": "New lint: default_numeric_fallback", "tree": {"sha": "136ddfa6acbeee4e59544d18c6c5a748f7a7c937", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/136ddfa6acbeee4e59544d18c6c5a748f7a7c937"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9", "html_url": "https://github.com/rust-lang/rust/commit/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "876ffa4674c5d304983ff4d9bfeaffadee2cbb37", "url": "https://api.github.com/repos/rust-lang/rust/commits/876ffa4674c5d304983ff4d9bfeaffadee2cbb37", "html_url": "https://github.com/rust-lang/rust/commit/876ffa4674c5d304983ff4d9bfeaffadee2cbb37"}], "stats": {"total": 679, "additions": 679, "deletions": 0}, "files": [{"sha": "5eed9664088caaf2c543fecff993f5282df3a38f", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9", "patch": "@@ -1909,6 +1909,7 @@ Released 2018-09-13\n [`debug_assert_with_mut_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#debug_assert_with_mut_call\n [`decimal_literal_representation`]: https://rust-lang.github.io/rust-clippy/master/index.html#decimal_literal_representation\n [`declare_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const\n+[`default_numeric_fallback`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_numeric_fallback\n [`default_trait_access`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_trait_access\n [`deprecated_cfg_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_cfg_attr\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver"}, {"sha": "f049e64d0fbdb7f175c843ba60a51c7e4e80ab81", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9", "patch": "@@ -0,0 +1,388 @@\n+use rustc_ast::ast::{Label, LitFloatType, LitIntType, LitKind};\n+use rustc_hir::{\n+    self as hir,\n+    intravisit::{walk_expr, walk_stmt, walk_ty, FnKind, NestedVisitorMap, Visitor},\n+    Body, Expr, ExprKind, FnDecl, FnRetTy, Guard, HirId, Lit, Stmt, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::{\n+    hir::map::Map,\n+    ty::{self, subst::GenericArgKind, FloatTy, IntTy, Ty, TyCtxt},\n+};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::span_lint_and_help;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of unconstrained numeric literals which may cause default numeric fallback in type\n+    /// inference.\n+    ///\n+    /// Default numeric fallback means that if numeric types have not yet been bound to concrete\n+    /// types at the end of type inference, then integer type is bound to `i32`, and similarly\n+    /// floating type is bound to `f64`.\n+    ///\n+    /// See [RFC0212](https://github.com/rust-lang/rfcs/blob/master/text/0212-restore-int-fallback.md) for more information about the fallback.\n+    ///\n+    /// **Why is this bad?** For those who are very careful about types, default numeric fallback\n+    /// can be a pitfall that cause unexpected runtime behavior.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let i = 10;\n+    /// let f = 1.23;\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let i = 10i32;\n+    /// let f = 1.23f64;\n+    /// ```\n+    pub DEFAULT_NUMERIC_FALLBACK,\n+    restriction,\n+    \"usage of unconstrained numeric literals which may cause default numeric fallback.\"\n+}\n+\n+declare_lint_pass!(DefaultNumericFallback => [DEFAULT_NUMERIC_FALLBACK]);\n+\n+fn enclosing_body_owner_opt(tcx: TyCtxt<'_>, hir_id: HirId) -> Option<HirId> {\n+    let hir_map = tcx.hir();\n+    for (parent, _) in hir_map.parent_iter(hir_id) {\n+        if let Some(body) = hir_map.maybe_body_owned_by(parent) {\n+            return Some(hir_map.body_owner(body));\n+        }\n+    }\n+    None\n+}\n+\n+impl LateLintPass<'_> for DefaultNumericFallback {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        _: FnKind<'tcx>,\n+        fn_decl: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        _: Span,\n+        hir_id: HirId,\n+    ) {\n+        let ret_ty_bound = match fn_decl.output {\n+            FnRetTy::DefaultReturn(_) => None,\n+            FnRetTy::Return(ty) => Some(ty),\n+        }\n+        .and_then(|ty| {\n+            let mut infer_ty_finder = InferTyFinder::new();\n+            infer_ty_finder.visit_ty(ty);\n+            if infer_ty_finder.found {\n+                None\n+            } else if enclosing_body_owner_opt(cx.tcx, hir_id).is_some() {\n+                cx.typeck_results().node_type_opt(ty.hir_id)\n+            } else {\n+                Some(hir_ty_to_ty(cx.tcx, ty))\n+            }\n+        });\n+\n+        let mut visitor = NumericFallbackVisitor::new(ret_ty_bound, cx);\n+        visitor.visit_body(body);\n+    }\n+}\n+\n+struct NumericFallbackVisitor<'a, 'tcx> {\n+    /// Stack manages type bound of exprs. The top element holds current expr type.\n+    ty_bounds: Vec<Option<Ty<'tcx>>>,\n+\n+    /// Ret type bound.\n+    ret_ty_bound: Option<Ty<'tcx>>,\n+\n+    /// Break type bounds.\n+    break_ty_bounds: Vec<(Option<Label>, Option<Ty<'tcx>>)>,\n+\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n+    fn new(ret_ty_bound: Option<Ty<'tcx>>, cx: &'a LateContext<'tcx>) -> Self {\n+        Self {\n+            ty_bounds: vec![ret_ty_bound],\n+            ret_ty_bound,\n+            break_ty_bounds: vec![],\n+            cx,\n+        }\n+    }\n+\n+    /// Check whether lit cause fallback or not.\n+    fn check_lit(&self, lit: &Lit, lit_ty: Ty<'tcx>) {\n+        let ty_bound = self.ty_bounds.last().unwrap();\n+\n+        let should_lint = match (&lit.node, lit_ty.kind()) {\n+            (LitKind::Int(_, LitIntType::Unsuffixed), ty::Int(ty::IntTy::I32)) => {\n+                // In case integer literal is explicitly bound to i32, then suppress lint.\n+                ty_bound.map_or(true, |ty_bound| !matches!(ty_bound.kind(), ty::Int(IntTy::I32)))\n+            },\n+\n+            (LitKind::Float(_, LitFloatType::Unsuffixed), ty::Float(ty::FloatTy::F64)) => {\n+                // In case float literal is explicitly bound to f64, then suppress lint.\n+                ty_bound.map_or(true, |ty_bound| !matches!(ty_bound.kind(), ty::Float(FloatTy::F64)))\n+            },\n+\n+            _ => false,\n+        };\n+\n+        if should_lint {\n+            span_lint_and_help(\n+                self.cx,\n+                DEFAULT_NUMERIC_FALLBACK,\n+                lit.span,\n+                \"default numeric fallback might occur\",\n+                None,\n+                \"consider adding suffix to avoid default numeric fallback\",\n+            );\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    #[allow(clippy::too_many_lines)]\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        match (&expr.kind, *self.ty_bounds.last().unwrap()) {\n+            (ExprKind::Array(_), Some(last_bound)) => {\n+                if let ty::Array(ty, _) = last_bound.kind() {\n+                    self.ty_bounds.push(Some(ty))\n+                } else {\n+                    self.ty_bounds.push(None)\n+                }\n+            },\n+\n+            (ExprKind::Call(func, args), _) => {\n+                if_chain! {\n+                    if let ExprKind::Path(ref func_path) = func.kind;\n+                    if let Some(def_id) = self.cx.qpath_res(func_path, func.hir_id).opt_def_id();\n+                    then {\n+                        let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n+                        for (expr, bound) in args.iter().zip(fn_sig.inputs().iter()) {\n+                            // Push found arg type, then visit arg.\n+                            self.ty_bounds.push(Some(bound));\n+                            self.visit_expr(expr);\n+                            self.ty_bounds.pop();\n+                        }\n+                        return;\n+                    } else {\n+                        self.ty_bounds.push(None)\n+                    }\n+                }\n+            },\n+\n+            (ExprKind::MethodCall(_, _, args, _), _) => {\n+                if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n+                    let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n+                    for (expr, bound) in args.iter().zip(fn_sig.inputs().iter()) {\n+                        self.ty_bounds.push(Some(bound));\n+                        self.visit_expr(expr);\n+                        self.ty_bounds.pop();\n+                    }\n+                    return;\n+                }\n+\n+                self.ty_bounds.push(None)\n+            },\n+\n+            (ExprKind::Tup(exprs), Some(last_bound)) => {\n+                if let ty::Tuple(tys) = last_bound.kind() {\n+                    for (expr, bound) in exprs.iter().zip(tys.iter()) {\n+                        if let GenericArgKind::Type(ty) = bound.unpack() {\n+                            self.ty_bounds.push(Some(ty));\n+                        } else {\n+                            self.ty_bounds.push(None);\n+                        }\n+\n+                        self.visit_expr(expr);\n+                        self.ty_bounds.pop();\n+                    }\n+                    return;\n+                }\n+\n+                self.ty_bounds.push(None)\n+            },\n+\n+            (ExprKind::Lit(lit), _) => {\n+                let ty = self.cx.typeck_results().expr_ty(expr);\n+                self.check_lit(lit, ty);\n+                return;\n+            },\n+\n+            (ExprKind::If(cond, then, else_), last_bound) => {\n+                // Cond has no type bound in any situation.\n+                self.ty_bounds.push(None);\n+                self.visit_expr(cond);\n+                self.ty_bounds.pop();\n+\n+                // Propagate current bound to childs.\n+                self.ty_bounds.push(last_bound);\n+                self.visit_expr(then);\n+                if let Some(else_) = else_ {\n+                    self.visit_expr(else_);\n+                }\n+                self.ty_bounds.pop();\n+                return;\n+            },\n+\n+            (ExprKind::Loop(_, label, ..), last_bound) => {\n+                self.break_ty_bounds.push((*label, last_bound));\n+                walk_expr(self, expr);\n+                self.break_ty_bounds.pop();\n+                return;\n+            },\n+\n+            (ExprKind::Match(arg, arms, _), last_bound) => {\n+                // Match argument has no type bound.\n+                self.ty_bounds.push(None);\n+                self.visit_expr(arg);\n+                for arm in arms.iter() {\n+                    self.visit_pat(arm.pat);\n+                    if let Some(Guard::If(guard)) = arm.guard {\n+                        self.visit_expr(guard);\n+                    }\n+                }\n+                self.ty_bounds.pop();\n+\n+                // Propagate current bound.\n+                self.ty_bounds.push(last_bound);\n+                for arm in arms.iter() {\n+                    self.visit_expr(arm.body);\n+                }\n+                self.ty_bounds.pop();\n+                return;\n+            },\n+\n+            (ExprKind::Block(..), last_bound) => self.ty_bounds.push(last_bound),\n+\n+            (ExprKind::Break(destination, _), _) => {\n+                let ty = destination.label.map_or_else(\n+                    || self.break_ty_bounds.last().unwrap().1,\n+                    |dest_label| {\n+                        self.break_ty_bounds\n+                            .iter()\n+                            .rev()\n+                            .find_map(|(loop_label, ty)| {\n+                                loop_label.map_or(None, |loop_label| {\n+                                    if loop_label.ident == dest_label.ident {\n+                                        Some(*ty)\n+                                    } else {\n+                                        None\n+                                    }\n+                                })\n+                            })\n+                            .unwrap()\n+                    },\n+                );\n+                self.ty_bounds.push(ty);\n+            },\n+\n+            (ExprKind::Ret(_), _) => self.ty_bounds.push(self.ret_ty_bound),\n+\n+            (ExprKind::Struct(qpath, fields, base), _) => {\n+                if_chain! {\n+                    if let Some(def_id) = self.cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n+                    let ty = self.cx.tcx.type_of(def_id);\n+                    if let Some(adt_def) = ty.ty_adt_def();\n+                    if adt_def.is_struct();\n+                    if let Some(variant) = adt_def.variants.iter().next();\n+                    then {\n+                        let fields_def = &variant.fields;\n+\n+                        // Push field type then visit each field expr.\n+                        for field in fields.iter() {\n+                            let field_ty =\n+                                fields_def\n+                                    .iter()\n+                                    .find_map(|f_def| {\n+                                        if f_def.ident == field.ident\n+                                            { Some(self.cx.tcx.type_of(f_def.did)) }\n+                                        else { None }\n+                                    });\n+                            self.ty_bounds.push(field_ty);\n+                            self.visit_expr(field.expr);\n+                            self.ty_bounds.pop();\n+                        }\n+\n+                        // Visit base with no bound.\n+                        if let Some(base) = base {\n+                            self.ty_bounds.push(None);\n+                            self.visit_expr(base);\n+                            self.ty_bounds.pop();\n+                        }\n+                        return;\n+                    }\n+                }\n+                self.ty_bounds.push(None);\n+            },\n+\n+            _ => self.ty_bounds.push(None),\n+        }\n+\n+        walk_expr(self, expr);\n+        self.ty_bounds.pop();\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        match stmt.kind {\n+            StmtKind::Local(local) => {\n+                let ty = local.ty.and_then(|hir_ty| {\n+                    let mut infer_ty_finder = InferTyFinder::new();\n+                    infer_ty_finder.visit_ty(hir_ty);\n+                    if infer_ty_finder.found {\n+                        None\n+                    } else {\n+                        self.cx.typeck_results().node_type_opt(hir_ty.hir_id)\n+                    }\n+                });\n+                self.ty_bounds.push(ty);\n+            },\n+\n+            _ => self.ty_bounds.push(None),\n+        }\n+\n+        walk_stmt(self, stmt);\n+        self.ty_bounds.pop();\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Find `hir::TyKind::Infer` is included in passed typed.\n+struct InferTyFinder {\n+    found: bool,\n+}\n+\n+impl InferTyFinder {\n+    fn new() -> Self {\n+        Self { found: false }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for InferTyFinder {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'_>) {\n+        match ty.kind {\n+            hir::TyKind::Infer => {\n+                self.found = true;\n+            },\n+            _ => {\n+                walk_ty(self, ty);\n+            },\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "642c1e68dacba173e70c485b77f73a6de811e5dc", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9", "patch": "@@ -181,6 +181,7 @@ mod copy_iterator;\n mod create_dir;\n mod dbg_macro;\n mod default;\n+mod default_numeric_fallback;\n mod dereference;\n mod derive;\n mod disallowed_method;\n@@ -584,6 +585,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &dbg_macro::DBG_MACRO,\n         &default::DEFAULT_TRAIT_ACCESS,\n         &default::FIELD_REASSIGN_WITH_DEFAULT,\n+        &default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n         &dereference::EXPLICIT_DEREF_METHODS,\n         &derive::DERIVE_HASH_XOR_EQ,\n         &derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n@@ -1026,6 +1028,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box strings::StringAdd);\n     store.register_late_pass(|| box implicit_return::ImplicitReturn);\n     store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n+    store.register_late_pass(|| box default_numeric_fallback::DefaultNumericFallback);\n \n     let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n@@ -1258,6 +1261,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&asm_syntax::INLINE_ASM_X86_INTEL_SYNTAX),\n         LintId::of(&create_dir::CREATE_DIR),\n         LintId::of(&dbg_macro::DBG_MACRO),\n+        LintId::of(&default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK),\n         LintId::of(&else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n         LintId::of(&exhaustive_items::EXHAUSTIVE_ENUMS),\n         LintId::of(&exhaustive_items::EXHAUSTIVE_STRUCTS),"}, {"sha": "90ee8ea03996d98b087108a7869cabf8c787fe42", "filename": "tests/ui/default_numeric_fallback.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/tests%2Fui%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/tests%2Fui%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.rs?ref=e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9", "patch": "@@ -0,0 +1,99 @@\n+#![warn(clippy::default_numeric_fallback)]\n+#![allow(unused)]\n+#![allow(clippy::never_loop)]\n+#![allow(clippy::no_effect)]\n+#![allow(clippy::unnecessary_operation)]\n+\n+fn ret_i31() -> i32 {\n+    23\n+}\n+\n+fn concrete_arg(x: i32) {}\n+\n+fn generic_arg<T>(t: T) {}\n+\n+struct ConcreteStruct {\n+    x: i32,\n+}\n+\n+struct GenericStruct<T> {\n+    x: T,\n+}\n+\n+struct StructForMethodCallTest {\n+    x: i32,\n+}\n+\n+impl StructForMethodCallTest {\n+    fn concrete_arg(&self, x: i32) {}\n+\n+    fn generic_arg<T>(&self, t: T) {}\n+}\n+\n+fn main() {\n+    let s = StructForMethodCallTest { x: 10_i32 };\n+\n+    // Bad.\n+    let x = 22;\n+    let x = 0.12;\n+    let x: _ = 13;\n+    let x: [_; 3] = [1, 2, 3];\n+    let x: (_, i32) = (1, 2);\n+\n+    let x = if true { (1, 2) } else { (3, 4) };\n+\n+    let x = match 1 {\n+        1 => 1,\n+        _ => 2,\n+    };\n+\n+    let x = loop {\n+        break 1;\n+    };\n+\n+    let x = 'outer0: loop {\n+        {\n+            'inner0: loop {\n+                break 3;\n+            }\n+        };\n+        break 2;\n+    };\n+\n+    let x = GenericStruct { x: 1 };\n+\n+    generic_arg(10);\n+    s.generic_arg(10);\n+    let f = || -> _ { 1 };\n+\n+    // Good.\n+    let x = 22_i32;\n+    let x: f64 = 0.12;\n+    let x = 0.12_f64;\n+    let x: i32 = 13;\n+    let x: [i32; 3] = [1, 2, 3];\n+    let x: (i32, i32) = (1, 2);\n+\n+    let x: (i32, i32) = if true { (1, 2) } else { (3, 4) };\n+\n+    let x: i32 = match true {\n+        true => 1,\n+        _ => 2,\n+    };\n+\n+    let x: i32 = loop {\n+        break 1;\n+    };\n+\n+    let x: i32 = 'outer1: loop {\n+        'inner1: loop {\n+            break 'outer1 3;\n+        }\n+    };\n+\n+    let x = ConcreteStruct { x: 1 };\n+\n+    concrete_arg(10);\n+    s.concrete_arg(10);\n+    let f = || -> i32 { 1 };\n+}"}, {"sha": "27629b994beabbe73870d2422ee2515441a2688f", "filename": "tests/ui/default_numeric_fallback.stderr", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/tests%2Fui%2Fdefault_numeric_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9/tests%2Fui%2Fdefault_numeric_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.stderr?ref=e32e4dedf1781a4696c34f31d69e68c7c0eaf6a9", "patch": "@@ -0,0 +1,187 @@\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:37:13\n+   |\n+LL |     let x = 22;\n+   |             ^^\n+   |\n+   = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:38:13\n+   |\n+LL |     let x = 0.12;\n+   |             ^^^^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:39:16\n+   |\n+LL |     let x: _ = 13;\n+   |                ^^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:40:22\n+   |\n+LL |     let x: [_; 3] = [1, 2, 3];\n+   |                      ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:40:25\n+   |\n+LL |     let x: [_; 3] = [1, 2, 3];\n+   |                         ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:40:28\n+   |\n+LL |     let x: [_; 3] = [1, 2, 3];\n+   |                            ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:41:24\n+   |\n+LL |     let x: (_, i32) = (1, 2);\n+   |                        ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:41:27\n+   |\n+LL |     let x: (_, i32) = (1, 2);\n+   |                           ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:43:24\n+   |\n+LL |     let x = if true { (1, 2) } else { (3, 4) };\n+   |                        ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:43:27\n+   |\n+LL |     let x = if true { (1, 2) } else { (3, 4) };\n+   |                           ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:43:40\n+   |\n+LL |     let x = if true { (1, 2) } else { (3, 4) };\n+   |                                        ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:43:43\n+   |\n+LL |     let x = if true { (1, 2) } else { (3, 4) };\n+   |                                           ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:45:19\n+   |\n+LL |     let x = match 1 {\n+   |                   ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:46:9\n+   |\n+LL |         1 => 1,\n+   |         ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:46:14\n+   |\n+LL |         1 => 1,\n+   |              ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:47:14\n+   |\n+LL |         _ => 2,\n+   |              ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:51:15\n+   |\n+LL |         break 1;\n+   |               ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:57:23\n+   |\n+LL |                 break 3;\n+   |                       ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:60:15\n+   |\n+LL |         break 2;\n+   |               ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:63:32\n+   |\n+LL |     let x = GenericStruct { x: 1 };\n+   |                                ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:65:17\n+   |\n+LL |     generic_arg(10);\n+   |                 ^^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:66:19\n+   |\n+LL |     s.generic_arg(10);\n+   |                   ^^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:67:23\n+   |\n+LL |     let f = || -> _ { 1 };\n+   |                       ^\n+   |\n+   = help: consider adding suffix to avoid default numeric fallback\n+\n+error: aborting due to 23 previous errors\n+"}]}