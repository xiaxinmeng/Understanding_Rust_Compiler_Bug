{"sha": "6e654564db85819ef401eeb4e950acf02096796c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNjU0NTY0ZGI4NTgxOWVmNDAxZWViNGU5NTBhY2YwMjA5Njc5NmM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-02T03:12:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-02T07:57:53Z"}, "message": "Lots of build system cleanup and documentation\n\nThis splits mk/stageN.mk into host.mk and target.mk and makes\nthe build rules somewhat simpler - there's no more building from stageN\ninto stageN+1; instead we always build from stageN(host) to\nstageN(target) then promote from stageN(target) to stageN+1(host).\n\nAdd a big honkin explaination right at the top of Makefile.in", "tree": {"sha": "d7279c8892293acf584a1aad35032a64d87a6ed0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7279c8892293acf584a1aad35032a64d87a6ed0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e654564db85819ef401eeb4e950acf02096796c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e654564db85819ef401eeb4e950acf02096796c", "html_url": "https://github.com/rust-lang/rust/commit/6e654564db85819ef401eeb4e950acf02096796c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e654564db85819ef401eeb4e950acf02096796c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9563c17d78570dc5646786c142a0f0b68a86dd3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9563c17d78570dc5646786c142a0f0b68a86dd3e", "html_url": "https://github.com/rust-lang/rust/commit/9563c17d78570dc5646786c142a0f0b68a86dd3e"}], "stats": {"total": 402, "additions": 235, "deletions": 167}, "files": [{"sha": "e401ec0ab333232f97583591f861cfb4dbf17d31", "filename": "Makefile.in", "status": "modified", "additions": 76, "deletions": 28, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/6e654564db85819ef401eeb4e950acf02096796c/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/6e654564db85819ef401eeb4e950acf02096796c/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=6e654564db85819ef401eeb4e950acf02096796c", "patch": "@@ -1,3 +1,47 @@\n+# An explanation of how the build is structured:\n+#\n+# There are multiple build stages (0-3) needed to verify that the\n+# compiler is properly self-hosting. Each stage is divided between\n+# 'host' artifacts and 'target' artifacts, where the stageN host\n+# compiler builds artifacts for 1 or more stageN target architectures.\n+# Once the stageN target compiler has been built for the host\n+# architecture it is promoted (copied) to a stageN+1 host artifact.\n+#\n+# The stage3 host compiler is a compiler that successfully builds\n+# itself and should (in theory) be bitwise identical to the stage2\n+# host compiler. The process is bootstrapped using a stage0 host\n+# compiler downloaded from a previous snapshot.\n+#\n+# At no time should stageN artifacts be interacting with artifacts\n+# from other stages. For consistency, we use the 'promotion' logic\n+# for all artifacts, even those that don't make sense on non-host\n+# architectures.\n+#\n+# The directory layout for a stage is intended to match the layout\n+# of the installed compiler, and looks like the following:\n+#\n+# stageN - this is the system root, corresponding to, e.g. /usr\n+#   bin - binaries compiled for the host\n+#   lib - libraries used by the host compiler\n+#     rustc - rustc's own place to organize libraries\n+#       $(target) - target-specific artifacts\n+#         bin - binaries for target architectures\n+#         lib - libraries for target architectures\n+#\n+# A note about host libraries:\n+#\n+# The only libraries that get promoted to stageN/lib are those needed\n+# by rustc. In general, rustc programs, even those compiled for the\n+# host architecture will use libraries from the target\n+# directories. This gives rust some freedom to experiment with how\n+# libraries are managed and versioned without polluting the common\n+# areas of the filesystem.\n+#\n+# General rust binaries may stil live in the host bin directory; they\n+# will just link against the libraries in the target lib directory.\n+#\n+# Admittedly this is a little convoluted.\n+\n ######################################################################\n # Residual auto-configuration\n ######################################################################\n@@ -142,12 +186,16 @@ COMPILER_INPUTS := $(wildcard $(addprefix $(S)src/comp/, \\\n # Exports for sub-utilities\n ######################################################################\n \n+# Note that any variable that re-configure should pick up needs to be\n+# exported\n+\n export CFG_SRC_DIR\n export CFG_BUILD_DIR\n export CFG_VERSION\n export CFG_HOST_TRIPLE\n export CFG_LLVM_ROOT\n export CFG_ENABLE_MINGW_CROSS\n+export CFG_PREFIX\n \n ######################################################################\n # Subprograms\n@@ -179,33 +227,34 @@ TARGET_HOST_ROOT$(1) = $$(TARGET_ROOT$(1)$$(CFG_HOST_TRIPLE))\n TARGET_HOST_BIN$(1) = $$(TARGET_BIN$(1)$$(CFG_HOST_TRIPLE))\n TARGET_HOST_LIB$(1) = $$(TARGET_LIB$(1)$$(CFG_HOST_TRIPLE))\n \n+# The name of the standard library used by rustc\n ifdef CFG_DISABLE_SHAREDSTD\n   HOST_STDLIB_DEFAULT$(1) = $$(HOST_LIB$(1))/libstd.rlib\n+  TARGET_STDLIB_DEFAULT$(1)$(2) = $$(TARGET_LIB$(1)$(2))/libstd.rlib\n else\n   HOST_STDLIB_DEFAULT$(1) = $$(HOST_LIB$(1))/$(CFG_STDLIB)\n+  TARGET_STDLIB_DEFAULT$(1)$(2) = $$(TARGET_LIB$(1)$(2))/$(CFG_STDLIB)\n endif\n \n-ifdef CFG_DISABLE_SHAREDSTD\n-SREQ$(1)$(2) = $$(HOST_BIN$(1))/rustc$(X)          \\\n-           $$(HOST_LIB$(1))/$$(CFG_RUNTIME)     \\\n-           $$(HOST_STDLIB_DEFAULT$(1)) \\\n-           $$(HOST_LIB$(1))/$$(CFG_RUSTLLVM)    \\\n-           $$(TARGET_LIB$(1)$(2))/$$(CFG_RUNTIME) \\\n-           $$(TARGET_LIB$(1)$(2))/$$(CFG_STDLIB) \\\n-           $$(TARGET_LIB$(1)$(2))/intrinsics.bc \\\n-           $$(TARGET_LIB$(1)$(2))/main.o \\\n-           $$(MKFILES)\n-else\n-SREQ$(1)$(2) = $$(HOST_BIN$(1))/rustc$(X)          \\\n-           $$(HOST_LIB$(1))/$$(CFG_RUNTIME)     \\\n-           $$(HOST_STDLIB_DEFAULT$(1)) \\\n-           $$(HOST_LIB$(1))/$$(CFG_RUSTLLVM)    \\\n-           $$(TARGET_LIB$(1)$(2))/$$(CFG_RUNTIME) \\\n-           $$(TARGET_LIB$(1)$(2))/$$(CFG_STDLIB) \\\n-           $$(TARGET_LIB$(1)$(2))/intrinsics.bc \\\n-           $$(TARGET_LIB$(1)$(2))/main.o \\\n-           $$(MKFILES)\n-endif\n+# Preqrequisites for using the stageN compiler\n+HOST_SREQ$(1) = \\\n+\t$$(HOST_BIN$(1))/rustc$$(X) \\\n+\t$$(HOST_LIB$(1))/$$(CFG_RUNTIME) \\\n+\t$$(HOST_LIB$(1))/$$(CFG_RUSTLLVM) \\\n+\t$$(HOST_STDLIB_DEFAULT$(1)) \\\n+\t$$(MKFILES)\n+\n+# Prerequisites for using the stageN compiler to build target artifacts\n+TARGET_SREQ$(1)$(2) = \\\n+\t$$(HOST_SREQ$(1)) \\\n+\t$$(TARGET_LIB$(1)$(2))/$$(CFG_RUNTIME) \\\n+\t$$(TARGET_LIB$(1)$(2))/intrinsics.bc \\\n+\t$$(TARGET_LIB$(1)$(2))/main.o\n+\n+# Prerequisites for complete stageN targets\n+SREQ$(1)$(2) = \\\n+\t$$(TARGET_SREQ$(1)$(2)) \\\n+\t$$(TARGET_LIB$(1)$(2))/$$(CFG_STDLIB)\n \n ifeq ($(1),0)\n # Don't run the the stage0 compiler under valgrind - that ship has sailed\n@@ -241,16 +290,14 @@ CFG_INFO := $(info cfg: *** compiler is in snapshot transition ***)\n CFG_INFO := $(info cfg: *** stage2 and later will not be built ***)\n CFG_INFO := $(info cfg:)\n \n-FUZZ := $(HOST_BIN1)/fuzzer$(X)\n+all: $(SREQ1$(CFG_HOST_TRIPLE)) $(GENERATED) $(DOCS)\n \n-all: $(SREQ0$(CFG_HOST_TRIPLE)) $(SREQ1$(CFG_HOST_TRIPLE)) \\\n-     $(GENERATED) $(DOCS) $(FUZZ)\n else\n \n-ALL_SREQS = $(foreach target,$(CFG_TARGET_TRIPLES), \\\n- $(SREQ0$(target)) $(SREQ1$(target)) $(SREQ2$(target)) $(SREQ3$(target)))\n+FUZZ := $(HOST_BIN3)/fuzzer$(X)\n+\n+all: $(SREQ3$(CFG_HOST_TRIPLE)) $(GENERATED) $(DOCS) $(FUZZ)\n \n-all: $(ALL_SREQS) $(GENERATED) $(DOCS) $(FUZZ)\n endif\n \n \n@@ -268,7 +315,8 @@ config.mk: $(S)configure $(S)Makefile.in $(S)src/snapshots.txt\n ######################################################################\n \n include $(CFG_SRC_DIR)/mk/intrinsics.mk\n-include $(CFG_SRC_DIR)/mk/stageN.mk\n+include $(CFG_SRC_DIR)/mk/target.mk\n+include $(CFG_SRC_DIR)/mk/host.mk\n include $(CFG_SRC_DIR)/mk/stage0.mk\n include $(CFG_SRC_DIR)/mk/rt.mk\n include $(CFG_SRC_DIR)/mk/rustllvm.mk"}, {"sha": "32bfccf0bdbc6b9be3cd0c39842479112aa2a1ac", "filename": "configure", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e654564db85819ef401eeb4e950acf02096796c/configure", "raw_url": "https://github.com/rust-lang/rust/raw/6e654564db85819ef401eeb4e950acf02096796c/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=6e654564db85819ef401eeb4e950acf02096796c", "patch": "@@ -223,6 +223,11 @@ opt mingw-cross 0 \"cross-compile for win32 using mingw\"\n \n if [ $HELP -eq 1 ]\n then\n+    echo \"\"\n+    echo \"Useful environment variables:\"\n+    echo \"\"\n+    printf \"    %-32s %s\\n\" \"CFG_LLVM_ROOT\" \"The host LLVM install\"\n+    printf \"    %-32s %s\\n\" \"CFG_PREFIX\" \"The installation prefix\"\n     echo \"\"\n     exit 0\n fi"}, {"sha": "3fa470f6982fe5fb8ed008eefcb0171b6f1a7229", "filename": "mk/clean.mk", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6e654564db85819ef401eeb4e950acf02096796c/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6e654564db85819ef401eeb4e950acf02096796c/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=6e654564db85819ef401eeb4e950acf02096796c", "patch": "@@ -3,7 +3,8 @@\n ######################################################################\n \n CLEAN_STAGE_RULES = $(foreach target,$(CFG_TARGET_TRIPLES), \\\n- clean0$(target) clean1$(target) clean2$(target) clean3$(target))\n+ clean0$(target) clean1$(target) clean2$(target) clean3$(target)) \\\n+ clean0 clean1 clean2 clean3\n \n \n .PHONY: clean\n@@ -43,14 +44,20 @@ clean-misc:\n \n define CLEAN_STAGE_N\n \n-clean$(1)$(2):\n+clean$(1):\n \t$(Q)rm -f $$(HOST_BIN$(1))/rustc\n \t$(Q)rm -f $$(HOST_BIN$(1))/fuzzer\n \t$(Q)rm -f $$(HOST_LIB$(1))/$(CFG_RUNTIME)\n \t$(Q)rm -f $$(HOST_LIB$(1))/$(CFG_STDLIB)\n \t$(Q)rm -f $$(HOST_LIB$(1))/$(CFG_RUSTLLVM)\n+\t$(Q)rm -f $$(HOST_LIB$(1))/libstd.rlib\n+\n+clean$(1)$(2):\n+\t$(Q)rm -f $$(TARGET_BIN$(1)$(2))/rustc\n+\t$(Q)rm -f $$(TARGET_BIN$(1)$(2))/fuzzer\n \t$(Q)rm -f $$(TARGET_LIB$(1)$(2))/$(CFG_RUNTIME)\n \t$(Q)rm -f $$(TARGET_LIB$(1)$(2))/$(CFG_STDLIB)\n+\t$(Q)rm -f $$(TARGET_LIB$(1)$(2))/$(CFG_RUSTLLVM)\n \t$(Q)rm -f $$(TARGET_LIB$(1)$(2))/libstd.rlib\n \t$(Q)rm -f $$(TARGET_LIB$(1)$(2))/intrinsics.bc\n \t$(Q)rm -f $$(TARGET_LIB$(1)$(2))/main.o"}, {"sha": "ced5d6ce6fe68465984b57edbbdcfe04882c3345", "filename": "mk/fuzzer.mk", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6e654564db85819ef401eeb4e950acf02096796c/mk%2Ffuzzer.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6e654564db85819ef401eeb4e950acf02096796c/mk%2Ffuzzer.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ffuzzer.mk?ref=6e654564db85819ef401eeb4e950acf02096796c", "patch": "@@ -3,14 +3,23 @@ FUZZER_INPUTS := $(wildcard $(addprefix $(S)src/fuzzer/, *.rs))\n \n define FUZZ_STAGE_N\n \n-stage$(2)/bin/fuzzer$$(X): $$(FUZZER_CRATE) $$(FUZZER_INPUTS) \\\n-                          $$(SREQ$(2)$$(CFG_HOST_TRIPLE)) \\\n-                          $$(HOST_LIB$(2))/$$(CFG_RUNTIME) \\\n-                          $$(HOST_LIB$(2))/$$(CFG_RUSTLLVM) \\\n-                          $$(HOST_LIB$(2))/$$(CFG_STDLIB) \\\n-                          $$(HOST_LIB$(2))/$$(CFG_LIBRUSTC)\n+# We only really care about fuzzing on the host arch\n+$$(TARGET_BIN$(1)$(CFG_HOST_TRIPLE))/fuzzer$$(X): \\\n+\t$$(FUZZER_CRATE) $$(FUZZER_INPUTS) \\\n+\t$$(TARGET_SREQ$(1)$(CFG_HOST_TRIPLE)) \\\n+\t$$(TARGET_LIB$(1)$(CFG_HOST_TRIPLE))/$$(CFG_STDLIB) \\\n+\t$$(TARGET_LIB$(1)$(CFG_HOST_TRIPLE))/$$(CFG_LIBRUSTC)\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)) -L $$(HOST_LIB$(2)) -o $$@ $$<\n+\t$$(STAGE$(1)) -o $$@ $$<\n+\n+# Promote the stageN target to stageN+1 host\n+# FIXME: Shouldn't need to depend on host/librustc.so once\n+# rpath is working\n+$$(HOST_BIN$(2))/fuzzer$$(X): \\\n+\t$$(TARGET_BIN$(1)$(CFG_HOST_TRIPLE))/fuzzer$$(X) \\\n+\t$$(HOST_LIB$(2))/$$(CFG_LIBRUSTC)\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n \n endef\n "}, {"sha": "31e995d22c63e48d13e8348f0763148742c3434f", "filename": "mk/host.mk", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6e654564db85819ef401eeb4e950acf02096796c/mk%2Fhost.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6e654564db85819ef401eeb4e950acf02096796c/mk%2Fhost.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fhost.mk?ref=6e654564db85819ef401eeb4e950acf02096796c", "patch": "@@ -0,0 +1,56 @@\n+# HOST_STAGE_N template: arg 1 is the N we're promoting *from*, arg 2\n+# is N+1. Must be invoked to promote target artifacts to host artifacts\n+# for stage 1-3 (stage0 host artifacts come from the snapshot).\n+#\n+# The easiest way to read this template is to assume we're promoting\n+# stage1 to stage2 and mentally gloss $(1) as 1, $(2) as 2.\n+\n+define HOST_STAGE_N\n+\n+# Host libraries and executables (stage$(2)/bin/rustc and its runtime needs)\n+\n+$$(HOST_BIN$(2))/rustc$$(X): \\\n+\t$$(TARGET_HOST_BIN$(1))/rustc$$(X) \\\n+\t$$(HOST_LIB$(2))/$$(CFG_RUNTIME) \\\n+\t$$(HOST_LIB$(2))/$$(CFG_RUSTLLVM) \\\n+\t$$(HOST_STDLIB_DEFAULT$(2))\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n+# FIXME: The fuzzer depends on this. Remove once it's rpathed to correctly\n+# find it in the appropriate target directory\n+$$(HOST_LIB$(2))/$$(CFG_LIBRUSTC): \\\n+\t$$(TARGET_HOST_LIB$(1))/$$(CFG_LIBRUSTC) \\\n+\t$$(HOST_LIB$(2))/$$(CFG_RUNTIME) \\\n+\t$$(HOST_LIB$(2))/$$(CFG_RUSTLLVM) \\\n+\t$$(HOST_STDLIB_DEFAULT$(2))\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n+$$(HOST_LIB$(2))/$$(CFG_RUNTIME): \\\n+\t$$(TARGET_HOST_LIB$(1))/$$(CFG_RUNTIME)\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n+$$(HOST_LIB$(2))/$$(CFG_STDLIB): \\\n+\t$$(TARGET_HOST_LIB$(1))/$$(CFG_STDLIB) \\\n+\t$$(HOST_LIB$(2))/$$(CFG_RUNTIME)\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n+$$(HOST_LIB$(2))/libstd.rlib: \\\n+\t$$(TARGET_HOST_LIB$(1))/libstd.rlib \\\n+\t$$(HOST_LIB$(2))/$$(CFG_RUNTIME)\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n+$$(HOST_LIB$(2))/$$(CFG_RUSTLLVM): \\\n+\t$$(TARGET_HOST_LIB$(1))/$$(CFG_RUSTLLVM)\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n+endef\n+\n+$(eval $(call HOST_STAGE_N,0,1))\n+$(eval $(call HOST_STAGE_N,1,2))\n+$(eval $(call HOST_STAGE_N,2,3))"}, {"sha": "badad0b1aac5467e071c5fcf6d27c6a35e9123ee", "filename": "mk/install.mk", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6e654564db85819ef401eeb4e950acf02096796c/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6e654564db85819ef401eeb4e950acf02096796c/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=6e654564db85819ef401eeb4e950acf02096796c", "patch": "@@ -1,10 +1,11 @@\n ifdef VERBOSE\n  INSTALL = cp $(1)/$(3) $(2)/$(3)\n else\n- INSTALL = @$(call E, install $(2)/$(3)) && cp $(1)/$(3) $(2)/$(3)\n+ INSTALL = @$(call E, install: $(2)/$(3)) && cp $(1)/$(3) $(2)/$(3)\n endif\n \n-ISTAGE = 1\n+# The stage we install from\n+ISTAGE = 3\n \n PREFIX_ROOT = $(CFG_PREFIX)\n PREFIX_BIN = $(PREFIX_ROOT)/bin"}, {"sha": "7a0ed8ddb92f6540a9ff27878b8d0e74fed6a189", "filename": "mk/snap.mk", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e654564db85819ef401eeb4e950acf02096796c/mk%2Fsnap.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6e654564db85819ef401eeb4e950acf02096796c/mk%2Fsnap.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fsnap.mk?ref=6e654564db85819ef401eeb4e950acf02096796c", "patch": "@@ -1,12 +1,9 @@\n \n-snap-stage1: $(HOST_BIN1)/rustc$(X) $(HOST_LIB1)/$(CFG_RUNTIME) \\\n-\t$(HOST_LIB1)/$(CFG_RUSTLLVM) $(HOST_LIB1)/$(CFG_STDLIB)\n+snap-stage1: $(HOST_SREQ1)\n \t$(S)src/etc/make-snapshot.py stage1\n \n-snap-stage2: $(HOST_BIN2)/rustc$(X) $(HOST_LIB2)/$(CFG_RUNTIME) \\\n-\t$(HOST_LIB2)/$(CFG_RUSTLLVM) $(HOST_LIB2)/$(CFG_STDLIB)\n+snap-stage2: $(HOST_SREQ2)\n \t$(S)src/etc/make-snapshot.py stage2\n \n-snap-stage3: $(HOST_BIN3)/rustc$(X) $(HOST_LIB3)/$(CFG_RUNTIME) \\\n-\t$(HOST_LIB3)/$(CFG_RUSTLLVM) $(HOST_LIB3)/$(CFG_STDLIB)\n+snap-stage3: $(HOST_SREQ3)\n \t$(S)src/etc/make-snapshot.py stage3"}, {"sha": "c2cb26da52787d894bd6563538115f93eb2cf168", "filename": "mk/stage0.mk", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e654564db85819ef401eeb4e950acf02096796c/mk%2Fstage0.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6e654564db85819ef401eeb4e950acf02096796c/mk%2Fstage0.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage0.mk?ref=6e654564db85819ef401eeb4e950acf02096796c", "patch": "@@ -1,9 +1,13 @@\n-$(HOST_BIN0)/rustc$(X): $(S)src/snapshots.txt $(S)src/etc/get-snapshot.py $(MKFILES)\n+# Extract the snapshot host compiler\n+\n+$(HOST_BIN0)/rustc$(X): \\\n+\t$(S)src/snapshots.txt \\\n+\t$(S)src/etc/get-snapshot.py $(MKFILES)\n \t@$(call E, fetch: $@)\n \t$(Q)$(S)src/etc/get-snapshot.py\n \t$(Q)touch $@\n \n-# Host libs will be made in the process of making rustc above.\n+# Host libs will be extracted by the above rule\n \n $(HOST_LIB0)/$(CFG_RUNTIME): $(HOST_BIN0)/rustc$(X)\n \t$(Q)touch $@\n@@ -13,10 +17,3 @@ $(HOST_LIB0)/$(CFG_STDLIB): $(HOST_BIN0)/rustc$(X)\n \n $(HOST_LIB0)/$(CFG_RUSTLLVM): $(HOST_BIN0)/rustc$(X)\n \t$(Q)touch $@\n-\n-# Instantiate template (in stageN.mk) for building\n-# target libraries.\n-\n-SREQpre = $(MKFILES)\n-$(eval $(call TARGET_LIBS,pre,0,$(CFG_HOST_TRIPLE)))\n-"}, {"sha": "f64c0088d29461c9740bad88b2798a2db7a4e2da", "filename": "mk/stageN.mk", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9563c17d78570dc5646786c142a0f0b68a86dd3e/mk%2FstageN.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9563c17d78570dc5646786c142a0f0b68a86dd3e/mk%2FstageN.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2FstageN.mk?ref=9563c17d78570dc5646786c142a0f0b68a86dd3e", "patch": "@@ -1,113 +0,0 @@\n-# STAGE_N template: arg 1 is the N we're building *from*, arg 2 is N+1, arg 3\n-# is the target triple we're building for. You have to invoke this for each\n-# target triple.\n-#\n-# The easiest way to read this template is to assume we're building stage2\n-# using stage1, and mentally gloss $(1) as 1, $(2) as 2.\n-#\n-# TARGET_LIBS is pulled out seperately because we need to specially invoke\n-# it to build stage0/lib/libstd using stage0/rustc and to use the\n-# new rustrt in stage0/lib/.\n-\n-define STAGE_N\n-\n-# Host libraries and executables (stage$(2)/rustc and its runtime needs)\n-#\n-# NB: Due to make not wanting to run the same implicit rules twice on the same\n-# rule tree (implicit-rule recursion prevention, see \"Chains of Implicit\n-# Rules\" in GNU Make manual) we have to re-state the %.o and %.s patterns here\n-# for different directories, to handle cases where (say) a test relies on a\n-# compiler that relies on a .o file.\n-\n-$$(HOST_BIN$(2))/%.o: $$(HOST_BIN$(2))/%.s\n-\t@$$(call E, assemble [gcc]: $$@)\n-\t$$(Q)gcc $$(CFG_GCCISH_CFLAGS) -o $$@ -c $$<\n-\n-$$(HOST_LIB$(2))/%.o: $$(HOST_LIB$(2))/%.s\n-\t@$$(call E, assemble [gcc]: $$@)\n-\t$$(Q)gcc $$(CFG_GCCISH_CFLAGS) -o $$@ -c $$<\n-\n-$$(HOST_BIN$(2))/rustc$$(X): $$(COMPILER_CRATE) $$(COMPILER_INPUTS)          \\\n-                          $$(HOST_LIB$(2))/$$(CFG_RUNTIME)                       \\\n-                          $$(HOST_STDLIB_DEFAULT$(2)) \\\n-                          $$(HOST_LIB$(2))/$$(CFG_RUSTLLVM)                      \\\n-                          $$(SREQ$(1)$(3))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)) -L $$(HOST_LIB$(2)) -o $$@ $$<\n-\n-$$(HOST_LIB$(2))/$$(CFG_LIBRUSTC): \\\n-          $$(COMPILER_CRATE) $$(COMPILER_INPUTS) \\\n-          $$(SREQ$(2)$(3))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)) -L $$(HOST_LIB$(2)) --lib -o $$@ $$<\n-\n-$$(HOST_LIB$(2))/$$(CFG_RUNTIME): rt/$$(CFG_RUNTIME)\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n-$$(HOST_LIB$(2))/$$(CFG_STDLIB): $$(TARGET_HOST_LIB$(1))/$$(CFG_STDLIB)\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n-$$(HOST_LIB$(2))/libstd.rlib: $$(TARGET_HOST_LIB$(1))/libstd.rlib\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n-$$(HOST_LIB$(2))/$$(CFG_RUSTLLVM): rustllvm/$$(CFG_RUSTLLVM)\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n-# Expand out target libraries\n-\n-$(eval $(call TARGET_LIBS,$(1),$(2),$(3)))\n-\n-endef\n-\n-\n-define TARGET_LIBS\n-\n-# New per-target-arch target libraries; when we've transitioned to\n-# using these exclusively, you should delete the non-arch-prefixed\n-# rules above. They're duplicates, redundant.\n-\n-$$(TARGET_LIB$(2)$(3))/intrinsics.bc: $$(INTRINSICS_BC)\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n-$$(TARGET_LIB$(2)$(3))/main.o: rt/main.o\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n-$$(TARGET_LIB$(2)$(3))/$$(CFG_STDLIB): \\\n-        $$(STDLIB_CRATE) $$(STDLIB_INPUTS) \\\n-        $$(HOST_BIN$(2))/rustc$$(X)               \\\n-        $$(HOST_LIB$(2))/$$(CFG_RUNTIME)          \\\n-        $$(HOST_LIB$(2))/$$(CFG_RUSTLLVM)         \\\n-        $$(TARGET_LIB$(2)$(3))/intrinsics.bc        \\\n-        $$(SREQ$(1)$(3))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(2))  --lib -o $$@ $$<\n-\n-$$(TARGET_LIB$(2)$(3))/libstd.rlib: \\\n-        $$(STDLIB_CRATE) $$(STDLIB_INPUTS) \\\n-        $$(HOST_BIN$(2))/rustc$$(X)               \\\n-        $$(HOST_LIB$(2))/$$(CFG_RUNTIME)          \\\n-        $$(HOST_LIB$(2))/$$(CFG_RUSTLLVM)         \\\n-        $$(TARGET_LIB$(2)$(3))/intrinsics.bc        \\\n-        $$(SREQ$(1)$(3))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(2)) --lib --static -o $$@ $$<\n-\n-$$(TARGET_LIB$(2)$(3))/$$(CFG_RUNTIME): rt/$$(CFG_RUNTIME)\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n-endef\n-\n-\n-\n-# Instantiate template for 0->1, 1->2, 2->3 build dirs\n-$(foreach target,$(CFG_TARGET_TRIPLES), \\\n- $(eval $(call STAGE_N,0,1,$(target)))   \\\n- $(eval $(call STAGE_N,1,2,$(target)))   \\\n- $(eval $(call STAGE_N,2,3,$(target))))"}, {"sha": "ccbfba2438303c0eba83966c7c48051371930338", "filename": "mk/target.mk", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6e654564db85819ef401eeb4e950acf02096796c/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6e654564db85819ef401eeb4e950acf02096796c/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=6e654564db85819ef401eeb4e950acf02096796c", "patch": "@@ -0,0 +1,61 @@\n+# TARGET_STAGE_N template: This defines how target artifacts are built\n+# for all stage/target architecture combinations. Argument 1 is the\n+# stage and arg 2 is the target triple\n+\n+# FIXME: We don't actually know how to build many of these when host\n+# and target architectures are not the same\n+\n+define TARGET_STAGE_N\n+\n+$$(TARGET_LIB$(1)$(2))/intrinsics.bc: $$(INTRINSICS_BC)\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n+$$(TARGET_LIB$(1)$(2))/main.o: rt/main.o\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n+$$(TARGET_LIB$(1)$(2))/$$(CFG_STDLIB): \\\n+\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS) \\\n+        $$(TARGET_SREQ$(1)$(2))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1))  --lib -o $$@ $$<\n+\n+$$(TARGET_LIB$(1)$(2))/libstd.rlib: \\\n+\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS) \\\n+        $$(TARGET_SREQ$(1)$(2))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)) --lib --static -o $$@ $$<\n+\n+$$(TARGET_LIB$(1)$(2))/$$(CFG_RUNTIME): rt/$$(CFG_RUNTIME)\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n+$$(TARGET_LIB$(1)$(2))/$$(CFG_RUSTLLVM): rustllvm/$$(CFG_RUSTLLVM)\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\n+$$(TARGET_BIN$(1)$(2))/rustc$$(X): \\\n+\t$$(COMPILER_CRATE) $$(COMPILER_INPUTS) \\\n+\t$$(TARGET_SREQ$(1)$(2)) \\\n+\t$$(TARGET_LIB$(1)$(2))/$$(CFG_RUSTLLVM) \\\n+\t$$(TARGET_STDLIB_DEFAULT$(1)$(2))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)) -o $$@ $$<\n+\n+$$(TARGET_LIB$(1)$(2))/$$(CFG_LIBRUSTC): \\\n+\t$$(COMPILER_CRATE) $$(COMPILER_INPUTS) \\\n+\t$$(TARGET_SREQ$(1)$(2)) \\\n+\t$$(TARGET_LIB$(1)$(2))/$$(CFG_RUSTLLVM) \\\n+\t$$(TARGET_STDLIB_DEFAULT$(1)$(2))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)) --lib -o $$@ $$<\n+\n+endef\n+\n+# Instantiate template for all stages\n+$(foreach target,$(CFG_TARGET_TRIPLES), \\\n+ $(eval $(call TARGET_STAGE_N,0,$(target))) \\\n+ $(eval $(call TARGET_STAGE_N,1,$(target))) \\\n+ $(eval $(call TARGET_STAGE_N,2,$(target))) \\\n+ $(eval $(call TARGET_STAGE_N,3,$(target))))"}]}