{"sha": "351c29d859d74f7a61e654bdbcad634bfb136225", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MWMyOWQ4NTlkNzRmN2E2MWU2NTRiZGJjYWQ2MzRiZmIxMzYyMjU=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-11-16T11:53:13Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-11-16T12:25:54Z"}, "message": "Fix handling of the binders in dyn/impl Trait\n\nWe need to be more careful now when substituting bound variables (previously, we\ndidn't have anything that used bound variables except Chalk, so it was not a\nproblem).\n\nThis is obviously quite ad-hoc; Chalk has more infrastructure for handling this\nin a principled way, which we maybe should adopt.", "tree": {"sha": "39289f3a5fd0d828780ffa3128317afc8a0598e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39289f3a5fd0d828780ffa3128317afc8a0598e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/351c29d859d74f7a61e654bdbcad634bfb136225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/351c29d859d74f7a61e654bdbcad634bfb136225", "html_url": "https://github.com/rust-lang/rust/commit/351c29d859d74f7a61e654bdbcad634bfb136225", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/351c29d859d74f7a61e654bdbcad634bfb136225/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c2a9a9a0635e53466749fdedcdc5a371e658cde", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c2a9a9a0635e53466749fdedcdc5a371e658cde", "html_url": "https://github.com/rust-lang/rust/commit/9c2a9a9a0635e53466749fdedcdc5a371e658cde"}], "stats": {"total": 161, "additions": 116, "deletions": 45}, "files": [{"sha": "a5413518806f6fedbf3560e9e31b5089af29932b", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 57, "deletions": 32, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/351c29d859d74f7a61e654bdbcad634bfb136225/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/351c29d859d74f7a61e654bdbcad634bfb136225/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=351c29d859d74f7a61e654bdbcad634bfb136225", "patch": "@@ -224,8 +224,8 @@ impl TypeWalk for ProjectionTy {\n         self.parameters.walk(f);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.parameters.walk_mut(f);\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.parameters.walk_mut_binders(f, binders);\n     }\n }\n \n@@ -291,6 +291,20 @@ pub enum Ty {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs(Arc<[Ty]>);\n \n+impl TypeWalk for Substs {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.0.iter() {\n+            t.walk(f);\n+        }\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        for t in make_mut_slice(&mut self.0) {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n impl Substs {\n     pub fn empty() -> Substs {\n         Substs(Arc::new([]))\n@@ -304,18 +318,6 @@ impl Substs {\n         Substs(self.0[..std::cmp::min(self.0.len(), n)].into())\n     }\n \n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.0.iter() {\n-            t.walk(f);\n-        }\n-    }\n-\n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        for t in make_mut_slice(&mut self.0) {\n-            t.walk_mut(f);\n-        }\n-    }\n-\n     pub fn as_single(&self) -> &Ty {\n         if self.0.len() != 1 {\n             panic!(\"expected substs of len 1, got {:?}\", self);\n@@ -440,8 +442,8 @@ impl TypeWalk for TraitRef {\n         self.substs.walk(f);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.substs.walk_mut(f);\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.substs.walk_mut_binders(f, binders);\n     }\n }\n \n@@ -491,10 +493,12 @@ impl TypeWalk for GenericPredicate {\n         }\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n         match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut(f),\n-            GenericPredicate::Projection(projection_pred) => projection_pred.walk_mut(f),\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut_binders(f, binders),\n+            GenericPredicate::Projection(projection_pred) => {\n+                projection_pred.walk_mut_binders(f, binders)\n+            }\n             GenericPredicate::Error => {}\n         }\n     }\n@@ -544,9 +548,9 @@ impl TypeWalk for FnSig {\n         }\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n         for t in make_mut_slice(&mut self.params_and_return) {\n-            t.walk_mut(f);\n+            t.walk_mut_binders(f, binders);\n         }\n     }\n }\n@@ -671,7 +675,20 @@ impl Ty {\n /// types, similar to Chalk's `Fold` trait.\n pub trait TypeWalk {\n     fn walk(&self, f: &mut impl FnMut(&Ty));\n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty));\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.walk_mut_binders(&mut |ty, _binders| f(ty), 0);\n+    }\n+    /// Walk the type, counting entered binders.\n+    ///\n+    /// `Ty::Bound` variables use DeBruijn indexing, which means that 0 refers\n+    /// to the innermost binder, 1 to the next, etc.. So when we want to\n+    /// substitute a certain bound variable, we can't just walk the whole type\n+    /// and blindly replace each instance of a certain index; when we 'enter'\n+    /// things that introduce new bound variables, we have to keep track of\n+    /// that. Currently, the only thing that introduces bound variables on our\n+    /// side are `Ty::Dyn` and `Ty::Opaque`, which each introduce a bound\n+    /// variable for the self type.\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize);\n \n     fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n     where\n@@ -700,14 +717,22 @@ pub trait TypeWalk {\n     }\n \n     /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n-    fn subst_bound_vars(self, substs: &Substs) -> Self\n+    fn subst_bound_vars(mut self, substs: &Substs) -> Self\n     where\n         Self: Sized,\n     {\n-        self.fold(&mut |ty| match ty {\n-            Ty::Bound(idx) => substs.get(idx as usize).cloned().unwrap_or_else(|| Ty::Bound(idx)),\n-            ty => ty,\n-        })\n+        self.walk_mut_binders(\n+            &mut |ty, binders| match ty {\n+                &mut Ty::Bound(idx) => {\n+                    if idx as usize >= binders && (idx as usize - binders) < substs.len() {\n+                        *ty = substs.0[idx as usize - binders].clone();\n+                    }\n+                }\n+                _ => {}\n+            },\n+            0,\n+        );\n+        self\n     }\n \n     /// Shifts up `Ty::Bound` vars by `n`.\n@@ -748,22 +773,22 @@ impl TypeWalk for Ty {\n         f(self);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n         match self {\n             Ty::Apply(a_ty) => {\n-                a_ty.parameters.walk_mut(f);\n+                a_ty.parameters.walk_mut_binders(f, binders);\n             }\n             Ty::Projection(p_ty) => {\n-                p_ty.parameters.walk_mut(f);\n+                p_ty.parameters.walk_mut_binders(f, binders);\n             }\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n                 for p in make_mut_slice(predicates) {\n-                    p.walk_mut(f);\n+                    p.walk_mut_binders(f, binders + 1);\n                 }\n             }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n-        f(self);\n+        f(self, binders);\n     }\n }\n "}, {"sha": "64d9394cf73b8d466d96b2dfc768b48ddf01220f", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/351c29d859d74f7a61e654bdbcad634bfb136225/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/351c29d859d74f7a61e654bdbcad634bfb136225/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=351c29d859d74f7a61e654bdbcad634bfb136225", "patch": "@@ -134,17 +134,19 @@ where\n }\n \n impl<T> Canonicalized<T> {\n-    pub fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Bound(idx) => {\n-                if (idx as usize) < self.free_vars.len() {\n-                    Ty::Infer(self.free_vars[idx as usize])\n-                } else {\n-                    Ty::Bound(idx)\n+    pub fn decanonicalize_ty(&self, mut ty: Ty) -> Ty {\n+        ty.walk_mut_binders(\n+            &mut |ty, binders| match ty {\n+                &mut Ty::Bound(idx) => {\n+                    if idx as usize >= binders && (idx as usize - binders) < self.free_vars.len() {\n+                        *ty = Ty::Infer(self.free_vars[idx as usize - binders]);\n+                    }\n                 }\n-            }\n-            ty => ty,\n-        })\n+                _ => {}\n+            },\n+            0,\n+        );\n+        ty\n     }\n \n     pub fn apply_solution("}, {"sha": "ca16936796b57045170d13f606d5900d7fac8b32", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/351c29d859d74f7a61e654bdbcad634bfb136225/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/351c29d859d74f7a61e654bdbcad634bfb136225/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=351c29d859d74f7a61e654bdbcad634bfb136225", "patch": "@@ -4184,6 +4184,49 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     );\n }\n \n+#[test]\n+fn impl_trait_assoc_binding_projection_bug() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+pub trait Language {\n+    type Kind;\n+}\n+pub enum RustLanguage {}\n+impl Language for RustLanguage {\n+    type Kind = SyntaxKind;\n+}\n+struct SyntaxNode<L> {}\n+fn foo() -> impl Iterator<Item = SyntaxNode<RustLanguage>> {}\n+\n+trait Clone {\n+    fn clone(&self) -> Self;\n+}\n+\n+fn api_walkthrough() {\n+    for node in foo() {\n+        node.clone()<|>;\n+    }\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use iter::*;\n+mod iter {\n+    trait IntoIterator {\n+        type Item;\n+    }\n+    trait Iterator {\n+        type Item;\n+    }\n+    impl<T: Iterator> IntoIterator for T {\n+        type Item = <T as Iterator>::Item;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"{unknown}\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn projection_eq_within_chalk() {\n     // std::env::set_var(\"CHALK_DEBUG\", \"1\");"}, {"sha": "99dbab99eac7d710f0a333a472ff3754198f99f0", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/351c29d859d74f7a61e654bdbcad634bfb136225/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/351c29d859d74f7a61e654bdbcad634bfb136225/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=351c29d859d74f7a61e654bdbcad634bfb136225", "patch": "@@ -165,9 +165,9 @@ impl TypeWalk for ProjectionPredicate {\n         self.ty.walk(f);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.projection_ty.walk_mut(f);\n-        self.ty.walk_mut(f);\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.projection_ty.walk_mut_binders(f, binders);\n+        self.ty.walk_mut_binders(f, binders);\n     }\n }\n \n@@ -188,6 +188,7 @@ pub(crate) fn trait_solve_query(\n     }\n \n     let canonical = goal.to_chalk(db).cast();\n+\n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n     let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };"}]}