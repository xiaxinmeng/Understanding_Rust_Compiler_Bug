{"sha": "45cde975cb9b5f3ebe1261b5a962c75731e884e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1Y2RlOTc1Y2I5YjVmM2ViZTEyNjFiNWE5NjJjNzU3MzFlODg0ZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-21T04:04:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-21T04:04:48Z"}, "message": "Auto merge of #34189 - eddyb:mir-trans-imm, r=nagisa\n\ntrans: generalize immediate temporaries to all MIR locals.\n\nAdded `Mir::local_index` which gives you an unified index for `Arg`, `Var`, `Temp` and `ReturnPointer`.\nAlso available is `Mir::count_locals` which returns the total number of the above locals.\nThis simplifies a lot of the code which can treat all of the local lvalues in the same manner.\nIf we had `-> impl Iterator`, I could have added a bunch of useful `Ty` or `Lvalue` iterators for all locals.\nWe could of course manually write such iterators as they are needed.\n\nThe only place which currently takes advantage of unified locals is trans' alloca elision.\nCurrently it's not as good as it could be, due to our usage of `llvm.dbg.declare` in debug mode.\nBut passing some arguments and variables as immediates has some effect on release-mode `libsyntax`:\n\nOld trans:\n```\ntime: 11.500; rss: 710MB        translation\ntime: 0.002; rss: 710MB assert dep graph\ntime: 0.000; rss: 710MB serialize dep graph\n  time: 4.410; rss: 628MB       llvm function passes [0]\n  time: 84.485; rss: 633MB      llvm module passes [0]\n  time: 23.898; rss: 634MB      codegen passes [0]\n  time: 0.002; rss: 634MB       codegen passes [0]\ntime: 113.408; rss: 634MB       LLVM passes\n```\n`-Z orbit`, previously:\n```\ntime: 12.588; rss: 723MB        translation\ntime: 0.002; rss: 723MB assert dep graph\ntime: 0.000; rss: 723MB serialize dep graph\n  time: 4.597; rss: 642MB       llvm function passes [0]\n  time: 77.347; rss: 646MB      llvm module passes [0]\n  time: 24.703; rss: 648MB      codegen passes [0]\n  time: 0.002; rss: 615MB       codegen passes [0]\ntime: 107.233; rss: 615MB       LLVM passes\n```\n`-Z orbit`, after this PR:\n```\ntime: 13.820; rss: 672MB        translation\ntime: 0.002; rss: 672MB assert dep graph\ntime: 0.000; rss: 672MB serialize dep graph\n  time: 3.969; rss: 591MB       llvm function passes [0]\n  time: 72.294; rss: 595MB      llvm module passes [0]\n  time: 24.610; rss: 597MB      codegen passes [0]\n  time: 0.002; rss: 597MB       codegen passes [0]\ntime: 101.439; rss: 597MB       LLVM passes\n```", "tree": {"sha": "d4a3c7d587c7f82b88ada6a28883919da4c3ec9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4a3c7d587c7f82b88ada6a28883919da4c3ec9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45cde975cb9b5f3ebe1261b5a962c75731e884e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45cde975cb9b5f3ebe1261b5a962c75731e884e4", "html_url": "https://github.com/rust-lang/rust/commit/45cde975cb9b5f3ebe1261b5a962c75731e884e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45cde975cb9b5f3ebe1261b5a962c75731e884e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ba60aba387b19267cace9759d9cf14682b72871", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ba60aba387b19267cace9759d9cf14682b72871", "html_url": "https://github.com/rust-lang/rust/commit/4ba60aba387b19267cace9759d9cf14682b72871"}, {"sha": "7279af86c8f6ab080e7d360e497e1c75b313d1a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7279af86c8f6ab080e7d360e497e1c75b313d1a1", "html_url": "https://github.com/rust-lang/rust/commit/7279af86c8f6ab080e7d360e497e1c75b313d1a1"}], "stats": {"total": 837, "additions": 497, "deletions": 340}, "files": [{"sha": "a6052f9aa75a13519ecd4ea96e4b647ebfc189ff", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -144,6 +144,40 @@ impl<'tcx> Mir<'tcx> {\n     pub fn predecessors_for(&self, bb: BasicBlock) -> Ref<Vec<BasicBlock>> {\n         Ref::map(self.predecessors(), |p| &p[bb])\n     }\n+\n+    /// Maps locals (Arg's, Var's, Temp's and ReturnPointer, in that order)\n+    /// to their index in the whole list of locals. This is useful if you\n+    /// want to treat all locals the same instead of repeating yourself.\n+    pub fn local_index(&self, lvalue: &Lvalue<'tcx>) -> Option<Local> {\n+        let idx = match *lvalue {\n+            Lvalue::Arg(arg) => arg.index(),\n+            Lvalue::Var(var) => {\n+                self.arg_decls.len() +\n+                var.index()\n+            }\n+            Lvalue::Temp(temp) => {\n+                self.arg_decls.len() +\n+                self.var_decls.len() +\n+                temp.index()\n+            }\n+            Lvalue::ReturnPointer => {\n+                self.arg_decls.len() +\n+                self.var_decls.len() +\n+                self.temp_decls.len()\n+            }\n+            Lvalue::Static(_) |\n+            Lvalue::Projection(_) => return None\n+        };\n+        Some(Local::new(idx))\n+    }\n+\n+    /// Counts the number of locals, such that that local_index\n+    /// will always return an index smaller than this count.\n+    pub fn count_locals(&self) -> usize {\n+        self.arg_decls.len() +\n+        self.var_decls.len() +\n+        self.temp_decls.len() + 1\n+    }\n }\n \n impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n@@ -663,6 +697,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n newtype_index!(Var, \"var\");\n newtype_index!(Temp, \"tmp\");\n newtype_index!(Arg, \"arg\");\n+newtype_index!(Local, \"local\");\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state."}, {"sha": "7c69618068a6b7c89597d3ae6cf23270d622e693", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -492,6 +492,13 @@ impl<'tcx> FnOutput<'tcx> {\n             ty::FnDiverging => def\n         }\n     }\n+\n+    pub fn maybe_converging(self) -> Option<Ty<'tcx>> {\n+        match self {\n+            ty::FnConverging(t) => Some(t),\n+            ty::FnDiverging => None\n+        }\n+    }\n }\n \n pub type PolyFnOutput<'tcx> = Binder<FnOutput<'tcx>>;"}, {"sha": "dac7afab6e38b4d85de41d18f1c2fae4b837c9d4", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 89, "deletions": 52, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! An analysis to determine which temporaries require allocas and\n+//! An analysis to determine which locals require allocas and\n //! which do not.\n \n use rustc_data_structures::bitvec::BitVector;\n@@ -18,18 +18,23 @@ use rustc::mir::repr::TerminatorKind;\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use common::{self, Block, BlockAndBuilder};\n+use glue;\n use super::rvalue;\n \n-pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n-                               mir: &mir::Mir<'tcx>) -> BitVector {\n+pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n+                                 mir: &mir::Mir<'tcx>) -> BitVector {\n     let bcx = bcx.build();\n-    let mut analyzer = TempAnalyzer::new(mir, &bcx, mir.temp_decls.len());\n+    let mut analyzer = LocalAnalyzer::new(mir, &bcx);\n \n     analyzer.visit_mir(mir);\n \n-    for (index, temp_decl) in mir.temp_decls.iter().enumerate() {\n-        let ty = bcx.monomorphize(&temp_decl.ty);\n-        debug!(\"temp {:?} has type {:?}\", index, ty);\n+    let local_types = mir.arg_decls.iter().map(|a| a.ty)\n+               .chain(mir.var_decls.iter().map(|v| v.ty))\n+               .chain(mir.temp_decls.iter().map(|t| t.ty))\n+               .chain(mir.return_ty.maybe_converging());\n+    for (index, ty) in local_types.enumerate() {\n+        let ty = bcx.monomorphize(&ty);\n+        debug!(\"local {} has type {:?}\", index, ty);\n         if ty.is_scalar() ||\n             ty.is_unique() ||\n             ty.is_region_ptr() ||\n@@ -49,76 +54,97 @@ pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n             // (e.g. structs) into an alloca unconditionally, just so\n             // that we don't have to deal with having two pathways\n             // (gep vs extractvalue etc).\n-            analyzer.mark_as_lvalue(index);\n+            analyzer.mark_as_lvalue(mir::Local::new(index));\n         }\n     }\n \n-    analyzer.lvalue_temps\n+    analyzer.lvalue_locals\n }\n \n-struct TempAnalyzer<'mir, 'bcx: 'mir, 'tcx: 'bcx> {\n+struct LocalAnalyzer<'mir, 'bcx: 'mir, 'tcx: 'bcx> {\n     mir: &'mir mir::Mir<'tcx>,\n     bcx: &'mir BlockAndBuilder<'bcx, 'tcx>,\n-    lvalue_temps: BitVector,\n+    lvalue_locals: BitVector,\n     seen_assigned: BitVector\n }\n \n-impl<'mir, 'bcx, 'tcx> TempAnalyzer<'mir, 'bcx, 'tcx> {\n+impl<'mir, 'bcx, 'tcx> LocalAnalyzer<'mir, 'bcx, 'tcx> {\n     fn new(mir: &'mir mir::Mir<'tcx>,\n-           bcx: &'mir BlockAndBuilder<'bcx, 'tcx>,\n-           temp_count: usize) -> TempAnalyzer<'mir, 'bcx, 'tcx> {\n-        TempAnalyzer {\n+           bcx: &'mir BlockAndBuilder<'bcx, 'tcx>)\n+           -> LocalAnalyzer<'mir, 'bcx, 'tcx> {\n+        let local_count = mir.count_locals();\n+        LocalAnalyzer {\n             mir: mir,\n             bcx: bcx,\n-            lvalue_temps: BitVector::new(temp_count),\n-            seen_assigned: BitVector::new(temp_count)\n+            lvalue_locals: BitVector::new(local_count),\n+            seen_assigned: BitVector::new(local_count)\n         }\n     }\n \n-    fn mark_as_lvalue(&mut self, temp: usize) {\n-        debug!(\"marking temp {} as lvalue\", temp);\n-        self.lvalue_temps.insert(temp);\n+    fn mark_as_lvalue(&mut self, local: mir::Local) {\n+        debug!(\"marking {:?} as lvalue\", local);\n+        self.lvalue_locals.insert(local.index());\n     }\n \n-    fn mark_assigned(&mut self, temp: usize) {\n-        if !self.seen_assigned.insert(temp) {\n-            self.mark_as_lvalue(temp);\n+    fn mark_assigned(&mut self, local: mir::Local) {\n+        if !self.seen_assigned.insert(local.index()) {\n+            self.mark_as_lvalue(local);\n         }\n     }\n }\n \n-impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n+impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n                     lvalue: &mir::Lvalue<'tcx>,\n                     rvalue: &mir::Rvalue<'tcx>) {\n         debug!(\"visit_assign(block={:?}, lvalue={:?}, rvalue={:?})\", block, lvalue, rvalue);\n \n-        match *lvalue {\n-            mir::Lvalue::Temp(temp) => {\n-                self.mark_assigned(temp.index());\n-                if !rvalue::rvalue_creates_operand(self.mir, self.bcx, rvalue) {\n-                    self.mark_as_lvalue(temp.index());\n-                }\n-            }\n-            _ => {\n-                self.visit_lvalue(lvalue, LvalueContext::Store);\n+        if let Some(index) = self.mir.local_index(lvalue) {\n+            self.mark_assigned(index);\n+            if !rvalue::rvalue_creates_operand(self.mir, self.bcx, rvalue) {\n+                self.mark_as_lvalue(index);\n             }\n+        } else {\n+            self.visit_lvalue(lvalue, LvalueContext::Store);\n         }\n \n         self.visit_rvalue(rvalue);\n     }\n \n+    fn visit_terminator_kind(&mut self,\n+                             block: mir::BasicBlock,\n+                             kind: &mir::TerminatorKind<'tcx>) {\n+        match *kind {\n+            mir::TerminatorKind::Call {\n+                func: mir::Operand::Constant(mir::Constant {\n+                    literal: mir::Literal::Item { def_id, .. }, ..\n+                }),\n+                ref args, ..\n+            } if Some(def_id) == self.bcx.tcx().lang_items.box_free_fn() => {\n+                // box_free(x) shares with `drop x` the property that it\n+                // is not guaranteed to be statically dominated by the\n+                // definition of x, so x must always be in an alloca.\n+                if let mir::Operand::Consume(ref lvalue) = args[0] {\n+                    self.visit_lvalue(lvalue, LvalueContext::Drop);\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        self.super_terminator_kind(block, kind);\n+    }\n+\n     fn visit_lvalue(&mut self,\n                     lvalue: &mir::Lvalue<'tcx>,\n                     context: LvalueContext) {\n         debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n \n         // Allow uses of projections of immediate pair fields.\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            if let mir::Lvalue::Temp(temp) = proj.base {\n-                let ty = self.mir.temp_decls[temp].ty;\n-                let ty = self.bcx.monomorphize(&ty);\n+            if self.mir.local_index(&proj.base).is_some() {\n+                let ty = self.mir.lvalue_ty(self.bcx.tcx(), &proj.base);\n+                let ty = self.bcx.monomorphize(&ty.to_ty(self.bcx.tcx()));\n                 if common::type_is_imm_pair(self.bcx.ccx(), ty) {\n                     if let mir::ProjectionElem::Field(..) = proj.elem {\n                         if let LvalueContext::Consume = context {\n@@ -129,25 +155,36 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n             }\n         }\n \n-        match *lvalue {\n-            mir::Lvalue::Temp(temp) => {\n-                match context {\n-                    LvalueContext::Call => {\n-                        self.mark_assigned(temp.index());\n-                    }\n-                    LvalueContext::Consume => {\n-                    }\n-                    LvalueContext::Store |\n-                    LvalueContext::Drop |\n-                    LvalueContext::Inspect |\n-                    LvalueContext::Borrow { .. } |\n-                    LvalueContext::Slice { .. } |\n-                    LvalueContext::Projection => {\n-                        self.mark_as_lvalue(temp.index());\n+        if let Some(index) = self.mir.local_index(lvalue) {\n+            match context {\n+                LvalueContext::Call => {\n+                    self.mark_assigned(index);\n+                }\n+                LvalueContext::Consume => {\n+                }\n+                LvalueContext::Store |\n+                LvalueContext::Inspect |\n+                LvalueContext::Borrow { .. } |\n+                LvalueContext::Slice { .. } |\n+                LvalueContext::Projection => {\n+                    self.mark_as_lvalue(index);\n+                }\n+                LvalueContext::Drop => {\n+                    let ty = self.mir.lvalue_ty(self.bcx.tcx(), lvalue);\n+                    let ty = self.bcx.monomorphize(&ty.to_ty(self.bcx.tcx()));\n+\n+                    // Only need the lvalue if we're actually dropping it.\n+                    if glue::type_needs_drop(self.bcx.tcx(), ty) {\n+                        self.mark_as_lvalue(index);\n                     }\n                 }\n             }\n-            _ => {\n+        }\n+\n+        // A deref projection only reads the pointer, never needs the lvalue.\n+        if let mir::Lvalue::Projection(ref proj) = *lvalue {\n+            if let mir::ProjectionElem::Deref = proj.elem {\n+                return self.visit_lvalue(&proj.base, LvalueContext::Consume);\n             }\n         }\n "}, {"sha": "7a7f1901736c5939af7d3787154d1b7a0ff22fbf", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 92, "deletions": 56, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -32,7 +32,7 @@ use type_::Type;\n use rustc_data_structures::fnv::FnvHashMap;\n use syntax::parse::token;\n \n-use super::{MirContext, TempRef};\n+use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n use super::constant::Const;\n use super::lvalue::{LvalueRef, load_fat_ptr};\n@@ -186,23 +186,60 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::TerminatorKind::Return => {\n-                bcx.with_block(|bcx| {\n-                    self.fcx.build_return_block(bcx, debug_loc);\n-                })\n+                let ret = bcx.fcx().fn_ty.ret;\n+                if ret.is_ignore() || ret.is_indirect() {\n+                    bcx.ret_void();\n+                    return;\n+                }\n+\n+                let llval = if let Some(cast_ty) = ret.cast {\n+                    let index = mir.local_index(&mir::Lvalue::ReturnPointer).unwrap();\n+                    let op = match self.locals[index] {\n+                        LocalRef::Operand(Some(op)) => op,\n+                        LocalRef::Operand(None) => bug!(\"use of return before def\"),\n+                        LocalRef::Lvalue(tr_lvalue) => {\n+                            OperandRef {\n+                                val: Ref(tr_lvalue.llval),\n+                                ty: tr_lvalue.ty.to_ty(bcx.tcx())\n+                            }\n+                        }\n+                    };\n+                    let llslot = match op.val {\n+                        Immediate(_) | Pair(..) => {\n+                            let llscratch = build::AllocaFcx(bcx.fcx(), ret.original_ty, \"ret\");\n+                            self.store_operand(&bcx, llscratch, op);\n+                            llscratch\n+                        }\n+                        Ref(llval) => llval\n+                    };\n+                    let load = bcx.load(bcx.pointercast(llslot, cast_ty.ptr_to()));\n+                    let llalign = llalign_of_min(bcx.ccx(), ret.ty);\n+                    unsafe {\n+                        llvm::LLVMSetAlignment(load, llalign);\n+                    }\n+                    load\n+                } else {\n+                    let op = self.trans_consume(&bcx, &mir::Lvalue::ReturnPointer);\n+                    op.pack_if_pair(&bcx).immediate()\n+                };\n+                bcx.ret(llval);\n             }\n \n             mir::TerminatorKind::Unreachable => {\n                 bcx.unreachable();\n             }\n \n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                let lvalue = self.trans_lvalue(&bcx, location);\n-                let ty = lvalue.ty.to_ty(bcx.tcx());\n+                let ty = mir.lvalue_ty(bcx.tcx(), location).to_ty(bcx.tcx());\n+                let ty = bcx.monomorphize(&ty);\n+\n                 // Double check for necessity to drop\n                 if !glue::type_needs_drop(bcx.tcx(), ty) {\n                     funclet_br(self, bcx, target);\n                     return;\n                 }\n+\n+                let lvalue = self.trans_lvalue(&bcx, location);\n                 let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n                 let drop_ty = glue::get_drop_glue_type(bcx.tcx(), ty);\n                 let llvalue = if drop_ty != ty {\n@@ -534,7 +571,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     fn trans_argument(&mut self,\n                       bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                      mut op: OperandRef<'tcx>,\n+                      op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n                       fn_ty: &FnType,\n                       next_idx: &mut usize,\n@@ -562,8 +599,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, callee);\n                 return;\n             }\n-\n-            op = op.pack_if_pair(bcx);\n         }\n \n         let arg = &fn_ty.args[*next_idx];\n@@ -580,14 +615,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n         // Force by-ref if we have to load through a cast pointer.\n         let (mut llval, by_ref) = match op.val {\n-            Immediate(llval) if arg.is_indirect() || arg.cast.is_some() => {\n-                let llscratch = build::AllocaFcx(bcx.fcx(), arg.original_ty, \"arg\");\n-                bcx.store(llval, llscratch);\n-                (llscratch, true)\n+            Immediate(_) | Pair(..) => {\n+                if arg.is_indirect() || arg.cast.is_some() {\n+                    let llscratch = build::AllocaFcx(bcx.fcx(), arg.original_ty, \"arg\");\n+                    self.store_operand(bcx, llscratch, op);\n+                    (llscratch, true)\n+                } else {\n+                    (op.pack_if_pair(bcx).immediate(), false)\n+                }\n             }\n-            Immediate(llval) => (llval, false),\n-            Ref(llval) => (llval, true),\n-            Pair(..) => bug!(\"pairs handled above\")\n+            Ref(llval) => (llval, true)\n         };\n \n         if by_ref && !arg.is_indirect() {\n@@ -773,40 +810,39 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         if fn_ret_ty.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n-        let dest = match *dest {\n-            mir::Lvalue::Temp(idx) => {\n-                let ret_ty = self.lvalue_ty(dest);\n-                match self.temps[idx] {\n-                    TempRef::Lvalue(dest) => dest,\n-                    TempRef::Operand(None) => {\n-                        // Handle temporary lvalues, specifically Operand ones, as\n-                        // they don't have allocas\n-                        return if fn_ret_ty.is_indirect() {\n-                            // Odd, but possible, case, we have an operand temporary,\n-                            // but the calling convention has an indirect return.\n-                            let tmp = bcx.with_block(|bcx| {\n-                                base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n-                            });\n-                            llargs.push(tmp);\n-                            ReturnDest::IndirectOperand(tmp, idx)\n-                        } else if is_intrinsic {\n-                            // Currently, intrinsics always need a location to store\n-                            // the result. so we create a temporary alloca for the\n-                            // result\n-                            let tmp = bcx.with_block(|bcx| {\n-                                base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n-                            });\n-                            ReturnDest::IndirectOperand(tmp, idx)\n-                        } else {\n-                            ReturnDest::DirectOperand(idx)\n-                        };\n-                    }\n-                    TempRef::Operand(Some(_)) => {\n-                        bug!(\"lvalue temp already assigned to\");\n-                    }\n+        let dest = if let Some(index) = self.mir.local_index(dest) {\n+            let ret_ty = self.lvalue_ty(dest);\n+            match self.locals[index] {\n+                LocalRef::Lvalue(dest) => dest,\n+                LocalRef::Operand(None) => {\n+                    // Handle temporary lvalues, specifically Operand ones, as\n+                    // they don't have allocas\n+                    return if fn_ret_ty.is_indirect() {\n+                        // Odd, but possible, case, we have an operand temporary,\n+                        // but the calling convention has an indirect return.\n+                        let tmp = bcx.with_block(|bcx| {\n+                            base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n+                        });\n+                        llargs.push(tmp);\n+                        ReturnDest::IndirectOperand(tmp, index)\n+                    } else if is_intrinsic {\n+                        // Currently, intrinsics always need a location to store\n+                        // the result. so we create a temporary alloca for the\n+                        // result\n+                        let tmp = bcx.with_block(|bcx| {\n+                            base::alloc_ty(bcx, ret_ty, \"tmp_ret\")\n+                        });\n+                        ReturnDest::IndirectOperand(tmp, index)\n+                    } else {\n+                        ReturnDest::DirectOperand(index)\n+                    };\n+                }\n+                LocalRef::Operand(Some(_)) => {\n+                    bug!(\"lvalue local already assigned to\");\n                 }\n             }\n-            _ => self.trans_lvalue(bcx, dest)\n+        } else {\n+            self.trans_lvalue(bcx, dest)\n         };\n         if fn_ret_ty.is_indirect() {\n             llargs.push(dest.llval);\n@@ -850,11 +886,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         match dest {\n             Nothing => (),\n             Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n-            IndirectOperand(tmp, idx) => {\n+            IndirectOperand(tmp, index) => {\n                 let op = self.trans_load(bcx, tmp, op.ty);\n-                self.temps[idx] = TempRef::Operand(Some(op));\n+                self.locals[index] = LocalRef::Operand(Some(op));\n             }\n-            DirectOperand(idx) => {\n+            DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if ret_ty.cast.is_some() {\n                     let tmp = bcx.with_block(|bcx| {\n@@ -865,7 +901,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 } else {\n                     op.unpack_if_pair(bcx)\n                 };\n-                self.temps[idx] = TempRef::Operand(Some(op));\n+                self.locals[index] = LocalRef::Operand(Some(op));\n             }\n         }\n     }\n@@ -876,8 +912,8 @@ enum ReturnDest {\n     Nothing,\n     // Store the return value to the pointer\n     Store(ValueRef),\n-    // Stores an indirect return value to an operand temporary lvalue\n-    IndirectOperand(ValueRef, mir::Temp),\n-    // Stores a direct return value to an operand temporary lvalue\n-    DirectOperand(mir::Temp)\n+    // Stores an indirect return value to an operand local lvalue\n+    IndirectOperand(ValueRef, mir::Local),\n+    // Stores a direct return value to an operand local lvalue\n+    DirectOperand(mir::Local)\n }"}, {"sha": "30be4a9737270dfbd787a890aa1a20230d4cad21", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -203,17 +203,8 @@ struct MirConstContext<'a, 'tcx: 'a> {\n     /// Type parameters for const fn and associated constants.\n     substs: &'tcx Substs<'tcx>,\n \n-    /// Arguments passed to a const fn.\n-    args: IndexVec<mir::Arg, Const<'tcx>>,\n-\n-    /// Variable values - specifically, argument bindings of a const fn.\n-    vars: IndexVec<mir::Var, Option<Const<'tcx>>>,\n-\n-    /// Temp values.\n-    temps: IndexVec<mir::Temp, Option<Const<'tcx>>>,\n-\n-    /// Value assigned to Return, which is the resulting constant.\n-    return_value: Option<Const<'tcx>>\n+    /// Values of locals in a constant or const fn.\n+    locals: IndexVec<mir::Local, Option<Const<'tcx>>>\n }\n \n \n@@ -223,15 +214,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n            substs: &'tcx Substs<'tcx>,\n            args: IndexVec<mir::Arg, Const<'tcx>>)\n            -> MirConstContext<'a, 'tcx> {\n-        MirConstContext {\n+        let mut context = MirConstContext {\n             ccx: ccx,\n             mir: mir,\n             substs: substs,\n-            args: args,\n-            vars: IndexVec::from_elem(None, &mir.var_decls),\n-            temps: IndexVec::from_elem(None, &mir.temp_decls),\n-            return_value: None\n+            locals: (0..mir.count_locals()).map(|_| None).collect(),\n+        };\n+        for (i, arg) in args.into_iter().enumerate() {\n+            let index = mir.local_index(&mir::Lvalue::Arg(mir::Arg::new(i))).unwrap();\n+            context.locals[index] = Some(arg);\n         }\n+        context\n     }\n \n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n@@ -302,9 +295,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 mir::TerminatorKind::Goto { target } => target,\n                 mir::TerminatorKind::Return => {\n                     failure?;\n-                    return Ok(self.return_value.unwrap_or_else(|| {\n+                    let index = self.mir.local_index(&mir::Lvalue::ReturnPointer).unwrap();\n+                    return Ok(self.locals[index].unwrap_or_else(|| {\n                         span_bug!(span, \"no returned value in constant\");\n-                    }))\n+                    }));\n                 }\n \n                 mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, .. } => {\n@@ -366,40 +360,35 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn store(&mut self, dest: &mir::Lvalue<'tcx>, value: Const<'tcx>, span: Span) {\n-        let dest = match *dest {\n-            mir::Lvalue::Var(var) => &mut self.vars[var],\n-            mir::Lvalue::Temp(temp) => &mut self.temps[temp],\n-            mir::Lvalue::ReturnPointer => &mut self.return_value,\n-            _ => span_bug!(span, \"assignment to {:?} in constant\", dest)\n-        };\n-        *dest = Some(value);\n+        if let Some(index) = self.mir.local_index(dest) {\n+            self.locals[index] = Some(value);\n+        } else {\n+            span_bug!(span, \"assignment to {:?} in constant\", dest);\n+        }\n     }\n \n     fn const_lvalue(&self, lvalue: &mir::Lvalue<'tcx>, span: Span)\n                     -> Result<ConstLvalue<'tcx>, ConstEvalFailure> {\n         let tcx = self.ccx.tcx();\n+\n+        if let Some(index) = self.mir.local_index(lvalue) {\n+            return Ok(self.locals[index].unwrap_or_else(|| {\n+                span_bug!(span, \"{:?} not initialized\", lvalue)\n+            }).as_lvalue());\n+        }\n+\n         let lvalue = match *lvalue {\n-            mir::Lvalue::Var(var) => {\n-                self.vars[var].unwrap_or_else(|| {\n-                    span_bug!(span, \"{:?} not initialized\", var)\n-                }).as_lvalue()\n-            }\n-            mir::Lvalue::Temp(temp) => {\n-                self.temps[temp].unwrap_or_else(|| {\n-                    span_bug!(span, \"{:?} not initialized\", temp)\n-                }).as_lvalue()\n-            }\n-            mir::Lvalue::Arg(arg) => self.args[arg].as_lvalue(),\n+            mir::Lvalue::Var(_) |\n+            mir::Lvalue::Temp(_) |\n+            mir::Lvalue::Arg(_) |\n+            mir::Lvalue::ReturnPointer => bug!(), // handled above\n             mir::Lvalue::Static(def_id) => {\n                 ConstLvalue {\n                     base: Base::Static(consts::get_static(self.ccx, def_id).val),\n                     llextra: ptr::null_mut(),\n                     ty: self.mir.lvalue_ty(tcx, lvalue).to_ty(tcx)\n                 }\n             }\n-            mir::Lvalue::ReturnPointer => {\n-                span_bug!(span, \"accessing Lvalue::ReturnPointer in constant\")\n-            }\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.const_lvalue(&projection.base, span)?;\n                 let projected_ty = LvalueTy::Ty { ty: tr_base.ty }"}, {"sha": "ceaba2a40ca55f77c7773194d179c0a838e53550", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -26,7 +26,8 @@ use Disr;\n \n use std::ptr;\n \n-use super::{MirContext, TempRef};\n+use super::{MirContext, LocalRef};\n+use super::operand::OperandValue;\n \n #[derive(Copy, Clone, Debug)]\n pub struct LvalueRef<'tcx> {\n@@ -87,40 +88,50 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         -> LvalueRef<'tcx> {\n         debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n \n-        let fcx = bcx.fcx();\n         let ccx = bcx.ccx();\n         let tcx = bcx.tcx();\n+\n+        if let Some(index) = self.mir.local_index(lvalue) {\n+            match self.locals[index] {\n+                LocalRef::Lvalue(lvalue) => {\n+                    return lvalue;\n+                }\n+                LocalRef::Operand(..) => {\n+                    bug!(\"using operand local {:?} as lvalue\", lvalue);\n+                }\n+            }\n+        }\n+\n         let result = match *lvalue {\n-            mir::Lvalue::Var(var) => self.vars[var],\n-            mir::Lvalue::Temp(temp) => match self.temps[temp] {\n-                TempRef::Lvalue(lvalue) =>\n-                    lvalue,\n-                TempRef::Operand(..) =>\n-                    bug!(\"using operand temp {:?} as lvalue\", lvalue),\n-            },\n-            mir::Lvalue::Arg(arg) => self.args[arg],\n+            mir::Lvalue::Var(_) |\n+            mir::Lvalue::Temp(_) |\n+            mir::Lvalue::Arg(_) |\n+            mir::Lvalue::ReturnPointer => bug!(), // handled above\n             mir::Lvalue::Static(def_id) => {\n                 let const_ty = self.lvalue_ty(lvalue);\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id).val,\n                                      LvalueTy::from_ty(const_ty))\n             },\n-            mir::Lvalue::ReturnPointer => {\n-                let llval = if !fcx.fn_ty.ret.is_ignore() {\n-                    bcx.with_block(|bcx| {\n-                        fcx.get_ret_slot(bcx, \"\")\n-                    })\n-                } else {\n-                    // This is a void return; that is, there\u2019s no place to store the value and\n-                    // there cannot really be one (or storing into it doesn\u2019t make sense, anyway).\n-                    // Ergo, we return an undef ValueRef, so we do not have to special-case every\n-                    // place using lvalues, and could use it the same way you use a regular\n-                    // ReturnPointer LValue (i.e. store into it, load from it etc).\n-                    C_undef(fcx.fn_ty.ret.original_ty.ptr_to())\n+            mir::Lvalue::Projection(box mir::Projection {\n+                ref base,\n+                elem: mir::ProjectionElem::Deref\n+            }) => {\n+                // Load the pointer from its location.\n+                let ptr = self.trans_consume(bcx, base);\n+                let projected_ty = LvalueTy::from_ty(ptr.ty)\n+                    .projection_ty(tcx, &mir::ProjectionElem::Deref);\n+                let projected_ty = bcx.monomorphize(&projected_ty);\n+                let (llptr, llextra) = match ptr.val {\n+                    OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n+                    OperandValue::Pair(llptr, llextra) => (llptr, llextra),\n+                    OperandValue::Ref(_) => bug!(\"Deref of by-Ref type {:?}\", ptr.ty)\n                 };\n-                let fn_return_ty = bcx.monomorphize(&self.mir.return_ty);\n-                let return_ty = fn_return_ty.unwrap();\n-                LvalueRef::new_sized(llval, LvalueTy::from_ty(return_ty))\n-            },\n+                LvalueRef {\n+                    llval: llptr,\n+                    llextra: llextra,\n+                    ty: projected_ty,\n+                }\n+            }\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n                 let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n@@ -138,15 +149,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n \n                 let (llprojected, llextra) = match projection.elem {\n-                    mir::ProjectionElem::Deref => {\n-                        let base_ty = tr_base.ty.to_ty(tcx);\n-                        if common::type_is_sized(tcx, projected_ty.to_ty(tcx)) {\n-                            (base::load_ty_builder(bcx, tr_base.llval, base_ty),\n-                             ptr::null_mut())\n-                        } else {\n-                            load_fat_ptr(bcx, tr_base.llval)\n-                        }\n-                    }\n+                    mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         let base_ty = tr_base.ty.to_ty(tcx);\n                         let base_repr = adt::represent_type(ccx, base_ty);\n@@ -227,44 +230,41 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n \n     // Perform an action using the given Lvalue.\n-    // If the Lvalue is an empty TempRef::Operand, then a temporary stack slot\n+    // If the Lvalue is an empty LocalRef::Operand, then a temporary stack slot\n     // is created first, then used as an operand to update the Lvalue.\n     pub fn with_lvalue_ref<F, U>(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                                  lvalue: &mir::Lvalue<'tcx>, f: F) -> U\n     where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n     {\n-        match *lvalue {\n-            mir::Lvalue::Temp(temp) => {\n-                match self.temps[temp] {\n-                    TempRef::Lvalue(lvalue) => f(self, lvalue),\n-                    TempRef::Operand(None) => {\n-                        let lvalue_ty = self.lvalue_ty(lvalue);\n-                        let lvalue = LvalueRef::alloca(bcx,\n-                                                       lvalue_ty,\n-                                                       \"lvalue_temp\");\n-                        let ret = f(self, lvalue);\n-                        let op = self.trans_load(bcx, lvalue.llval, lvalue_ty);\n-                        self.temps[temp] = TempRef::Operand(Some(op));\n-                        ret\n-                    }\n-                    TempRef::Operand(Some(_)) => {\n-                        // See comments in TempRef::new_operand as to why\n-                        // we always have Some in a ZST TempRef::Operand.\n-                        let ty = self.lvalue_ty(lvalue);\n-                        if common::type_is_zero_size(bcx.ccx(), ty) {\n-                            // Pass an undef pointer as no stores can actually occur.\n-                            let llptr = C_undef(type_of(bcx.ccx(), ty).ptr_to());\n-                            f(self, LvalueRef::new_sized(llptr, LvalueTy::from_ty(ty)))\n-                        } else {\n-                            bug!(\"Lvalue temp already set\");\n-                        }\n+        if let Some(index) = self.mir.local_index(lvalue) {\n+            match self.locals[index] {\n+                LocalRef::Lvalue(lvalue) => f(self, lvalue),\n+                LocalRef::Operand(None) => {\n+                    let lvalue_ty = self.lvalue_ty(lvalue);\n+                    let lvalue = LvalueRef::alloca(bcx,\n+                                                   lvalue_ty,\n+                                                   \"lvalue_temp\");\n+                    let ret = f(self, lvalue);\n+                    let op = self.trans_load(bcx, lvalue.llval, lvalue_ty);\n+                    self.locals[index] = LocalRef::Operand(Some(op));\n+                    ret\n+                }\n+                LocalRef::Operand(Some(_)) => {\n+                    // See comments in LocalRef::new_operand as to why\n+                    // we always have Some in a ZST LocalRef::Operand.\n+                    let ty = self.lvalue_ty(lvalue);\n+                    if common::type_is_zero_size(bcx.ccx(), ty) {\n+                        // Pass an undef pointer as no stores can actually occur.\n+                        let llptr = C_undef(type_of(bcx.ccx(), ty).ptr_to());\n+                        f(self, LvalueRef::new_sized(llptr, LvalueTy::from_ty(ty)))\n+                    } else {\n+                        bug!(\"Lvalue local already set\");\n                     }\n                 }\n             }\n-            _ => {\n-                let lvalue = self.trans_lvalue(bcx, lvalue);\n-                f(self, lvalue)\n-            }\n+        } else {\n+            let lvalue = self.trans_lvalue(bcx, lvalue);\n+            f(self, lvalue)\n         }\n     }\n "}, {"sha": "0db5d3ae4d131bebcdd24dd31a3fc36275cf334d", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 95, "deletions": 58, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -84,16 +84,13 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     /// Cached unreachable block\n     unreachable_block: Option<Block<'bcx, 'tcx>>,\n \n-    /// An LLVM alloca for each MIR `VarDecl`\n-    vars: IndexVec<mir::Var, LvalueRef<'tcx>>,\n-\n-    /// The location where each MIR `TempDecl` is stored. This is\n+    /// The location where each MIR arg/var/tmp/ret is stored. This is\n     /// usually an `LvalueRef` representing an alloca, but not always:\n     /// sometimes we can skip the alloca and just store the value\n     /// directly using an `OperandRef`, which makes for tighter LLVM\n     /// IR. The conditions for using an `OperandRef` are as follows:\n     ///\n-    /// - the type of the temporary must be judged \"immediate\" by `type_is_immediate`\n+    /// - the type of the local must be judged \"immediate\" by `type_is_immediate`\n     /// - the operand must never be referenced indirectly\n     ///     - we should not take its address using the `&` operator\n     ///     - nor should it appear in an lvalue path like `tmp.a`\n@@ -102,12 +99,7 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     ///\n     /// Avoiding allocs can also be important for certain intrinsics,\n     /// notably `expect`.\n-    temps: IndexVec<mir::Temp, TempRef<'tcx>>,\n-\n-    /// The arguments to the function; as args are lvalues, these are\n-    /// always indirect, though we try to avoid creating an alloca\n-    /// when we can (and just reuse the pointer the caller provided).\n-    args: IndexVec<mir::Arg, LvalueRef<'tcx>>,\n+    locals: IndexVec<mir::Local, LocalRef<'tcx>>,\n \n     /// Debug information for MIR scopes.\n     scopes: IndexVec<mir::VisibilityScope, DIScope>\n@@ -119,14 +111,14 @@ impl<'blk, 'tcx> MirContext<'blk, 'tcx> {\n     }\n }\n \n-enum TempRef<'tcx> {\n+enum LocalRef<'tcx> {\n     Lvalue(LvalueRef<'tcx>),\n     Operand(Option<OperandRef<'tcx>>),\n }\n \n-impl<'tcx> TempRef<'tcx> {\n+impl<'tcx> LocalRef<'tcx> {\n     fn new_operand<'bcx>(ccx: &CrateContext<'bcx, 'tcx>,\n-                         ty: ty::Ty<'tcx>) -> TempRef<'tcx> {\n+                         ty: ty::Ty<'tcx>) -> LocalRef<'tcx> {\n         if common::type_is_zero_size(ccx, ty) {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n@@ -142,9 +134,9 @@ impl<'tcx> TempRef<'tcx> {\n                 val: val,\n                 ty: ty\n             };\n-            TempRef::Operand(Some(op))\n+            LocalRef::Operand(Some(op))\n         } else {\n-            TempRef::Operand(None)\n+            LocalRef::Operand(None)\n         }\n     }\n }\n@@ -157,46 +149,58 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n-    let (lvalue_temps, cleanup_kinds) = bcx.with_block(|bcx| {\n-        (analyze::lvalue_temps(bcx, &mir),\n+    let (lvalue_locals, cleanup_kinds) = bcx.with_block(|bcx| {\n+        (analyze::lvalue_locals(bcx, &mir),\n          analyze::cleanup_kinds(bcx, &mir))\n     });\n \n     // Compute debuginfo scopes from MIR scopes.\n     let scopes = debuginfo::create_mir_scopes(fcx);\n \n     // Allocate variable and temp allocas\n-    let args = arg_value_refs(&bcx, &mir, &scopes);\n-    let vars = mir.var_decls.iter()\n-                            .map(|decl| (bcx.monomorphize(&decl.ty), decl))\n-                            .map(|(mty, decl)| {\n-        let lvalue = LvalueRef::alloca(&bcx, mty, &decl.name.as_str());\n-\n-        let scope = scopes[decl.source_info.scope];\n-        if !scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n-            bcx.with_block(|bcx| {\n-                declare_local(bcx, decl.name, mty, scope,\n-                              VariableAccess::DirectVariable { alloca: lvalue.llval },\n-                              VariableKind::LocalVariable, decl.source_info.span);\n-            });\n-        }\n+    let locals = {\n+        let args = arg_local_refs(&bcx, &mir, &scopes, &lvalue_locals);\n+        let vars = mir.var_decls.iter().enumerate().map(|(i, decl)| {\n+            let ty = bcx.monomorphize(&decl.ty);\n+            let scope = scopes[decl.source_info.scope];\n+            let dbg = !scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo;\n+\n+            let local = mir.local_index(&mir::Lvalue::Var(mir::Var::new(i))).unwrap();\n+            if !lvalue_locals.contains(local.index()) && !dbg {\n+                return LocalRef::new_operand(bcx.ccx(), ty);\n+            }\n \n-        lvalue\n-    }).collect();\n-    let temps = mir.temp_decls.iter()\n-                              .map(|decl| bcx.monomorphize(&decl.ty))\n-                              .enumerate()\n-                              .map(|(i, mty)| if lvalue_temps.contains(i) {\n-                                  TempRef::Lvalue(LvalueRef::alloca(&bcx,\n-                                                                    mty,\n-                                                                    &format!(\"temp{:?}\", i)))\n-                              } else {\n-                                  // If this is an immediate temp, we do not create an\n-                                  // alloca in advance. Instead we wait until we see the\n-                                  // definition and update the operand there.\n-                                  TempRef::new_operand(bcx.ccx(), mty)\n-                              })\n-                              .collect();\n+            let lvalue = LvalueRef::alloca(&bcx, ty, &decl.name.as_str());\n+            if dbg {\n+                bcx.with_block(|bcx| {\n+                    declare_local(bcx, decl.name, ty, scope,\n+                                VariableAccess::DirectVariable { alloca: lvalue.llval },\n+                                VariableKind::LocalVariable, decl.source_info.span);\n+                });\n+            }\n+            LocalRef::Lvalue(lvalue)\n+        });\n+\n+        let locals = mir.temp_decls.iter().enumerate().map(|(i, decl)| {\n+            (mir::Lvalue::Temp(mir::Temp::new(i)), decl.ty)\n+        }).chain(mir.return_ty.maybe_converging().map(|ty| (mir::Lvalue::ReturnPointer, ty)));\n+\n+        args.into_iter().chain(vars).chain(locals.map(|(lvalue, ty)| {\n+            let ty = bcx.monomorphize(&ty);\n+            let local = mir.local_index(&lvalue).unwrap();\n+            if lvalue == mir::Lvalue::ReturnPointer && fcx.fn_ty.ret.is_indirect() {\n+                let llretptr = llvm::get_param(fcx.llfn, 0);\n+                LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty)))\n+            } else if lvalue_locals.contains(local.index()) {\n+                LocalRef::Lvalue(LvalueRef::alloca(&bcx, ty, &format!(\"{:?}\", lvalue)))\n+            } else {\n+                // If this is an immediate local, we do not create an\n+                // alloca in advance. Instead we wait until we see the\n+                // definition and update the operand there.\n+                LocalRef::new_operand(bcx.ccx(), ty)\n+            }\n+        })).collect()\n+    };\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: IndexVec<mir::BasicBlock, Block<'blk,'tcx>> =\n@@ -225,9 +229,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         unreachable_block: None,\n         cleanup_kinds: cleanup_kinds,\n         landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n-        vars: vars,\n-        temps: temps,\n-        args: args,\n+        locals: locals,\n         scopes: scopes\n     };\n \n@@ -266,10 +268,11 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are lvalues, these are always\n /// indirect.\n-fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               mir: &mir::Mir<'tcx>,\n-                              scopes: &IndexVec<mir::VisibilityScope, DIScope>)\n-                              -> IndexVec<mir::Arg, LvalueRef<'tcx>> {\n+                              scopes: &IndexVec<mir::VisibilityScope, DIScope>,\n+                              lvalue_locals: &BitVector)\n+                              -> Vec<LocalRef<'tcx>> {\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;\n@@ -285,6 +288,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n \n     mir.arg_decls.iter().enumerate().map(|(arg_index, arg_decl)| {\n         let arg_ty = bcx.monomorphize(&arg_decl.ty);\n+        let local = mir.local_index(&mir::Lvalue::Arg(mir::Arg::new(arg_index))).unwrap();\n         if arg_decl.spread {\n             // This argument (e.g. the last argument in the \"rust-call\" ABI)\n             // is a tuple that was spread at the ABI level and now we have\n@@ -305,8 +309,8 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                 let arg = &fcx.fn_ty.args[idx];\n                 idx += 1;\n                 if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n-                        // We pass fat pointers as two words, but inside the tuple\n-                        // they are the two sub-fields of a single aggregate field.\n+                    // We pass fat pointers as two words, but inside the tuple\n+                    // they are the two sub-fields of a single aggregate field.\n                     let meta = &fcx.fn_ty.args[idx];\n                     idx += 1;\n                     arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, dst));\n@@ -335,7 +339,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                                   bcx.fcx().span.unwrap_or(DUMMY_SP));\n                 }));\n             }\n-            return LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty));\n+            return LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty)));\n         }\n \n         let arg = &fcx.fn_ty.args[idx];\n@@ -345,9 +349,42 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n             // already put it in a temporary alloca and gave it up, unless\n             // we emit extra-debug-info, which requires local allocas :(.\n             // FIXME: lifetimes\n+            if arg.pad.is_some() {\n+                llarg_idx += 1;\n+            }\n             let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n             llarg_idx += 1;\n             llarg\n+        } else if !lvalue_locals.contains(local.index()) &&\n+                  !arg.is_indirect() && arg.cast.is_none() &&\n+                  arg_scope.is_none() {\n+            if arg.is_ignore() {\n+                return LocalRef::new_operand(bcx.ccx(), arg_ty);\n+            }\n+\n+            // We don't have to cast or keep the argument in the alloca.\n+            // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n+            // of putting everything in allocas just so we can use llvm.dbg.declare.\n+            if arg.pad.is_some() {\n+                llarg_idx += 1;\n+            }\n+            let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+            llarg_idx += 1;\n+            let val = if common::type_is_fat_ptr(tcx, arg_ty) {\n+                let meta = &fcx.fn_ty.args[idx];\n+                idx += 1;\n+                assert_eq!((meta.cast, meta.pad), (None, None));\n+                let llmeta = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+                llarg_idx += 1;\n+                OperandValue::Pair(llarg, llmeta)\n+            } else {\n+                OperandValue::Immediate(llarg)\n+            };\n+            let operand = OperandRef {\n+                val: val,\n+                ty: arg_ty\n+            };\n+            return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n             let lltemp = bcx.with_block(|bcx| {\n                 base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n@@ -441,7 +478,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               bcx.fcx().span.unwrap_or(DUMMY_SP));\n             }\n         }));\n-        LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n+        LocalRef::Lvalue(LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty)))\n     }).collect()\n }\n "}, {"sha": "446ac91b1f58086d990aea8eeb3154542a0341de", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -21,7 +21,7 @@ use type_::Type;\n \n use std::fmt;\n \n-use super::{MirContext, TempRef};\n+use super::{MirContext, LocalRef};\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -112,6 +112,8 @@ impl<'bcx, 'tcx> OperandRef<'tcx> {\n         if let OperandValue::Immediate(llval) = self.val {\n             // Deconstruct the immediate aggregate.\n             if common::type_is_imm_pair(bcx.ccx(), self.ty) {\n+                debug!(\"Operand::unpack_if_pair: unpacking {:?}\", self);\n+\n                 let mut a = bcx.extract_value(llval, 0);\n                 let mut b = bcx.extract_value(llval, 1);\n \n@@ -164,56 +166,65 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         OperandRef { val: val, ty: ty }\n     }\n \n-    pub fn trans_operand(&mut self,\n+    pub fn trans_consume(&mut self,\n                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                         operand: &mir::Operand<'tcx>)\n+                         lvalue: &mir::Lvalue<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n-        debug!(\"trans_operand(operand={:?})\", operand);\n+        debug!(\"trans_consume(lvalue={:?})\", lvalue);\n \n-        match *operand {\n-            mir::Operand::Consume(ref lvalue) => {\n-                // watch out for temporaries that do not have an\n-                // alloca; they are handled somewhat differently\n-                if let &mir::Lvalue::Temp(index) = lvalue {\n-                    match self.temps[index] {\n-                        TempRef::Operand(Some(o)) => {\n-                            return o;\n-                        }\n-                        TempRef::Operand(None) => {\n-                            bug!(\"use of {:?} before def\", lvalue);\n-                        }\n-                        TempRef::Lvalue(..) => {\n-                            // use path below\n-                        }\n-                    }\n+        // watch out for locals that do not have an\n+        // alloca; they are handled somewhat differently\n+        if let Some(index) = self.mir.local_index(lvalue) {\n+            match self.locals[index] {\n+                LocalRef::Operand(Some(o)) => {\n+                    return o;\n+                }\n+                LocalRef::Operand(None) => {\n+                    bug!(\"use of {:?} before def\", lvalue);\n                 }\n+                LocalRef::Lvalue(..) => {\n+                    // use path below\n+                }\n+            }\n+        }\n \n-                // Moves out of pair fields are trivial.\n-                if let &mir::Lvalue::Projection(ref proj) = lvalue {\n-                    if let mir::Lvalue::Temp(index) = proj.base {\n-                        let temp_ref = &self.temps[index];\n-                        if let &TempRef::Operand(Some(o)) = temp_ref {\n-                            match (o.val, &proj.elem) {\n-                                (OperandValue::Pair(a, b),\n-                                 &mir::ProjectionElem::Field(ref f, ty)) => {\n-                                    let llval = [a, b][f.index()];\n-                                    return OperandRef {\n-                                        val: OperandValue::Immediate(llval),\n-                                        ty: bcx.monomorphize(&ty)\n-                                    };\n-                                }\n-                                _ => {}\n-                            }\n+        // Moves out of pair fields are trivial.\n+        if let &mir::Lvalue::Projection(ref proj) = lvalue {\n+            if let Some(index) = self.mir.local_index(&proj.base) {\n+                if let LocalRef::Operand(Some(o)) = self.locals[index] {\n+                    match (o.val, &proj.elem) {\n+                        (OperandValue::Pair(a, b),\n+                         &mir::ProjectionElem::Field(ref f, ty)) => {\n+                            let llval = [a, b][f.index()];\n+                            return OperandRef {\n+                                val: OperandValue::Immediate(llval),\n+                                ty: bcx.monomorphize(&ty)\n+                            };\n                         }\n+                        _ => {}\n                     }\n                 }\n+            }\n+        }\n+\n+        // for most lvalues, to consume them we just load them\n+        // out from their home\n+        let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+        let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+        self.trans_load(bcx, tr_lvalue.llval, ty)\n+    }\n \n-                // for most lvalues, to consume them we just load them\n-                // out from their home\n-                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-                self.trans_load(bcx, tr_lvalue.llval, ty)\n+    pub fn trans_operand(&mut self,\n+                         bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                         operand: &mir::Operand<'tcx>)\n+                         -> OperandRef<'tcx>\n+    {\n+        debug!(\"trans_operand(operand={:?})\", operand);\n+\n+        match *operand {\n+            mir::Operand::Consume(ref lvalue) => {\n+                self.trans_consume(bcx, lvalue)\n             }\n \n             mir::Operand::Constant(ref constant) => {"}, {"sha": "55efa75b17336aafdea56e516b496388d19a5a36", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::repr as mir;\n use common::{self, BlockAndBuilder};\n \n use super::MirContext;\n-use super::TempRef;\n+use super::LocalRef;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_statement(&mut self,\n@@ -27,37 +27,34 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         debug_loc.apply(bcx.fcx());\n         match statement.kind {\n             mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                match *lvalue {\n-                    mir::Lvalue::Temp(index) => {\n-                        match self.temps[index] {\n-                            TempRef::Lvalue(tr_dest) => {\n-                                self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n-                            }\n-                            TempRef::Operand(None) => {\n-                                let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue,\n-                                                                               debug_loc);\n-                                self.temps[index] = TempRef::Operand(Some(operand));\n-                                bcx\n-                            }\n-                            TempRef::Operand(Some(_)) => {\n-                                let ty = self.lvalue_ty(lvalue);\n+                if let Some(index) = self.mir.local_index(lvalue) {\n+                    match self.locals[index] {\n+                        LocalRef::Lvalue(tr_dest) => {\n+                            self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n+                        }\n+                        LocalRef::Operand(None) => {\n+                            let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue,\n+                                                                           debug_loc);\n+                            self.locals[index] = LocalRef::Operand(Some(operand));\n+                            bcx\n+                        }\n+                        LocalRef::Operand(Some(_)) => {\n+                            let ty = self.lvalue_ty(lvalue);\n \n-                                if !common::type_is_zero_size(bcx.ccx(), ty) {\n-                                    span_bug!(statement.source_info.span,\n-                                              \"operand {:?} already assigned\",\n-                                              rvalue);\n-                                } else {\n-                                    // If the type is zero-sized, it's already been set here,\n-                                    // but we still need to make sure we translate the operand\n-                                    self.trans_rvalue_operand(bcx, rvalue, debug_loc).0\n-                                }\n+                            if !common::type_is_zero_size(bcx.ccx(), ty) {\n+                                span_bug!(statement.source_info.span,\n+                                          \"operand {:?} already assigned\",\n+                                          rvalue);\n+                            } else {\n+                                // If the type is zero-sized, it's already been set here,\n+                                // but we still need to make sure we translate the operand\n+                                self.trans_rvalue_operand(bcx, rvalue, debug_loc).0\n                             }\n                         }\n                     }\n-                    _ => {\n-                        let tr_dest = self.trans_lvalue(&bcx, lvalue);\n-                        self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n-                    }\n+                } else {\n+                    let tr_dest = self.trans_lvalue(&bcx, lvalue);\n+                    self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n                 }\n             }\n         }"}, {"sha": "a65a3e1bb66fe52a446bb25cf4fda9a497ca612f", "filename": "src/test/codegen/loads.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Ftest%2Fcodegen%2Floads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Ftest%2Fcodegen%2Floads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Floads.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -11,6 +11,7 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n \n pub struct Bytes {\n   a: u8,\n@@ -21,13 +22,15 @@ pub struct Bytes {\n \n // CHECK-LABEL: @borrow\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn borrow(x: &i32) -> &i32 {\n // CHECK: load {{(i32\\*, )?}}i32** %x{{.*}}, !nonnull\n     x\n }\n \n // CHECK-LABEL: @_box\n #[no_mangle]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n pub fn _box(x: Box<i32>) -> i32 {\n // CHECK: load {{(i32\\*, )?}}i32** %x{{.*}}, !nonnull\n     *x"}, {"sha": "199f7f0201877b95ac0b71a3bc12ed81af01e1a9", "filename": "src/test/codegen/naked-functions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Ftest%2Fcodegen%2Fnaked-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Ftest%2Fcodegen%2Fnaked-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnaked-functions.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -13,7 +13,7 @@\n // compile-flags: -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(naked_functions)]\n+#![feature(naked_functions, rustc_attrs)]\n \n // CHECK: Function Attrs: naked uwtable\n // CHECK-NEXT: define internal void @naked_empty()\n@@ -26,6 +26,7 @@ fn naked_empty() {\n // CHECK: Function Attrs: naked uwtable\n #[no_mangle]\n #[naked]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n // CHECK-NEXT: define internal void @naked_with_args(i{{[0-9]+}})\n fn naked_with_args(a: isize) {\n     // CHECK: %a = alloca i{{[0-9]+}}\n@@ -45,6 +46,7 @@ fn naked_with_return() -> isize {\n // CHECK-NEXT: define internal i{{[0-9]+}} @naked_with_args_and_return(i{{[0-9]+}})\n #[no_mangle]\n #[naked]\n+#[rustc_no_mir] // FIXME #27840 MIR has different codegen.\n fn naked_with_args_and_return(a: isize) -> isize {\n     // CHECK: %a = alloca i{{[0-9]+}}\n     // CHECK: ret i{{[0-9]+}} %{{[0-9]+}}"}, {"sha": "b6d5e5458ff0866405159e693076477f2cf32a40", "filename": "src/test/compile-fail/issue-26548.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cde975cb9b5f3ebe1261b5a962c75731e884e4/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=45cde975cb9b5f3ebe1261b5a962c75731e884e4", "patch": "@@ -10,10 +10,13 @@\n \n // error-pattern: overflow representing the type `S`\n \n+#![feature(rustc_attrs)]\n+\n trait Mirror { type It: ?Sized; }\n impl<T: ?Sized> Mirror for T { type It = Self; }\n struct S(Option<<S as Mirror>::It>);\n \n+#[rustc_no_mir] // FIXME #27840 MIR tries to represent `std::option::Option<S>` first.\n fn main() {\n     let _s = S(None);\n }"}]}