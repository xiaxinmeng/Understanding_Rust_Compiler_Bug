{"sha": "f89e975685a3a9f258c996865cdd144a0f30f83c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4OWU5NzU2ODVhM2E5ZjI1OGM5OTY4NjVjZGQxNDRhMGYzMGY4M2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-10T20:21:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-10T20:21:53Z"}, "message": "auto merge of #18287 : michaelsproul/rust/triemap-collection-views, r=bstrie\n\nI've implemented the new collection views API for TrieMap. I more or less followed the approach set out by @Gankro in BTreeMap, by using a `SearchStack`. There's quite a bit of unsafe code, but I've wrapped it safely where I think is appropriate. I've added tests to ensure everything works, and performance seems quite good.\r\n\r\n```\r\ntest trie::bench_map::bench_find                           ... bench:     67879 ns/iter (+/- 4192)\r\ntest trie::bench_map::bench_find_entry                     ... bench:    186814 ns/iter (+/- 18748)\r\ntest trie::bench_map::bench_insert_large                   ... bench:    716612 ns/iter (+/- 160121)\r\ntest trie::bench_map::bench_insert_large_entry             ... bench:    851219 ns/iter (+/- 20331)\r\ntest trie::bench_map::bench_remove                         ... bench:    838856 ns/iter (+/- 27998)\r\ntest trie::bench_map::bench_remove_entry                   ... bench:    981711 ns/iter (+/- 53046)\r\n```\r\n\r\nUsing an entry is slow compared to a plain find, but is only ~15% slower for inserts and removes, which is where this API is most useful. I'm tempted to remove the standalone `remove` function in favour of an entry-based approach (to cut down on complexity).\r\n\r\nI've added some more comments to the general part of the code-base, which will hopefully help the next person looking over this. I moved the three key structures to the top of the file so that the nesting structure is clearly visible, and renamed `Child<T>` to `TrieNode<T>` and `TrieNode<T>` to `InternalNode<T>` to improve clarity. If these changes are creeping, I'm happy to revert them.\r\n\r\nLet me know if my use of `fail!` is ok, I was a little unsure of how specific to be. Some of the data-structures have various invariants that shouldn't be broken, so using `fail!` seemed appropriate.\r\n\r\n## Still to do\r\n\r\n* Modernise iterators (make them double-ended).\r\n* Make the keys generic, or rename this data-structure (see: https://github.com/rust-lang/rust/issues/14902).\r\n* Possibly move this code out of libcollections. [Searching Github for TrieMap turns up very few real results.][triemap-search]\r\n\r\nRelated issues: https://github.com/rust-lang/rust/issues/18009 and https://github.com/rust-lang/rust/issues/17320\r\n\r\n[triemap-search]: https://github.com/search?utf8=%E2%9C%93&q=TrieMap+language%3ARust&type=Code&ref=searchresults", "tree": {"sha": "ed6da9fbc9643c7c84a79c70c1ab36a9b67c2088", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed6da9fbc9643c7c84a79c70c1ab36a9b67c2088"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f89e975685a3a9f258c996865cdd144a0f30f83c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f89e975685a3a9f258c996865cdd144a0f30f83c", "html_url": "https://github.com/rust-lang/rust/commit/f89e975685a3a9f258c996865cdd144a0f30f83c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f89e975685a3a9f258c996865cdd144a0f30f83c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a30b72bb1420620d5b36dbd221a81374d3668271", "url": "https://api.github.com/repos/rust-lang/rust/commits/a30b72bb1420620d5b36dbd221a81374d3668271", "html_url": "https://github.com/rust-lang/rust/commit/a30b72bb1420620d5b36dbd221a81374d3668271"}, {"sha": "f52e2bd32fee91aab56ed44abac3719ece3d69fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f52e2bd32fee91aab56ed44abac3719ece3d69fd", "html_url": "https://github.com/rust-lang/rust/commit/f52e2bd32fee91aab56ed44abac3719ece3d69fd"}], "stats": {"total": 691, "additions": 589, "deletions": 102}, "files": [{"sha": "da53b5e9166ab00e23a74e860211f4231659be3a", "filename": "src/libcollections/trie/map.rs", "status": "modified", "additions": 589, "deletions": 102, "changes": 691, "blob_url": "https://github.com/rust-lang/rust/blob/f89e975685a3a9f258c996865cdd144a0f30f83c/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f89e975685a3a9f258c996865cdd144a0f30f83c/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=f89e975685a3a9f258c996865cdd144a0f30f83c", "patch": "@@ -8,13 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Maps are collections of unique keys with corresponding values, and sets are\n-//! just unique keys without a corresponding value. The `Map` and `Set` traits in\n-//! `std::container` define the basic interface.\n-//!\n-//! This crate defines `TrieMap` and `TrieSet`, which require `uint` keys.\n-//!\n-//! `TrieMap` is ordered.\n+//! Ordered maps and sets, implemented as simple tries.\n \n use core::prelude::*;\n \n@@ -24,9 +18,10 @@ use core::fmt;\n use core::fmt::Show;\n use core::mem::zeroed;\n use core::mem;\n-use core::ops::{Slice,SliceMut};\n+use core::ops::{Slice, SliceMut};\n use core::uint;\n use core::iter;\n+use core::ptr;\n use std::hash::{Writer, Hash};\n \n use slice::{Items, MutItems};\n@@ -36,21 +31,27 @@ use slice;\n // FIXME(conventions): implement into_iter\n // FIXME(conventions): replace each_reverse by making iter DoubleEnded\n \n-// FIXME: #5244: need to manually update the TrieNode constructor\n+// FIXME: #5244: need to manually update the InternalNode constructor\n const SHIFT: uint = 4;\n const SIZE: uint = 1 << SHIFT;\n const MASK: uint = SIZE - 1;\n-const NUM_CHUNKS: uint = uint::BITS / SHIFT;\n-\n-#[deriving(Clone)]\n-enum Child<T> {\n-    Internal(Box<TrieNode<T>>),\n-    External(uint, T),\n-    Nothing\n-}\n+// The number of chunks that the key is divided into. Also the maximum depth of the TrieMap.\n+const MAX_DEPTH: uint = uint::BITS / SHIFT;\n \n /// A map implemented as a radix trie.\n ///\n+/// Keys are split into sequences of 4 bits, which are used to place elements in\n+/// 16-entry arrays which are nested to form a tree structure. Inserted elements are placed\n+/// as close to the top of the tree as possible. The most significant bits of the key are used to\n+/// assign the key to a node/bucket in the first layer. If there are no other elements keyed by\n+/// the same 4 bits in the first layer, a leaf node will be created in the first layer.\n+/// When keys coincide, the next 4 bits are used to assign the node to a bucket in the next layer,\n+/// with this process continuing until an empty spot is found or there are no more bits left in the\n+/// key. As a result, the maximum depth using 32-bit `uint` keys is 8. The worst collisions occur\n+/// for very small numbers. For example, 1 and 2 are identical in all but their least significant\n+/// 4 bits. If both numbers are used as keys, a chain of maximum length will be created to\n+/// differentiate them.\n+///\n /// # Example\n ///\n /// ```\n@@ -89,10 +90,29 @@ enum Child<T> {\n /// ```\n #[deriving(Clone)]\n pub struct TrieMap<T> {\n-    root: TrieNode<T>,\n+    root: InternalNode<T>,\n     length: uint\n }\n \n+// An internal node holds SIZE child nodes, which may themselves contain more internal nodes.\n+//\n+// Throughout this implementation, \"idx\" is used to refer to a section of key that is used\n+// to access a node. The layer of the tree directly below the root corresponds to idx 0.\n+struct InternalNode<T> {\n+    // The number of direct children which are external (i.e. that store a value).\n+    count: uint,\n+    children: [TrieNode<T>, ..SIZE]\n+}\n+\n+// Each child of an InternalNode may be internal, in which case nesting continues,\n+// external (containing a value), or empty.\n+#[deriving(Clone)]\n+enum TrieNode<T> {\n+    Internal(Box<InternalNode<T>>),\n+    External(uint, T),\n+    Nothing\n+}\n+\n impl<T: PartialEq> PartialEq for TrieMap<T> {\n     fn eq(&self, other: &TrieMap<T>) -> bool {\n         self.len() == other.len() &&\n@@ -146,7 +166,7 @@ impl<T> TrieMap<T> {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> TrieMap<T> {\n-        TrieMap{root: TrieNode::new(), length: 0}\n+        TrieMap{root: InternalNode::new(), length: 0}\n     }\n \n     /// Visits all key-value pairs in reverse order. Aborts traversal when `f` returns `false`.\n@@ -284,7 +304,7 @@ impl<T> TrieMap<T> {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n-        self.root = TrieNode::new();\n+        self.root = InternalNode::new();\n         self.length = 0;\n     }\n \n@@ -396,11 +416,11 @@ impl<T> TrieMap<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, key: uint, value: T) -> Option<T> {\n-        let ret = insert(&mut self.root.count,\n-                         &mut self.root.children[chunk(key, 0)],\n-                         key, value, 1);\n-        if ret.is_none() { self.length += 1 }\n-        ret\n+        let (_, old_val) = insert(&mut self.root.count,\n+                                    &mut self.root.children[chunk(key, 0)],\n+                                    key, value, 1);\n+        if old_val.is_none() { self.length += 1 }\n+        old_val\n     }\n \n     /// Deprecated: Renamed to `remove`.\n@@ -467,14 +487,14 @@ macro_rules! bound {\n             // place that mutation is can actually occur is of the actual\n             // values of the TrieMap (as the return value of the\n             // iterator), i.e. we can never cause a deallocation of any\n-            // TrieNodes so the raw pointer is always valid.\n+            // InternalNodes so the raw pointer is always valid.\n             //\n             // # For non-`mut`\n             // We like sharing code so much that even a little unsafe won't\n             // stop us.\n             let this = $this;\n             let mut node = unsafe {\n-                mem::transmute::<_, uint>(&this.root) as *mut TrieNode<T>\n+                mem::transmute::<_, uint>(&this.root) as *mut InternalNode<T>\n             };\n \n             let key = $key;\n@@ -493,7 +513,7 @@ macro_rules! bound {\n                         Internal(ref $($mut_)* n) => {\n                             node = unsafe {\n                                 mem::transmute::<_, uint>(&**n)\n-                                    as *mut TrieNode<T>\n+                                    as *mut InternalNode<T>\n                             };\n                             (child_id + 1, false)\n                         }\n@@ -658,16 +678,11 @@ impl<T> IndexMut<uint, T> for TrieMap<T> {\n     }\n }\n \n-struct TrieNode<T> {\n-    count: uint,\n-    children: [Child<T>, ..SIZE]\n-}\n-\n-impl<T:Clone> Clone for TrieNode<T> {\n+impl<T:Clone> Clone for InternalNode<T> {\n     #[inline]\n-    fn clone(&self) -> TrieNode<T> {\n+    fn clone(&self) -> InternalNode<T> {\n         let ch = &self.children;\n-        TrieNode {\n+        InternalNode {\n             count: self.count,\n              children: [ch[0].clone(), ch[1].clone(), ch[2].clone(), ch[3].clone(),\n                         ch[4].clone(), ch[5].clone(), ch[6].clone(), ch[7].clone(),\n@@ -676,20 +691,20 @@ impl<T:Clone> Clone for TrieNode<T> {\n     }\n }\n \n-impl<T> TrieNode<T> {\n+impl<T> InternalNode<T> {\n     #[inline]\n-    fn new() -> TrieNode<T> {\n+    fn new() -> InternalNode<T> {\n         // FIXME: #5244: [Nothing, ..SIZE] should be possible without implicit\n         // copyability\n-        TrieNode{count: 0,\n+        InternalNode{count: 0,\n                  children: [Nothing, Nothing, Nothing, Nothing,\n                             Nothing, Nothing, Nothing, Nothing,\n                             Nothing, Nothing, Nothing, Nothing,\n                             Nothing, Nothing, Nothing, Nothing]}\n     }\n }\n \n-impl<T> TrieNode<T> {\n+impl<T> InternalNode<T> {\n     fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         for elt in self.children.iter().rev() {\n             match *elt {\n@@ -709,7 +724,7 @@ fn chunk(n: uint, idx: uint) -> uint {\n     (n >> sh) & MASK\n }\n \n-fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n+fn find_mut<'r, T>(child: &'r mut TrieNode<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n     match *child {\n         External(stored, ref mut value) if stored == key => Some(value),\n         External(..) => None,\n@@ -718,58 +733,72 @@ fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r\n     }\n }\n \n-fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,\n-             idx: uint) -> Option<T> {\n-    // we branch twice to avoid having to do the `replace` when we\n+/// Inserts a new node for the given key and value, at or below `start_node`.\n+///\n+/// The index (`idx`) is the index of the next node, such that the start node\n+/// was accessed via parent.children[chunk(key, idx - 1)].\n+///\n+/// The count is the external node counter for the start node's parent,\n+/// which will be incremented only if `start_node` is transformed into a *new* external node.\n+///\n+/// Returns a mutable reference to the inserted value and an optional previous value.\n+fn insert<'a, T>(count: &mut uint, start_node: &'a mut TrieNode<T>, key: uint, value: T, idx: uint)\n+    -> (&'a mut T, Option<T>) {\n+    // We branch twice to avoid having to do the `replace` when we\n     // don't need to; this is much faster, especially for keys that\n     // have long shared prefixes.\n-    match *child {\n+    match *start_node {\n         Nothing => {\n             *count += 1;\n-            *child = External(key, value);\n-            return None;\n+            *start_node = External(key, value);\n+            match *start_node {\n+                External(_, ref mut value_ref) => return (value_ref, None),\n+                _ => unreachable!()\n+            }\n         }\n         Internal(box ref mut x) => {\n             return insert(&mut x.count, &mut x.children[chunk(key, idx)], key, value, idx + 1);\n         }\n         External(stored_key, ref mut stored_value) if stored_key == key => {\n-            // swap in the new value and return the old.\n-            return Some(mem::replace(stored_value, value));\n+            // Swap in the new value and return the old.\n+            let old_value = mem::replace(stored_value, value);\n+            return (stored_value, Some(old_value));\n         }\n         _ => {}\n     }\n \n-    // conflict, an external node with differing keys: we have to\n-    // split the node, so we need the old value by value; hence we\n-    // have to move out of `child`.\n-    match mem::replace(child, Nothing) {\n+    // Conflict, an external node with differing keys.\n+    // We replace the old node by an internal one, then re-insert the two values beneath it.\n+    match mem::replace(start_node, Internal(box InternalNode::new())) {\n         External(stored_key, stored_value) => {\n-            let mut new = box TrieNode::new();\n-\n-            let ret = {\n-                let new_interior = &mut *new;\n-                insert(&mut new_interior.count,\n-                       &mut new_interior.children[chunk(stored_key, idx)],\n-                       stored_key, stored_value, idx + 1);\n-                insert(&mut new_interior.count,\n-                       &mut new_interior.children[chunk(key, idx)],\n-                       key, value, idx + 1)\n-            };\n-\n-            *child = Internal(new);\n-            return ret;\n+            match *start_node {\n+                Internal(box ref mut new_node) => {\n+                    // Re-insert the old value.\n+                    insert(&mut new_node.count,\n+                           &mut new_node.children[chunk(stored_key, idx)],\n+                           stored_key, stored_value, idx + 1);\n+\n+                    // Insert the new value, and return a reference to it directly.\n+                    insert(&mut new_node.count,\n+                           &mut new_node.children[chunk(key, idx)],\n+                           key, value, idx + 1)\n+                }\n+                // Value that was just copied disappeared.\n+                _ => unreachable!()\n+            }\n         }\n-        _ => panic!(\"unreachable code\"),\n+        // Logic error in previous match.\n+        _ => unreachable!(),\n     }\n }\n \n-fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n+fn remove<T>(count: &mut uint, child: &mut TrieNode<T>, key: uint,\n              idx: uint) -> Option<T> {\n     let (ret, this) = match *child {\n       External(stored, _) if stored == key => {\n         match mem::replace(child, Nothing) {\n             External(_, value) => (Some(value), true),\n-            _ => panic!()\n+            _ => unreachable!()\n         }\n       }\n       External(..) => (None, false),\n@@ -788,9 +817,264 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n     return ret;\n }\n \n+/// A view into a single entry in a TrieMap, which may be vacant or occupied.\n+pub enum Entry<'a, T: 'a> {\n+    /// An occupied entry.\n+    Occupied(OccupiedEntry<'a, T>),\n+    /// A vacant entry.\n+    Vacant(VacantEntry<'a, T>)\n+}\n+\n+/// A view into an occupied entry in a TrieMap.\n+pub struct OccupiedEntry<'a, T: 'a> {\n+    search_stack: SearchStack<'a, T>\n+}\n+\n+/// A view into a vacant entry in a TrieMap.\n+pub struct VacantEntry<'a, T: 'a> {\n+    search_stack: SearchStack<'a, T>\n+}\n+\n+/// A list of nodes encoding a path from the root of a TrieMap to a node.\n+///\n+/// Invariants:\n+/// * The last node is either `External` or `Nothing`.\n+/// * Pointers at indexes less than `length` can be safely dereferenced.\n+struct SearchStack<'a, T: 'a> {\n+    map: &'a mut TrieMap<T>,\n+    length: uint,\n+    key: uint,\n+    items: [*mut TrieNode<T>, ..MAX_DEPTH]\n+}\n+\n+impl<'a, T> SearchStack<'a, T> {\n+    /// Creates a new search-stack with empty entries.\n+    fn new(map: &'a mut TrieMap<T>, key: uint) -> SearchStack<'a, T> {\n+        SearchStack {\n+            map: map,\n+            length: 0,\n+            key: key,\n+            items: [ptr::null_mut(), ..MAX_DEPTH]\n+        }\n+    }\n+\n+    fn push(&mut self, node: *mut TrieNode<T>) {\n+        self.length += 1;\n+        self.items[self.length - 1] = node;\n+    }\n+\n+    fn peek(&self) -> *mut TrieNode<T> {\n+        self.items[self.length - 1]\n+    }\n+\n+    fn peek_ref(&self) -> &'a mut TrieNode<T> {\n+        unsafe {\n+            &mut *self.items[self.length - 1]\n+        }\n+    }\n+\n+    fn pop_ref(&mut self) -> &'a mut TrieNode<T> {\n+        self.length -= 1;\n+        unsafe {\n+            &mut *self.items[self.length]\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.length == 0\n+    }\n+\n+    fn get_ref(&self, idx: uint) -> &'a mut TrieNode<T> {\n+        assert!(idx < self.length);\n+        unsafe {\n+            &mut *self.items[idx]\n+        }\n+    }\n+}\n+\n+// Implementation of SearchStack creation logic.\n+// Once a SearchStack has been created the Entry methods are relatively straight-forward.\n+impl<T> TrieMap<T> {\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    #[inline]\n+    pub fn entry<'a>(&'a mut self, key: uint) -> Entry<'a, T> {\n+        // Create an empty search stack.\n+        let mut search_stack = SearchStack::new(self, key);\n+\n+        // Unconditionally add the corresponding node from the first layer.\n+        let first_node = &mut search_stack.map.root.children[chunk(key, 0)] as *mut _;\n+        search_stack.push(first_node);\n+\n+        // While no appropriate slot is found, keep descending down the Trie,\n+        // adding nodes to the search stack.\n+        let search_successful: bool;\n+        loop {\n+            match unsafe { next_child(search_stack.peek(), key, search_stack.length) } {\n+                (Some(child), _) => search_stack.push(child),\n+                (None, success) => {\n+                    search_successful = success;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if search_successful {\n+            Occupied(OccupiedEntry { search_stack: search_stack })\n+        } else {\n+            Vacant(VacantEntry { search_stack: search_stack })\n+        }\n+    }\n+}\n+\n+/// Get a mutable pointer to the next child of a node, given a key and an idx.\n+///\n+/// The idx is the index of the next child, such that `node` was accessed via\n+/// parent.children[chunk(key, idx - 1)].\n+///\n+/// Returns a tuple with an optional mutable pointer to the next child, and\n+/// a boolean flag to indicate whether the external key node was found.\n+///\n+/// This function is safe only if `node` points to a valid `TrieNode`.\n+#[inline]\n+unsafe fn next_child<'a, T>(node: *mut TrieNode<T>, key: uint, idx: uint)\n+    -> (Option<*mut TrieNode<T>>, bool) {\n+    match *node {\n+        // If the node is internal, tell the caller to descend further.\n+        Internal(box ref mut node_internal) => {\n+            (Some(&mut node_internal.children[chunk(key, idx)] as *mut _), false)\n+        },\n+        // If the node is external or empty, the search is complete.\n+        // If the key doesn't match, node expansion will be done upon\n+        // insertion. If it does match, we've found our node.\n+        External(stored_key, _) if stored_key == key => (None, true),\n+        External(..) | Nothing => (None, false)\n+    }\n+}\n+\n+// NB: All these methods assume a correctly constructed occupied entry (matching the given key).\n+impl<'a, T> OccupiedEntry<'a, T> {\n+    /// Gets a reference to the value in the entry.\n+    #[inline]\n+    pub fn get(&self) -> &T {\n+        match *self.search_stack.peek_ref() {\n+            External(_, ref value) => value,\n+            // Invalid SearchStack, non-external last node.\n+            _ => unreachable!()\n+        }\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    #[inline]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        match *self.search_stack.peek_ref() {\n+            External(_, ref mut value) => value,\n+            // Invalid SearchStack, non-external last node.\n+            _ => unreachable!()\n+        }\n+    }\n+\n+    /// Converts the OccupiedEntry into a mutable reference to the value in the entry,\n+    /// with a lifetime bound to the map itself.\n+    #[inline]\n+    pub fn into_mut(self) -> &'a mut T {\n+        match *self.search_stack.peek_ref() {\n+            External(_, ref mut value) => value,\n+            // Invalid SearchStack, non-external last node.\n+            _ => unreachable!()\n+        }\n+    }\n+\n+    /// Sets the value of the entry, and returns the entry's old value.\n+    #[inline]\n+    pub fn set(&mut self, value: T) -> T {\n+        match *self.search_stack.peek_ref() {\n+            External(_, ref mut stored_value) => {\n+                mem::replace(stored_value, value)\n+            }\n+            // Invalid SearchStack, non-external last node.\n+            _ => unreachable!()\n+        }\n+    }\n+\n+    /// Takes the value out of the entry, and returns it.\n+    #[inline]\n+    pub fn take(self) -> T {\n+        // This function removes the external leaf-node, then unwinds the search-stack\n+        // deleting now-childless ancestors.\n+        let mut search_stack = self.search_stack;\n+\n+        // Extract the value from the leaf-node of interest.\n+        let leaf_node = mem::replace(search_stack.pop_ref(), Nothing);\n+\n+        let value = match leaf_node {\n+            External(_, value) => value,\n+            // Invalid SearchStack, non-external last node.\n+            _ => unreachable!()\n+        };\n+\n+        // Iterate backwards through the search stack, deleting nodes if they are childless.\n+        // We compare each ancestor's parent count to 1 because each ancestor reached has just\n+        // had one of its children deleted.\n+        while !search_stack.is_empty() {\n+            let ancestor = search_stack.pop_ref();\n+            match *ancestor {\n+                Internal(ref mut internal) => {\n+                    // If stopping deletion, update the child count and break.\n+                    if internal.count != 1 {\n+                        internal.count -= 1;\n+                        break;\n+                    }\n+                }\n+                // Invalid SearchStack, non-internal ancestor node.\n+                _ => unreachable!()\n+            }\n+            *ancestor = Nothing;\n+        }\n+\n+        // Decrement the length of the entire TrieMap, for the removed node.\n+        search_stack.map.length -= 1;\n+\n+        value\n+    }\n+}\n+\n+impl<'a, T> VacantEntry<'a, T> {\n+    /// Set the vacant entry to the given value.\n+    pub fn set(self, value: T) -> &'a mut T {\n+        let search_stack = self.search_stack;\n+        let old_length = search_stack.length;\n+        let key = search_stack.key;\n+\n+        // Update the TrieMap's length for the new element.\n+        search_stack.map.length += 1;\n+\n+        // If there's only 1 node in the search stack, insert a new node below it at idx 1.\n+        if old_length == 1 {\n+            // Note: Small hack to appease the borrow checker. Can't mutably borrow root.count\n+            let mut temp = search_stack.map.root.count;\n+            let (value_ref, _) = insert(&mut temp, search_stack.get_ref(0), key, value, 1);\n+            search_stack.map.root.count = temp;\n+            value_ref\n+        }\n+        // Otherwise, find the predeccessor of the last stack node, and insert as normal.\n+        else {\n+            match *search_stack.get_ref(old_length - 2) {\n+                Internal(box ref mut parent) => {\n+                    let (value_ref, _) = insert(&mut parent.count,\n+                                                &mut parent.children[chunk(key, old_length - 1)],\n+                                                key, value, old_length);\n+                    value_ref\n+                }\n+                // Invalid SearchStack, non-internal ancestor node.\n+                _ => unreachable!()\n+            }\n+        }\n+    }\n+}\n+\n /// A forward iterator over a map.\n pub struct Entries<'a, T:'a> {\n-    stack: [slice::Items<'a, Child<T>>, .. NUM_CHUNKS],\n+    stack: [slice::Items<'a, TrieNode<T>>, .. MAX_DEPTH],\n     length: uint,\n     remaining_min: uint,\n     remaining_max: uint\n@@ -799,7 +1083,7 @@ pub struct Entries<'a, T:'a> {\n /// A forward iterator over the key-value pairs of a map, with the\n /// values being mutable.\n pub struct MutEntries<'a, T:'a> {\n-    stack: [slice::MutItems<'a, Child<T>>, .. NUM_CHUNKS],\n+    stack: [slice::MutItems<'a, TrieNode<T>>, .. MAX_DEPTH],\n     length: uint,\n     remaining_min: uint,\n     remaining_max: uint\n@@ -937,9 +1221,10 @@ mod test {\n     use std::uint;\n     use std::hash;\n \n-    use super::{TrieMap, TrieNode, Internal, External, Nothing};\n+    use super::{TrieMap, InternalNode, Internal, External, Nothing};\n+    use super::{Occupied, Vacant};\n \n-    fn check_integrity<T>(trie: &TrieNode<T>) {\n+    fn check_integrity<T>(trie: &InternalNode<T>) {\n         assert!(trie.count != 0);\n \n         let mut sum = 0;\n@@ -1344,6 +1629,135 @@ mod test {\n \n         map[4];\n     }\n+\n+    // Number of items to insert into the map during entry tests.\n+    // The tests rely on it being even.\n+    const SQUARES_UPPER_LIM: uint = 128;\n+\n+    /// Make a TrieMap storing i^2 for i in [0, 128)\n+    fn squares_map() -> TrieMap<uint> {\n+        let mut map = TrieMap::new();\n+        for i in range(0, SQUARES_UPPER_LIM) {\n+            map.insert(i, i * i);\n+        }\n+        map\n+    }\n+\n+    #[test]\n+    fn test_entry_get() {\n+        let mut map = squares_map();\n+\n+        for i in range(0, SQUARES_UPPER_LIM) {\n+            match map.entry(i) {\n+                Occupied(slot) => assert_eq!(slot.get(), &(i * i)),\n+                Vacant(_) => panic!(\"Key not found.\")\n+            }\n+        }\n+        check_integrity(&map.root);\n+    }\n+\n+    #[test]\n+    fn test_entry_get_mut() {\n+        let mut map = squares_map();\n+\n+        // Change the entries to cubes.\n+        for i in range(0, SQUARES_UPPER_LIM) {\n+            match map.entry(i) {\n+                Occupied(mut e) => {\n+                    *e.get_mut() = i * i * i;\n+                }\n+                Vacant(_) => panic!(\"Key not found.\")\n+            }\n+            assert_eq!(map.get(&i).unwrap(), &(i * i * i));\n+        }\n+\n+        check_integrity(&map.root);\n+    }\n+\n+    #[test]\n+    fn test_entry_into_mut() {\n+        let mut map = TrieMap::new();\n+        map.insert(3, 6u);\n+\n+        let value_ref = match map.entry(3) {\n+            Occupied(e) => e.into_mut(),\n+            Vacant(_) => panic!(\"Entry not found.\")\n+        };\n+\n+        assert_eq!(*value_ref, 6u);\n+    }\n+\n+    #[test]\n+    fn test_entry_take() {\n+        let mut map = squares_map();\n+        assert_eq!(map.len(), SQUARES_UPPER_LIM);\n+\n+        // Remove every odd key, checking that the correct value is returned.\n+        for i in range_step(1, SQUARES_UPPER_LIM, 2) {\n+            match map.entry(i) {\n+                Occupied(e) => assert_eq!(e.take(), i * i),\n+                Vacant(_) => panic!(\"Key not found.\")\n+            }\n+        }\n+\n+        check_integrity(&map.root);\n+\n+        // Check that the values for even keys remain unmodified.\n+        for i in range_step(0, SQUARES_UPPER_LIM, 2) {\n+            assert_eq!(map.get(&i).unwrap(), &(i * i));\n+        }\n+\n+        assert_eq!(map.len(), SQUARES_UPPER_LIM / 2);\n+    }\n+\n+    #[test]\n+    fn test_occupied_entry_set() {\n+        let mut map = squares_map();\n+\n+        // Change all the entries to cubes.\n+        for i in range(0, SQUARES_UPPER_LIM) {\n+            match map.entry(i) {\n+                Occupied(mut e) => assert_eq!(e.set(i * i * i), i * i),\n+                Vacant(_) => panic!(\"Key not found.\")\n+            }\n+            assert_eq!(map.get(&i).unwrap(), &(i * i * i));\n+        }\n+        check_integrity(&map.root);\n+    }\n+\n+    #[test]\n+    fn test_vacant_entry_set() {\n+        let mut map = TrieMap::new();\n+\n+        for i in range(0, SQUARES_UPPER_LIM) {\n+            match map.entry(i) {\n+                Vacant(e) => {\n+                    // Insert i^2.\n+                    let inserted_val = e.set(i * i);\n+                    assert_eq!(*inserted_val, i * i);\n+\n+                    // Update it to i^3 using the returned mutable reference.\n+                    *inserted_val = i * i * i;\n+                },\n+                _ => panic!(\"Non-existant key found.\")\n+            }\n+            assert_eq!(map.get(&i).unwrap(), &(i * i * i));\n+        }\n+\n+        check_integrity(&map.root);\n+        assert_eq!(map.len(), SQUARES_UPPER_LIM);\n+    }\n+\n+    #[test]\n+    fn test_single_key() {\n+        let mut map = TrieMap::new();\n+        map.insert(1, 2u);\n+\n+        match map.entry(1) {\n+            Occupied(e) => { e.take(); },\n+            _ => ()\n+        }\n+    }\n }\n \n #[cfg(test)]\n@@ -1352,16 +1766,22 @@ mod bench {\n     use std::rand::{weak_rng, Rng};\n     use test::{Bencher, black_box};\n \n-    use super::TrieMap;\n+    use super::{TrieMap, Occupied, Vacant};\n \n-    fn bench_iter(b: &mut Bencher, size: uint) {\n+    const MAP_SIZE: uint = 1000;\n+\n+    fn random_map(size: uint) -> TrieMap<uint> {\n         let mut map = TrieMap::<uint>::new();\n         let mut rng = weak_rng();\n \n         for _ in range(0, size) {\n             map.insert(rng.gen(), rng.gen());\n         }\n+        map\n+    }\n \n+    fn bench_iter(b: &mut Bencher, size: uint) {\n+        let map = random_map(size);\n         b.iter(|| {\n             for entry in map.iter() {\n                 black_box(entry);\n@@ -1388,30 +1808,30 @@ mod bench {\n     fn bench_lower_bound(b: &mut Bencher) {\n         let mut m = TrieMap::<uint>::new();\n         let mut rng = weak_rng();\n-        for _ in range(0u, 1000) {\n+        for _ in range(0u, MAP_SIZE) {\n             m.insert(rng.gen(), rng.gen());\n         }\n \n         b.iter(|| {\n-                for _ in range(0u, 10) {\n-                    m.lower_bound(rng.gen());\n-                }\n-            });\n+            for _ in range(0u, 10) {\n+                m.lower_bound(rng.gen());\n+            }\n+        });\n     }\n \n     #[bench]\n     fn bench_upper_bound(b: &mut Bencher) {\n         let mut m = TrieMap::<uint>::new();\n         let mut rng = weak_rng();\n-        for _ in range(0u, 1000) {\n+        for _ in range(0u, MAP_SIZE) {\n             m.insert(rng.gen(), rng.gen());\n         }\n \n         b.iter(|| {\n-                for _ in range(0u, 10) {\n-                    m.upper_bound(rng.gen());\n-                }\n-            });\n+            for _ in range(0u, 10) {\n+                m.upper_bound(rng.gen());\n+            }\n+        });\n     }\n \n     #[bench]\n@@ -1420,22 +1840,38 @@ mod bench {\n         let mut rng = weak_rng();\n \n         b.iter(|| {\n-                for _ in range(0u, 1000) {\n-                    m.insert(rng.gen(), [1, .. 10]);\n+            for _ in range(0u, MAP_SIZE) {\n+                m.insert(rng.gen(), [1, .. 10]);\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_insert_large_entry(b: &mut Bencher) {\n+        let mut m = TrieMap::<[uint, .. 10]>::new();\n+        let mut rng = weak_rng();\n+\n+        b.iter(|| {\n+            for _ in range(0u, MAP_SIZE) {\n+                match m.entry(rng.gen()) {\n+                    Occupied(mut e) => { e.set([1, ..10]); },\n+                    Vacant(e) => { e.set([1, ..10]); }\n                 }\n-            })\n+            }\n+        });\n     }\n+\n     #[bench]\n     fn bench_insert_large_low_bits(b: &mut Bencher) {\n         let mut m = TrieMap::<[uint, .. 10]>::new();\n         let mut rng = weak_rng();\n \n         b.iter(|| {\n-                for _ in range(0u, 1000) {\n-                    // only have the last few bits set.\n-                    m.insert(rng.gen::<uint>() & 0xff_ff, [1, .. 10]);\n-                }\n-            })\n+            for _ in range(0u, MAP_SIZE) {\n+                // only have the last few bits set.\n+                m.insert(rng.gen::<uint>() & 0xff_ff, [1, .. 10]);\n+            }\n+        });\n     }\n \n     #[bench]\n@@ -1444,21 +1880,72 @@ mod bench {\n         let mut rng = weak_rng();\n \n         b.iter(|| {\n-                for _ in range(0u, 1000) {\n-                    m.insert(rng.gen(), ());\n-                }\n-            })\n+            for _ in range(0u, MAP_SIZE) {\n+                m.insert(rng.gen(), ());\n+            }\n+        });\n     }\n+\n     #[bench]\n     fn bench_insert_small_low_bits(b: &mut Bencher) {\n         let mut m = TrieMap::<()>::new();\n         let mut rng = weak_rng();\n \n         b.iter(|| {\n-                for _ in range(0u, 1000) {\n-                    // only have the last few bits set.\n-                    m.insert(rng.gen::<uint>() & 0xff_ff, ());\n+            for _ in range(0u, MAP_SIZE) {\n+                // only have the last few bits set.\n+                m.insert(rng.gen::<uint>() & 0xff_ff, ());\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_get(b: &mut Bencher) {\n+        let map = random_map(MAP_SIZE);\n+        let keys: Vec<uint> = map.keys().collect();\n+        b.iter(|| {\n+            for key in keys.iter() {\n+                black_box(map.get(key));\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_get_entry(b: &mut Bencher) {\n+        let mut map = random_map(MAP_SIZE);\n+        let keys: Vec<uint> = map.keys().collect();\n+        b.iter(|| {\n+            for key in keys.iter() {\n+                match map.entry(*key) {\n+                    Occupied(e) => { black_box(e.get()); },\n+                    _ => ()\n                 }\n-            })\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_remove(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut map = random_map(MAP_SIZE);\n+            let keys: Vec<uint> = map.keys().collect();\n+            for key in keys.iter() {\n+                black_box(map.remove(key));\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_remove_entry(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut map = random_map(MAP_SIZE);\n+            let keys: Vec<uint> = map.keys().collect();\n+            for key in keys.iter() {\n+                match map.entry(*key) {\n+                    Occupied(e) => { black_box(e.take()); },\n+                    _ => ()\n+                }\n+            }\n+        });\n     }\n }"}]}