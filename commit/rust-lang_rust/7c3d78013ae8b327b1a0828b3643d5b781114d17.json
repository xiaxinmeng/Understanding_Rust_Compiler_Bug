{"sha": "7c3d78013ae8b327b1a0828b3643d5b781114d17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjM2Q3ODAxM2FlOGIzMjdiMWEwODI4YjM2NDNkNWI3ODExMTRkMTc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-13T14:28:22Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-13T14:28:22Z"}, "message": "Reorganize some code in typeck\n\nThis should cut down a lot on the amount of closures being allocated, and removes\nsome duplicated code.", "tree": {"sha": "fc17aa444a68a75a14eed4866bf4d4a1612a76aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc17aa444a68a75a14eed4866bf4d4a1612a76aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c3d78013ae8b327b1a0828b3643d5b781114d17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3d78013ae8b327b1a0828b3643d5b781114d17", "html_url": "https://github.com/rust-lang/rust/commit/7c3d78013ae8b327b1a0828b3643d5b781114d17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c3d78013ae8b327b1a0828b3643d5b781114d17/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a98dec035f1f2ddce6efcf3c2f43884ef659cc0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a98dec035f1f2ddce6efcf3c2f43884ef659cc0a", "html_url": "https://github.com/rust-lang/rust/commit/a98dec035f1f2ddce6efcf3c2f43884ef659cc0a"}], "stats": {"total": 538, "additions": 233, "deletions": 305}, "files": [{"sha": "0bef6035016f506e55a3fa7f991764dc831bf82e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 233, "deletions": 305, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/7c3d78013ae8b327b1a0828b3643d5b781114d17/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c3d78013ae8b327b1a0828b3643d5b781114d17/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=7c3d78013ae8b327b1a0828b3643d5b781114d17", "patch": "@@ -48,9 +48,6 @@ type fn_ctxt =\n      ccx: @crate_ctxt};\n \n \n-// Used for ast_ty_to_ty() below.\n-type ty_getter = fn@(ast::def_id) -> ty::ty_param_kinds_and_ty;\n-\n fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> int {\n     alt fcx.locals.find(id) {\n       some(x) { x }\n@@ -229,11 +226,32 @@ fn default_arg_mode_for_ty(tcx: ty::ctxt, m: ast::mode,\n       _ { m }\n     }\n }\n-fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n-    -> ty::t {\n-    fn ast_arg_to_arg(tcx: ty::ctxt, getter: ty_getter, arg: ast::ty_arg)\n+\n+tag mode { m_collect; m_check; m_check_tyvar(@fn_ctxt); }\n+\n+fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n+    fn getter(tcx: ty::ctxt, mode: mode, id: ast::def_id)\n+        -> ty::ty_param_kinds_and_ty {\n+        alt mode {\n+          m_check. | m_check_tyvar(_) { ty::lookup_item_type(tcx, id) }\n+          m_collect. {\n+            if id.crate != ast::local_crate { csearch::get_type(tcx, id) }\n+            else {\n+                alt tcx.items.find(id.node) {\n+                  some(ast_map::node_item(item)) {\n+                    ty_of_item(tcx, mode, item)\n+                  }\n+                  some(ast_map::node_native_item(native_item)) {\n+                    ty_of_native_item(tcx, mode, native_item)\n+                  }\n+                }\n+            }\n+          }\n+        }\n+    }\n+    fn ast_arg_to_arg(tcx: ty::ctxt, mode: mode, arg: ast::ty_arg)\n         -> {mode: ty::mode, ty: ty::t} {\n-        let ty = ast_ty_to_ty(tcx, getter, arg.node.ty);\n+        let ty = ast_ty_to_ty(tcx, mode, arg.node.ty);\n         ret {mode: default_arg_mode_for_ty(tcx, arg.node.mode, ty), ty: ty};\n     }\n     alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n@@ -248,15 +266,15 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n     } /* go on */\n \n     tcx.ast_ty_to_ty_cache.insert(ast_ty, none::<ty::t>);\n-    fn ast_mt_to_mt(tcx: ty::ctxt, getter: ty_getter, mt: ast::mt) -> ty::mt {\n-        ret {ty: ast_ty_to_ty(tcx, getter, mt.ty), mut: mt.mut};\n+    fn ast_mt_to_mt(tcx: ty::ctxt, mode: mode, mt: ast::mt) -> ty::mt {\n+        ret {ty: ast_ty_to_ty(tcx, mode, mt.ty), mut: mt.mut};\n     }\n-    fn instantiate(tcx: ty::ctxt, sp: span, getter: ty_getter,\n+    fn instantiate(tcx: ty::ctxt, sp: span, mode: mode,\n                    id: ast::def_id, args: [@ast::ty]) -> ty::t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n \n-        let ty_param_kinds_and_ty = getter(id);\n+        let ty_param_kinds_and_ty = getter(tcx, mode, id);\n         if vec::len(ty_param_kinds_and_ty.kinds) == 0u {\n             ret ty_param_kinds_and_ty.ty;\n         }\n@@ -268,7 +286,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n                                      polymorphic type\");\n         }\n         for ast_ty: @ast::ty in args {\n-            param_bindings += [ast_ty_to_ty(tcx, getter, ast_ty)];\n+            param_bindings += [ast_ty_to_ty(tcx, mode, ast_ty)];\n         }\n         let typ =\n             ty::substitute_type_params(tcx, param_bindings,\n@@ -286,35 +304,35 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n       ast::ty_float(ft) { typ = ty::mk_mach_float(tcx, ft); }\n       ast::ty_str. { typ = ty::mk_str(tcx); }\n       ast::ty_box(mt) {\n-        typ = ty::mk_box(tcx, ast_mt_to_mt(tcx, getter, mt));\n+        typ = ty::mk_box(tcx, ast_mt_to_mt(tcx, mode, mt));\n       }\n       ast::ty_uniq(mt) {\n-        typ = ty::mk_uniq(tcx, ast_mt_to_mt(tcx, getter, mt));\n+        typ = ty::mk_uniq(tcx, ast_mt_to_mt(tcx, mode, mt));\n       }\n       ast::ty_vec(mt) {\n-        typ = ty::mk_vec(tcx, ast_mt_to_mt(tcx, getter, mt));\n+        typ = ty::mk_vec(tcx, ast_mt_to_mt(tcx, mode, mt));\n       }\n       ast::ty_ptr(mt) {\n-        typ = ty::mk_ptr(tcx, ast_mt_to_mt(tcx, getter, mt));\n+        typ = ty::mk_ptr(tcx, ast_mt_to_mt(tcx, mode, mt));\n       }\n       ast::ty_tup(fields) {\n-        let flds = vec::map(bind ast_ty_to_ty(tcx, getter, _), fields);\n+        let flds = vec::map(bind ast_ty_to_ty(tcx, mode, _), fields);\n         typ = ty::mk_tup(tcx, flds);\n       }\n       ast::ty_rec(fields) {\n         let flds: [field] = [];\n         for f: ast::ty_field in fields {\n-            let tm = ast_mt_to_mt(tcx, getter, f.node.mt);\n+            let tm = ast_mt_to_mt(tcx, mode, f.node.mt);\n             flds += [{ident: f.node.ident, mt: tm}];\n         }\n         typ = ty::mk_rec(tcx, flds);\n       }\n       ast::ty_fn(proto, inputs, output, cf, constrs) {\n         let i = [];\n         for ta: ast::ty_arg in inputs {\n-            i += [ast_arg_to_arg(tcx, getter, ta)];\n+            i += [ast_arg_to_arg(tcx, mode, ta)];\n         }\n-        let out_ty = ast_ty_to_ty(tcx, getter, output);\n+        let out_ty = ast_ty_to_ty(tcx, mode, output);\n \n         let out_constrs = [];\n         for constr: @ast::constr in constrs {\n@@ -325,9 +343,9 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n       ast::ty_path(path, id) {\n         alt tcx.def_map.find(id) {\n           some(ast::def_ty(id)) {\n-            typ = instantiate(tcx, ast_ty.span, getter, id, path.node.types);\n+            typ = instantiate(tcx, ast_ty.span, mode, id, path.node.types);\n           }\n-          some(ast::def_native_ty(id)) { typ = getter(id).ty; }\n+          some(ast::def_native_ty(id)) { typ = getter(tcx, mode, id).ty; }\n           some(ast::def_ty_param(id, k)) { typ = ty::mk_param(tcx, id, k); }\n           some(_) {\n             tcx.sess.span_fatal(ast_ty.span,\n@@ -344,9 +362,9 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n         for m: ast::ty_method in meths {\n             let ins = [];\n             for ta: ast::ty_arg in m.node.inputs {\n-                ins += [ast_arg_to_arg(tcx, getter, ta)];\n+                ins += [ast_arg_to_arg(tcx, mode, ta)];\n             }\n-            let out = ast_ty_to_ty(tcx, getter, m.node.output);\n+            let out = ast_ty_to_ty(tcx, mode, m.node.output);\n \n             let out_constrs = [];\n             for constr: @ast::constr in m.node.constrs {\n@@ -368,10 +386,14 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n         for constr: @ast::ty_constr in cs {\n             out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n         }\n-        typ = ty::mk_constr(tcx, ast_ty_to_ty(tcx, getter, t), out_cs);\n+        typ = ty::mk_constr(tcx, ast_ty_to_ty(tcx, mode, t), out_cs);\n       }\n       ast::ty_infer. {\n-        tcx.sess.span_bug(ast_ty.span, \"found ty_infer in unexpected place\");\n+        alt mode {\n+          m_check_tyvar(fcx) { ret next_ty_var(fcx); }\n+          _ { tcx.sess.span_bug(ast_ty.span,\n+                                \"found ty_infer in unexpected place\"); }\n+        }\n       }\n     }\n     alt cname {\n@@ -382,16 +404,160 @@ fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, &&ast_ty: @ast::ty)\n     ret typ;\n }\n \n+fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n+    -> ty::ty_param_kinds_and_ty {\n+    let no_kinds: [ast::kind] = [];\n+    alt it.node {\n+      ast::item_const(t, _) {\n+        let typ = ast_ty_to_ty(tcx, mode, t);\n+        let tpt = {kinds: no_kinds, ty: typ};\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_fn(fn_info, tps) {\n+        ret ty_of_fn_decl(tcx, mode, fn_info.decl, fn_info.proto,\n+                          tps, some(local_def(it.id)));\n+      }\n+      ast::item_obj(ob, tps, _) {\n+        let t_obj = ty_of_obj(tcx, mode, it.ident, ob, tps);\n+        tcx.tcache.insert(local_def(it.id), t_obj);\n+        ret t_obj;\n+      }\n+      ast::item_ty(t, tps) {\n+        alt tcx.tcache.find(local_def(it.id)) {\n+          some(tpt) { ret tpt; }\n+          none. { }\n+        }\n+        // Tell ast_ty_to_ty() that we want to perform a recursive\n+        // call to resolve any named types.\n+\n+        let typ = ast_ty_to_ty(tcx, mode, t);\n+        let tpt = {kinds: ty_param_kinds(tps), ty: typ};\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_res(f, _, tps, _) {\n+        let t_arg = ty_of_arg(tcx, mode, f.decl.inputs[0]);\n+        let t_res =\n+            {kinds: ty_param_kinds(tps),\n+             ty: ty::mk_res(tcx, local_def(it.id), t_arg.ty,\n+                            mk_ty_params(tcx, tps))};\n+        tcx.tcache.insert(local_def(it.id), t_res);\n+        ret t_res;\n+      }\n+      ast::item_tag(_, tps) {\n+        // Create a new generic polytype.\n+        let subtys: [ty::t] = mk_ty_params(tcx, tps);\n+        let t = ty::mk_tag(tcx, local_def(it.id), subtys);\n+        let tpt = {kinds: ty_param_kinds(tps), ty: t};\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+      ast::item_mod(_) { fail; }\n+      ast::item_native_mod(_) { fail; }\n+    }\n+}\n+fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n+    -> ty::ty_param_kinds_and_ty {\n+    let no_kinds: [ast::kind] = [];\n+    alt it.node {\n+      ast::native_item_fn(fn_decl, params) {\n+        ret ty_of_native_fn_decl(tcx, mode, fn_decl, params,\n+                                 ast_util::local_def(it.id));\n+      }\n+      ast::native_item_ty. {\n+        alt tcx.tcache.find(local_def(it.id)) {\n+          some(tpt) { ret tpt; }\n+          none. { }\n+        }\n+        let t = ty::mk_native(tcx, ast_util::local_def(it.id));\n+        let tpt = {kinds: no_kinds, ty: t};\n+        tcx.tcache.insert(local_def(it.id), tpt);\n+        ret tpt;\n+      }\n+    }\n+}\n+fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n+    let ty = ast_ty_to_ty(tcx, mode, a.ty);\n+    {mode: default_arg_mode_for_ty(tcx, a.mode, ty), ty: ty}\n+}\n+fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n+           proto: ast::proto, ty_params: [ast::ty_param],\n+           def_id: option::t<ast::def_id>) -> ty::ty_param_kinds_and_ty {\n+    let input_tys = [];\n+    for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(tcx, mode, a)]; }\n+    let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n+\n+    let out_constrs = [];\n+    for constr: @ast::constr in decl.constraints {\n+        out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n+    }\n+    let t_fn = ty::mk_fn(tcx, proto, input_tys, output_ty,\n+                         decl.cf, out_constrs);\n+    let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n+    alt def_id { some(did) { tcx.tcache.insert(did, tpt); } _ { } }\n+    ret tpt;\n+}\n+fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n+                  ty_params: [ast::ty_param], def_id: ast::def_id)\n+    -> ty::ty_param_kinds_and_ty {\n+    let input_tys = [];\n+    for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(tcx, mode, a)]; }\n+    let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n+\n+    let t_fn = ty::mk_native_fn(tcx, input_tys, output_ty);\n+    let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n+    tcx.tcache.insert(def_id, tpt);\n+    ret tpt;\n+}\n+fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n+    let inputs = vec::map({|i| ty_of_arg(tcx, mode, i)},\n+                          m.node.meth.decl.inputs);\n+    let output = ast_ty_to_ty(tcx, mode, m.node.meth.decl.output);\n+\n+    let out_constrs = [];\n+    for constr: @ast::constr in m.node.meth.decl.constraints {\n+        out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n+    }\n+    ret {proto: m.node.meth.proto,\n+         ident: m.node.ident,\n+         inputs: inputs,\n+         output: output,\n+         cf: m.node.meth.decl.cf,\n+         constrs: out_constrs};\n+}\n+fn ty_of_obj(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n+        ty_params: [ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n+    let methods = ty_of_obj_methods(tcx, mode, ob);\n+    let t_obj = ty::mk_obj(tcx, ty::sort_methods(methods));\n+    t_obj = ty::rename(tcx, t_obj, id);\n+    ret {kinds: ty_param_kinds(ty_params), ty: t_obj};\n+}\n+fn ty_of_obj_methods(tcx: ty::ctxt, mode: mode, object: ast::_obj)\n+    -> [ty::method] {\n+    vec::map({|m| ty_of_method(tcx, mode, m)}, object.methods)\n+}\n+fn ty_of_obj_ctor(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n+            ctor_id: ast::node_id, ty_params: [ast::ty_param])\n+    -> ty::ty_param_kinds_and_ty {\n+    let t_obj = ty_of_obj(tcx, mode, id, ob, ty_params);\n+    let t_inputs: [arg] = [];\n+    for f: ast::obj_field in ob.fields {\n+        let t_field = ast_ty_to_ty(tcx, mode, f.ty);\n+        t_inputs += [{mode: ast::by_copy, ty: t_field}];\n+    }\n+    let t_fn = ty::mk_fn(tcx, ast::proto_shared(ast::sugar_normal),\n+                         t_inputs, t_obj.ty,\n+                         ast::return_val, []);\n+    let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n+    tcx.tcache.insert(local_def(ctor_id), tpt);\n+    ret tpt;\n+}\n \n // A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n fn ast_ty_to_ty_crate(ccx: @crate_ctxt, &&ast_ty: @ast::ty) -> ty::t {\n-    fn getter(ccx: @crate_ctxt, id: ast::def_id) ->\n-       ty::ty_param_kinds_and_ty {\n-        ret ty::lookup_item_type(ccx.tcx, id);\n-    }\n-    let f = bind getter(ccx, _);\n-    ret ast_ty_to_ty(ccx.tcx, f, ast_ty);\n+    ret ast_ty_to_ty(ccx.tcx, m_check, ast_ty);\n }\n \n // A wrapper around ast_ty_to_ty_crate that handles ty_infer.\n@@ -402,14 +568,6 @@ fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, &&ast_ty: @ast::ty) ->\n       _ { some(ast_ty_to_ty_crate(ccx, ast_ty)) }\n     }\n }\n-// A wrapper around ast_ty_to_ty_infer that generates a new type variable if\n-// there isn't a fixed type.\n-fn ast_ty_to_ty_crate_tyvar(fcx: @fn_ctxt, &&ast_ty: @ast::ty) -> ty::t {\n-    alt ast_ty_to_ty_crate_infer(fcx.ccx, ast_ty) {\n-      some(ty) { ty }\n-      none. { next_ty_var(fcx) }\n-    }\n-}\n \n \n // Functions that write types into the node type table.\n@@ -428,7 +586,7 @@ mod write {\n \n     // Writes a type parameter count and type pair into the node type table.\n     // This function allows for the possibility of type variables, which will\n-    // be rewritten later during the fixup phase.\n+    // be rewritten later during the fixup mode.\n     fn ty_fixup(fcx: @fn_ctxt, node_id: ast::node_id,\n                 tpot: ty_param_substs_opt_and_ty) {\n         inner(fcx.ccx.tcx.node_types, node_id, tpot);\n@@ -459,6 +617,21 @@ mod write {\n     }\n }\n \n+fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param]) -> [ty::t] {\n+    let tps = [];\n+    let i = 0u;\n+    for atp: ast::ty_param in atps {\n+        tps += [ty::mk_param(tcx, i, ty_param_kind(atp))];\n+        i += 1u;\n+    }\n+    ret tps;\n+}\n+\n+fn ty_param_kinds(tps: [ast::ty_param]) -> [ast::kind] {\n+    let k: [ast::kind] = [];\n+    for p: ast::ty_param in tps { k += [ty_param_kind(p)]; }\n+    ret k;\n+}\n \n // Item collection - a pair of bootstrap passes:\n //\n@@ -477,209 +650,12 @@ mod write {\n mod collect {\n     type ctxt = {tcx: ty::ctxt};\n \n-    fn mk_ty_params(cx: @ctxt, atps: [ast::ty_param]) -> [ty::t] {\n-        let tps = [];\n-        let i = 0u;\n-        for atp: ast::ty_param in atps {\n-            tps += [ty::mk_param(cx.tcx, i, ty_param_kind(atp))];\n-            i += 1u;\n-        }\n-        ret tps;\n-    }\n-\n-    fn ty_param_kinds(tps: [ast::ty_param]) -> [ast::kind] {\n-        let k: [ast::kind] = [];\n-        for p: ast::ty_param in tps { k += [ty_param_kind(p)]; }\n-        ret k;\n-    }\n-\n-    fn ty_of_fn_decl(cx: @ctxt, convert: fn@(&&@ast::ty) -> ty::t,\n-                     ty_of_arg: fn@(ast::arg) -> arg, decl: ast::fn_decl,\n-                     proto: ast::proto, ty_params: [ast::ty_param],\n-                     def_id: option::t<ast::def_id>) ->\n-       ty::ty_param_kinds_and_ty {\n-        let input_tys = [];\n-        for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(a)]; }\n-        let output_ty = convert(decl.output);\n-\n-        let out_constrs = [];\n-        for constr: @ast::constr in decl.constraints {\n-            out_constrs += [ty::ast_constr_to_constr(cx.tcx, constr)];\n-        }\n-        let t_fn =\n-            ty::mk_fn(cx.tcx, proto, input_tys, output_ty,\n-                      decl.cf, out_constrs);\n-        let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n-        alt def_id { some(did) { cx.tcx.tcache.insert(did, tpt); } _ { } }\n-        ret tpt;\n-    }\n-    fn ty_of_native_fn_decl(cx: @ctxt, convert: fn@(&&@ast::ty) -> ty::t,\n-                            ty_of_arg: fn@(ast::arg) -> arg,\n-                            decl: ast::fn_decl,\n-                            ty_params: [ast::ty_param], def_id: ast::def_id)\n-       -> ty::ty_param_kinds_and_ty {\n-        let input_tys = [];\n-        for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(a)]; }\n-        let output_ty = convert(decl.output);\n-\n-        let t_fn = ty::mk_native_fn(cx.tcx, input_tys, output_ty);\n-        let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n-        cx.tcx.tcache.insert(def_id, tpt);\n-        ret tpt;\n-    }\n-    fn getter(cx: @ctxt, id: ast::def_id) -> ty::ty_param_kinds_and_ty {\n-        if id.crate != ast::local_crate {\n-            // This is a type we need to load in from the crate reader.\n-            ret csearch::get_type(cx.tcx, id);\n-        }\n-        let it = cx.tcx.items.find(id.node);\n-        let tpt;\n-        alt it {\n-          some(ast_map::node_item(item)) { tpt = ty_of_item(cx, item); }\n-          some(ast_map::node_native_item(native_item)) {\n-            tpt = ty_of_native_item(cx, native_item);\n-          }\n-          _ { cx.tcx.sess.fatal(\"internal error \" + std::int::str(id.node)); }\n-        }\n-        ret tpt;\n-    }\n-    fn ty_of_arg(cx: @ctxt, a: ast::arg) -> ty::arg {\n-        let ty = ast_ty_to_ty(cx.tcx, bind getter(cx, _), a.ty);\n-        {mode: default_arg_mode_for_ty(cx.tcx, a.mode, ty), ty: ty}\n-    }\n-    fn ty_of_method(cx: @ctxt, m: @ast::method) -> ty::method {\n-        let get = bind getter(cx, _);\n-        let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n-\n-        let inputs = [];\n-        for a: ast::arg in m.node.meth.decl.inputs {\n-            inputs += [ty_of_arg(cx, a)];\n-        }\n-\n-        let output = convert(m.node.meth.decl.output);\n-\n-        let out_constrs = [];\n-        for constr: @ast::constr in m.node.meth.decl.constraints {\n-            out_constrs += [ty::ast_constr_to_constr(cx.tcx, constr)];\n-        }\n-        ret {proto: m.node.meth.proto,\n-             ident: m.node.ident,\n-             inputs: inputs,\n-             output: output,\n-             cf: m.node.meth.decl.cf,\n-             constrs: out_constrs};\n-    }\n-    fn ty_of_obj(cx: @ctxt, id: ast::ident, ob: ast::_obj,\n-                 ty_params: [ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n-        let methods = get_obj_method_types(cx, ob);\n-        let t_obj = ty::mk_obj(cx.tcx, ty::sort_methods(methods));\n-        t_obj = ty::rename(cx.tcx, t_obj, id);\n-        ret {kinds: ty_param_kinds(ty_params), ty: t_obj};\n-    }\n-    fn ty_of_obj_ctor(cx: @ctxt, id: ast::ident, ob: ast::_obj,\n-                      ctor_id: ast::node_id, ty_params: [ast::ty_param]) ->\n-       ty::ty_param_kinds_and_ty {\n-        let t_obj = ty_of_obj(cx, id, ob, ty_params);\n-\n-        let t_inputs: [arg] = [];\n-        for f: ast::obj_field in ob.fields {\n-            let g = bind getter(cx, _);\n-            let t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n-            t_inputs += [{mode: ast::by_copy, ty: t_field}];\n-        }\n-\n-        let t_fn =\n-            ty::mk_fn(cx.tcx, ast::proto_shared(ast::sugar_normal),\n-                      t_inputs, t_obj.ty,\n-                      ast::return_val, []);\n-        let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n-        cx.tcx.tcache.insert(local_def(ctor_id), tpt);\n-        ret tpt;\n-    }\n-    fn ty_of_item(cx: @ctxt, it: @ast::item) -> ty::ty_param_kinds_and_ty {\n-        let get = bind getter(cx, _);\n-        let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n-        let no_kinds: [ast::kind] = [];\n-        alt it.node {\n-          ast::item_const(t, _) {\n-            let typ = convert(t);\n-            let tpt = {kinds: no_kinds, ty: typ};\n-            cx.tcx.tcache.insert(local_def(it.id), tpt);\n-            ret tpt;\n-          }\n-          ast::item_fn(fn_info, tps) {\n-            let f = bind ty_of_arg(cx, _);\n-            ret ty_of_fn_decl(cx, convert, f, fn_info.decl, fn_info.proto,\n-                              tps, some(local_def(it.id)));\n-          }\n-          ast::item_obj(ob, tps, _) {\n-            let t_obj = ty_of_obj(cx, it.ident, ob, tps);\n-            cx.tcx.tcache.insert(local_def(it.id), t_obj);\n-            ret t_obj;\n-          }\n-          ast::item_ty(t, tps) {\n-            alt cx.tcx.tcache.find(local_def(it.id)) {\n-              some(tpt) { ret tpt; }\n-              none. { }\n-            }\n-            // Tell ast_ty_to_ty() that we want to perform a recursive\n-            // call to resolve any named types.\n-\n-            let typ = convert(t);\n-            let tpt = {kinds: ty_param_kinds(tps), ty: typ};\n-            cx.tcx.tcache.insert(local_def(it.id), tpt);\n-            ret tpt;\n-          }\n-          ast::item_res(f, _, tps, _) {\n-            let t_arg = ty_of_arg(cx, f.decl.inputs[0]);\n-            let t_res =\n-                {kinds: ty_param_kinds(tps),\n-                 ty: ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n-                                mk_ty_params(cx, tps))};\n-            cx.tcx.tcache.insert(local_def(it.id), t_res);\n-            ret t_res;\n-          }\n-          ast::item_tag(_, tps) {\n-            // Create a new generic polytype.\n-            let subtys: [ty::t] = mk_ty_params(cx, tps);\n-            let t = ty::mk_tag(cx.tcx, local_def(it.id), subtys);\n-            let tpt = {kinds: ty_param_kinds(tps), ty: t};\n-            cx.tcx.tcache.insert(local_def(it.id), tpt);\n-            ret tpt;\n-          }\n-          ast::item_mod(_) { fail; }\n-          ast::item_native_mod(_) { fail; }\n-        }\n-    }\n-    fn ty_of_native_item(cx: @ctxt, it: @ast::native_item)\n-        -> ty::ty_param_kinds_and_ty {\n-        let no_kinds: [ast::kind] = [];\n-        alt it.node {\n-          ast::native_item_fn(fn_decl, params) {\n-            let get = bind getter(cx, _);\n-            let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n-            let f = bind ty_of_arg(cx, _);\n-            ret ty_of_native_fn_decl(cx, convert, f, fn_decl, params,\n-                                     ast_util::local_def(it.id));\n-          }\n-          ast::native_item_ty. {\n-            alt cx.tcx.tcache.find(local_def(it.id)) {\n-              some(tpt) { ret tpt; }\n-              none. { }\n-            }\n-            let t = ty::mk_native(cx.tcx, ast_util::local_def(it.id));\n-            let tpt = {kinds: no_kinds, ty: t};\n-            cx.tcx.tcache.insert(local_def(it.id), tpt);\n-            ret tpt;\n-          }\n-        }\n-    }\n     fn get_tag_variant_types(cx: @ctxt, tag_id: ast::def_id,\n                              variants: [ast::variant],\n                              ty_params: [ast::ty_param]) {\n         // Create a set of parameter types shared among all the variants.\n \n-        let ty_param_tys: [ty::t] = mk_ty_params(cx, ty_params);\n+        let ty_param_tys: [ty::t] = mk_ty_params(cx.tcx, ty_params);\n         for variant: ast::variant in variants {\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n@@ -690,11 +666,9 @@ mod collect {\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n-\n-                let f = bind getter(cx, _);\n                 let args: [arg] = [];\n                 for va: ast::variant_arg in variant.node.args {\n-                    let arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n+                    let arg_ty = ast_ty_to_ty(cx.tcx, m_collect, va.ty);\n                     args += [{mode: ast::by_copy, ty: arg_ty}];\n                 }\n                 let tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n@@ -709,13 +683,6 @@ mod collect {\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n     }\n-    fn get_obj_method_types(cx: @ctxt, object: ast::_obj) -> [ty::method] {\n-        let meths = [];\n-        for m: @ast::method in object.methods {\n-            meths += [ty_of_method(cx, m)];\n-        }\n-        ret meths;\n-    }\n     fn convert(cx: @ctxt, it: @ast::item) {\n         alt it.node {\n           ast::item_mod(_) {\n@@ -725,24 +692,23 @@ mod collect {\n             // do nothing, as native modules have no types.\n           }\n           ast::item_tag(variants, ty_params) {\n-            let tpt = ty_of_item(cx, it);\n+            let tpt = ty_of_item(cx.tcx, m_collect, it);\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n             get_tag_variant_types(cx, local_def(it.id), variants, ty_params);\n           }\n           ast::item_obj(object, ty_params, ctor_id) {\n             // Now we need to call ty_of_obj_ctor(); this is the type that\n             // we write into the table for this item.\n-            ty_of_item(cx, it);\n-\n-            let tpt =\n-                ty_of_obj_ctor(cx, it.ident, object, ctor_id, ty_params);\n+            ty_of_item(cx.tcx, m_collect, it);\n+            let tpt = ty_of_obj_ctor(cx.tcx, m_collect, it.ident, object,\n+                                      ctor_id, ty_params);\n             write::ty_only(cx.tcx, ctor_id, tpt.ty);\n             // Write the methods into the type table.\n             //\n             // FIXME: Inefficient; this ends up calling\n             // get_obj_method_types() twice. (The first time was above in\n             // ty_of_obj().)\n-            let method_types = get_obj_method_types(cx, object);\n+            let method_types = ty_of_obj_methods(cx.tcx, m_collect, object);\n             let i = 0u;\n             while i < vec::len::<@ast::method>(object.methods) {\n                 write::ty_only(cx.tcx, object.methods[i].node.id,\n@@ -763,10 +729,10 @@ mod collect {\n             }\n           }\n           ast::item_res(f, dtor_id, tps, ctor_id) {\n-            let t_arg = ty_of_arg(cx, f.decl.inputs[0]);\n+            let t_arg = ty_of_arg(cx.tcx, m_collect, f.decl.inputs[0]);\n             let t_res =\n                 ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n-                           mk_ty_params(cx, tps));\n+                           mk_ty_params(cx.tcx, tps));\n             let t_ctor =\n                 ty::mk_fn(cx.tcx, ast::proto_shared(ast::sugar_normal),\n                           [{mode: ast::by_copy with t_arg}], t_res,\n@@ -786,7 +752,7 @@ mod collect {\n             // This call populates the type cache with the converted type\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n-            let tpt = ty_of_item(cx, it);\n+            let tpt = ty_of_item(cx.tcx, m_collect, it);\n             write::ty_only(cx.tcx, it.id, tpt.ty);\n           }\n         }\n@@ -795,7 +761,7 @@ mod collect {\n         // As above, this call populates the type table with the converted\n         // type of the native item. We simply write it into the node type\n         // table.\n-        let tpt = ty_of_native_item(cx, i);\n+        let tpt = ty_of_native_item(cx.tcx, m_collect, i);\n         alt i.node {\n           ast::native_item_ty. {\n             // FIXME: Native types have no annotation. Should they? --pcw\n@@ -1936,15 +1902,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         write::ty_only_fixup(fcx, id, result_ty);\n       }\n       ast::expr_fn(f) {\n-        let convert = bind ast_ty_to_ty_crate_tyvar(fcx, _);\n-        let ty_of_arg = lambda (a: ast::arg) -> ty::arg {\n-            let tt = ast_ty_to_ty_crate_tyvar(fcx, a.ty);\n-            ret {mode: default_arg_mode_for_ty(fcx.ccx.tcx, a.mode, tt),\n-                 ty: tt};\n-        };\n         let cx = @{tcx: tcx};\n-        let fty = collect::ty_of_fn_decl(cx, convert, ty_of_arg, f.decl,\n-                                         f.proto, [], none).ty;\n+        let fty = ty_of_fn_decl(cx.tcx, m_check_tyvar(fcx), f.decl,\n+                                 f.proto, [], none).ty;\n \n         write::ty_only_fixup(fcx, id, fty);\n \n@@ -2241,41 +2201,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let fields: [ast::anon_obj_field] = [];\n         alt ao.fields { none. { } some(v) { fields = v; } }\n \n-        // FIXME: These next three functions are largely ripped off from\n-        // similar ones in collect::.  Is there a better way to do this?\n-        fn ty_of_arg(ccx: @crate_ctxt, a: ast::arg) -> ty::arg {\n-            let ty = ast_ty_to_ty_crate(ccx, a.ty);\n-            ret {mode: default_arg_mode_for_ty(ccx.tcx, a.mode, ty), ty: ty};\n-        }\n-\n-        fn ty_of_method(ccx: @crate_ctxt, m: @ast::method) -> ty::method {\n-            let convert = bind ast_ty_to_ty_crate(ccx, _);\n-\n-            let inputs = [];\n-            for aa: ast::arg in m.node.meth.decl.inputs {\n-                inputs += [ty_of_arg(ccx, aa)];\n-            }\n-\n-            let output = convert(m.node.meth.decl.output);\n-\n-            let out_constrs = [];\n-            for constr: @ast::constr in m.node.meth.decl.constraints {\n-                out_constrs += [ty::ast_constr_to_constr(ccx.tcx, constr)];\n-            }\n-\n-            ret {proto: m.node.meth.proto,\n-                 ident: m.node.ident,\n-                 inputs: inputs,\n-                 output: output,\n-                 cf: m.node.meth.decl.cf,\n-                 constrs: out_constrs};\n-        }\n-\n         let method_types: [ty::method] = [];\n         {\n             // Outer methods.\n             for m: @ast::method in ao.methods {\n-                method_types += [ty_of_method(fcx.ccx, m)];\n+                method_types += [ty_of_method(fcx.ccx.tcx, m_check, m)];\n             }\n \n             // Inner methods.\n@@ -2326,7 +2256,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                     if str::eq(om.node.ident, m.ident) {\n                         // We'd better be overriding with one of the same\n                         // type.  Check to make sure.\n-                        let new_type = ty_of_method(ccx, om);\n+                        let new_type = ty_of_method(ccx.tcx, m_check, om);\n                         if new_type != m {\n                             ccx.tcx.sess.span_fatal\n                                 (om.span, \"attempted to override method \"\n@@ -2517,22 +2447,20 @@ fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n               _ {\n                 fcx.ccx.tcx.sess.span_err(operator.span,\n                                             \"Impure function as operator \\\n-in constraint\");\n+                                             in constraint\");\n               }\n             }\n             for operand: @ast::expr in operands {\n                 if !ast_util::is_constraint_arg(operand) {\n                     let s =\n-                        \"Constraint args must be \\\n-slot variables or literals\";\n+                        \"Constraint args must be slot variables or literals\";\n                     fcx.ccx.tcx.sess.span_err(e.span, s);\n                 }\n             }\n           }\n           _ {\n-            let s =\n-                \"In a constraint, expected the \\\n-constraint name to be an explicit name\";\n+            let s = \"In a constraint, expected the \\\n+                     constraint name to be an explicit name\";\n             fcx.ccx.tcx.sess.span_err(e.span, s);\n           }\n         }"}]}