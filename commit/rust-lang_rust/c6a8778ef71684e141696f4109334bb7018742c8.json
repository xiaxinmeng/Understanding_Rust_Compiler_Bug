{"sha": "c6a8778ef71684e141696f4109334bb7018742c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YTg3NzhlZjcxNjg0ZTE0MTY5NmY0MTA5MzM0YmI3MDE4NzQyYzg=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2012-12-22T01:34:30Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2012-12-22T06:14:26Z"}, "message": "Move BigUint and BigDIgit to std::bigint.", "tree": {"sha": "d3fc4a4bcd7a9896ef109df919cb835033b25c49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3fc4a4bcd7a9896ef109df919cb835033b25c49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6a8778ef71684e141696f4109334bb7018742c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a8778ef71684e141696f4109334bb7018742c8", "html_url": "https://github.com/rust-lang/rust/commit/c6a8778ef71684e141696f4109334bb7018742c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6a8778ef71684e141696f4109334bb7018742c8/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccc1f8d5e8f3ed1751c783e875ba318e577cfb56", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56", "html_url": "https://github.com/rust-lang/rust/commit/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56"}], "stats": {"total": 1679, "additions": 834, "deletions": 845}, "files": [{"sha": "4dc009794982a8aa5ce47b27d31ba46820eee63c", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 834, "deletions": 4, "changes": 838, "blob_url": "https://github.com/rust-lang/rust/blob/c6a8778ef71684e141696f4109334bb7018742c8/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a8778ef71684e141696f4109334bb7018742c8/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=c6a8778ef71684e141696f4109334bb7018742c8", "patch": "@@ -1,13 +1,486 @@\n /*!\n \n-A Big signed integer.\n+A Big integer (signed version: BigInt, unsigned version: BigUint).\n \n+A BigUint is represented as an array of BigDigits.\n A BigInt is a combination of BigUint and Sign.\n */\n \n use core::cmp::{Eq, Ord};\n \n-use biguint::{BigDigit, BigUint};\n+/**\n+A BigDigit is a BigUint's composing element.\n+\n+A BigDigit is half the size of machine word size.\n+*/\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"arm\")]\n+pub type BigDigit = u16;\n+\n+/**\n+A BigDigit is a BigUint's composing element.\n+\n+A BigDigit is half the size of machine word size.\n+*/\n+#[cfg(target_arch = \"x86_64\")]\n+pub type BigDigit = u32;\n+\n+pub mod BigDigit {\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"arm\")]\n+    pub const bits: uint = 16;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    pub const bits: uint = 32;\n+\n+    pub const base: uint = 1 << bits;\n+    priv const hi_mask: uint = (-1 as uint) << bits;\n+    priv const lo_mask: uint = (-1 as uint) >> bits;\n+\n+    priv pure fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n+    priv pure fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n+\n+    /// Split one machine sized unsigned integer into two BigDigits.\n+    pub pure fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n+        (get_hi(n), get_lo(n))\n+    }\n+\n+    /// Join two BigDigits into one machine sized unsigned integer\n+    pub pure fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n+        (lo as uint) | ((hi as uint) << bits)\n+    }\n+}\n+\n+/**\n+A big unsigned integer type.\n+\n+A BigUint-typed value BigUint { data: @[a, b, c] } represents a number\n+(a + b * BigDigit::base + c * BigDigit::base^2).\n+*/\n+pub struct BigUint {\n+    priv data: @[BigDigit]\n+}\n+\n+impl BigUint : Eq {\n+    pure fn eq(&self, other: &BigUint) -> bool { self.cmp(other) == 0 }\n+    pure fn ne(&self, other: &BigUint) -> bool { self.cmp(other) != 0 }\n+}\n+\n+impl BigUint : Ord {\n+    pure fn lt(&self, other: &BigUint) -> bool { self.cmp(other) <  0 }\n+    pure fn le(&self, other: &BigUint) -> bool { self.cmp(other) <= 0 }\n+    pure fn ge(&self, other: &BigUint) -> bool { self.cmp(other) >= 0 }\n+    pure fn gt(&self, other: &BigUint) -> bool { self.cmp(other) >  0 }\n+}\n+\n+impl BigUint : ToStr {\n+    pure fn to_str() -> ~str { self.to_str_radix(10) }\n+}\n+\n+impl BigUint : from_str::FromStr {\n+    static pure fn from_str(s: &str) -> Option<BigUint> {\n+        BigUint::from_str_radix(s, 10)\n+    }\n+}\n+\n+impl BigUint : Shl<uint, BigUint> {\n+    pure fn shl(&self, rhs: &uint) -> BigUint {\n+        let n_unit = *rhs / BigDigit::bits;\n+        let n_bits = *rhs % BigDigit::bits;\n+        return self.shl_unit(n_unit).shl_bits(n_bits);\n+    }\n+}\n+\n+impl BigUint : Shr<uint, BigUint> {\n+    pure fn shr(&self, rhs: &uint) -> BigUint {\n+        let n_unit = *rhs / BigDigit::bits;\n+        let n_bits = *rhs % BigDigit::bits;\n+        return self.shr_unit(n_unit).shr_bits(n_bits);\n+    }\n+}\n+\n+impl BigUint : Num {\n+    pure fn add(&self, other: &BigUint) -> BigUint {\n+        let new_len = uint::max(self.data.len(), other.data.len());\n+\n+        let mut carry = 0;\n+        let sum = do at_vec::from_fn(new_len) |i| {\n+            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n+            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n+            let (hi, lo) = BigDigit::from_uint(\n+                (ai as uint) + (bi as uint) + (carry as uint)\n+            );\n+            carry = hi;\n+            lo\n+        };\n+        if carry == 0 { return BigUint::from_at_vec(sum) };\n+        return BigUint::from_at_vec(sum + [carry]);\n+    }\n+\n+    pure fn sub(&self, other: &BigUint) -> BigUint {\n+        let new_len = uint::max(self.data.len(), other.data.len());\n+\n+        let mut borrow = 0;\n+        let diff = do at_vec::from_fn(new_len) |i| {\n+            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n+            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n+            let (hi, lo) = BigDigit::from_uint(\n+                (BigDigit::base) +\n+                (ai as uint) - (bi as uint) - (borrow as uint)\n+            );\n+            /*\n+            hi * (base) + lo == 1*(base) + ai - bi - borrow\n+            => ai - bi - borrow < 0 <=> hi == 0\n+            */\n+            borrow = if hi == 0 { 1 } else { 0 };\n+            lo\n+        };\n+\n+        assert borrow == 0;     // <=> assert (self >= other);\n+        return BigUint::from_at_vec(diff);\n+    }\n+\n+    pure fn mul(&self, other: &BigUint) -> BigUint {\n+        if self.is_zero() || other.is_zero() { return BigUint::zero(); }\n+\n+        let s_len = self.data.len(), o_len = other.data.len();\n+        if s_len == 1 { return mul_digit(other, self.data[0]);  }\n+        if o_len == 1 { return mul_digit(self,  other.data[0]); }\n+\n+        // Using Karatsuba multiplication\n+        // (a1 * base + a0) * (b1 * base + b0)\n+        // = a1*b1 * base^2 +\n+        //   (a1*b1 + a0*b0 - (a1-b0)*(b1-a0)) * base +\n+        //   a0*b0\n+        let half_len = uint::max(s_len, o_len) / 2;\n+        let (sHi, sLo) = cut_at(self,  half_len);\n+        let (oHi, oLo) = cut_at(other, half_len);\n+\n+        let ll = sLo * oLo;\n+        let hh = sHi * oHi;\n+        let mm =  match (sub_sign(sHi, sLo), sub_sign(oHi, oLo)) {\n+            ((s1, n1), (s2, n2)) if s1 * s2 < 0 => hh + ll + (n1 * n2),\n+            ((s1, n1), (s2, n2)) if s1 * s2 > 0 => hh + ll - (n1 * n2),\n+            _   => hh + ll,\n+        };\n+\n+        return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n+\n+        pure fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n+            if n == 0 { return BigUint::zero(); }\n+            if n == 1 { return *a; }\n+\n+            let mut carry = 0;\n+            let prod = do at_vec::map(a.data) |ai| {\n+                let (hi, lo) = BigDigit::from_uint(\n+                    (*ai as uint) * (n as uint) + (carry as uint)\n+                );\n+                carry = hi;\n+                lo\n+            };\n+            if carry == 0 { return BigUint::from_at_vec(prod) };\n+            return BigUint::from_at_vec(prod + [carry]);\n+        }\n+\n+        pure fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n+            let mid = uint::min(a.data.len(), n);\n+            return (BigUint::from_slice(vec::view(a.data, mid, a.data.len())),\n+                    BigUint::from_slice(vec::view(a.data, 0, mid)));\n+        }\n+\n+        pure fn sub_sign(a: BigUint, b: BigUint) -> (int, BigUint) {\n+            match a.cmp(&b) {\n+                s if s < 0 => (s, b - a),\n+                s if s > 0 => (s, a - b),\n+                _          => (0, BigUint::zero())\n+            }\n+        }\n+    }\n+\n+    pure fn div(&self, other: &BigUint) -> BigUint{\n+        self.divmod(other).first()\n+    }\n+    pure fn modulo(&self, other: &BigUint) -> BigUint {\n+        self.divmod(other).second()\n+    }\n+\n+    pure fn neg(&self) -> BigUint { fail }\n+\n+    pure fn to_int(&self) -> int {\n+        uint::min(self.to_uint(), int::max_value as uint) as int\n+    }\n+\n+    static pure fn from_int(n: int) -> BigUint {\n+        if (n < 0) { BigUint::zero() } else { BigUint::from_uint(n as uint) }\n+    }\n+}\n+\n+pub impl BigUint {\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_uint(n: uint) -> BigUint {\n+        match BigDigit::from_uint(n) {\n+            (0,  0)  => BigUint::zero(),\n+            (0,  n0) => BigUint::from_at_vec(@[n0]),\n+            (n1, n0) => BigUint::from_at_vec(@[n0, n1])\n+        }\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_slice(slice: &[BigDigit]) -> BigUint {\n+        // omit trailing zeros\n+        let new_len = slice.rposition(|n| *n != 0)\n+            .map_default(0, |p| *p + 1);\n+\n+        return BigUint { data: at_vec::from_fn(new_len, |i| slice[i]) };\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_at_vec(at_vec: @[BigDigit]) -> BigUint {\n+        // omit trailing zeros\n+        let new_len = at_vec.rposition(|n| *n != 0)\n+            .map_default(0, |p| *p + 1);\n+\n+        if new_len == at_vec.len() { return BigUint { data: at_vec }; }\n+        return BigUint { data: at_vec::from_fn(new_len, |i| at_vec[i]) };\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_str_radix(s: &str, radix: uint)\n+        -> Option<BigUint> {\n+        BigUint::parse_bytes(str::to_bytes(s), radix)\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn parse_bytes(buf: &[u8], radix: uint)\n+        -> Option<BigUint> {\n+        let (base, unit_len) = get_radix_base(radix);\n+        let base_num: BigUint = BigUint::from_uint(base);\n+\n+        let mut end             = buf.len();\n+        let mut n: BigUint      = BigUint::zero();\n+        let mut power: BigUint  = BigUint::one();\n+        loop {\n+            let start = uint::max(end, unit_len) - unit_len;\n+            match uint::parse_bytes(vec::view(buf, start, end), radix) {\n+                Some(d) => n += BigUint::from_uint(d) * power,\n+                None    => return None\n+            }\n+            if end <= unit_len {\n+                return Some(n);\n+            }\n+            end -= unit_len;\n+            power *= base_num;\n+        }\n+    }\n+\n+    static pub pure fn zero() -> BigUint { BigUint::from_at_vec(@[]) }\n+    static pub pure fn one() -> BigUint { BigUint::from_at_vec(@[1]) }\n+\n+    pure fn abs() -> BigUint { self }\n+\n+    /// Compare two BigUint value.\n+    pure fn cmp(other: &BigUint) -> int {\n+        let s_len = self.data.len(), o_len = other.data.len();\n+        if s_len < o_len { return -1; }\n+        if s_len > o_len { return  1;  }\n+\n+        for vec::rev_eachi(self.data) |i, elm| {\n+            match (*elm, other.data[i]) {\n+                (l, r) if l < r => return -1,\n+                (l, r) if l > r => return  1,\n+                _               => loop\n+            };\n+        }\n+        return 0;\n+    }\n+\n+    pure fn divmod(other: &BigUint) -> (BigUint, BigUint) {\n+        if other.is_zero() { fail }\n+        if self.is_zero() { return (BigUint::zero(), BigUint::zero()); }\n+        if *other == BigUint::one() { return (self, BigUint::zero()); }\n+\n+        match self.cmp(other) {\n+            s if s < 0 => return (BigUint::zero(), self),\n+            0          => return (BigUint::one(), BigUint::zero()),\n+            _          => {} // Do nothing\n+        }\n+\n+        let mut shift = 0;\n+        let mut n = other.data.last();\n+        while n < (1 << BigDigit::bits - 2) {\n+            n <<= 1;\n+            shift += 1;\n+        }\n+        assert shift < BigDigit::bits;\n+        let (d, m) = divmod_inner(self << shift, other << shift);\n+        return (d, m >> shift);\n+\n+\n+        pure fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n+            let mut r = a;\n+            let mut d = BigUint::zero();\n+            let mut n = 1;\n+            while r >= b {\n+                let mut (d0, d_unit, b_unit) = div_estimate(r, b, n);\n+                let mut prod = b * d0;\n+                while prod > r {\n+                    d0   -= d_unit;\n+                    prod -= b_unit;\n+                }\n+                if d0.is_zero() {\n+                    n = 2;\n+                    loop;\n+                }\n+                n = 1;\n+                d += d0;\n+                r -= prod;\n+            }\n+            return (d, r);\n+        }\n+\n+        pure fn div_estimate(a: BigUint, b: BigUint, n: uint)\n+            -> (BigUint, BigUint, BigUint) {\n+            if a.data.len() < n {\n+                return (BigUint::zero(), BigUint::zero(), a);\n+            }\n+\n+            let an = vec::view(a.data, a.data.len() - n, a.data.len());\n+            let bn = b.data.last();\n+            let mut d = ~[];\n+            let mut carry = 0;\n+            for vec::rev_each(an) |elt| {\n+                let ai = BigDigit::to_uint(carry, *elt);\n+                let di = ai / (bn as uint);\n+                assert di < BigDigit::base;\n+                carry = (ai % (bn as uint)) as BigDigit;\n+                d = ~[di as BigDigit] + d;\n+            }\n+\n+            let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n+            return (BigUint::from_slice(d).shl_unit(shift),\n+                    BigUint::one().shl_unit(shift),\n+                    b.shl_unit(shift));\n+        }\n+    }\n+\n+    pure fn quot(other: &BigUint) -> BigUint { self.quotrem(other).first() }\n+    pure fn rem(other: &BigUint) -> BigUint { self.quotrem(other).second() }\n+    pure fn quotrem(other: &BigUint) -> (BigUint, BigUint) {\n+        self.divmod(other)\n+    }\n+\n+    pure fn is_zero() -> bool { self.data.is_empty() }\n+    pure fn is_not_zero() -> bool { self.data.is_not_empty() }\n+    pure fn is_positive() -> bool { self.is_not_zero() }\n+    pure fn is_negative() -> bool { false }\n+    pure fn is_nonpositive() -> bool { self.is_zero() }\n+    pure fn is_nonnegative() -> bool { true }\n+\n+    pure fn to_uint() -> uint {\n+        match self.data.len() {\n+            0 => 0,\n+            1 => self.data[0] as uint,\n+            2 => BigDigit::to_uint(self.data[1], self.data[0]),\n+            _ => uint::max_value\n+        }\n+    }\n+\n+    pure fn to_str_radix(radix: uint) -> ~str {\n+        assert 1 < radix && radix <= 16;\n+\n+        pure fn convert_base(n: BigUint, base: uint) -> @[BigDigit] {\n+            if base == BigDigit::base { return n.data; }\n+            let divider    = BigUint::from_uint(base);\n+            let mut result = @[];\n+            let mut r      = n;\n+            while r > divider {\n+                let (d, r0) = r.divmod(&divider);\n+                result += [r0.to_uint() as BigDigit];\n+                r = d;\n+            }\n+            if r.is_not_zero() {\n+                result += [r.to_uint() as BigDigit];\n+            }\n+            return result;\n+        }\n+\n+        pure fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n+            if v.is_empty() { return ~\"0\" }\n+            str::trim_left_chars(str::concat(vec::reversed(v).map(|n| {\n+                let s = uint::to_str(*n as uint, radix);\n+                str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n+            })), ['0'])\n+        }\n+\n+        let (base, max_len) = get_radix_base(radix);\n+        return fill_concat(convert_base(self, base), radix, max_len);\n+    }\n+\n+    priv pure fn shl_unit(n_unit: uint) -> BigUint {\n+        if n_unit == 0 || self.is_zero() { return self; }\n+\n+        return BigUint::from_at_vec(at_vec::from_elem(n_unit, 0) + self.data);\n+    }\n+\n+    priv pure fn shl_bits(n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.is_zero() { return self; }\n+\n+        let mut carry = 0;\n+        let shifted = do at_vec::map(self.data) |elem| {\n+            let (hi, lo) = BigDigit::from_uint(\n+                (*elem as uint) << n_bits | (carry as uint)\n+            );\n+            carry = hi;\n+            lo\n+        };\n+        if carry == 0 { return BigUint::from_at_vec(shifted); }\n+        return BigUint::from_at_vec(shifted + [carry]);\n+    }\n+\n+    priv pure fn shr_unit(n_unit: uint) -> BigUint {\n+        if n_unit == 0 { return self; }\n+        if self.data.len() < n_unit { return BigUint::zero(); }\n+        return BigUint::from_slice(\n+            vec::view(self.data, n_unit, self.data.len())\n+        );\n+    }\n+\n+    priv pure fn shr_bits(n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.data.is_empty() { return self; }\n+\n+        let mut borrow = 0;\n+        let mut shifted = @[];\n+        for vec::rev_each(self.data) |elem| {\n+            // internal compiler error: no enclosing scope with id 10671\n+            // shifted = @[(*elem >> n_bits) | borrow] + shifted;\n+            shifted = at_vec::append(@[(*elem >> n_bits) | borrow], shifted);\n+            borrow = *elem << (uint::bits - n_bits);\n+        }\n+        return BigUint::from_at_vec(shifted);\n+    }\n+}\n+\n+priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n+    assert 1 < radix && radix <= 16;\n+    match radix {\n+        2  => (4294967296, 32),\n+        3  => (3486784401, 20),\n+        4  => (4294967296, 16),\n+        5  => (1220703125, 13),\n+        6  => (2176782336, 12),\n+        7  => (1977326743, 11),\n+        8  => (1073741824, 10),\n+        9  => (3486784401, 10),\n+        10 => (1000000000, 9),\n+        11 => (2357947691, 9),\n+        12 => (429981696,  8),\n+        13 => (815730721,  8),\n+        14 => (1475789056, 8),\n+        15 => (2562890625, 8),\n+        16 => (4294967296, 8),\n+        _  => fail\n+    }\n+}\n \n /// A Sign is a BigInt's composing element.\n pub enum Sign { Minus, Zero, Plus }\n@@ -288,7 +761,364 @@ pub impl BigInt {\n }\n \n #[cfg(test)]\n-mod tests {\n+mod biguint_tests {\n+    #[test]\n+    fn test_from_slice() {\n+        let pairs = [\n+            (&[1],                &[1]),\n+            (&[0, 0],             &[]),\n+            (&[1, 2, 0, 0],       &[1, 2]),\n+            (&[0, 0, 1, 2, 0, 0], &[0, 0, 1, 2]),\n+            (&[-1],               &[-1])\n+        ];\n+        for pairs.each |p| {\n+            assert p.second() == BigUint::from_slice(p.first()).data;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_cmp() {\n+        let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n+            .map(|v| BigUint::from_slice(*v));\n+        for data.eachi |i, ni| {\n+            for vec::view(data, i, data.len()).eachi |j0, nj| {\n+                let j = j0 + i;\n+                if i == j {\n+                    assert ni.cmp(nj) == 0;\n+                    assert nj.cmp(ni) == 0;\n+                    assert ni == nj;\n+                    assert !(ni != nj);\n+                    assert ni <= nj;\n+                    assert ni >= nj;\n+                    assert !(ni < nj);\n+                    assert !(ni > nj);\n+                } else {\n+                    assert ni.cmp(nj) < 0;\n+                    assert nj.cmp(ni) > 0;\n+\n+                    assert !(ni == nj);\n+                    assert ni != nj;\n+\n+                    assert ni <= nj;\n+                    assert !(ni >= nj);\n+                    assert ni < nj;\n+                    assert !(ni > nj);\n+\n+                    assert !(nj <= ni);\n+                    assert nj >= ni;\n+                    assert !(nj < ni);\n+                    assert nj > ni;\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_shl() {\n+        assert BigUint::from_at_vec(@[]) << 3 == BigUint::from_at_vec(@[]);\n+        assert BigUint::from_at_vec(@[1, 1, 1]) << 3 ==\n+            BigUint::from_at_vec(@[1 << 3, 1 << 3, 1 << 3]);\n+\n+        assert BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]) << 2 ==\n+            BigUint::from_at_vec(@[0, 1]);\n+        assert BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]) << 3 ==\n+            BigUint::from_at_vec(@[0, 2]);\n+        assert (BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)])\n+                << (3 + BigDigit::bits)) ==\n+            BigUint::from_at_vec(@[0, 0, 2]);\n+\n+        assert BigUint::from_at_vec(\n+            @[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98]\n+        ) << 4 == BigUint::from_at_vec(\n+            @[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf]\n+        );\n+        assert BigUint::from_at_vec(\n+            @[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777]\n+        ) << 16 == BigUint::from_at_vec(\n+                @[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888]\n+            );\n+    }\n+\n+    #[test]\n+    fn test_shr() {\n+        assert BigUint::from_at_vec(@[]) >> 3 == BigUint::from_at_vec(@[]);\n+        assert BigUint::from_at_vec(@[1, 1, 1]) >> 3 == BigUint::from_at_vec(\n+            @[1 << (BigDigit::bits - 3), 1 << (BigDigit::bits - 3)]\n+        );\n+\n+        assert BigUint::from_at_vec(@[1 << 2]) >> 2 ==\n+            BigUint::from_at_vec(@[1]);\n+        assert BigUint::from_at_vec(@[1, 2]) >> 3 ==\n+            BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]);\n+        assert BigUint::from_at_vec(@[1, 1, 2]) >> (3 + BigDigit::bits) ==\n+            BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]);\n+\n+        assert BigUint::from_at_vec(\n+            @[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf]\n+        ) >> 4 == BigUint::from_at_vec(\n+            @[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98]\n+        );\n+\n+        assert BigUint::from_at_vec(\n+            @[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888]\n+        ) >> 16 == BigUint::from_at_vec(\n+            @[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_convert_int() {\n+        fn check_conv(b: BigUint, i: int) {\n+            assert b == num::Num::from_int(i);\n+            assert b.to_int() == i;\n+        }\n+\n+        check_conv(BigUint::zero(), 0);\n+        check_conv(BigUint::from_at_vec(@[1]), 1);\n+\n+        check_conv(BigUint::from_at_vec(@[-1]),\n+                   (uint::max_value >> BigDigit::bits) as int);\n+        check_conv(BigUint::from_at_vec(@[ 0,  1]),\n+                   ((uint::max_value >> BigDigit::bits) + 1) as int);\n+        check_conv(BigUint::from_at_vec(@[-1, -1 >> 1]),\n+                   int::max_value);\n+\n+        assert BigUint::from_at_vec(@[0, -1]).to_int() == int::max_value;\n+        assert BigUint::from_at_vec(@[0, 0, 1]).to_int() == int::max_value;\n+        assert BigUint::from_at_vec(@[0, 0, -1]).to_int() == int::max_value;\n+    }\n+\n+    #[test]\n+    fn test_convert_uint() {\n+        fn check_conv(b: BigUint, u: uint) {\n+            assert b == BigUint::from_uint(u);\n+            assert b.to_uint() == u;\n+        }\n+\n+        check_conv(BigUint::zero(), 0);\n+        check_conv(BigUint::from_at_vec(@[ 1]), 1);\n+        check_conv(BigUint::from_at_vec(@[-1]),\n+                   uint::max_value >> BigDigit::bits);\n+        check_conv(BigUint::from_at_vec(@[ 0,  1]),\n+                   (uint::max_value >> BigDigit::bits) + 1);\n+        check_conv(BigUint::from_at_vec(@[ 0, -1]),\n+                   uint::max_value << BigDigit::bits);\n+        check_conv(BigUint::from_at_vec(@[-1, -1]),\n+                   uint::max_value);\n+\n+        assert BigUint::from_at_vec(@[0, 0, 1]).to_uint()  == uint::max_value;\n+        assert BigUint::from_at_vec(@[0, 0, -1]).to_uint() == uint::max_value;\n+    }\n+\n+    const sum_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+        (&[],          &[],       &[]),\n+        (&[],          &[ 1],     &[ 1]),\n+        (&[ 1],        &[ 1],     &[ 2]),\n+        (&[ 1],        &[ 1,  1], &[ 2,  1]),\n+        (&[ 1],        &[-1],     &[ 0,  1]),\n+        (&[ 1],        &[-1, -1], &[ 0,  0, 1]),\n+        (&[-1, -1],    &[-1, -1], &[-2, -1, 1]),\n+        (&[ 1,  1, 1], &[-1, -1], &[ 0,  1, 2]),\n+        (&[ 2,  2, 1], &[-1, -2], &[ 1,  1, 2])\n+    ];\n+\n+    #[test]\n+    fn test_add() {\n+        for sum_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert a + b == c;\n+            assert b + a == c;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sub() {\n+        for sum_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert c - a == b;\n+            assert c - b == a;\n+        }\n+    }\n+\n+    const mul_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+        (&[],               &[],               &[]),\n+        (&[],               &[ 1],             &[]),\n+        (&[ 2],             &[],               &[]),\n+        (&[ 1],             &[ 1],             &[1]),\n+        (&[ 2],             &[ 3],             &[ 6]),\n+        (&[ 1],             &[ 1,  1,  1],     &[1, 1,  1]),\n+        (&[ 1,  2,  3],     &[ 3],             &[ 3,  6,  9]),\n+        (&[ 1,  1,  1],     &[-1],             &[-1, -1, -1]),\n+        (&[ 1,  2,  3],     &[-1],             &[-1, -2, -2, 2]),\n+        (&[ 1,  2,  3,  4], &[-1],             &[-1, -2, -2, -2, 3]),\n+        (&[-1],             &[-1],             &[ 1, -2]),\n+        (&[-1, -1],         &[-1],             &[ 1, -1, -2]),\n+        (&[-1, -1, -1],     &[-1],             &[ 1, -1, -1, -2]),\n+        (&[-1, -1, -1, -1], &[-1],             &[ 1, -1, -1, -1, -2]),\n+        (&[-1/2 + 1],       &[ 2],             &[ 0,  1]),\n+        (&[0, -1/2 + 1],    &[ 2],             &[ 0,  0,  1]),\n+        (&[ 1,  2],         &[ 1,  2,  3],     &[1, 4,  7,  6]),\n+        (&[-1, -1],         &[-1, -1, -1],     &[1, 0, -1, -2, -1]),\n+        (&[-1, -1, -1],     &[-1, -1, -1, -1], &[1, 0,  0, -1, -2, -1, -1]),\n+        (&[ 0,  0,  1],     &[ 1,  2,  3],     &[0, 0,  1,  2,  3]),\n+        (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n+    ];\n+\n+    const divmod_quadruples: &[(&[BigDigit], &[BigDigit],\n+                                &[BigDigit], &[BigDigit])]\n+        = &[\n+            (&[ 1],        &[ 2], &[],               &[1]),\n+            (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n+            (&[ 1,  1, 1], &[ 2], &[-1/2+1, -1/2+1], &[1]),\n+            (&[ 0,  1],    &[-1], &[1],              &[1]),\n+            (&[-1, -1],    &[-2], &[2, 1],           &[3])\n+        ];\n+\n+    #[test]\n+    fn test_mul() {\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert a * b == c;\n+            assert b * a == c;\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+            let d = BigUint::from_slice(dVec);\n+\n+            assert a == b * c + d;\n+            assert a == c * b + d;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_divmod() {\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            if a.is_not_zero() {\n+                assert c.divmod(&a) == (b, BigUint::zero());\n+            }\n+            if b.is_not_zero() {\n+                assert c.divmod(&b) == (a, BigUint::zero());\n+            }\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+            let d = BigUint::from_slice(dVec);\n+\n+            if b.is_not_zero() { assert a.divmod(&b) == (c, d); }\n+        }\n+    }\n+\n+    fn to_str_pairs() -> ~[ (BigUint, ~[(uint, ~str)]) ] {\n+        ~[( BigUint::zero(), ~[\n+            (2, ~\"0\"), (3, ~\"0\")\n+        ]), ( BigUint::from_slice([ 0xff ]), ~[\n+            (2,  ~\"11111111\"),\n+            (3,  ~\"100110\"),\n+            (4,  ~\"3333\"),\n+            (5,  ~\"2010\"),\n+            (6,  ~\"1103\"),\n+            (7,  ~\"513\"),\n+            (8,  ~\"377\"),\n+            (9,  ~\"313\"),\n+            (10, ~\"255\"),\n+            (11, ~\"212\"),\n+            (12, ~\"193\"),\n+            (13, ~\"168\"),\n+            (14, ~\"143\"),\n+            (15, ~\"120\"),\n+            (16, ~\"ff\")\n+        ]), ( BigUint::from_slice([ 0xfff ]), ~[\n+            (2,  ~\"111111111111\"),\n+            (4,  ~\"333333\"),\n+            (16, ~\"fff\")\n+        ]), ( BigUint::from_slice([ 1, 2 ]), ~[\n+            (2,  ~\"10\" + str::from_chars(vec::from_elem(31, '0')) + \"1\"),\n+            (4,  ~\"2\"  + str::from_chars(vec::from_elem(15, '0')) + \"1\"),\n+            (10, ~\"8589934593\"),\n+            (16, ~\"2\"  + str::from_chars(vec::from_elem(7, '0')) + \"1\")\n+        ]), (BigUint::from_slice([ 1, 2, 3 ]), ~[\n+            (2,  ~\"11\" + str::from_chars(vec::from_elem(30, '0')) + \"10\" +\n+             str::from_chars(vec::from_elem(31, '0')) + \"1\"),\n+            (4,  ~\"3\"  + str::from_chars(vec::from_elem(15, '0')) + \"2\"  +\n+             str::from_chars(vec::from_elem(15, '0')) + \"1\"),\n+            (10, ~\"55340232229718589441\"),\n+            (16, ~\"3\"  + str::from_chars(vec::from_elem(7, '0')) + \"2\"  +\n+             str::from_chars(vec::from_elem(7, '0')) + \"1\")\n+        ])]\n+    }\n+\n+    #[test]\n+    fn test_to_str_radix() {\n+        for to_str_pairs().each |num_pair| {\n+            let &(n, rs) = num_pair;\n+            for rs.each |str_pair| {\n+                let &(radix, str) = str_pair;\n+                assert n.to_str_radix(radix) == str;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix() {\n+        for to_str_pairs().each |num_pair| {\n+            let &(n, rs) = num_pair;\n+            for rs.each |str_pair| {\n+                let &(radix, str) = str_pair;\n+                assert Some(n) == BigUint::from_str_radix(str, radix);\n+            }\n+        }\n+\n+        assert BigUint::from_str_radix(~\"Z\", 10) == None;\n+        assert BigUint::from_str_radix(~\"_\", 2) == None;\n+        assert BigUint::from_str_radix(~\"-1\", 10) == None;\n+    }\n+\n+    #[test]\n+    fn test_factor() {\n+        fn factor(n: uint) -> BigUint {\n+            let mut f= BigUint::one();\n+            for uint::range(2, n + 1) |i| {\n+                f *= BigUint::from_uint(i);\n+            }\n+            return f;\n+        }\n+\n+        assert factor(3) == BigUint::from_str_radix(~\"6\", 10).get();\n+        assert factor(10) == BigUint::from_str_radix(~\"3628800\", 10).get();\n+        assert factor(20) == BigUint::from_str_radix(\n+            ~\"2432902008176640000\", 10).get();\n+        assert factor(30) == BigUint::from_str_radix(\n+            ~\"265252859812191058636308480000000\", 10).get();\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bigint_tests {\n     #[test]\n     fn test_from_biguint() {\n         assert BigInt::from_biguint(Plus, BigUint::from_uint(1)) ==\n@@ -346,7 +1176,7 @@ mod tests {\n     #[test]\n     fn test_convert_int() {\n         fn check_conv(b: BigInt, i: int) {\n-            assert b == num::from_int(i);\n+            assert b == num::Num::from_int(i);\n             assert b.to_int() == i;\n         }\n "}, {"sha": "63cedbc1369d02cff7b09c3f3689f98ac874451f", "filename": "src/libstd/biguint.rs", "status": "removed", "additions": 0, "deletions": 840, "changes": 840, "blob_url": "https://github.com/rust-lang/rust/blob/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56/src%2Flibstd%2Fbiguint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccc1f8d5e8f3ed1751c783e875ba318e577cfb56/src%2Flibstd%2Fbiguint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbiguint.rs?ref=ccc1f8d5e8f3ed1751c783e875ba318e577cfb56", "patch": "@@ -1,840 +0,0 @@\n-/*!\n-\n-A Big unsigned integer.\n-\n-A BigUint is represented as an array of BigDigits.\n-*/\n-\n-use core::cmp::{Eq, Ord};\n-\n-/**\n-A BigDigit is a BigUint's composing element.\n-\n-A BigDigit is half the size of machine word size.\n-*/\n-#[cfg(target_arch = \"x86\")]\n-#[cfg(target_arch = \"arm\")]\n-pub type BigDigit = u16;\n-\n-/**\n-A BigDigit is a BigUint's composing element.\n-\n-A BigDigit is half the size of machine word size.\n-*/\n-#[cfg(target_arch = \"x86_64\")]\n-pub type BigDigit = u32;\n-\n-pub mod BigDigit {\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"arm\")]\n-    pub const bits: uint = 16;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    pub const bits: uint = 32;\n-\n-    pub const base: uint = 1 << bits;\n-    priv const hi_mask: uint = (-1 as uint) << bits;\n-    priv const lo_mask: uint = (-1 as uint) >> bits;\n-\n-    priv pure fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n-    priv pure fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n-\n-    /// Split one machine sized unsigned integer into two BigDigits.\n-    pub pure fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n-        (get_hi(n), get_lo(n))\n-    }\n-\n-    /// Join two BigDigits into one machine sized unsigned integer\n-    pub pure fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n-        (lo as uint) | ((hi as uint) << bits)\n-    }\n-}\n-\n-/**\n-A big unsigned integer type.\n-\n-A BigUint-typed value BigUint { data: @[a, b, c] } represents a number\n-(a + b * BigDigit::base + c * BigDigit::base^2).\n-*/\n-pub struct BigUint {\n-    priv data: @[BigDigit]\n-}\n-\n-impl BigUint : Eq {\n-    pure fn eq(&self, other: &BigUint) -> bool { self.cmp(other) == 0 }\n-    pure fn ne(&self, other: &BigUint) -> bool { self.cmp(other) != 0 }\n-}\n-\n-impl BigUint : Ord {\n-    pure fn lt(&self, other: &BigUint) -> bool { self.cmp(other) <  0 }\n-    pure fn le(&self, other: &BigUint) -> bool { self.cmp(other) <= 0 }\n-    pure fn ge(&self, other: &BigUint) -> bool { self.cmp(other) >= 0 }\n-    pure fn gt(&self, other: &BigUint) -> bool { self.cmp(other) >  0 }\n-}\n-\n-impl BigUint : ToStr {\n-    pure fn to_str() -> ~str { self.to_str_radix(10) }\n-}\n-\n-impl BigUint : from_str::FromStr {\n-    static pure fn from_str(s: &str) -> Option<BigUint> {\n-        BigUint::from_str_radix(s, 10)\n-    }\n-}\n-\n-impl BigUint : Shl<uint, BigUint> {\n-    pure fn shl(&self, rhs: &uint) -> BigUint {\n-        let n_unit = *rhs / BigDigit::bits;\n-        let n_bits = *rhs % BigDigit::bits;\n-        return self.shl_unit(n_unit).shl_bits(n_bits);\n-    }\n-}\n-\n-impl BigUint : Shr<uint, BigUint> {\n-    pure fn shr(&self, rhs: &uint) -> BigUint {\n-        let n_unit = *rhs / BigDigit::bits;\n-        let n_bits = *rhs % BigDigit::bits;\n-        return self.shr_unit(n_unit).shr_bits(n_bits);\n-    }\n-}\n-\n-impl BigUint : Num {\n-    pure fn add(&self, other: &BigUint) -> BigUint {\n-        let new_len = uint::max(self.data.len(), other.data.len());\n-\n-        let mut carry = 0;\n-        let sum = do at_vec::from_fn(new_len) |i| {\n-            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n-            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n-            let (hi, lo) = BigDigit::from_uint(\n-                (ai as uint) + (bi as uint) + (carry as uint)\n-            );\n-            carry = hi;\n-            lo\n-        };\n-        if carry == 0 { return BigUint::from_at_vec(sum) };\n-        return BigUint::from_at_vec(sum + [carry]);\n-    }\n-\n-    pure fn sub(&self, other: &BigUint) -> BigUint {\n-        let new_len = uint::max(self.data.len(), other.data.len());\n-\n-        let mut borrow = 0;\n-        let diff = do at_vec::from_fn(new_len) |i| {\n-            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n-            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n-            let (hi, lo) = BigDigit::from_uint(\n-                (BigDigit::base) +\n-                (ai as uint) - (bi as uint) - (borrow as uint)\n-            );\n-            /*\n-            hi * (base) + lo == 1*(base) + ai - bi - borrow\n-            => ai - bi - borrow < 0 <=> hi == 0\n-            */\n-            borrow = if hi == 0 { 1 } else { 0 };\n-            lo\n-        };\n-\n-        assert borrow == 0;     // <=> assert (self >= other);\n-        return BigUint::from_at_vec(diff);\n-    }\n-\n-    pure fn mul(&self, other: &BigUint) -> BigUint {\n-        if self.is_zero() || other.is_zero() { return BigUint::zero(); }\n-\n-        let s_len = self.data.len(), o_len = other.data.len();\n-        if s_len == 1 { return mul_digit(other, self.data[0]);  }\n-        if o_len == 1 { return mul_digit(self,  other.data[0]); }\n-\n-        // Using Karatsuba multiplication\n-        // (a1 * base + a0) * (b1 * base + b0)\n-        // = a1*b1 * base^2 +\n-        //   (a1*b1 + a0*b0 - (a1-b0)*(b1-a0)) * base +\n-        //   a0*b0\n-        let half_len = uint::max(s_len, o_len) / 2;\n-        let (sHi, sLo) = cut_at(self,  half_len);\n-        let (oHi, oLo) = cut_at(other, half_len);\n-\n-        let ll = sLo * oLo;\n-        let hh = sHi * oHi;\n-        let mm =  match (sub_sign(sHi, sLo), sub_sign(oHi, oLo)) {\n-            ((s1, n1), (s2, n2)) if s1 * s2 < 0 => hh + ll + (n1 * n2),\n-            ((s1, n1), (s2, n2)) if s1 * s2 > 0 => hh + ll - (n1 * n2),\n-            _   => hh + ll,\n-        };\n-\n-        return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n-\n-        pure fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n-            if n == 0 { return BigUint::zero(); }\n-            if n == 1 { return *a; }\n-\n-            let mut carry = 0;\n-            let prod = do at_vec::map(a.data) |ai| {\n-                let (hi, lo) = BigDigit::from_uint(\n-                    (*ai as uint) * (n as uint) + (carry as uint)\n-                );\n-                carry = hi;\n-                lo\n-            };\n-            if carry == 0 { return BigUint::from_at_vec(prod) };\n-            return BigUint::from_at_vec(prod + [carry]);\n-        }\n-\n-        pure fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n-            let mid = uint::min(a.data.len(), n);\n-            return (BigUint::from_slice(vec::view(a.data, mid, a.data.len())),\n-                    BigUint::from_slice(vec::view(a.data, 0, mid)));\n-        }\n-\n-        pure fn sub_sign(a: BigUint, b: BigUint) -> (int, BigUint) {\n-            match a.cmp(&b) {\n-                s if s < 0 => (s, b - a),\n-                s if s > 0 => (s, a - b),\n-                _          => (0, BigUint::zero())\n-            }\n-        }\n-    }\n-\n-    pure fn div(&self, other: &BigUint) -> BigUint{\n-        self.divmod(other).first()\n-    }\n-    pure fn modulo(&self, other: &BigUint) -> BigUint {\n-        self.divmod(other).second()\n-    }\n-\n-    pure fn neg(&self) -> BigUint { fail }\n-\n-    pure fn to_int(&self) -> int {\n-        uint::min(self.to_uint(), int::max_value as uint) as int\n-    }\n-\n-    static pure fn from_int(n: int) -> BigUint {\n-        if (n < 0) { BigUint::zero() } else { BigUint::from_uint(n as uint) }\n-    }\n-}\n-\n-pub impl BigUint {\n-    /// Creates and initializes an BigUint.\n-    static pub pure fn from_uint(n: uint) -> BigUint {\n-        match BigDigit::from_uint(n) {\n-            (0,  0)  => BigUint::zero(),\n-            (0,  n0) => BigUint::from_at_vec(@[n0]),\n-            (n1, n0) => BigUint::from_at_vec(@[n0, n1])\n-        }\n-    }\n-\n-    /// Creates and initializes an BigUint.\n-    static pub pure fn from_slice(slice: &[BigDigit]) -> BigUint {\n-        // omit trailing zeros\n-        let new_len = slice.rposition(|n| *n != 0)\n-            .map_default(0, |p| *p + 1);\n-\n-        return BigUint { data: at_vec::from_fn(new_len, |i| slice[i]) };\n-    }\n-\n-    /// Creates and initializes an BigUint.\n-    static pub pure fn from_at_vec(at_vec: @[BigDigit]) -> BigUint {\n-        // omit trailing zeros\n-        let new_len = at_vec.rposition(|n| *n != 0)\n-            .map_default(0, |p| *p + 1);\n-\n-        if new_len == at_vec.len() { return BigUint { data: at_vec }; }\n-        return BigUint { data: at_vec::from_fn(new_len, |i| at_vec[i]) };\n-    }\n-\n-    /// Creates and initializes an BigUint.\n-    static pub pure fn from_str_radix(s: &str, radix: uint)\n-        -> Option<BigUint> {\n-        BigUint::parse_bytes(str::to_bytes(s), radix)\n-    }\n-\n-    /// Creates and initializes an BigUint.\n-    static pub pure fn parse_bytes(buf: &[u8], radix: uint)\n-        -> Option<BigUint> {\n-        let (base, unit_len) = get_radix_base(radix);\n-        let base_num: BigUint = BigUint::from_uint(base);\n-\n-        let mut end             = buf.len();\n-        let mut n: BigUint      = BigUint::zero();\n-        let mut power: BigUint  = BigUint::one();\n-        loop {\n-            let start = uint::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(vec::view(buf, start, end), radix) {\n-                Some(d) => n += BigUint::from_uint(d) * power,\n-                None    => return None\n-            }\n-            if end <= unit_len {\n-                return Some(n);\n-            }\n-            end -= unit_len;\n-            power *= base_num;\n-        }\n-    }\n-\n-    static pub pure fn zero() -> BigUint { BigUint::from_at_vec(@[]) }\n-    static pub pure fn one() -> BigUint { BigUint::from_at_vec(@[1]) }\n-\n-    pure fn abs() -> BigUint { self }\n-\n-    /// Compare two BigUint value.\n-    pure fn cmp(other: &BigUint) -> int {\n-        let s_len = self.data.len(), o_len = other.data.len();\n-        if s_len < o_len { return -1; }\n-        if s_len > o_len { return  1;  }\n-\n-        for vec::rev_eachi(self.data) |i, elm| {\n-            match (*elm, other.data[i]) {\n-                (l, r) if l < r => return -1,\n-                (l, r) if l > r => return  1,\n-                _               => loop\n-            };\n-        }\n-        return 0;\n-    }\n-\n-    pure fn divmod(other: &BigUint) -> (BigUint, BigUint) {\n-        if other.is_zero() { fail }\n-        if self.is_zero() { return (BigUint::zero(), BigUint::zero()); }\n-        if *other == BigUint::one() { return (self, BigUint::zero()); }\n-\n-        match self.cmp(other) {\n-            s if s < 0 => return (BigUint::zero(), self),\n-            0          => return (BigUint::one(), BigUint::zero()),\n-            _          => {} // Do nothing\n-        }\n-\n-        let mut shift = 0;\n-        let mut n = other.data.last();\n-        while n < (1 << BigDigit::bits - 2) {\n-            n <<= 1;\n-            shift += 1;\n-        }\n-        assert shift < BigDigit::bits;\n-        let (d, m) = divmod_inner(self << shift, other << shift);\n-        return (d, m >> shift);\n-\n-\n-        pure fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n-            let mut r = a;\n-            let mut d = BigUint::zero();\n-            let mut n = 1;\n-            while r >= b {\n-                let mut (d0, d_unit, b_unit) = div_estimate(r, b, n);\n-                let mut prod = b * d0;\n-                while prod > r {\n-                    d0   -= d_unit;\n-                    prod -= b_unit;\n-                }\n-                if d0.is_zero() {\n-                    n = 2;\n-                    loop;\n-                }\n-                n = 1;\n-                d += d0;\n-                r -= prod;\n-            }\n-            return (d, r);\n-        }\n-\n-        pure fn div_estimate(a: BigUint, b: BigUint, n: uint)\n-            -> (BigUint, BigUint, BigUint) {\n-            if a.data.len() < n {\n-                return (BigUint::zero(), BigUint::zero(), a);\n-            }\n-\n-            let an = vec::view(a.data, a.data.len() - n, a.data.len());\n-            let bn = b.data.last();\n-            let mut d = ~[];\n-            let mut carry = 0;\n-            for vec::rev_each(an) |elt| {\n-                let ai = BigDigit::to_uint(carry, *elt);\n-                let di = ai / (bn as uint);\n-                assert di < BigDigit::base;\n-                carry = (ai % (bn as uint)) as BigDigit;\n-                d = ~[di as BigDigit] + d;\n-            }\n-\n-            let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n-            return (BigUint::from_slice(d).shl_unit(shift),\n-                    BigUint::one().shl_unit(shift),\n-                    b.shl_unit(shift));\n-        }\n-    }\n-\n-    pure fn quot(other: &BigUint) -> BigUint { self.quotrem(other).first() }\n-    pure fn rem(other: &BigUint) -> BigUint { self.quotrem(other).second() }\n-    pure fn quotrem(other: &BigUint) -> (BigUint, BigUint) {\n-        self.divmod(other)\n-    }\n-\n-    pure fn is_zero() -> bool { self.data.is_empty() }\n-    pure fn is_not_zero() -> bool { self.data.is_not_empty() }\n-    pure fn is_positive() -> bool { self.is_not_zero() }\n-    pure fn is_negative() -> bool { false }\n-    pure fn is_nonpositive() -> bool { self.is_zero() }\n-    pure fn is_nonnegative() -> bool { true }\n-\n-    pure fn to_uint() -> uint {\n-        match self.data.len() {\n-            0 => 0,\n-            1 => self.data[0] as uint,\n-            2 => BigDigit::to_uint(self.data[1], self.data[0]),\n-            _ => uint::max_value\n-        }\n-    }\n-\n-    pure fn to_str_radix(radix: uint) -> ~str {\n-        assert 1 < radix && radix <= 16;\n-\n-        pure fn convert_base(n: BigUint, base: uint) -> @[BigDigit] {\n-            if base == BigDigit::base { return n.data; }\n-            let divider    = BigUint::from_uint(base);\n-            let mut result = @[];\n-            let mut r      = n;\n-            while r > divider {\n-                let (d, r0) = r.divmod(&divider);\n-                result += [r0.to_uint() as BigDigit];\n-                r = d;\n-            }\n-            if r.is_not_zero() {\n-                result += [r.to_uint() as BigDigit];\n-            }\n-            return result;\n-        }\n-\n-        pure fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n-            if v.is_empty() { return ~\"0\" }\n-            str::trim_left_chars(str::concat(vec::reversed(v).map(|n| {\n-                let s = uint::to_str(*n as uint, radix);\n-                str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n-            })), ['0'])\n-        }\n-\n-        let (base, max_len) = get_radix_base(radix);\n-        return fill_concat(convert_base(self, base), radix, max_len);\n-    }\n-\n-    priv pure fn shl_unit(n_unit: uint) -> BigUint {\n-        if n_unit == 0 || self.is_zero() { return self; }\n-\n-        return BigUint::from_at_vec(at_vec::from_elem(n_unit, 0) + self.data);\n-    }\n-\n-    priv pure fn shl_bits(n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.is_zero() { return self; }\n-\n-        let mut carry = 0;\n-        let shifted = do at_vec::map(self.data) |elem| {\n-            let (hi, lo) = BigDigit::from_uint(\n-                (*elem as uint) << n_bits | (carry as uint)\n-            );\n-            carry = hi;\n-            lo\n-        };\n-        if carry == 0 { return BigUint::from_at_vec(shifted); }\n-        return BigUint::from_at_vec(shifted + [carry]);\n-    }\n-\n-    priv pure fn shr_unit(n_unit: uint) -> BigUint {\n-        if n_unit == 0 { return self; }\n-        if self.data.len() < n_unit { return BigUint::zero(); }\n-        return BigUint::from_slice(\n-            vec::view(self.data, n_unit, self.data.len())\n-        );\n-    }\n-\n-    priv pure fn shr_bits(n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.data.is_empty() { return self; }\n-\n-        let mut borrow = 0;\n-        let mut shifted = @[];\n-        for vec::rev_each(self.data) |elem| {\n-            // internal compiler error: no enclosing scope with id 10671\n-            // shifted = @[(*elem >> n_bits) | borrow] + shifted;\n-            shifted = at_vec::append(@[(*elem >> n_bits) | borrow], shifted);\n-            borrow = *elem << (uint::bits - n_bits);\n-        }\n-        return BigUint::from_at_vec(shifted);\n-    }\n-}\n-\n-priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n-    assert 1 < radix && radix <= 16;\n-    match radix {\n-        2  => (4294967296, 32),\n-        3  => (3486784401, 20),\n-        4  => (4294967296, 16),\n-        5  => (1220703125, 13),\n-        6  => (2176782336, 12),\n-        7  => (1977326743, 11),\n-        8  => (1073741824, 10),\n-        9  => (3486784401, 10),\n-        10 => (1000000000, 9),\n-        11 => (2357947691, 9),\n-        12 => (429981696,  8),\n-        13 => (815730721,  8),\n-        14 => (1475789056, 8),\n-        15 => (2562890625, 8),\n-        16 => (4294967296, 8),\n-        _  => fail\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    #[test]\n-    fn test_from_slice() {\n-        let pairs = [\n-            (&[1],                &[1]),\n-            (&[0, 0],             &[]),\n-            (&[1, 2, 0, 0],       &[1, 2]),\n-            (&[0, 0, 1, 2, 0, 0], &[0, 0, 1, 2]),\n-            (&[-1],               &[-1])\n-        ];\n-        for pairs.each |p| {\n-            assert p.second() == BigUint::from_slice(p.first()).data;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_cmp() {\n-        let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n-            .map(|v| BigUint::from_slice(*v));\n-        for data.eachi |i, ni| {\n-            for vec::view(data, i, data.len()).eachi |j0, nj| {\n-                let j = j0 + i;\n-                if i == j {\n-                    assert ni.cmp(nj) == 0;\n-                    assert nj.cmp(ni) == 0;\n-                    assert ni == nj;\n-                    assert !(ni != nj);\n-                    assert ni <= nj;\n-                    assert ni >= nj;\n-                    assert !(ni < nj);\n-                    assert !(ni > nj);\n-                } else {\n-                    assert ni.cmp(nj) < 0;\n-                    assert nj.cmp(ni) > 0;\n-\n-                    assert !(ni == nj);\n-                    assert ni != nj;\n-\n-                    assert ni <= nj;\n-                    assert !(ni >= nj);\n-                    assert ni < nj;\n-                    assert !(ni > nj);\n-\n-                    assert !(nj <= ni);\n-                    assert nj >= ni;\n-                    assert !(nj < ni);\n-                    assert nj > ni;\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_shl() {\n-        assert BigUint::from_at_vec(@[]) << 3 == BigUint::from_at_vec(@[]);\n-        assert BigUint::from_at_vec(@[1, 1, 1]) << 3 ==\n-            BigUint::from_at_vec(@[1 << 3, 1 << 3, 1 << 3]);\n-\n-        assert BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]) << 2 ==\n-            BigUint::from_at_vec(@[0, 1]);\n-        assert BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]) << 3 ==\n-            BigUint::from_at_vec(@[0, 2]);\n-        assert (BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)])\n-                << (3 + BigDigit::bits)) ==\n-            BigUint::from_at_vec(@[0, 0, 2]);\n-\n-        assert BigUint::from_at_vec(\n-            @[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98]\n-        ) << 4 == BigUint::from_at_vec(\n-            @[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf]\n-        );\n-        assert BigUint::from_at_vec(\n-            @[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777]\n-        ) << 16 == BigUint::from_at_vec(\n-                @[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888]\n-            );\n-    }\n-\n-    #[test]\n-    fn test_shr() {\n-        assert BigUint::from_at_vec(@[]) >> 3 == BigUint::from_at_vec(@[]);\n-        assert BigUint::from_at_vec(@[1, 1, 1]) >> 3 == BigUint::from_at_vec(\n-            @[1 << (BigDigit::bits - 3), 1 << (BigDigit::bits - 3)]\n-        );\n-\n-        assert BigUint::from_at_vec(@[1 << 2]) >> 2 ==\n-            BigUint::from_at_vec(@[1]);\n-        assert BigUint::from_at_vec(@[1, 2]) >> 3 ==\n-            BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]);\n-        assert BigUint::from_at_vec(@[1, 1, 2]) >> (3 + BigDigit::bits) ==\n-            BigUint::from_at_vec(@[1 << (BigDigit::bits - 2)]);\n-\n-        assert BigUint::from_at_vec(\n-            @[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf]\n-        ) >> 4 == BigUint::from_at_vec(\n-            @[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98]\n-        );\n-\n-        assert BigUint::from_at_vec(\n-            @[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888]\n-        ) >> 16 == BigUint::from_at_vec(\n-            @[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_convert_int() {\n-        fn check_conv(b: BigUint, i: int) {\n-            assert b == num::from_int(i);\n-            assert b.to_int() == i;\n-        }\n-\n-        check_conv(BigUint::zero(), 0);\n-        check_conv(BigUint::from_at_vec(@[1]), 1);\n-\n-        check_conv(BigUint::from_at_vec(@[-1]),\n-                   (uint::max_value >> BigDigit::bits) as int);\n-        check_conv(BigUint::from_at_vec(@[ 0,  1]),\n-                   ((uint::max_value >> BigDigit::bits) + 1) as int);\n-        check_conv(BigUint::from_at_vec(@[-1, -1 >> 1]),\n-                   int::max_value);\n-\n-        assert BigUint::from_at_vec(@[0, -1]).to_int() == int::max_value;\n-        assert BigUint::from_at_vec(@[0, 0, 1]).to_int() == int::max_value;\n-        assert BigUint::from_at_vec(@[0, 0, -1]).to_int() == int::max_value;\n-    }\n-\n-    #[test]\n-    fn test_convert_uint() {\n-        fn check_conv(b: BigUint, u: uint) {\n-            assert b == BigUint::from_uint(u);\n-            assert b.to_uint() == u;\n-        }\n-\n-        check_conv(BigUint::zero(), 0);\n-        check_conv(BigUint::from_at_vec(@[ 1]), 1);\n-        check_conv(BigUint::from_at_vec(@[-1]),\n-                   uint::max_value >> BigDigit::bits);\n-        check_conv(BigUint::from_at_vec(@[ 0,  1]),\n-                   (uint::max_value >> BigDigit::bits) + 1);\n-        check_conv(BigUint::from_at_vec(@[ 0, -1]),\n-                   uint::max_value << BigDigit::bits);\n-        check_conv(BigUint::from_at_vec(@[-1, -1]),\n-                   uint::max_value);\n-\n-        assert BigUint::from_at_vec(@[0, 0, 1]).to_uint()  == uint::max_value;\n-        assert BigUint::from_at_vec(@[0, 0, -1]).to_uint() == uint::max_value;\n-    }\n-\n-    const sum_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n-        (&[],          &[],       &[]),\n-        (&[],          &[ 1],     &[ 1]),\n-        (&[ 1],        &[ 1],     &[ 2]),\n-        (&[ 1],        &[ 1,  1], &[ 2,  1]),\n-        (&[ 1],        &[-1],     &[ 0,  1]),\n-        (&[ 1],        &[-1, -1], &[ 0,  0, 1]),\n-        (&[-1, -1],    &[-1, -1], &[-2, -1, 1]),\n-        (&[ 1,  1, 1], &[-1, -1], &[ 0,  1, 2]),\n-        (&[ 2,  2, 1], &[-1, -2], &[ 1,  1, 2])\n-    ];\n-\n-    #[test]\n-    fn test_add() {\n-        for sum_triples.each |elm| {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n-\n-            assert a + b == c;\n-            assert b + a == c;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_sub() {\n-        for sum_triples.each |elm| {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n-\n-            assert c - a == b;\n-            assert c - b == a;\n-        }\n-    }\n-\n-    const mul_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n-        (&[],               &[],               &[]),\n-        (&[],               &[ 1],             &[]),\n-        (&[ 2],             &[],               &[]),\n-        (&[ 1],             &[ 1],             &[1]),\n-        (&[ 2],             &[ 3],             &[ 6]),\n-        (&[ 1],             &[ 1,  1,  1],     &[1, 1,  1]),\n-        (&[ 1,  2,  3],     &[ 3],             &[ 3,  6,  9]),\n-        (&[ 1,  1,  1],     &[-1],             &[-1, -1, -1]),\n-        (&[ 1,  2,  3],     &[-1],             &[-1, -2, -2, 2]),\n-        (&[ 1,  2,  3,  4], &[-1],             &[-1, -2, -2, -2, 3]),\n-        (&[-1],             &[-1],             &[ 1, -2]),\n-        (&[-1, -1],         &[-1],             &[ 1, -1, -2]),\n-        (&[-1, -1, -1],     &[-1],             &[ 1, -1, -1, -2]),\n-        (&[-1, -1, -1, -1], &[-1],             &[ 1, -1, -1, -1, -2]),\n-        (&[-1/2 + 1],       &[ 2],             &[ 0,  1]),\n-        (&[0, -1/2 + 1],    &[ 2],             &[ 0,  0,  1]),\n-        (&[ 1,  2],         &[ 1,  2,  3],     &[1, 4,  7,  6]),\n-        (&[-1, -1],         &[-1, -1, -1],     &[1, 0, -1, -2, -1]),\n-        (&[-1, -1, -1],     &[-1, -1, -1, -1], &[1, 0,  0, -1, -2, -1, -1]),\n-        (&[ 0,  0,  1],     &[ 1,  2,  3],     &[0, 0,  1,  2,  3]),\n-        (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n-    ];\n-\n-    const divmod_quadruples: &[(&[BigDigit], &[BigDigit],\n-                                &[BigDigit], &[BigDigit])]\n-        = &[\n-            (&[ 1],        &[ 2], &[],               &[1]),\n-            (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n-            (&[ 1,  1, 1], &[ 2], &[-1/2+1, -1/2+1], &[1]),\n-            (&[ 0,  1],    &[-1], &[1],              &[1]),\n-            (&[-1, -1],    &[-2], &[2, 1],           &[3])\n-        ];\n-\n-    #[test]\n-    fn test_mul() {\n-        for mul_triples.each |elm| {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n-\n-            assert a * b == c;\n-            assert b * a == c;\n-        }\n-\n-        for divmod_quadruples.each |elm| {\n-            let (aVec, bVec, cVec, dVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n-            let d = BigUint::from_slice(dVec);\n-\n-            assert a == b * c + d;\n-            assert a == c * b + d;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_divmod() {\n-        for mul_triples.each |elm| {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n-\n-            if a.is_not_zero() {\n-                assert c.divmod(&a) == (b, BigUint::zero());\n-            }\n-            if b.is_not_zero() {\n-                assert c.divmod(&b) == (a, BigUint::zero());\n-            }\n-        }\n-\n-        for divmod_quadruples.each |elm| {\n-            let (aVec, bVec, cVec, dVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n-            let d = BigUint::from_slice(dVec);\n-\n-            if b.is_not_zero() { assert a.divmod(&b) == (c, d); }\n-        }\n-    }\n-\n-    fn to_str_pairs() -> ~[ (BigUint, ~[(uint, ~str)]) ] {\n-        ~[( BigUint::zero(), ~[\n-            (2, ~\"0\"), (3, ~\"0\")\n-        ]), ( BigUint::from_slice([ 0xff ]), ~[\n-            (2,  ~\"11111111\"),\n-            (3,  ~\"100110\"),\n-            (4,  ~\"3333\"),\n-            (5,  ~\"2010\"),\n-            (6,  ~\"1103\"),\n-            (7,  ~\"513\"),\n-            (8,  ~\"377\"),\n-            (9,  ~\"313\"),\n-            (10, ~\"255\"),\n-            (11, ~\"212\"),\n-            (12, ~\"193\"),\n-            (13, ~\"168\"),\n-            (14, ~\"143\"),\n-            (15, ~\"120\"),\n-            (16, ~\"ff\")\n-        ]), ( BigUint::from_slice([ 0xfff ]), ~[\n-            (2,  ~\"111111111111\"),\n-            (4,  ~\"333333\"),\n-            (16, ~\"fff\")\n-        ]), ( BigUint::from_slice([ 1, 2 ]), ~[\n-            (2,  ~\"10\" + str::from_chars(vec::from_elem(31, '0')) + \"1\"),\n-            (4,  ~\"2\"  + str::from_chars(vec::from_elem(15, '0')) + \"1\"),\n-            (10, ~\"8589934593\"),\n-            (16, ~\"2\"  + str::from_chars(vec::from_elem(7, '0')) + \"1\")\n-        ]), (BigUint::from_slice([ 1, 2, 3 ]), ~[\n-            (2,  ~\"11\" + str::from_chars(vec::from_elem(30, '0')) + \"10\" +\n-             str::from_chars(vec::from_elem(31, '0')) + \"1\"),\n-            (4,  ~\"3\"  + str::from_chars(vec::from_elem(15, '0')) + \"2\"  +\n-             str::from_chars(vec::from_elem(15, '0')) + \"1\"),\n-            (10, ~\"55340232229718589441\"),\n-            (16, ~\"3\"  + str::from_chars(vec::from_elem(7, '0')) + \"2\"  +\n-             str::from_chars(vec::from_elem(7, '0')) + \"1\")\n-        ])]\n-    }\n-\n-    #[test]\n-    fn test_to_str_radix() {\n-        for to_str_pairs().each |num_pair| {\n-            let &(n, rs) = num_pair;\n-            for rs.each |str_pair| {\n-                let &(radix, str) = str_pair;\n-                assert n.to_str_radix(radix) == str;\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix() {\n-        for to_str_pairs().each |num_pair| {\n-            let &(n, rs) = num_pair;\n-            for rs.each |str_pair| {\n-                let &(radix, str) = str_pair;\n-                assert Some(n) == BigUint::from_str_radix(str, radix);\n-            }\n-        }\n-\n-        assert BigUint::from_str_radix(~\"Z\", 10) == None;\n-        assert BigUint::from_str_radix(~\"_\", 2) == None;\n-        assert BigUint::from_str_radix(~\"-1\", 10) == None;\n-    }\n-\n-    #[test]\n-    fn test_factor() {\n-        fn factor(n: uint) -> BigUint {\n-            let mut f= BigUint::one();\n-            for uint::range(2, n + 1) |i| {\n-                f *= BigUint::from_uint(i);\n-            }\n-            return f;\n-        }\n-\n-        assert factor(3) == BigUint::from_str_radix(~\"6\", 10).get();\n-        assert factor(10) == BigUint::from_str_radix(~\"3628800\", 10).get();\n-        assert factor(20) == BigUint::from_str_radix(\n-            ~\"2432902008176640000\", 10).get();\n-        assert factor(30) == BigUint::from_str_radix(\n-            ~\"265252859812191058636308480000000\", 10).get();\n-    }\n-}"}, {"sha": "bd7c94d631a5b9ce9a5f35f01620828a0e43c6fe", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6a8778ef71684e141696f4109334bb7018742c8/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c6a8778ef71684e141696f4109334bb7018742c8/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=c6a8778ef71684e141696f4109334bb7018742c8", "patch": "@@ -99,7 +99,6 @@ pub mod base64;\n pub mod rl;\n pub mod workcache;\n pub mod bigint;\n-pub mod biguint;\n \n #[cfg(unicode)]\n mod unicode;"}]}