{"sha": "befbd3a680e79672108845e1b2d9d5278f92659c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZmJkM2E2ODBlNzk2NzIxMDg4NDVlMWIyZDlkNTI3OGY5MjY1OWM=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-15T23:58:51Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-22T00:26:33Z"}, "message": "Add the rest of the atomic operations.\n\nThis makes the handling of atomic operations more generic, which\ndoes impose a specific naming convention for the intrinsics, but\nthat seems ok with me, rather than having an individual case for\neach name.\n\nIt also adds the intrinsics to the the intrinsics file.", "tree": {"sha": "ecf891b159e62121fad0c601ecd2d7dbba508abf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecf891b159e62121fad0c601ecd2d7dbba508abf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/befbd3a680e79672108845e1b2d9d5278f92659c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/befbd3a680e79672108845e1b2d9d5278f92659c", "html_url": "https://github.com/rust-lang/rust/commit/befbd3a680e79672108845e1b2d9d5278f92659c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/befbd3a680e79672108845e1b2d9d5278f92659c/comments", "author": null, "committer": null, "parents": [{"sha": "fd83b92b598219d74317406a25234d572de584e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd83b92b598219d74317406a25234d572de584e0", "html_url": "https://github.com/rust-lang/rust/commit/fd83b92b598219d74317406a25234d572de584e0"}], "stats": {"total": 871, "additions": 475, "deletions": 396}, "files": [{"sha": "34898e20f1e41789994298be39efeffacd137a1e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 65, "deletions": 111, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/befbd3a680e79672108845e1b2d9d5278f92659c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befbd3a680e79672108845e1b2d9d5278f92659c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=befbd3a680e79672108845e1b2d9d5278f92659c", "patch": "@@ -11,7 +11,6 @@\n use core::prelude::*;\n \n use back::{link, abi};\n-use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n use lib::llvm::{TypeRef, ValueRef};\n use lib;\n use middle::trans::base::*;\n@@ -578,118 +577,73 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n     let mut bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n     let first_real_arg = fcx.arg_pos(0u);\n-    match ccx.sess.str_of(item.ident).as_slice() {\n-        \"atomic_cxchg\" => {\n-            let old = AtomicCmpXchg(bcx,\n-                                    get_param(decl, first_real_arg),\n-                                    get_param(decl, first_real_arg + 1u),\n-                                    get_param(decl, first_real_arg + 2u),\n-                                    SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_cxchg_acq\" => {\n-            let old = AtomicCmpXchg(bcx,\n-                                    get_param(decl, first_real_arg),\n-                                    get_param(decl, first_real_arg + 1u),\n-                                    get_param(decl, first_real_arg + 2u),\n-                                    Acquire);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_cxchg_rel\" => {\n-            let old = AtomicCmpXchg(bcx,\n-                                    get_param(decl, first_real_arg),\n+\n+    let nm = ccx.sess.str_of(item.ident);\n+    let name = nm.as_slice();\n+\n+    // This requires that atomic intrinsics follow a specific naming pattern:\n+    // \"atomic_<operation>[_<ordering>], and no ordering means SeqCst\n+    if name.starts_with(\"atomic_\") {\n+        let split : ~[&str] = name.split_iter('_').collect();\n+        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n+        let order = if split.len() == 2 {\n+            lib::llvm::SequentiallyConsistent\n+        } else {\n+            match split[2] {\n+                \"relaxed\" => lib::llvm::Monotonic,\n+                \"acq\"     => lib::llvm::Acquire,\n+                \"rel\"     => lib::llvm::Release,\n+                \"acqrel\"  => lib::llvm::AcquireRelease,\n+                _ => ccx.sess.fatal(\"Unknown ordering in atomic intrinsic\")\n+            }\n+        };\n+\n+        match split[1] {\n+            \"cxchg\" => {\n+                let old = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n+                                        get_param(decl, first_real_arg + 1u),\n+                                        get_param(decl, first_real_arg + 2u),\n+                                        order);\n+                Store(bcx, old, fcx.llretptr.get());\n+            }\n+            \"load\" => {\n+                let old = AtomicLoad(bcx, get_param(decl, first_real_arg),\n+                                     order);\n+                Store(bcx, old, fcx.llretptr.get());\n+            }\n+            \"store\" => {\n+                AtomicStore(bcx, get_param(decl, first_real_arg + 1u),\n+                            get_param(decl, first_real_arg),\n+                            order);\n+            }\n+            op => {\n+                // These are all AtomicRMW ops\n+                let atom_op = match op {\n+                    \"xchg\"  => lib::llvm::Xchg,\n+                    \"xadd\"  => lib::llvm::Add,\n+                    \"xsub\"  => lib::llvm::Sub,\n+                    \"and\"   => lib::llvm::And,\n+                    \"nand\"  => lib::llvm::Nand,\n+                    \"or\"    => lib::llvm::Or,\n+                    \"xor\"   => lib::llvm::Xor,\n+                    \"max\"   => lib::llvm::Max,\n+                    \"min\"   => lib::llvm::Min,\n+                    \"umax\"  => lib::llvm::UMax,\n+                    \"umin\"  => lib::llvm::UMin,\n+                    _ => ccx.sess.fatal(\"Unknown atomic operation\")\n+                };\n+\n+                let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n-                                    get_param(decl, first_real_arg + 2u),\n-                                    Release);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_load\" => {\n-            let old = AtomicLoad(bcx,\n-                                 get_param(decl, first_real_arg),\n-                                 SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_load_acq\" => {\n-            let old = AtomicLoad(bcx,\n-                                 get_param(decl, first_real_arg),\n-                                 Acquire);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_store\" => {\n-            AtomicStore(bcx,\n-                        get_param(decl, first_real_arg + 1u),\n-                        get_param(decl, first_real_arg),\n-                        SequentiallyConsistent);\n-        }\n-        \"atomic_store_rel\" => {\n-            AtomicStore(bcx,\n-                        get_param(decl, first_real_arg + 1u),\n-                        get_param(decl, first_real_arg),\n-                        Release);\n-        }\n-        \"atomic_xchg\" => {\n-            let old = AtomicRMW(bcx, Xchg,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xchg_acq\" => {\n-            let old = AtomicRMW(bcx, Xchg,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Acquire);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xchg_rel\" => {\n-            let old = AtomicRMW(bcx, Xchg,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Release);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xadd\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Add,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xadd_acq\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Add,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Acquire);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xadd_rel\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Add,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Release);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xsub\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Sub,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xsub_acq\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Sub,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Acquire);\n-            Store(bcx, old, fcx.llretptr.get());\n-        }\n-        \"atomic_xsub_rel\" => {\n-            let old = AtomicRMW(bcx, lib::llvm::Sub,\n-                                get_param(decl, first_real_arg),\n-                                get_param(decl, first_real_arg + 1u),\n-                                Release);\n-            Store(bcx, old, fcx.llretptr.get());\n+                                    order);\n+                Store(bcx, old, fcx.llretptr.get());\n+            }\n         }\n+\n+        return;\n+    }\n+\n+    match name {\n         \"size_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);"}, {"sha": "4f532885c92f24b867257685ba77bf323596b88a", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/befbd3a680e79672108845e1b2d9d5278f92659c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befbd3a680e79672108845e1b2d9d5278f92659c/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=befbd3a680e79672108845e1b2d9d5278f92659c", "patch": "@@ -117,46 +117,43 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n                                  _,\n                                  _) => {\n         if abi.is_intrinsic() {\n-            let flags = match cx.ccx.sess.str_of(i.ident).as_slice() {\n-                \"size_of\"  | \"pref_align_of\" | \"min_align_of\" |\n-                \"uninit\"   | \"init\" | \"transmute\" | \"move_val\" |\n-                \"move_val_init\" => use_repr,\n-\n-                \"get_tydesc\" | \"needs_drop\" => use_tydesc,\n-\n-                \"atomic_cxchg\"    | \"atomic_cxchg_acq\"|\n-                \"atomic_cxchg_rel\"| \"atomic_load\"     |\n-                \"atomic_load_acq\" | \"atomic_store\"    |\n-                \"atomic_store_rel\"| \"atomic_xchg\"     |\n-                \"atomic_xadd\"     | \"atomic_xsub\"     |\n-                \"atomic_xchg_acq\" | \"atomic_xadd_acq\" |\n-                \"atomic_xsub_acq\" | \"atomic_xchg_rel\" |\n-                \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => 0,\n-\n-                \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n-                \"morestack_addr\" => 0,\n-\n-                \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n-                \"memset32\" | \"memset64\" => use_repr,\n-\n-                \"sqrtf32\" | \"sqrtf64\" | \"powif32\" | \"powif64\" |\n-                \"sinf32\"  | \"sinf64\"  | \"cosf32\"  | \"cosf64\"  |\n-                \"powf32\"  | \"powf64\"  | \"expf32\"  | \"expf64\"  |\n-                \"exp2f32\" | \"exp2f64\" | \"logf32\"  | \"logf64\"  |\n-                \"log10f32\"| \"log10f64\"| \"log2f32\" | \"log2f64\" |\n-                \"fmaf32\"  | \"fmaf64\"  | \"fabsf32\" | \"fabsf64\" |\n-                \"floorf32\"| \"floorf64\"| \"ceilf32\" | \"ceilf64\" |\n-                \"truncf32\"| \"truncf64\" => 0,\n-\n-                \"ctpop8\" | \"ctpop16\" | \"ctpop32\" | \"ctpop64\" => 0,\n-\n-                \"ctlz8\" | \"ctlz16\" | \"ctlz32\" | \"ctlz64\" => 0,\n-                \"cttz8\" | \"cttz16\" | \"cttz32\" | \"cttz64\" => 0,\n-\n-                \"bswap16\" | \"bswap32\" | \"bswap64\" => 0,\n-\n-                // would be cool to make these an enum instead of strings!\n-                _ => fail!(\"unknown intrinsic in type_use\")\n+            let nm = cx.ccx.sess.str_of(i.ident);\n+            let name = nm.as_slice();\n+            let flags = if name.starts_with(\"atomic_\") {\n+                0\n+            } else {\n+                match name {\n+                    \"size_of\"  | \"pref_align_of\" | \"min_align_of\" |\n+                    \"uninit\"   | \"init\" | \"transmute\" | \"move_val\" |\n+                    \"move_val_init\" => use_repr,\n+\n+                    \"get_tydesc\" | \"needs_drop\" => use_tydesc,\n+\n+                    \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n+                    \"morestack_addr\" => 0,\n+\n+                    \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n+                    \"memset32\" | \"memset64\" => use_repr,\n+\n+                    \"sqrtf32\" | \"sqrtf64\" | \"powif32\" | \"powif64\" |\n+                    \"sinf32\"  | \"sinf64\"  | \"cosf32\"  | \"cosf64\"  |\n+                    \"powf32\"  | \"powf64\"  | \"expf32\"  | \"expf64\"  |\n+                    \"exp2f32\" | \"exp2f64\" | \"logf32\"  | \"logf64\"  |\n+                    \"log10f32\"| \"log10f64\"| \"log2f32\" | \"log2f64\" |\n+                    \"fmaf32\"  | \"fmaf64\"  | \"fabsf32\" | \"fabsf64\" |\n+                    \"floorf32\"| \"floorf64\"| \"ceilf32\" | \"ceilf64\" |\n+                    \"truncf32\"| \"truncf64\" => 0,\n+\n+                    \"ctpop8\" | \"ctpop16\" | \"ctpop32\" | \"ctpop64\" => 0,\n+\n+                    \"ctlz8\" | \"ctlz16\" | \"ctlz32\" | \"ctlz64\" => 0,\n+                    \"cttz8\" | \"cttz16\" | \"cttz32\" | \"cttz64\" => 0,\n+\n+                    \"bswap16\" | \"bswap32\" | \"bswap64\" => 0,\n+\n+                    // would be cool to make these an enum instead of strings!\n+                    _ => fail!(\"unknown intrinsic in type_use\")\n+                }\n             };\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n         }"}, {"sha": "1ac300271166b97ad1818560d87a42112126fef3", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 261, "deletions": 245, "changes": 506, "blob_url": "https://github.com/rust-lang/rust/blob/befbd3a680e79672108845e1b2d9d5278f92659c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befbd3a680e79672108845e1b2d9d5278f92659c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=befbd3a680e79672108845e1b2d9d5278f92659c", "patch": "@@ -3434,252 +3434,268 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     }\n \n     let tcx = ccx.tcx;\n-    let str = ccx.tcx.sess.str_of(it.ident);\n-    let (n_tps, inputs, output) = match str.as_slice() {\n-        \"size_of\" |\n-        \"pref_align_of\" | \"min_align_of\" => (1u, ~[], ty::mk_uint()),\n-        \"init\" => (1u, ~[], param(ccx, 0u)),\n-        \"uninit\" => (1u, ~[], param(ccx, 0u)),\n-        \"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n-        \"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n-        \"move_val\" | \"move_val_init\" => {\n-            (1u,\n-             ~[\n-                ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), param(ccx, 0)),\n-                param(ccx, 0u)\n-              ],\n-           ty::mk_nil())\n-        }\n-        \"needs_drop\" => (1u, ~[], ty::mk_bool()),\n-\n-        \"atomic_cxchg\"    | \"atomic_cxchg_acq\"| \"atomic_cxchg_rel\" => {\n-          (0,\n-           ~[\n-              ty::mk_mut_rptr(tcx,\n-                              ty::re_bound(ty::br_anon(0)),\n-                              ty::mk_int()),\n-              ty::mk_int(),\n-              ty::mk_int()\n-           ],\n-           ty::mk_int())\n-        }\n-        \"atomic_load\"     | \"atomic_load_acq\" => {\n-          (0,\n-           ~[\n-              ty::mk_imm_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int())\n-           ],\n-          ty::mk_int())\n-        }\n-        \"atomic_store\"    | \"atomic_store_rel\" => {\n-          (0,\n-           ~[\n-              ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n-              ty::mk_int()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"atomic_xchg\"     | \"atomic_xadd\"     | \"atomic_xsub\"     |\n-        \"atomic_xchg_acq\" | \"atomic_xadd_acq\" | \"atomic_xsub_acq\" |\n-        \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {\n-          (0,\n-           ~[\n-              ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n-              ty::mk_int()\n-           ],\n-           ty::mk_int())\n-        }\n-\n-        \"get_tydesc\" => {\n-          // FIXME (#3730): return *intrinsic::tydesc, not *()\n-          (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n-        }\n-        \"visit_tydesc\" => {\n-          let tydesc_name = special_idents::tydesc;\n-          assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-          let (_, tydesc_ty) = tcx.intrinsic_defs.get_copy(&tydesc_name);\n-          let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n-          let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n-              ty: tydesc_ty,\n-              mutbl: ast::m_imm\n-          });\n-          (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n-        }\n-        \"frame_address\" => {\n-          let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n-              purity: ast::impure_fn,\n-              sigil: ast::BorrowedSigil,\n-              onceness: ast::Once,\n-              region: ty::re_bound(ty::br_anon(0)),\n-              bounds: ty::EmptyBuiltinBounds(),\n-              sig: ty::FnSig {\n-                  bound_lifetime_names: opt_vec::Empty,\n-                  inputs: ~[ty::mk_imm_ptr(ccx.tcx, ty::mk_mach_uint(ast::ty_u8))],\n-                  output: ty::mk_nil()\n-              }\n-          });\n-          (0u, ~[fty], ty::mk_nil())\n-        }\n-        \"morestack_addr\" => {\n-          (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n-        }\n-        \"memcpy32\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_imm\n-              }),\n-              ty::mk_u32()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"memcpy64\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_imm\n-              }),\n-              ty::mk_u64()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"memmove32\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_imm\n-              }),\n-              ty::mk_u32()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"memmove64\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n+    let nm = ccx.tcx.sess.str_of(it.ident);\n+    let name = nm.as_slice();\n+    let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n+        let split : ~[&str] = name.split_iter('_').collect();\n+        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n+\n+        //We only care about the operation here\n+        match split[1] {\n+            \"cxchg\" => (0, ~[ty::mk_mut_rptr(tcx,\n+                                             ty::re_bound(ty::br_anon(0)),\n+                                             ty::mk_int()),\n+                        ty::mk_int(),\n+                        ty::mk_int()\n+                        ], ty::mk_int()),\n+            \"load\" => (0,\n+               ~[\n+                  ty::mk_imm_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int())\n+               ],\n+              ty::mk_int()),\n+            \"store\" => (0,\n+               ~[\n+                  ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+                  ty::mk_int()\n+               ],\n+               ty::mk_nil()),\n+\n+            \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\"   | \"xor\"  | \"max\"  |\n+            \"min\"  | \"umax\" | \"umin\" => {\n+                (0, ~[ty::mk_mut_rptr(tcx,\n+                                      ty::re_bound(ty::br_anon(0)),\n+                                      ty::mk_int()), ty::mk_int() ], ty::mk_int())\n+            }\n+\n+            op => {\n+                tcx.sess.span_err(it.span,\n+                                  fmt!(\"unrecognized atomic operation function: `%s`\",\n+                                       op));\n+                return;\n+            }\n+        }\n+\n+    } else {\n+        match name {\n+            \"size_of\" |\n+            \"pref_align_of\" | \"min_align_of\" => (1u, ~[], ty::mk_uint()),\n+            \"init\" => (1u, ~[], param(ccx, 0u)),\n+            \"uninit\" => (1u, ~[], param(ccx, 0u)),\n+            \"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n+            \"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n+            \"move_val\" | \"move_val_init\" => {\n+                (1u,\n+                 ~[\n+                    ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), param(ccx, 0)),\n+                    param(ccx, 0u)\n+                  ],\n+               ty::mk_nil())\n+            }\n+            \"needs_drop\" => (1u, ~[], ty::mk_bool()),\n+\n+            \"atomic_xchg\"     | \"atomic_xadd\"     | \"atomic_xsub\"     |\n+            \"atomic_xchg_acq\" | \"atomic_xadd_acq\" | \"atomic_xsub_acq\" |\n+            \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {\n+              (0,\n+               ~[\n+                  ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+                  ty::mk_int()\n+               ],\n+               ty::mk_int())\n+            }\n+\n+            \"get_tydesc\" => {\n+              // FIXME (#3730): return *intrinsic::tydesc, not *()\n+              (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n+            }\n+            \"visit_tydesc\" => {\n+              let tydesc_name = special_idents::tydesc;\n+              assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n+              let (_, tydesc_ty) = tcx.intrinsic_defs.get_copy(&tydesc_name);\n+              let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n+              let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n+                  ty: tydesc_ty,\n                   mutbl: ast::m_imm\n-              }),\n-              ty::mk_u64()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"memset32\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_u8(),\n-              ty::mk_u32()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"memset64\" => {\n-          (1,\n-           ~[\n-              ty::mk_ptr(tcx, ty::mt {\n-                  ty: param(ccx, 0),\n-                  mutbl: ast::m_mutbl\n-              }),\n-              ty::mk_u8(),\n-              ty::mk_u64()\n-           ],\n-           ty::mk_nil())\n-        }\n-        \"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"powif32\" => {\n-           (0,\n-            ~[ ty::mk_f32(), ty::mk_i32() ],\n-            ty::mk_f32())\n-        }\n-        \"powif64\" => {\n-           (0,\n-            ~[ ty::mk_f64(), ty::mk_i32() ],\n-            ty::mk_f64())\n-        }\n-        \"sinf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"sinf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"cosf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"cosf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"powf32\" => {\n-           (0,\n-            ~[ ty::mk_f32(), ty::mk_f32() ],\n-            ty::mk_f32())\n-        }\n-        \"powf64\" => {\n-           (0,\n-            ~[ ty::mk_f64(), ty::mk_f64() ],\n-            ty::mk_f64())\n-        }\n-        \"expf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"expf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"exp2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"exp2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"logf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"logf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"log10f32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"log10f64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"log2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"log2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"fmaf32\" => {\n-            (0,\n-             ~[ ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ],\n-             ty::mk_f32())\n-        }\n-        \"fmaf64\" => {\n-            (0,\n-             ~[ ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ],\n-             ty::mk_f64())\n-        }\n-        \"fabsf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"fabsf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"floorf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"floorf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"ceilf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"ceilf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"truncf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        \"truncf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        \"ctpop8\"   => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-        \"ctpop16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        \"ctpop32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        \"ctpop64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        \"ctlz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-        \"ctlz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        \"ctlz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        \"ctlz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        \"cttz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-        \"cttz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        \"cttz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        \"cttz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        \"bswap16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        \"bswap32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        \"bswap64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        ref other => {\n-            tcx.sess.span_err(it.span,\n-                              fmt!(\"unrecognized intrinsic function: `%s`\",\n-                                   *other));\n-            return;\n+              });\n+              (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n+            }\n+            \"frame_address\" => {\n+              let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n+                  purity: ast::impure_fn,\n+                  sigil: ast::BorrowedSigil,\n+                  onceness: ast::Once,\n+                  region: ty::re_bound(ty::br_anon(0)),\n+                  bounds: ty::EmptyBuiltinBounds(),\n+                  sig: ty::FnSig {\n+                      bound_lifetime_names: opt_vec::Empty,\n+                      inputs: ~[ty::mk_imm_ptr(ccx.tcx, ty::mk_mach_uint(ast::ty_u8))],\n+                      output: ty::mk_nil()\n+                  }\n+              });\n+              (0u, ~[fty], ty::mk_nil())\n+            }\n+            \"morestack_addr\" => {\n+              (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n+            }\n+            \"memcpy32\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_u32()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"memcpy64\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_u64()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"memmove32\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_u32()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"memmove64\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_u64()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"memset32\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_u8(),\n+                  ty::mk_u32()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"memset64\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_mutbl\n+                  }),\n+                  ty::mk_u8(),\n+                  ty::mk_u64()\n+               ],\n+               ty::mk_nil())\n+            }\n+            \"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"powif32\" => {\n+               (0,\n+                ~[ ty::mk_f32(), ty::mk_i32() ],\n+                ty::mk_f32())\n+            }\n+            \"powif64\" => {\n+               (0,\n+                ~[ ty::mk_f64(), ty::mk_i32() ],\n+                ty::mk_f64())\n+            }\n+            \"sinf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"sinf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"cosf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"cosf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"powf32\" => {\n+               (0,\n+                ~[ ty::mk_f32(), ty::mk_f32() ],\n+                ty::mk_f32())\n+            }\n+            \"powf64\" => {\n+               (0,\n+                ~[ ty::mk_f64(), ty::mk_f64() ],\n+                ty::mk_f64())\n+            }\n+            \"expf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"expf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"exp2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"exp2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"logf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"logf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"log10f32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"log10f64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"log2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"log2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"fmaf32\" => {\n+                (0,\n+                 ~[ ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ],\n+                 ty::mk_f32())\n+            }\n+            \"fmaf64\" => {\n+                (0,\n+                 ~[ ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ],\n+                 ty::mk_f64())\n+            }\n+            \"fabsf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"fabsf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"floorf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"floorf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"ceilf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"ceilf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"truncf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+            \"truncf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+            \"ctpop8\"   => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+            \"ctpop16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+            \"ctpop32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+            \"ctpop64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+            \"ctlz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+            \"ctlz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+            \"ctlz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+            \"ctlz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+            \"cttz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+            \"cttz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+            \"cttz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+            \"cttz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+            \"bswap16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+            \"bswap32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+            \"bswap64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+            ref other => {\n+                tcx.sess.span_err(it.span,\n+                                  fmt!(\"unrecognized intrinsic function: `%s`\",\n+                                       *other));\n+                return;\n+            }\n         }\n     };\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {"}, {"sha": "e1daf6c81b2ab8e8ac46b5d1593d2b58990856cd", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/befbd3a680e79672108845e1b2d9d5278f92659c/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befbd3a680e79672108845e1b2d9d5278f92659c/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=befbd3a680e79672108845e1b2d9d5278f92659c", "patch": "@@ -42,36 +42,148 @@ pub extern \"rust-intrinsic\" {\n     /// Atomic compare and exchange, release ordering.\n     pub fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;\n \n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_acqrel(dst: &mut int, old: int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_relaxed(dst: &mut int, old: int, src: int) -> int;\n+\n+\n     /// Atomic load, sequentially consistent.\n     pub fn atomic_load(src: &int) -> int;\n     /// Atomic load, acquire ordering.\n     pub fn atomic_load_acq(src: &int) -> int;\n \n+    #[cfg(not(stage0))]\n+    pub fn atomic_load_relaxed(src: &int) -> int;\n+\n     /// Atomic store, sequentially consistent.\n     pub fn atomic_store(dst: &mut int, val: int);\n     /// Atomic store, release ordering.\n     pub fn atomic_store_rel(dst: &mut int, val: int);\n \n+    #[cfg(not(stage0))]\n+    pub fn atomic_store_relaxed(dst: &mut int, val: int);\n+\n     /// Atomic exchange, sequentially consistent.\n     pub fn atomic_xchg(dst: &mut int, src: int) -> int;\n     /// Atomic exchange, acquire ordering.\n     pub fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n     /// Atomic exchange, release ordering.\n     pub fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xchg_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xchg_relaxed(dst: &mut int, src: int) -> int;\n \n     /// Atomic addition, sequentially consistent.\n     pub fn atomic_xadd(dst: &mut int, src: int) -> int;\n     /// Atomic addition, acquire ordering.\n     pub fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n     /// Atomic addition, release ordering.\n     pub fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xadd_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xadd_relaxed(dst: &mut int, src: int) -> int;\n \n     /// Atomic subtraction, sequentially consistent.\n     pub fn atomic_xsub(dst: &mut int, src: int) -> int;\n     /// Atomic subtraction, acquire ordering.\n     pub fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n     /// Atomic subtraction, release ordering.\n     pub fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xsub_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xsub_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_and(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_and_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_and_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_and_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_and_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_nand(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_nand_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_nand_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_nand_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_nand_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_or(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_or_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_or_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_or_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_or_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xor(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xor_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xor_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xor_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_xor_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_max(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_max_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_max_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_max_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_max_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_min(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_min_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_min_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_min_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_min_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_relaxed(dst: &mut int, src: int) -> int;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_acq(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_rel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_acqrel(dst: &mut int, src: int) -> int;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_umin_relaxed(dst: &mut int, src: int) -> int;\n \n     /// The size of a type in bytes.\n     ///"}]}