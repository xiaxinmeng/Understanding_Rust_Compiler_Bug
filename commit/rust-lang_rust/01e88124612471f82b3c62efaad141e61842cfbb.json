{"sha": "01e88124612471f82b3c62efaad141e61842cfbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZTg4MTI0NjEyNDcxZjgyYjNjNjJlZmFhZDE0MWU2MTg0MmNmYmI=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-08-16T20:37:18Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-08-16T20:37:18Z"}, "message": "StrSearcher: Additional comments and small code moves\n\nBreak out a separate static method to create the \"byteset\".", "tree": {"sha": "ebc24f73e20e6dc0a0810a7eb69ff2c699aab462", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebc24f73e20e6dc0a0810a7eb69ff2c699aab462"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01e88124612471f82b3c62efaad141e61842cfbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01e88124612471f82b3c62efaad141e61842cfbb", "html_url": "https://github.com/rust-lang/rust/commit/01e88124612471f82b3c62efaad141e61842cfbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01e88124612471f82b3c62efaad141e61842cfbb/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b82c072c75d64c434a62f185b67fb41028d6f71", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b82c072c75d64c434a62f185b67fb41028d6f71", "html_url": "https://github.com/rust-lang/rust/commit/2b82c072c75d64c434a62f185b67fb41028d6f71"}], "stats": {"total": 46, "additions": 27, "deletions": 19}, "files": [{"sha": "8e22fdc30426cb202ca5e9bec3b0eeea5f9e08ef", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/01e88124612471f82b3c62efaad141e61842cfbb/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01e88124612471f82b3c62efaad141e61842cfbb/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=01e88124612471f82b3c62efaad141e61842cfbb", "patch": "@@ -641,6 +641,8 @@ unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n             }\n             StrSearcherImpl::TwoWay(ref mut searcher) => {\n                 let is_long = searcher.memory == usize::MAX;\n+                // write out `true` and `false` cases to encourage the compiler\n+                // to specialize the two cases separately.\n                 if is_long {\n                     searcher.next::<MatchOnly>(self.haystack.as_bytes(),\n                                                self.needle.as_bytes(),\n@@ -653,8 +655,8 @@ unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {\n             }\n         }\n     }\n-\n }\n+\n unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n     #[inline]\n     fn next_back(&mut self) -> SearchStep {\n@@ -709,6 +711,7 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n             }\n             StrSearcherImpl::TwoWay(ref mut searcher) => {\n                 let is_long = searcher.memory == usize::MAX;\n+                // write out `true` and `false`, like `next_match`\n                 if is_long {\n                     searcher.next_back::<MatchOnly>(self.haystack.as_bytes(),\n                                                     self.needle.as_bytes(),\n@@ -723,8 +726,7 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b> {\n     }\n }\n \n-/// The internal state of an iterator that searches for matches of a substring\n-/// within a larger string using two-way search\n+/// The internal state of the two-way substring search algorithm.\n #[derive(Clone, Debug)]\n struct TwoWaySearcher {\n     // constants\n@@ -741,7 +743,9 @@ struct TwoWaySearcher {\n     // variables\n     position: usize,\n     end: usize,\n+    /// index into needle before which we have already matched\n     memory: usize,\n+    /// index into needle after which we have already matched\n     memory_back: usize,\n }\n \n@@ -841,9 +845,6 @@ impl TwoWaySearcher {\n         // is large.\n         if &needle[..crit_pos] == &needle[period.. period + crit_pos] {\n             // short period case -- the period is exact\n-            let byteset = needle[..period].iter()\n-                                .fold(0, |a, &b| (1 << (b & 0x3f)) | a);\n-\n             // compute a separate critical factorization for the reversed needle\n             // x = u' v' where |v'| < period(x).\n             //\n@@ -860,26 +861,26 @@ impl TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 crit_pos_back: crit_pos_back,\n                 period: period,\n-                byteset: byteset,\n+                byteset: Self::byteset_create(&needle[..period]),\n \n                 position: 0,\n                 end: end,\n                 memory: 0,\n-                // memory_back after which we have already matched\n                 memory_back: needle.len(),\n             }\n         } else {\n             // long period case -- we have an approximation to the actual period,\n             // and don't use memorization.\n-\n-            let byteset = needle.iter()\n-                                .fold(0, |a, &b| (1 << (b & 0x3f)) | a);\n+            //\n+            // Approximate the period by lower bound max(|u|, |v|) + 1.\n+            // The critical factorization is efficient to use for both forward and\n+            // reverse search.\n \n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 crit_pos_back: crit_pos,\n                 period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,\n-                byteset: byteset,\n+                byteset: Self::byteset_create(needle),\n \n                 position: 0,\n                 end: end,\n@@ -889,6 +890,11 @@ impl TwoWaySearcher {\n         }\n     }\n \n+    #[inline]\n+    fn byteset_create(bytes: &[u8]) -> u64 {\n+        bytes.iter().fold(0, |a, &b| (1 << (b & 0x3f)) | a)\n+    }\n+\n     #[inline(always)]\n     fn byteset_contains(&self, byte: u8) -> bool {\n         (self.byteset >> ((byte & 0x3f) as usize)) & 1 != 0\n@@ -976,9 +982,9 @@ impl TwoWaySearcher {\n     // and local_period(u, v) = local_period(reverse(v), reverse(u)), so if (u, v)\n     // is a critical factorization, so is (reverse(v), reverse(u)).\n     //\n-    // For the short period case, using memorization, we rely on |u| < period(x).\n-    // For this case we have computed a critical factorization x = u' v'\n-    // where |v'| < period(x) instead (field `crit_pos_back`).\n+    // For the reverse case we have computed a critical factorization x = u' v'\n+    // (field `crit_pos_back`). We need |u| < period(x) for the forward case and\n+    // thus |v'| < period(x) for the reverse.\n     //\n     // To search in reverse through the haystack, we search forward through\n     // a reversed haystack with a reversed needle, matching first u' and then v'.\n@@ -1018,7 +1024,7 @@ impl TwoWaySearcher {\n \n             // See if the left part of the needle matches\n             let crit = if long_period { self.crit_pos_back }\n-                        else { cmp::min(self.crit_pos_back, self.memory_back) };\n+                       else { cmp::min(self.crit_pos_back, self.memory_back) };\n             for i in (0..crit).rev() {\n                 if needle[i] != haystack[self.end - needle.len() + i] {\n                     self.end -= self.crit_pos_back - i;\n@@ -1031,7 +1037,7 @@ impl TwoWaySearcher {\n \n             // See if the right part of the needle matches\n             let needle_end = if long_period { needle.len() }\n-                        else { self.memory_back };\n+                             else { self.memory_back };\n             for i in self.crit_pos_back..needle_end {\n                 if needle[i] != haystack[self.end - needle.len() + i] {\n                     self.end -= self.period;\n@@ -1070,7 +1076,8 @@ impl TwoWaySearcher {\n     fn maximal_suffix(arr: &[u8], order_greater: bool) -> (usize, usize) {\n         let mut left = 0; // Corresponds to i in the paper\n         let mut right = 1; // Corresponds to j in the paper\n-        let mut offset = 0; // Corresponds to k in the paper\n+        let mut offset = 0; // Corresponds to k in the paper, but starting at 0\n+                            // to match 0-based indexing.\n         let mut period = 1; // Corresponds to p in the paper\n \n         while let Some(&a) = arr.get(right + offset) {\n@@ -1117,7 +1124,8 @@ impl TwoWaySearcher {\n     {\n         let mut left = 0; // Corresponds to i in the paper\n         let mut right = 1; // Corresponds to j in the paper\n-        let mut offset = 0; // Corresponds to k in the paper\n+        let mut offset = 0; // Corresponds to k in the paper, but starting at 0\n+                            // to match 0-based indexing.\n         let mut period = 1; // Corresponds to p in the paper\n         let n = arr.len();\n "}]}