{"sha": "92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYjVlMjBhZDU5YjE4M2EyZTZjZDc5NDIzZjU0YjhhYTdhYzljYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-02T04:47:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-02T04:47:36Z"}, "message": "Auto merge of #59008 - varkor:const-generics-infer, r=eddyb\n\nAdd const generics to infer (and transitive dependencies)\n\nSplit out from #53645. This work is a collaborative effort with @yodaldevoid.\n\nThere are a number of stubs. These are mainly to ensure we don't overlook them when completing the implementation, but are not necessary for the initial implementation. We plan to address these in follow up PRs.\n\nr? @eddyb / @nikomatsakis", "tree": {"sha": "6506cb8294055f817bc903b0f14d9b08a2c29592", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6506cb8294055f817bc903b0f14d9b08a2c29592"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "html_url": "https://github.com/rust-lang/rust/commit/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "url": "https://api.github.com/repos/rust-lang/rust/commits/767f59462663fbc55a69d39fc5e1f7f83b6fb37d", "html_url": "https://github.com/rust-lang/rust/commit/767f59462663fbc55a69d39fc5e1f7f83b6fb37d"}, {"sha": "a68ed060bdab2d4c5d36062cda24f89d22488271", "url": "https://api.github.com/repos/rust-lang/rust/commits/a68ed060bdab2d4c5d36062cda24f89d22488271", "html_url": "https://github.com/rust-lang/rust/commit/a68ed060bdab2d4c5d36062cda24f89d22488271"}], "stats": {"total": 1627, "additions": 1414, "deletions": 213}, "files": [{"sha": "0e9dbcac5cd64c3b1c00f26717f38b41c14f2074", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 86, "deletions": 3, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -10,10 +10,12 @@ use crate::infer::canonical::{\n     OriginalQueryValues,\n };\n use crate::infer::InferCtxt;\n+use crate::mir::interpret::ConstValue;\n use std::sync::atomic::Ordering;\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::subst::Kind;\n-use crate::ty::{self, BoundVar, Lift, List, Ty, TyCtxt, TypeFlags};\n+use crate::ty::{self, BoundVar, InferConst, Lift, List, Ty, TyCtxt, TypeFlags};\n+use crate::ty::flags::FlagComputation;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -432,6 +434,61 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n             }\n         }\n     }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        match ct.val {\n+            ConstValue::Infer(InferConst::Var(vid)) => {\n+                debug!(\"canonical: const var found with vid {:?}\", vid);\n+                match self.infcx.unwrap().probe_const_var(vid) {\n+                    Ok(c) => {\n+                        debug!(\"(resolved to {:?})\", c);\n+                        return self.fold_const(c);\n+                    }\n+\n+                    // `ConstVar(vid)` is unresolved, track its universe index in the\n+                    // canonicalized result\n+                    Err(mut ui) => {\n+                        if !self.infcx.unwrap().tcx.sess.opts.debugging_opts.chalk {\n+                            // FIXME: perf problem described in #55921.\n+                            ui = ty::UniverseIndex::ROOT;\n+                        }\n+                        return self.canonicalize_const_var(\n+                            CanonicalVarInfo {\n+                                kind: CanonicalVarKind::Const(ui),\n+                            },\n+                            ct,\n+                        );\n+                    }\n+                }\n+            }\n+            ConstValue::Infer(InferConst::Fresh(_)) => {\n+                bug!(\"encountered a fresh const during canonicalization\")\n+            }\n+            ConstValue::Infer(InferConst::Canonical(debruijn, _)) => {\n+                if debruijn >= self.binder_index {\n+                    bug!(\"escaping bound type during canonicalization\")\n+                } else {\n+                    return ct;\n+                }\n+            }\n+            ConstValue::Placeholder(placeholder) => {\n+                return self.canonicalize_const_var(\n+                    CanonicalVarInfo {\n+                        kind: CanonicalVarKind::PlaceholderConst(placeholder),\n+                    },\n+                    ct,\n+                );\n+            }\n+            _ => {}\n+        }\n+\n+        let flags = FlagComputation::for_const(ct);\n+        if flags.intersects(self.needs_canonical_flags) {\n+            ct.super_fold_with(self)\n+        } else {\n+            ct\n+        }\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n@@ -450,11 +507,13 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::KEEP_IN_LOCAL_TCX |\n             TypeFlags::HAS_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_FREE_REGIONS`\n-            TypeFlags::HAS_TY_PLACEHOLDER\n+            TypeFlags::HAS_TY_PLACEHOLDER |\n+            TypeFlags::HAS_CT_PLACEHOLDER\n         } else {\n             TypeFlags::KEEP_IN_LOCAL_TCX |\n             TypeFlags::HAS_RE_PLACEHOLDER |\n-            TypeFlags::HAS_TY_PLACEHOLDER\n+            TypeFlags::HAS_TY_PLACEHOLDER |\n+            TypeFlags::HAS_CT_PLACEHOLDER\n         };\n \n         let gcx = tcx.global_tcx();\n@@ -633,4 +692,28 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n             self.tcx().mk_ty(ty::Bound(self.binder_index, var.into()))\n         }\n     }\n+\n+    /// Given a type variable `const_var` of the given kind, first check\n+    /// if `const_var` is bound to anything; if so, canonicalize\n+    /// *that*. Otherwise, create a new canonical variable for\n+    /// `const_var`.\n+    fn canonicalize_const_var(\n+        &mut self,\n+        info: CanonicalVarInfo,\n+        const_var: &'tcx ty::Const<'tcx>\n+    ) -> &'tcx ty::Const<'tcx> {\n+        let infcx = self.infcx.expect(\"encountered const-var without infcx\");\n+        let bound_to = infcx.resolve_const_var(const_var);\n+        if bound_to != const_var {\n+            self.fold_const(bound_to)\n+        } else {\n+            let var = self.canonical_var(info, const_var.into());\n+            self.tcx().mk_const(\n+                ty::Const {\n+                    val: ConstValue::Infer(InferConst::Canonical(self.binder_index, var.into())),\n+                    ty: const_var.ty,\n+                }\n+            )\n+        }\n+    }\n }"}, {"sha": "7c61db21e613a3a27babc95a0e7b1009e9748d50", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -21,7 +21,8 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin};\n+use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, ConstVariableOrigin};\n+use crate::mir::interpret::ConstValue;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_macros::HashStable;\n use serialize::UseSpecializedDecodable;\n@@ -30,7 +31,7 @@ use std::ops::Index;\n use syntax::source_map::Span;\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::Kind;\n-use crate::ty::{self, BoundVar, Lift, List, Region, TyCtxt};\n+use crate::ty::{self, BoundVar, InferConst, Lift, List, Region, TyCtxt};\n \n mod canonicalizer;\n \n@@ -115,6 +116,8 @@ impl CanonicalVarInfo {\n             CanonicalVarKind::PlaceholderTy(_) => false,\n             CanonicalVarKind::Region(_) => true,\n             CanonicalVarKind::PlaceholderRegion(..) => false,\n+            CanonicalVarKind::Const(_) => true,\n+            CanonicalVarKind::PlaceholderConst(_) => false,\n         }\n     }\n }\n@@ -137,6 +140,12 @@ pub enum CanonicalVarKind {\n     /// are solving a goal like `for<'a> T: Foo<'a>` to represent the\n     /// bound region `'a`.\n     PlaceholderRegion(ty::PlaceholderRegion),\n+\n+    /// Some kind of const inference variable.\n+    Const(ty::UniverseIndex),\n+\n+    /// A \"placeholder\" that represents \"any const\".\n+    PlaceholderConst(ty::PlaceholderConst),\n }\n \n impl CanonicalVarKind {\n@@ -150,6 +159,8 @@ impl CanonicalVarKind {\n             CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.universe,\n             CanonicalVarKind::Region(ui) => ui,\n             CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.universe,\n+            CanonicalVarKind::Const(ui) => ui,\n+            CanonicalVarKind::PlaceholderConst(placeholder) => placeholder.universe,\n         }\n     }\n }\n@@ -388,6 +399,33 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 };\n                 self.tcx.mk_region(ty::RePlaceholder(placeholder_mapped)).into()\n             }\n+\n+            CanonicalVarKind::Const(ui) => {\n+                self.next_const_var_in_universe(\n+                    self.next_ty_var_in_universe(\n+                        TypeVariableOrigin::MiscVariable(span),\n+                        universe_map(ui),\n+                    ),\n+                    ConstVariableOrigin::MiscVariable(span),\n+                    universe_map(ui),\n+                ).into()\n+            }\n+\n+            CanonicalVarKind::PlaceholderConst(\n+                ty::PlaceholderConst { universe, name },\n+            ) => {\n+                let universe_mapped = universe_map(universe);\n+                let placeholder_mapped = ty::PlaceholderConst {\n+                    universe: universe_mapped,\n+                    name,\n+                };\n+                self.tcx.mk_const(\n+                    ty::Const {\n+                        val: ConstValue::Placeholder(placeholder_mapped),\n+                        ty: self.tcx.types.err, // FIXME(const_generics)\n+                    }\n+                ).into()\n+            }\n         }\n     }\n }\n@@ -443,8 +481,13 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                     UnpackedKind::Lifetime(..) => tcx.mk_region(\n                         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i))\n                     ).into(),\n-                    UnpackedKind::Const(..) => {\n-                        unimplemented!() // FIXME(const_generics)\n+                    UnpackedKind::Const(ct) => {\n+                        tcx.mk_const(ty::Const {\n+                            ty: ct.ty,\n+                            val: ConstValue::Infer(\n+                                InferConst::Canonical(ty::INNERMOST, ty::BoundVar::from_u32(i))\n+                            ),\n+                        }).into()\n                     }\n                 })\n                 .collect()"}, {"sha": "8225ed70c5827b283f06748bf8ff21a71f1b03bd", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -16,6 +16,7 @@ use crate::infer::canonical::{\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxtBuilder;\n use crate::infer::{InferCtxt, InferOk, InferResult};\n+use crate::mir::interpret::ConstValue;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -25,7 +26,7 @@ use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{Kind, UnpackedKind};\n-use crate::ty::{self, BoundVar, Lift, Ty, TyCtxt};\n+use crate::ty::{self, BoundVar, InferConst, Lift, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n@@ -479,8 +480,17 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                         opt_values[br.assert_bound_var()] = Some(*original_value);\n                     }\n                 }\n-                UnpackedKind::Const(..) => {\n-                    unimplemented!() // FIXME(const_generics)\n+                UnpackedKind::Const(result_value) => {\n+                    if let ty::Const {\n+                        val: ConstValue::Infer(InferConst::Canonical(debrujin, b)),\n+                        ..\n+                    } = result_value {\n+                        // ...in which case we would set `canonical_vars[0]` to `Some(const X)`.\n+\n+                        // We only allow a `ty::INNERMOST` index in substitutions.\n+                        assert_eq!(*debrujin, ty::INNERMOST);\n+                        opt_values[*b] = Some(*original_value);\n+                    }\n                 }\n             }\n         }"}, {"sha": "6b716d6c3b8ea2831cb104277f59674f7117a5a6", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -70,6 +70,13 @@ where\n             }\n         };\n \n-        tcx.replace_escaping_bound_vars(value, fld_r, fld_t).0\n+        let fld_c = |bound_ct: ty::BoundVar, _| {\n+            match var_values.var_values[bound_ct].unpack() {\n+                UnpackedKind::Const(ct) => ct,\n+                c => bug!(\"{:?} is a const but value is {:?}\", bound_ct, c),\n+            }\n+        };\n+\n+        tcx.replace_escaping_bound_vars(value, fld_r, fld_t, fld_c).0\n     }\n }"}, {"sha": "048c0a7a8fd0a5cdba566f6ad5df6d0b967f55d1", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 92, "deletions": 4, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -28,17 +28,19 @@ use super::{InferCtxt, MiscVariable, TypeTrace};\n use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n+use super::unify_key::{ConstVarValue, ConstVariableValue, ConstVariableOrigin};\n \n use crate::hir::def_id::DefId;\n+use crate::mir::interpret::ConstValue;\n use crate::ty::{IntType, UintType};\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt, InferConst};\n use crate::ty::error::TypeError;\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::SubstsRef;\n use crate::traits::{Obligation, PredicateObligations};\n \n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Clone)]\n pub struct CombineFields<'infcx, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -107,13 +109,69 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n                 Err(TypeError::Sorts(ty::relate::expected_found(relation, &a, &b)))\n             }\n \n-\n             _ => {\n                 ty::relate::super_relate_tys(relation, a, b)\n             }\n         }\n     }\n \n+    pub fn super_combine_consts<R>(\n+        &self,\n+        relation: &mut R,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n+    where\n+        R: TypeRelation<'infcx, 'gcx, 'tcx>,\n+    {\n+        let a_is_expected = relation.a_is_expected();\n+\n+        match (a.val, b.val) {\n+            (ConstValue::Infer(InferConst::Var(a_vid)),\n+                ConstValue::Infer(InferConst::Var(b_vid))) => {\n+                self.const_unification_table\n+                    .borrow_mut()\n+                    .unify_var_var(a_vid, b_vid)\n+                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n+                return Ok(a);\n+            }\n+\n+            // All other cases of inference with other variables are errors.\n+            (ConstValue::Infer(InferConst::Var(_)), ConstValue::Infer(_)) |\n+            (ConstValue::Infer(_), ConstValue::Infer(InferConst::Var(_))) => {\n+                bug!(\"tried to combine ConstValue::Infer/ConstValue::Infer(InferConst::Var)\")\n+            }\n+\n+            (ConstValue::Infer(InferConst::Var(vid)), _) => {\n+                return self.unify_const_variable(a_is_expected, vid, b);\n+            }\n+\n+            (_, ConstValue::Infer(InferConst::Var(vid))) => {\n+                return self.unify_const_variable(!a_is_expected, vid, a);\n+            }\n+\n+            _ => {}\n+        }\n+\n+        ty::relate::super_relate_consts(relation, a, b)\n+    }\n+\n+    pub fn unify_const_variable(\n+        &self,\n+        vid_is_expected: bool,\n+        vid: ty::ConstVid<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        self.const_unification_table\n+            .borrow_mut()\n+            .unify_var_value(vid, ConstVarValue {\n+                origin: ConstVariableOrigin::ConstInference(DUMMY_SP),\n+                val: ConstVariableValue::Known { value },\n+            })\n+            .map_err(|e| const_unification_error(vid_is_expected, e))?;\n+        Ok(value)\n+    }\n+\n     fn unify_integral_variable(&self,\n                                vid_is_expected: bool,\n                                vid: ty::IntVid,\n@@ -407,7 +465,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n \n         debug!(\"generalize: t={:?}\", t);\n \n-        // Check to see whether the type we are genealizing references\n+        // Check to see whether the type we are generalizing references\n         // any other type variable related to `vid` via\n         // subtyping. This is basically our \"occurs check\", preventing\n         // us from creating infinitely sized types.\n@@ -519,6 +577,29 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         // very descriptive origin for this region variable.\n         Ok(self.infcx.next_region_var_in_universe(MiscVariable(self.span), self.for_universe))\n     }\n+\n+    fn consts(\n+        &mut self,\n+        c: &'tcx ty::Const<'tcx>,\n+        c2: &'tcx ty::Const<'tcx>\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        assert_eq!(c, c2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n+\n+        match c {\n+            ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } => {\n+                let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n+                match variable_table.probe_value(*vid).val.known() {\n+                    Some(u) => {\n+                        self.relate(&u, &u)\n+                    }\n+                    None => Ok(c),\n+                }\n+            }\n+            _ => {\n+                relate::super_relate_consts(self, c, c)\n+            }\n+        }\n+    }\n }\n \n pub trait RelateResultCompare<'tcx, T> {\n@@ -540,6 +621,13 @@ impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'t\n     }\n }\n \n+pub fn const_unification_error<'tcx>(\n+    a_is_expected: bool,\n+    (a, b): (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>),\n+) -> TypeError<'tcx> {\n+    TypeError::ConstMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))\n+}\n+\n fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::IntVarValue))\n                                -> TypeError<'tcx>\n {"}, {"sha": "f61408696ecbff8606da4aba221fd15760757851", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -1,12 +1,14 @@\n-use super::combine::{CombineFields, RelationDir};\n-use super::{Subtype};\n+use super::combine::{CombineFields, RelationDir, const_unification_error};\n+use super::Subtype;\n \n use crate::hir::def_id::DefId;\n \n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt, InferConst};\n use crate::ty::TyVar;\n use crate::ty::subst::SubstsRef;\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use crate::mir::interpret::ConstValue;\n+use crate::infer::unify_key::replace_if_possible;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n pub struct Equate<'combine, 'infcx: 'combine, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n@@ -100,6 +102,46 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         Ok(a)\n     }\n \n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n+        if a == b { return Ok(a); }\n+\n+        let infcx = self.fields.infcx;\n+        let a = replace_if_possible(infcx.const_unification_table.borrow_mut(), a);\n+        let b = replace_if_possible(infcx.const_unification_table.borrow_mut(), b);\n+        let a_is_expected = self.a_is_expected();\n+\n+        match (a.val, b.val) {\n+            (ConstValue::Infer(InferConst::Var(a_vid)),\n+                ConstValue::Infer(InferConst::Var(b_vid))) => {\n+                infcx.const_unification_table\n+                    .borrow_mut()\n+                    .unify_var_var(a_vid, b_vid)\n+                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n+                return Ok(a);\n+            }\n+\n+            (ConstValue::Infer(InferConst::Var(a_id)), _) => {\n+                self.fields.infcx.unify_const_variable(a_is_expected, a_id, b)?;\n+                return Ok(a);\n+            }\n+\n+            (_, ConstValue::Infer(InferConst::Var(b_id))) => {\n+                self.fields.infcx.unify_const_variable(!a_is_expected, b_id, a)?;\n+                return Ok(a);\n+            }\n+\n+            _ => {}\n+        }\n+\n+        self.fields.infcx.super_combine_consts(self, a, b)?;\n+        Ok(a)\n+    }\n+\n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>"}, {"sha": "679635bef13e5623436aab23f846427c4ad59306", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 97, "deletions": 22, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -31,6 +31,7 @@\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n \n+use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::fold::TypeFolder;\n use crate::util::nodemap::FxHashMap;\n@@ -42,42 +43,74 @@ use super::unify_key::ToType;\n \n pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    freshen_count: u32,\n-    freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n+    ty_freshen_count: u32,\n+    const_freshen_count: u32,\n+    ty_freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n+    const_freshen_map: FxHashMap<ty::InferConst<'tcx>, &'tcx ty::Const<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n                -> TypeFreshener<'a, 'gcx, 'tcx> {\n         TypeFreshener {\n             infcx,\n-            freshen_count: 0,\n-            freshen_map: Default::default(),\n+            ty_freshen_count: 0,\n+            const_freshen_count: 0,\n+            ty_freshen_map: Default::default(),\n+            const_freshen_map: Default::default(),\n         }\n     }\n \n-    fn freshen<F>(&mut self,\n-                  opt_ty: Option<Ty<'tcx>>,\n-                  key: ty::InferTy,\n-                  freshener: F)\n-                  -> Ty<'tcx> where\n+    fn freshen_ty<F>(\n+        &mut self,\n+        opt_ty: Option<Ty<'tcx>>,\n+        key: ty::InferTy,\n+        freshener: F,\n+    ) -> Ty<'tcx>\n+    where\n         F: FnOnce(u32) -> ty::InferTy,\n     {\n         if let Some(ty) = opt_ty {\n             return ty.fold_with(self);\n         }\n \n-        match self.freshen_map.entry(key) {\n+        match self.ty_freshen_map.entry(key) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n-                let index = self.freshen_count;\n-                self.freshen_count += 1;\n-                let t = self.infcx.tcx.mk_infer(freshener(index));\n+                let index = self.ty_freshen_count;\n+                self.ty_freshen_count += 1;\n+                let t = self.infcx.tcx.mk_ty_infer(freshener(index));\n                 entry.insert(t);\n                 t\n             }\n         }\n     }\n+\n+    fn freshen_const<F>(\n+        &mut self,\n+        opt_ct: Option<&'tcx ty::Const<'tcx>>,\n+        key: ty::InferConst<'tcx>,\n+        freshener: F,\n+        ty: Ty<'tcx>,\n+    ) -> &'tcx ty::Const<'tcx>\n+    where\n+        F: FnOnce(u32) -> ty::InferConst<'tcx>,\n+    {\n+        if let Some(ct) = opt_ct {\n+            return ct.fold_with(self);\n+        }\n+\n+        match self.const_freshen_map.entry(key) {\n+            Entry::Occupied(entry) => *entry.get(),\n+            Entry::Vacant(entry) => {\n+                let index = self.const_freshen_count;\n+                self.const_freshen_count += 1;\n+                let ct = self.infcx.tcx.mk_const_infer(freshener(index), ty);\n+                entry.insert(ct);\n+                ct\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -124,14 +157,14 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n         match t.sty {\n             ty::Infer(ty::TyVar(v)) => {\n                 let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n-                self.freshen(\n+                self.freshen_ty(\n                     opt_ty,\n                     ty::TyVar(v),\n                     ty::FreshTy)\n             }\n \n             ty::Infer(ty::IntVar(v)) => {\n-                self.freshen(\n+                self.freshen_ty(\n                     self.infcx.int_unification_table.borrow_mut()\n                                                     .probe_value(v)\n                                                     .map(|v| v.to_type(tcx)),\n@@ -140,22 +173,22 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             }\n \n             ty::Infer(ty::FloatVar(v)) => {\n-                self.freshen(\n+                self.freshen_ty(\n                     self.infcx.float_unification_table.borrow_mut()\n                                                       .probe_value(v)\n                                                       .map(|v| v.to_type(tcx)),\n                     ty::FloatVar(v),\n                     ty::FreshFloatTy)\n             }\n \n-            ty::Infer(ty::FreshTy(c)) |\n-            ty::Infer(ty::FreshIntTy(c)) |\n-            ty::Infer(ty::FreshFloatTy(c)) => {\n-                if c >= self.freshen_count {\n+            ty::Infer(ty::FreshTy(ct)) |\n+            ty::Infer(ty::FreshIntTy(ct)) |\n+            ty::Infer(ty::FreshFloatTy(ct)) => {\n+                if ct >= self.ty_freshen_count {\n                     bug!(\"Encountered a freshend type with id {} \\\n                           but our counter is only at {}\",\n-                         c,\n-                         self.freshen_count);\n+                         ct,\n+                         self.ty_freshen_count);\n                 }\n                 t\n             }\n@@ -192,4 +225,46 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::Bound(..) => bug!(\"unexpected type {:?}\", t),\n         }\n     }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        match ct.val {\n+            ConstValue::Infer(ty::InferConst::Var(v)) => {\n+                let opt_ct = self.infcx.const_unification_table\n+                    .borrow_mut()\n+                    .probe_value(v)\n+                    .val\n+                    .known();\n+                return self.freshen_const(\n+                    opt_ct,\n+                    ty::InferConst::Var(v),\n+                    ty::InferConst::Fresh,\n+                    ct.ty,\n+                );\n+            }\n+            ConstValue::Infer(ty::InferConst::Fresh(i)) => {\n+                if i >= self.const_freshen_count {\n+                    bug!(\n+                        \"Encountered a freshend const with id {} \\\n+                            but our counter is only at {}\",\n+                        i,\n+                        self.const_freshen_count,\n+                    );\n+                }\n+                return ct;\n+            }\n+\n+            ConstValue::Infer(ty::InferConst::Canonical(..)) |\n+            ConstValue::Placeholder(_) => {\n+                bug!(\"unexpected const {:?}\", ct)\n+            }\n+\n+            ConstValue::Param(_) |\n+            ConstValue::Scalar(_) |\n+            ConstValue::Slice(..) |\n+            ConstValue::ByRef(..) |\n+            ConstValue::Unevaluated(..) => {}\n+        }\n+\n+        ct.super_fold_with(self)\n+    }\n }"}, {"sha": "5f5a2d4a489e361fbfa10bb5c00f31a6614ca2a4", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -1,12 +1,27 @@\n-use crate::ty::{self, Ty, TyCtxt, TyVid, IntVid, FloatVid, RegionVid};\n+use crate::ty::{self, Ty, TyCtxt, TyVid, IntVid, FloatVid, RegionVid, ConstVid};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n+use crate::mir::interpret::ConstValue;\n \n use super::InferCtxt;\n-use super::RegionVariableOrigin;\n+use super::{RegionVariableOrigin, ConstVariableOrigin};\n use super::type_variable::TypeVariableOrigin;\n \n+use rustc_data_structures::unify as ut;\n+use ut::UnifyKey;\n+\n+use std::cell::RefMut;\n use std::ops::Range;\n \n+fn const_vars_since_snapshot<'tcx>(\n+    mut table: RefMut<'_, ut::UnificationTable<ut::InPlace<ConstVid<'tcx>>>>,\n+    snapshot: &ut::Snapshot<ut::InPlace<ConstVid<'tcx>>>,\n+) -> (Range<ConstVid<'tcx>>, Vec<ConstVariableOrigin>) {\n+    let range = table.vars_since_snapshot(snapshot);\n+    (range.start..range.end, (range.start.index..range.end.index).map(|index| {\n+        table.probe_value(ConstVid::from_index(index)).origin.clone()\n+    }).collect())\n+}\n+\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// This rather funky routine is used while processing expected\n     /// types. What happens here is that we want to propagate a\n@@ -79,13 +94,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     let region_vars = self.borrow_region_constraints().vars_since_snapshot(\n                         &snapshot.region_constraints_snapshot,\n                     );\n+                    let const_vars = const_vars_since_snapshot(\n+                        self.const_unification_table.borrow_mut(),\n+                        &snapshot.const_snapshot,\n+                    );\n \n                     let fudger = InferenceFudger {\n                         infcx: self,\n                         type_vars,\n                         int_vars,\n                         float_vars,\n                         region_vars,\n+                        const_vars,\n                     };\n \n                     Ok((fudger, value))\n@@ -104,7 +124,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         if fudger.type_vars.0.is_empty() &&\n             fudger.int_vars.is_empty() &&\n             fudger.float_vars.is_empty() &&\n-            fudger.region_vars.0.is_empty() {\n+            fudger.region_vars.0.is_empty() &&\n+            fudger.const_vars.0.is_empty() {\n             Ok(value)\n         } else {\n             Ok(value.fold_with(&mut fudger))\n@@ -118,6 +139,7 @@ pub struct InferenceFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     int_vars: Range<IntVid>,\n     float_vars: Range<FloatVid>,\n     region_vars: (Range<RegionVid>, Vec<RegionVariableOrigin>),\n+    const_vars: (Range<ConstVid<'tcx>>, Vec<ConstVariableOrigin>),\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx> {\n@@ -165,13 +187,29 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx>\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        if let ty::ReVar(vid) = r {\n+        if let ty::ReVar(vid) = *r {\n             if self.region_vars.0.contains(&vid) {\n-                let idx = (vid.index() - self.region_vars.0.start.index()) as usize;\n+                let idx = vid.index() - self.region_vars.0.start.index();\n                 let origin = self.region_vars.1[idx];\n                 return self.infcx.next_region_var(origin);\n             }\n         }\n         r\n     }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const { val: ConstValue::Infer(ty::InferConst::Var(vid)), ty } = ct {\n+            if self.const_vars.0.contains(&vid) {\n+                // This variable was created during the fudging.\n+                // Recreate it with a fresh variable here.\n+                let idx = (vid.index - self.const_vars.0.start.index) as usize;\n+                let origin = self.const_vars.1[idx];\n+                self.infcx.next_const_var(ty, origin)\n+            } else {\n+                ct\n+            }\n+        } else {\n+            ct.super_fold_with(self)\n+        }\n+    }\n }"}, {"sha": "63a8f17398a0460bf994dc4e74a6553053dfd12c", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -60,6 +60,19 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         Ok(self.fields.infcx.borrow_region_constraints().glb_regions(self.tcx(), origin, a, b))\n     }\n \n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n+        if a == b {\n+            return Ok(a);\n+        }\n+\n+        self.fields.infcx.super_combine_consts(self, a, b)\n+    }\n+\n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>"}, {"sha": "fcec820cbb92ae844f7e2cdc8de66dc4674e4bb0", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -7,6 +7,7 @@ use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n use crate::infer::CombinedSnapshot;\n use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n use crate::ty::{self, Binder, TypeFoldable};\n+use crate::mir::interpret::ConstValue;\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n@@ -99,7 +100,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }))\n         };\n \n-        let (result, map) = self.tcx.replace_bound_vars(binder, fld_r, fld_t);\n+        let fld_c = |bound_var: ty::BoundVar, ty| {\n+            self.tcx.mk_const(\n+                ty::Const {\n+                    val: ConstValue::Placeholder(ty::PlaceholderConst {\n+                        universe: next_universe,\n+                        name: bound_var,\n+                    }),\n+                    ty,\n+                }\n+            )\n+        };\n+\n+        let (result, map) = self.tcx.replace_bound_vars(binder, fld_r, fld_t, fld_c);\n \n         debug!(\n             \"replace_bound_vars_with_placeholders(\\"}, {"sha": "29b319ef8f5ff5ed8086cdb3fa6e129f8a27db36", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -60,6 +60,19 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         Ok(self.fields.infcx.borrow_region_constraints().lub_regions(self.tcx(), origin, a, b))\n     }\n \n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n+        if a == b {\n+            return Ok(a);\n+        }\n+\n+        self.fields.infcx.super_combine_consts(self, a, b)\n+    }\n+\n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>"}, {"sha": "65bc2b3e945cec2f571e8b334281f858307ab0b3", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 187, "deletions": 78, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -10,17 +10,19 @@ pub use crate::ty::IntVarValue;\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::canonical::{Canonical, CanonicalVarValues};\n+use crate::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use crate::middle::free_region::RegionRelations;\n use crate::middle::lang_items;\n use crate::middle::region;\n+use crate::mir::interpret::ConstValue;\n use crate::session::config::BorrowckMode;\n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use crate::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use crate::ty::fold::TypeFoldable;\n+use crate::ty::fold::{TypeFolder, TypeFoldable};\n use crate::ty::relate::RelateResult;\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef};\n-use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners};\n-use crate::ty::{FloatVid, IntVid, TyVid};\n+use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt, CtxtInterners, InferConst};\n+use crate::ty::{FloatVid, IntVid, TyVid, ConstVid};\n use crate::util::nodemap::FxHashMap;\n \n use arena::SyncDroplessArena;\n@@ -39,7 +41,7 @@ use self::outlives::env::OutlivesEnvironment;\n use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n use self::type_variable::TypeVariableOrigin;\n-use self::unify_key::ToType;\n+use self::unify_key::{ToType, ConstVariableOrigin};\n \n pub mod at;\n pub mod canonical;\n@@ -72,7 +74,7 @@ pub type InferResult<'tcx, T> = Result<InferOk<'tcx, T>, TypeError<'tcx>>;\n \n pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n-pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n+pub type FixupResult<'tcx, T> = Result<T, FixupError<'tcx>>; // \"fixup result\"\n \n /// A flag that is used to suppress region errors. This is normally\n /// false, but sometimes -- when we are doing region checks that the\n@@ -122,7 +124,10 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// order, represented by its upper and lower bounds.\n     pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n-    /// Map from integral variable to the kind of integer it represents\n+    /// Map from const parameter variable to the kind of const it represents.\n+    const_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>>,\n+\n+    /// Map from integral variable to the kind of integer it represents.\n     int_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::IntVid>>>,\n \n     /// Map from floating variable to the kind of float it represents\n@@ -422,10 +427,11 @@ impl NLLRegionVariableOrigin {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum FixupError {\n+pub enum FixupError<'tcx> {\n     UnresolvedIntTy(IntVid),\n     UnresolvedFloatTy(FloatVid),\n     UnresolvedTy(TyVid),\n+    UnresolvedConst(ConstVid<'tcx>),\n }\n \n /// See the `region_obligations` field for more information.\n@@ -436,7 +442,7 @@ pub struct RegionObligation<'tcx> {\n     pub origin: SubregionOrigin<'tcx>,\n }\n \n-impl fmt::Display for FixupError {\n+impl<'tcx> fmt::Display for FixupError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::FixupError::*;\n \n@@ -452,6 +458,7 @@ impl fmt::Display for FixupError {\n                  add a suffix to specify the type explicitly\"\n             ),\n             UnresolvedTy(_) => write!(f, \"unconstrained type\"),\n+            UnresolvedConst(_) => write!(f, \"unconstrained const value\"),\n         }\n     }\n }\n@@ -524,6 +531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n                 in_progress_tables,\n                 projection_cache: Default::default(),\n                 type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n+                const_unification_table: RefCell::new(ut::UnificationTable::new()),\n                 int_unification_table: RefCell::new(ut::UnificationTable::new()),\n                 float_unification_table: RefCell::new(ut::UnificationTable::new()),\n                 region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n@@ -589,6 +597,7 @@ impl<'tcx> InferOk<'tcx, ()> {\n pub struct CombinedSnapshot<'a, 'tcx: 'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot<'tcx>,\n+    const_snapshot: ut::Snapshot<ut::InPlace<ty::ConstVid<'tcx>>>,\n     int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n     float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n     region_constraints_snapshot: RegionSnapshot,\n@@ -652,6 +661,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut type_variables = self.type_variables.borrow_mut();\n         let mut int_unification_table = self.int_unification_table.borrow_mut();\n         let mut float_unification_table = self.float_unification_table.borrow_mut();\n+        // FIXME(const_generics): should there be an equivalent function for const variables?\n \n         type_variables\n             .unsolved_variables()\n@@ -722,6 +732,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         CombinedSnapshot {\n             projection_cache_snapshot: self.projection_cache.borrow_mut().snapshot(),\n             type_snapshot: self.type_variables.borrow_mut().snapshot(),\n+            const_snapshot: self.const_unification_table.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_constraints_snapshot: self.borrow_region_constraints().start_snapshot(),\n@@ -739,6 +750,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let CombinedSnapshot {\n             projection_cache_snapshot,\n             type_snapshot,\n+            const_snapshot,\n             int_snapshot,\n             float_snapshot,\n             region_constraints_snapshot,\n@@ -751,28 +763,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.in_snapshot.set(was_in_snapshot);\n         self.universe.set(universe);\n \n-        self.projection_cache\n-            .borrow_mut()\n-            .rollback_to(projection_cache_snapshot);\n+        self.projection_cache.borrow_mut().rollback_to(projection_cache_snapshot);\n         self.type_variables.borrow_mut().rollback_to(type_snapshot);\n-        self.int_unification_table\n-            .borrow_mut()\n-            .rollback_to(int_snapshot);\n-        self.float_unification_table\n-            .borrow_mut()\n-            .rollback_to(float_snapshot);\n-        self.region_obligations\n-            .borrow_mut()\n-            .truncate(region_obligations_snapshot);\n-        self.borrow_region_constraints()\n-            .rollback_to(region_constraints_snapshot);\n+        self.const_unification_table.borrow_mut().rollback_to(const_snapshot);\n+        self.int_unification_table.borrow_mut().rollback_to(int_snapshot);\n+        self.float_unification_table.borrow_mut().rollback_to(float_snapshot);\n+        self.region_obligations.borrow_mut().truncate(region_obligations_snapshot);\n+        self.borrow_region_constraints().rollback_to(region_constraints_snapshot);\n     }\n \n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"commit_from()\");\n         let CombinedSnapshot {\n             projection_cache_snapshot,\n             type_snapshot,\n+            const_snapshot,\n             int_snapshot,\n             float_snapshot,\n             region_constraints_snapshot,\n@@ -784,16 +789,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.in_snapshot.set(was_in_snapshot);\n \n-        self.projection_cache\n-            .borrow_mut()\n-            .commit(projection_cache_snapshot);\n+        self.projection_cache.borrow_mut().commit(projection_cache_snapshot);\n         self.type_variables.borrow_mut().commit(type_snapshot);\n+        self.const_unification_table.borrow_mut().commit(const_snapshot);\n         self.int_unification_table.borrow_mut().commit(int_snapshot);\n-        self.float_unification_table\n-            .borrow_mut()\n-            .commit(float_snapshot);\n-        self.borrow_region_constraints()\n-            .commit(region_constraints_snapshot);\n+        self.float_unification_table.borrow_mut().commit(float_snapshot);\n+        self.borrow_region_constraints().commit(region_constraints_snapshot);\n     }\n \n     /// Executes `f` and commit the bindings.\n@@ -999,6 +1000,38 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_ty_var(self.next_ty_var_id(true, origin))\n     }\n \n+    pub fn next_const_var(\n+        &self,\n+        ty: Ty<'tcx>,\n+        origin: ConstVariableOrigin\n+    ) -> &'tcx ty::Const<'tcx> {\n+        self.tcx.mk_const_var(self.next_const_var_id(origin), ty)\n+    }\n+\n+    pub fn next_const_var_in_universe(\n+        &self,\n+        ty: Ty<'tcx>,\n+        origin: ConstVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> &'tcx ty::Const<'tcx> {\n+        let vid = self.const_unification_table\n+            .borrow_mut()\n+            .new_key(ConstVarValue {\n+                origin,\n+                val: ConstVariableValue::Unknown { universe },\n+            });\n+        self.tcx.mk_const_var(vid, ty)\n+    }\n+\n+    pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n+        self.const_unification_table\n+            .borrow_mut()\n+            .new_key(ConstVarValue {\n+                origin,\n+                val: ConstVariableValue::Unknown { universe: self.universe() },\n+            })\n+    }\n+\n     fn next_int_var_id(&self) -> IntVid {\n         self.int_unification_table.borrow_mut().new_key(None)\n     }\n@@ -1092,7 +1125,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.tcx.mk_ty_var(ty_var_id).into()\n             }\n             GenericParamDefKind::Const { .. } => {\n-                unimplemented!() // FIXME(const_generics)\n+                let origin = ConstVariableOrigin::ConstParameterDefinition(span, param.name);\n+                let const_var_id =\n+                    self.const_unification_table\n+                        .borrow_mut()\n+                        .new_key(ConstVarValue {\n+                            origin,\n+                            val: ConstVariableValue::Unknown { universe: self.universe() },\n+                        });\n+                self.tcx.mk_const_var(const_var_id, self.tcx.type_of(param.def_id)).into()\n             }\n         }\n     }\n@@ -1233,46 +1274,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.resolve_type_vars_if_possible(t).to_string()\n     }\n \n-    // We have this force-inlined variant of shallow_resolve() for the one\n-    // callsite that is extremely hot. All other callsites use the normal\n-    // variant.\n-    #[inline(always)]\n-    pub fn inlined_shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match typ.sty {\n-            ty::Infer(ty::TyVar(v)) => {\n-                // Not entirely obvious: if `typ` is a type variable,\n-                // it can be resolved to an int/float variable, which\n-                // can then be recursively resolved, hence the\n-                // recursion. Note though that we prevent type\n-                // variables from unifyxing to other type variables\n-                // directly (though they may be embedded\n-                // structurally), and we prevent cycles in any case,\n-                // so this recursion should always be of very limited\n-                // depth.\n-                self.type_variables\n-                    .borrow_mut()\n-                    .probe(v)\n-                    .known()\n-                    .map(|t| self.shallow_resolve(t))\n-                    .unwrap_or(typ)\n-            }\n-\n-            ty::Infer(ty::IntVar(v)) => self.int_unification_table\n-                .borrow_mut()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.tcx))\n-                .unwrap_or(typ),\n-\n-            ty::Infer(ty::FloatVar(v)) => self.float_unification_table\n-                .borrow_mut()\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.tcx))\n-                .unwrap_or(typ),\n-\n-            _ => typ,\n-        }\n-    }\n-\n     /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n     /// universe index of `TyVar(vid)`.\n     pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n@@ -1284,8 +1285,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        self.inlined_shallow_resolve(typ)\n+    pub fn shallow_resolve<T>(&self, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let mut r = ShallowResolver::new(self);\n+        value.fold_with(&mut r)\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n@@ -1323,9 +1328,36 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r.first_unresolved\n     }\n \n-    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n+    pub fn probe_const_var(\n+        &self,\n+        vid: ty::ConstVid<'tcx>\n+    ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n+        match self.const_unification_table.borrow_mut().probe_value(vid).val {\n+            ConstVariableValue::Known { value } => Ok(value),\n+            ConstVariableValue::Unknown { universe } => Err(universe),\n+        }\n+    }\n+\n+    pub fn resolve_const_var(\n+        &self,\n+        ct: &'tcx ty::Const<'tcx>\n+    ) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const { val: ConstValue::Infer(InferConst::Var(v)), .. } = ct {\n+            self.const_unification_table\n+                .borrow_mut()\n+                .probe_value(*v)\n+                .val\n+                .known()\n+                .map(|c| self.resolve_const_var(c))\n+                .unwrap_or(ct)\n+        } else {\n+            ct\n+        }\n+    }\n+\n+    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<'tcx, T> {\n         /*!\n-         * Attempts to resolve all type/region variables in\n+         * Attempts to resolve all type/region/const variables in\n          * `value`. Region inference must have been run already (e.g.,\n          * by calling `resolve_regions_and_report_errors`). If some\n          * variable was never unified, an `Err` results.\n@@ -1390,7 +1422,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         let fld_r = |br| self.next_region_var(LateBoundRegion(span, br, lbrct));\n         let fld_t = |_| self.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n-        self.tcx.replace_bound_vars(value, fld_r, fld_t)\n+        let fld_c = |_, ty| self.next_const_var(ty, ConstVariableOrigin::MiscVariable(span));\n+        self.tcx.replace_bound_vars(value, fld_r, fld_t, fld_c)\n     }\n \n     /// See the [`region_constraints::verify_generic_bound`] method.\n@@ -1441,7 +1474,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         closure_substs: ty::ClosureSubsts<'tcx>,\n     ) -> Option<ty::ClosureKind> {\n         let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self.tcx);\n-        let closure_kind_ty = self.shallow_resolve(&closure_kind_ty);\n+        let closure_kind_ty = self.shallow_resolve(closure_kind_ty);\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n@@ -1455,7 +1488,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         substs: ty::ClosureSubsts<'tcx>,\n     ) -> ty::PolyFnSig<'tcx> {\n         let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n-        let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n+        let closure_sig_ty = self.shallow_resolve(closure_sig_ty);\n         closure_sig_ty.fn_sig(self.tcx)\n     }\n \n@@ -1511,6 +1544,82 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+pub struct ShallowResolver<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> ShallowResolver<'a, 'gcx, 'tcx> {\n+    #[inline(always)]\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        ShallowResolver { infcx }\n+    }\n+\n+    // We have this force-inlined variant of `shallow_resolve` for the one\n+    // callsite that is extremely hot. All other callsites use the normal\n+    // variant.\n+    #[inline(always)]\n+    pub fn inlined_shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+        match typ.sty {\n+            ty::Infer(ty::TyVar(v)) => {\n+                // Not entirely obvious: if `typ` is a type variable,\n+                // it can be resolved to an int/float variable, which\n+                // can then be recursively resolved, hence the\n+                // recursion. Note though that we prevent type\n+                // variables from unifyxing to other type variables\n+                // directly (though they may be embedded\n+                // structurally), and we prevent cycles in any case,\n+                // so this recursion should always be of very limited\n+                // depth.\n+                self.infcx.type_variables\n+                    .borrow_mut()\n+                    .probe(v)\n+                    .known()\n+                    .map(|t| self.fold_ty(t))\n+                    .unwrap_or(typ)\n+            }\n+\n+            ty::Infer(ty::IntVar(v)) => self.infcx.int_unification_table\n+                .borrow_mut()\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.infcx.tcx))\n+                .unwrap_or(typ),\n+\n+            ty::Infer(ty::FloatVar(v)) => self.infcx.float_unification_table\n+                .borrow_mut()\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.infcx.tcx))\n+                .unwrap_or(typ),\n+\n+            _ => typ,\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ShallowResolver<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.inlined_shallow_resolve(ty)\n+    }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        match ct {\n+            ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } => {\n+                self.infcx.const_unification_table\n+                    .borrow_mut()\n+                    .probe_value(*vid)\n+                    .val\n+                    .known()\n+                    .map(|c| self.fold_const(c))\n+                    .unwrap_or(ct)\n+            }\n+            _ => ct,\n+        }\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n         self.cause.span"}, {"sha": "a3800d8f0754e4a31b7517ebed91fa372ddc0cd3", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -27,7 +27,8 @@ use crate::ty::error::TypeError;\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::Kind;\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt, InferConst};\n+use crate::mir::interpret::ConstValue;\n use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Debug;\n \n@@ -608,6 +609,21 @@ where\n         Ok(a)\n     }\n \n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        if let ty::Const { val: ConstValue::Infer(InferConst::Canonical(_, _)), .. } = a {\n+            // FIXME(const_generics): I'm unsure how this branch should actually be handled,\n+            // so this is probably not correct.\n+            self.infcx.super_combine_consts(self, a, b)\n+        } else {\n+            debug!(\"consts(a={:?}, b={:?}, variance={:?})\", a, b, self.ambient_variance);\n+            relate::super_relate_consts(self, a, b)\n+        }\n+    }\n+\n     fn binders<T>(\n         &mut self,\n         a: &ty::Binder<T>,\n@@ -853,7 +869,7 @@ where\n     fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         use crate::infer::type_variable::TypeVariableValue;\n \n-        debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n+        debug!(\"TypeGeneralizer::tys(a={:?})\", a);\n \n         match a.sty {\n             ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_))\n@@ -934,7 +950,7 @@ where\n         a: ty::Region<'tcx>,\n         _: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"TypeGeneralizer::regions(a={:?})\", a,);\n+        debug!(\"TypeGeneralizer::regions(a={:?})\", a);\n \n         if let ty::ReLateBound(debruijn, _) = a {\n             if *debruijn < self.first_free_index {\n@@ -963,6 +979,23 @@ where\n         Ok(replacement_region_vid)\n     }\n \n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        _: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        debug!(\"TypeGeneralizer::consts(a={:?})\", a);\n+\n+        if let ty::Const { val: ConstValue::Infer(InferConst::Canonical(_, _)), .. } = a {\n+            bug!(\n+                \"unexpected inference variable encountered in NLL generalization: {:?}\",\n+                a\n+            );\n+        } else {\n+            relate::super_relate_consts(self, a, a)\n+        }\n+    }\n+\n     fn binders<T>(\n         &mut self,\n         a: &ty::Binder<T>,\n@@ -971,7 +1004,7 @@ where\n     where\n         T: Relate<'tcx>,\n     {\n-        debug!(\"TypeGeneralizer::binders(a={:?})\", a,);\n+        debug!(\"TypeGeneralizer::binders(a={:?})\", a);\n \n         self.first_free_index.shift_in(1);\n         let result = self.relate(a.skip_binder(), a.skip_binder())?;"}, {"sha": "6d8558211818b777716922954f146cbf08b25210", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -676,8 +676,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         value.fold_with(&mut BottomUpFolder {\n             tcx,\n-            reg_op: |reg| reg,\n-            fldop: |ty| {\n+            ty_op: |ty| {\n                 if let ty::Opaque(def_id, substs) = ty.sty {\n                     // Check that this is `impl Trait` type is\n                     // declared by `parent_def_id` -- i.e., one whose\n@@ -776,6 +775,8 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n                 ty\n             },\n+            lt_op: |lt| lt,\n+            ct_op: |ct| ct,\n         })\n     }\n "}, {"sha": "079385368f883885981e8f5478d074007a9ca133", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -1,5 +1,6 @@\n use super::{InferCtxt, FixupError, FixupResult, Span, type_variable::TypeVariableOrigin};\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use crate::mir::interpret::ConstValue;\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable, InferConst};\n use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -72,6 +73,15 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n                 r,\n         }\n     }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if !ct.needs_infer() {\n+            ct // micro-optimize -- if there is nothing in this const that this fold affects...\n+        } else {\n+            let c0 = self.infcx.shallow_resolve(ct);\n+            c0.super_fold_with(self)\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -136,7 +146,7 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'gcx, 'tcx>\n /// their concrete results. If any variable cannot be replaced (never unified, etc)\n /// then an `Err` result is returned.\n pub fn fully_resolve<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                        value: &T) -> FixupResult<T>\n+                                        value: &T) -> FixupResult<'tcx, T>\n     where T : TypeFoldable<'tcx>\n {\n     let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n@@ -151,7 +161,7 @@ pub fn fully_resolve<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n // `err` field is not enforcable otherwise.\n struct FullTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    err: Option<FixupError>,\n+    err: Option<FixupError<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx> {\n@@ -199,4 +209,25 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n             _ => r,\n         }\n     }\n+\n+    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if !c.needs_infer() && !ty::keep_local(&c) {\n+            c // micro-optimize -- if there is nothing in this const that this fold affects...\n+              // ^ we need to have the `keep_local` check to un-default\n+              // defaulted tuples.\n+        } else {\n+            let c = self.infcx.shallow_resolve(c);\n+            match c.val {\n+                ConstValue::Infer(InferConst::Var(vid)) => {\n+                    self.err = Some(FixupError::UnresolvedConst(vid));\n+                    return self.tcx().consts.err;\n+                }\n+                ConstValue::Infer(InferConst::Fresh(_)) => {\n+                    bug!(\"Unexpected const in full const resolver: {:?}\", c);\n+                }\n+                _ => {}\n+            }\n+            c.super_fold_with(self)\n+        }\n+    }\n }"}, {"sha": "f2f36d59cbef6b6bb8d466e45762c98e03beab05", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -1,11 +1,13 @@\n use super::SubregionOrigin;\n-use super::combine::{CombineFields, RelationDir};\n+use super::combine::{CombineFields, RelationDir, const_unification_error};\n \n use crate::traits::Obligation;\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt, InferConst};\n use crate::ty::TyVar;\n use crate::ty::fold::TypeFoldable;\n use crate::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use crate::infer::unify_key::replace_if_possible;\n+use crate::mir::interpret::ConstValue;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -133,6 +135,48 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         Ok(a)\n     }\n \n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n+        if a == b { return Ok(a); }\n+\n+        let infcx = self.fields.infcx;\n+        let a = replace_if_possible(infcx.const_unification_table.borrow_mut(), a);\n+        let b = replace_if_possible(infcx.const_unification_table.borrow_mut(), b);\n+\n+        // Consts can only be equal or unequal to each other: there's no subtyping\n+        // relation, so we're just going to perform equating here instead.\n+        let a_is_expected = self.a_is_expected();\n+        match (a.val, b.val) {\n+            (ConstValue::Infer(InferConst::Var(a_vid)),\n+                ConstValue::Infer(InferConst::Var(b_vid))) => {\n+                infcx.const_unification_table\n+                    .borrow_mut()\n+                    .unify_var_var(a_vid, b_vid)\n+                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n+                return Ok(a);\n+            }\n+\n+            (ConstValue::Infer(InferConst::Var(a_id)), _) => {\n+                self.fields.infcx.unify_const_variable(a_is_expected, a_id, b)?;\n+                return Ok(a);\n+            }\n+\n+            (_, ConstValue::Infer(InferConst::Var(b_id))) => {\n+                self.fields.infcx.unify_const_variable(!a_is_expected, b_id, a)?;\n+                return Ok(a);\n+            }\n+\n+            _ => {}\n+        }\n+\n+        self.fields.infcx.super_combine_consts(self, a, b)?;\n+        Ok(a)\n+    }\n+\n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>"}, {"sha": "88933312b0d40d9ccb9a08019ab68d656f838529", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -17,7 +17,7 @@ pub struct TypeVariableTable<'tcx> {\n     /// the known value.\n     eq_relations: ut::UnificationTable<ut::InPlace<TyVidEqKey<'tcx>>>,\n \n-    /// Two variables are unified in `eq_relations` when we have a\n+    /// Two variables are unified in `sub_relations` when we have a\n     /// constraint `?X <: ?Y` *or* a constraint `?Y <: ?X`. This second\n     /// table exists only to help with the occurs check. In particular,\n     /// we want to report constraints like these as an occurs check\n@@ -365,7 +365,7 @@ impl sv::SnapshotVecDelegate for Delegate {\n \n     fn reverse(_values: &mut Vec<TypeVariableData>, _action: Instantiate) {\n         // We don't actually have to *do* anything to reverse an\n-        // instanation; the value for a variable is stored in the\n+        // instantiation; the value for a variable is stored in the\n         // `eq_relations` and hence its rollback code will handle\n         // it. In fact, we could *almost* just remove the\n         // `SnapshotVec` entirely, except that we would have to"}, {"sha": "678a45a84e9eafc9dac86a21ca8555b311fc23e4", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 116, "deletions": 6, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -1,5 +1,13 @@\n-use crate::ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt};\n-use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue};\n+use crate::ty::{self, FloatVarValue, IntVarValue, Ty, TyCtxt, InferConst};\n+use crate::mir::interpret::ConstValue;\n+use rustc_data_structures::unify::{NoError, EqUnifyValue, UnifyKey, UnifyValue, UnificationTable};\n+use rustc_data_structures::unify::InPlace;\n+use syntax_pos::{Span, DUMMY_SP};\n+use syntax::symbol::InternedString;\n+\n+use std::cmp;\n+use std::marker::PhantomData;\n+use std::cell::RefMut;\n \n pub trait ToType {\n     fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n@@ -12,8 +20,7 @@ impl UnifyKey for ty::IntVid {\n     fn tag() -> &'static str { \"IntVid\" }\n }\n \n-impl EqUnifyValue for IntVarValue {\n-}\n+impl EqUnifyValue for IntVarValue {}\n \n #[derive(PartialEq, Copy, Clone, Debug)]\n pub struct RegionVidKey {\n@@ -62,11 +69,114 @@ impl UnifyKey for ty::FloatVid {\n     fn tag() -> &'static str { \"FloatVid\" }\n }\n \n-impl EqUnifyValue for FloatVarValue {\n-}\n+impl EqUnifyValue for FloatVarValue {}\n \n impl ToType for FloatVarValue {\n     fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_mach_float(self.0)\n     }\n }\n+\n+// Generic consts.\n+\n+/// Reasons to create a const inference variable\n+#[derive(Copy, Clone, Debug)]\n+pub enum ConstVariableOrigin {\n+    MiscVariable(Span),\n+    ConstInference(Span),\n+    ConstParameterDefinition(Span, InternedString),\n+    SubstitutionPlaceholder(Span),\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum ConstVariableValue<'tcx> {\n+    Known { value: &'tcx ty::Const<'tcx> },\n+    Unknown { universe: ty::UniverseIndex },\n+}\n+\n+impl<'tcx> ConstVariableValue<'tcx> {\n+    /// If this value is known, returns the const it is known to be.\n+    /// Otherwise, `None`.\n+    pub fn known(&self) -> Option<&'tcx ty::Const<'tcx>> {\n+        match *self {\n+            ConstVariableValue::Unknown { .. } => None,\n+            ConstVariableValue::Known { value } => Some(value),\n+        }\n+    }\n+\n+    pub fn is_unknown(&self) -> bool {\n+        match *self {\n+            ConstVariableValue::Unknown { .. } => true,\n+            ConstVariableValue::Known { .. } => false,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct ConstVarValue<'tcx> {\n+    pub origin: ConstVariableOrigin,\n+    pub val: ConstVariableValue<'tcx>,\n+}\n+\n+impl<'tcx> UnifyKey for ty::ConstVid<'tcx> {\n+    type Value = ConstVarValue<'tcx>;\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> Self { ty::ConstVid { index: i, phantom: PhantomData } }\n+    fn tag() -> &'static str { \"ConstVid\" }\n+}\n+\n+impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n+    type Error = (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>);\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, Self::Error> {\n+        let val = match (value1.val, value2.val) {\n+            (\n+                ConstVariableValue::Known { .. },\n+                ConstVariableValue::Known { .. }\n+            ) => {\n+                bug!(\"equating two const variables, both of which have known values\")\n+            }\n+\n+            // If one side is known, prefer that one.\n+            (ConstVariableValue::Known { .. }, ConstVariableValue::Unknown { .. }) => {\n+                Ok(value1.val)\n+            }\n+            (ConstVariableValue::Unknown { .. }, ConstVariableValue::Known { .. }) => {\n+                Ok(value2.val)\n+            }\n+\n+            // If both sides are *unknown*, it hardly matters, does it?\n+            (ConstVariableValue::Unknown { universe: universe1 },\n+             ConstVariableValue::Unknown { universe: universe2 }) =>  {\n+                // If we unify two unbound variables, ?T and ?U, then whatever\n+                // value they wind up taking (which must be the same value) must\n+                // be nameable by both universes. Therefore, the resulting\n+                // universe is the minimum of the two universes, because that is\n+                // the one which contains the fewest names in scope.\n+                let universe = cmp::min(universe1, universe2);\n+                Ok(ConstVariableValue::Unknown { universe })\n+            }\n+        }?;\n+\n+        Ok(ConstVarValue {\n+            origin: ConstVariableOrigin::ConstInference(DUMMY_SP),\n+            val,\n+        })\n+    }\n+}\n+\n+impl<'tcx> EqUnifyValue for &'tcx ty::Const<'tcx> {}\n+\n+pub fn replace_if_possible(\n+    mut table: RefMut<'_, UnificationTable<InPlace<ty::ConstVid<'tcx>>>>,\n+    c: &'tcx ty::Const<'tcx>\n+) -> &'tcx ty::Const<'tcx> {\n+    if let ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } = c {\n+        match table.probe_value(*vid).val.known() {\n+            Some(c) => c,\n+            None => c,\n+        }\n+    } else {\n+        c\n+    }\n+}"}, {"sha": "7e45568725f3557c67e0c021ee700881a6e14832", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -2,6 +2,7 @@ use std::fmt;\n use rustc_macros::HashStable;\n \n use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n+use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n \n use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n@@ -26,6 +27,9 @@ pub enum ConstValue<'tcx> {\n     /// Infer the value of the const.\n     Infer(InferConst<'tcx>),\n \n+    /// A placeholder const - universally quantified higher-ranked const.\n+    Placeholder(PlaceholderConst),\n+\n     /// Used only for types with `layout::abi::Scalar` ABI and ZSTs.\n     ///\n     /// Not using the enum `Value` to encode that this must not be `Undef`.\n@@ -58,6 +62,7 @@ impl<'tcx> ConstValue<'tcx> {\n         match *self {\n             ConstValue::Param(_) |\n             ConstValue::Infer(_) |\n+            ConstValue::Placeholder(_) |\n             ConstValue::ByRef(..) |\n             ConstValue::Unevaluated(..) |\n             ConstValue::Slice(..) => None,"}, {"sha": "007ff32f32776a1229a2c34e94d815173441df95", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -1248,15 +1248,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let sig = if let ty::Tuple(inputs) = inputs.sty {\n                 tcx.mk_fn_sig(\n                     inputs.iter().map(|k| k.expect_ty()),\n-                    tcx.mk_infer(ty::TyVar(ty::TyVid { index: 0 })),\n+                    tcx.mk_ty_infer(ty::TyVar(ty::TyVid { index: 0 })),\n                     false,\n                     hir::Unsafety::Normal,\n                     ::rustc_target::spec::abi::Abi::Rust\n                 )\n             } else {\n                 tcx.mk_fn_sig(\n                     ::std::iter::once(inputs),\n-                    tcx.mk_infer(ty::TyVar(ty::TyVid { index: 0 })),\n+                    tcx.mk_ty_infer(ty::TyVar(ty::TyVid { index: 0 })),\n                     false,\n                     hir::Unsafety::Normal,\n                     ::rustc_target::spec::abi::Abi::Rust"}, {"sha": "96212d829d44884cec1c4aef2d47e4b3093ecf43", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::InferCtxt;\n+use crate::infer::{InferCtxt, ShallowResolver};\n use crate::mir::interpret::{GlobalId, ErrorHandled};\n use crate::ty::{self, Ty, TypeFoldable, ToPolyTraitRef};\n use crate::ty::error::ExpectedFound;\n@@ -256,8 +256,8 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n         if !pending_obligation.stalled_on.is_empty() {\n             if pending_obligation.stalled_on.iter().all(|&ty| {\n                 // Use the force-inlined variant of shallow_resolve() because this code is hot.\n-                let resolved_ty = self.selcx.infcx().inlined_shallow_resolve(&ty);\n-                resolved_ty == ty // nothing changed here\n+                let resolved = ShallowResolver::new(self.selcx.infcx()).inlined_shallow_resolve(ty);\n+                resolved == ty // nothing changed here\n             }) {\n                 debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n                        self.selcx.infcx()"}, {"sha": "dabb8a728901cf554326d2be6d70b9d809c524c8", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -1371,7 +1371,7 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n     let tcx = selcx.tcx();\n     let infcx = selcx.infcx();\n     let closure_sig_ty = vtable.substs.closure_sig_ty(vtable.closure_def_id, tcx);\n-    let closure_sig = infcx.shallow_resolve(&closure_sig_ty).fn_sig(tcx);\n+    let closure_sig = infcx.shallow_resolve(closure_sig_ty).fn_sig(tcx);\n     let Normalized {\n         value: closure_sig,\n         obligations"}, {"sha": "f0c402789c4cd192428a241e4493672c4ce08715", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -3124,8 +3124,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // OK to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n-        let self_ty = self.infcx\n-            .shallow_resolve(obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (generator_def_id, substs) = match self_ty.sty {\n             ty::Generator(id, substs, _) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n@@ -3182,8 +3181,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // OK to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n-        let self_ty = self.infcx\n-            .shallow_resolve(obligation.self_ty().skip_binder());\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::Closure(id, substs) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),"}, {"sha": "8640216b071ae4783cd27d01c64a2579c28fa532", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -1,6 +1,7 @@\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt, InferConst};\n use crate::ty::error::TypeError;\n use crate::ty::relate::{self, Relate, TypeRelation, RelateResult};\n+use crate::mir::interpret::ConstValue;\n \n /// A type \"A\" *matches* \"B\" if the fresh types in B could be\n /// substituted with values so as to make it equal to A. Matching is\n@@ -78,6 +79,31 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n+        if a == b {\n+            return Ok(a);\n+        }\n+\n+        match (a.val, b.val) {\n+            (_, ConstValue::Infer(InferConst::Fresh(_))) => {\n+                return Ok(a);\n+            }\n+\n+            (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n+                return Err(TypeError::ConstMismatch(relate::expected_found(self, &a, &b)));\n+            }\n+\n+            _ => {}\n+        }\n+\n+        relate::super_relate_consts(self, a, b)\n+    }\n+\n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n         where T: Relate<'tcx>"}, {"sha": "c07175d9451e647e15cecb2f3cfe1d5d570c4724", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -233,6 +233,10 @@ pub struct CommonLifetimes<'tcx> {\n     pub re_erased: Region<'tcx>,\n }\n \n+pub struct CommonConsts<'tcx> {\n+    pub err: &'tcx Const<'tcx>,\n+}\n+\n pub struct LocalTableInContext<'a, V: 'a> {\n     local_id_root: Option<DefId>,\n     data: &'a ItemLocalMap<V>\n@@ -980,6 +984,20 @@ impl<'tcx> CommonLifetimes<'tcx> {\n     }\n }\n \n+impl<'tcx> CommonConsts<'tcx> {\n+    fn new(interners: &CtxtInterners<'tcx>, types: &CommonTypes<'tcx>) -> CommonConsts<'tcx> {\n+        let mk_const = |c| {\n+            interners.const_.borrow_mut().intern(c, |c| {\n+                Interned(interners.arena.alloc(c))\n+            }).0\n+        };\n+\n+        CommonConsts {\n+            err: mk_const(ty::Const::zero_sized(types.err)),\n+        }\n+    }\n+}\n+\n // This struct contains information regarding the `ReFree(FreeRegion)` corresponding to a lifetime\n // conflict.\n #[derive(Debug)]\n@@ -1030,6 +1048,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common lifetimes, pre-interned for your convenience.\n     pub lifetimes: CommonLifetimes<'tcx>,\n \n+    /// Common consts, pre-interned for your convenience.\n+    pub consts: CommonConsts<'tcx>,\n+\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     trait_map: FxHashMap<DefIndex,\n@@ -1229,6 +1250,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let interners = CtxtInterners::new(&arenas.interner);\n         let common_types = CommonTypes::new(&interners);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n+        let common_consts = CommonConsts::new(&interners, &common_types);\n         let dep_graph = hir.dep_graph.clone();\n         let max_cnum = cstore.crates_untracked().iter().map(|c| c.as_usize()).max().unwrap_or(0);\n         let mut providers = IndexVec::from_elem_n(extern_providers, max_cnum + 1);\n@@ -1284,6 +1306,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             dep_graph,\n             types: common_types,\n             lifetimes: common_lifetimes,\n+            consts: common_consts,\n             trait_map,\n             export_map: resolutions.export_map.into_iter().map(|(k, v)| {\n                 let exports: Vec<_> = v.into_iter().map(|e| {\n@@ -2650,7 +2673,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_ty_var(self, v: TyVid) -> Ty<'tcx> {\n-        self.mk_infer(TyVar(v))\n+        self.mk_ty_infer(TyVar(v))\n     }\n \n     #[inline]\n@@ -2663,19 +2686,31 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_int_var(self, v: IntVid) -> Ty<'tcx> {\n-        self.mk_infer(IntVar(v))\n+        self.mk_ty_infer(IntVar(v))\n     }\n \n     #[inline]\n     pub fn mk_float_var(self, v: FloatVid) -> Ty<'tcx> {\n-        self.mk_infer(FloatVar(v))\n+        self.mk_ty_infer(FloatVar(v))\n     }\n \n     #[inline]\n-    pub fn mk_infer(self, it: InferTy) -> Ty<'tcx> {\n+    pub fn mk_ty_infer(self, it: InferTy) -> Ty<'tcx> {\n         self.mk_ty(Infer(it))\n     }\n \n+    #[inline]\n+    pub fn mk_const_infer(\n+        self,\n+        ic: InferConst<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> &'tcx ty::Const<'tcx> {\n+        self.mk_const(ty::Const {\n+            val: ConstValue::Infer(ic),\n+            ty,\n+        })\n+    }\n+\n     #[inline]\n     pub fn mk_ty_param(self,\n                        index: u32,"}, {"sha": "4e4024d5bab43e67ba507a02be7d3b68d825daad", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -44,6 +44,8 @@ pub enum TypeError<'tcx> {\n     ProjectionMismatched(ExpectedFound<DefId>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n+\n+    ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -163,6 +165,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 report_maybe_different(f, &format!(\"trait `{}`\", values.expected),\n                                        &format!(\"trait `{}`\", values.found))\n             }\n+            ConstMismatch(ref values) => {\n+                write!(f, \"expected `{:?}`, found `{:?}`\", values.expected, values.found)\n+            }\n         }\n     }\n }"}, {"sha": "8d7e7e16e85cb738fc102c4d0e76c3b39c4f90da", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -254,6 +254,9 @@ impl FlagComputation {\n             ConstValue::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_PARAMS);\n             }\n+            ConstValue::Placeholder(_) => {\n+                self.add_flags(TypeFlags::HAS_FREE_REGIONS | TypeFlags::HAS_CT_PLACEHOLDER);\n+            }\n             _ => {},\n         }\n     }"}, {"sha": "dbf9047f775bf2ea738ebd2c64730ef00242e408", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 115, "deletions": 21, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -32,6 +32,7 @@\n //! looking for, and does not need to visit anything else.\n \n use crate::hir::def_id::DefId;\n+use crate::mir::interpret::ConstValue;\n use crate::ty::{self, Binder, Ty, TyCtxt, TypeFlags, flags::FlagComputation};\n \n use std::collections::BTreeMap;\n@@ -96,7 +97,11 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         )\n     }\n     fn has_placeholders(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_PLACEHOLDER | TypeFlags::HAS_TY_PLACEHOLDER)\n+        self.has_type_flags(\n+            TypeFlags::HAS_RE_PLACEHOLDER |\n+            TypeFlags::HAS_TY_PLACEHOLDER |\n+            TypeFlags::HAS_CT_PLACEHOLDER\n+        )\n     }\n     fn needs_subst(&self) -> bool {\n         self.has_type_flags(TypeFlags::NEEDS_SUBST)\n@@ -193,29 +198,37 @@ pub trait TypeVisitor<'tcx> : Sized {\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a, F, G>\n+pub struct BottomUpFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a, F, G, H>\n     where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n           G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n+          H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    pub fldop: F,\n-    pub reg_op: G,\n+    pub ty_op: F,\n+    pub lt_op: G,\n+    pub ct_op: H,\n }\n \n-impl<'a, 'gcx, 'tcx, F, G> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx, 'tcx, F, G>\n+impl<'a, 'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx, 'tcx, F, G, H>\n     where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n           G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n+          H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let t1 = ty.super_fold_with(self);\n-        (self.fldop)(t1)\n+        let t = ty.super_fold_with(self);\n+        (self.ty_op)(t)\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         let r = r.super_fold_with(self);\n-        (self.reg_op)(r)\n+        (self.lt_op)(r)\n+    }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        let ct = ct.super_fold_with(self);\n+        (self.ct_op)(ct)\n     }\n }\n \n@@ -422,22 +435,26 @@ struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n     fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n     fld_t: &'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a),\n+    fld_c: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx> + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n-    fn new<F, G>(\n+    fn new<F, G, H>(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         fld_r: &'a mut F,\n-        fld_t: &'a mut G\n+        fld_t: &'a mut G,\n+        fld_c: &'a mut H,\n     ) -> Self\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-              G: FnMut(ty::BoundTy) -> Ty<'tcx>\n+              G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n+              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n     {\n         BoundVarReplacer {\n             tcx,\n             current_index: ty::INNERMOST,\n             fld_r,\n             fld_t,\n+            fld_c,\n         }\n     }\n }\n@@ -497,6 +514,32 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx>\n             _ => r\n         }\n     }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const {\n+            val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, bound_const)),\n+            ty,\n+        } = *ct {\n+            if debruijn == self.current_index {\n+                let fld_c = &mut self.fld_c;\n+                let ct = fld_c(bound_const, ty);\n+                ty::fold::shift_vars(\n+                    self.tcx,\n+                    &ct,\n+                    self.current_index.as_u32()\n+                )\n+            } else {\n+                ct\n+            }\n+        } else {\n+            if !ct.has_vars_bound_at_or_above(self.current_index) {\n+                // Nothing more to substitute.\n+                ct\n+            } else {\n+                ct.super_fold_with(self)\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -519,27 +562,34 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               T: TypeFoldable<'tcx>\n     {\n-        // identity for bound types\n+        // identity for bound types and consts\n         let fld_t = |bound_ty| self.mk_ty(ty::Bound(ty::INNERMOST, bound_ty));\n-        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n+        let fld_c = |bound_ct, ty| {\n+            self.mk_const_infer(ty::InferConst::Canonical(ty::INNERMOST, bound_ct), ty)\n+        };\n+        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces all escaping bound vars. The `fld_r` closure replaces escaping\n-    /// bound regions while the `fld_t` closure replaces escaping bound types.\n-    pub fn replace_escaping_bound_vars<T, F, G>(\n+    /// bound regions; the `fld_t` closure replaces escaping bound types and the `fld_c`\n+    /// closure replaces escaping bound consts.\n+    pub fn replace_escaping_bound_vars<T, F, G, H>(\n         self,\n         value: &T,\n         mut fld_r: F,\n-        mut fld_t: G\n+        mut fld_t: G,\n+        mut fld_c: H,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n-              T: TypeFoldable<'tcx>\n+              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n+              T: TypeFoldable<'tcx>,\n     {\n         use rustc_data_structures::fx::FxHashMap;\n \n         let mut region_map = BTreeMap::new();\n         let mut type_map = FxHashMap::default();\n+        let mut const_map = FxHashMap::default();\n \n         if !value.has_escaping_bound_vars() {\n             (value.clone(), region_map)\n@@ -552,7 +602,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 *type_map.entry(bound_ty).or_insert_with(|| fld_t(bound_ty))\n             };\n \n-            let mut replacer = BoundVarReplacer::new(self, &mut real_fld_r, &mut real_fld_t);\n+            let mut real_fld_c = |bound_ct, ty| {\n+                *const_map.entry(bound_ct).or_insert_with(|| fld_c(bound_ct, ty))\n+            };\n+\n+            let mut replacer = BoundVarReplacer::new(\n+                self,\n+                &mut real_fld_r,\n+                &mut real_fld_t,\n+                &mut real_fld_c,\n+            );\n             let result = value.fold_with(&mut replacer);\n             (result, region_map)\n         }\n@@ -561,17 +620,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Replaces all types or regions bound by the given `Binder`. The `fld_r`\n     /// closure replaces bound regions while the `fld_t` closure replaces bound\n     /// types.\n-    pub fn replace_bound_vars<T, F, G>(\n+    pub fn replace_bound_vars<T, F, G, H>(\n         self,\n         value: &Binder<T>,\n         fld_r: F,\n-        fld_t: G\n+        fld_t: G,\n+        fld_c: H,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n+              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n               T: TypeFoldable<'tcx>\n     {\n-        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n+        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n     }\n \n     /// Replaces any late-bound regions bound in `value` with\n@@ -732,6 +793,28 @@ impl TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n             _ => ty.super_fold_with(self),\n         }\n     }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const {\n+            val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, bound_const)),\n+            ty,\n+        } = *ct {\n+            if self.amount == 0 || debruijn < self.current_index {\n+                ct\n+            } else {\n+                let debruijn = match self.direction {\n+                    Direction::In => debruijn.shifted_in(self.amount),\n+                    Direction::Out => {\n+                        assert!(debruijn.as_u32() >= self.amount);\n+                        debruijn.shifted_out(self.amount)\n+                    }\n+                };\n+                self.tcx.mk_const_infer(ty::InferConst::Canonical(debruijn, bound_const), ty)\n+            }\n+        } else {\n+            ct.super_fold_with(self)\n+        }\n+    }\n }\n \n pub fn shift_region<'a, 'gcx, 'tcx>(\n@@ -824,6 +907,17 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         // visited.\n         r.bound_at_or_above_binder(self.outer_index)\n     }\n+\n+    fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> bool {\n+        if let ty::Const {\n+            val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, _)),\n+            ..\n+        } = *ct {\n+            debruijn >= self.outer_index\n+        } else {\n+            false\n+        }\n+    }\n }\n \n struct HasTypeFlagsVisitor {"}, {"sha": "36da21b71f53676fcd13907d5a33de83be642734", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -96,6 +96,7 @@ mod constness;\n pub mod error;\n mod erase_regions;\n pub mod fast_reject;\n+pub mod flags;\n pub mod fold;\n pub mod inhabitedness;\n pub mod layout;\n@@ -112,7 +113,6 @@ pub mod wf;\n pub mod util;\n \n mod context;\n-mod flags;\n mod instance;\n mod structural_impls;\n mod sty;\n@@ -455,6 +455,7 @@ bitflags! {\n         const HAS_TY_PLACEHOLDER = 1 << 14;\n \n         const HAS_CT_INFER = 1 << 15;\n+        const HAS_CT_PLACEHOLDER = 1 << 16;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n@@ -477,7 +478,8 @@ bitflags! {\n                                   TypeFlags::HAS_FREE_LOCAL_NAMES.bits |\n                                   TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n                                   TypeFlags::HAS_RE_LATE_BOUND.bits |\n-                                  TypeFlags::HAS_TY_PLACEHOLDER.bits;\n+                                  TypeFlags::HAS_TY_PLACEHOLDER.bits |\n+                                  TypeFlags::HAS_CT_PLACEHOLDER.bits;\n     }\n }\n \n@@ -1630,6 +1632,8 @@ pub type PlaceholderRegion = Placeholder<BoundRegion>;\n \n pub type PlaceholderType = Placeholder<BoundVar>;\n \n+pub type PlaceholderConst = Placeholder<BoundVar>;\n+\n /// When type checking, we use the `ParamEnv` to track\n /// details about the set of where-clauses that are in scope at this\n /// particular point."}, {"sha": "d2cc2514536102ac335656f51bf21516318dc9b9", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -712,7 +712,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             // in order to place the projections inside the `<...>`.\n             if !resugared {\n                 // Use a type that can't appear in defaults of type parameters.\n-                let dummy_self = self.tcx().mk_infer(ty::FreshTy(0));\n+                let dummy_self = self.tcx().mk_ty_infer(ty::FreshTy(0));\n                 let principal = principal.with_self_ty(self.tcx(), dummy_self);\n \n                 let args = self.generic_args_to_print(\n@@ -1481,7 +1481,7 @@ define_print_and_forward_display! {\n \n     ty::ExistentialTraitRef<'tcx> {\n         // Use a type that can't appear in defaults of type parameters.\n-        let dummy_self = cx.tcx().mk_infer(ty::FreshTy(0));\n+        let dummy_self = cx.tcx().mk_ty_infer(ty::FreshTy(0));\n         let trait_ref = self.with_self_ty(cx.tcx(), dummy_self);\n         p!(print(trait_ref))\n     }"}, {"sha": "d7b19070741955075e205afe50b5f4ae1e47e477", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 89, "deletions": 9, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -8,7 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{GlobalId, ConstValue};\n+use crate::mir::interpret::{GlobalId, ConstValue, Scalar};\n use crate::util::common::ErrorReported;\n use syntax_pos::DUMMY_SP;\n use std::rc::Rc;\n@@ -76,11 +76,19 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     // additional hooks for other types in the future if needed\n     // without making older code, which called `relate`, obsolete.\n \n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>)\n-           -> RelateResult<'tcx, Ty<'tcx>>;\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>>;\n \n-    fn regions(&mut self, a: ty::Region<'tcx>, b: ty::Region<'tcx>)\n-               -> RelateResult<'tcx, ty::Region<'tcx>>;\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>>;\n+\n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>;\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n@@ -116,7 +124,7 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n                 ast::Mutability::MutMutable => ty::Invariant,\n             };\n             let ty = relation.relate_with_variance(variance, &a.ty, &b.ty)?;\n-            Ok(ty::TypeAndMut {ty: ty, mutbl: mutbl})\n+            Ok(ty::TypeAndMut { ty, mutbl })\n         }\n     }\n }\n@@ -468,6 +476,8 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             let t = relation.relate(&a_t, &b_t)?;\n             let to_u64 = |x: ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n                 match x.val {\n+                    // FIXME(const_generics): this doesn't work right now,\n+                    // because it tries to relate an `Infer` to a `Param`.\n                     ConstValue::Unevaluated(def_id, substs) => {\n                         // FIXME(eddyb) get the right param_env.\n                         let param_env = ty::ParamEnv::empty();\n@@ -481,7 +491,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                             if let Some(instance) = instance {\n                                 let cid = GlobalId {\n                                     instance,\n-                                    promoted: None\n+                                    promoted: None,\n                                 };\n                                 if let Some(s) = tcx.const_eval(param_env.and(cid))\n                                                     .ok()\n@@ -575,6 +585,62 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     }\n }\n \n+/// The main \"const relation\" routine. Note that this does not handle\n+/// inference artifacts, so you should filter those out before calling\n+/// it.\n+pub fn super_relate_consts<'a, 'gcx, 'tcx, R>(\n+    relation: &mut R,\n+    a: &'tcx ty::Const<'tcx>,\n+    b: &'tcx ty::Const<'tcx>\n+) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n+where\n+    R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+{\n+    let tcx = relation.tcx();\n+\n+    // Currently, the values that can be unified are those that\n+    // implement both `PartialEq` and `Eq`, corresponding to\n+    // `structural_match` types.\n+    // FIXME(const_generics): check for `structural_match` synthetic attribute.\n+    match (a.val, b.val) {\n+        (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n+            // The caller should handle these cases!\n+            bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n+        }\n+        (ConstValue::Param(a_p), ConstValue::Param(b_p)) if a_p.index == b_p.index => {\n+            Ok(a)\n+        }\n+        (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n+            Ok(a)\n+        }\n+        (ConstValue::Scalar(Scalar::Bits { .. }), _) if a == b => {\n+            Ok(a)\n+        }\n+        (ConstValue::ByRef(..), _) => {\n+            bug!(\n+                \"non-Scalar ConstValue encountered in super_relate_consts {:?} {:?}\",\n+                a,\n+                b,\n+            );\n+        }\n+\n+        // FIXME(const_generics): this is wrong, as it is a projection\n+        (ConstValue::Unevaluated(a_def_id, a_substs),\n+            ConstValue::Unevaluated(b_def_id, b_substs)) if a_def_id == b_def_id => {\n+                let substs =\n+                    relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n+                Ok(tcx.mk_const(ty::Const {\n+                    val: ConstValue::Unevaluated(a_def_id, &substs),\n+                    ty: a.ty,\n+                }))\n+            }\n+\n+            _ => {\n+            Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+        }\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &Self,\n@@ -646,6 +712,17 @@ impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &&'tcx ty::Const<'tcx>,\n+                           b: &&'tcx ty::Const<'tcx>)\n+                           -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    {\n+        relation.consts(*a, *b)\n+    }\n+}\n+\n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ty::Binder<T>,\n@@ -699,14 +776,17 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n             (UnpackedKind::Type(a_ty), UnpackedKind::Type(b_ty)) => {\n                 Ok(relation.relate(&a_ty, &b_ty)?.into())\n             }\n+            (UnpackedKind::Const(a_ct), UnpackedKind::Const(b_ct)) => {\n+                Ok(relation.relate(&a_ct, &b_ct)?.into())\n+            }\n             (UnpackedKind::Lifetime(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n             (UnpackedKind::Type(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n-            (UnpackedKind::Const(_), _) => {\n-                unimplemented!() // FIXME(const_generics)\n+            (UnpackedKind::Const(unpacked), x) => {\n+                bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n         }\n     }"}, {"sha": "504b939c5f2d6bcf07d4827cb0b20db9e1595ee0", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -737,7 +737,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n             ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n-            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch)\n+            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n+            ConstMismatch(ref x) => return tcx.lift(x).map(ConstMismatch),\n         })\n     }\n }\n@@ -1320,6 +1321,7 @@ EnumTypeFoldableImpl! {\n         (ty::error::TypeError::ProjectionBoundsLength)(x),\n         (ty::error::TypeError::Sorts)(x),\n         (ty::error::TypeError::ExistentialMismatch)(x),\n+        (ty::error::TypeError::ConstMismatch)(x),\n     }\n }\n \n@@ -1353,6 +1355,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n             // FIXME(const_generics): implement TypeFoldable for InferConst\n             ConstValue::Infer(ic) => ConstValue::Infer(ic),\n             ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n+            ConstValue::Placeholder(p) => ConstValue::Placeholder(p),\n             ConstValue::Scalar(a) => ConstValue::Scalar(a),\n             ConstValue::Slice(a, b) => ConstValue::Slice(a, b),\n             ConstValue::Unevaluated(did, substs)\n@@ -1364,8 +1367,9 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n         match *self {\n             ConstValue::ByRef(..) => false,\n             // FIXME(const_generics): implement TypeFoldable for InferConst\n-            ConstValue::Infer(_ic) => false,\n+            ConstValue::Infer(_) => false,\n             ConstValue::Param(p) => p.visit_with(visitor),\n+            ConstValue::Placeholder(_) => false,\n             ConstValue::Scalar(_) => false,\n             ConstValue::Slice(..) => false,\n             ConstValue::Unevaluated(_, substs) => substs.visit_with(visitor),"}, {"sha": "c474baac3d1293d98b5b9a31b8c6d87896b2d710", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -516,7 +516,7 @@ pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a placeholder type.\n-    let open_ty = tcx.mk_infer(ty::FreshTy(0));\n+    let open_ty = tcx.mk_ty_infer(ty::FreshTy(0));\n \n     let predicates = existential_predicates.iter().filter_map(|predicate| {\n         if let ty::ExistentialPredicate::Projection(_) = *predicate.skip_binder() {"}, {"sha": "3b8e5b449538324c522328192b3bd61d470ba74c", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -79,6 +79,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n             ConstValue::Unevaluated(..) => bug!(\"unevaluated constant in `OperandRef::from_const`\"),\n             ConstValue::Param(_) => bug!(\"encountered a ConstValue::Param in codegen\"),\n             ConstValue::Infer(_) => bug!(\"encountered a ConstValue::Infer in codegen\"),\n+            ConstValue::Placeholder(_) => bug!(\"encountered a ConstValue::Placeholder in codegen\"),\n             ConstValue::Scalar(x) => {\n                 let scalar = match layout.abi {\n                     layout::Abi::Scalar(ref x) => x,"}, {"sha": "ed7c316e3da75076891b699394ae6e538f30668a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -524,7 +524,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let op = match val.val {\n-            ConstValue::Param(_) | ConstValue::Infer(_) => bug!(),\n+            ConstValue::Param(_) => return err!(TooGeneric),\n+            ConstValue::Infer(_) | ConstValue::Placeholder(_) => bug!(),\n             ConstValue::ByRef(ptr, alloc) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway."}, {"sha": "b001a09529e5b44867d8a52c50f28d5fa82d58db", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n     // FIXME(const_generics): handle debug printing.\n     pub fn push_const_name(&self, c: &Const<'tcx>, output: &mut String, debug: bool) {\n         match c.val {\n-            ConstValue::Infer(..) => output.push_str(\"_\"),\n+            ConstValue::Infer(..) | ConstValue::Placeholder(_) => output.push_str(\"_\"),\n             ConstValue::Param(ParamConst { name, .. }) => {\n                 write!(output, \"{}\", name).unwrap();\n             }"}, {"sha": "9d234e93b837bc797aed624171a3dc41006503f5", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -16,9 +16,10 @@ use rustc::traits::{\n     Environment,\n     InEnvironment,\n };\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, InferConst};\n use rustc::ty::subst::Kind;\n use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc::mir::interpret::ConstValue;\n use syntax_pos::DUMMY_SP;\n \n use super::{ChalkInferenceContext, ChalkArenas, ChalkExClause, ConstrainedSubst};\n@@ -275,4 +276,44 @@ impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n \n         Ok(a)\n     }\n+\n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        if let ty::Const {\n+            val: ConstValue::Infer(InferConst::Canonical(debruijn, bound_ct)),\n+            ..\n+        } = a {\n+            if *debruijn == self.binder_index {\n+                self.unify_free_answer_var(*bound_ct, b.into())?;\n+                return Ok(b);\n+            }\n+        }\n+\n+        match (a, b) {\n+            (\n+                ty::Const {\n+                    val: ConstValue::Infer(InferConst::Canonical(a_debruijn, a_bound)),\n+                    ..\n+                },\n+                ty::Const {\n+                    val: ConstValue::Infer(InferConst::Canonical(b_debruijn, b_bound)),\n+                    ..\n+                },\n+            ) => {\n+                assert_eq!(a_debruijn, b_debruijn);\n+                assert_eq!(a_bound, b_bound);\n+                Ok(a)\n+            }\n+\n+            // Everything else should just be a perfect match as well,\n+            // and we forbid inference variables.\n+            _ => match ty::relate::super_relate_consts(self, a, b) {\n+                Ok(ct) => Ok(ct),\n+                Err(err) => bug!(\"const mismatch in `AnswerSubstitutor`: {}\", err),\n+            }\n+        }\n+    }\n }"}, {"sha": "a35777873abdfc73ac5560149fb5b8ce49af6674", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -21,6 +21,7 @@ use rustc::traits::query::method_autoderef::{MethodAutoderefBadTy};\n use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n use rustc::ty::GenericParamDefKind;\n use rustc::infer::type_variable::TypeVariableOrigin;\n+use rustc::infer::unify_key::ConstVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n use rustc::infer::canonical::{Canonical, QueryResponse};\n@@ -1572,7 +1573,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                         self.tcx.def_span(def_id))).into()\n                 }\n                 GenericParamDefKind::Const { .. } => {\n-                    unimplemented!() // FIXME(const_generics)\n+                    let span = self.tcx.def_span(def_id);\n+                    let origin = ConstVariableOrigin::SubstitutionPlaceholder(span);\n+                    self.next_const_var(self.tcx.type_of(param.def_id), origin).into()\n                 }\n             }\n         })"}, {"sha": "8ee30c0d2d31d8759378367e37745425ecdb4e8b", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -616,7 +616,7 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n     let mut substituted_predicates = Vec::new();\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n-        fldop: |ty| {\n+        ty_op: |ty| {\n             if let ty::Opaque(def_id, substs) = ty.sty {\n                 trace!(\"check_existential_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n@@ -739,7 +739,8 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n             } // if let Opaque\n             ty\n         },\n-        reg_op: |reg| reg,\n+        lt_op: |lt| lt,\n+        ct_op: |ct| ct,\n     });\n     substituted_predicates\n }"}, {"sha": "f9d83146e30c32071a05e3c64018bb6eb09c699d", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -12,6 +12,7 @@ use rustc::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::mir::interpret::ConstValue;\n use rustc::util::nodemap::DefIdSet;\n use rustc_data_structures::sync::Lrc;\n use std::mem;\n@@ -488,7 +489,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 // figures out the concrete type with `U`, but the stored type is with `T`\n                 instantiated_ty.fold_with(&mut BottomUpFolder {\n                     tcx: self.tcx().global_tcx(),\n-                    fldop: |ty| {\n+                    ty_op: |ty| {\n                         trace!(\"checking type {:?}\", ty);\n                         // find a type parameter\n                         if let ty::Param(..) = ty.sty {\n@@ -520,7 +521,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                         }\n                         ty\n                     },\n-                    reg_op: |region| {\n+                    lt_op: |region| {\n                         match region {\n                             // ignore static regions\n                             ty::ReStatic => region,\n@@ -564,6 +565,39 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                             }\n                         }\n                     },\n+                    ct_op: |ct| {\n+                        trace!(\"checking const {:?}\", ct);\n+                        // Find a const parameter\n+                        if let ConstValue::Param(..) = ct.val {\n+                            // look it up in the substitution list\n+                            assert_eq!(opaque_defn.substs.len(), generics.params.len());\n+                            for (subst, param) in opaque_defn.substs.iter()\n+                                                                    .zip(&generics.params) {\n+                                if let UnpackedKind::Const(subst) = subst.unpack() {\n+                                    if subst == ct {\n+                                        // found it in the substitution list, replace with the\n+                                        // parameter from the existential type\n+                                        return self.tcx()\n+                                            .global_tcx()\n+                                            .mk_const_param(param.index, param.name, ct.ty);\n+                                    }\n+                                }\n+                            }\n+                            self.tcx()\n+                                .sess\n+                                .struct_span_err(\n+                                    span,\n+                                    &format!(\n+                                        \"const parameter `{}` is part of concrete type but not \\\n+                                            used in parameter list for existential type\",\n+                                        ct,\n+                                    ),\n+                                )\n+                                .emit();\n+                            return self.tcx().consts.err;\n+                        }\n+                        ct\n+                    }\n                 })\n             };\n \n@@ -819,6 +853,21 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         self.infcx.fully_resolve(&r).unwrap_or(self.tcx.lifetimes.re_static)\n     }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        match self.infcx.fully_resolve(&ct) {\n+            Ok(ct) => ct,\n+            Err(_) => {\n+                debug!(\n+                    \"Resolver::fold_const: input const `{:?}` not fully resolvable\",\n+                    ct\n+                );\n+                // FIXME: we'd like to use `self.report_error`, but it doesn't yet\n+                // accept a &'tcx ty::Const.\n+                self.tcx().consts.err\n+            }\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "9c8b5ac58e337529a0b0aa4852a7ddfc57b0858c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -15,7 +15,7 @@\n //! crate as a kind of pass. This should eventually be factored away.\n \n use crate::astconv::{AstConv, Bounds};\n-use crate::constrained_generic_params as ctp;\n+use crate::constrained_generic_params as cgp;\n use crate::check::intrinsic::intrisic_operation_unsafety;\n use crate::lint;\n use crate::middle::lang_items::SizedTraitLangItem;\n@@ -2202,11 +2202,11 @@ fn explicit_predicates_of<'a, 'tcx>(\n     {\n         let self_ty = tcx.type_of(def_id);\n         let trait_ref = tcx.impl_trait_ref(def_id);\n-        ctp::setup_constraining_predicates(\n+        cgp::setup_constraining_predicates(\n             tcx,\n             &mut predicates,\n             trait_ref,\n-            &mut ctp::parameters_for_impl(self_ty, trait_ref),\n+            &mut cgp::parameters_for_impl(self_ty, trait_ref),\n         );\n     }\n "}, {"sha": "e7ec5bc81c7695661c1dc046168adfd1773abdec", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -8,7 +8,7 @@\n //! specialization errors. These things can (and probably should) be\n //! fixed, but for the moment it's easier to do these checks early.\n \n-use crate::constrained_generic_params as ctp;\n+use crate::constrained_generic_params as cgp;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::def_id::DefId;\n@@ -102,8 +102,8 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let impl_predicates = tcx.predicates_of(impl_def_id);\n     let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n-    let mut input_parameters = ctp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n-    ctp::identify_constrained_generic_params(\n+    let mut input_parameters = cgp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n+    cgp::identify_constrained_generic_params(\n         tcx, &impl_predicates, impl_trait_ref, &mut input_parameters);\n \n     // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n@@ -114,23 +114,23 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             item.kind == ty::AssociatedKind::Type && item.defaultness.has_value()\n         })\n         .flat_map(|def_id| {\n-            ctp::parameters_for(&tcx.type_of(def_id), true)\n+            cgp::parameters_for(&tcx.type_of(def_id), true)\n         }).collect();\n \n     for param in &impl_generics.params {\n         match param.kind {\n             // Disallow ANY unconstrained type parameters.\n             ty::GenericParamDefKind::Type { .. } => {\n                 let param_ty = ty::ParamTy::for_def(param);\n-                if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n+                if !input_parameters.contains(&cgp::Parameter::from(param_ty)) {\n                     report_unused_parameter(tcx,\n                                             tcx.def_span(param.def_id),\n                                             \"type\",\n                                             &param_ty.to_string());\n                 }\n             }\n             ty::GenericParamDefKind::Lifetime => {\n-                let param_lt = ctp::Parameter::from(param.to_early_bound_region_data());\n+                let param_lt = cgp::Parameter::from(param.to_early_bound_region_data());\n                 if lifetimes_in_associated_types.contains(&param_lt) && // (*)\n                     !input_parameters.contains(&param_lt) {\n                     report_unused_parameter(tcx,\n@@ -141,7 +141,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n             ty::GenericParamDefKind::Const => {\n                 let param_ct = ty::ParamConst::for_def(param);\n-                if !input_parameters.contains(&ctp::Parameter::from(param_ct)) {\n+                if !input_parameters.contains(&cgp::Parameter::from(param_ct)) {\n                     report_unused_parameter(tcx,\n                                            tcx.def_span(param.def_id),\n                                            \"const\","}, {"sha": "e1061c6d1a33d7a122951e24814f543cc2c36c5d", "filename": "src/test/ui/const-generics/cannot-infer-const-args.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -0,0 +1,10 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn foo<const X: usize>() -> usize {\n+    0\n+}\n+\n+fn main() {\n+    foo(); //~ ERROR type annotations needed\n+}"}, {"sha": "5528c2fca6a3ba43e3ddba53fc864af54b789953", "filename": "src/test/ui/const-generics/cannot-infer-const-args.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-const-args.stderr?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -0,0 +1,15 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/cannot-infer-const-args.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/cannot-infer-const-args.rs:9:5\n+   |\n+LL |     foo();\n+   |     ^^^ cannot infer type for `fn() -> usize {foo::<_>}`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "3f86782838ca17eb1f5c755a347b0309d63e2645", "filename": "src/test/ui/const-generics/const-arg-in-fn.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-fn.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -0,0 +1,13 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn const_u32_identity<const X: u32>() -> u32 {\n+    X\n+}\n+\n+ fn main() {\n+    let val = const_u32_identity::<18>();\n+    assert_eq!(val, 18);\n+}"}, {"sha": "e32b714b25d3635b9aae94b176b6aafad9be2ba2", "filename": "src/test/ui/const-generics/const-arg-in-fn.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-fn.stderr?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/const-arg-in-fn.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "11757cd588dabad9e3761376b540babe80d40567", "filename": "src/test/ui/const-generics/const-types.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-types.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+#[allow(dead_code)]\n+\n+struct ConstArray<T, const LEN: usize> {\n+    array: [T; LEN],\n+}\n+\n+fn main() {\n+    let arr = ConstArray::<i32, 8> {\n+        array: [0; 8],\n+    };\n+}"}, {"sha": "fbf5d537541643d8f27e114f1e6c5f5f3e9dab13", "filename": "src/test/ui/const-generics/const-types.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-types.stderr?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/const-types.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "7059e9d8348e3c5f4ba57ed75bb817f45178eea1", "filename": "src/test/ui/const-generics/incorrect-number-of-const-args.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fincorrect-number-of-const-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fincorrect-number-of-const-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fincorrect-number-of-const-args.rs?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -0,0 +1,11 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn foo<const X: usize, const Y: usize>() -> usize {\n+    0\n+}\n+\n+fn main() {\n+    foo::<0>(); //~ ERROR wrong number of const arguments: expected 2, found 1\n+    foo::<0, 0, 0>(); //~ ERROR wrong number of const arguments: expected 2, found 3\n+}"}, {"sha": "11727733eb533e9a37b4fc5350c286eb394ebd80", "filename": "src/test/ui/const-generics/incorrect-number-of-const-args.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fincorrect-number-of-const-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf/src%2Ftest%2Fui%2Fconst-generics%2Fincorrect-number-of-const-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fincorrect-number-of-const-args.stderr?ref=92b5e20ad59b183a2e6cd79423f54b8aa7ac9cbf", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/incorrect-number-of-const-args.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+\n+error[E0107]: wrong number of const arguments: expected 2, found 1\n+  --> $DIR/incorrect-number-of-const-args.rs:9:5\n+   |\n+LL |     foo::<0>();\n+   |     ^^^^^^^^ expected 2 const arguments\n+\n+error[E0107]: wrong number of const arguments: expected 2, found 3\n+  --> $DIR/incorrect-number-of-const-args.rs:10:17\n+   |\n+LL |     foo::<0, 0, 0>();\n+   |                 ^ unexpected const argument\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0107`."}]}