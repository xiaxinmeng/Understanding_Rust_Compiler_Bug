{"sha": "3248bc5bd0384712e70f67eb90daa38ae5e5a21f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNDhiYzViZDAzODQ3MTJlNzBmNjdlYjkwZGFhMzhhZTVlNWEyMWY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2014-12-09T09:44:01Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-01-08T08:07:50Z"}, "message": "librustc::session : Make cgoptions macro more generic", "tree": {"sha": "e53d5e7b21073978577797346b9f4162dabd6f3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e53d5e7b21073978577797346b9f4162dabd6f3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3248bc5bd0384712e70f67eb90daa38ae5e5a21f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3248bc5bd0384712e70f67eb90daa38ae5e5a21f", "html_url": "https://github.com/rust-lang/rust/commit/3248bc5bd0384712e70f67eb90daa38ae5e5a21f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3248bc5bd0384712e70f67eb90daa38ae5e5a21f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b3cd3900ceda838f5798c30ab96ceb41f962534", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b3cd3900ceda838f5798c30ab96ceb41f962534", "html_url": "https://github.com/rust-lang/rust/commit/5b3cd3900ceda838f5798c30ab96ceb41f962534"}], "stats": {"total": 115, "additions": 60, "deletions": 55}, "files": [{"sha": "a108982f031247f272b608a41def4c25d5a04bb3", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 60, "deletions": 55, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3248bc5bd0384712e70f67eb90daa38ae5e5a21f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3248bc5bd0384712e70f67eb90daa38ae5e5a21f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3248bc5bd0384712e70f67eb90daa38ae5e5a21f", "patch": "@@ -370,7 +370,7 @@ impl Passes {\n     }\n }\n \n-/// Declare a macro that will define all CodegenOptions fields and parsers all\n+/// Declare a macro that will define all CodegenOptions/DebuggingOptions fields and parsers all\n /// at once. The goal of this macro is to define an interface that can be\n /// programmatically used by the option parser in order to initialize the struct\n /// without hardcoding field names all over the place.\n@@ -380,23 +380,67 @@ impl Passes {\n /// cgsetters module which is a bunch of generated code to parse an option into\n /// its respective field in the struct. There are a few hand-written parsers for\n /// parsing specific types of values in this module.\n-macro_rules! cgoptions {\n-    ($($opt:ident : $t:ty = ($init:expr, $parse:ident, $desc:expr)),* ,) =>\n+macro_rules! options {\n+    ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n+     $buildfn:ident, $prefix:expr, $outputname:expr,\n+     $stat:ident, $mod_desc:ident, $mod_set:ident,\n+     $($opt:ident : $t:ty = ($init:expr, $parse:ident, $desc:expr)),* ,) =>\n (\n     #[derive(Clone)]\n-    pub struct CodegenOptions { $(pub $opt: $t),* }\n+    pub struct $struct_name { $(pub $opt: $t),* }\n \n-    pub fn basic_codegen_options() -> CodegenOptions {\n-        CodegenOptions { $($opt: $init),* }\n+    pub fn $defaultfn() -> $struct_name {\n+        $struct_name { $($opt: $init),* }\n     }\n \n-    pub type CodegenSetter = fn(&mut CodegenOptions, v: Option<&str>) -> bool;\n-    pub const CG_OPTIONS: &'static [(&'static str, CodegenSetter,\n+    pub fn $buildfn(matches: &getopts::Matches) -> $struct_name\n+    {\n+        let mut op = $defaultfn();\n+        for option in matches.opt_strs($prefix).into_iter() {\n+            let mut iter = option.splitn(1, '=');\n+            let key = iter.next().unwrap();\n+            let value = iter.next();\n+            let option_to_lookup = key.replace(\"-\", \"_\");\n+            let mut found = false;\n+            for &(candidate, setter, opt_type_desc, _) in $stat.iter() {\n+                if option_to_lookup != candidate { continue }\n+                if !setter(&mut op, value) {\n+                    match (value, opt_type_desc) {\n+                        (Some(..), None) => {\n+                            early_error(format!(\"{} option `{}` takes no \\\n+                                                 value\", $outputname, key)[])\n+                        }\n+                        (None, Some(type_desc)) => {\n+                            early_error(format!(\"{0} option `{1}` requires \\\n+                                                 {2} ({3} {1}=<value>)\",\n+                                                $outputname, key, type_desc, $prefix)[])\n+                        }\n+                        (Some(value), Some(type_desc)) => {\n+                            early_error(format!(\"incorrect value `{}` for {} \\\n+                                                 option `{}` - {} was expected\",\n+                                                 value, $outputname, key, type_desc)[])\n+                        }\n+                        (None, None) => unreachable!()\n+                    }\n+                }\n+                found = true;\n+                break;\n+            }\n+            if !found {\n+                early_error(format!(\"unknown codegen option: `{}`\",\n+                                    key)[]);\n+            }\n+        }\n+        return op;\n+    }\n+\n+    pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n+    pub const $stat: &'static [(&'static str, $setter_name,\n                                      Option<&'static str>, &'static str)] =\n-        &[ $( (stringify!($opt), cgsetters::$opt, cg_type_descs::$parse, $desc) ),* ];\n+        &[ $( (stringify!($opt), $mod_set::$opt, $mod_desc::$parse, $desc) ),* ];\n \n     #[allow(non_upper_case_globals)]\n-    mod cg_type_descs {\n+    mod $mod_desc {\n         pub const parse_bool: Option<&'static str> = None;\n         pub const parse_opt_bool: Option<&'static str> = None;\n         pub const parse_string: Option<&'static str> = Some(\"a string\");\n@@ -410,11 +454,11 @@ macro_rules! cgoptions {\n             Some(\"a number\");\n     }\n \n-    mod cgsetters {\n-        use super::{CodegenOptions, Passes, SomePasses, AllPasses};\n+    mod $mod_set {\n+        use super::{$struct_name, Passes, SomePasses, AllPasses};\n \n         $(\n-            pub fn $opt(cg: &mut CodegenOptions, v: Option<&str>) -> bool {\n+            pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n                 $parse(&mut cg.$opt, v)\n             }\n         )*\n@@ -506,7 +550,9 @@ macro_rules! cgoptions {\n     }\n ) }\n \n-cgoptions! {\n+options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n+         build_codegen_options, \"C\", \"codegen\",\n+         CG_OPTIONS, cg_type_desc, cgsetters,\n     ar: Option<String> = (None, parse_opt_string,\n         \"tool to assemble archives with\"),\n     linker: Option<String> = (None, parse_opt_string,\n@@ -562,47 +608,6 @@ cgoptions! {\n         \"Optimize with possible levels 0-3\"),\n }\n \n-pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n-{\n-    let mut cg = basic_codegen_options();\n-    for option in matches.opt_strs(\"C\").into_iter() {\n-        let mut iter = option.splitn(1, '=');\n-        let key = iter.next().unwrap();\n-        let value = iter.next();\n-        let option_to_lookup = key.replace(\"-\", \"_\");\n-        let mut found = false;\n-        for &(candidate, setter, opt_type_desc, _) in CG_OPTIONS.iter() {\n-            if option_to_lookup != candidate { continue }\n-            if !setter(&mut cg, value) {\n-                match (value, opt_type_desc) {\n-                    (Some(..), None) => {\n-                        early_error(&format!(\"codegen option `{}` takes no \\\n-                                             value\", key)[])\n-                    }\n-                    (None, Some(type_desc)) => {\n-                        early_error(&format!(\"codegen option `{0}` requires \\\n-                                             {1} (-C {0}=<value>)\",\n-                                            key, type_desc)[])\n-                    }\n-                    (Some(value), Some(type_desc)) => {\n-                        early_error(&format!(\"incorrect value `{}` for codegen \\\n-                                             option `{}` - {} was expected\",\n-                                             value, key, type_desc)[])\n-                    }\n-                    (None, None) => unreachable!()\n-                }\n-            }\n-            found = true;\n-            break;\n-        }\n-        if !found {\n-            early_error(&format!(\"unknown codegen option: `{}`\",\n-                                key)[]);\n-        }\n-    }\n-    return cg;\n-}\n-\n pub fn default_lib_output() -> CrateType {\n     CrateTypeRlib\n }"}]}