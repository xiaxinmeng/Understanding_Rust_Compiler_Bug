{"sha": "b8dc2a7c768eb288b0984a4429a793df6a1213de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZGMyYTdjNzY4ZWIyODhiMDk4NGE0NDI5YTc5M2RmNmExMjEzZGU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-30T19:48:46Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-01T23:49:12Z"}, "message": "Remove the lowering context's id caching system", "tree": {"sha": "594cc3249980b88c0d6600516aa3398f6f4637d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/594cc3249980b88c0d6600516aa3398f6f4637d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8dc2a7c768eb288b0984a4429a793df6a1213de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8dc2a7c768eb288b0984a4429a793df6a1213de", "html_url": "https://github.com/rust-lang/rust/commit/b8dc2a7c768eb288b0984a4429a793df6a1213de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8dc2a7c768eb288b0984a4429a793df6a1213de/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca88c44a9092c22ce39797e9b19ed6f7bb179ada", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca88c44a9092c22ce39797e9b19ed6f7bb179ada", "html_url": "https://github.com/rust-lang/rust/commit/ca88c44a9092c22ce39797e9b19ed6f7bb179ada"}], "stats": {"total": 158, "additions": 27, "deletions": 131}, "files": [{"sha": "90a5eee1f160d188dd549dd16266889e0d8ce69a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 27, "deletions": 131, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/b8dc2a7c768eb288b0984a4429a793df6a1213de/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8dc2a7c768eb288b0984a4429a793df6a1213de/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b8dc2a7c768eb288b0984a4429a793df6a1213de", "patch": "@@ -29,21 +29,6 @@\n // are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n // If you do, you must then set the new node's id to a fresh one.\n //\n-// Lowering must be reproducable (the compiler only lowers once, but tools and\n-// custom lints may lower an AST node to a HIR node to interact with the\n-// compiler). The most interesting bit of this is ids - if you lower an AST node\n-// and create new HIR nodes with fresh ids, when re-lowering the same node, you\n-// must ensure you get the same ids! To do this, we keep track of the next id\n-// when we translate a node which requires new ids. By checking this cache and\n-// using node ids starting with the cached id, we ensure ids are reproducible.\n-// To use this system, you just need to hold on to a CachedIdSetter object\n-// whilst lowering. This is an RAII object that takes care of setting and\n-// restoring the cached id, etc.\n-//\n-// This whole system relies on node ids being incremented one at a time and\n-// all increments being for lowering. This means that you should not call any\n-// non-lowering function which will use new node ids.\n-//\n // We must also cache gensym'ed Idents to ensure that we get the same Ident\n // every time we lower a node with gensym'ed names. One consequence of this is\n // that you can only gensym a name once in a lowering (you don't need to worry\n@@ -67,7 +52,6 @@ use hir::map::definitions::DefPathData;\n use hir::def_id::DefIndex;\n \n use std::collections::BTreeMap;\n-use std::collections::HashMap;\n use std::iter;\n use syntax::ast::*;\n use syntax::attr::{ThinAttributes, ThinAttributesExt};\n@@ -83,18 +67,8 @@ use std::cell::{Cell, RefCell};\n \n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n-    // Map AST ids to ids used for expanded nodes.\n-    id_cache: RefCell<HashMap<NodeId, NodeId>>,\n-    // Use if there are no cached ids for the current node.\n+    // Use to assign ids to hir nodes that do not directly correspond to an ast node\n     id_assigner: &'a NodeIdAssigner,\n-    // 0 == no cached id. Must be incremented to align with previous id\n-    // incrementing.\n-    cached_id: Cell<u32>,\n-    // Keep track of gensym'ed idents.\n-    gensym_cache: RefCell<HashMap<(NodeId, &'static str), hir::Ident>>,\n-    // A copy of cached_id, but is also set to an id while a node is lowered for\n-    // the first time.\n-    gensym_key: Cell<u32>,\n     // We must keep the set of definitions up to date as we add nodes that\n     // weren't in the AST.\n     definitions: Option<&'a RefCell<Definitions>>,\n@@ -121,11 +95,7 @@ impl<'a, 'hir> LoweringContext<'a> {\n \n         LoweringContext {\n             crate_root: crate_root,\n-            id_cache: RefCell::new(HashMap::new()),\n             id_assigner: id_assigner,\n-            cached_id: Cell::new(0),\n-            gensym_cache: RefCell::new(HashMap::new()),\n-            gensym_key: Cell::new(0),\n             definitions: Some(defs),\n             parent_def: Cell::new(None),\n         }\n@@ -136,40 +106,18 @@ impl<'a, 'hir> LoweringContext<'a> {\n     pub fn testing_context(id_assigner: &'a NodeIdAssigner) -> LoweringContext<'a> {\n         LoweringContext {\n             crate_root: None,\n-            id_cache: RefCell::new(HashMap::new()),\n             id_assigner: id_assigner,\n-            cached_id: Cell::new(0),\n-            gensym_cache: RefCell::new(HashMap::new()),\n-            gensym_key: Cell::new(0),\n             definitions: None,\n             parent_def: Cell::new(None),\n         }\n     }\n \n     fn next_id(&self) -> NodeId {\n-        let cached_id = self.cached_id.get();\n-        if cached_id == 0 {\n-            return self.id_assigner.next_node_id();\n-        }\n-\n-        self.cached_id.set(cached_id + 1);\n-        cached_id\n+        self.id_assigner.next_node_id()\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> hir::Ident {\n-        let gensym_key = self.gensym_key.get();\n-        if gensym_key == 0 {\n-            return hir::Ident::from_name(token::gensym(s));\n-        }\n-\n-        let cached = self.gensym_cache.borrow().contains_key(&(gensym_key, s));\n-        if cached {\n-            self.gensym_cache.borrow()[&(gensym_key, s)]\n-        } else {\n-            let result = hir::Ident::from_name(token::gensym(s));\n-            self.gensym_cache.borrow_mut().insert((gensym_key, s), result);\n-            result\n-        }\n+        hir::Ident::from_name(token::gensym(s))\n     }\n \n     // Panics if this LoweringContext's NodeIdAssigner is not able to emit diagnostics.\n@@ -197,56 +145,6 @@ impl<'a, 'hir> LoweringContext<'a> {\n     }\n }\n \n-// Utility fn for setting and unsetting the cached id.\n-fn cache_ids<'a, OP, R>(lctx: &LoweringContext, expr_id: NodeId, op: OP) -> R\n-    where OP: FnOnce(&LoweringContext) -> R\n-{\n-    // Only reset the id if it was previously 0, i.e., was not cached.\n-    // If it was cached, we are in a nested node, but our id count will\n-    // still count towards the parent's count.\n-    let reset_cached_id = lctx.cached_id.get() == 0;\n-    // We always reset gensym_key so that if we use the same name in a nested\n-    // node and after that node, they get different values.\n-    let old_gensym_key = lctx.gensym_key.get();\n-\n-    {\n-        let id_cache: &mut HashMap<_, _> = &mut lctx.id_cache.borrow_mut();\n-\n-        if id_cache.contains_key(&expr_id) {\n-            panic!(\"relowering!!!\");\n-            /*\n-            let cached_id = lctx.cached_id.get();\n-            if cached_id == 0 {\n-                // We're entering a node where we need to track ids, but are not\n-                // yet tracking.\n-                lctx.cached_id.set(id_cache[&expr_id]);\n-            } else {\n-                // We're already tracking - check that the tracked id is the same\n-                // as the expected id.\n-                assert!(cached_id == id_cache[&expr_id], \"id mismatch\");\n-            }\n-            lctx.gensym_key.set(id_cache[&expr_id]);\n-            */\n-        } else {\n-            // We've never lowered this node before, remember it for next time.\n-            let next_id = lctx.id_assigner.peek_node_id();\n-            id_cache.insert(expr_id, next_id);\n-            lctx.gensym_key.set(next_id);\n-            // self.cached_id is not set when we lower a node for the first time,\n-            // only on re-lowering.\n-        }\n-    }\n-\n-    let result = op(lctx);\n-\n-    if reset_cached_id {\n-        lctx.cached_id.set(0);\n-    }\n-    lctx.gensym_key.set(old_gensym_key);\n-\n-    result\n-}\n-\n pub fn lower_ident(_lctx: &LoweringContext, ident: Ident) -> hir::Ident {\n     hir::Ident {\n         name: mtwt::resolve(ident),\n@@ -1080,7 +978,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                 //     InPlace::finalize(place)\n                 // })\n-                return cache_ids(lctx, e.id, |lctx| {\n+                return {\n                     let placer_expr = lower_expr(lctx, placer);\n                     let value_expr = lower_expr(lctx, value_expr);\n \n@@ -1175,7 +1073,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                       e.span,\n                                       hir::PushUnstableBlock,\n                                       e.attrs.clone())\n-                });\n+                }\n             }\n \n             ExprKind::Vec(ref exprs) => {\n@@ -1229,20 +1127,18 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let else_opt = else_opt.as_ref().map(|els| {\n                     match els.node {\n                         ExprKind::IfLet(..) => {\n-                            cache_ids(lctx, e.id, |lctx| {\n-                                // wrap the if-let expr in a block\n-                                let span = els.span;\n-                                let els = lower_expr(lctx, els);\n-                                let id = lctx.next_id();\n-                                let blk = P(hir::Block {\n-                                    stmts: hir_vec![],\n-                                    expr: Some(els),\n-                                    id: id,\n-                                    rules: hir::DefaultBlock,\n-                                    span: span,\n-                                });\n-                                expr_block(lctx, blk, None)\n-                            })\n+                            // wrap the if-let expr in a block\n+                            let span = els.span;\n+                            let els = lower_expr(lctx, els);\n+                            let id = lctx.next_id();\n+                            let blk = P(hir::Block {\n+                                stmts: hir_vec![],\n+                                expr: Some(els),\n+                                id: id,\n+                                rules: hir::DefaultBlock,\n+                                span: span,\n+                            });\n+                            expr_block(lctx, blk, None)\n                         }\n                         _ => lower_expr(lctx, els),\n                     }\n@@ -1331,7 +1227,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                       None)\n                 }\n \n-                return cache_ids(lctx, e.id, |lctx| {\n+                return {\n                     use syntax::ast::RangeLimits::*;\n \n                     match (e1, e2, lims) {\n@@ -1362,7 +1258,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         _ => panic!(lctx.diagnostic().span_fatal(e.span,\n                                                                  \"inclusive range with no end\"))\n                     }\n-                });\n+                }\n             }\n             ExprKind::Path(ref qself, ref path) => {\n                 let hir_qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n@@ -1436,7 +1332,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     _ => [<else_opt> | ()]\n                 //   }\n \n-                return cache_ids(lctx, e.id, |lctx| {\n+                return {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n@@ -1510,7 +1406,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                             contains_else_clause: contains_else_clause,\n                                         }),\n                          e.attrs.clone())\n-                });\n+                }\n             }\n \n             // Desugar ExprWhileLet\n@@ -1525,7 +1421,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     }\n                 //   }\n \n-                return cache_ids(lctx, e.id, |lctx| {\n+                return {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n@@ -1556,7 +1452,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                   opt_ident.map(|ident| lower_ident(lctx, ident)));\n                     // add attributes to the outer returned expr node\n                     expr(lctx, e.span, loop_expr, e.attrs.clone())\n-                });\n+                }\n             }\n \n             // Desugar ExprForLoop\n@@ -1578,7 +1474,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     result\n                 //   }\n \n-                return cache_ids(lctx, e.id, |lctx| {\n+                return {\n                     // expand <head>\n                     let head = lower_expr(lctx, head);\n \n@@ -1677,7 +1573,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n                     // add the attributes to the outer returned expr node\n                     expr_block(lctx, block, e.attrs.clone())\n-                });\n+                }\n             }\n \n             // Desugar ExprKind::Try\n@@ -1694,7 +1590,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     }\n                 // }\n \n-                return cache_ids(lctx, e.id, |lctx| {\n+                return {\n                     // expand <expr>\n                     let sub_expr = lower_expr(lctx, sub_expr);\n \n@@ -1735,7 +1631,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                     expr_match(lctx, e.span, sub_expr, hir_vec![err_arm, ok_arm],\n                                hir::MatchSource::TryDesugar, None)\n-                })\n+                }\n             }\n \n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),"}]}