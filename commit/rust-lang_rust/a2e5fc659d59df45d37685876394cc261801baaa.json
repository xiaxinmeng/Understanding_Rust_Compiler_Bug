{"sha": "a2e5fc659d59df45d37685876394cc261801baaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZTVmYzY1OWQ1OWRmNDVkMzc2ODU4NzYzOTRjYzI2MTgwMWJhYWE=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-08T13:56:26Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-08T14:26:25Z"}, "message": "Improve naming and add comments", "tree": {"sha": "7112736cc9e2ba4ce32d5faec7c5c3642afda78c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7112736cc9e2ba4ce32d5faec7c5c3642afda78c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2e5fc659d59df45d37685876394cc261801baaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e5fc659d59df45d37685876394cc261801baaa", "html_url": "https://github.com/rust-lang/rust/commit/a2e5fc659d59df45d37685876394cc261801baaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2e5fc659d59df45d37685876394cc261801baaa/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "720508a2df928f4973e6ef594652be22aebcdfcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/720508a2df928f4973e6ef594652be22aebcdfcb", "html_url": "https://github.com/rust-lang/rust/commit/720508a2df928f4973e6ef594652be22aebcdfcb"}], "stats": {"total": 42, "additions": 23, "deletions": 19}, "files": [{"sha": "71d5331e280d5e0642f88724f26e5ec7d847dbeb", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a2e5fc659d59df45d37685876394cc261801baaa/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2e5fc659d59df45d37685876394cc261801baaa/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=a2e5fc659d59df45d37685876394cc261801baaa", "patch": "@@ -129,9 +129,6 @@ fn add_assist(\n                     let mut cursor = Cursor::Before(first_assoc_item.syntax());\n                     let placeholder;\n                     if let ast::AssocItem::Fn(ref func) = first_assoc_item {\n-                        // need to know what kind of derive this is: if it's Derive Debug, special case it.\n-                        // the name of the struct\n-                        // list of fields of the struct\n                         if let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast)\n                         {\n                             if m.syntax().text() == \"todo!()\" {\n@@ -170,10 +167,12 @@ fn impl_def_from_trait(\n     let (impl_def, first_assoc_item) =\n         add_trait_assoc_items_to_impl(sema, trait_items, trait_, impl_def, target_scope);\n \n+    // Generate a default `impl` function body for the derived trait.\n     if let ast::AssocItem::Fn(func) = &first_assoc_item {\n-        if trait_path.segment().unwrap().name_ref().unwrap().text() == \"Debug\" {\n-            gen_debug_impl(adt, func, annotated_name);\n-        }\n+        match trait_path.segment().unwrap().name_ref().unwrap().text().as_str() {\n+            \"Debug\" => gen_debug_impl(adt, func, annotated_name),\n+            _ => {} // => If we don't know about the trait, the function body is left as `todo!`.\n+        };\n     }\n     Some((impl_def, first_assoc_item))\n }\n@@ -183,31 +182,31 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) {\n     match adt {\n         ast::Adt::Union(_) => {} // `Debug` cannot be derived for unions, so no default impl can be provided.\n         ast::Adt::Enum(enum_) => {\n+            // => match self { Self::Variant => write!(f, \"Variant\") }\n             if let Some(list) = enum_.variant_list() {\n                 let mut arms = vec![];\n                 for variant in list.variants() {\n-                    // => Self::<Variant>\n                     let name = variant.name().unwrap();\n-                    let first = make::ext::ident_path(\"Self\");\n-                    let second = make::ext::ident_path(&format!(\"{}\", name));\n-                    let pat = make::path_pat(make::path_concat(first, second));\n \n-                    // => write!(f, \"<Variant>\")\n+                    let left = make::ext::ident_path(\"Self\");\n+                    let right = make::ext::ident_path(&format!(\"{}\", name));\n+                    let variant_name = make::path_pat(make::path_concat(left, right));\n+\n                     let target = make::expr_path(make::ext::ident_path(\"f\").into());\n                     let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n                     let args = make::arg_list(vec![target, fmt_string]);\n-                    let target = make::expr_path(make::ext::ident_path(\"write\"));\n-                    let expr = make::expr_macro_call(target, args);\n+                    let macro_name = make::expr_path(make::ext::ident_path(\"write\"));\n+                    let macro_call = make::expr_macro_call(macro_name, args);\n \n-                    arms.push(make::match_arm(Some(pat.into()), None, expr.into()));\n+                    arms.push(make::match_arm(Some(variant_name.into()), None, macro_call.into()));\n                 }\n \n-                // => match self { ... }\n-                let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n+                let match_target = make::expr_path(make::ext::ident_path(\"self\"));\n                 let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n-                let expr = make::expr_match(f_path, list);\n+                let match_expr = make::expr_match(match_target, list);\n \n-                let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n+                let body = make::block_expr(None, Some(match_expr));\n+                let body = body.indent(ast::edit::IndentLevel(1));\n                 ted::replace(func.body().unwrap().syntax(), body.clone_for_update().syntax());\n             }\n         }\n@@ -217,8 +216,12 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) {\n             let target = make::expr_path(make::ext::ident_path(\"f\"));\n \n             let expr = match strukt.field_list() {\n-                None => make::expr_method_call(target, \"debug_struct\", args),\n+                None => {\n+                    // => f.debug_struct(\"Name\").finish()\n+                    make::expr_method_call(target, \"debug_struct\", args)\n+                }\n                 Some(ast::FieldList::RecordFieldList(field_list)) => {\n+                    // => f.debug_struct(\"Name\").field(\"foo\", &self.foo).finish()\n                     let mut expr = make::expr_method_call(target, \"debug_struct\", args);\n                     for field in field_list.fields() {\n                         if let Some(name) = field.name() {\n@@ -233,6 +236,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) {\n                     expr\n                 }\n                 Some(ast::FieldList::TupleFieldList(field_list)) => {\n+                    // => f.debug_tuple(\"Name\").field(self.0).finish()\n                     let mut expr = make::expr_method_call(target, \"debug_tuple\", args);\n                     for (idx, _) in field_list.fields().enumerate() {\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));"}]}