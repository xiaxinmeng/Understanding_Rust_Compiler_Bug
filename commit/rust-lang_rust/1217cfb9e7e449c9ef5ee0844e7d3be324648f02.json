{"sha": "1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMTdjZmI5ZTdlNDQ5YzllZjVlZTA4NDRlN2QzYmUzMjQ2NDhmMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-01T20:26:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-01T20:26:49Z"}, "message": "auto merge of #13225 : thestinger/rust/num, r=cmr\n\nThe `Float` trait methods will be usable as functions via UFCS, and\r\nwe came to a consensus to remove duplicate functions like this a long\r\ntime ago.\r\n\r\nIt does still make sense to keep the duplicate functions when the trait\r\nmethods are static, unless the decision to leave out the in-scope trait\r\nname resolution for static methods changes.", "tree": {"sha": "ce831ee4530348b32b5ccbb6c0dfa1d15df3279e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce831ee4530348b32b5ccbb6c0dfa1d15df3279e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "html_url": "https://github.com/rust-lang/rust/commit/1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "html_url": "https://github.com/rust-lang/rust/commit/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6"}, {"sha": "5e12e1b1a49134f578e1778f4a1216221417bc5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e12e1b1a49134f578e1778f4a1216221417bc5e", "html_url": "https://github.com/rust-lang/rust/commit/5e12e1b1a49134f578e1778f4a1216221417bc5e"}], "stats": {"total": 429, "additions": 136, "deletions": 293}, "files": [{"sha": "76e3b521957d79c2a05c0e3ac1991749c8b75ca7", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "patch": "@@ -332,8 +332,6 @@ sense, they're simple: just keep whatever ownership the data already has. For\n example:\n \n ~~~rust\n-use std::num::sqrt;\n-\n struct Point {\n     x: f32,\n     y: f32,\n@@ -343,7 +341,7 @@ fn compute_distance(p1: &Point, p2: &Point) -> f32 {\n     let x_d = p1.x - p2.x;\n     let y_d = p1.y - p2.y;\n \n-    sqrt(x_d * x_d + y_d * y_d)\n+    (x_d * x_d + y_d * y_d).sqrt()\n }\n \n fn main() {"}, {"sha": "9e211dda2fb409f6c2e5ea9f619adf580eb02936", "filename": "src/doc/rust.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "patch": "@@ -826,14 +826,14 @@ Use declarations support a number of convenient shortcuts:\n An example of `use` declarations:\n \n ~~~~\n-use std::num::sin;\n+use std::iter::range_step;\n use std::option::{Some, None};\n \n # fn foo<T>(_: T){}\n \n fn main() {\n-    // Equivalent to 'std::num::sin(1.0);'\n-    sin(1.0);\n+    // Equivalent to 'std::iter::range_step(0, 10, 2);'\n+    range_step(0, 10, 2);\n \n     // Equivalent to 'foo(~[std::option::Some(1.0), std::option::None]);'\n     foo(~[Some(1.0), None]);"}, {"sha": "62e0fabdc053058d87a33df848c9f8894f2dbe78", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "patch": "@@ -504,13 +504,12 @@ matching in order to bind names to the contents of data types.\n \n ~~~~\n use std::f64;\n-use std::num::atan;\n fn angle(vector: (f64, f64)) -> f64 {\n     let pi = f64::consts::PI;\n     match vector {\n       (0.0, y) if y < 0.0 => 1.5 * pi,\n       (0.0, _) => 0.5 * pi,\n-      (x, y) => atan(y / x)\n+      (x, y) => (y / x).atan()\n     }\n }\n ~~~~\n@@ -1430,12 +1429,11 @@ bad, but often copies are expensive. So we\u2019d like to define a function\n that takes the points by pointer. We can use references to do this:\n \n ~~~\n-use std::num::sqrt;\n # struct Point { x: f64, y: f64 }\n fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n     let x_d = p1.x - p2.x;\n     let y_d = p1.y - p2.y;\n-    sqrt(x_d * x_d + y_d * y_d)\n+    (x_d * x_d + y_d * y_d).sqrt()\n }\n ~~~\n \n@@ -2303,7 +2301,7 @@ impl Shape for Circle {\n     fn new(area: f64) -> Circle { Circle { radius: (area / PI).sqrt() } }\n }\n impl Shape for Square {\n-    fn new(area: f64) -> Square { Square { length: (area).sqrt() } }\n+    fn new(area: f64) -> Square { Square { length: area.sqrt() } }\n }\n \n let area = 42.5;"}, {"sha": "575e621cc66ab1c00f1ba43b75231f9c3feb8310", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "patch": "@@ -11,7 +11,6 @@\n //! The Gamma and derived distributions.\n \n use std::num::Float;\n-use std::num;\n use {Rng, Open01};\n use super::normal::StandardNormal;\n use super::{IndependentSample, Sample, Exp};\n@@ -114,7 +113,7 @@ impl GammaLargeShape {\n         GammaLargeShape {\n             shape: shape,\n             scale: scale,\n-            c: 1. / num::sqrt(9. * d),\n+            c: 1. / (9. * d).sqrt(),\n             d: d\n         }\n     }\n@@ -143,7 +142,7 @@ impl IndependentSample<f64> for GammaSmallShape {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n         let Open01(u) = rng.gen::<Open01<f64>>();\n \n-        self.large_shape.ind_sample(rng) * num::powf(u, self.inv_shape)\n+        self.large_shape.ind_sample(rng) * u.powf(&self.inv_shape)\n     }\n }\n impl IndependentSample<f64> for GammaLargeShape {\n@@ -160,7 +159,7 @@ impl IndependentSample<f64> for GammaLargeShape {\n \n             let x_sqr = x * x;\n             if u < 1.0 - 0.0331 * x_sqr * x_sqr ||\n-                num::ln(u) < 0.5 * x_sqr + self.d * (1.0 - v + num::ln(v)) {\n+                u.ln() < 0.5 * x_sqr + self.d * (1.0 - v + v.ln()) {\n                 return self.d * v * self.scale\n             }\n         }"}, {"sha": "fb6c1b4c8a3a8776f990d93e21e8b8cc4157b5e2", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "patch": "@@ -206,8 +206,6 @@ pub mod raw;\n /* For internal use, not exported */\n \n mod unicode;\n-#[path = \"num/cmath.rs\"]\n-mod cmath;\n \n // FIXME #7809: This shouldn't be pub, and it should be reexported under 'unstable'\n // but name resolution doesn't work without it being pub."}, {"sha": "32864f14c9631fb9daa0dfbb3ac72c5b3c72ab96", "filename": "src/libstd/num/cmath.rs", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6/src%2Flibstd%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcmath.rs?ref=b71c02e512fcfe18ea7a5a8a99ac758b4fa564a6", "patch": "@@ -1,151 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(missing_doc)]\n-#![allow(dead_code)]\n-\n-//! Bindings for the C math library (for basic mathematic functions)\n-\n-// Function names are almost identical to C's libmath, a few have been\n-// renamed, grep for \"rename:\"\n-\n-pub mod c_double {\n-    use libc::{c_double, c_int};\n-\n-    #[link_name = \"m\"]\n-    extern {\n-        // Alphabetically sorted by link_name\n-\n-        pub fn acos(n: c_double) -> c_double;\n-        pub fn asin(n: c_double) -> c_double;\n-        pub fn atan(n: c_double) -> c_double;\n-        pub fn atan2(a: c_double, b: c_double) -> c_double;\n-        pub fn cbrt(n: c_double) -> c_double;\n-        pub fn cosh(n: c_double) -> c_double;\n-        pub fn erf(n: c_double) -> c_double;\n-        pub fn erfc(n: c_double) -> c_double;\n-        // rename: for consistency with underscore usage elsewhere\n-        #[link_name=\"expm1\"]\n-        pub fn exp_m1(n: c_double) -> c_double;\n-        // rename: for clarity and consistency with add/sub/mul/div\n-        #[link_name=\"fdim\"]\n-        pub fn abs_sub(a: c_double, b: c_double) -> c_double;\n-        #[link_name=\"fmax\"]\n-        pub fn fmax(a: c_double, b: c_double) -> c_double;\n-        #[link_name=\"fmin\"]\n-        pub fn fmin(a: c_double, b: c_double) -> c_double;\n-        #[link_name=\"nextafter\"]\n-        pub fn next_after(x: c_double, y: c_double) -> c_double;\n-        pub fn frexp(n: c_double, value: &mut c_int) -> c_double;\n-        pub fn hypot(x: c_double, y: c_double) -> c_double;\n-        pub fn ldexp(x: c_double, n: c_int) -> c_double;\n-        #[cfg(unix)]\n-        #[link_name=\"lgamma_r\"]\n-        pub fn lgamma(n: c_double, sign: &mut c_int) -> c_double;\n-        #[cfg(windows)]\n-        #[link_name=\"__lgamma_r\"]\n-        pub fn lgamma(n: c_double, sign: &mut c_int) -> c_double;\n-        // renamed: \"logb\" /often/ is confused for log2 by beginners\n-        #[link_name=\"logb\"]\n-        pub fn log_radix(n: c_double) -> c_double;\n-        // renamed: to be consitent with log as ln\n-        #[link_name=\"log1p\"]\n-        pub fn ln_1p(n: c_double) -> c_double;\n-        #[link_name=\"ilogb\"]\n-        pub fn ilog_radix(n: c_double) -> c_int;\n-        pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;\n-        // rename: for consistency with logradix\n-        #[link_name=\"scalbn\"]\n-        pub fn ldexp_radix(n: c_double, i: c_int) -> c_double;\n-        pub fn sinh(n: c_double) -> c_double;\n-        pub fn tan(n: c_double) -> c_double;\n-        pub fn tanh(n: c_double) -> c_double;\n-        pub fn tgamma(n: c_double) -> c_double;\n-\n-        // These are commonly only available for doubles\n-\n-        pub fn j0(n: c_double) -> c_double;\n-        pub fn j1(n: c_double) -> c_double;\n-        pub fn jn(i: c_int, n: c_double) -> c_double;\n-\n-        pub fn y0(n: c_double) -> c_double;\n-        pub fn y1(n: c_double) -> c_double;\n-        pub fn yn(i: c_int, n: c_double) -> c_double;\n-    }\n-}\n-\n-pub mod c_float {\n-    use libc::{c_float, c_int};\n-\n-    #[link_name = \"m\"]\n-    extern {\n-        // Alphabetically sorted by link_name\n-\n-        #[link_name=\"acosf\"]\n-        pub fn acos(n: c_float) -> c_float;\n-        #[link_name=\"asinf\"]\n-        pub fn asin(n: c_float) -> c_float;\n-        #[link_name=\"atanf\"]\n-        pub fn atan(n: c_float) -> c_float;\n-        #[link_name=\"atan2f\"]\n-        pub fn atan2(a: c_float, b: c_float) -> c_float;\n-        #[link_name=\"cbrtf\"]\n-        pub fn cbrt(n: c_float) -> c_float;\n-        #[link_name=\"coshf\"]\n-        pub fn cosh(n: c_float) -> c_float;\n-        #[link_name=\"erff\"]\n-        pub fn erf(n: c_float) -> c_float;\n-        #[link_name=\"erfcf\"]\n-        pub fn erfc(n: c_float) -> c_float;\n-        #[link_name=\"expm1f\"]\n-        pub fn exp_m1(n: c_float) -> c_float;\n-        #[link_name=\"fdimf\"]\n-        pub fn abs_sub(a: c_float, b: c_float) -> c_float;\n-        #[link_name=\"frexpf\"]\n-        pub fn frexp(n: c_float, value: &mut c_int) -> c_float;\n-        #[link_name=\"fmaxf\"]\n-        pub fn fmax(a: c_float, b: c_float) -> c_float;\n-        #[link_name=\"fminf\"]\n-        pub fn fmin(a: c_float, b: c_float) -> c_float;\n-        #[link_name=\"nextafterf\"]\n-        pub fn next_after(x: c_float, y: c_float) -> c_float;\n-        #[link_name=\"hypotf\"]\n-        pub fn hypot(x: c_float, y: c_float) -> c_float;\n-        #[link_name=\"ldexpf\"]\n-        pub fn ldexp(x: c_float, n: c_int) -> c_float;\n-\n-        #[cfg(unix)]\n-        #[link_name=\"lgammaf_r\"]\n-        pub fn lgamma(n: c_float, sign: &mut c_int) -> c_float;\n-\n-        #[cfg(windows)]\n-        #[link_name=\"__lgammaf_r\"]\n-        pub fn lgamma(n: c_float, sign: &mut c_int) -> c_float;\n-\n-        #[link_name=\"logbf\"]\n-        pub fn log_radix(n: c_float) -> c_float;\n-        #[link_name=\"log1pf\"]\n-        pub fn ln_1p(n: c_float) -> c_float;\n-        #[link_name=\"ilogbf\"]\n-        pub fn ilog_radix(n: c_float) -> c_int;\n-        #[link_name=\"modff\"]\n-        pub fn modf(n: c_float, iptr: &mut c_float) -> c_float;\n-        #[link_name=\"scalbnf\"]\n-        pub fn ldexp_radix(n: c_float, i: c_int) -> c_float;\n-        #[link_name=\"sinhf\"]\n-        pub fn sinh(n: c_float) -> c_float;\n-        #[link_name=\"tanf\"]\n-        pub fn tan(n: c_float) -> c_float;\n-        #[link_name=\"tanhf\"]\n-        pub fn tanh(n: c_float) -> c_float;\n-        #[link_name=\"tgammaf\"]\n-        pub fn tgamma(n: c_float) -> c_float;\n-    }\n-}"}, {"sha": "6bae0648a57ba0642157702d6c4bcacdb7e3123b", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 58, "deletions": 26, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "patch": "@@ -14,7 +14,6 @@\n \n use prelude::*;\n \n-use cmath;\n use default::Default;\n use from_str::FromStr;\n use libc::{c_float, c_int};\n@@ -23,6 +22,46 @@ use num::{Zero, One, Bounded, strconv};\n use num;\n use intrinsics;\n \n+#[allow(dead_code)]\n+mod cmath {\n+    use libc::{c_float, c_int};\n+\n+    #[link_name = \"m\"]\n+    extern {\n+        pub fn acosf(n: c_float) -> c_float;\n+        pub fn asinf(n: c_float) -> c_float;\n+        pub fn atanf(n: c_float) -> c_float;\n+        pub fn atan2f(a: c_float, b: c_float) -> c_float;\n+        pub fn cbrtf(n: c_float) -> c_float;\n+        pub fn coshf(n: c_float) -> c_float;\n+        pub fn erff(n: c_float) -> c_float;\n+        pub fn erfcf(n: c_float) -> c_float;\n+        pub fn expm1f(n: c_float) -> c_float;\n+        pub fn fdimf(a: c_float, b: c_float) -> c_float;\n+        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;\n+        pub fn fmaxf(a: c_float, b: c_float) -> c_float;\n+        pub fn fminf(a: c_float, b: c_float) -> c_float;\n+        pub fn nextafterf(x: c_float, y: c_float) -> c_float;\n+        pub fn hypotf(x: c_float, y: c_float) -> c_float;\n+        pub fn ldexpf(x: c_float, n: c_int) -> c_float;\n+        pub fn logbf(n: c_float) -> c_float;\n+        pub fn log1pf(n: c_float) -> c_float;\n+        pub fn ilogbf(n: c_float) -> c_int;\n+        pub fn modff(n: c_float, iptr: &mut c_float) -> c_float;\n+        pub fn sinhf(n: c_float) -> c_float;\n+        pub fn tanf(n: c_float) -> c_float;\n+        pub fn tanhf(n: c_float) -> c_float;\n+        pub fn tgammaf(n: c_float) -> c_float;\n+\n+        #[cfg(unix)]\n+        pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;\n+\n+        #[cfg(windows)]\n+        #[link_name=\"__lgammaf_r\"]\n+        pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;\n+    }\n+}\n+\n macro_rules! delegate(\n     (\n         $(\n@@ -66,29 +105,22 @@ delegate!(\n     fn nearbyint(n: f32) -> f32 = intrinsics::nearbyintf32,\n     fn round(n: f32) -> f32 = intrinsics::roundf32,\n \n-    // cmath\n-    fn acos(n: c_float) -> c_float = cmath::c_float::acos,\n-    fn asin(n: c_float) -> c_float = cmath::c_float::asin,\n-    fn atan(n: c_float) -> c_float = cmath::c_float::atan,\n-    fn atan2(a: c_float, b: c_float) -> c_float = cmath::c_float::atan2,\n-    fn cbrt(n: c_float) -> c_float = cmath::c_float::cbrt,\n-    fn cosh(n: c_float) -> c_float = cmath::c_float::cosh,\n-    // fn erf(n: c_float) -> c_float = cmath::c_float::erf,\n-    // fn erfc(n: c_float) -> c_float = cmath::c_float::erfc,\n-    fn exp_m1(n: c_float) -> c_float = cmath::c_float::exp_m1,\n-    fn abs_sub(a: c_float, b: c_float) -> c_float = cmath::c_float::abs_sub,\n-    fn next_after(x: c_float, y: c_float) -> c_float = cmath::c_float::next_after,\n-    fn frexp(n: c_float, value: &mut c_int) -> c_float = cmath::c_float::frexp,\n-    fn hypot(x: c_float, y: c_float) -> c_float = cmath::c_float::hypot,\n-    fn ldexp(x: c_float, n: c_int) -> c_float = cmath::c_float::ldexp,\n-    // fn log_radix(n: c_float) -> c_float = cmath::c_float::log_radix,\n-    fn ln_1p(n: c_float) -> c_float = cmath::c_float::ln_1p,\n-    // fn ilog_radix(n: c_float) -> c_int = cmath::c_float::ilog_radix,\n-    // fn modf(n: c_float, iptr: &mut c_float) -> c_float = cmath::c_float::modf,\n-    // fn ldexp_radix(n: c_float, i: c_int) -> c_float = cmath::c_float::ldexp_radix,\n-    fn sinh(n: c_float) -> c_float = cmath::c_float::sinh,\n-    fn tan(n: c_float) -> c_float = cmath::c_float::tan,\n-    fn tanh(n: c_float) -> c_float = cmath::c_float::tanh\n+    fn acos(n: c_float) -> c_float = cmath::acosf,\n+    fn asin(n: c_float) -> c_float = cmath::asinf,\n+    fn atan(n: c_float) -> c_float = cmath::atanf,\n+    fn atan2(a: c_float, b: c_float) -> c_float = cmath::atan2f,\n+    fn cbrt(n: c_float) -> c_float = cmath::cbrtf,\n+    fn cosh(n: c_float) -> c_float = cmath::coshf,\n+    fn exp_m1(n: c_float) -> c_float = cmath::expm1f,\n+    fn abs_sub(a: c_float, b: c_float) -> c_float = cmath::fdimf,\n+    fn next_after(x: c_float, y: c_float) -> c_float = cmath::nextafterf,\n+    fn frexp(n: c_float, value: &mut c_int) -> c_float = cmath::frexpf,\n+    fn hypot(x: c_float, y: c_float) -> c_float = cmath::hypotf,\n+    fn ldexp(x: c_float, n: c_int) -> c_float = cmath::ldexpf,\n+    fn ln_1p(n: c_float) -> c_float = cmath::log1pf,\n+    fn sinh(n: c_float) -> c_float = cmath::sinhf,\n+    fn tan(n: c_float) -> c_float = cmath::tanf,\n+    fn tanh(n: c_float) -> c_float = cmath::tanhf\n )\n \n // FIXME(#11621): These constants should be deprecated once CTFE is implemented\n@@ -308,12 +340,12 @@ impl Primitive for f32 {}\n impl Float for f32 {\n     #[inline]\n     fn max(self, other: f32) -> f32 {\n-        unsafe { cmath::c_float::fmax(self, other) }\n+        unsafe { cmath::fmaxf(self, other) }\n     }\n \n     #[inline]\n     fn min(self, other: f32) -> f32 {\n-        unsafe { cmath::c_float::fmin(self, other) }\n+        unsafe { cmath::fminf(self, other) }\n     }\n \n     #[inline]"}, {"sha": "4defa452b5ce6164d8888e056ae1940b6ebac8b1", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 68, "deletions": 26, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "patch": "@@ -14,7 +14,6 @@\n \n use prelude::*;\n \n-use cmath;\n use default::Default;\n use from_str::FromStr;\n use libc::{c_double, c_int};\n@@ -23,6 +22,56 @@ use num::{Zero, One, Bounded, strconv};\n use num;\n use intrinsics;\n \n+#[allow(dead_code)]\n+mod cmath {\n+    use libc::{c_double, c_int};\n+\n+    #[link_name = \"m\"]\n+    extern {\n+        pub fn acos(n: c_double) -> c_double;\n+        pub fn asin(n: c_double) -> c_double;\n+        pub fn atan(n: c_double) -> c_double;\n+        pub fn atan2(a: c_double, b: c_double) -> c_double;\n+        pub fn cbrt(n: c_double) -> c_double;\n+        pub fn cosh(n: c_double) -> c_double;\n+        pub fn erf(n: c_double) -> c_double;\n+        pub fn erfc(n: c_double) -> c_double;\n+        pub fn expm1(n: c_double) -> c_double;\n+        pub fn fdim(a: c_double, b: c_double) -> c_double;\n+        pub fn fmax(a: c_double, b: c_double) -> c_double;\n+        pub fn fmin(a: c_double, b: c_double) -> c_double;\n+        pub fn nextafter(x: c_double, y: c_double) -> c_double;\n+        pub fn frexp(n: c_double, value: &mut c_int) -> c_double;\n+        pub fn hypot(x: c_double, y: c_double) -> c_double;\n+        pub fn ldexp(x: c_double, n: c_int) -> c_double;\n+        pub fn logb(n: c_double) -> c_double;\n+        pub fn log1p(n: c_double) -> c_double;\n+        pub fn ilogb(n: c_double) -> c_int;\n+        pub fn modf(n: c_double, iptr: &mut c_double) -> c_double;\n+        pub fn sinh(n: c_double) -> c_double;\n+        pub fn tan(n: c_double) -> c_double;\n+        pub fn tanh(n: c_double) -> c_double;\n+        pub fn tgamma(n: c_double) -> c_double;\n+\n+        // These are commonly only available for doubles\n+\n+        pub fn j0(n: c_double) -> c_double;\n+        pub fn j1(n: c_double) -> c_double;\n+        pub fn jn(i: c_int, n: c_double) -> c_double;\n+\n+        pub fn y0(n: c_double) -> c_double;\n+        pub fn y1(n: c_double) -> c_double;\n+        pub fn yn(i: c_int, n: c_double) -> c_double;\n+\n+        #[cfg(unix)]\n+        pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;\n+        #[cfg(windows)]\n+        #[link_name=\"__lgamma_r\"]\n+        pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;\n+    }\n+}\n+\n+\n macro_rules! delegate(\n     (\n         $(\n@@ -66,29 +115,22 @@ delegate!(\n     fn nearbyint(n: f64) -> f64 = intrinsics::nearbyintf64,\n     fn round(n: f64) -> f64 = intrinsics::roundf64,\n \n-    // cmath\n-    fn acos(n: c_double) -> c_double = cmath::c_double::acos,\n-    fn asin(n: c_double) -> c_double = cmath::c_double::asin,\n-    fn atan(n: c_double) -> c_double = cmath::c_double::atan,\n-    fn atan2(a: c_double, b: c_double) -> c_double = cmath::c_double::atan2,\n-    fn cbrt(n: c_double) -> c_double = cmath::c_double::cbrt,\n-    fn cosh(n: c_double) -> c_double = cmath::c_double::cosh,\n-    // fn erf(n: c_double) -> c_double = cmath::c_double::erf,\n-    // fn erfc(n: c_double) -> c_double = cmath::c_double::erfc,\n-    fn exp_m1(n: c_double) -> c_double = cmath::c_double::exp_m1,\n-    fn abs_sub(a: c_double, b: c_double) -> c_double = cmath::c_double::abs_sub,\n-    fn next_after(x: c_double, y: c_double) -> c_double = cmath::c_double::next_after,\n-    fn frexp(n: c_double, value: &mut c_int) -> c_double = cmath::c_double::frexp,\n-    fn hypot(x: c_double, y: c_double) -> c_double = cmath::c_double::hypot,\n-    fn ldexp(x: c_double, n: c_int) -> c_double = cmath::c_double::ldexp,\n-    // fn log_radix(n: c_double) -> c_double = cmath::c_double::log_radix,\n-    fn ln_1p(n: c_double) -> c_double = cmath::c_double::ln_1p,\n-    // fn ilog_radix(n: c_double) -> c_int = cmath::c_double::ilog_radix,\n-    // fn modf(n: c_double, iptr: &mut c_double) -> c_double = cmath::c_double::modf,\n-    // fn ldexp_radix(n: c_double, i: c_int) -> c_double = cmath::c_double::ldexp_radix,\n-    fn sinh(n: c_double) -> c_double = cmath::c_double::sinh,\n-    fn tan(n: c_double) -> c_double = cmath::c_double::tan,\n-    fn tanh(n: c_double) -> c_double = cmath::c_double::tanh\n+    fn acos(n: c_double) -> c_double = cmath::acos,\n+    fn asin(n: c_double) -> c_double = cmath::asin,\n+    fn atan(n: c_double) -> c_double = cmath::atan,\n+    fn atan2(a: c_double, b: c_double) -> c_double = cmath::atan2,\n+    fn cbrt(n: c_double) -> c_double = cmath::cbrt,\n+    fn cosh(n: c_double) -> c_double = cmath::cosh,\n+    fn exp_m1(n: c_double) -> c_double = cmath::expm1,\n+    fn abs_sub(a: c_double, b: c_double) -> c_double = cmath::fdim,\n+    fn next_after(x: c_double, y: c_double) -> c_double = cmath::nextafter,\n+    fn frexp(n: c_double, value: &mut c_int) -> c_double = cmath::frexp,\n+    fn hypot(x: c_double, y: c_double) -> c_double = cmath::hypot,\n+    fn ldexp(x: c_double, n: c_int) -> c_double = cmath::ldexp,\n+    fn ln_1p(n: c_double) -> c_double = cmath::log1p,\n+    fn sinh(n: c_double) -> c_double = cmath::sinh,\n+    fn tan(n: c_double) -> c_double = cmath::tan,\n+    fn tanh(n: c_double) -> c_double = cmath::tanh\n )\n \n // FIXME (#1433): obtain these in a different way\n@@ -307,12 +349,12 @@ impl Primitive for f64 {}\n impl Float for f64 {\n     #[inline]\n     fn max(self, other: f64) -> f64 {\n-        unsafe { cmath::c_double::fmax(self, other) }\n+        unsafe { cmath::fmax(self, other) }\n     }\n \n     #[inline]\n     fn min(self, other: f64) -> f64 {\n-        unsafe { cmath::c_double::fmin(self, other) }\n+        unsafe { cmath::fmin(self, other) }\n     }\n \n     #[inline]"}, {"sha": "2c628112957a5c29c0d988122c5505a50a9fb1e2", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1217cfb9e7e449c9ef5ee0844e7d3be324648f02/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=1217cfb9e7e449c9ef5ee0844e7d3be324648f02", "patch": "@@ -553,79 +553,6 @@ pub trait Float: Signed + Round + Primitive {\n     fn to_radians(&self) -> Self;\n }\n \n-/// Returns the exponential of the number, minus `1`, `exp(n) - 1`, in a way\n-/// that is accurate even if the number is close to zero.\n-#[inline(always)] pub fn exp_m1<T: Float>(value: T) -> T { value.exp_m1() }\n-/// Returns the natural logarithm of the number plus `1`, `ln(n + 1)`, more\n-/// accurately than if the operations were performed separately.\n-#[inline(always)] pub fn ln_1p<T: Float>(value: T) -> T { value.ln_1p() }\n-/// Fused multiply-add. Computes `(a * b) + c` with only one rounding error.\n-///\n-/// This produces a more accurate result with better performance (on some\n-/// architectures) than a separate multiplication operation followed by an add.\n-#[inline(always)] pub fn mul_add<T: Float>(a: T, b: T, c: T) -> T { a.mul_add(b, c) }\n-\n-/// Raise a number to a power.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::num;\n-///\n-/// let sixteen: f64 = num::powf(2.0, 4.0);\n-/// assert_eq!(sixteen, 16.0);\n-/// ```\n-#[inline(always)] pub fn powf<T: Float>(value: T, n: T) -> T { value.powf(&n) }\n-/// Take the square root of a number.\n-#[inline(always)] pub fn sqrt<T: Float>(value: T) -> T { value.sqrt() }\n-/// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-#[inline(always)] pub fn rsqrt<T: Float>(value: T) -> T { value.rsqrt() }\n-/// Take the cubic root of a number.\n-#[inline(always)] pub fn cbrt<T: Float>(value: T) -> T { value.cbrt() }\n-/// Calculate the length of the hypotenuse of a right-angle triangle given legs\n-/// of length `x` and `y`.\n-#[inline(always)] pub fn hypot<T: Float>(x: T, y: T) -> T { x.hypot(&y) }\n-/// Sine function.\n-#[inline(always)] pub fn sin<T: Float>(value: T) -> T { value.sin() }\n-/// Cosine function.\n-#[inline(always)] pub fn cos<T: Float>(value: T) -> T { value.cos() }\n-/// Tangent function.\n-#[inline(always)] pub fn tan<T: Float>(value: T) -> T { value.tan() }\n-/// Compute the arcsine of the number.\n-#[inline(always)] pub fn asin<T: Float>(value: T) -> T { value.asin() }\n-/// Compute the arccosine of the number.\n-#[inline(always)] pub fn acos<T: Float>(value: T) -> T { value.acos() }\n-/// Compute the arctangent of the number.\n-#[inline(always)] pub fn atan<T: Float>(value: T) -> T { value.atan() }\n-/// Compute the arctangent with 2 arguments.\n-#[inline(always)] pub fn atan2<T: Float>(x: T, y: T) -> T { x.atan2(&y) }\n-/// Simultaneously computes the sine and cosine of the number.\n-#[inline(always)] pub fn sin_cos<T: Float>(value: T) -> (T, T) { value.sin_cos() }\n-/// Returns `e^(value)`, (the exponential function).\n-#[inline(always)] pub fn exp<T: Float>(value: T) -> T { value.exp() }\n-/// Returns 2 raised to the power of the number, `2^(value)`.\n-#[inline(always)] pub fn exp2<T: Float>(value: T) -> T { value.exp2() }\n-/// Returns the natural logarithm of the number.\n-#[inline(always)] pub fn ln<T: Float>(value: T) -> T { value.ln() }\n-/// Returns the logarithm of the number with respect to an arbitrary base.\n-#[inline(always)] pub fn log<T: Float>(value: T, base: T) -> T { value.log(&base) }\n-/// Returns the base 2 logarithm of the number.\n-#[inline(always)] pub fn log2<T: Float>(value: T) -> T { value.log2() }\n-/// Returns the base 10 logarithm of the number.\n-#[inline(always)] pub fn log10<T: Float>(value: T) -> T { value.log10() }\n-/// Hyperbolic sine function.\n-#[inline(always)] pub fn sinh<T: Float>(value: T) -> T { value.sinh() }\n-/// Hyperbolic cosine function.\n-#[inline(always)] pub fn cosh<T: Float>(value: T) -> T { value.cosh() }\n-/// Hyperbolic tangent function.\n-#[inline(always)] pub fn tanh<T: Float>(value: T) -> T { value.tanh() }\n-/// Inverse hyperbolic sine function.\n-#[inline(always)] pub fn asinh<T: Float>(value: T) -> T { value.asinh() }\n-/// Inverse hyperbolic cosine function.\n-#[inline(always)] pub fn acosh<T: Float>(value: T) -> T { value.acosh() }\n-/// Inverse hyperbolic tangent function.\n-#[inline(always)] pub fn atanh<T: Float>(value: T) -> T { value.atanh() }\n-\n /// A generic trait for converting a value to a number.\n pub trait ToPrimitive {\n     /// Converts the value of `self` to an `int`."}]}