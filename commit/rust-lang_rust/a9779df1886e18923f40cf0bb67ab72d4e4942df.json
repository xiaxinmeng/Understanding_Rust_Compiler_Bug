{"sha": "a9779df1886e18923f40cf0bb67ab72d4e4942df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5Nzc5ZGYxODg2ZTE4OTIzZjQwY2YwYmI2N2FiNzJkNGU0OTQyZGY=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-05-05T05:42:14Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-05-07T15:52:41Z"}, "message": "Implement RFC 1542\n\ncc #33417", "tree": {"sha": "8b2cb30118bca393968a3bd28ab0d47384ee76ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b2cb30118bca393968a3bd28ab0d47384ee76ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9779df1886e18923f40cf0bb67ab72d4e4942df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9779df1886e18923f40cf0bb67ab72d4e4942df", "html_url": "https://github.com/rust-lang/rust/commit/a9779df1886e18923f40cf0bb67ab72d4e4942df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9779df1886e18923f40cf0bb67ab72d4e4942df/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "936b32a514b73c1d3dfcbd9d17818f9f18bf4883", "url": "https://api.github.com/repos/rust-lang/rust/commits/936b32a514b73c1d3dfcbd9d17818f9f18bf4883", "html_url": "https://github.com/rust-lang/rust/commit/936b32a514b73c1d3dfcbd9d17818f9f18bf4883"}], "stats": {"total": 610, "additions": 451, "deletions": 159}, "files": [{"sha": "48421abc7bbdf7e4a2793debd028a0959a95151b", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=a9779df1886e18923f40cf0bb67ab72d4e4942df", "patch": "@@ -20,18 +20,19 @@\n //! - Impl the `As*` traits for reference-to-reference conversions\n //! - Impl the `Into` trait when you want to consume the value in the conversion\n //! - The `From` trait is the most flexible, useful for value _and_ reference conversions\n+//! - The `TryFrom` and `TryInto` traits behave like `From` and `Into`, but allow for the\n+//!   conversion to fail\n //!\n-//! As a library author, you should prefer implementing `From<T>` rather than\n-//! `Into<U>`, as `From` provides greater flexibility and offers an equivalent `Into`\n-//! implementation for free, thanks to a blanket implementation in the standard library.\n-//!\n-//! **Note: these traits must not fail**. If the conversion can fail, you must use a dedicated\n-//! method which returns an `Option<T>` or a `Result<T, E>`.\n+//! As a library author, you should prefer implementing `From<T>` or `TryFrom<T>` rather than\n+//! `Into<U>` or `TryInto<U>`, as `From` and `TryFrom` provide greater flexibility and offer\n+//! equivalent `Into` or `TryInto` implementations for free, thanks to a blanket implementation\n+//! in the standard library.\n //!\n //! # Generic impl\n //!\n //! - `AsRef` and `AsMut` auto-dereference if the inner type is a reference\n //! - `From<U> for T` implies `Into<T> for U`\n+//! - `TryFrom<U> for T` implies `TryInto<T> for U`\n //! - `From` and `Into` are reflexive, which means that all types can `into()`\n //!   themselves and `from()` themselves\n //!\n@@ -40,6 +41,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n+use result::Result;\n \n /// A cheap, reference-to-reference conversion.\n ///\n@@ -98,8 +100,8 @@ pub trait AsMut<T: ?Sized> {\n \n /// A conversion that consumes `self`, which may or may not be expensive.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a dedicated method which\n-/// returns an `Option<T>` or a `Result<T, E>`.\n+/// **Note: this trait must not fail**. If the conversion can fail, use `TryInto` or a dedicated\n+/// method which returns an `Option<T>` or a `Result<T, E>`.\n ///\n /// Library authors should not directly implement this trait, but should prefer implementing\n /// the `From` trait, which offers greater flexibility and provides an equivalent `Into`\n@@ -133,8 +135,8 @@ pub trait Into<T>: Sized {\n \n /// Construct `Self` via a conversion.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a dedicated method which\n-/// returns an `Option<T>` or a `Result<T, E>`.\n+/// **Note: this trait must not fail**. If the conversion can fail, use `TryFrom` or a dedicated\n+/// method which returns an `Option<T>` or a `Result<T, E>`.\n ///\n /// # Examples\n ///\n@@ -158,6 +160,30 @@ pub trait From<T>: Sized {\n     fn from(T) -> Self;\n }\n \n+/// An attempted conversion that consumes `self`, which may or may not be expensive.\n+///\n+/// Library authors should not directly implement this trait, but should prefer implementing\n+/// the `TryFrom` trait, which offers greater flexibility and provides an equivalent `TryInto`\n+/// implementation for free, thanks to a blanket implementation in the standard library.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+pub trait TryInto<T>: Sized {\n+    /// The type returned in the event of a conversion error.\n+    type Err;\n+\n+    /// Performs the conversion.\n+    fn try_into(self) -> Result<T, Self::Err>;\n+}\n+\n+/// Attempt to construct `Self` via a conversion.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+pub trait TryFrom<T>: Sized {\n+    /// The type returned in the event of a conversion error.\n+    type Err;\n+\n+    /// Performs the conversion.\n+    fn try_from(T) -> Result<Self, Self::Err>;\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // GENERIC IMPLS\n ////////////////////////////////////////////////////////////////////////////////\n@@ -216,6 +242,17 @@ impl<T> From<T> for T {\n     fn from(t: T) -> T { t }\n }\n \n+\n+// TryFrom implies TryInto\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl<T, U> TryInto<U> for T where U: TryFrom<T> {\n+    type Err = U::Err;\n+\n+    fn try_into(self) -> Result<U, U::Err> {\n+        U::try_from(self)\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // CONCRETE IMPLS\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "e048c963d1556ff61bd94e2901697806df0a4678", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 94, "deletions": 1, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a9779df1886e18923f40cf0bb67ab72d4e4942df", "patch": "@@ -15,7 +15,7 @@\n \n use char::CharExt;\n use cmp::PartialOrd;\n-use convert::From;\n+use convert::{From, TryFrom};\n use fmt;\n use intrinsics;\n use marker::{Copy, Sized};\n@@ -2341,9 +2341,101 @@ macro_rules! from_str_radix_int_impl {\n }\n from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }\n \n+/// The error type returned when a checked integral type conversion fails.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[derive(Debug, Copy, Clone)]\n+pub struct TryFromIntError(());\n+\n+impl TryFromIntError {\n+    #[unstable(feature = \"int_error_internals\",\n+               reason = \"available through Error trait and this method should \\\n+                         not be exposed publicly\",\n+               issue = \"0\")]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        \"out of range integral type conversion attempted\"\n+    }\n+}\n+\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl fmt::Display for TryFromIntError {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        self.__description().fmt(fmt)\n+    }\n+}\n+\n+macro_rules! same_sign_from_int_impl {\n+    ($storage:ty, $target:ty, $($source:ty),*) => {$(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Err = TryFromIntError;\n+\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                let min = <$target as FromStrRadixHelper>::min_value() as $storage;\n+                let max = <$target as FromStrRadixHelper>::max_value() as $storage;\n+                if u as $storage < min || u as $storage > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+same_sign_from_int_impl!(u64, u8, u8, u16, u32, u64, usize);\n+same_sign_from_int_impl!(i64, i8, i8, i16, i32, i64, isize);\n+same_sign_from_int_impl!(u64, u16, u8, u16, u32, u64, usize);\n+same_sign_from_int_impl!(i64, i16, i8, i16, i32, i64, isize);\n+same_sign_from_int_impl!(u64, u32, u8, u16, u32, u64, usize);\n+same_sign_from_int_impl!(i64, i32, i8, i16, i32, i64, isize);\n+same_sign_from_int_impl!(u64, u64, u8, u16, u32, u64, usize);\n+same_sign_from_int_impl!(i64, i64, i8, i16, i32, i64, isize);\n+same_sign_from_int_impl!(u64, usize, u8, u16, u32, u64, usize);\n+same_sign_from_int_impl!(i64, isize, i8, i16, i32, i64, isize);\n+\n+macro_rules! cross_sign_from_int_impl {\n+    ($unsigned:ty, $($signed:ty),*) => {$(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl TryFrom<$unsigned> for $signed {\n+            type Err = TryFromIntError;\n+\n+            fn try_from(u: $unsigned) -> Result<$signed, TryFromIntError> {\n+                let max = <$signed as FromStrRadixHelper>::max_value() as u64;\n+                if u as u64 > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $signed)\n+                }\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl TryFrom<$signed> for $unsigned {\n+            type Err = TryFromIntError;\n+\n+            fn try_from(u: $signed) -> Result<$unsigned, TryFromIntError> {\n+                let max = <$unsigned as FromStrRadixHelper>::max_value() as u64;\n+                if u < 0 || u as u64 > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $unsigned)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+cross_sign_from_int_impl!(u8, i8, i16, i32, i64, isize);\n+cross_sign_from_int_impl!(u16, i8, i16, i32, i64, isize);\n+cross_sign_from_int_impl!(u32, i8, i16, i32, i64, isize);\n+cross_sign_from_int_impl!(u64, i8, i16, i32, i64, isize);\n+cross_sign_from_int_impl!(usize, i8, i16, i32, i64, isize);\n+\n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n     fn min_value() -> Self;\n+    fn max_value() -> Self;\n     fn from_u32(u: u32) -> Self;\n     fn checked_mul(&self, other: u32) -> Option<Self>;\n     fn checked_sub(&self, other: u32) -> Option<Self>;\n@@ -2353,6 +2445,7 @@ trait FromStrRadixHelper: PartialOrd + Copy {\n macro_rules! doit {\n     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n         fn min_value() -> Self { Self::min_value() }\n+        fn max_value() -> Self { Self::max_value() }\n         fn from_u32(u: u32) -> Self { u as Self }\n         fn checked_mul(&self, other: u32) -> Option<Self> {\n             Self::checked_mul(*self, other as Self)"}, {"sha": "a3c46ffcea5d650d172b79a9816871f2ae19bf92", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=a9779df1886e18923f40cf0bb67ab72d4e4942df", "patch": "@@ -34,6 +34,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n+#![feature(try_from)]\n \n extern crate core;\n extern crate test;"}, {"sha": "642aea9f4f733919d0124a424a81f6abb1a792f1", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 300, "deletions": 147, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=a9779df1886e18923f40cf0bb67ab72d4e4942df", "patch": "@@ -8,10 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::convert::TryFrom;\n use core::cmp::PartialEq;\n use core::fmt::Debug;\n-use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::marker::Copy;\n+use core::num::Float;\n+use core::ops::{Add, Sub, Mul, Div, Rem};\n+use core::option::Option;\n+use core::option::Option::{Some, None};\n \n #[macro_use]\n mod int_macros;\n@@ -48,169 +52,318 @@ pub fn test_num<T>(ten: T, two: T) where\n     assert_eq!(ten.rem(two),  ten % two);\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use core::option::Option;\n-    use core::option::Option::{Some, None};\n-    use core::num::Float;\n-\n-    #[test]\n-    fn from_str_issue7588() {\n-        let u : Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n-        assert_eq!(u, None);\n-        let s : Option<i16> = i16::from_str_radix(\"80000\", 10).ok();\n-        assert_eq!(s, None);\n-    }\n+#[test]\n+fn from_str_issue7588() {\n+    let u : Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n+    assert_eq!(u, None);\n+    let s : Option<i16> = i16::from_str_radix(\"80000\", 10).ok();\n+    assert_eq!(s, None);\n+}\n \n-    #[test]\n-    fn test_int_from_str_overflow() {\n-        let mut i8_val: i8 = 127;\n-        assert_eq!(\"127\".parse::<i8>().ok(), Some(i8_val));\n-        assert_eq!(\"128\".parse::<i8>().ok(), None);\n+#[test]\n+fn test_int_from_str_overflow() {\n+    let mut i8_val: i8 = 127;\n+    assert_eq!(\"127\".parse::<i8>().ok(), Some(i8_val));\n+    assert_eq!(\"128\".parse::<i8>().ok(), None);\n \n-        i8_val = i8_val.wrapping_add(1);\n-        assert_eq!(\"-128\".parse::<i8>().ok(), Some(i8_val));\n-        assert_eq!(\"-129\".parse::<i8>().ok(), None);\n+    i8_val = i8_val.wrapping_add(1);\n+    assert_eq!(\"-128\".parse::<i8>().ok(), Some(i8_val));\n+    assert_eq!(\"-129\".parse::<i8>().ok(), None);\n \n-        let mut i16_val: i16 = 32_767;\n-        assert_eq!(\"32767\".parse::<i16>().ok(), Some(i16_val));\n-        assert_eq!(\"32768\".parse::<i16>().ok(), None);\n+    let mut i16_val: i16 = 32_767;\n+    assert_eq!(\"32767\".parse::<i16>().ok(), Some(i16_val));\n+    assert_eq!(\"32768\".parse::<i16>().ok(), None);\n \n-        i16_val = i16_val.wrapping_add(1);\n-        assert_eq!(\"-32768\".parse::<i16>().ok(), Some(i16_val));\n-        assert_eq!(\"-32769\".parse::<i16>().ok(), None);\n+    i16_val = i16_val.wrapping_add(1);\n+    assert_eq!(\"-32768\".parse::<i16>().ok(), Some(i16_val));\n+    assert_eq!(\"-32769\".parse::<i16>().ok(), None);\n \n-        let mut i32_val: i32 = 2_147_483_647;\n-        assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(i32_val));\n-        assert_eq!(\"2147483648\".parse::<i32>().ok(), None);\n+    let mut i32_val: i32 = 2_147_483_647;\n+    assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(i32_val));\n+    assert_eq!(\"2147483648\".parse::<i32>().ok(), None);\n \n-        i32_val = i32_val.wrapping_add(1);\n-        assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(i32_val));\n-        assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);\n+    i32_val = i32_val.wrapping_add(1);\n+    assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(i32_val));\n+    assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);\n \n-        let mut i64_val: i64 = 9_223_372_036_854_775_807;\n-        assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(i64_val));\n-        assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);\n+    let mut i64_val: i64 = 9_223_372_036_854_775_807;\n+    assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(i64_val));\n+    assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);\n \n-        i64_val = i64_val.wrapping_add(1);\n-        assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));\n-        assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);\n-    }\n+    i64_val = i64_val.wrapping_add(1);\n+    assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));\n+    assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);\n+}\n+\n+#[test]\n+fn test_leading_plus() {\n+    assert_eq!(\"+127\".parse::<u8>().ok(), Some(127));\n+    assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807));\n+}\n \n-    #[test]\n-    fn test_leading_plus() {\n-        assert_eq!(\"+127\".parse::<u8>().ok(), Some(127));\n-        assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807));\n+#[test]\n+fn test_invalid() {\n+    assert_eq!(\"--129\".parse::<i8>().ok(), None);\n+    assert_eq!(\"++129\".parse::<i8>().ok(), None);\n+    assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);\n+}\n+\n+#[test]\n+fn test_empty() {\n+    assert_eq!(\"-\".parse::<i8>().ok(), None);\n+    assert_eq!(\"+\".parse::<i8>().ok(), None);\n+    assert_eq!(\"\".parse::<u8>().ok(), None);\n+}\n+\n+macro_rules! test_impl_from {\n+    ($fn_name: ident, $Small: ty, $Large: ty) => {\n+        #[test]\n+        fn $fn_name() {\n+            let small_max = <$Small>::max_value();\n+            let small_min = <$Small>::min_value();\n+            let large_max: $Large = small_max.into();\n+            let large_min: $Large = small_min.into();\n+            assert_eq!(large_max as $Small, small_max);\n+            assert_eq!(large_min as $Small, small_min);\n+        }\n     }\n+}\n+\n+// Unsigned -> Unsigned\n+test_impl_from! { test_u8u16, u8, u16 }\n+test_impl_from! { test_u8u32, u8, u32 }\n+test_impl_from! { test_u8u64, u8, u64 }\n+test_impl_from! { test_u8usize, u8, usize }\n+test_impl_from! { test_u16u32, u16, u32 }\n+test_impl_from! { test_u16u64, u16, u64 }\n+test_impl_from! { test_u32u64, u32, u64 }\n+\n+// Signed -> Signed\n+test_impl_from! { test_i8i16, i8, i16 }\n+test_impl_from! { test_i8i32, i8, i32 }\n+test_impl_from! { test_i8i64, i8, i64 }\n+test_impl_from! { test_i8isize, i8, isize }\n+test_impl_from! { test_i16i32, i16, i32 }\n+test_impl_from! { test_i16i64, i16, i64 }\n+test_impl_from! { test_i32i64, i32, i64 }\n+\n+// Unsigned -> Signed\n+test_impl_from! { test_u8i16, u8, i16 }\n+test_impl_from! { test_u8i32, u8, i32 }\n+test_impl_from! { test_u8i64, u8, i64 }\n+test_impl_from! { test_u16i32, u16, i32 }\n+test_impl_from! { test_u16i64, u16, i64 }\n+test_impl_from! { test_u32i64, u32, i64 }\n+\n+// Signed -> Float\n+test_impl_from! { test_i8f32, i8, f32 }\n+test_impl_from! { test_i8f64, i8, f64 }\n+test_impl_from! { test_i16f32, i16, f32 }\n+test_impl_from! { test_i16f64, i16, f64 }\n+test_impl_from! { test_i32f64, i32, f64 }\n+\n+// Unsigned -> Float\n+test_impl_from! { test_u8f32, u8, f32 }\n+test_impl_from! { test_u8f64, u8, f64 }\n+test_impl_from! { test_u16f32, u16, f32 }\n+test_impl_from! { test_u16f64, u16, f64 }\n+test_impl_from! { test_u32f64, u32, f64 }\n+\n+// Float -> Float\n+#[test]\n+fn test_f32f64() {\n+    use core::f32;\n+\n+    let max: f64 = f32::MAX.into();\n+    assert_eq!(max as f32, f32::MAX);\n+    assert!(max.is_normal());\n+\n+    let min: f64 = f32::MIN.into();\n+    assert_eq!(min as f32, f32::MIN);\n+    assert!(min.is_normal());\n+\n+    let min_positive: f64 = f32::MIN_POSITIVE.into();\n+    assert_eq!(min_positive as f32, f32::MIN_POSITIVE);\n+    assert!(min_positive.is_normal());\n+\n+    let epsilon: f64 = f32::EPSILON.into();\n+    assert_eq!(epsilon as f32, f32::EPSILON);\n+    assert!(epsilon.is_normal());\n+\n+    let zero: f64 = (0.0f32).into();\n+    assert_eq!(zero as f32, 0.0f32);\n+    assert!(zero.is_sign_positive());\n+\n+    let neg_zero: f64 = (-0.0f32).into();\n+    assert_eq!(neg_zero as f32, -0.0f32);\n+    assert!(neg_zero.is_sign_negative());\n+\n+    let infinity: f64 = f32::INFINITY.into();\n+    assert_eq!(infinity as f32, f32::INFINITY);\n+    assert!(infinity.is_infinite());\n+    assert!(infinity.is_sign_positive());\n+\n+    let neg_infinity: f64 = f32::NEG_INFINITY.into();\n+    assert_eq!(neg_infinity as f32, f32::NEG_INFINITY);\n+    assert!(neg_infinity.is_infinite());\n+    assert!(neg_infinity.is_sign_negative());\n+\n+    let nan: f64 = f32::NAN.into();\n+    assert!(nan.is_nan());\n+}\n \n-    #[test]\n-    fn test_invalid() {\n-        assert_eq!(\"--129\".parse::<i8>().ok(), None);\n-        assert_eq!(\"++129\".parse::<i8>().ok(), None);\n-        assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);\n+macro_rules! test_impl_try_from_always_ok {\n+    ($fn_name:ident, $source:ty, $target: ty) => {\n+        #[test]\n+        fn $fn_name() {\n+            let max = <$source>::max_value();\n+            let min = <$source>::min_value();\n+            let zero: $source = 0;\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(),\n+                       max as $target);\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(),\n+                       min as $target);\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),\n+                       zero as $target);\n+        }\n     }\n+}\n \n-    #[test]\n-    fn test_empty() {\n-        assert_eq!(\"-\".parse::<i8>().ok(), None);\n-        assert_eq!(\"+\".parse::<i8>().ok(), None);\n-        assert_eq!(\"\".parse::<u8>().ok(), None);\n+test_impl_try_from_always_ok! { test_try_u8u8, u8, u8 }\n+test_impl_try_from_always_ok! { test_try_u8u16, u8, u16 }\n+test_impl_try_from_always_ok! { test_try_u8u32, u8, u32 }\n+test_impl_try_from_always_ok! { test_try_u8u64, u8, u64 }\n+test_impl_try_from_always_ok! { test_try_u8i16, u8, i16 }\n+test_impl_try_from_always_ok! { test_try_u8i32, u8, i32 }\n+test_impl_try_from_always_ok! { test_try_u8i64, u8, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_u16u16, u16, u16 }\n+test_impl_try_from_always_ok! { test_try_u16u32, u16, u32 }\n+test_impl_try_from_always_ok! { test_try_u16u64, u16, u64 }\n+test_impl_try_from_always_ok! { test_try_u16i32, u16, i32 }\n+test_impl_try_from_always_ok! { test_try_u16i64, u16, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_u32u32, u32, u32 }\n+test_impl_try_from_always_ok! { test_try_u32u64, u32, u64 }\n+test_impl_try_from_always_ok! { test_try_u32i64, u32, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_u64u64, u64, u64 }\n+\n+test_impl_try_from_always_ok! { test_try_i8i8, i8, i8 }\n+test_impl_try_from_always_ok! { test_try_i8i16, i8, i16 }\n+test_impl_try_from_always_ok! { test_try_i8i32, i8, i32 }\n+test_impl_try_from_always_ok! { test_try_i8i64, i8, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_i16i16, i16, i16 }\n+test_impl_try_from_always_ok! { test_try_i16i32, i16, i32 }\n+test_impl_try_from_always_ok! { test_try_i16i64, i16, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_i32i32, i32, i32 }\n+test_impl_try_from_always_ok! { test_try_i32i64, i32, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_i64i64, i64, i64 }\n+\n+macro_rules! test_impl_try_from_signed_to_unsigned_upper_ok {\n+    ($fn_name:ident, $source:ty, $target:ty) => {\n+        #[test]\n+        fn $fn_name() {\n+            let max = <$source>::max_value();\n+            let min = <$source>::min_value();\n+            let zero: $source = 0;\n+            let neg_one: $source = -1;\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(),\n+                       max as $target);\n+            assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),\n+                       zero as $target);\n+            assert!(<$target as TryFrom<$source>>::try_from(neg_one).is_err());\n+        }\n     }\n+}\n \n-    macro_rules! test_impl_from {\n-        ($fn_name: ident, $Small: ty, $Large: ty) => {\n-            #[test]\n-            fn $fn_name() {\n-                let small_max = <$Small>::max_value();\n-                let small_min = <$Small>::min_value();\n-                let large_max: $Large = small_max.into();\n-                let large_min: $Large = small_min.into();\n-                assert_eq!(large_max as $Small, small_max);\n-                assert_eq!(large_min as $Small, small_min);\n-            }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u8, i8, u8 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u16, i8, u16 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u32, i8, u32 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u64, i8, u64 }\n+\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u16, i16, u16 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u32, i16, u32 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u64, i16, u64 }\n+\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u32, i32, u32 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u64, i32, u64 }\n+\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64u64, i64, u64 }\n+\n+macro_rules! test_impl_try_from_unsigned_to_signed_upper_err {\n+    ($fn_name:ident, $source:ty, $target:ty) => {\n+        #[test]\n+        fn $fn_name() {\n+            let max = <$source>::max_value();\n+            let min = <$source>::min_value();\n+            let zero: $source = 0;\n+            assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(),\n+                       min as $target);\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),\n+                       zero as $target);\n         }\n     }\n+}\n \n-    // Unsigned -> Unsigned\n-    test_impl_from! { test_u8u16, u8, u16 }\n-    test_impl_from! { test_u8u32, u8, u32 }\n-    test_impl_from! { test_u8u64, u8, u64 }\n-    test_impl_from! { test_u8usize, u8, usize }\n-    test_impl_from! { test_u16u32, u16, u32 }\n-    test_impl_from! { test_u16u64, u16, u64 }\n-    test_impl_from! { test_u32u64, u32, u64 }\n-\n-    // Signed -> Signed\n-    test_impl_from! { test_i8i16, i8, i16 }\n-    test_impl_from! { test_i8i32, i8, i32 }\n-    test_impl_from! { test_i8i64, i8, i64 }\n-    test_impl_from! { test_i8isize, i8, isize }\n-    test_impl_from! { test_i16i32, i16, i32 }\n-    test_impl_from! { test_i16i64, i16, i64 }\n-    test_impl_from! { test_i32i64, i32, i64 }\n-\n-    // Unsigned -> Signed\n-    test_impl_from! { test_u8i16, u8, i16 }\n-    test_impl_from! { test_u8i32, u8, i32 }\n-    test_impl_from! { test_u8i64, u8, i64 }\n-    test_impl_from! { test_u16i32, u16, i32 }\n-    test_impl_from! { test_u16i64, u16, i64 }\n-    test_impl_from! { test_u32i64, u32, i64 }\n-\n-    // Signed -> Float\n-    test_impl_from! { test_i8f32, i8, f32 }\n-    test_impl_from! { test_i8f64, i8, f64 }\n-    test_impl_from! { test_i16f32, i16, f32 }\n-    test_impl_from! { test_i16f64, i16, f64 }\n-    test_impl_from! { test_i32f64, i32, f64 }\n-\n-    // Unsigned -> Float\n-    test_impl_from! { test_u8f32, u8, f32 }\n-    test_impl_from! { test_u8f64, u8, f64 }\n-    test_impl_from! { test_u16f32, u16, f32 }\n-    test_impl_from! { test_u16f64, u16, f64 }\n-    test_impl_from! { test_u32f64, u32, f64 }\n-\n-    // Float -> Float\n-    #[test]\n-    fn test_f32f64() {\n-        use core::f32;\n-\n-        let max: f64 = f32::MAX.into();\n-        assert_eq!(max as f32, f32::MAX);\n-        assert!(max.is_normal());\n-\n-        let min: f64 = f32::MIN.into();\n-        assert_eq!(min as f32, f32::MIN);\n-        assert!(min.is_normal());\n-\n-        let min_positive: f64 = f32::MIN_POSITIVE.into();\n-        assert_eq!(min_positive as f32, f32::MIN_POSITIVE);\n-        assert!(min_positive.is_normal());\n-\n-        let epsilon: f64 = f32::EPSILON.into();\n-        assert_eq!(epsilon as f32, f32::EPSILON);\n-        assert!(epsilon.is_normal());\n-\n-        let zero: f64 = (0.0f32).into();\n-        assert_eq!(zero as f32, 0.0f32);\n-        assert!(zero.is_sign_positive());\n-\n-        let neg_zero: f64 = (-0.0f32).into();\n-        assert_eq!(neg_zero as f32, -0.0f32);\n-        assert!(neg_zero.is_sign_negative());\n-\n-        let infinity: f64 = f32::INFINITY.into();\n-        assert_eq!(infinity as f32, f32::INFINITY);\n-        assert!(infinity.is_infinite());\n-        assert!(infinity.is_sign_positive());\n-\n-        let neg_infinity: f64 = f32::NEG_INFINITY.into();\n-        assert_eq!(neg_infinity as f32, f32::NEG_INFINITY);\n-        assert!(neg_infinity.is_infinite());\n-        assert!(neg_infinity.is_sign_negative());\n-\n-        let nan: f64 = f32::NAN.into();\n-        assert!(nan.is_nan());\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u8i8, u8, i8 }\n+\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16i8, u16, i8 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16i16, u16, i16 }\n+\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i8, u32, i8 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i16, u32, i16 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i32, u32, i32 }\n+\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i8, u64, i8 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i16, u64, i16 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i32, u64, i32 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i64, u64, i64 }\n+\n+macro_rules! test_impl_try_from_same_sign_err {\n+    ($fn_name:ident, $source:ty, $target:ty) => {\n+        #[test]\n+        fn $fn_name() {\n+            let max = <$source>::max_value();\n+            let min = <$source>::min_value();\n+            let zero: $source = 0;\n+            let t_max = <$target>::max_value();\n+            let t_min = <$target>::min_value();\n+            assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n+            if min != 0 {\n+                assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n+            }\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),\n+                       zero as $target);\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(t_max as $source)\n+                            .unwrap(),\n+                       t_max as $target);\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(t_min as $source)\n+                            .unwrap(),\n+                       t_min as $target);\n+        }\n     }\n }\n+\n+test_impl_try_from_same_sign_err! { test_try_u16u8, u16, u8 }\n+\n+test_impl_try_from_same_sign_err! { test_try_u32u8, u32, u8 }\n+test_impl_try_from_same_sign_err! { test_try_u32u16, u32, u16 }\n+\n+test_impl_try_from_same_sign_err! { test_try_u64u8, u64, u8 }\n+test_impl_try_from_same_sign_err! { test_try_u64u16, u64, u16 }\n+test_impl_try_from_same_sign_err! { test_try_u64u32, u64, u32 }\n+\n+test_impl_try_from_same_sign_err! { test_try_i16i8, i16, i8 }\n+\n+test_impl_try_from_same_sign_err! { test_try_i32i8, i32, i8 }\n+test_impl_try_from_same_sign_err! { test_try_i32i16, i32, i16 }\n+\n+test_impl_try_from_same_sign_err! { test_try_i64i8, i64, i8 }\n+test_impl_try_from_same_sign_err! { test_try_i64i16, i64, i16 }\n+test_impl_try_from_same_sign_err! { test_try_i64i32, i64, i32 }"}, {"sha": "d49d97649467ae1d61a726350aaf396628d244a3", "filename": "src/libstd/error.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=a9779df1886e18923f40cf0bb67ab72d4e4942df", "patch": "@@ -159,6 +159,13 @@ impl Error for num::ParseIntError {\n     }\n }\n \n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl Error for num::TryFromIntError {\n+    fn description(&self) -> &str {\n+        self.__description()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for num::ParseFloatError {\n     fn description(&self) -> &str {"}, {"sha": "d4b40b844fce5e28d15bafcf66b1a75b3bb217d4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a9779df1886e18923f40cf0bb67ab72d4e4942df", "patch": "@@ -270,6 +270,7 @@\n #![feature(vec_push_all)]\n #![feature(zero_one)]\n #![feature(question_mark)]\n+#![feature(try_from)]\n \n // Issue# 30592: Systematically use alloc_system during stage0 since jemalloc\n // might be unavailable or disabled"}, {"sha": "d33df05acf2248fcea578cdc2672176aff1089dd", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9779df1886e18923f40cf0bb67ab72d4e4942df/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=a9779df1886e18923f40cf0bb67ab72d4e4942df", "patch": "@@ -19,7 +19,7 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::{Zero, One};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n+pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::Wrapping;\n "}]}