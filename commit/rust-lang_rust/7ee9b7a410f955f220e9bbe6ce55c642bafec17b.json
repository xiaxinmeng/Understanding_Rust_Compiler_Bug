{"sha": "7ee9b7a410f955f220e9bbe6ce55c642bafec17b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZTliN2E0MTBmOTU1ZjIyMGU5YmJlNmNlNTVjNjQyYmFmZWMxN2I=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-07-27T18:18:50Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-07-27T18:35:14Z"}, "message": "Use doc comments from 'pub use' statements\n\nSplit off from #62855\n\nCurrently, rustdoc ignores any doc comments found on 'pub use'\nstatements. As described in issue #58700, this makes it impossible to\nproperly document procedural macros. Any doc comments must be written on\nthe procedural macro definition, which must occur in a dedicated\nproc-macro crate. This means that any doc comments or doc tests cannot\nreference items defined in re-exporting crate, despite the fact that\nsuch items may be required to use the procedural macro.\n\nTo solve this issue, this commit allows doc comments to be written on\n'pub use' statements. For consistency, this applies to *all* 'pub use'\nstatements, not just those importing procedural macros.\n\nWhen inlining documentation, documentation on 'pub use' statements will\nbe prepended to the documentation of the inlined item. For example,\nthe following items:\n\n```rust\n\nmod other_mod {\n    /// Doc comment from definition\n    pub struct MyStruct;\n}\n\n/// Doc comment from 'pub use'\n///\npub use other_mod::MyStruct;\n```\n\nwill caues the documentation for the re-export of 'MyStruct' to be\nrendered as:\n\n```\nDoc comment from 'pub use'\nDoc comment from definition\n```\n\nNote the empty line in the 'pub use' doc comments - because doc comments\nare concatenated as-is, this ensure that the doc comments on the\ndefinition start on a new line.", "tree": {"sha": "9fa96c9631f80bec3e6dcb5bbaf2e553e88e0368", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fa96c9631f80bec3e6dcb5bbaf2e553e88e0368"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ee9b7a410f955f220e9bbe6ce55c642bafec17b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl08mWIACgkQtAh+UQ6Y\nsWQQcw//X05qhtiLTbSs3/ooNQuljgx2S5817LNbRqyW3ZKsm8Ucqj3sSLKw3K/r\nXiJUJYdFaaSu+nYI0b7Uk8xKRJ5k3qdpjXnUqhO8d5NkVhUOOdjRosnMK5jTWHRV\nk/CPHNL8gjkrqq5N9jUoqmwnpzzmPAEeyuh0+4SfYUhzZQU9f/12nCNYfYbH//Eu\nwKsFByw/EsSlceYwv9rA2Stpck4cgdWNf9XW08DCaDDNX5s1hEttEe7zlQCX154H\nquvMVWpPY/TVjDjc4Ie+BCeH1lOzFR0Z8AddwI/IgBiDI4NSLNLl6MIwQX2kB20z\n8TMMwGf36yRCFDGjj2OYD1exseT0LKa7Apt42hwOZIvf1vPyQTm8vZBv0ctxMQ0h\nuBoZN21rbSr5c5kCunJe3MFpd+BTrlu/+/ZJRpzys4aE8mhK7K1PXtPFHDtOiS4l\nQL/yU6CS/DeCAN/Tgo7Br8V+jKEZj4StrQ7FfGhPo3XTB6SKiin+SlcoBalAW6Wv\nVX1e/BxaacFul7hEZQjYvcPUx67mxK70FcdTVVzPde4qdZSekQYr2yfeeXF21LbO\nmojdUqkCkfMZrJYlI6D65D+oVAzzCljWj4VLl0ss4AgsAH7K5BD6ehTzn8s6sR8f\nUdBo4HhD43UoIty1946K/8v3m1Fv9dO61sWWaz6LJ84vDk7BLeM=\n=vlid\n-----END PGP SIGNATURE-----", "payload": "tree 9fa96c9631f80bec3e6dcb5bbaf2e553e88e0368\nparent 0e9b465d729d07101b29b4d096d83edf9be82df0\nauthor Aaron Hill <aa1ronham@gmail.com> 1564251530 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1564252514 -0400\n\nUse doc comments from 'pub use' statements\n\nSplit off from #62855\n\nCurrently, rustdoc ignores any doc comments found on 'pub use'\nstatements. As described in issue #58700, this makes it impossible to\nproperly document procedural macros. Any doc comments must be written on\nthe procedural macro definition, which must occur in a dedicated\nproc-macro crate. This means that any doc comments or doc tests cannot\nreference items defined in re-exporting crate, despite the fact that\nsuch items may be required to use the procedural macro.\n\nTo solve this issue, this commit allows doc comments to be written on\n'pub use' statements. For consistency, this applies to *all* 'pub use'\nstatements, not just those importing procedural macros.\n\nWhen inlining documentation, documentation on 'pub use' statements will\nbe prepended to the documentation of the inlined item. For example,\nthe following items:\n\n```rust\n\nmod other_mod {\n    /// Doc comment from definition\n    pub struct MyStruct;\n}\n\n/// Doc comment from 'pub use'\n///\npub use other_mod::MyStruct;\n```\n\nwill caues the documentation for the re-export of 'MyStruct' to be\nrendered as:\n\n```\nDoc comment from 'pub use'\nDoc comment from definition\n```\n\nNote the empty line in the 'pub use' doc comments - because doc comments\nare concatenated as-is, this ensure that the doc comments on the\ndefinition start on a new line.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee9b7a410f955f220e9bbe6ce55c642bafec17b", "html_url": "https://github.com/rust-lang/rust/commit/7ee9b7a410f955f220e9bbe6ce55c642bafec17b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e9b465d729d07101b29b4d096d83edf9be82df0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9b465d729d07101b29b4d096d83edf9be82df0", "html_url": "https://github.com/rust-lang/rust/commit/0e9b465d729d07101b29b4d096d83edf9be82df0"}], "stats": {"total": 97, "additions": 73, "deletions": 24}, "files": [{"sha": "8463fbfbd200b0258c98742d5fbe0eef9370d2f3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7ee9b7a410f955f220e9bbe6ce55c642bafec17b", "patch": "@@ -24,6 +24,8 @@ use crate::clean::{\n \n use super::Clean;\n \n+type Attrs<'hir> = rustc::ty::Attributes<'hir>;\n+\n /// Attempt to inline a definition into this AST.\n ///\n /// This function will fetch the definition specified, and if it is\n@@ -40,6 +42,7 @@ pub fn try_inline(\n     cx: &DocContext<'_>,\n     res: Res,\n     name: ast::Name,\n+    attrs: Option<Attrs<'_>>,\n     visited: &mut FxHashSet<DefId>\n ) -> Option<Vec<clean::Item>> {\n     let did = if let Some(did) = res.opt_def_id() {\n@@ -49,10 +52,13 @@ pub fn try_inline(\n     };\n     if did.is_local() { return None }\n     let mut ret = Vec::new();\n+\n+    let attrs_clone = attrs.clone();\n+\n     let inner = match res {\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, attrs));\n             clean::TraitItem(build_external_trait(cx, did))\n         }\n         Res::Def(DefKind::Fn, did) => {\n@@ -61,27 +67,27 @@ pub fn try_inline(\n         }\n         Res::Def(DefKind::Struct, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, attrs));\n             clean::StructItem(build_struct(cx, did))\n         }\n         Res::Def(DefKind::Union, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Union);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, attrs));\n             clean::UnionItem(build_union(cx, did))\n         }\n         Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, attrs));\n             clean::TypedefItem(build_type_alias(cx, did), false)\n         }\n         Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Enum);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, attrs));\n             clean::EnumItem(build_enum(cx, did))\n         }\n         Res::Def(DefKind::ForeignTy, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Foreign);\n-            ret.extend(build_impls(cx, did));\n+            ret.extend(build_impls(cx, did, attrs));\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n@@ -113,11 +119,15 @@ pub fn try_inline(\n         }\n         _ => return None,\n     };\n+\n+    let target_attrs = load_attrs(cx, did);\n+    let attrs = merge_attrs(cx, target_attrs,  attrs_clone);\n+\n     cx.renderinfo.borrow_mut().inlined.insert(did);\n     ret.push(clean::Item {\n         source: cx.tcx.def_span(did).clean(cx),\n         name: Some(name.clean(cx)),\n-        attrs: load_attrs(cx, did),\n+        attrs,\n         inner,\n         visibility: Some(clean::Public),\n         stability: cx.tcx.lookup_stability(did).clean(cx),\n@@ -144,8 +154,8 @@ pub fn try_inline_glob(cx: &DocContext<'_>, res: Res, visited: &mut FxHashSet<De\n     }\n }\n \n-pub fn load_attrs(cx: &DocContext<'_>, did: DefId) -> clean::Attributes {\n-    cx.tcx.get_attrs(did).clean(cx)\n+pub fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n+    cx.tcx.get_attrs(did)\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n@@ -187,7 +197,7 @@ pub fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n     let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n-    let is_spotlight = load_attrs(cx, did).has_doc_flag(sym::spotlight);\n+    let is_spotlight = load_attrs(cx, did).clean(cx).has_doc_flag(sym::spotlight);\n     let is_auto = cx.tcx.trait_is_auto(did);\n     clean::Trait {\n         auto: auto_trait,\n@@ -274,23 +284,41 @@ fn build_type_alias(cx: &DocContext<'_>, did: DefId) -> clean::Typedef {\n     }\n }\n \n-pub fn build_impls(cx: &DocContext<'_>, did: DefId) -> Vec<clean::Item> {\n+pub fn build_impls(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n     let mut impls = Vec::new();\n \n     for &did in tcx.inherent_impls(did).iter() {\n-        build_impl(cx, did, &mut impls);\n+        build_impl(cx, did, attrs.clone(), &mut impls);\n     }\n \n     impls\n }\n \n-pub fn build_impl(cx: &DocContext<'_>, did: DefId, ret: &mut Vec<clean::Item>) {\n+fn merge_attrs(cx: &DocContext<'_>, attrs: Attrs<'_>, other_attrs: Option<Attrs<'_>>\n+) -> clean::Attributes {\n+    let mut merged_attrs: Vec<ast::Attribute> = Vec::with_capacity(attrs.len());\n+    // If we have additional attributes (from a re-export),\n+    // always insert them first. This ensure that re-export\n+    // doc comments show up before the original doc comments\n+    // when we render them.\n+    if let Some(a) = other_attrs {\n+        merged_attrs.extend(a.iter().cloned());\n+    }\n+    merged_attrs.extend(attrs.to_vec());\n+    merged_attrs.clean(cx)\n+}\n+\n+pub fn build_impl(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>,\n+                  ret: &mut Vec<clean::Item>\n+) {\n     if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n         return\n     }\n \n-    let attrs = load_attrs(cx, did);\n+    let attrs = merge_attrs(cx, load_attrs(cx, did), attrs);\n+\n+\n     let tcx = cx.tcx;\n     let associated_trait = tcx.impl_trait_ref(did);\n \n@@ -416,7 +444,7 @@ fn build_module(\n             let def_id = item.res.def_id();\n             if item.vis == ty::Visibility::Public {\n                 if did == def_id || !visited.insert(def_id) { continue }\n-                if let Some(i) = try_inline(cx, item.res, item.ident.name, visited) {\n+                if let Some(i) = try_inline(cx, item.res, item.ident.name, None, visited) {\n                     items.extend(i)\n                 }\n             }"}, {"sha": "d0b9e9799bea3afdce5173594fcfa148952c586b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7ee9b7a410f955f220e9bbe6ce55c642bafec17b", "patch": "@@ -2429,7 +2429,7 @@ impl Clean<Item> for ty::AssocItem {\n             stability: get_stability(cx, self.def_id),\n             deprecation: get_deprecation(cx, self.def_id),\n             def_id: self.def_id,\n-            attrs: inline::load_attrs(cx, self.def_id),\n+            attrs: inline::load_attrs(cx, self.def_id).clean(cx),\n             source: cx.tcx.def_span(self.def_id).clean(cx),\n             inner,\n         }\n@@ -3372,7 +3372,7 @@ impl Clean<Item> for ty::VariantDef {\n         };\n         Item {\n             name: Some(self.ident.clean(cx)),\n-            attrs: inline::load_attrs(cx, self.def_id),\n+            attrs: inline::load_attrs(cx, self.def_id).clean(cx),\n             source: cx.tcx.def_span(self.def_id).clean(cx),\n             visibility: Some(Inherited),\n             def_id: self.def_id,\n@@ -3856,7 +3856,7 @@ fn build_deref_target_impls(cx: &DocContext<'_>,\n         let primitive = match *target {\n             ResolvedPath { did, .. } if did.is_local() => continue,\n             ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, did));\n+                ret.extend(inline::build_impls(cx, did, None));\n                 continue\n             }\n             _ => match target.primitive_type() {\n@@ -3894,7 +3894,7 @@ fn build_deref_target_impls(cx: &DocContext<'_>,\n         };\n         if let Some(did) = did {\n             if !did.is_local() {\n-                inline::build_impl(cx, did, ret);\n+                inline::build_impl(cx, did, None, ret);\n             }\n         }\n     }\n@@ -3921,7 +3921,11 @@ impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n                 },\n             );\n \n-            if let Some(items) = inline::try_inline(cx, res, self.name, &mut visited) {\n+            if let Some(items) = inline::try_inline(\n+                cx, res, self.name,\n+                Some(rustc::ty::Attributes::Borrowed(self.attrs)),\n+                &mut visited\n+            ) {\n                 return items;\n             }\n         }\n@@ -3981,7 +3985,11 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n             }\n             if !denied {\n                 let mut visited = FxHashSet::default();\n-                if let Some(items) = inline::try_inline(cx, path.res, name, &mut visited) {\n+                if let Some(items) = inline::try_inline(\n+                    cx, path.res, name,\n+                    Some(rustc::ty::Attributes::Borrowed(self.attrs)),\n+                    &mut visited\n+                ) {\n                     return items;\n                 }\n             }"}, {"sha": "cd488b9df78d26c3b3d567c9bf1a4241cccdd366", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=7ee9b7a410f955f220e9bbe6ce55c642bafec17b", "patch": "@@ -30,7 +30,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n     for &cnum in cx.tcx.crates().iter() {\n         for &did in cx.tcx.all_trait_implementations(cnum).iter() {\n-            inline::build_impl(cx, did, &mut new_items);\n+            inline::build_impl(cx, did, None, &mut new_items);\n         }\n     }\n \n@@ -66,7 +66,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n     for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n         if !def_id.is_local() {\n-            inline::build_impl(cx, def_id, &mut new_items);\n+            inline::build_impl(cx, def_id, None, &mut new_items);\n \n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n             if !cx.tcx.get_attrs(def_id).lists(sym::doc).has_word(sym::hidden) {\n@@ -119,7 +119,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     for &trait_did in cx.all_traits.iter() {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n             let impl_did = cx.tcx.hir().local_def_id(impl_node);\n-            inline::build_impl(cx, impl_did, &mut new_items);\n+            inline::build_impl(cx, impl_did, None, &mut new_items);\n         }\n     }\n "}, {"sha": "1af5e8f03b44e2d7291892e0aede8ca75fe2004c", "filename": "src/test/rustdoc/inline_cross/add-docs.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/src%2Ftest%2Frustdoc%2Finline_cross%2Fadd-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/src%2Ftest%2Frustdoc%2Finline_cross%2Fadd-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fadd-docs.rs?ref=7ee9b7a410f955f220e9bbe6ce55c642bafec17b", "patch": "@@ -0,0 +1,9 @@\n+// aux-build:add-docs.rs\n+\n+extern crate inner;\n+\n+\n+// @has add_docs/struct.MyStruct.html\n+// @has add_docs/struct.MyStruct.html \"Doc comment from 'pub use', Doc comment from definition\"\n+/// Doc comment from 'pub use',\n+pub use inner::MyStruct;"}, {"sha": "85efa508f30b528f191842fcddcfb65705a3fcf6", "filename": "src/test/rustdoc/inline_cross/auxiliary/add-docs.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fadd-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ee9b7a410f955f220e9bbe6ce55c642bafec17b/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fadd-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fadd-docs.rs?ref=7ee9b7a410f955f220e9bbe6ce55c642bafec17b", "patch": "@@ -0,0 +1,4 @@\n+#![crate_name = \"inner\"]\n+\n+/// Doc comment from definition\n+pub struct MyStruct;"}]}