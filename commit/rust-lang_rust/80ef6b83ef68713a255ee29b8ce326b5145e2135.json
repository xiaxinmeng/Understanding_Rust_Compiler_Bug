{"sha": "80ef6b83ef68713a255ee29b8ce326b5145e2135", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZWY2YjgzZWY2ODcxM2EyNTVlZTI5YjhjZTMyNmI1MTQ1ZTIxMzU=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-14T17:29:29Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-16T15:26:57Z"}, "message": "Extend HashSet documentation.\n\nAdd main example and simple examples for the methods.", "tree": {"sha": "fa2c358bcb39711f96a7a3b3495a50e41b70b4a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa2c358bcb39711f96a7a3b3495a50e41b70b4a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80ef6b83ef68713a255ee29b8ce326b5145e2135", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80ef6b83ef68713a255ee29b8ce326b5145e2135", "html_url": "https://github.com/rust-lang/rust/commit/80ef6b83ef68713a255ee29b8ce326b5145e2135", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80ef6b83ef68713a255ee29b8ce326b5145e2135/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "058242141b54bf9e9b82caf02a39c4b9083023c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/058242141b54bf9e9b82caf02a39c4b9083023c1", "html_url": "https://github.com/rust-lang/rust/commit/058242141b54bf9e9b82caf02a39c4b9083023c1"}], "stats": {"total": 163, "additions": 159, "deletions": 4}, "files": [{"sha": "9a53c941377e44be6bc29810d392bdc92711825e", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 159, "deletions": 4, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/80ef6b83ef68713a255ee29b8ce326b5145e2135/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ef6b83ef68713a255ee29b8ce326b5145e2135/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=80ef6b83ef68713a255ee29b8ce326b5145e2135", "patch": "@@ -1484,6 +1484,36 @@ pub type SetMoveItems<K> =\n /// An implementation of a hash set using the underlying representation of a\n /// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n /// requires that the elements implement the `Eq` and `Hash` traits.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::collections::HashSet;\n+///\n+/// // Type inference lets us omit an explicit type signature (which\n+/// // would be `HashSet<&str>` in this example).\n+/// let mut books = HashSet::new();\n+///\n+/// // Add some books.\n+/// books.insert(\"A Dance With Dragons\");\n+/// books.insert(\"To Kill a Mockingbird\");\n+/// books.insert(\"The Odyssey\");\n+/// books.insert(\"The Great Gatsby\");\n+///\n+/// // Check for a specific one.\n+/// if !books.contains(&(\"The Winds of Winter\")) {\n+///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n+///              books.len());\n+/// }\n+///\n+/// // Remove a book.\n+/// books.remove(&\"The Odyssey\");\n+///\n+/// // Iterate over everything.\n+/// for book in books.iter() {\n+///     println!(\"{}\", *book);\n+/// }\n+/// ```\n #[deriving(Clone)]\n pub struct HashSet<T, H = RandomSipHasher> {\n     map: HashMap<T, (), H>\n@@ -1527,13 +1557,27 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n \n impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// Create an empty HashSet\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let mut set: HashSet<int> = HashSet::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> HashSet<T, RandomSipHasher> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Create an empty HashSet with space for at least `n` elements in\n     /// the hash table.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n+    /// ```\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n@@ -1563,6 +1607,14 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     }\n \n     /// Reserve space for at least `n` elements in the hash table.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let mut set: HashSet<int> = HashSet::new();\n+    /// set.reserve(10);\n+    /// ```\n     pub fn reserve(&mut self, n: uint) {\n         self.map.reserve(n)\n     }\n@@ -1575,32 +1627,119 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n \n     /// An iterator visiting all elements in arbitrary order.\n     /// Iterator element type is &'a T.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(\"a\");\n+    /// set.insert(\"b\");\n+    ///\n+    /// // Will print in an arbitrary order.\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n         self.map.keys()\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out\n     /// of the set in arbitrary order. The set cannot be used after calling\n     /// this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(\"a\".to_string());\n+    /// set.insert(\"b\".to_string());\n+    ///\n+    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n+    /// let v: Vec<String> = set.move_iter().collect();\n+    ///\n+    /// // Will print in an arbitrary order.\n+    /// for x in v.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     pub fn move_iter(self) -> SetMoveItems<T> {\n         self.map.move_iter().map(|(k, _)| k)\n     }\n \n-    /// Visit the values representing the difference\n+    /// Visit the values representing the difference.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Can be seen as `a - b`.\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x); // Print 1\n+    /// }\n+    ///\n+    /// let diff: HashSet<int> = a.difference(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1i].iter().map(|&x| x).collect());\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else:\n+    /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n+    /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> {\n         Repeat::new(other).zip(self.iter())\n             .filter_map(|(other, elt)| {\n                 if !other.contains(elt) { Some(elt) } else { None }\n             })\n     }\n \n-    /// Visit the values representing the symmetric difference\n+    /// Visit the values representing the symmetric difference.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 4 in arbitrary order.\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff1: HashSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n+    /// let diff2: HashSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(diff1, diff2);\n+    /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>> {\n         self.difference(other).chain(other.difference(self))\n     }\n \n-    /// Visit the values representing the intersection\n+    /// Visit the values representing the intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 2, 3 in arbitrary order.\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> SetAlgebraItems<'a, T, H> {\n         Repeat::new(other).zip(self.iter())\n@@ -1609,7 +1748,23 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n             })\n     }\n \n-    /// Visit the values representing the union\n+    /// Visit the values representing the union.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// # use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 3, 4 in arbitrary order.\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>> {\n         self.iter().chain(other.difference(self))"}]}