{"sha": "03b324ff4481255a371bb234fc3e53bcb8d08e7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYjMyNGZmNDQ4MTI1NWEzNzFiYjIzNGZjM2U1M2JjYjhkMDhlN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T08:26:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-14T08:26:47Z"}, "message": "auto merge of #12186 : alexcrichton/rust/no-sleep-2, r=brson\n\nAny single-threaded task benchmark will spend a good chunk of time in `kqueue()` on osx and `epoll()` on linux, and the reason for this is that each time a task is terminated it will hit the syscall. When a task terminates, it context switches back to the scheduler thread, and the scheduler thread falls out of `run_sched_once` whenever it figures out that it did some work.\r\n\r\nIf we know that `epoll()` will return nothing, then we can continue to do work locally (only while there's work to be done). We must fall back to `epoll()` whenever there's active I/O in order to check whether it's ready or not, but without that (which is largely the case in benchmarks), we can prevent the costly syscall and can get a nice speedup.\r\n\r\nI've separated the commits into preparation for this change and then the change itself, the last commit message has more details.", "tree": {"sha": "0ff6f6307f936d2b2eced588c60b3dd2bc568e6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ff6f6307f936d2b2eced588c60b3dd2bc568e6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03b324ff4481255a371bb234fc3e53bcb8d08e7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03b324ff4481255a371bb234fc3e53bcb8d08e7e", "html_url": "https://github.com/rust-lang/rust/commit/03b324ff4481255a371bb234fc3e53bcb8d08e7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03b324ff4481255a371bb234fc3e53bcb8d08e7e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fe7bfe4d2de9942449d3656317e66bc9ec50204", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fe7bfe4d2de9942449d3656317e66bc9ec50204", "html_url": "https://github.com/rust-lang/rust/commit/2fe7bfe4d2de9942449d3656317e66bc9ec50204"}, {"sha": "2650b61505e5ed5ac3075451a73e64fd226f5b10", "url": "https://api.github.com/repos/rust-lang/rust/commits/2650b61505e5ed5ac3075451a73e64fd226f5b10", "html_url": "https://github.com/rust-lang/rust/commit/2650b61505e5ed5ac3075451a73e64fd226f5b10"}], "stats": {"total": 242, "additions": 157, "deletions": 85}, "files": [{"sha": "5bccf05f7b3f6ed4f661dd1173fcb433fdcc6c22", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -158,6 +158,8 @@ impl EventLoop for BasicLoop {\n     }\n \n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> { None }\n+\n+    fn has_active_io(&self) -> bool { false }\n }\n \n struct BasicRemote {"}, {"sha": "4b1c4e3b425d4da9822c603ddccccc494defa054", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 97, "deletions": 60, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -252,12 +252,23 @@ impl Scheduler {\n \n     // * Execution Functions - Core Loop Logic\n \n-    // The model for this function is that you continue through it\n-    // until you either use the scheduler while performing a schedule\n-    // action, in which case you give it away and return early, or\n-    // you reach the end and sleep. In the case that a scheduler\n-    // action is performed the loop is evented such that this function\n-    // is called again.\n+    // This function is run from the idle callback on the uv loop, indicating\n+    // that there are no I/O events pending. When this function returns, we will\n+    // fall back to epoll() in the uv event loop, waiting for more things to\n+    // happen. We may come right back off epoll() if the idle callback is still\n+    // active, in which case we're truly just polling to see if I/O events are\n+    // complete.\n+    //\n+    // The model for this function is to execute as much work as possible while\n+    // still fairly considering I/O tasks. Falling back to epoll() frequently is\n+    // often quite expensive, so we attempt to avoid it as much as possible. If\n+    // we have any active I/O on the event loop, then we're forced to fall back\n+    // to epoll() in order to provide fairness, but as long as we're doing work\n+    // and there's no active I/O, we can continue to do work.\n+    //\n+    // If we try really hard to do some work, but no work is available to be\n+    // done, then we fall back to epoll() to block this thread waiting for more\n+    // work (instead of busy waiting).\n     fn run_sched_once(mut ~self, stask: ~GreenTask) {\n         // Make sure that we're not lying in that the `stask` argument is indeed\n         // the scheduler task for this scheduler.\n@@ -269,26 +280,46 @@ impl Scheduler {\n \n         // First we check for scheduler messages, these are higher\n         // priority than regular tasks.\n-        let (sched, stask) =\n-            match self.interpret_message_queue(stask, DontTryTooHard) {\n-                Some(pair) => pair,\n-                None => return\n-            };\n-\n-        // This helper will use a randomized work-stealing algorithm\n-        // to find work.\n-        let (sched, stask) = match sched.do_work(stask) {\n-            Some(pair) => pair,\n-            None => return\n-        };\n+        let (mut sched, mut stask, mut did_work) =\n+            self.interpret_message_queue(stask, DontTryTooHard);\n \n-        // Now, before sleeping we need to find out if there really\n-        // were any messages. Give it your best!\n-        let (mut sched, stask) =\n-            match sched.interpret_message_queue(stask, GiveItYourBest) {\n-                Some(pair) => pair,\n-                None => return\n+        // After processing a message, we consider doing some more work on the\n+        // event loop. The \"keep going\" condition changes after the first\n+        // iteration becase we don't want to spin here infinitely.\n+        //\n+        // Once we start doing work we can keep doing work so long as the\n+        // iteration does something. Note that we don't want to starve the\n+        // message queue here, so each iteration when we're done working we\n+        // check the message queue regardless of whether we did work or not.\n+        let mut keep_going = !did_work || !sched.event_loop.has_active_io();\n+        while keep_going {\n+            let (a, b, c) = match sched.do_work(stask) {\n+                (sched, task, false) => {\n+                    sched.interpret_message_queue(task, GiveItYourBest)\n+                }\n+                (sched, task, true) => {\n+                    let (sched, task, _) =\n+                        sched.interpret_message_queue(task, GiveItYourBest);\n+                    (sched, task, true)\n+                }\n             };\n+            sched = a;\n+            stask = b;\n+            did_work = c;\n+\n+            // We only keep going if we managed to do something productive and\n+            // also don't have any active I/O. If we didn't do anything, we\n+            // should consider going to sleep, and if we have active I/O we need\n+            // to poll for completion.\n+            keep_going = did_work && !sched.event_loop.has_active_io();\n+        }\n+\n+        // If we ever did some work, then we shouldn't put our scheduler\n+        // entirely to sleep just yet. Leave the idle callback active and fall\n+        // back to epoll() to see what's going on.\n+        if did_work {\n+            return stask.put_with_sched(sched);\n+        }\n \n         // If we got here then there was no work to do.\n         // Generate a SchedHandle and push it to the sleeper list so\n@@ -318,7 +349,7 @@ impl Scheduler {\n     // return None.\n     fn interpret_message_queue(mut ~self, stask: ~GreenTask,\n                                effort: EffortLevel)\n-        -> Option<(~Scheduler, ~GreenTask)>\n+            -> (~Scheduler, ~GreenTask, bool)\n     {\n \n         let msg = if effort == DontTryTooHard {\n@@ -349,25 +380,25 @@ impl Scheduler {\n             Some(PinnedTask(task)) => {\n                 let mut task = task;\n                 task.give_home(HomeSched(self.make_handle()));\n-                self.resume_task_immediately(stask, task).put();\n-                return None;\n+                let (sched, task) = self.resume_task_immediately(stask, task);\n+                (sched, task, true)\n             }\n             Some(TaskFromFriend(task)) => {\n                 rtdebug!(\"got a task from a friend. lovely!\");\n-                self.process_task(stask, task,\n-                                  Scheduler::resume_task_immediately_cl);\n-                return None;\n+                let (sched, task) =\n+                    self.process_task(stask, task,\n+                                      Scheduler::resume_task_immediately_cl);\n+                (sched, task, true)\n             }\n             Some(RunOnce(task)) => {\n                 // bypass the process_task logic to force running this task once\n                 // on this home scheduler. This is often used for I/O (homing).\n-                self.resume_task_immediately(stask, task).put();\n-                return None;\n+                let (sched, task) = self.resume_task_immediately(stask, task);\n+                (sched, task, true)\n             }\n             Some(Wake) => {\n                 self.sleepy = false;\n-                stask.put_with_sched(self);\n-                return None;\n+                (self, stask, true)\n             }\n             Some(Shutdown) => {\n                 rtdebug!(\"shutting down\");\n@@ -389,31 +420,30 @@ impl Scheduler {\n                 // event loop references we will shut down.\n                 self.no_sleep = true;\n                 self.sleepy = false;\n-                stask.put_with_sched(self);\n-                return None;\n+                (self, stask, true)\n             }\n             Some(NewNeighbor(neighbor)) => {\n                 self.work_queues.push(neighbor);\n-                return Some((self, stask));\n-            }\n-            None => {\n-                return Some((self, stask));\n+                (self, stask, false)\n             }\n+            None => (self, stask, false)\n         }\n     }\n \n-    fn do_work(mut ~self, stask: ~GreenTask) -> Option<(~Scheduler, ~GreenTask)> {\n+    fn do_work(mut ~self,\n+               stask: ~GreenTask) -> (~Scheduler, ~GreenTask, bool) {\n         rtdebug!(\"scheduler calling do work\");\n         match self.find_work() {\n             Some(task) => {\n                 rtdebug!(\"found some work! running the task\");\n-                self.process_task(stask, task,\n-                                  Scheduler::resume_task_immediately_cl);\n-                return None;\n+                let (sched, task) =\n+                    self.process_task(stask, task,\n+                                      Scheduler::resume_task_immediately_cl);\n+                (sched, task, true)\n             }\n             None => {\n                 rtdebug!(\"no work was found, returning the scheduler struct\");\n-                return Some((self, stask));\n+                (self, stask, false)\n             }\n         }\n     }\n@@ -486,7 +516,8 @@ impl Scheduler {\n     // place.\n \n     fn process_task(mut ~self, cur: ~GreenTask,\n-                    mut next: ~GreenTask, schedule_fn: SchedulingFn) {\n+                    mut next: ~GreenTask,\n+                    schedule_fn: SchedulingFn) -> (~Scheduler, ~GreenTask) {\n         rtdebug!(\"processing a task\");\n \n         match next.take_unwrap_home() {\n@@ -495,23 +526,23 @@ impl Scheduler {\n                     rtdebug!(\"sending task home\");\n                     next.give_home(HomeSched(home_handle));\n                     Scheduler::send_task_home(next);\n-                    cur.put_with_sched(self);\n+                    (self, cur)\n                 } else {\n                     rtdebug!(\"running task here\");\n                     next.give_home(HomeSched(home_handle));\n-                    schedule_fn(self, cur, next);\n+                    schedule_fn(self, cur, next)\n                 }\n             }\n             AnySched if self.run_anything => {\n                 rtdebug!(\"running anysched task here\");\n                 next.give_home(AnySched);\n-                schedule_fn(self, cur, next);\n+                schedule_fn(self, cur, next)\n             }\n             AnySched => {\n                 rtdebug!(\"sending task to friend\");\n                 next.give_home(AnySched);\n                 self.send_to_friend(next);\n-                cur.put_with_sched(self);\n+                (self, cur)\n             }\n         }\n     }\n@@ -664,18 +695,19 @@ impl Scheduler {\n     // * Context Swapping Helpers - Here be ugliness!\n \n     pub fn resume_task_immediately(~self, cur: ~GreenTask,\n-                                   next: ~GreenTask) -> ~GreenTask {\n+                                   next: ~GreenTask) -> (~Scheduler, ~GreenTask) {\n         assert!(cur.is_sched());\n-        self.change_task_context(cur, next, |sched, stask| {\n+        let mut cur = self.change_task_context(cur, next, |sched, stask| {\n             assert!(sched.sched_task.is_none());\n             sched.sched_task = Some(stask);\n-        })\n+        });\n+        (cur.sched.take_unwrap(), cur)\n     }\n \n     fn resume_task_immediately_cl(sched: ~Scheduler,\n                                   cur: ~GreenTask,\n-                                  next: ~GreenTask) {\n-        sched.resume_task_immediately(cur, next).put()\n+                                  next: ~GreenTask) -> (~Scheduler, ~GreenTask) {\n+        sched.resume_task_immediately(cur, next)\n     }\n \n     /// Block a running task, context switch to the scheduler, then pass the\n@@ -741,15 +773,17 @@ impl Scheduler {\n         cur.put();\n     }\n \n-    fn switch_task(sched: ~Scheduler, cur: ~GreenTask, next: ~GreenTask) {\n-        sched.change_task_context(cur, next, |sched, last_task| {\n+    fn switch_task(sched: ~Scheduler, cur: ~GreenTask,\n+                   next: ~GreenTask) -> (~Scheduler, ~GreenTask) {\n+        let mut cur = sched.change_task_context(cur, next, |sched, last_task| {\n             if last_task.is_sched() {\n                 assert!(sched.sched_task.is_none());\n                 sched.sched_task = Some(last_task);\n             } else {\n                 sched.enqueue_task(last_task);\n             }\n-        }).put()\n+        });\n+        (cur.sched.take_unwrap(), cur)\n     }\n \n     // * Task Context Helpers\n@@ -769,7 +803,9 @@ impl Scheduler {\n     }\n \n     pub fn run_task(~self, cur: ~GreenTask, next: ~GreenTask) {\n-        self.process_task(cur, next, Scheduler::switch_task);\n+        let (sched, task) =\n+            self.process_task(cur, next, Scheduler::switch_task);\n+        task.put_with_sched(sched);\n     }\n \n     pub fn run_task_later(mut cur: ~GreenTask, next: ~GreenTask) {\n@@ -836,7 +872,8 @@ impl Scheduler {\n \n // Supporting types\n \n-type SchedulingFn = extern \"Rust\" fn (~Scheduler, ~GreenTask, ~GreenTask);\n+type SchedulingFn = fn (~Scheduler, ~GreenTask, ~GreenTask)\n+                            -> (~Scheduler, ~GreenTask);\n \n pub enum SchedMessage {\n     Wake,"}, {"sha": "5d6af2969b8b3ba21434ed72f589e26bd103e234", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -86,7 +86,7 @@ impl GetAddrInfoRequest {\n                 req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { slot: None, status: 0, addrinfo: None };\n \n-                wait_until_woken_after(&mut cx.slot, || {\n+                wait_until_woken_after(&mut cx.slot, loop_, || {\n                     req.set_data(&cx);\n                 });\n "}, {"sha": "e66452041a5315fec507cbac63528d10a5e6a302", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -304,7 +304,8 @@ fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n         0 => {\n             req.fired = true;\n             let mut slot = None;\n-            wait_until_woken_after(&mut slot, || {\n+            let loop_ = unsafe { uvll::get_loop_from_fs_req(req.req) };\n+            wait_until_woken_after(&mut slot, &Loop::wrap(loop_), || {\n                 unsafe { uvll::set_data_for_req(req.req, &slot) }\n             });\n             match req.get_result() {"}, {"sha": "8c263c5e5f738231aa9f8075deb549019fc2c0a0", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -47,7 +47,7 @@ via `close` and `delete` methods.\n use std::cast;\n use std::io;\n use std::io::IoError;\n-use std::libc::c_int;\n+use std::libc::{c_int, c_void};\n use std::ptr::null;\n use std::ptr;\n use std::rt::local::Local;\n@@ -95,6 +95,10 @@ pub mod stream;\n pub trait UvHandle<T> {\n     fn uv_handle(&self) -> *T;\n \n+    fn uv_loop(&self) -> Loop {\n+        Loop::wrap(unsafe { uvll::get_loop_for_uv_handle(self.uv_handle()) })\n+    }\n+\n     // FIXME(#8888) dummy self\n     fn alloc(_: Option<Self>, ty: uvll::uv_handle_type) -> *T {\n         unsafe {\n@@ -136,7 +140,7 @@ pub trait UvHandle<T> {\n             uvll::uv_close(self.uv_handle() as *uvll::uv_handle_t, close_cb);\n             uvll::set_data_for_uv_handle(self.uv_handle(), ptr::null::<()>());\n \n-            wait_until_woken_after(&mut slot, || {\n+            wait_until_woken_after(&mut slot, &self.uv_loop(), || {\n                 uvll::set_data_for_uv_handle(self.uv_handle(), &slot);\n             })\n         }\n@@ -195,16 +199,20 @@ impl Drop for ForbidUnwind {\n     }\n }\n \n-fn wait_until_woken_after(slot: *mut Option<BlockedTask>, f: ||) {\n+fn wait_until_woken_after(slot: *mut Option<BlockedTask>,\n+                          loop_: &Loop,\n+                          f: ||) {\n     let _f = ForbidUnwind::new(\"wait_until_woken_after\");\n     unsafe {\n         assert!((*slot).is_none());\n         let task: ~Task = Local::take();\n+        loop_.modify_blockers(1);\n         task.deschedule(1, |task| {\n             *slot = Some(task);\n             f();\n             Ok(())\n         });\n+        loop_.modify_blockers(-1);\n     }\n }\n \n@@ -273,6 +281,7 @@ impl Loop {\n     pub fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n         assert!(handle.is_not_null());\n+        unsafe { uvll::set_data_for_uv_loop(handle, 0 as *c_void) }\n         Loop::wrap(handle)\n     }\n \n@@ -285,6 +294,19 @@ impl Loop {\n     pub fn close(&mut self) {\n         unsafe { uvll::uv_loop_delete(self.handle) };\n     }\n+\n+    // The 'data' field of the uv_loop_t is used to count the number of tasks\n+    // that are currently blocked waiting for I/O to complete.\n+    fn modify_blockers(&self, amt: uint) {\n+        unsafe {\n+            let cur = uvll::get_data_for_uv_loop(self.handle) as uint;\n+            uvll::set_data_for_uv_loop(self.handle, (cur + amt) as *c_void)\n+        }\n+    }\n+\n+    fn get_blockers(&self) -> uint {\n+        unsafe { uvll::get_data_for_uv_loop(self.handle) as uint }\n+    }\n }\n \n // FIXME: Need to define the error constants like EOF so they can be"}, {"sha": "a091829f297e86b4435eb06c0683d5e2c2b4f6d1", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -216,7 +216,7 @@ impl TcpWatcher {\n             0 => {\n                 req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { status: 0, task: None };\n-                wait_until_woken_after(&mut cx.task, || {\n+                wait_until_woken_after(&mut cx.task, &io.loop_, || {\n                     req.set_data(&cx);\n                 });\n                 match cx.status {\n@@ -498,6 +498,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             buf: Option<Buf>,\n             result: Option<(ssize_t, Option<ip::SocketAddr>)>,\n         }\n+        let loop_ = self.uv_loop();\n         let m = self.fire_homing_missile();\n         let _g = self.read_access.grant(m);\n \n@@ -511,7 +512,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                     result: None,\n                 };\n                 let handle = self.handle;\n-                wait_until_woken_after(&mut cx.task, || {\n+                wait_until_woken_after(&mut cx.task, &loop_, || {\n                     unsafe { uvll::set_data_for_uv_handle(handle, &cx) }\n                 });\n                 match cx.result.take_unwrap() {\n@@ -571,6 +572,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         struct Ctx { task: Option<BlockedTask>, result: c_int }\n \n         let m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n         let _g = self.write_access.grant(m);\n \n         let mut req = Request::new(uvll::UV_UDP_SEND);\n@@ -586,7 +588,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             0 => {\n                 req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { task: None, result: 0 };\n-                wait_until_woken_after(&mut cx.task, || {\n+                wait_until_woken_after(&mut cx.task, &loop_, || {\n                     req.set_data(&cx);\n                 });\n                 match cx.result {"}, {"sha": "24ac17700cc2748148b2426964ee041367d6ecc2", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -92,7 +92,7 @@ impl PipeWatcher {\n         let mut req = Request::new(uvll::UV_CONNECT);\n         let pipe = PipeWatcher::new(io, false);\n \n-        wait_until_woken_after(&mut cx.task, || {\n+        wait_until_woken_after(&mut cx.task, &io.loop_, || {\n             unsafe {\n                 uvll::uv_pipe_connect(req.handle,\n                                       pipe.handle(),"}, {"sha": "e1f94d8c4df5a2bd99576d93d9b58f4be7d8aecc", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -211,7 +211,7 @@ impl RtioProcess for Process {\n                 // If there's no exit code previously listed, then the\n                 // process's exit callback has yet to be invoked. We just\n                 // need to deschedule ourselves and wait to be reawoken.\n-                wait_until_woken_after(&mut self.to_wake, || {});\n+                wait_until_woken_after(&mut self.to_wake, &self.uv_loop(), || {});\n                 assert!(self.exit_status.is_some());\n             }\n         }"}, {"sha": "f7bf2f051eb90c5029176b0e29f40bc3ebad3169", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -13,6 +13,7 @@ use std::libc::{c_int, size_t, ssize_t};\n use std::ptr;\n use std::rt::task::BlockedTask;\n \n+use Loop;\n use super::{UvError, Buf, slice_to_uv_buf, Request, wait_until_woken_after,\n             ForbidUnwind, wakeup};\n use uvll;\n@@ -87,7 +88,8 @@ impl StreamWatcher {\n             uvll::uv_read_start(self.handle, alloc_cb, read_cb)\n         } {\n             0 => {\n-                wait_until_woken_after(&mut rcx.task, || {});\n+                let loop_ = unsafe { uvll::get_loop_for_uv_handle(self.handle) };\n+                wait_until_woken_after(&mut rcx.task, &Loop::wrap(loop_), || {});\n                 match rcx.result {\n                     n if n < 0 => Err(UvError(n as c_int)),\n                     n => Ok(n as uint),\n@@ -121,7 +123,8 @@ impl StreamWatcher {\n                 let mut wcx = WriteContext { result: 0, task: None, };\n                 req.defuse(); // uv callback now owns this request\n \n-                wait_until_woken_after(&mut wcx.task, || {\n+                let loop_ = unsafe { uvll::get_loop_for_uv_handle(self.handle) };\n+                wait_until_woken_after(&mut wcx.task, &Loop::wrap(loop_), || {\n                     req.set_data(&wcx);\n                 });\n                 self.last_write_req = Some(Request::wrap(req.handle));"}, {"sha": "8c80cc991450483d12653697db01562130ca7d00", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -9,25 +9,25 @@\n // except according to those terms.\n \n use std::libc::c_int;\n-use std::mem::replace;\n-use std::rt::local::Local;\n+use std::mem;\n use std::rt::rtio::RtioTimer;\n-use std::rt::task::{BlockedTask, Task};\n+use std::rt::task::BlockedTask;\n \n use homing::{HomeHandle, HomingIO};\n-use super::{UvHandle, ForbidUnwind, ForbidSwitch};\n+use super::{UvHandle, ForbidUnwind, ForbidSwitch, wait_until_woken_after};\n use uvio::UvIoFactory;\n use uvll;\n \n pub struct TimerWatcher {\n     handle: *uvll::uv_timer_t,\n     home: HomeHandle,\n     action: Option<NextAction>,\n+    blocker: Option<BlockedTask>,\n     id: uint, // see comments in timer_cb\n }\n \n pub enum NextAction {\n-    WakeTask(BlockedTask),\n+    WakeTask,\n     SendOnce(Chan<()>),\n     SendMany(Chan<()>, uint),\n }\n@@ -41,6 +41,7 @@ impl TimerWatcher {\n         let me = ~TimerWatcher {\n             handle: handle,\n             action: None,\n+            blocker: None,\n             home: io.make_handle(),\n             id: 0,\n         };\n@@ -76,7 +77,7 @@ impl RtioTimer for TimerWatcher {\n         let missile = self.fire_homing_missile();\n         self.id += 1;\n         self.stop();\n-        let _missile = match replace(&mut self.action, None) {\n+        let _missile = match mem::replace(&mut self.action, None) {\n             None => missile, // no need to do a homing dance\n             Some(action) => {\n                 drop(missile);      // un-home ourself\n@@ -89,11 +90,9 @@ impl RtioTimer for TimerWatcher {\n         // started, then we need to call stop on the timer.\n         let _f = ForbidUnwind::new(\"timer\");\n \n-        let task: ~Task = Local::take();\n-        task.deschedule(1, |task| {\n-            self.action = Some(WakeTask(task));\n+        self.action = Some(WakeTask);\n+        wait_until_woken_after(&mut self.blocker, &self.uv_loop(), || {\n             self.start(msecs, 0);\n-            Ok(())\n         });\n         self.stop();\n     }\n@@ -108,7 +107,7 @@ impl RtioTimer for TimerWatcher {\n             self.id += 1;\n             self.stop();\n             self.start(msecs, 0);\n-            replace(&mut self.action, Some(SendOnce(chan)))\n+            mem::replace(&mut self.action, Some(SendOnce(chan)))\n         };\n \n         return port;\n@@ -124,7 +123,7 @@ impl RtioTimer for TimerWatcher {\n             self.id += 1;\n             self.stop();\n             self.start(msecs, msecs);\n-            replace(&mut self.action, Some(SendMany(chan, self.id)))\n+            mem::replace(&mut self.action, Some(SendMany(chan, self.id)))\n         };\n \n         return port;\n@@ -137,7 +136,8 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n     let timer: &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n \n     match timer.action.take_unwrap() {\n-        WakeTask(task) => {\n+        WakeTask => {\n+            let task = timer.blocker.take_unwrap();\n             let _ = task.wake().map(|t| t.reawaken());\n         }\n         SendOnce(chan) => { let _ = chan.try_send(()); }"}, {"sha": "14406cb2a6a0146b6f3d21d699fb0b739f615100", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -99,6 +99,10 @@ impl rtio::EventLoop for UvEventLoop {\n         let factory = &mut self.uvio as &mut rtio::IoFactory;\n         Some(factory)\n     }\n+\n+    fn has_active_io(&self) -> bool {\n+        self.uvio.loop_.get_blockers() > 0\n+    }\n }\n \n #[cfg(not(test))]"}, {"sha": "5573f8ec02eb3c17e457a22cf57336958f1139cd", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b324ff4481255a371bb234fc3e53bcb8d08e7e/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=03b324ff4481255a371bb234fc3e53bcb8d08e7e", "patch": "@@ -41,6 +41,7 @@ pub trait EventLoop {\n \n     /// The asynchronous I/O services. Not all event loops may provide one.\n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;\n+    fn has_active_io(&self) -> bool;\n }\n \n pub trait RemoteCallback {"}]}