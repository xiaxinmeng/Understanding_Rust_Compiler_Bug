{"sha": "3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYTJiYzRlOTM1ZTI3MzI2OGYzZjZkOGRlNDVhMjcwNDJkYzVlNDg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-14T12:00:25Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-20T11:46:00Z"}, "message": "Refactor away `ast::Attribute_`.", "tree": {"sha": "4def39226f97e50bebf099a93857735bc3c77bb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4def39226f97e50bebf099a93857735bc3c77bb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "html_url": "https://github.com/rust-lang/rust/commit/3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfa709a38a8c607e1c13ee5635fbfd1940eb18b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa709a38a8c607e1c13ee5635fbfd1940eb18b1", "html_url": "https://github.com/rust-lang/rust/commit/bfa709a38a8c607e1c13ee5635fbfd1940eb18b1"}], "stats": {"total": 178, "additions": 85, "deletions": 93}, "files": [{"sha": "e9d2aa7e7750c4af5320c1d196058144364949f3", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -405,7 +405,7 @@ pub fn gather_attr(attr: &ast::Attribute)\n \n     attr::mark_used(attr);\n \n-    let meta = &attr.node.value;\n+    let meta = &attr.value;\n     let metas = if let Some(metas) = meta.meta_item_list() {\n         metas\n     } else {"}, {"sha": "21c628d18bac95d86ad28fc7c127a6c2fa6ab2ef", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -914,7 +914,7 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         let indices = self.indices_sorted_by(attributes, |attr| attr.name());\n \n         for i in indices {\n-            let attr = &attributes[i].node;\n+            let attr = &attributes[i];\n             if !attr.is_sugared_doc &&\n                !IGNORED_ATTRIBUTES.contains(&&*attr.value.name()) {\n                 SawAttribute(attr.style).hash(self.st);"}, {"sha": "aaca823369bf8bbf980d4a9bec8aabd6a74817d7", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -277,7 +277,7 @@ impl LateLintPass for UnusedAttributes {\n                 .find(|&&(ref x, t)| &*attr.name() == x && AttributeType::CrateLevel == t)\n                 .is_some();\n             if known_crate || plugin_crate {\n-                let msg = match attr.node.style {\n+                let msg = match attr.style {\n                     ast::AttrStyle::Outer => {\n                         \"crate-level attribute should be an inner attribute: add an exclamation \\\n                          mark: #![foo]\""}, {"sha": "fb1314992c094d0596ab1618c618a69e112383ec", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -934,7 +934,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .decode(self)\n             .map(|mut attr| {\n                 // Need new unique IDs: old thread-local IDs won't map to new threads.\n-                attr.node.id = attr::mk_attr_id();\n+                attr.id = attr::mk_attr_id();\n                 attr\n             })\n             .collect()"}, {"sha": "dafb7bc6e60996d67482cb982f4e83b19071e9cf", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -240,7 +240,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n-        self.record(\"Attribute\", Id::Attr(attr.node.id), attr);\n+        self.record(\"Attribute\", Id::Attr(attr.id), attr);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef) {\n         self.record(\"MacroDef\", Id::Node(macro_def.id), macro_def);"}, {"sha": "5d743fc5d4e4db17faf4717eb154308cb54e33d0", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -607,7 +607,7 @@ impl<'b> Resolver<'b> {\n             if attr.check_name(\"macro_escape\") {\n                 let msg = \"macro_escape is a deprecated synonym for macro_use\";\n                 let mut err = self.session.struct_span_warn(attr.span, msg);\n-                if let ast::AttrStyle::Inner = attr.node.style {\n+                if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n                 } else {\n                     err.emit();"}, {"sha": "c8e350e475af16a412ca2e0be3e36af998cda1cb", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -734,7 +734,7 @@ fn docs_for_attrs(attrs: &[Attribute]) -> String {\n     for attr in attrs {\n         if attr.name() == doc {\n             if let Some(ref val) = attr.value_str() {\n-                if attr.node.is_sugared_doc {\n+                if attr.is_sugared_doc {\n                     result.push_str(&strip_doc_comment_decoration(val));\n                 } else {\n                     result.push_str(val);"}, {"sha": "bc6d21cab642fd21f989f048a2a191fd16c6c640", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -1755,8 +1755,6 @@ impl ViewPath_ {\n     }\n }\n \n-/// Meta-data associated with an item\n-pub type Attribute = Spanned<Attribute_>;\n \n /// Distinguishes between Attributes that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n@@ -1770,13 +1768,15 @@ pub enum AttrStyle {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct AttrId(pub usize);\n \n+/// Meta-data associated with an item\n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct Attribute_ {\n+pub struct Attribute {\n     pub id: AttrId,\n     pub style: AttrStyle,\n     pub value: P<MetaItem>,\n     pub is_sugared_doc: bool,\n+    pub span: Span,\n }\n \n /// TraitRef's appear in impls."}, {"sha": "8f3ef0e16df5ed53d5521eca3e98fe9f6997bb3d", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -15,10 +15,10 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute, Attribute_};\n+use ast::{AttrId, Attribute};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, Expr, Item, Local, Stmt, StmtKind};\n-use codemap::{respan, spanned, dummy_spanned};\n+use codemap::{respan, spanned, dummy_spanned, mk_sp};\n use syntax_pos::{Span, BytePos, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n@@ -61,7 +61,7 @@ fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n \n pub fn mark_used(attr: &Attribute) {\n     debug!(\"Marking {:?} as used.\", attr);\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     USED_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -73,7 +73,7 @@ pub fn mark_used(attr: &Attribute) {\n }\n \n pub fn is_used(attr: &Attribute) -> bool {\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     USED_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -84,7 +84,7 @@ pub fn is_used(attr: &Attribute) -> bool {\n \n pub fn mark_known(attr: &Attribute) {\n     debug!(\"Marking {:?} as known.\", attr);\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     KNOWN_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -96,7 +96,7 @@ pub fn mark_known(attr: &Attribute) {\n }\n \n pub fn is_known(attr: &Attribute) -> bool {\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     KNOWN_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -270,7 +270,7 @@ impl MetaItem {\n impl Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> &MetaItem {\n-        &self.node.value\n+        &self.value\n     }\n \n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n@@ -279,16 +279,16 @@ impl Attribute {\n     pub fn with_desugared_doc<T, F>(&self, f: F) -> T where\n         F: FnOnce(&Attribute) -> T,\n     {\n-        if self.node.is_sugared_doc {\n+        if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n                 InternedString::new(\"doc\"),\n                 token::intern_and_get_ident(&strip_doc_comment_decoration(\n                         &comment)));\n-            if self.node.style == ast::AttrStyle::Outer {\n-                f(&mk_attr_outer(self.node.id, meta))\n+            if self.style == ast::AttrStyle::Outer {\n+                f(&mk_attr_outer(self.id, meta))\n             } else {\n-                f(&mk_attr_inner(self.node.id, meta))\n+                f(&mk_attr_inner(self.id, meta))\n             }\n         } else {\n             f(self)\n@@ -355,13 +355,13 @@ pub fn mk_attr_inner(id: AttrId, item: P<MetaItem>) -> Attribute {\n \n /// Returns an innter attribute with the given value and span.\n pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: P<MetaItem>) -> Attribute {\n-    respan(sp,\n-           Attribute_ {\n-            id: id,\n-            style: ast::AttrStyle::Inner,\n-            value: item,\n-            is_sugared_doc: false,\n-          })\n+    Attribute {\n+        id: id,\n+        style: ast::AttrStyle::Inner,\n+        value: item,\n+        is_sugared_doc: false,\n+        span: sp,\n+    }\n }\n \n \n@@ -372,36 +372,36 @@ pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n \n /// Returns an outer attribute with the given value and span.\n pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: P<MetaItem>) -> Attribute {\n-    respan(sp,\n-           Attribute_ {\n-            id: id,\n-            style: ast::AttrStyle::Outer,\n-            value: item,\n-            is_sugared_doc: false,\n-          })\n+    Attribute {\n+        id: id,\n+        style: ast::AttrStyle::Outer,\n+        value: item,\n+        is_sugared_doc: false,\n+        span: sp,\n+    }\n }\n \n pub fn mk_doc_attr_outer(id: AttrId, item: P<MetaItem>, is_sugared_doc: bool) -> Attribute {\n-    dummy_spanned(Attribute_ {\n+    Attribute {\n         id: id,\n         style: ast::AttrStyle::Outer,\n         value: item,\n         is_sugared_doc: is_sugared_doc,\n-    })\n+        span: DUMMY_SP,\n+    }\n }\n \n-pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n-                           hi: BytePos)\n+pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos, hi: BytePos)\n                            -> Attribute {\n     let style = doc_comment_style(&text);\n     let lit = spanned(lo, hi, ast::LitKind::Str(text, ast::StrStyle::Cooked));\n-    let attr = Attribute_ {\n+    Attribute {\n         id: id,\n         style: style,\n         value: P(spanned(lo, hi, MetaItemKind::NameValue(InternedString::new(\"doc\"), lit))),\n-        is_sugared_doc: true\n-    };\n-    spanned(lo, hi, attr)\n+        is_sugared_doc: true,\n+        span: mk_sp(lo, hi),\n+    }\n }\n \n /* Searching */\n@@ -489,7 +489,7 @@ pub enum InlineAttr {\n /// Determine what `#[inline]` attribute is present in `attrs`, if any.\n pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n     attrs.iter().fold(InlineAttr::None, |ia,attr| {\n-        match attr.node.value.node {\n+        match attr.value.node {\n             MetaItemKind::Word(ref n) if n == \"inline\" => {\n                 mark_used(attr);\n                 InlineAttr::Hint\n@@ -896,7 +896,7 @@ pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n /// structure layout, and `packed` to remove padding.\n pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n-    match attr.node.value.node {\n+    match attr.value.node {\n         ast::MetaItemKind::List(ref s, ref items) if s == \"repr\" => {\n             mark_used(attr);\n             for item in items {"}, {"sha": "e83606200f87e5426dd11a50db332178a0d55563", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -12,7 +12,7 @@ use attr::HasAttrs;\n use feature_gate::{feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n use {fold, attr};\n use ast;\n-use codemap::{Spanned, respan};\n+use codemap::Spanned;\n use parse::ParseSess;\n use ptr::P;\n \n@@ -106,12 +106,13 @@ impl<'a> StripUnconfigured<'a> {\n         match (cfg.meta_item(), mi.meta_item()) {\n             (Some(cfg), Some(mi)) =>\n                 if cfg_matches(&cfg, self.sess, self.features) {\n-                    self.process_cfg_attr(respan(mi.span, ast::Attribute_ {\n+                    self.process_cfg_attr(ast::Attribute {\n                         id: attr::mk_attr_id(),\n-                        style: attr.node.style,\n+                        style: attr.style,\n                         value: mi.clone(),\n                         is_sugared_doc: false,\n-                    }))\n+                        span: mi.span,\n+                    })\n                 } else {\n                     None\n                 },\n@@ -131,7 +132,7 @@ impl<'a> StripUnconfigured<'a> {\n                 return false;\n             }\n \n-            let mis = match attr.node.value.node {\n+            let mis = match attr.value.node {\n                 ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n                 _ => return true\n             };\n@@ -160,7 +161,7 @@ impl<'a> StripUnconfigured<'a> {\n                                           attr.span,\n                                           GateIssue::Language,\n                                           EXPLAIN_STMT_ATTR_SYNTAX);\n-                if attr.node.is_sugared_doc {\n+                if attr.is_sugared_doc {\n                     err.help(\"`///` is for documentation comments. For a plain comment, use `//`.\");\n                 }\n                 err.emit();"}, {"sha": "841a6bb1b06c0fdda36149bf9274f7994c026c65", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -353,12 +353,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         match *ext {\n             MultiModifier(ref mac) => {\n-                let item = mac.expand(self.cx, attr.span, &attr.node.value, item);\n+                let item = mac.expand(self.cx, attr.span, &attr.value, item);\n                 kind.expect_from_annotatables(item)\n             }\n             MultiDecorator(ref mac) => {\n                 let mut items = Vec::new();\n-                mac.expand(self.cx, attr.span, &attr.node.value, &item,\n+                mac.expand(self.cx, attr.span, &attr.value, &item,\n                            &mut |item| items.push(item));\n                 items.push(item);\n                 kind.expect_from_annotatables(items)"}, {"sha": "4386dbeb8344e8f1974f8db048ff0a8c276d86c0", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -223,13 +223,13 @@ pub mod rt {\n             let mut r = vec![];\n             // FIXME: The spans could be better\n             r.push(TokenTree::Token(self.span, token::Pound));\n-            if self.node.style == ast::AttrStyle::Inner {\n+            if self.style == ast::AttrStyle::Inner {\n                 r.push(TokenTree::Token(self.span, token::Not));\n             }\n             r.push(TokenTree::Delimited(self.span, Rc::new(tokenstream::Delimited {\n                 delim: token::Bracket,\n                 open_span: self.span,\n-                tts: self.node.value.to_tokens(cx),\n+                tts: self.value.to_tokens(cx),\n                 close_span: self.span,\n             })));\n             r"}, {"sha": "2416ead122404f36837d3070f000f7c382d6863a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -1013,7 +1013,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n             self.context.check_attribute(attr, false);\n         }\n \n-        if contains_novel_literal(&*(attr.node.value)) {\n+        if contains_novel_literal(&*(attr.value)) {\n             gate_feature_post!(&self, attr_literals, attr.span,\n                                \"non-string literals in attributes, or string \\\n                                literals in top-level positions, are experimental\");"}, {"sha": "aac99e4e5139a74dd4c2da5661eea504a9bb5d5c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -486,16 +486,13 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     })\n }\n \n-pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attribute> {\n-    let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n-    Some(Spanned {\n-        node: Attribute_ {\n-            id: id,\n-            style: style,\n-            value: fld.fold_meta_item(value),\n-            is_sugared_doc: is_sugared_doc\n-        },\n-        span: fld.new_span(span)\n+pub fn noop_fold_attribute<T: Folder>(attr: Attribute, fld: &mut T) -> Option<Attribute> {\n+    Some(Attribute {\n+        id: attr.id,\n+        style: attr.style,\n+        value: fld.fold_meta_item(attr.value),\n+        is_sugared_doc: attr.is_sugared_doc,\n+        span: fld.new_span(attr.span),\n     })\n }\n "}, {"sha": "8818b94209e02e5ea7cbc1edc4d7683c8991f32f", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -11,7 +11,7 @@\n use attr;\n use ast;\n use syntax_pos::{mk_sp, Span};\n-use codemap::{spanned, Spanned};\n+use codemap::spanned;\n use parse::common::SeqSep;\n use parse::PResult;\n use parse::token;\n@@ -55,7 +55,7 @@ impl<'a> Parser<'a> {\n                         self.span.lo,\n                         self.span.hi\n                     );\n-                    if attr.node.style != ast::AttrStyle::Outer {\n+                    if attr.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n                                   `//!` or `/*!`) can only appear before items\");\n@@ -145,14 +145,12 @@ impl<'a> Parser<'a> {\n             style = ast::AttrStyle::Inner;\n         }\n \n-        Ok(Spanned {\n+        Ok(ast::Attribute {\n+            id: attr::mk_attr_id(),\n+            style: style,\n+            value: value,\n+            is_sugared_doc: false,\n             span: span,\n-            node: ast::Attribute_ {\n-                id: attr::mk_attr_id(),\n-                style: style,\n-                value: value,\n-                is_sugared_doc: false,\n-            },\n         })\n     }\n \n@@ -172,15 +170,15 @@ impl<'a> Parser<'a> {\n                     }\n \n                     let attr = self.parse_attribute(true)?;\n-                    assert!(attr.node.style == ast::AttrStyle::Inner);\n+                    assert!(attr.style == ast::AttrStyle::Inner);\n                     attrs.push(attr);\n                 }\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n                     let Span { lo, hi, .. } = self.span;\n                     let str = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n                     let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), str, lo, hi);\n-                    if attr.node.style == ast::AttrStyle::Inner {\n+                    if attr.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n                         self.bump();\n                     } else {"}, {"sha": "98ce00c7d381887829b1741ed1fd3b309fb115e6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -3751,9 +3751,7 @@ impl<'a> Parser<'a> {\n     /// Emit an expected item after attributes error.\n     fn expected_item_err(&self, attrs: &[Attribute]) {\n         let message = match attrs.last() {\n-            Some(&Attribute { node: ast::Attribute_ { is_sugared_doc: true, .. }, .. }) => {\n-                \"expected item after doc comment\"\n-            }\n+            Some(&Attribute { is_sugared_doc: true, .. }) => \"expected item after doc comment\",\n             _ => \"expected item after attributes\",\n         };\n "}, {"sha": "ea4a9177d426bb2d9787112eb79b4adc19ae273d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -727,7 +727,7 @@ pub trait PrintState<'a> {\n                               trailing_hardbreak: bool) -> io::Result<()> {\n         let mut count = 0;\n         for attr in attrs {\n-            if attr.node.style == kind {\n+            if attr.style == kind {\n                 try!(self.print_attribute_inline(attr, is_inline));\n                 if is_inline {\n                     try!(self.nbsp());\n@@ -751,11 +751,11 @@ pub trait PrintState<'a> {\n             try!(self.hardbreak_if_not_bol());\n         }\n         try!(self.maybe_print_comment(attr.span.lo));\n-        if attr.node.is_sugared_doc {\n+        if attr.is_sugared_doc {\n             try!(word(self.writer(), &attr.value_str().unwrap()));\n             hardbreak(self.writer())\n         } else {\n-            match attr.node.style {\n+            match attr.style {\n                 ast::AttrStyle::Inner => try!(word(self.writer(), \"#![\")),\n                 ast::AttrStyle::Outer => try!(word(self.writer(), \"#[\")),\n             }"}, {"sha": "f0cfd42c8240b5e76932449137c5f251ed93461c", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -68,15 +68,13 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n     let span = ignored_span(sess, DUMMY_SP);\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n-            node: ast::Attribute_ {\n-                style: ast::AttrStyle::Outer,\n-                value: P(ast::MetaItem {\n-                    node: ast::MetaItemKind::Word(token::intern_and_get_ident(\"prelude_import\")),\n-                    span: span,\n-                }),\n-                id: attr::mk_attr_id(),\n-                is_sugared_doc: false,\n-            },\n+            style: ast::AttrStyle::Outer,\n+            value: P(ast::MetaItem {\n+                node: ast::MetaItemKind::Word(token::intern_and_get_ident(\"prelude_import\")),\n+                span: span,\n+            }),\n+            id: attr::mk_attr_id(),\n+            is_sugared_doc: false,\n             span: span,\n         }],\n         vis: ast::Visibility::Inherited,"}, {"sha": "09d529f5313f880f6e832145c346f98b004a28e0", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea2bc4e935e273268f3f6d8de45a27042dc5e48/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=3ea2bc4e935e273268f3f6d8de45a27042dc5e48", "patch": "@@ -135,7 +135,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n \n     let mut traits = get_traits(mitem, cx);\n     for derive_attr in derive_attrs {\n-        traits.extend(get_traits(&derive_attr.node.value, cx));\n+        traits.extend(get_traits(&derive_attr.value, cx));\n     }\n \n     // First, weed out malformed #[derive]"}]}