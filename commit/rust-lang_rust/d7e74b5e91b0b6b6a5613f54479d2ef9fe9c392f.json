{"sha": "d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZTc0YjVlOTFiMGI2YjZhNTYxM2Y1NDQ3OWQyZWY5ZmU5YzM5MmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-06T21:58:02Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-08T06:37:57Z"}, "message": "librustc: Convert all uses of `assert` over to `fail_unless!`", "tree": {"sha": "b1ce2f5b126be2790aad28ac0c0e526979d91e49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1ce2f5b126be2790aad28ac0c0e526979d91e49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "html_url": "https://github.com/rust-lang/rust/commit/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ea031bcb8c237365b8bf15ae474972570cf15f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ea031bcb8c237365b8bf15ae474972570cf15f9", "html_url": "https://github.com/rust-lang/rust/commit/0ea031bcb8c237365b8bf15ae474972570cf15f9"}], "stats": {"total": 12793, "additions": 6418, "deletions": 6375}, "files": [{"sha": "8924ee6f4f60cac67916d0c567aec9470e61535b", "filename": "doc/rust.md", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -205,7 +205,7 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n The keywords are the following strings:\n \n ~~~~~~~~ {.keyword}\n-as assert\n+as\n break\n const copy\n do drop\n@@ -2000,7 +2000,7 @@ let v = ~[1,2,3];\n \n mutate(copy v);   // Pass a copy\n \n-assert v[0] == 1; // Original was not modified\n+fail_unless!(v[0] == 1); // Original was not modified\n ~~~~\n \n ### Unary move expressions\n@@ -2450,17 +2450,6 @@ In the future, logging will move into a library, and will no longer be a core ex\n It is therefore recommended to use the macro forms of logging (`error!`, `debug!`, etc.) to minimize disruption in code that uses logging.\n \n \n-### Assert expressions\n-\n-~~~~~~~~{.ebnf .gram}\n-assert_expr : \"assert\" expr ;\n-~~~~~~~~\n-\n-> **Note:** In future versions of Rust, `assert` will be changed from a full expression to a macro.\n-\n-An `assert` expression causes the program to fail if its `expr` argument evaluates to `false`.\n-The failure carries string representation of the false expression.\n-\n # Type system\n \n ## Types\n@@ -2560,7 +2549,7 @@ An example of a tuple type and its use:\n type Pair<'self> = (int,&'self str);\n let p: Pair<'static> = (10,\"hello\");\n let (a, b) = p;\n-assert b != \"world\";\n+fail_unless!(b != \"world\");\n ~~~~\n \n \n@@ -2581,7 +2570,7 @@ An example of a vector type and its use:\n ~~~~\n let v: &[int] = &[7, 5, 3];\n let i: int = v[2];\n-assert (i == 3);\n+fail_unless!(i == 3);\n ~~~~\n \n All accessible elements of a vector are always initialized, and access to a vector is always bounds-checked.\n@@ -2986,7 +2975,7 @@ example of an _implicit dereference_ operation performed on box values:\n ~~~~~~~~\n struct Foo { y: int }\n let x = @Foo{y: 10};\n-assert x.y == 10;\n+fail_unless!(x.y == 10);\n ~~~~~~~~\n \n Other operations act on box values as single-word-sized address values. For"}, {"sha": "6660a4a7942163eac4349e5cb5ff16f5b01be6a9", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -239,7 +239,7 @@ fn unix_time_in_microseconds() -> u64 {\n     }\n }\n \n-# fn main() { assert fmt!(\"%?\", unix_time_in_microseconds()) != ~\"\"; }\n+# fn main() { fail_unless!(fmt!(\"%?\", unix_time_in_microseconds()) != ~\"\"); }\n ~~~~\n \n The `#[nolink]` attribute indicates that there's no foreign library to"}, {"sha": "f5d3a482a9f7b3db9247c48756ba12bd699c97da", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -297,9 +297,9 @@ let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n \n Rust has a built-in mechanism for raising exceptions. The `fail!()` macro\n (which can also be written with an error string as an argument: `fail!(\n-~reason)`) and the `assert` construct (which effectively calls `fail!()` if a\n-boolean expression is false) are both ways to raise exceptions. When a task\n-raises an exception the task unwinds its stack---running destructors and\n+~reason)`) and the `fail_unless!` construct (which effectively calls `fail!()`\n+if a boolean expression is false) are both ways to raise exceptions. When a\n+task raises an exception the task unwinds its stack---running destructors and\n freeing memory along the way---and then exits. Unlike exceptions in C++,\n exceptions in Rust are unrecoverable within a single task: once a task fails,\n there is no way to \"catch\" the exception.\n@@ -339,7 +339,7 @@ let result: Result<int, ()> = do task::try {\n         fail!(~\"oops!\");\n     }\n };\n-assert result.is_err();\n+fail_unless!(result.is_err());\n ~~~\n \n Unlike `spawn`, the function spawned using `try` may return a value,\n@@ -401,7 +401,7 @@ do spawn {  // Bidirectionally linked\n     // Wait for the supervised child task to exist.\n     let message = receiver.recv();\n     // Kill both it and the parent task.\n-    assert message != 42;\n+    fail_unless!(message != 42);\n }\n do try {  // Unidirectionally linked\n     sender.send(42);\n@@ -507,13 +507,13 @@ do spawn {\n };\n \n from_child.send(22);\n-assert from_child.recv() == ~\"22\";\n+fail_unless!(from_child.recv() == ~\"22\");\n \n from_child.send(23);\n from_child.send(0);\n \n-assert from_child.recv() == ~\"23\";\n-assert from_child.recv() == ~\"0\";\n+fail_unless!(from_child.recv() == ~\"23\");\n+fail_unless!(from_child.recv() == ~\"0\");\n \n # }\n ~~~~"}, {"sha": "79553d5aa6ed0a6dd1ec4a4b57791a60982bd670", "filename": "doc/tutorial.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -381,7 +381,7 @@ expression to the given type.\n ~~~~\n let x: float = 4.0;\n let y: uint = x as uint;\n-assert y == 4u;\n+fail_unless!(y == 4u);\n ~~~~\n \n ## Syntax extensions\n@@ -849,8 +849,8 @@ Ending the function with a semicolon like so is equivalent to returning `()`.\n fn line(a: int, b: int, x: int) -> int { a * x + b  }\n fn oops(a: int, b: int, x: int) -> ()  { a * x + b; }\n \n-assert 8  == line(5, 3, 1);\n-assert () == oops(5, 3, 1);\n+fail_unless!(8 == line(5, 3, 1));\n+fail_unless!(() == oops(5, 3, 1));\n ~~~~\n \n As with `match` expressions and `let` bindings, function arguments support\n@@ -1000,7 +1000,7 @@ let x = ~10;\n let y = copy x;\n \n let z = *x + *y;\n-assert z == 20;\n+fail_unless!(z == 20);\n ~~~~\n \n When they do not contain any managed boxes, owned boxes can be sent\n@@ -1327,8 +1327,8 @@ and [`core::str`]. Here are some examples.\n let crayons = [Almond, AntiqueBrass, Apricot];\n \n // Check the length of the vector\n-assert crayons.len() == 3;\n-assert !crayons.is_empty();\n+fail_unless!(crayons.len() == 3);\n+fail_unless!(!crayons.is_empty());\n \n // Iterate over a vector, obtaining a pointer to each element\n for crayons.each |crayon| {"}, {"sha": "7d53b29e040296e57d244e800e91c742759f097e", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -63,7 +63,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n           getopts::optopt(~\"logfile\"),\n           getopts::optflag(~\"jit\")];\n \n-    assert !args.is_empty();\n+    fail_unless!(!args.is_empty());\n     let args_ = vec::tail(args);\n     let matches =\n         &match getopts::getopts(args_, opts) {"}, {"sha": "b8e95c67e27667528dcf7679c68f45a075068d59", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -25,7 +25,7 @@ fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n     let mut env = os::env();\n \n     // Make sure we include the aux directory in the path\n-    assert prog.ends_with(~\".exe\");\n+    fail_unless!(prog.ends_with(~\".exe\"));\n     let aux_path = prog.slice(0u, prog.len() - 4u) + ~\".libaux\";\n \n     env = do vec::map(env) |pair| {"}, {"sha": "7a2a15a5421dc2202e927e531443d13ea1cdd529", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -292,31 +292,31 @@ pub fn test() {\n         }\n     }\n \n-    assert seq_range(10, 15) == @[10, 11, 12, 13, 14];\n-    assert from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5];\n-    assert from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14];\n+    fail_unless!(seq_range(10, 15) == @[10, 11, 12, 13, 14]);\n+    fail_unless!(from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5]);\n+    fail_unless!(from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14]);\n }\n \n #[test]\n pub fn append_test() {\n-    assert @[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6];\n+    fail_unless!(@[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6]);\n }\n \n #[test]\n pub fn test_from_owned() {\n-    assert from_owned::<int>(~[]) == @[];\n-    assert from_owned(~[true]) == @[true];\n-    assert from_owned(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5];\n-    assert from_owned(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"];\n-    assert from_owned(~[~[42]]) == @[~[42]];\n+    fail_unless!(from_owned::<int>(~[]) == @[]);\n+    fail_unless!(from_owned(~[true]) == @[true]);\n+    fail_unless!(from_owned(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n+    fail_unless!(from_owned(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"]);\n+    fail_unless!(from_owned(~[~[42]]) == @[~[42]]);\n }\n \n #[test]\n pub fn test_from_slice() {\n-    assert from_slice::<int>([]) == @[];\n-    assert from_slice([true]) == @[true];\n-    assert from_slice([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5];\n-    assert from_slice([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"];\n-    assert from_slice([@[42]]) == @[@[42]];\n+    fail_unless!(from_slice::<int>([]) == @[]);\n+    fail_unless!(from_slice([true]) == @[true]);\n+    fail_unless!(from_slice([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n+    fail_unless!(from_slice([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"]);\n+    fail_unless!(from_slice([@[42]]) == @[@[42]]);\n }\n "}, {"sha": "13b8d0fc907fd998612e739ea0d5a6039066cc64", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -86,20 +86,20 @@ pub fn test_bool_from_str() {\n     use from_str::FromStr;\n \n     do all_values |v| {\n-        assert Some(v) == FromStr::from_str(to_str(v))\n+        fail_unless!(Some(v) == FromStr::from_str(to_str(v)))\n     }\n }\n \n #[test]\n pub fn test_bool_to_str() {\n-    assert to_str(false) == ~\"false\";\n-    assert to_str(true) == ~\"true\";\n+    fail_unless!(to_str(false) == ~\"false\");\n+    fail_unless!(to_str(true) == ~\"true\");\n }\n \n #[test]\n pub fn test_bool_to_bit() {\n     do all_values |v| {\n-        assert to_bit(v) == if is_true(v) { 1u8 } else { 0u8 };\n+        fail_unless!(to_bit(v) == if is_true(v) { 1u8 } else { 0u8 });\n     }\n }\n "}, {"sha": "f17b04da503a9b875408f80112e12f6cffba96c9", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -48,7 +48,7 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n  *\n  * # Example\n  *\n- *     assert transmute(\"L\") == ~[76u8, 0u8];\n+ *     fail_unless!(transmute(\"L\") == ~[76u8, 0u8]);\n  */\n #[inline(always)]\n pub unsafe fn transmute<L, G>(thing: L) -> G {\n@@ -112,7 +112,7 @@ pub mod tests {\n \n     #[test]\n     pub fn test_reinterpret_cast() {\n-        assert 1u == unsafe { reinterpret_cast(&1) };\n+        fail_unless!(1u == unsafe { reinterpret_cast(&1) });\n     }\n \n     #[test]\n@@ -123,8 +123,8 @@ pub mod tests {\n             let ptr: *int = transmute(box); // refcount 2\n             let _box1: @~str = reinterpret_cast(&ptr);\n             let _box2: @~str = reinterpret_cast(&ptr);\n-            assert *_box1 == ~\"box box box\";\n-            assert *_box2 == ~\"box box box\";\n+            fail_unless!(*_box1 == ~\"box box box\");\n+            fail_unless!(*_box2 == ~\"box box box\");\n             // Will destroy _box1 and _box2. Without the bump, this would\n             // use-after-free. With too many bumps, it would leak.\n         }\n@@ -136,15 +136,15 @@ pub mod tests {\n         unsafe {\n             let x = @100u8;\n             let x: *BoxRepr = transmute(x);\n-            assert (*x).data == 100;\n+            fail_unless!((*x).data == 100);\n             let _x: @int = transmute(x);\n         }\n     }\n \n     #[test]\n     pub fn test_transmute2() {\n         unsafe {\n-            assert ~[76u8, 0u8] == transmute(~\"L\");\n+            fail_unless!(~[76u8, 0u8] == transmute(~\"L\"));\n         }\n     }\n }"}, {"sha": "8df0037b2afe309d3893cbdc87a26fb9f0d98753", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -65,12 +65,12 @@ pub impl<T> Cell<T> {\n #[test]\n fn test_basic() {\n     let value_cell = Cell(~10);\n-    assert !value_cell.is_empty();\n+    fail_unless!(!value_cell.is_empty());\n     let value = value_cell.take();\n-    assert value == ~10;\n-    assert value_cell.is_empty();\n+    fail_unless!(value == ~10);\n+    fail_unless!(value_cell.is_empty());\n     value_cell.put_back(value);\n-    assert !value_cell.is_empty();\n+    fail_unless!(!value_cell.is_empty());\n }\n \n #[test]"}, {"sha": "7922103029b510de9d44b6b64a0ad51bb80ede89", "filename": "src/libcore/char.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -200,7 +200,7 @@ pub pure fn escape_unicode(c: char) -> ~str {\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n                     else if c <= '\\uffff' { ('u', 4u) }\n                     else { ('U', 8u) });\n-    assert str::len(s) <= pad;\n+    fail_unless!(str::len(s) <= pad);\n     let mut out = ~\"\\\\\";\n     unsafe {\n         str::push_str(&mut out, str::from_char(c));\n@@ -258,91 +258,91 @@ impl Eq for char {\n \n #[test]\n fn test_is_lowercase() {\n-    assert is_lowercase('a');\n-    assert is_lowercase('\u00f6');\n-    assert is_lowercase('\u00df');\n-    assert !is_lowercase('\u00dc');\n-    assert !is_lowercase('P');\n+    fail_unless!(is_lowercase('a'));\n+    fail_unless!(is_lowercase('\u00f6'));\n+    fail_unless!(is_lowercase('\u00df'));\n+    fail_unless!(!is_lowercase('\u00dc'));\n+    fail_unless!(!is_lowercase('P'));\n }\n \n #[test]\n fn test_is_uppercase() {\n-    assert !is_uppercase('h');\n-    assert !is_uppercase('\u00e4');\n-    assert !is_uppercase('\u00df');\n-    assert is_uppercase('\u00d6');\n-    assert is_uppercase('T');\n+    fail_unless!(!is_uppercase('h'));\n+    fail_unless!(!is_uppercase('\u00e4'));\n+    fail_unless!(!is_uppercase('\u00df'));\n+    fail_unless!(is_uppercase('\u00d6'));\n+    fail_unless!(is_uppercase('T'));\n }\n \n #[test]\n fn test_is_whitespace() {\n-    assert is_whitespace(' ');\n-    assert is_whitespace('\\u2007');\n-    assert is_whitespace('\\t');\n-    assert is_whitespace('\\n');\n+    fail_unless!(is_whitespace(' '));\n+    fail_unless!(is_whitespace('\\u2007'));\n+    fail_unless!(is_whitespace('\\t'));\n+    fail_unless!(is_whitespace('\\n'));\n \n-    assert !is_whitespace('a');\n-    assert !is_whitespace('_');\n-    assert !is_whitespace('\\u0000');\n+    fail_unless!(!is_whitespace('a'));\n+    fail_unless!(!is_whitespace('_'));\n+    fail_unless!(!is_whitespace('\\u0000'));\n }\n \n #[test]\n fn test_to_digit() {\n-    assert to_digit('0', 10u) == Some(0u);\n-    assert to_digit('1', 2u) == Some(1u);\n-    assert to_digit('2', 3u) == Some(2u);\n-    assert to_digit('9', 10u) == Some(9u);\n-    assert to_digit('a', 16u) == Some(10u);\n-    assert to_digit('A', 16u) == Some(10u);\n-    assert to_digit('b', 16u) == Some(11u);\n-    assert to_digit('B', 16u) == Some(11u);\n-    assert to_digit('z', 36u) == Some(35u);\n-    assert to_digit('Z', 36u) == Some(35u);\n+    fail_unless!(to_digit('0', 10u) == Some(0u));\n+    fail_unless!(to_digit('1', 2u) == Some(1u));\n+    fail_unless!(to_digit('2', 3u) == Some(2u));\n+    fail_unless!(to_digit('9', 10u) == Some(9u));\n+    fail_unless!(to_digit('a', 16u) == Some(10u));\n+    fail_unless!(to_digit('A', 16u) == Some(10u));\n+    fail_unless!(to_digit('b', 16u) == Some(11u));\n+    fail_unless!(to_digit('B', 16u) == Some(11u));\n+    fail_unless!(to_digit('z', 36u) == Some(35u));\n+    fail_unless!(to_digit('Z', 36u) == Some(35u));\n \n-    assert to_digit(' ', 10u).is_none();\n-    assert to_digit('$', 36u).is_none();\n+    fail_unless!(to_digit(' ', 10u).is_none());\n+    fail_unless!(to_digit('$', 36u).is_none());\n }\n \n #[test]\n fn test_is_ascii() {\n-   assert str::all(~\"banana\", is_ascii);\n-   assert ! str::all(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", is_ascii);\n+   fail_unless!(str::all(~\"banana\", is_ascii));\n+   fail_unless!(! str::all(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", is_ascii));\n }\n \n #[test]\n fn test_is_digit() {\n-   assert is_digit('2');\n-   assert is_digit('7');\n-   assert ! is_digit('c');\n-   assert ! is_digit('i');\n-   assert ! is_digit('z');\n-   assert ! is_digit('Q');\n+   fail_unless!(is_digit('2'));\n+   fail_unless!(is_digit('7'));\n+   fail_unless!(! is_digit('c'));\n+   fail_unless!(! is_digit('i'));\n+   fail_unless!(! is_digit('z'));\n+   fail_unless!(! is_digit('Q'));\n }\n \n #[test]\n fn test_escape_default() {\n-    assert escape_default('\\n') == ~\"\\\\n\";\n-    assert escape_default('\\r') == ~\"\\\\r\";\n-    assert escape_default('\\'') == ~\"\\\\'\";\n-    assert escape_default('\"') == ~\"\\\\\\\"\";\n-    assert escape_default(' ') == ~\" \";\n-    assert escape_default('a') == ~\"a\";\n-    assert escape_default('~') == ~\"~\";\n-    assert escape_default('\\x00') == ~\"\\\\x00\";\n-    assert escape_default('\\x1f') == ~\"\\\\x1f\";\n-    assert escape_default('\\x7f') == ~\"\\\\x7f\";\n-    assert escape_default('\\xff') == ~\"\\\\xff\";\n-    assert escape_default('\\u011b') == ~\"\\\\u011b\";\n-    assert escape_default('\\U0001d4b6') == ~\"\\\\U0001d4b6\";\n+    fail_unless!(escape_default('\\n') == ~\"\\\\n\");\n+    fail_unless!(escape_default('\\r') == ~\"\\\\r\");\n+    fail_unless!(escape_default('\\'') == ~\"\\\\'\");\n+    fail_unless!(escape_default('\"') == ~\"\\\\\\\"\");\n+    fail_unless!(escape_default(' ') == ~\" \");\n+    fail_unless!(escape_default('a') == ~\"a\");\n+    fail_unless!(escape_default('~') == ~\"~\");\n+    fail_unless!(escape_default('\\x00') == ~\"\\\\x00\");\n+    fail_unless!(escape_default('\\x1f') == ~\"\\\\x1f\");\n+    fail_unless!(escape_default('\\x7f') == ~\"\\\\x7f\");\n+    fail_unless!(escape_default('\\xff') == ~\"\\\\xff\");\n+    fail_unless!(escape_default('\\u011b') == ~\"\\\\u011b\");\n+    fail_unless!(escape_default('\\U0001d4b6') == ~\"\\\\U0001d4b6\");\n }\n \n \n #[test]\n fn test_escape_unicode() {\n-    assert escape_unicode('\\x00') == ~\"\\\\x00\";\n-    assert escape_unicode('\\n') == ~\"\\\\x0a\";\n-    assert escape_unicode(' ') == ~\"\\\\x20\";\n-    assert escape_unicode('a') == ~\"\\\\x61\";\n-    assert escape_unicode('\\u011b') == ~\"\\\\u011b\";\n-    assert escape_unicode('\\U0001d4b6') == ~\"\\\\U0001d4b6\";\n+    fail_unless!(escape_unicode('\\x00') == ~\"\\\\x00\");\n+    fail_unless!(escape_unicode('\\n') == ~\"\\\\x0a\");\n+    fail_unless!(escape_unicode(' ') == ~\"\\\\x20\");\n+    fail_unless!(escape_unicode('a') == ~\"\\\\x61\");\n+    fail_unless!(escape_unicode('\\u011b') == ~\"\\\\u011b\");\n+    fail_unless!(escape_unicode('\\U0001d4b6') == ~\"\\\\U0001d4b6\");\n }"}, {"sha": "81f6a7e426640ebb1ad72e5ce9c3cd2dab7d9b29", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -172,10 +172,10 @@ pub pure fn max<T:Ord>(v1: T, v2: T) -> T {\n mod test {\n     #[test]\n     fn test_int() {\n-        assert 5.cmp(&10) == Less;\n-        assert 10.cmp(&5) == Greater;\n-        assert 5.cmp(&5) == Equal;\n-        assert (-5).cmp(&12) == Less;\n-        assert 12.cmp(-5) == Greater;\n+        fail_unless!(5.cmp(&10) == Less);\n+        fail_unless!(10.cmp(&5) == Greater);\n+        fail_unless!(5.cmp(&5) == Equal);\n+        fail_unless!((-5).cmp(&12) == Less);\n+        fail_unless!(12.cmp(-5) == Greater);\n     }\n }"}, {"sha": "5b189abf4a373adbd417670b763d7c9cf6e514a8", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -464,6 +464,6 @@ pub mod test {\n             let _chan = chan;\n         }\n \n-        assert !port.peek();\n+        fail_unless!(!port.peek());\n     }\n }"}, {"sha": "17d15a8886f4d6c3a9ba789fe0cd5f08f924bf79", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -124,7 +124,7 @@ mod test {\n             trouble(1);\n         }\n \n-        assert inner_trapped;\n+        fail_unless!(inner_trapped);\n     }\n \n     #[test]\n@@ -140,7 +140,7 @@ mod test {\n             trouble(1);\n         }\n \n-        assert outer_trapped;\n+        fail_unless!(outer_trapped);\n     }\n \n     fn nested_reraise_trap_test_inner() {\n@@ -157,7 +157,7 @@ mod test {\n             trouble(1);\n         }\n \n-        assert inner_trapped;\n+        fail_unless!(inner_trapped);\n     }\n \n     #[test]\n@@ -172,7 +172,7 @@ mod test {\n             nested_reraise_trap_test_inner();\n         }\n \n-        assert outer_trapped;\n+        fail_unless!(outer_trapped);\n     }\n \n     #[test]\n@@ -187,6 +187,6 @@ mod test {\n             trouble(1);\n         }\n \n-        assert trapped;\n+        fail_unless!(trapped);\n     }\n }"}, {"sha": "5654d4b9c9b5806a2eec897829c35459cd9f6976", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 182, "deletions": 182, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -170,7 +170,7 @@ priv impl<T> DList<T> {\n     // Remove a node from the list.\n     fn unlink(@mut self, nobe: @mut DListNode<T>) {\n         self.assert_mine(nobe);\n-        assert self.size > 0;\n+        fail_unless!(self.size > 0);\n         self.link(nobe.prev, nobe.next);\n         nobe.prev = None; // Release extraneous references.\n         nobe.next = None;\n@@ -192,7 +192,7 @@ priv impl<T> DList<T> {\n                    nobe: DListLink<T>,\n                    neighbour: @mut DListNode<T>) {\n         self.assert_mine(neighbour);\n-        assert self.size > 0;\n+        fail_unless!(self.size > 0);\n         self.link(neighbour.prev, nobe);\n         self.link(nobe, Some(neighbour));\n         self.size += 1;\n@@ -201,7 +201,7 @@ priv impl<T> DList<T> {\n                     neighbour: @mut DListNode<T>,\n                     nobe: DListLink<T>) {\n         self.assert_mine(neighbour);\n-        assert self.size > 0;\n+        fail_unless!(self.size > 0);\n         self.link(nobe, neighbour.next);\n         self.link(Some(neighbour), nobe);\n         self.size += 1;\n@@ -409,15 +409,15 @@ pub impl<T> DList<T> {\n     /// Check data structure integrity. O(n).\n     fn assert_consistent(@mut self) {\n         if self.hd.is_none() || self.tl.is_none() {\n-            assert self.hd.is_none() && self.tl.is_none();\n+            fail_unless!(self.hd.is_none() && self.tl.is_none());\n         }\n         // iterate forwards\n         let mut count = 0;\n         let mut link = self.peek_n();\n         let mut rabbit = link;\n         while link.is_some() {\n             let nobe = link.get();\n-            assert nobe.linked;\n+            fail_unless!(nobe.linked);\n             // check cycle\n             if rabbit.is_some() {\n                 rabbit = rabbit.get().next;\n@@ -426,19 +426,19 @@ pub impl<T> DList<T> {\n                 rabbit = rabbit.get().next;\n             }\n             if rabbit.is_some() {\n-                assert !managed::mut_ptr_eq(rabbit.get(), nobe);\n+                fail_unless!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n             }\n             // advance\n             link = nobe.next_link();\n             count += 1;\n         }\n-        assert count == self.len();\n+        fail_unless!(count == self.len());\n         // iterate backwards - some of this is probably redundant.\n         link = self.peek_tail_n();\n         rabbit = link;\n         while link.is_some() {\n             let nobe = link.get();\n-            assert nobe.linked;\n+            fail_unless!(nobe.linked);\n             // check cycle\n             if rabbit.is_some() {\n                 rabbit = rabbit.get().prev;\n@@ -447,13 +447,13 @@ pub impl<T> DList<T> {\n                 rabbit = rabbit.get().prev;\n             }\n             if rabbit.is_some() {\n-                assert !managed::mut_ptr_eq(rabbit.get(), nobe);\n+                fail_unless!(!managed::mut_ptr_eq(rabbit.get(), nobe));\n             }\n             // advance\n             link = nobe.prev_link();\n             count -= 1;\n         }\n-        assert count == 0;\n+        fail_unless!(count == 0);\n     }\n }\n \n@@ -513,66 +513,66 @@ mod tests {\n         let ab = from_vec(~[a,b]);\n         let cd = from_vec(~[c,d]);\n         let abcd = concat(concat(from_vec(~[ab,cd])));\n-        abcd.assert_consistent(); assert abcd.len() == 8;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 1;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 2;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 3;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 4;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 5;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 6;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 7;\n-        abcd.assert_consistent(); assert abcd.pop().get() == 8;\n-        abcd.assert_consistent(); assert abcd.is_empty();\n+        abcd.assert_consistent(); fail_unless!(abcd.len() == 8);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 1);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 2);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 3);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 4);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 5);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 6);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 7);\n+        abcd.assert_consistent(); fail_unless!(abcd.pop().get() == 8);\n+        abcd.assert_consistent(); fail_unless!(abcd.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append() {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n-        assert a.len() == 6;\n-        assert b.len() == 0;\n+        fail_unless!(a.len() == 6);\n+        fail_unless!(b.len() == 0);\n         b.assert_consistent();\n-        a.assert_consistent(); assert a.pop().get() == 1;\n-        a.assert_consistent(); assert a.pop().get() == 2;\n-        a.assert_consistent(); assert a.pop().get() == 3;\n-        a.assert_consistent(); assert a.pop().get() == 4;\n-        a.assert_consistent(); assert a.pop().get() == 5;\n-        a.assert_consistent(); assert a.pop().get() == 6;\n-        a.assert_consistent(); assert a.is_empty();\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 6);\n+        a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_empty() {\n         let a = from_vec(~[1,2,3]);\n         let b = DList::<int>();\n         a.append(b);\n-        assert a.len() == 3;\n-        assert b.len() == 0;\n+        fail_unless!(a.len() == 3);\n+        fail_unless!(b.len() == 0);\n         b.assert_consistent();\n-        a.assert_consistent(); assert a.pop().get() == 1;\n-        a.assert_consistent(); assert a.pop().get() == 2;\n-        a.assert_consistent(); assert a.pop().get() == 3;\n-        a.assert_consistent(); assert a.is_empty();\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_to_empty() {\n         let a = DList::<int>();\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n-        assert a.len() == 3;\n-        assert b.len() == 0;\n+        fail_unless!(a.len() == 3);\n+        fail_unless!(b.len() == 0);\n         b.assert_consistent();\n-        a.assert_consistent(); assert a.pop().get() == 4;\n-        a.assert_consistent(); assert a.pop().get() == 5;\n-        a.assert_consistent(); assert a.pop().get() == 6;\n-        a.assert_consistent(); assert a.is_empty();\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 6);\n+        a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_append_two_empty() {\n         let a = DList::<int>();\n         let b = DList::<int>();\n         a.append(b);\n-        assert a.len() == 0;\n-        assert b.len() == 0;\n+        fail_unless!(a.len() == 0);\n+        fail_unless!(b.len() == 0);\n         b.assert_consistent();\n         a.assert_consistent();\n     }\n@@ -595,34 +595,34 @@ mod tests {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         b.prepend(a);\n-        assert a.len() == 0;\n-        assert b.len() == 6;\n+        fail_unless!(a.len() == 0);\n+        fail_unless!(b.len() == 6);\n         a.assert_consistent();\n-        b.assert_consistent(); assert b.pop().get() == 1;\n-        b.assert_consistent(); assert b.pop().get() == 2;\n-        b.assert_consistent(); assert b.pop().get() == 3;\n-        b.assert_consistent(); assert b.pop().get() == 4;\n-        b.assert_consistent(); assert b.pop().get() == 5;\n-        b.assert_consistent(); assert b.pop().get() == 6;\n-        b.assert_consistent(); assert b.is_empty();\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 1);\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 2);\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 3);\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 4);\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 5);\n+        b.assert_consistent(); fail_unless!(b.pop().get() == 6);\n+        b.assert_consistent(); fail_unless!(b.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_reverse() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.reverse();\n-        assert a.len() == 5;\n-        a.assert_consistent(); assert a.pop().get() == 1;\n-        a.assert_consistent(); assert a.pop().get() == 2;\n-        a.assert_consistent(); assert a.pop().get() == 3;\n-        a.assert_consistent(); assert a.pop().get() == 4;\n-        a.assert_consistent(); assert a.pop().get() == 5;\n-        a.assert_consistent(); assert a.is_empty();\n+        fail_unless!(a.len() == 5);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n+        a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_reverse_empty() {\n         let a = DList::<int>();\n         a.reverse();\n-        assert a.len() == 0;\n+        fail_unless!(a.len() == 0);\n         a.assert_consistent();\n     }\n     #[test]\n@@ -633,94 +633,94 @@ mod tests {\n                 a.insert_before(3, nobe);\n             }\n         }\n-        assert a.len() == 6;\n-        a.assert_consistent(); assert a.pop().get() == 1;\n-        a.assert_consistent(); assert a.pop().get() == 2;\n-        a.assert_consistent(); assert a.pop().get() == 3;\n-        a.assert_consistent(); assert a.pop().get() == 4;\n-        a.assert_consistent(); assert a.pop().get() == 3;\n-        a.assert_consistent(); assert a.pop().get() == 5;\n-        a.assert_consistent(); assert a.is_empty();\n+        fail_unless!(a.len() == 6);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 1);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 2);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 4);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 3);\n+        a.assert_consistent(); fail_unless!(a.pop().get() == 5);\n+        a.assert_consistent(); fail_unless!(a.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_clear() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.clear();\n-        assert a.len() == 0;\n+        fail_unless!(a.len() == 0);\n         a.assert_consistent();\n     }\n     #[test]\n     pub fn test_dlist_is_empty() {\n         let empty = DList::<int>();\n         let full1 = from_vec(~[1,2,3]);\n-        assert empty.is_empty();\n-        assert !full1.is_empty();\n+        fail_unless!(empty.is_empty());\n+        fail_unless!(!full1.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_head_tail() {\n         let l = from_vec(~[1,2,3]);\n-        assert l.head() == 1;\n-        assert l.tail() == 3;\n-        assert l.len() == 3;\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.tail() == 3);\n+        fail_unless!(l.len() == 3);\n     }\n     #[test]\n     pub fn test_dlist_pop() {\n         let l = from_vec(~[1,2,3]);\n-        assert l.pop().get() == 1;\n-        assert l.tail() == 3;\n-        assert l.head() == 2;\n-        assert l.pop().get() == 2;\n-        assert l.tail() == 3;\n-        assert l.head() == 3;\n-        assert l.pop().get() == 3;\n-        assert l.is_empty();\n-        assert l.pop().is_none();\n+        fail_unless!(l.pop().get() == 1);\n+        fail_unless!(l.tail() == 3);\n+        fail_unless!(l.head() == 2);\n+        fail_unless!(l.pop().get() == 2);\n+        fail_unless!(l.tail() == 3);\n+        fail_unless!(l.head() == 3);\n+        fail_unless!(l.pop().get() == 3);\n+        fail_unless!(l.is_empty());\n+        fail_unless!(l.pop().is_none());\n     }\n     #[test]\n     pub fn test_dlist_pop_tail() {\n         let l = from_vec(~[1,2,3]);\n-        assert l.pop_tail().get() == 3;\n-        assert l.tail() == 2;\n-        assert l.head() == 1;\n-        assert l.pop_tail().get() == 2;\n-        assert l.tail() == 1;\n-        assert l.head() == 1;\n-        assert l.pop_tail().get() == 1;\n-        assert l.is_empty();\n-        assert l.pop_tail().is_none();\n+        fail_unless!(l.pop_tail().get() == 3);\n+        fail_unless!(l.tail() == 2);\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.pop_tail().get() == 2);\n+        fail_unless!(l.tail() == 1);\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.pop_tail().get() == 1);\n+        fail_unless!(l.is_empty());\n+        fail_unless!(l.pop_tail().is_none());\n     }\n     #[test]\n     pub fn test_dlist_push() {\n         let l = DList::<int>();\n         l.push(1);\n-        assert l.head() == 1;\n-        assert l.tail() == 1;\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.tail() == 1);\n         l.push(2);\n-        assert l.head() == 1;\n-        assert l.tail() == 2;\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.tail() == 2);\n         l.push(3);\n-        assert l.head() == 1;\n-        assert l.tail() == 3;\n-        assert l.len() == 3;\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.tail() == 3);\n+        fail_unless!(l.len() == 3);\n     }\n     #[test]\n     pub fn test_dlist_push_head() {\n         let l = DList::<int>();\n         l.push_head(3);\n-        assert l.head() == 3;\n-        assert l.tail() == 3;\n+        fail_unless!(l.head() == 3);\n+        fail_unless!(l.tail() == 3);\n         l.push_head(2);\n-        assert l.head() == 2;\n-        assert l.tail() == 3;\n+        fail_unless!(l.head() == 2);\n+        fail_unless!(l.tail() == 3);\n         l.push_head(1);\n-        assert l.head() == 1;\n-        assert l.tail() == 3;\n-        assert l.len() == 3;\n+        fail_unless!(l.head() == 1);\n+        fail_unless!(l.tail() == 3);\n+        fail_unless!(l.len() == 3);\n     }\n     #[test]\n     pub fn test_dlist_foldl() {\n         let l = from_vec(vec::from_fn(101, |x|x));\n-        assert iter::foldl(&l, 0, |accum,elem| *accum+*elem) == 5050;\n+        fail_unless!(iter::foldl(&l, 0, |accum,elem| *accum+*elem) == 5050);\n     }\n     #[test]\n     pub fn test_dlist_break_early() {\n@@ -730,173 +730,173 @@ mod tests {\n             x += 1;\n             if (*i == 3) { break; }\n         }\n-        assert x == 3;\n+        fail_unless!(x == 3);\n     }\n     #[test]\n     pub fn test_dlist_remove_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(one);\n-        l.assert_consistent(); assert l.len() == 2;\n-        l.assert_consistent(); assert l.head() == 2;\n-        l.assert_consistent(); assert l.tail() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n+        l.assert_consistent(); fail_unless!(l.head() == 2);\n+        l.assert_consistent(); fail_unless!(l.tail() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_mid() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(two);\n-        l.assert_consistent(); assert l.len() == 2;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert l.len() == 2;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_one_two() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(one);\n         l.assert_consistent(); l.remove(two);\n         // and through and through, the vorpal blade went snicker-snack\n-        l.assert_consistent(); assert l.len() == 1;\n-        l.assert_consistent(); assert l.head() == 3;\n-        l.assert_consistent(); assert l.tail() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 1);\n+        l.assert_consistent(); fail_unless!(l.head() == 3);\n+        l.assert_consistent(); fail_unless!(l.tail() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_one_three() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(one);\n         l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert l.len() == 1;\n-        l.assert_consistent(); assert l.head() == 2;\n-        l.assert_consistent(); assert l.tail() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 1);\n+        l.assert_consistent(); fail_unless!(l.head() == 2);\n+        l.assert_consistent(); fail_unless!(l.tail() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_two_three() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(two);\n         l.assert_consistent(); l.remove(three);\n-        l.assert_consistent(); assert l.len() == 1;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 1);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_remove_all() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n-        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n         l.assert_consistent(); l.remove(two);\n         l.assert_consistent(); l.remove(three);\n         l.assert_consistent(); l.remove(one); // Twenty-three is number one!\n-        l.assert_consistent(); assert l.peek().is_none();\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.peek().is_none());\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_n_before() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = new_dlist_node(3);\n-        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n         l.assert_consistent(); l.insert_n_before(three, two);\n-        l.assert_consistent(); assert l.len() == 3;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_n_after() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = new_dlist_node(3);\n-        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n         l.assert_consistent(); l.insert_n_after(three, one);\n-        l.assert_consistent(); assert l.len() == 3;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_before_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n         l.assert_consistent(); l.insert_before(3, one);\n-        l.assert_consistent(); assert l.len() == 3;\n-        l.assert_consistent(); assert l.head() == 3;\n-        l.assert_consistent(); assert l.tail() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); fail_unless!(l.head() == 3);\n+        l.assert_consistent(); fail_unless!(l.tail() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test]\n     pub fn test_dlist_insert_after_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); fail_unless!(l.len() == 2);\n         l.assert_consistent(); l.insert_after(3, two);\n-        l.assert_consistent(); assert l.len() == 3;\n-        l.assert_consistent(); assert l.head() == 1;\n-        l.assert_consistent(); assert l.tail() == 3;\n-        l.assert_consistent(); assert l.pop().get() == 1;\n-        l.assert_consistent(); assert l.pop().get() == 2;\n-        l.assert_consistent(); assert l.pop().get() == 3;\n-        l.assert_consistent(); assert l.is_empty();\n+        l.assert_consistent(); fail_unless!(l.len() == 3);\n+        l.assert_consistent(); fail_unless!(l.head() == 1);\n+        l.assert_consistent(); fail_unless!(l.tail() == 3);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 1);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 2);\n+        l.assert_consistent(); fail_unless!(l.pop().get() == 3);\n+        l.assert_consistent(); fail_unless!(l.is_empty());\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     pub fn test_dlist_asymmetric_link() {"}, {"sha": "e26f94261f9f9e071905230abe5b3a950b234e18", "filename": "src/libcore/either.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -176,92 +176,92 @@ fn test_either_left() {\n     let val = Left(10);\n     fn f_left(x: &int) -> bool { *x == 10 }\n     fn f_right(_x: &uint) -> bool { false }\n-    assert (either(f_left, f_right, &val));\n+    fail_unless!((either(f_left, f_right, &val)));\n }\n \n #[test]\n fn test_either_right() {\n     let val = Right(10u);\n     fn f_left(_x: &int) -> bool { false }\n     fn f_right(x: &uint) -> bool { *x == 10u }\n-    assert (either(f_left, f_right, &val));\n+    fail_unless!((either(f_left, f_right, &val)));\n }\n \n #[test]\n fn test_lefts() {\n     let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let result = lefts(input);\n-    assert (result == ~[10, 12, 14]);\n+    fail_unless!((result == ~[10, 12, 14]));\n }\n \n #[test]\n fn test_lefts_none() {\n     let input: ~[Either<int, int>] = ~[Right(10), Right(10)];\n     let result = lefts(input);\n-    assert (vec::len(result) == 0u);\n+    fail_unless!((vec::len(result) == 0u));\n }\n \n #[test]\n fn test_lefts_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let result = lefts(input);\n-    assert (vec::len(result) == 0u);\n+    fail_unless!((vec::len(result) == 0u));\n }\n \n #[test]\n fn test_rights() {\n     let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let result = rights(input);\n-    assert (result == ~[11, 13]);\n+    fail_unless!((result == ~[11, 13]));\n }\n \n #[test]\n fn test_rights_none() {\n     let input: ~[Either<int, int>] = ~[Left(10), Left(10)];\n     let result = rights(input);\n-    assert (vec::len(result) == 0u);\n+    fail_unless!((vec::len(result) == 0u));\n }\n \n #[test]\n fn test_rights_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let result = rights(input);\n-    assert (vec::len(result) == 0u);\n+    fail_unless!((vec::len(result) == 0u));\n }\n \n #[test]\n fn test_partition() {\n     let input = ~[Left(10), Right(11), Left(12), Right(13), Left(14)];\n     let (lefts, rights) = partition(input);\n-    assert (lefts[0] == 10);\n-    assert (lefts[1] == 12);\n-    assert (lefts[2] == 14);\n-    assert (rights[0] == 11);\n-    assert (rights[1] == 13);\n+    fail_unless!((lefts[0] == 10));\n+    fail_unless!((lefts[1] == 12));\n+    fail_unless!((lefts[2] == 14));\n+    fail_unless!((rights[0] == 11));\n+    fail_unless!((rights[1] == 13));\n }\n \n #[test]\n fn test_partition_no_lefts() {\n     let input: ~[Either<int, int>] = ~[Right(10), Right(11)];\n     let (lefts, rights) = partition(input);\n-    assert (vec::len(lefts) == 0u);\n-    assert (vec::len(rights) == 2u);\n+    fail_unless!((vec::len(lefts) == 0u));\n+    fail_unless!((vec::len(rights) == 2u));\n }\n \n #[test]\n fn test_partition_no_rights() {\n     let input: ~[Either<int, int>] = ~[Left(10), Left(11)];\n     let (lefts, rights) = partition(input);\n-    assert (vec::len(lefts) == 2u);\n-    assert (vec::len(rights) == 0u);\n+    fail_unless!((vec::len(lefts) == 2u));\n+    fail_unless!((vec::len(rights) == 0u));\n }\n \n #[test]\n fn test_partition_empty() {\n     let input: ~[Either<int, int>] = ~[];\n     let (lefts, rights) = partition(input);\n-    assert (vec::len(lefts) == 0u);\n-    assert (vec::len(rights) == 0u);\n+    fail_unless!((vec::len(lefts) == 0u));\n+    fail_unless!((vec::len(rights) == 0u));\n }\n \n //"}, {"sha": "f9348ae5380736cf1150d245cb676f985f5e937b", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -54,7 +54,7 @@ pub fn deflate_bytes(bytes: &[const u8]) -> ~[u8] {\n                                                    len as size_t,\n                                                    ptr::addr_of(&outsz),\n                                                    lz_norm);\n-            assert res as int != 0;\n+            fail_unless!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n@@ -72,7 +72,7 @@ pub fn inflate_bytes(bytes: &[const u8]) -> ~[u8] {\n                                                      len as size_t,\n                                                      ptr::addr_of(&outsz),\n                                                      0);\n-            assert res as int != 0;\n+            fail_unless!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n@@ -101,6 +101,6 @@ fn test_flate_round_trip() {\n         debug!(\"%u bytes deflated to %u (%.1f%% size)\",\n                in.len(), cmp.len(),\n                100.0 * ((cmp.len() as float) / (in.len() as float)));\n-        assert(in == out);\n+        fail_unless!((in == out));\n     }\n }"}, {"sha": "7f2189df20e25699f042cb69fbf741e89fa65d45", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -458,7 +458,7 @@ pub fn test_siphash() {\n         let vec = u8to64_le!(vecs[t], 0);\n         let out = buf.hash_keyed(k0, k1);\n         debug!(\"got %?, expected %?\", out, vec);\n-        assert vec == out;\n+        fail_unless!(vec == out);\n \n         stream_full.reset();\n         stream_full.input(buf);\n@@ -467,7 +467,7 @@ pub fn test_siphash() {\n         let v = to_hex_str(&vecs[t]);\n         debug!(\"%d: (%s) => inc=%s full=%s\", t, v, i, f);\n \n-        assert f == i && f == v;\n+        fail_unless!(f == i && f == v);\n \n         buf += ~[t as u8];\n         stream_inc.input(~[t as u8]);\n@@ -479,20 +479,20 @@ pub fn test_siphash() {\n #[test] #[cfg(target_arch = \"arm\")]\n pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert (val as u64).hash() != (val as uint).hash();\n-    assert (val as u32).hash() == (val as uint).hash();\n+    fail_unless!((val as u64).hash() != (val as uint).hash());\n+    fail_unless!((val as u32).hash() == (val as uint).hash());\n }\n #[test] #[cfg(target_arch = \"x86_64\")]\n pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert (val as u64).hash() == (val as uint).hash();\n-    assert (val as u32).hash() != (val as uint).hash();\n+    fail_unless!((val as u64).hash() == (val as uint).hash());\n+    fail_unless!((val as u32).hash() != (val as uint).hash());\n }\n #[test] #[cfg(target_arch = \"x86\")]\n pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert (val as u64).hash() != (val as uint).hash();\n-    assert (val as u32).hash() == (val as uint).hash();\n+    fail_unless!((val as u64).hash() != (val as uint).hash());\n+    fail_unless!((val as u32).hash() == (val as uint).hash());\n }\n \n #[test]\n@@ -507,17 +507,17 @@ pub fn test_hash_idempotent() {\n pub fn test_hash_no_bytes_dropped_64() {\n     let val = 0xdeadbeef_deadbeef_u64;\n \n-    assert val.hash() != zero_byte(val, 0).hash();\n-    assert val.hash() != zero_byte(val, 1).hash();\n-    assert val.hash() != zero_byte(val, 2).hash();\n-    assert val.hash() != zero_byte(val, 3).hash();\n-    assert val.hash() != zero_byte(val, 4).hash();\n-    assert val.hash() != zero_byte(val, 5).hash();\n-    assert val.hash() != zero_byte(val, 6).hash();\n-    assert val.hash() != zero_byte(val, 7).hash();\n+    fail_unless!(val.hash() != zero_byte(val, 0).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 1).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 2).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 3).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 4).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 5).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 6).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 7).hash());\n \n     fn zero_byte(val: u64, byte: uint) -> u64 {\n-        assert byte < 8;\n+        fail_unless!(byte < 8);\n         val & !(0xff << (byte * 8))\n     }\n }\n@@ -526,13 +526,13 @@ pub fn test_hash_no_bytes_dropped_64() {\n pub fn test_hash_no_bytes_dropped_32() {\n     let val = 0xdeadbeef_u32;\n \n-    assert val.hash() != zero_byte(val, 0).hash();\n-    assert val.hash() != zero_byte(val, 1).hash();\n-    assert val.hash() != zero_byte(val, 2).hash();\n-    assert val.hash() != zero_byte(val, 3).hash();\n+    fail_unless!(val.hash() != zero_byte(val, 0).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 1).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 2).hash());\n+    fail_unless!(val.hash() != zero_byte(val, 3).hash());\n \n     fn zero_byte(val: u32, byte: uint) -> u32 {\n-        assert byte < 4;\n+        fail_unless!(byte < 4);\n         val & !(0xff << (byte * 8))\n     }\n }"}, {"sha": "783f96d9b9e81f50506a5f4b5a950abb1316b950", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 140, "deletions": 140, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -642,119 +642,119 @@ pub mod linear {\n         #[test]\n         pub fn test_insert() {\n             let mut m = LinearMap::new();\n-            assert m.insert(1, 2);\n-            assert m.insert(2, 4);\n-            assert *m.get(&1) == 2;\n-            assert *m.get(&2) == 4;\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(m.insert(2, 4));\n+            fail_unless!(*m.get(&1) == 2);\n+            fail_unless!(*m.get(&2) == 4);\n         }\n \n         #[test]\n         pub fn test_insert_overwrite() {\n             let mut m = LinearMap::new();\n-            assert m.insert(1, 2);\n-            assert *m.get(&1) == 2;\n-            assert !m.insert(1, 3);\n-            assert *m.get(&1) == 3;\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(*m.get(&1) == 2);\n+            fail_unless!(!m.insert(1, 3));\n+            fail_unless!(*m.get(&1) == 3);\n         }\n \n         #[test]\n         pub fn test_insert_conflicts() {\n             let mut m = linear::linear_map_with_capacity(4);\n-            assert m.insert(1, 2);\n-            assert m.insert(5, 3);\n-            assert m.insert(9, 4);\n-            assert *m.get(&9) == 4;\n-            assert *m.get(&5) == 3;\n-            assert *m.get(&1) == 2;\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(m.insert(5, 3));\n+            fail_unless!(m.insert(9, 4));\n+            fail_unless!(*m.get(&9) == 4);\n+            fail_unless!(*m.get(&5) == 3);\n+            fail_unless!(*m.get(&1) == 2);\n         }\n \n         #[test]\n         pub fn test_conflict_remove() {\n             let mut m = linear::linear_map_with_capacity(4);\n-            assert m.insert(1, 2);\n-            assert m.insert(5, 3);\n-            assert m.insert(9, 4);\n-            assert m.remove(&1);\n-            assert *m.get(&9) == 4;\n-            assert *m.get(&5) == 3;\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(m.insert(5, 3));\n+            fail_unless!(m.insert(9, 4));\n+            fail_unless!(m.remove(&1));\n+            fail_unless!(*m.get(&9) == 4);\n+            fail_unless!(*m.get(&5) == 3);\n         }\n \n         #[test]\n         pub fn test_is_empty() {\n             let mut m = linear::linear_map_with_capacity(4);\n-            assert m.insert(1, 2);\n-            assert !m.is_empty();\n-            assert m.remove(&1);\n-            assert m.is_empty();\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(!m.is_empty());\n+            fail_unless!(m.remove(&1));\n+            fail_unless!(m.is_empty());\n         }\n \n         #[test]\n         pub fn test_pop() {\n             let mut m = LinearMap::new();\n             m.insert(1, 2);\n-            assert m.pop(&1) == Some(2);\n-            assert m.pop(&1) == None;\n+            fail_unless!(m.pop(&1) == Some(2));\n+            fail_unless!(m.pop(&1) == None);\n         }\n \n         #[test]\n         pub fn test_swap() {\n             let mut m = LinearMap::new();\n-            assert m.swap(1, 2) == None;\n-            assert m.swap(1, 3) == Some(2);\n-            assert m.swap(1, 4) == Some(3);\n+            fail_unless!(m.swap(1, 2) == None);\n+            fail_unless!(m.swap(1, 3) == Some(2));\n+            fail_unless!(m.swap(1, 4) == Some(3));\n         }\n \n         #[test]\n         pub fn test_find_or_insert() {\n             let mut m = LinearMap::new::<int, int>();\n-            assert m.find_or_insert(1, 2) == &2;\n-            assert m.find_or_insert(1, 3) == &2;\n+            fail_unless!(m.find_or_insert(1, 2) == &2);\n+            fail_unless!(m.find_or_insert(1, 3) == &2);\n         }\n \n         #[test]\n         pub fn test_find_or_insert_with() {\n             let mut m = LinearMap::new::<int, int>();\n-            assert m.find_or_insert_with(1, |_| 2) == &2;\n-            assert m.find_or_insert_with(1, |_| 3) == &2;\n+            fail_unless!(m.find_or_insert_with(1, |_| 2) == &2);\n+            fail_unless!(m.find_or_insert_with(1, |_| 3) == &2);\n         }\n \n         #[test]\n         pub fn test_consume() {\n             let mut m = LinearMap::new();\n-            assert m.insert(1, 2);\n-            assert m.insert(2, 3);\n+            fail_unless!(m.insert(1, 2));\n+            fail_unless!(m.insert(2, 3));\n             let mut m2 = LinearMap::new();\n             do m.consume |k, v| {\n                 m2.insert(k, v);\n             }\n-            assert m.len() == 0;\n-            assert m2.len() == 2;\n-            assert m2.get(&1) == &2;\n-            assert m2.get(&2) == &3;\n+            fail_unless!(m.len() == 0);\n+            fail_unless!(m2.len() == 2);\n+            fail_unless!(m2.get(&1) == &2);\n+            fail_unless!(m2.get(&2) == &3);\n         }\n \n         #[test]\n         pub fn test_iterate() {\n             let mut m = linear::linear_map_with_capacity(4);\n             for uint::range(0, 32) |i| {\n-                assert m.insert(i, i*2);\n+                fail_unless!(m.insert(i, i*2));\n             }\n             let mut observed = 0;\n             for m.each |&(k, v)| {\n-                assert *v == *k * 2;\n+                fail_unless!(*v == *k * 2);\n                 observed |= (1 << *k);\n             }\n-            assert observed == 0xFFFF_FFFF;\n+            fail_unless!(observed == 0xFFFF_FFFF);\n         }\n \n         #[test]\n         pub fn test_find() {\n             let mut m = LinearMap::new();\n-            assert m.find(&1).is_none();\n+            fail_unless!(m.find(&1).is_none());\n             m.insert(1, 2);\n             match m.find(&1) {\n                 None => fail!(),\n-                Some(v) => assert *v == 2\n+                Some(v) => fail_unless!(*v == 2)\n             }\n         }\n \n@@ -769,19 +769,19 @@ pub mod linear {\n             m2.insert(1, 2);\n             m2.insert(2, 3);\n \n-            assert m1 != m2;\n+            fail_unless!(m1 != m2);\n \n             m2.insert(3, 4);\n \n-            assert m1 == m2;\n+            fail_unless!(m1 == m2);\n         }\n \n         #[test]\n         pub fn test_expand() {\n             let mut m = LinearMap::new();\n \n-            assert m.len() == 0;\n-            assert m.is_empty();\n+            fail_unless!(m.len() == 0);\n+            fail_unless!(m.is_empty());\n \n             let mut i = 0u;\n             let old_resize_at = m.resize_at;\n@@ -790,8 +790,8 @@ pub mod linear {\n                 i += 1;\n             }\n \n-            assert m.len() == i;\n-            assert !m.is_empty();\n+            fail_unless!(m.len() == i);\n+            fail_unless!(!m.is_empty());\n         }\n     }\n \n@@ -805,160 +805,160 @@ pub mod linear {\n         fn test_disjoint() {\n             let mut xs = linear::LinearSet::new();\n             let mut ys = linear::LinearSet::new();\n-            assert xs.is_disjoint(&ys);\n-            assert ys.is_disjoint(&xs);\n-            assert xs.insert(5);\n-            assert ys.insert(11);\n-            assert xs.is_disjoint(&ys);\n-            assert ys.is_disjoint(&xs);\n-            assert xs.insert(7);\n-            assert xs.insert(19);\n-            assert xs.insert(4);\n-            assert ys.insert(2);\n-            assert ys.insert(-11);\n-            assert xs.is_disjoint(&ys);\n-            assert ys.is_disjoint(&xs);\n-            assert ys.insert(7);\n-            assert !xs.is_disjoint(&ys);\n-            assert !ys.is_disjoint(&xs);\n+            fail_unless!(xs.is_disjoint(&ys));\n+            fail_unless!(ys.is_disjoint(&xs));\n+            fail_unless!(xs.insert(5));\n+            fail_unless!(ys.insert(11));\n+            fail_unless!(xs.is_disjoint(&ys));\n+            fail_unless!(ys.is_disjoint(&xs));\n+            fail_unless!(xs.insert(7));\n+            fail_unless!(xs.insert(19));\n+            fail_unless!(xs.insert(4));\n+            fail_unless!(ys.insert(2));\n+            fail_unless!(ys.insert(-11));\n+            fail_unless!(xs.is_disjoint(&ys));\n+            fail_unless!(ys.is_disjoint(&xs));\n+            fail_unless!(ys.insert(7));\n+            fail_unless!(!xs.is_disjoint(&ys));\n+            fail_unless!(!ys.is_disjoint(&xs));\n         }\n \n         #[test]\n         fn test_subset_and_superset() {\n             let mut a = linear::LinearSet::new();\n-            assert a.insert(0);\n-            assert a.insert(5);\n-            assert a.insert(11);\n-            assert a.insert(7);\n+            fail_unless!(a.insert(0));\n+            fail_unless!(a.insert(5));\n+            fail_unless!(a.insert(11));\n+            fail_unless!(a.insert(7));\n \n             let mut b = linear::LinearSet::new();\n-            assert b.insert(0);\n-            assert b.insert(7);\n-            assert b.insert(19);\n-            assert b.insert(250);\n-            assert b.insert(11);\n-            assert b.insert(200);\n+            fail_unless!(b.insert(0));\n+            fail_unless!(b.insert(7));\n+            fail_unless!(b.insert(19));\n+            fail_unless!(b.insert(250));\n+            fail_unless!(b.insert(11));\n+            fail_unless!(b.insert(200));\n \n-            assert !a.is_subset(&b);\n-            assert !a.is_superset(&b);\n-            assert !b.is_subset(&a);\n-            assert !b.is_superset(&a);\n+            fail_unless!(!a.is_subset(&b));\n+            fail_unless!(!a.is_superset(&b));\n+            fail_unless!(!b.is_subset(&a));\n+            fail_unless!(!b.is_superset(&a));\n \n-            assert b.insert(5);\n+            fail_unless!(b.insert(5));\n \n-            assert a.is_subset(&b);\n-            assert !a.is_superset(&b);\n-            assert !b.is_subset(&a);\n-            assert b.is_superset(&a);\n+            fail_unless!(a.is_subset(&b));\n+            fail_unless!(!a.is_superset(&b));\n+            fail_unless!(!b.is_subset(&a));\n+            fail_unless!(b.is_superset(&a));\n         }\n \n         #[test]\n         fn test_intersection() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            assert a.insert(11);\n-            assert a.insert(1);\n-            assert a.insert(3);\n-            assert a.insert(77);\n-            assert a.insert(103);\n-            assert a.insert(5);\n-            assert a.insert(-5);\n-\n-            assert b.insert(2);\n-            assert b.insert(11);\n-            assert b.insert(77);\n-            assert b.insert(-9);\n-            assert b.insert(-42);\n-            assert b.insert(5);\n-            assert b.insert(3);\n+            fail_unless!(a.insert(11));\n+            fail_unless!(a.insert(1));\n+            fail_unless!(a.insert(3));\n+            fail_unless!(a.insert(77));\n+            fail_unless!(a.insert(103));\n+            fail_unless!(a.insert(5));\n+            fail_unless!(a.insert(-5));\n+\n+            fail_unless!(b.insert(2));\n+            fail_unless!(b.insert(11));\n+            fail_unless!(b.insert(77));\n+            fail_unless!(b.insert(-9));\n+            fail_unless!(b.insert(-42));\n+            fail_unless!(b.insert(5));\n+            fail_unless!(b.insert(3));\n \n             let mut i = 0;\n             let expected = [3, 5, 11, 77];\n             for a.intersection(&b) |x| {\n-                assert vec::contains(expected, x);\n+                fail_unless!(vec::contains(expected, x));\n                 i += 1\n             }\n-            assert i == expected.len();\n+            fail_unless!(i == expected.len());\n         }\n \n         #[test]\n         fn test_difference() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            assert a.insert(1);\n-            assert a.insert(3);\n-            assert a.insert(5);\n-            assert a.insert(9);\n-            assert a.insert(11);\n+            fail_unless!(a.insert(1));\n+            fail_unless!(a.insert(3));\n+            fail_unless!(a.insert(5));\n+            fail_unless!(a.insert(9));\n+            fail_unless!(a.insert(11));\n \n-            assert b.insert(3);\n-            assert b.insert(9);\n+            fail_unless!(b.insert(3));\n+            fail_unless!(b.insert(9));\n \n             let mut i = 0;\n             let expected = [1, 5, 11];\n             for a.difference(&b) |x| {\n-                assert vec::contains(expected, x);\n+                fail_unless!(vec::contains(expected, x));\n                 i += 1\n             }\n-            assert i == expected.len();\n+            fail_unless!(i == expected.len());\n         }\n \n         #[test]\n         fn test_symmetric_difference() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            assert a.insert(1);\n-            assert a.insert(3);\n-            assert a.insert(5);\n-            assert a.insert(9);\n-            assert a.insert(11);\n+            fail_unless!(a.insert(1));\n+            fail_unless!(a.insert(3));\n+            fail_unless!(a.insert(5));\n+            fail_unless!(a.insert(9));\n+            fail_unless!(a.insert(11));\n \n-            assert b.insert(-2);\n-            assert b.insert(3);\n-            assert b.insert(9);\n-            assert b.insert(14);\n-            assert b.insert(22);\n+            fail_unless!(b.insert(-2));\n+            fail_unless!(b.insert(3));\n+            fail_unless!(b.insert(9));\n+            fail_unless!(b.insert(14));\n+            fail_unless!(b.insert(22));\n \n             let mut i = 0;\n             let expected = [-2, 1, 5, 11, 14, 22];\n             for a.symmetric_difference(&b) |x| {\n-                assert vec::contains(expected, x);\n+                fail_unless!(vec::contains(expected, x));\n                 i += 1\n             }\n-            assert i == expected.len();\n+            fail_unless!(i == expected.len());\n         }\n \n         #[test]\n         fn test_union() {\n             let mut a = linear::LinearSet::new();\n             let mut b = linear::LinearSet::new();\n \n-            assert a.insert(1);\n-            assert a.insert(3);\n-            assert a.insert(5);\n-            assert a.insert(9);\n-            assert a.insert(11);\n-            assert a.insert(16);\n-            assert a.insert(19);\n-            assert a.insert(24);\n-\n-            assert b.insert(-2);\n-            assert b.insert(1);\n-            assert b.insert(5);\n-            assert b.insert(9);\n-            assert b.insert(13);\n-            assert b.insert(19);\n+            fail_unless!(a.insert(1));\n+            fail_unless!(a.insert(3));\n+            fail_unless!(a.insert(5));\n+            fail_unless!(a.insert(9));\n+            fail_unless!(a.insert(11));\n+            fail_unless!(a.insert(16));\n+            fail_unless!(a.insert(19));\n+            fail_unless!(a.insert(24));\n+\n+            fail_unless!(b.insert(-2));\n+            fail_unless!(b.insert(1));\n+            fail_unless!(b.insert(5));\n+            fail_unless!(b.insert(9));\n+            fail_unless!(b.insert(13));\n+            fail_unless!(b.insert(19));\n \n             let mut i = 0;\n             let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n             for a.union(&b) |x| {\n-                assert vec::contains(expected, x);\n+                fail_unless!(vec::contains(expected, x));\n                 i += 1\n             }\n-            assert i == expected.len();\n+            fail_unless!(i == expected.len());\n         }\n     }\n }"}, {"sha": "cc40b90d61a348adfd012efd0b630a87f89020f7", "filename": "src/libcore/io.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -247,7 +247,7 @@ impl<T:Reader> ReaderUtil for T {\n                 let w = str::utf8_char_width(b0);\n                 let end = i + w;\n                 i += 1;\n-                assert (w > 0);\n+                fail_unless!((w > 0));\n                 if w == 1 {\n                     chars.push(b0 as char);\n                     loop;\n@@ -260,8 +260,8 @@ impl<T:Reader> ReaderUtil for T {\n                 while i < end {\n                     let next = bytes[i] as int;\n                     i += 1;\n-                    assert (next > -1);\n-                    assert (next & 192 == 128);\n+                    fail_unless!((next > -1));\n+                    fail_unless!((next & 192 == 128));\n                     val <<= 6;\n                     val += (next & 63) as uint;\n                 }\n@@ -302,7 +302,7 @@ impl<T:Reader> ReaderUtil for T {\n         if vec::len(c) == 0 {\n             return -1 as char; // FIXME will this stay valid? // #2004\n         }\n-        assert(vec::len(c) == 1);\n+        fail_unless!((vec::len(c) == 1));\n         return c[0];\n     }\n \n@@ -337,7 +337,7 @@ impl<T:Reader> ReaderUtil for T {\n     // FIXME int reading methods need to deal with eof - issue #2004\n \n     fn read_le_uint_n(&self, nbytes: uint) -> u64 {\n-        assert nbytes > 0 && nbytes <= 8;\n+        fail_unless!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64, pos = 0, i = nbytes;\n         while i > 0 {\n@@ -353,7 +353,7 @@ impl<T:Reader> ReaderUtil for T {\n     }\n \n     fn read_be_uint_n(&self, nbytes: uint) -> u64 {\n-        assert nbytes > 0 && nbytes <= 8;\n+        fail_unless!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0u64, i = nbytes;\n         while i > 0 {\n@@ -483,7 +483,7 @@ impl Reader for *libc::FILE {\n     fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         unsafe {\n             do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n-                assert buf_len >= len;\n+                fail_unless!(buf_len >= len);\n \n                 let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n                                         len as size_t, *self);\n@@ -504,9 +504,9 @@ impl Reader for *libc::FILE {\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n         unsafe {\n-            assert libc::fseek(*self,\n-                               offset as c_long,\n-                               convert_whence(whence)) == 0 as c_int;\n+            fail_unless!(libc::fseek(*self,\n+                                     offset as c_long,\n+                                     convert_whence(whence)) == 0 as c_int);\n         }\n     }\n     fn tell(&self) -> uint {\n@@ -692,9 +692,9 @@ impl Writer for *libc::FILE {\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n         unsafe {\n-            assert libc::fseek(*self,\n-                               offset as c_long,\n-                               convert_whence(whence)) == 0 as c_int;\n+            fail_unless!(libc::fseek(*self,\n+                                     offset as c_long,\n+                                     convert_whence(whence)) == 0 as c_int);\n         }\n     }\n     fn tell(&self) -> uint {\n@@ -821,7 +821,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n \n pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n                           f: fn(v: &[u8]) -> T) -> T {\n-    assert size <= 8u;\n+    fail_unless!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n       2u => f(&[n as u8,\n@@ -853,7 +853,7 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n \n pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n                            f: fn(v: &[u8]) -> T) -> T {\n-    assert size <= 8u;\n+    fail_unless!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n       2u => f(&[(n >> 8) as u8,\n@@ -886,7 +886,7 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n pub fn u64_from_be_bytes(data: &[const u8],\n                          start: uint, size: uint) -> u64 {\n     let mut sz = size;\n-    assert (sz <= 8u);\n+    fail_unless!((sz <= 8u));\n     let mut val = 0_u64;\n     let mut pos = start;\n     while sz > 0u {\n@@ -1163,7 +1163,7 @@ pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n         // Make sure the vector has a trailing null and is proper utf8.\n         v.push(0);\n     }\n-    assert str::is_utf8(v);\n+    fail_unless!(str::is_utf8(v));\n \n     unsafe { ::cast::transmute(v) }\n }\n@@ -1235,7 +1235,7 @@ pub mod fsync {\n             None => (),\n             Some(level) => {\n               // fail hard if not succesful\n-              assert((self.arg.fsync_fn)(self.arg.val, level) != -1);\n+              fail_unless!(((self.arg.fsync_fn)(self.arg.val, level) != -1));\n             }\n           }\n         }\n@@ -1320,22 +1320,22 @@ mod tests {\n         let inp: io::Reader = result::get(&io::file_reader(tmpfile));\n         let frood2: ~str = inp.read_c_str();\n         log(debug, copy frood2);\n-        assert frood == frood2;\n+        fail_unless!(frood == frood2);\n     }\n \n     #[test]\n     fn test_readchars_empty() {\n         do io::with_str_reader(~\"\") |inp| {\n             let res : ~[char] = inp.read_chars(128);\n-            assert(vec::len(res) == 0);\n+            fail_unless!((vec::len(res) == 0));\n         }\n     }\n \n     #[test]\n     fn test_read_line_utf8() {\n         do io::with_str_reader(~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\") |inp| {\n             let line = inp.read_line();\n-            assert line == ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";\n+            fail_unless!(line == ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\");\n         }\n     }\n \n@@ -1352,10 +1352,10 @@ mod tests {\n             do io::with_str_reader(s) |inp| {\n                 let res : ~[char] = inp.read_chars(len);\n                 if (len <= vec::len(ivals)) {\n-                    assert(vec::len(res) == len);\n+                    fail_unless!((vec::len(res) == len));\n                 }\n-                assert(vec::slice(ivals, 0u, vec::len(res)) ==\n-                       vec::map(res, |x| *x as int));\n+                fail_unless!(vec::slice(ivals, 0u, vec::len(res)) ==\n+                             vec::map(res, |x| *x as int));\n             }\n         }\n         let mut i = 0;\n@@ -1371,23 +1371,23 @@ mod tests {\n     fn test_readchar() {\n         do io::with_str_reader(~\"\u751f\") |inp| {\n             let res : char = inp.read_char();\n-            assert(res as int == 29983);\n+            fail_unless!((res as int == 29983));\n         }\n     }\n \n     #[test]\n     fn test_readchar_empty() {\n         do io::with_str_reader(~\"\") |inp| {\n             let res : char = inp.read_char();\n-            assert(res as int == -1);\n+            fail_unless!((res as int == -1));\n         }\n     }\n \n     #[test]\n     fn file_reader_not_exist() {\n         match io::file_reader(&Path(\"not a file\")) {\n           result::Err(copy e) => {\n-            assert e == ~\"error opening not a file\";\n+            fail_unless!(e == ~\"error opening not a file\");\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1428,7 +1428,7 @@ mod tests {\n     fn file_writer_bad_name() {\n         match io::file_writer(&Path(\"?/?\"), ~[]) {\n           result::Err(copy e) => {\n-            assert str::starts_with(e, \"error opening\");\n+            fail_unless!(str::starts_with(e, \"error opening\"));\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1438,7 +1438,7 @@ mod tests {\n     fn buffered_file_writer_bad_name() {\n         match io::buffered_file_writer(&Path(\"?/?\")) {\n           result::Err(copy e) => {\n-            assert str::starts_with(e, \"error opening\");\n+            fail_unless!(str::starts_with(e, \"error opening\"));\n           }\n           result::Ok(_) => fail!()\n         }\n@@ -1448,17 +1448,17 @@ mod tests {\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter();\n         wr.write(~[0u8, 1u8, 2u8, 3u8]);\n-        assert wr.bytes.borrow(|bytes| bytes == ~[0u8, 1u8, 2u8, 3u8]);\n+        fail_unless!(wr.bytes.borrow(|bytes| bytes == ~[0u8, 1u8, 2u8, 3u8]));\n         wr.seek(-2, SeekCur);\n         wr.write(~[4u8, 5u8, 6u8, 7u8]);\n-        assert wr.bytes.borrow(|bytes| bytes ==\n-            ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n+        fail_unless!(wr.bytes.borrow(|bytes| bytes ==\n+            ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]));\n         wr.seek(-2, SeekEnd);\n         wr.write(~[8u8]);\n         wr.seek(1, SeekSet);\n         wr.write(~[9u8]);\n-        assert wr.bytes.borrow(|bytes| bytes ==\n-            ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n+        fail_unless!(wr.bytes.borrow(|bytes| bytes ==\n+            ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]));\n     }\n \n     #[test]\n@@ -1478,7 +1478,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             for uints.each |i| {\n-                assert file.read_le_u64() == *i;\n+                fail_unless!(file.read_le_u64() == *i);\n             }\n         }\n     }\n@@ -1500,7 +1500,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             for uints.each |i| {\n-                assert file.read_be_u64() == *i;\n+                fail_unless!(file.read_be_u64() == *i);\n             }\n         }\n     }\n@@ -1524,7 +1524,7 @@ mod tests {\n             for ints.each |i| {\n                 // this tests that the sign extension is working\n                 // (comparing the values as i32 would not test this)\n-                assert file.read_be_int_n(4) == *i as i64;\n+                fail_unless!(file.read_be_int_n(4) == *i as i64);\n             }\n         }\n     }\n@@ -1543,7 +1543,7 @@ mod tests {\n         {\n             let file = io::file_reader(&path).get();\n             let f = file.read_be_f32();\n-            assert f == 8.1250;\n+            fail_unless!(f == 8.1250);\n         }\n     }\n \n@@ -1560,8 +1560,8 @@ mod tests {\n \n         {\n             let file = io::file_reader(&path).get();\n-            assert file.read_be_f32() == 8.1250;\n-            assert file.read_le_f32() == 8.1250;\n+            fail_unless!(file.read_be_f32() == 8.1250);\n+            fail_unless!(file.read_le_f32() == 8.1250);\n         }\n     }\n }"}, {"sha": "245c1db2bb4b8c5eddf4ae93911480a7bae9e2e5", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -28,7 +28,7 @@ mod inst {\n         let mut link = self.peek_n();\n         while option::is_some(&link) {\n             let nobe = option::get(link);\n-            assert nobe.linked;\n+            fail_unless!(nobe.linked);\n \n             {\n                 let frozen_nobe = &*nobe;"}, {"sha": "1bef895ea0b7286f865b85a41680eba5702a1772", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -72,8 +72,8 @@ impl<T:Ord> Ord for @const T {\n fn test() {\n     let x = @3;\n     let y = @3;\n-    assert (ptr_eq::<int>(x, x));\n-    assert (ptr_eq::<int>(y, y));\n-    assert (!ptr_eq::<int>(x, y));\n-    assert (!ptr_eq::<int>(y, x));\n+    fail_unless!((ptr_eq::<int>(x, x)));\n+    fail_unless!((ptr_eq::<int>(y, y)));\n+    fail_unless!((!ptr_eq::<int>(x, y)));\n+    fail_unless!((!ptr_eq::<int>(y, x)));\n }"}, {"sha": "875d378b6453f80084b91f205de87487877a0e27", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -38,7 +38,7 @@ pub fn Mut<T>(t: T) -> Mut<T> {\n pub fn unwrap<T>(m: Mut<T>) -> T {\n     // Borrowck should prevent us from calling unwrap while the value\n     // is in use, as that would be a move from a borrowed value.\n-    assert (m.mode as uint) == (ReadOnly as uint);\n+    fail_unless!((m.mode as uint) == (ReadOnly as uint));\n     let Data {value: value, mode: _} = m;\n     value\n }\n@@ -105,9 +105,9 @@ pub fn test_const_in_mut() {\n     let m = @Mut(1);\n     do m.borrow_mut |p| {\n         do m.borrow_const |q| {\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n             *p += 1;\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n         }\n     }\n }\n@@ -117,9 +117,9 @@ pub fn test_mut_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_mut |q| {\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n             *q += 1;\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n         }\n     }\n }\n@@ -129,7 +129,7 @@ pub fn test_imm_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_imm |q| {\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n         }\n     }\n }\n@@ -139,7 +139,7 @@ pub fn test_const_in_imm() {\n     let m = @Mut(1);\n     do m.borrow_imm |p| {\n         do m.borrow_const |q| {\n-            assert *p == *q;\n+            fail_unless!(*p == *q);\n         }\n     }\n }"}, {"sha": "54521abea9ec0da5d0fbd87d880edbd0943b60e2", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -583,56 +583,56 @@ pub fn test_num() {\n     let ten: f32 = num::cast(10);\n     let two: f32 = num::cast(2);\n \n-    assert (ten.add(&two)    == num::cast(12));\n-    assert (ten.sub(&two)    == num::cast(8));\n-    assert (ten.mul(&two)    == num::cast(20));\n-    assert (ten.div(&two)    == num::cast(5));\n-    assert (ten.modulo(&two) == num::cast(0));\n+    fail_unless!((ten.add(&two)    == num::cast(12)));\n+    fail_unless!((ten.sub(&two)    == num::cast(8)));\n+    fail_unless!((ten.mul(&two)    == num::cast(20)));\n+    fail_unless!((ten.div(&two)    == num::cast(5)));\n+    fail_unless!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n fn test_numcast() {\n-    assert (20u     == 20f32.to_uint());\n-    assert (20u8    == 20f32.to_u8());\n-    assert (20u16   == 20f32.to_u16());\n-    assert (20u32   == 20f32.to_u32());\n-    assert (20u64   == 20f32.to_u64());\n-    assert (20i     == 20f32.to_int());\n-    assert (20i8    == 20f32.to_i8());\n-    assert (20i16   == 20f32.to_i16());\n-    assert (20i32   == 20f32.to_i32());\n-    assert (20i64   == 20f32.to_i64());\n-    assert (20f     == 20f32.to_float());\n-    assert (20f32   == 20f32.to_f32());\n-    assert (20f64   == 20f32.to_f64());\n-\n-    assert (20f32 == NumCast::from(20u));\n-    assert (20f32 == NumCast::from(20u8));\n-    assert (20f32 == NumCast::from(20u16));\n-    assert (20f32 == NumCast::from(20u32));\n-    assert (20f32 == NumCast::from(20u64));\n-    assert (20f32 == NumCast::from(20i));\n-    assert (20f32 == NumCast::from(20i8));\n-    assert (20f32 == NumCast::from(20i16));\n-    assert (20f32 == NumCast::from(20i32));\n-    assert (20f32 == NumCast::from(20i64));\n-    assert (20f32 == NumCast::from(20f));\n-    assert (20f32 == NumCast::from(20f32));\n-    assert (20f32 == NumCast::from(20f64));\n-\n-    assert (20f32 == num::cast(20u));\n-    assert (20f32 == num::cast(20u8));\n-    assert (20f32 == num::cast(20u16));\n-    assert (20f32 == num::cast(20u32));\n-    assert (20f32 == num::cast(20u64));\n-    assert (20f32 == num::cast(20i));\n-    assert (20f32 == num::cast(20i8));\n-    assert (20f32 == num::cast(20i16));\n-    assert (20f32 == num::cast(20i32));\n-    assert (20f32 == num::cast(20i64));\n-    assert (20f32 == num::cast(20f));\n-    assert (20f32 == num::cast(20f32));\n-    assert (20f32 == num::cast(20f64));\n+    fail_unless!((20u     == 20f32.to_uint()));\n+    fail_unless!((20u8    == 20f32.to_u8()));\n+    fail_unless!((20u16   == 20f32.to_u16()));\n+    fail_unless!((20u32   == 20f32.to_u32()));\n+    fail_unless!((20u64   == 20f32.to_u64()));\n+    fail_unless!((20i     == 20f32.to_int()));\n+    fail_unless!((20i8    == 20f32.to_i8()));\n+    fail_unless!((20i16   == 20f32.to_i16()));\n+    fail_unless!((20i32   == 20f32.to_i32()));\n+    fail_unless!((20i64   == 20f32.to_i64()));\n+    fail_unless!((20f     == 20f32.to_float()));\n+    fail_unless!((20f32   == 20f32.to_f32()));\n+    fail_unless!((20f64   == 20f32.to_f64()));\n+\n+    fail_unless!((20f32 == NumCast::from(20u)));\n+    fail_unless!((20f32 == NumCast::from(20u8)));\n+    fail_unless!((20f32 == NumCast::from(20u16)));\n+    fail_unless!((20f32 == NumCast::from(20u32)));\n+    fail_unless!((20f32 == NumCast::from(20u64)));\n+    fail_unless!((20f32 == NumCast::from(20i)));\n+    fail_unless!((20f32 == NumCast::from(20i8)));\n+    fail_unless!((20f32 == NumCast::from(20i16)));\n+    fail_unless!((20f32 == NumCast::from(20i32)));\n+    fail_unless!((20f32 == NumCast::from(20i64)));\n+    fail_unless!((20f32 == NumCast::from(20f)));\n+    fail_unless!((20f32 == NumCast::from(20f32)));\n+    fail_unless!((20f32 == NumCast::from(20f64)));\n+\n+    fail_unless!((20f32 == num::cast(20u)));\n+    fail_unless!((20f32 == num::cast(20u8)));\n+    fail_unless!((20f32 == num::cast(20u16)));\n+    fail_unless!((20f32 == num::cast(20u32)));\n+    fail_unless!((20f32 == num::cast(20u64)));\n+    fail_unless!((20f32 == num::cast(20i)));\n+    fail_unless!((20f32 == num::cast(20i8)));\n+    fail_unless!((20f32 == num::cast(20i16)));\n+    fail_unless!((20f32 == num::cast(20i32)));\n+    fail_unless!((20f32 == num::cast(20i64)));\n+    fail_unless!((20f32 == num::cast(20f)));\n+    fail_unless!((20f32 == num::cast(20f32)));\n+    fail_unless!((20f32 == num::cast(20f64)));\n }\n \n //"}, {"sha": "a2cf629dc9f362dde7879883d37bdc44b75f52b1", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -607,56 +607,56 @@ pub fn test_num() {\n     let ten: f64 = num::cast(10);\n     let two: f64 = num::cast(2);\n \n-    assert (ten.add(&two)    == num::cast(12));\n-    assert (ten.sub(&two)    == num::cast(8));\n-    assert (ten.mul(&two)    == num::cast(20));\n-    assert (ten.div(&two)    == num::cast(5));\n-    assert (ten.modulo(&two) == num::cast(0));\n+    fail_unless!((ten.add(&two)    == num::cast(12)));\n+    fail_unless!((ten.sub(&two)    == num::cast(8)));\n+    fail_unless!((ten.mul(&two)    == num::cast(20)));\n+    fail_unless!((ten.div(&two)    == num::cast(5)));\n+    fail_unless!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20f64.to_uint());\n-    assert (20u8  == 20f64.to_u8());\n-    assert (20u16 == 20f64.to_u16());\n-    assert (20u32 == 20f64.to_u32());\n-    assert (20u64 == 20f64.to_u64());\n-    assert (20i   == 20f64.to_int());\n-    assert (20i8  == 20f64.to_i8());\n-    assert (20i16 == 20f64.to_i16());\n-    assert (20i32 == 20f64.to_i32());\n-    assert (20i64 == 20f64.to_i64());\n-    assert (20f   == 20f64.to_float());\n-    assert (20f32 == 20f64.to_f32());\n-    assert (20f64 == 20f64.to_f64());\n-\n-    assert (20f64 == NumCast::from(20u));\n-    assert (20f64 == NumCast::from(20u8));\n-    assert (20f64 == NumCast::from(20u16));\n-    assert (20f64 == NumCast::from(20u32));\n-    assert (20f64 == NumCast::from(20u64));\n-    assert (20f64 == NumCast::from(20i));\n-    assert (20f64 == NumCast::from(20i8));\n-    assert (20f64 == NumCast::from(20i16));\n-    assert (20f64 == NumCast::from(20i32));\n-    assert (20f64 == NumCast::from(20i64));\n-    assert (20f64 == NumCast::from(20f));\n-    assert (20f64 == NumCast::from(20f32));\n-    assert (20f64 == NumCast::from(20f64));\n-\n-    assert (20f64 == num::cast(20u));\n-    assert (20f64 == num::cast(20u8));\n-    assert (20f64 == num::cast(20u16));\n-    assert (20f64 == num::cast(20u32));\n-    assert (20f64 == num::cast(20u64));\n-    assert (20f64 == num::cast(20i));\n-    assert (20f64 == num::cast(20i8));\n-    assert (20f64 == num::cast(20i16));\n-    assert (20f64 == num::cast(20i32));\n-    assert (20f64 == num::cast(20i64));\n-    assert (20f64 == num::cast(20f));\n-    assert (20f64 == num::cast(20f32));\n-    assert (20f64 == num::cast(20f64));\n+    fail_unless!((20u   == 20f64.to_uint()));\n+    fail_unless!((20u8  == 20f64.to_u8()));\n+    fail_unless!((20u16 == 20f64.to_u16()));\n+    fail_unless!((20u32 == 20f64.to_u32()));\n+    fail_unless!((20u64 == 20f64.to_u64()));\n+    fail_unless!((20i   == 20f64.to_int()));\n+    fail_unless!((20i8  == 20f64.to_i8()));\n+    fail_unless!((20i16 == 20f64.to_i16()));\n+    fail_unless!((20i32 == 20f64.to_i32()));\n+    fail_unless!((20i64 == 20f64.to_i64()));\n+    fail_unless!((20f   == 20f64.to_float()));\n+    fail_unless!((20f32 == 20f64.to_f32()));\n+    fail_unless!((20f64 == 20f64.to_f64()));\n+\n+    fail_unless!((20f64 == NumCast::from(20u)));\n+    fail_unless!((20f64 == NumCast::from(20u8)));\n+    fail_unless!((20f64 == NumCast::from(20u16)));\n+    fail_unless!((20f64 == NumCast::from(20u32)));\n+    fail_unless!((20f64 == NumCast::from(20u64)));\n+    fail_unless!((20f64 == NumCast::from(20i)));\n+    fail_unless!((20f64 == NumCast::from(20i8)));\n+    fail_unless!((20f64 == NumCast::from(20i16)));\n+    fail_unless!((20f64 == NumCast::from(20i32)));\n+    fail_unless!((20f64 == NumCast::from(20i64)));\n+    fail_unless!((20f64 == NumCast::from(20f)));\n+    fail_unless!((20f64 == NumCast::from(20f32)));\n+    fail_unless!((20f64 == NumCast::from(20f64)));\n+\n+    fail_unless!((20f64 == num::cast(20u)));\n+    fail_unless!((20f64 == num::cast(20u8)));\n+    fail_unless!((20f64 == num::cast(20u16)));\n+    fail_unless!((20f64 == num::cast(20u32)));\n+    fail_unless!((20f64 == num::cast(20u64)));\n+    fail_unless!((20f64 == num::cast(20i)));\n+    fail_unless!((20f64 == num::cast(20i8)));\n+    fail_unless!((20f64 == num::cast(20i16)));\n+    fail_unless!((20f64 == num::cast(20i32)));\n+    fail_unless!((20f64 == num::cast(20i64)));\n+    fail_unless!((20f64 == num::cast(20f)));\n+    fail_unless!((20f64 == num::cast(20f32)));\n+    fail_unless!((20f64 == num::cast(20f64)));\n }\n \n //"}, {"sha": "1cceddf51a1d3dd74897ea4635ba5b86a5dbe2f1", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 169, "deletions": 169, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -180,7 +180,7 @@ pub pure fn to_str_exact(num: float, digits: uint) -> ~str {\n #[test]\n pub fn test_to_str_exact_do_decimal() {\n     let s = to_str_exact(5.0, 4u);\n-    assert s == ~\"5.0000\";\n+    fail_unless!(s == ~\"5.0000\");\n }\n \n /**\n@@ -500,248 +500,248 @@ impl ops::Neg<float> for float {\n \n #[test]\n pub fn test_from_str() {\n-   assert from_str(~\"3\") == Some(3.);\n-   assert from_str(~\"3.14\") == Some(3.14);\n-   assert from_str(~\"+3.14\") == Some(3.14);\n-   assert from_str(~\"-3.14\") == Some(-3.14);\n-   assert from_str(~\"2.5E10\") == Some(25000000000.);\n-   assert from_str(~\"2.5e10\") == Some(25000000000.);\n-   assert from_str(~\"25000000000.E-10\") == Some(2.5);\n-   assert from_str(~\".\") == Some(0.);\n-   assert from_str(~\".e1\") == Some(0.);\n-   assert from_str(~\".e-1\") == Some(0.);\n-   assert from_str(~\"5.\") == Some(5.);\n-   assert from_str(~\".5\") == Some(0.5);\n-   assert from_str(~\"0.5\") == Some(0.5);\n-   assert from_str(~\"-.5\") == Some(-0.5);\n-   assert from_str(~\"-5\") == Some(-5.);\n-   assert from_str(~\"inf\") == Some(infinity);\n-   assert from_str(~\"+inf\") == Some(infinity);\n-   assert from_str(~\"-inf\") == Some(neg_infinity);\n+   fail_unless!(from_str(~\"3\") == Some(3.));\n+   fail_unless!(from_str(~\"3.14\") == Some(3.14));\n+   fail_unless!(from_str(~\"+3.14\") == Some(3.14));\n+   fail_unless!(from_str(~\"-3.14\") == Some(-3.14));\n+   fail_unless!(from_str(~\"2.5E10\") == Some(25000000000.));\n+   fail_unless!(from_str(~\"2.5e10\") == Some(25000000000.));\n+   fail_unless!(from_str(~\"25000000000.E-10\") == Some(2.5));\n+   fail_unless!(from_str(~\".\") == Some(0.));\n+   fail_unless!(from_str(~\".e1\") == Some(0.));\n+   fail_unless!(from_str(~\".e-1\") == Some(0.));\n+   fail_unless!(from_str(~\"5.\") == Some(5.));\n+   fail_unless!(from_str(~\".5\") == Some(0.5));\n+   fail_unless!(from_str(~\"0.5\") == Some(0.5));\n+   fail_unless!(from_str(~\"-.5\") == Some(-0.5));\n+   fail_unless!(from_str(~\"-5\") == Some(-5.));\n+   fail_unless!(from_str(~\"inf\") == Some(infinity));\n+   fail_unless!(from_str(~\"+inf\") == Some(infinity));\n+   fail_unless!(from_str(~\"-inf\") == Some(neg_infinity));\n    // note: NaN != NaN, hence this slightly complex test\n    match from_str(~\"NaN\") {\n-       Some(f) => assert is_NaN(f),\n+       Some(f) => fail_unless!(is_NaN(f)),\n        None => fail!()\n    }\n    // note: -0 == 0, hence these slightly more complex tests\n    match from_str(~\"-0\") {\n-       Some(v) if is_zero(v) => assert is_negative(v),\n+       Some(v) if is_zero(v) => fail_unless!(is_negative(v)),\n        _ => fail!()\n    }\n    match from_str(~\"0\") {\n-       Some(v) if is_zero(v) => assert is_positive(v),\n+       Some(v) if is_zero(v) => fail_unless!(is_positive(v)),\n        _ => fail!()\n    }\n \n-   assert from_str(~\"\").is_none();\n-   assert from_str(~\"x\").is_none();\n-   assert from_str(~\" \").is_none();\n-   assert from_str(~\"   \").is_none();\n-   assert from_str(~\"e\").is_none();\n-   assert from_str(~\"E\").is_none();\n-   assert from_str(~\"E1\").is_none();\n-   assert from_str(~\"1e1e1\").is_none();\n-   assert from_str(~\"1e1.1\").is_none();\n-   assert from_str(~\"1e1-1\").is_none();\n+   fail_unless!(from_str(~\"\").is_none());\n+   fail_unless!(from_str(~\"x\").is_none());\n+   fail_unless!(from_str(~\" \").is_none());\n+   fail_unless!(from_str(~\"   \").is_none());\n+   fail_unless!(from_str(~\"e\").is_none());\n+   fail_unless!(from_str(~\"E\").is_none());\n+   fail_unless!(from_str(~\"E1\").is_none());\n+   fail_unless!(from_str(~\"1e1e1\").is_none());\n+   fail_unless!(from_str(~\"1e1.1\").is_none());\n+   fail_unless!(from_str(~\"1e1-1\").is_none());\n }\n \n #[test]\n pub fn test_from_str_hex() {\n-   assert from_str_hex(~\"a4\") == Some(164.);\n-   assert from_str_hex(~\"a4.fe\") == Some(164.9921875);\n-   assert from_str_hex(~\"-a4.fe\") == Some(-164.9921875);\n-   assert from_str_hex(~\"+a4.fe\") == Some(164.9921875);\n-   assert from_str_hex(~\"ff0P4\") == Some(0xff00 as float);\n-   assert from_str_hex(~\"ff0p4\") == Some(0xff00 as float);\n-   assert from_str_hex(~\"ff0p-4\") == Some(0xff as float);\n-   assert from_str_hex(~\".\") == Some(0.);\n-   assert from_str_hex(~\".p1\") == Some(0.);\n-   assert from_str_hex(~\".p-1\") == Some(0.);\n-   assert from_str_hex(~\"f.\") == Some(15.);\n-   assert from_str_hex(~\".f\") == Some(0.9375);\n-   assert from_str_hex(~\"0.f\") == Some(0.9375);\n-   assert from_str_hex(~\"-.f\") == Some(-0.9375);\n-   assert from_str_hex(~\"-f\") == Some(-15.);\n-   assert from_str_hex(~\"inf\") == Some(infinity);\n-   assert from_str_hex(~\"+inf\") == Some(infinity);\n-   assert from_str_hex(~\"-inf\") == Some(neg_infinity);\n+   fail_unless!(from_str_hex(~\"a4\") == Some(164.));\n+   fail_unless!(from_str_hex(~\"a4.fe\") == Some(164.9921875));\n+   fail_unless!(from_str_hex(~\"-a4.fe\") == Some(-164.9921875));\n+   fail_unless!(from_str_hex(~\"+a4.fe\") == Some(164.9921875));\n+   fail_unless!(from_str_hex(~\"ff0P4\") == Some(0xff00 as float));\n+   fail_unless!(from_str_hex(~\"ff0p4\") == Some(0xff00 as float));\n+   fail_unless!(from_str_hex(~\"ff0p-4\") == Some(0xff as float));\n+   fail_unless!(from_str_hex(~\".\") == Some(0.));\n+   fail_unless!(from_str_hex(~\".p1\") == Some(0.));\n+   fail_unless!(from_str_hex(~\".p-1\") == Some(0.));\n+   fail_unless!(from_str_hex(~\"f.\") == Some(15.));\n+   fail_unless!(from_str_hex(~\".f\") == Some(0.9375));\n+   fail_unless!(from_str_hex(~\"0.f\") == Some(0.9375));\n+   fail_unless!(from_str_hex(~\"-.f\") == Some(-0.9375));\n+   fail_unless!(from_str_hex(~\"-f\") == Some(-15.));\n+   fail_unless!(from_str_hex(~\"inf\") == Some(infinity));\n+   fail_unless!(from_str_hex(~\"+inf\") == Some(infinity));\n+   fail_unless!(from_str_hex(~\"-inf\") == Some(neg_infinity));\n    // note: NaN != NaN, hence this slightly complex test\n    match from_str_hex(~\"NaN\") {\n-       Some(f) => assert is_NaN(f),\n+       Some(f) => fail_unless!(is_NaN(f)),\n        None => fail!()\n    }\n    // note: -0 == 0, hence these slightly more complex tests\n    match from_str_hex(~\"-0\") {\n-       Some(v) if is_zero(v) => assert is_negative(v),\n+       Some(v) if is_zero(v) => fail_unless!(is_negative(v)),\n        _ => fail!()\n    }\n    match from_str_hex(~\"0\") {\n-       Some(v) if is_zero(v) => assert is_positive(v),\n+       Some(v) if is_zero(v) => fail_unless!(is_positive(v)),\n        _ => fail!()\n    }\n-   assert from_str_hex(~\"e\") == Some(14.);\n-   assert from_str_hex(~\"E\") == Some(14.);\n-   assert from_str_hex(~\"E1\") == Some(225.);\n-   assert from_str_hex(~\"1e1e1\") == Some(123361.);\n-   assert from_str_hex(~\"1e1.1\") == Some(481.0625);\n-\n-   assert from_str_hex(~\"\").is_none();\n-   assert from_str_hex(~\"x\").is_none();\n-   assert from_str_hex(~\" \").is_none();\n-   assert from_str_hex(~\"   \").is_none();\n-   assert from_str_hex(~\"p\").is_none();\n-   assert from_str_hex(~\"P\").is_none();\n-   assert from_str_hex(~\"P1\").is_none();\n-   assert from_str_hex(~\"1p1p1\").is_none();\n-   assert from_str_hex(~\"1p1.1\").is_none();\n-   assert from_str_hex(~\"1p1-1\").is_none();\n+   fail_unless!(from_str_hex(~\"e\") == Some(14.));\n+   fail_unless!(from_str_hex(~\"E\") == Some(14.));\n+   fail_unless!(from_str_hex(~\"E1\") == Some(225.));\n+   fail_unless!(from_str_hex(~\"1e1e1\") == Some(123361.));\n+   fail_unless!(from_str_hex(~\"1e1.1\") == Some(481.0625));\n+\n+   fail_unless!(from_str_hex(~\"\").is_none());\n+   fail_unless!(from_str_hex(~\"x\").is_none());\n+   fail_unless!(from_str_hex(~\" \").is_none());\n+   fail_unless!(from_str_hex(~\"   \").is_none());\n+   fail_unless!(from_str_hex(~\"p\").is_none());\n+   fail_unless!(from_str_hex(~\"P\").is_none());\n+   fail_unless!(from_str_hex(~\"P1\").is_none());\n+   fail_unless!(from_str_hex(~\"1p1p1\").is_none());\n+   fail_unless!(from_str_hex(~\"1p1.1\").is_none());\n+   fail_unless!(from_str_hex(~\"1p1-1\").is_none());\n }\n \n #[test]\n pub fn test_to_str_hex() {\n-   assert to_str_hex(164.) == ~\"a4\";\n-   assert to_str_hex(164.9921875) == ~\"a4.fe\";\n-   assert to_str_hex(-164.9921875) == ~\"-a4.fe\";\n-   assert to_str_hex(0xff00 as float) == ~\"ff00\";\n-   assert to_str_hex(-(0xff00 as float)) == ~\"-ff00\";\n-   assert to_str_hex(0.) == ~\"0\";\n-   assert to_str_hex(15.) == ~\"f\";\n-   assert to_str_hex(-15.) == ~\"-f\";\n-   assert to_str_hex(0.9375) == ~\"0.f\";\n-   assert to_str_hex(-0.9375) == ~\"-0.f\";\n-   assert to_str_hex(infinity) == ~\"inf\";\n-   assert to_str_hex(neg_infinity) == ~\"-inf\";\n-   assert to_str_hex(NaN) == ~\"NaN\";\n-   assert to_str_hex(0.) == ~\"0\";\n-   assert to_str_hex(-0.) == ~\"-0\";\n+   fail_unless!(to_str_hex(164.) == ~\"a4\");\n+   fail_unless!(to_str_hex(164.9921875) == ~\"a4.fe\");\n+   fail_unless!(to_str_hex(-164.9921875) == ~\"-a4.fe\");\n+   fail_unless!(to_str_hex(0xff00 as float) == ~\"ff00\");\n+   fail_unless!(to_str_hex(-(0xff00 as float)) == ~\"-ff00\");\n+   fail_unless!(to_str_hex(0.) == ~\"0\");\n+   fail_unless!(to_str_hex(15.) == ~\"f\");\n+   fail_unless!(to_str_hex(-15.) == ~\"-f\");\n+   fail_unless!(to_str_hex(0.9375) == ~\"0.f\");\n+   fail_unless!(to_str_hex(-0.9375) == ~\"-0.f\");\n+   fail_unless!(to_str_hex(infinity) == ~\"inf\");\n+   fail_unless!(to_str_hex(neg_infinity) == ~\"-inf\");\n+   fail_unless!(to_str_hex(NaN) == ~\"NaN\");\n+   fail_unless!(to_str_hex(0.) == ~\"0\");\n+   fail_unless!(to_str_hex(-0.) == ~\"-0\");\n }\n \n #[test]\n pub fn test_to_str_radix() {\n-   assert to_str_radix(36., 36u) == ~\"10\";\n-   assert to_str_radix(8.125, 2u) == ~\"1000.001\";\n+   fail_unless!(to_str_radix(36., 36u) == ~\"10\");\n+   fail_unless!(to_str_radix(8.125, 2u) == ~\"1000.001\");\n }\n \n #[test]\n pub fn test_from_str_radix() {\n-   assert from_str_radix(~\"10\", 36u) == Some(36.);\n-   assert from_str_radix(~\"1000.001\", 2u) == Some(8.125);\n+   fail_unless!(from_str_radix(~\"10\", 36u) == Some(36.));\n+   fail_unless!(from_str_radix(~\"1000.001\", 2u) == Some(8.125));\n }\n \n #[test]\n pub fn test_positive() {\n-  assert(is_positive(infinity));\n-  assert(is_positive(1.));\n-  assert(is_positive(0.));\n-  assert(!is_positive(-1.));\n-  assert(!is_positive(neg_infinity));\n-  assert(!is_positive(1./neg_infinity));\n-  assert(!is_positive(NaN));\n+  fail_unless!((is_positive(infinity)));\n+  fail_unless!((is_positive(1.)));\n+  fail_unless!((is_positive(0.)));\n+  fail_unless!((!is_positive(-1.)));\n+  fail_unless!((!is_positive(neg_infinity)));\n+  fail_unless!((!is_positive(1./neg_infinity)));\n+  fail_unless!((!is_positive(NaN)));\n }\n \n #[test]\n pub fn test_negative() {\n-  assert(!is_negative(infinity));\n-  assert(!is_negative(1.));\n-  assert(!is_negative(0.));\n-  assert(is_negative(-1.));\n-  assert(is_negative(neg_infinity));\n-  assert(is_negative(1./neg_infinity));\n-  assert(!is_negative(NaN));\n+  fail_unless!((!is_negative(infinity)));\n+  fail_unless!((!is_negative(1.)));\n+  fail_unless!((!is_negative(0.)));\n+  fail_unless!((is_negative(-1.)));\n+  fail_unless!((is_negative(neg_infinity)));\n+  fail_unless!((is_negative(1./neg_infinity)));\n+  fail_unless!((!is_negative(NaN)));\n }\n \n #[test]\n pub fn test_nonpositive() {\n-  assert(!is_nonpositive(infinity));\n-  assert(!is_nonpositive(1.));\n-  assert(!is_nonpositive(0.));\n-  assert(is_nonpositive(-1.));\n-  assert(is_nonpositive(neg_infinity));\n-  assert(is_nonpositive(1./neg_infinity));\n-  assert(!is_nonpositive(NaN));\n+  fail_unless!((!is_nonpositive(infinity)));\n+  fail_unless!((!is_nonpositive(1.)));\n+  fail_unless!((!is_nonpositive(0.)));\n+  fail_unless!((is_nonpositive(-1.)));\n+  fail_unless!((is_nonpositive(neg_infinity)));\n+  fail_unless!((is_nonpositive(1./neg_infinity)));\n+  fail_unless!((!is_nonpositive(NaN)));\n }\n \n #[test]\n pub fn test_nonnegative() {\n-  assert(is_nonnegative(infinity));\n-  assert(is_nonnegative(1.));\n-  assert(is_nonnegative(0.));\n-  assert(!is_nonnegative(-1.));\n-  assert(!is_nonnegative(neg_infinity));\n-  assert(!is_nonnegative(1./neg_infinity));\n-  assert(!is_nonnegative(NaN));\n+  fail_unless!((is_nonnegative(infinity)));\n+  fail_unless!((is_nonnegative(1.)));\n+  fail_unless!((is_nonnegative(0.)));\n+  fail_unless!((!is_nonnegative(-1.)));\n+  fail_unless!((!is_nonnegative(neg_infinity)));\n+  fail_unless!((!is_nonnegative(1./neg_infinity)));\n+  fail_unless!((!is_nonnegative(NaN)));\n }\n \n #[test]\n pub fn test_to_str_inf() {\n-    assert to_str_digits(infinity, 10u) == ~\"inf\";\n-    assert to_str_digits(-infinity, 10u) == ~\"-inf\";\n+    fail_unless!(to_str_digits(infinity, 10u) == ~\"inf\");\n+    fail_unless!(to_str_digits(-infinity, 10u) == ~\"-inf\");\n }\n \n #[test]\n pub fn test_round() {\n-    assert round(5.8) == 6.0;\n-    assert round(5.2) == 5.0;\n-    assert round(3.0) == 3.0;\n-    assert round(2.5) == 3.0;\n-    assert round(-3.5) == -4.0;\n+    fail_unless!(round(5.8) == 6.0);\n+    fail_unless!(round(5.2) == 5.0);\n+    fail_unless!(round(3.0) == 3.0);\n+    fail_unless!(round(2.5) == 3.0);\n+    fail_unless!(round(-3.5) == -4.0);\n }\n \n #[test]\n pub fn test_num() {\n     let ten: float = num::cast(10);\n     let two: float = num::cast(2);\n \n-    assert (ten.add(&two)    == num::cast(12));\n-    assert (ten.sub(&two)    == num::cast(8));\n-    assert (ten.mul(&two)    == num::cast(20));\n-    assert (ten.div(&two)    == num::cast(5));\n-    assert (ten.modulo(&two) == num::cast(0));\n+    fail_unless!((ten.add(&two)    == num::cast(12)));\n+    fail_unless!((ten.sub(&two)    == num::cast(8)));\n+    fail_unless!((ten.mul(&two)    == num::cast(20)));\n+    fail_unless!((ten.div(&two)    == num::cast(5)));\n+    fail_unless!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20f.to_uint());\n-    assert (20u8  == 20f.to_u8());\n-    assert (20u16 == 20f.to_u16());\n-    assert (20u32 == 20f.to_u32());\n-    assert (20u64 == 20f.to_u64());\n-    assert (20i   == 20f.to_int());\n-    assert (20i8  == 20f.to_i8());\n-    assert (20i16 == 20f.to_i16());\n-    assert (20i32 == 20f.to_i32());\n-    assert (20i64 == 20f.to_i64());\n-    assert (20f   == 20f.to_float());\n-    assert (20f32 == 20f.to_f32());\n-    assert (20f64 == 20f.to_f64());\n-\n-    assert (20f == NumCast::from(20u));\n-    assert (20f == NumCast::from(20u8));\n-    assert (20f == NumCast::from(20u16));\n-    assert (20f == NumCast::from(20u32));\n-    assert (20f == NumCast::from(20u64));\n-    assert (20f == NumCast::from(20i));\n-    assert (20f == NumCast::from(20i8));\n-    assert (20f == NumCast::from(20i16));\n-    assert (20f == NumCast::from(20i32));\n-    assert (20f == NumCast::from(20i64));\n-    assert (20f == NumCast::from(20f));\n-    assert (20f == NumCast::from(20f32));\n-    assert (20f == NumCast::from(20f64));\n-\n-    assert (20f == num::cast(20u));\n-    assert (20f == num::cast(20u8));\n-    assert (20f == num::cast(20u16));\n-    assert (20f == num::cast(20u32));\n-    assert (20f == num::cast(20u64));\n-    assert (20f == num::cast(20i));\n-    assert (20f == num::cast(20i8));\n-    assert (20f == num::cast(20i16));\n-    assert (20f == num::cast(20i32));\n-    assert (20f == num::cast(20i64));\n-    assert (20f == num::cast(20f));\n-    assert (20f == num::cast(20f32));\n-    assert (20f == num::cast(20f64));\n+    fail_unless!((20u   == 20f.to_uint()));\n+    fail_unless!((20u8  == 20f.to_u8()));\n+    fail_unless!((20u16 == 20f.to_u16()));\n+    fail_unless!((20u32 == 20f.to_u32()));\n+    fail_unless!((20u64 == 20f.to_u64()));\n+    fail_unless!((20i   == 20f.to_int()));\n+    fail_unless!((20i8  == 20f.to_i8()));\n+    fail_unless!((20i16 == 20f.to_i16()));\n+    fail_unless!((20i32 == 20f.to_i32()));\n+    fail_unless!((20i64 == 20f.to_i64()));\n+    fail_unless!((20f   == 20f.to_float()));\n+    fail_unless!((20f32 == 20f.to_f32()));\n+    fail_unless!((20f64 == 20f.to_f64()));\n+\n+    fail_unless!((20f == NumCast::from(20u)));\n+    fail_unless!((20f == NumCast::from(20u8)));\n+    fail_unless!((20f == NumCast::from(20u16)));\n+    fail_unless!((20f == NumCast::from(20u32)));\n+    fail_unless!((20f == NumCast::from(20u64)));\n+    fail_unless!((20f == NumCast::from(20i)));\n+    fail_unless!((20f == NumCast::from(20i8)));\n+    fail_unless!((20f == NumCast::from(20i16)));\n+    fail_unless!((20f == NumCast::from(20i32)));\n+    fail_unless!((20f == NumCast::from(20i64)));\n+    fail_unless!((20f == NumCast::from(20f)));\n+    fail_unless!((20f == NumCast::from(20f32)));\n+    fail_unless!((20f == NumCast::from(20f64)));\n+\n+    fail_unless!((20f == num::cast(20u)));\n+    fail_unless!((20f == num::cast(20u8)));\n+    fail_unless!((20f == num::cast(20u16)));\n+    fail_unless!((20f == num::cast(20u32)));\n+    fail_unless!((20f == num::cast(20u64)));\n+    fail_unless!((20f == num::cast(20i)));\n+    fail_unless!((20f == num::cast(20i8)));\n+    fail_unless!((20f == num::cast(20i16)));\n+    fail_unless!((20f == num::cast(20i32)));\n+    fail_unless!((20f == num::cast(20i64)));\n+    fail_unless!((20f == num::cast(20f)));\n+    fail_unless!((20f == num::cast(20f32)));\n+    fail_unless!((20f == num::cast(20f64)));\n }\n \n "}, {"sha": "8096e6f99e7b454f67fc6f92150d0ac22f1e66a3", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -41,18 +41,18 @@ pub pure fn div(x: T, y: T) -> T { x / y }\n  *\n  * # Examples\n  * ~~~\n- * assert int::rem(5 / 2) == 1;\n+ * fail_unless!(int::rem(5 / 2) == 1);\n  * ~~~\n  *\n  * When faced with negative numbers, the result copies the sign of the\n  * dividend.\n  *\n  * ~~~\n- * assert int::rem(2 / -3) ==  2;\n+ * fail_unless!(int::rem(2 / -3) ==  2);\n  * ~~~\n  *\n  * ~~~\n- * assert int::rem(-2 / 3) ==  -2;\n+ * fail_unless!(int::rem(-2 / 3) ==  -2);\n  * ~~~\n  *\n  */\n@@ -95,7 +95,7 @@ pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n  * for int::range(1, 5) |i| {\n  *     sum += i;\n  * }\n- * assert sum == 10;\n+ * fail_unless!(sum == 10);\n  * ~~~\n  */\n #[inline(always)]\n@@ -275,129 +275,129 @@ impl ToStrRadix for T {\n \n #[test]\n fn test_from_str() {\n-    assert from_str(~\"0\") == Some(0 as T);\n-    assert from_str(~\"3\") == Some(3 as T);\n-    assert from_str(~\"10\") == Some(10 as T);\n-    assert i32::from_str(~\"123456789\") == Some(123456789 as i32);\n-    assert from_str(~\"00100\") == Some(100 as T);\n+    fail_unless!(from_str(~\"0\") == Some(0 as T));\n+    fail_unless!(from_str(~\"3\") == Some(3 as T));\n+    fail_unless!(from_str(~\"10\") == Some(10 as T));\n+    fail_unless!(i32::from_str(~\"123456789\") == Some(123456789 as i32));\n+    fail_unless!(from_str(~\"00100\") == Some(100 as T));\n \n-    assert from_str(~\"-1\") == Some(-1 as T);\n-    assert from_str(~\"-3\") == Some(-3 as T);\n-    assert from_str(~\"-10\") == Some(-10 as T);\n-    assert i32::from_str(~\"-123456789\") == Some(-123456789 as i32);\n-    assert from_str(~\"-00100\") == Some(-100 as T);\n+    fail_unless!(from_str(~\"-1\") == Some(-1 as T));\n+    fail_unless!(from_str(~\"-3\") == Some(-3 as T));\n+    fail_unless!(from_str(~\"-10\") == Some(-10 as T));\n+    fail_unless!(i32::from_str(~\"-123456789\") == Some(-123456789 as i32));\n+    fail_unless!(from_str(~\"-00100\") == Some(-100 as T));\n \n-    assert from_str(~\" \").is_none();\n-    assert from_str(~\"x\").is_none();\n+    fail_unless!(from_str(~\" \").is_none());\n+    fail_unless!(from_str(~\"x\").is_none());\n }\n \n #[test]\n fn test_parse_bytes() {\n     use str::to_bytes;\n-    assert parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T);\n-    assert parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T);\n-    assert parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T);\n-    assert i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32);\n-    assert i32::parse_bytes(to_bytes(~\"ffff\"), 16u) == Some(65535 as i32);\n-    assert i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) == Some(65535 as i32);\n-    assert parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T);\n-    assert parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T);\n-\n-    assert parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T);\n-    assert parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T);\n-    assert parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T);\n-    assert i32::parse_bytes(to_bytes(~\"-123\"), 16u) == Some(-291 as i32);\n-    assert i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) == Some(-65535 as i32);\n-    assert i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) == Some(-65535 as i32);\n-    assert parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T);\n-    assert parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T);\n-\n-    assert parse_bytes(to_bytes(~\"Z\"), 35u).is_none();\n-    assert parse_bytes(to_bytes(~\"-9\"), 2u).is_none();\n+    fail_unless!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u) == Some(65535 as i32));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) == Some(65535 as i32));\n+    fail_unless!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T));\n+\n+    fail_unless!(parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"-123\"), 16u) == Some(-291 as i32));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) == Some(-65535 as i32));\n+    fail_unless!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) == Some(-65535 as i32));\n+    fail_unless!(parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T));\n+\n+    fail_unless!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n+    fail_unless!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n }\n \n #[test]\n fn test_to_str() {\n-    assert (to_str_radix(0 as T, 10u) == ~\"0\");\n-    assert (to_str_radix(1 as T, 10u) == ~\"1\");\n-    assert (to_str_radix(-1 as T, 10u) == ~\"-1\");\n-    assert (to_str_radix(127 as T, 16u) == ~\"7f\");\n-    assert (to_str_radix(100 as T, 10u) == ~\"100\");\n+    fail_unless!((to_str_radix(0 as T, 10u) == ~\"0\"));\n+    fail_unless!((to_str_radix(1 as T, 10u) == ~\"1\"));\n+    fail_unless!((to_str_radix(-1 as T, 10u) == ~\"-1\"));\n+    fail_unless!((to_str_radix(127 as T, 16u) == ~\"7f\"));\n+    fail_unless!((to_str_radix(100 as T, 10u) == ~\"100\"));\n \n }\n \n #[test]\n fn test_int_to_str_overflow() {\n     let mut i8_val: i8 = 127_i8;\n-    assert (i8::to_str(i8_val) == ~\"127\");\n+    fail_unless!((i8::to_str(i8_val) == ~\"127\"));\n \n     i8_val += 1 as i8;\n-    assert (i8::to_str(i8_val) == ~\"-128\");\n+    fail_unless!((i8::to_str(i8_val) == ~\"-128\"));\n \n     let mut i16_val: i16 = 32_767_i16;\n-    assert (i16::to_str(i16_val) == ~\"32767\");\n+    fail_unless!((i16::to_str(i16_val) == ~\"32767\"));\n \n     i16_val += 1 as i16;\n-    assert (i16::to_str(i16_val) == ~\"-32768\");\n+    fail_unless!((i16::to_str(i16_val) == ~\"-32768\"));\n \n     let mut i32_val: i32 = 2_147_483_647_i32;\n-    assert (i32::to_str(i32_val) == ~\"2147483647\");\n+    fail_unless!((i32::to_str(i32_val) == ~\"2147483647\"));\n \n     i32_val += 1 as i32;\n-    assert (i32::to_str(i32_val) == ~\"-2147483648\");\n+    fail_unless!((i32::to_str(i32_val) == ~\"-2147483648\"));\n \n     let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-    assert (i64::to_str(i64_val) == ~\"9223372036854775807\");\n+    fail_unless!((i64::to_str(i64_val) == ~\"9223372036854775807\"));\n \n     i64_val += 1 as i64;\n-    assert (i64::to_str(i64_val) == ~\"-9223372036854775808\");\n+    fail_unless!((i64::to_str(i64_val) == ~\"-9223372036854775808\"));\n }\n \n #[test]\n fn test_int_from_str_overflow() {\n     let mut i8_val: i8 = 127_i8;\n-    assert (i8::from_str(~\"127\") == Some(i8_val));\n-    assert (i8::from_str(~\"128\").is_none());\n+    fail_unless!((i8::from_str(~\"127\") == Some(i8_val)));\n+    fail_unless!((i8::from_str(~\"128\").is_none()));\n \n     i8_val += 1 as i8;\n-    assert (i8::from_str(~\"-128\") == Some(i8_val));\n-    assert (i8::from_str(~\"-129\").is_none());\n+    fail_unless!((i8::from_str(~\"-128\") == Some(i8_val)));\n+    fail_unless!((i8::from_str(~\"-129\").is_none()));\n \n     let mut i16_val: i16 = 32_767_i16;\n-    assert (i16::from_str(~\"32767\") == Some(i16_val));\n-    assert (i16::from_str(~\"32768\").is_none());\n+    fail_unless!((i16::from_str(~\"32767\") == Some(i16_val)));\n+    fail_unless!((i16::from_str(~\"32768\").is_none()));\n \n     i16_val += 1 as i16;\n-    assert (i16::from_str(~\"-32768\") == Some(i16_val));\n-    assert (i16::from_str(~\"-32769\").is_none());\n+    fail_unless!((i16::from_str(~\"-32768\") == Some(i16_val)));\n+    fail_unless!((i16::from_str(~\"-32769\").is_none()));\n \n     let mut i32_val: i32 = 2_147_483_647_i32;\n-    assert (i32::from_str(~\"2147483647\") == Some(i32_val));\n-    assert (i32::from_str(~\"2147483648\").is_none());\n+    fail_unless!((i32::from_str(~\"2147483647\") == Some(i32_val)));\n+    fail_unless!((i32::from_str(~\"2147483648\").is_none()));\n \n     i32_val += 1 as i32;\n-    assert (i32::from_str(~\"-2147483648\") == Some(i32_val));\n-    assert (i32::from_str(~\"-2147483649\").is_none());\n+    fail_unless!((i32::from_str(~\"-2147483648\") == Some(i32_val)));\n+    fail_unless!((i32::from_str(~\"-2147483649\").is_none()));\n \n     let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-    assert (i64::from_str(~\"9223372036854775807\") == Some(i64_val));\n-    assert (i64::from_str(~\"9223372036854775808\").is_none());\n+    fail_unless!((i64::from_str(~\"9223372036854775807\") == Some(i64_val)));\n+    fail_unless!((i64::from_str(~\"9223372036854775808\").is_none()));\n \n     i64_val += 1 as i64;\n-    assert (i64::from_str(~\"-9223372036854775808\") == Some(i64_val));\n-    assert (i64::from_str(~\"-9223372036854775809\").is_none());\n+    fail_unless!((i64::from_str(~\"-9223372036854775808\") == Some(i64_val)));\n+    fail_unless!((i64::from_str(~\"-9223372036854775809\").is_none()));\n }\n \n #[test]\n pub fn test_num() {\n     let ten: T = num::cast(10);\n     let two: T = num::cast(2);\n \n-    assert (ten.add(&two)    == num::cast(12));\n-    assert (ten.sub(&two)    == num::cast(8));\n-    assert (ten.mul(&two)    == num::cast(20));\n-    assert (ten.div(&two)    == num::cast(5));\n-    assert (ten.modulo(&two) == num::cast(0));\n+    fail_unless!((ten.add(&two)    == num::cast(12)));\n+    fail_unless!((ten.sub(&two)    == num::cast(8)));\n+    fail_unless!((ten.mul(&two)    == num::cast(20)));\n+    fail_unless!((ten.div(&two)    == num::cast(5)));\n+    fail_unless!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]\n@@ -416,10 +416,10 @@ pub fn test_ranges() {\n     for range_step(36,30,-2) |i| {\n         l.push(i);\n     }\n-    assert l == ~[0,1,2,\n-                  13,12,11,\n-                  20,22,24,\n-                  36,34,32];\n+    fail_unless!(l == ~[0,1,2,\n+                        13,12,11,\n+                        20,22,24,\n+                        36,34,32]);\n \n     // None of the `fail`s should execute.\n     for range(10,0) |_i| {"}, {"sha": "3c4ca532be764beb3edcb1cf62da5ded3032344f", "filename": "src/libcore/num/int-template/i16.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi16.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i16 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20i16.to_uint());\n-    assert (20u8  == 20i16.to_u8());\n-    assert (20u16 == 20i16.to_u16());\n-    assert (20u32 == 20i16.to_u32());\n-    assert (20u64 == 20i16.to_u64());\n-    assert (20i   == 20i16.to_int());\n-    assert (20i8  == 20i16.to_i8());\n-    assert (20i16 == 20i16.to_i16());\n-    assert (20i32 == 20i16.to_i32());\n-    assert (20i64 == 20i16.to_i64());\n-    assert (20f   == 20i16.to_float());\n-    assert (20f32 == 20i16.to_f32());\n-    assert (20f64 == 20i16.to_f64());\n+    fail_unless!((20u   == 20i16.to_uint()));\n+    fail_unless!((20u8  == 20i16.to_u8()));\n+    fail_unless!((20u16 == 20i16.to_u16()));\n+    fail_unless!((20u32 == 20i16.to_u32()));\n+    fail_unless!((20u64 == 20i16.to_u64()));\n+    fail_unless!((20i   == 20i16.to_int()));\n+    fail_unless!((20i8  == 20i16.to_i8()));\n+    fail_unless!((20i16 == 20i16.to_i16()));\n+    fail_unless!((20i32 == 20i16.to_i32()));\n+    fail_unless!((20i64 == 20i16.to_i64()));\n+    fail_unless!((20f   == 20i16.to_float()));\n+    fail_unless!((20f32 == 20i16.to_f32()));\n+    fail_unless!((20f64 == 20i16.to_f64()));\n \n-    assert (20i16 == NumCast::from(20u));\n-    assert (20i16 == NumCast::from(20u8));\n-    assert (20i16 == NumCast::from(20u16));\n-    assert (20i16 == NumCast::from(20u32));\n-    assert (20i16 == NumCast::from(20u64));\n-    assert (20i16 == NumCast::from(20i));\n-    assert (20i16 == NumCast::from(20i8));\n-    assert (20i16 == NumCast::from(20i16));\n-    assert (20i16 == NumCast::from(20i32));\n-    assert (20i16 == NumCast::from(20i64));\n-    assert (20i16 == NumCast::from(20f));\n-    assert (20i16 == NumCast::from(20f32));\n-    assert (20i16 == NumCast::from(20f64));\n+    fail_unless!((20i16 == NumCast::from(20u)));\n+    fail_unless!((20i16 == NumCast::from(20u8)));\n+    fail_unless!((20i16 == NumCast::from(20u16)));\n+    fail_unless!((20i16 == NumCast::from(20u32)));\n+    fail_unless!((20i16 == NumCast::from(20u64)));\n+    fail_unless!((20i16 == NumCast::from(20i)));\n+    fail_unless!((20i16 == NumCast::from(20i8)));\n+    fail_unless!((20i16 == NumCast::from(20i16)));\n+    fail_unless!((20i16 == NumCast::from(20i32)));\n+    fail_unless!((20i16 == NumCast::from(20i64)));\n+    fail_unless!((20i16 == NumCast::from(20f)));\n+    fail_unless!((20i16 == NumCast::from(20f32)));\n+    fail_unless!((20i16 == NumCast::from(20f64)));\n \n-    assert (20i16 == num::cast(20u));\n-    assert (20i16 == num::cast(20u8));\n-    assert (20i16 == num::cast(20u16));\n-    assert (20i16 == num::cast(20u32));\n-    assert (20i16 == num::cast(20u64));\n-    assert (20i16 == num::cast(20i));\n-    assert (20i16 == num::cast(20i8));\n-    assert (20i16 == num::cast(20i16));\n-    assert (20i16 == num::cast(20i32));\n-    assert (20i16 == num::cast(20i64));\n-    assert (20i16 == num::cast(20f));\n-    assert (20i16 == num::cast(20f32));\n-    assert (20i16 == num::cast(20f64));\n+    fail_unless!((20i16 == num::cast(20u)));\n+    fail_unless!((20i16 == num::cast(20u8)));\n+    fail_unless!((20i16 == num::cast(20u16)));\n+    fail_unless!((20i16 == num::cast(20u32)));\n+    fail_unless!((20i16 == num::cast(20u64)));\n+    fail_unless!((20i16 == num::cast(20i)));\n+    fail_unless!((20i16 == num::cast(20i8)));\n+    fail_unless!((20i16 == num::cast(20i16)));\n+    fail_unless!((20i16 == num::cast(20i32)));\n+    fail_unless!((20i16 == num::cast(20i64)));\n+    fail_unless!((20i16 == num::cast(20f)));\n+    fail_unless!((20i16 == num::cast(20f32)));\n+    fail_unless!((20i16 == num::cast(20f64)));\n }"}, {"sha": "30eb4437d570113611b08313371177649513d1a3", "filename": "src/libcore/num/int-template/i32.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi32.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i32 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20i32.to_uint());\n-    assert (20u8  == 20i32.to_u8());\n-    assert (20u16 == 20i32.to_u16());\n-    assert (20u32 == 20i32.to_u32());\n-    assert (20u64 == 20i32.to_u64());\n-    assert (20i   == 20i32.to_int());\n-    assert (20i8  == 20i32.to_i8());\n-    assert (20i16 == 20i32.to_i16());\n-    assert (20i32 == 20i32.to_i32());\n-    assert (20i64 == 20i32.to_i64());\n-    assert (20f   == 20i32.to_float());\n-    assert (20f32 == 20i32.to_f32());\n-    assert (20f64 == 20i32.to_f64());\n+    fail_unless!((20u   == 20i32.to_uint()));\n+    fail_unless!((20u8  == 20i32.to_u8()));\n+    fail_unless!((20u16 == 20i32.to_u16()));\n+    fail_unless!((20u32 == 20i32.to_u32()));\n+    fail_unless!((20u64 == 20i32.to_u64()));\n+    fail_unless!((20i   == 20i32.to_int()));\n+    fail_unless!((20i8  == 20i32.to_i8()));\n+    fail_unless!((20i16 == 20i32.to_i16()));\n+    fail_unless!((20i32 == 20i32.to_i32()));\n+    fail_unless!((20i64 == 20i32.to_i64()));\n+    fail_unless!((20f   == 20i32.to_float()));\n+    fail_unless!((20f32 == 20i32.to_f32()));\n+    fail_unless!((20f64 == 20i32.to_f64()));\n \n-    assert (20i32 == NumCast::from(20u));\n-    assert (20i32 == NumCast::from(20u8));\n-    assert (20i32 == NumCast::from(20u16));\n-    assert (20i32 == NumCast::from(20u32));\n-    assert (20i32 == NumCast::from(20u64));\n-    assert (20i32 == NumCast::from(20i));\n-    assert (20i32 == NumCast::from(20i8));\n-    assert (20i32 == NumCast::from(20i16));\n-    assert (20i32 == NumCast::from(20i32));\n-    assert (20i32 == NumCast::from(20i64));\n-    assert (20i32 == NumCast::from(20f));\n-    assert (20i32 == NumCast::from(20f32));\n-    assert (20i32 == NumCast::from(20f64));\n+    fail_unless!((20i32 == NumCast::from(20u)));\n+    fail_unless!((20i32 == NumCast::from(20u8)));\n+    fail_unless!((20i32 == NumCast::from(20u16)));\n+    fail_unless!((20i32 == NumCast::from(20u32)));\n+    fail_unless!((20i32 == NumCast::from(20u64)));\n+    fail_unless!((20i32 == NumCast::from(20i)));\n+    fail_unless!((20i32 == NumCast::from(20i8)));\n+    fail_unless!((20i32 == NumCast::from(20i16)));\n+    fail_unless!((20i32 == NumCast::from(20i32)));\n+    fail_unless!((20i32 == NumCast::from(20i64)));\n+    fail_unless!((20i32 == NumCast::from(20f)));\n+    fail_unless!((20i32 == NumCast::from(20f32)));\n+    fail_unless!((20i32 == NumCast::from(20f64)));\n \n-    assert (20i32 == num::cast(20u));\n-    assert (20i32 == num::cast(20u8));\n-    assert (20i32 == num::cast(20u16));\n-    assert (20i32 == num::cast(20u32));\n-    assert (20i32 == num::cast(20u64));\n-    assert (20i32 == num::cast(20i));\n-    assert (20i32 == num::cast(20i8));\n-    assert (20i32 == num::cast(20i16));\n-    assert (20i32 == num::cast(20i32));\n-    assert (20i32 == num::cast(20i64));\n-    assert (20i32 == num::cast(20f));\n-    assert (20i32 == num::cast(20f32));\n-    assert (20i32 == num::cast(20f64));\n+    fail_unless!((20i32 == num::cast(20u)));\n+    fail_unless!((20i32 == num::cast(20u8)));\n+    fail_unless!((20i32 == num::cast(20u16)));\n+    fail_unless!((20i32 == num::cast(20u32)));\n+    fail_unless!((20i32 == num::cast(20u64)));\n+    fail_unless!((20i32 == num::cast(20i)));\n+    fail_unless!((20i32 == num::cast(20i8)));\n+    fail_unless!((20i32 == num::cast(20i16)));\n+    fail_unless!((20i32 == num::cast(20i32)));\n+    fail_unless!((20i32 == num::cast(20i64)));\n+    fail_unless!((20i32 == num::cast(20f)));\n+    fail_unless!((20i32 == num::cast(20f32)));\n+    fail_unless!((20i32 == num::cast(20f64)));\n }"}, {"sha": "61736cf958743783abb182c58ccc439c629fd83a", "filename": "src/libcore/num/int-template/i64.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi64.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i64 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20i64.to_uint());\n-    assert (20u8  == 20i64.to_u8());\n-    assert (20u16 == 20i64.to_u16());\n-    assert (20u32 == 20i64.to_u32());\n-    assert (20u64 == 20i64.to_u64());\n-    assert (20i   == 20i64.to_int());\n-    assert (20i8  == 20i64.to_i8());\n-    assert (20i16 == 20i64.to_i16());\n-    assert (20i32 == 20i64.to_i32());\n-    assert (20i64 == 20i64.to_i64());\n-    assert (20f   == 20i64.to_float());\n-    assert (20f32 == 20i64.to_f32());\n-    assert (20f64 == 20i64.to_f64());\n+    fail_unless!((20u   == 20i64.to_uint()));\n+    fail_unless!((20u8  == 20i64.to_u8()));\n+    fail_unless!((20u16 == 20i64.to_u16()));\n+    fail_unless!((20u32 == 20i64.to_u32()));\n+    fail_unless!((20u64 == 20i64.to_u64()));\n+    fail_unless!((20i   == 20i64.to_int()));\n+    fail_unless!((20i8  == 20i64.to_i8()));\n+    fail_unless!((20i16 == 20i64.to_i16()));\n+    fail_unless!((20i32 == 20i64.to_i32()));\n+    fail_unless!((20i64 == 20i64.to_i64()));\n+    fail_unless!((20f   == 20i64.to_float()));\n+    fail_unless!((20f32 == 20i64.to_f32()));\n+    fail_unless!((20f64 == 20i64.to_f64()));\n \n-    assert (20i64 == NumCast::from(20u));\n-    assert (20i64 == NumCast::from(20u8));\n-    assert (20i64 == NumCast::from(20u16));\n-    assert (20i64 == NumCast::from(20u32));\n-    assert (20i64 == NumCast::from(20u64));\n-    assert (20i64 == NumCast::from(20i));\n-    assert (20i64 == NumCast::from(20i8));\n-    assert (20i64 == NumCast::from(20i16));\n-    assert (20i64 == NumCast::from(20i32));\n-    assert (20i64 == NumCast::from(20i64));\n-    assert (20i64 == NumCast::from(20f));\n-    assert (20i64 == NumCast::from(20f32));\n-    assert (20i64 == NumCast::from(20f64));\n+    fail_unless!((20i64 == NumCast::from(20u)));\n+    fail_unless!((20i64 == NumCast::from(20u8)));\n+    fail_unless!((20i64 == NumCast::from(20u16)));\n+    fail_unless!((20i64 == NumCast::from(20u32)));\n+    fail_unless!((20i64 == NumCast::from(20u64)));\n+    fail_unless!((20i64 == NumCast::from(20i)));\n+    fail_unless!((20i64 == NumCast::from(20i8)));\n+    fail_unless!((20i64 == NumCast::from(20i16)));\n+    fail_unless!((20i64 == NumCast::from(20i32)));\n+    fail_unless!((20i64 == NumCast::from(20i64)));\n+    fail_unless!((20i64 == NumCast::from(20f)));\n+    fail_unless!((20i64 == NumCast::from(20f32)));\n+    fail_unless!((20i64 == NumCast::from(20f64)));\n \n-    assert (20i64 == num::cast(20u));\n-    assert (20i64 == num::cast(20u8));\n-    assert (20i64 == num::cast(20u16));\n-    assert (20i64 == num::cast(20u32));\n-    assert (20i64 == num::cast(20u64));\n-    assert (20i64 == num::cast(20i));\n-    assert (20i64 == num::cast(20i8));\n-    assert (20i64 == num::cast(20i16));\n-    assert (20i64 == num::cast(20i32));\n-    assert (20i64 == num::cast(20i64));\n-    assert (20i64 == num::cast(20f));\n-    assert (20i64 == num::cast(20f32));\n-    assert (20i64 == num::cast(20f64));\n+    fail_unless!((20i64 == num::cast(20u)));\n+    fail_unless!((20i64 == num::cast(20u8)));\n+    fail_unless!((20i64 == num::cast(20u16)));\n+    fail_unless!((20i64 == num::cast(20u32)));\n+    fail_unless!((20i64 == num::cast(20u64)));\n+    fail_unless!((20i64 == num::cast(20i)));\n+    fail_unless!((20i64 == num::cast(20i8)));\n+    fail_unless!((20i64 == num::cast(20i16)));\n+    fail_unless!((20i64 == num::cast(20i32)));\n+    fail_unless!((20i64 == num::cast(20i64)));\n+    fail_unless!((20i64 == num::cast(20f)));\n+    fail_unless!((20i64 == num::cast(20f32)));\n+    fail_unless!((20i64 == num::cast(20f64)));\n }"}, {"sha": "e70811adff1c0162e494c50bfe1ae21a3a5f5de2", "filename": "src/libcore/num/int-template/i8.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fi8.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -43,45 +43,45 @@ impl NumCast for i8 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20i8.to_uint());\n-    assert (20u8  == 20i8.to_u8());\n-    assert (20u16 == 20i8.to_u16());\n-    assert (20u32 == 20i8.to_u32());\n-    assert (20u64 == 20i8.to_u64());\n-    assert (20i   == 20i8.to_int());\n-    assert (20i8  == 20i8.to_i8());\n-    assert (20i16 == 20i8.to_i16());\n-    assert (20i32 == 20i8.to_i32());\n-    assert (20i64 == 20i8.to_i64());\n-    assert (20f   == 20i8.to_float());\n-    assert (20f32 == 20i8.to_f32());\n-    assert (20f64 == 20i8.to_f64());\n+    fail_unless!((20u   == 20i8.to_uint()));\n+    fail_unless!((20u8  == 20i8.to_u8()));\n+    fail_unless!((20u16 == 20i8.to_u16()));\n+    fail_unless!((20u32 == 20i8.to_u32()));\n+    fail_unless!((20u64 == 20i8.to_u64()));\n+    fail_unless!((20i   == 20i8.to_int()));\n+    fail_unless!((20i8  == 20i8.to_i8()));\n+    fail_unless!((20i16 == 20i8.to_i16()));\n+    fail_unless!((20i32 == 20i8.to_i32()));\n+    fail_unless!((20i64 == 20i8.to_i64()));\n+    fail_unless!((20f   == 20i8.to_float()));\n+    fail_unless!((20f32 == 20i8.to_f32()));\n+    fail_unless!((20f64 == 20i8.to_f64()));\n \n-    assert (20i8 == NumCast::from(20u));\n-    assert (20i8 == NumCast::from(20u8));\n-    assert (20i8 == NumCast::from(20u16));\n-    assert (20i8 == NumCast::from(20u32));\n-    assert (20i8 == NumCast::from(20u64));\n-    assert (20i8 == NumCast::from(20i));\n-    assert (20i8 == NumCast::from(20i8));\n-    assert (20i8 == NumCast::from(20i16));\n-    assert (20i8 == NumCast::from(20i32));\n-    assert (20i8 == NumCast::from(20i64));\n-    assert (20i8 == NumCast::from(20f));\n-    assert (20i8 == NumCast::from(20f32));\n-    assert (20i8 == NumCast::from(20f64));\n+    fail_unless!((20i8 == NumCast::from(20u)));\n+    fail_unless!((20i8 == NumCast::from(20u8)));\n+    fail_unless!((20i8 == NumCast::from(20u16)));\n+    fail_unless!((20i8 == NumCast::from(20u32)));\n+    fail_unless!((20i8 == NumCast::from(20u64)));\n+    fail_unless!((20i8 == NumCast::from(20i)));\n+    fail_unless!((20i8 == NumCast::from(20i8)));\n+    fail_unless!((20i8 == NumCast::from(20i16)));\n+    fail_unless!((20i8 == NumCast::from(20i32)));\n+    fail_unless!((20i8 == NumCast::from(20i64)));\n+    fail_unless!((20i8 == NumCast::from(20f)));\n+    fail_unless!((20i8 == NumCast::from(20f32)));\n+    fail_unless!((20i8 == NumCast::from(20f64)));\n \n-    assert (20i8 == num::cast(20u));\n-    assert (20i8 == num::cast(20u8));\n-    assert (20i8 == num::cast(20u16));\n-    assert (20i8 == num::cast(20u32));\n-    assert (20i8 == num::cast(20u64));\n-    assert (20i8 == num::cast(20i));\n-    assert (20i8 == num::cast(20i8));\n-    assert (20i8 == num::cast(20i16));\n-    assert (20i8 == num::cast(20i32));\n-    assert (20i8 == num::cast(20i64));\n-    assert (20i8 == num::cast(20f));\n-    assert (20i8 == num::cast(20f32));\n-    assert (20i8 == num::cast(20f64));\n+    fail_unless!((20i8 == num::cast(20u)));\n+    fail_unless!((20i8 == num::cast(20u8)));\n+    fail_unless!((20i8 == num::cast(20u16)));\n+    fail_unless!((20i8 == num::cast(20u32)));\n+    fail_unless!((20i8 == num::cast(20u64)));\n+    fail_unless!((20i8 == num::cast(20i)));\n+    fail_unless!((20i8 == num::cast(20i8)));\n+    fail_unless!((20i8 == num::cast(20i16)));\n+    fail_unless!((20i8 == num::cast(20i32)));\n+    fail_unless!((20i8 == num::cast(20i64)));\n+    fail_unless!((20i8 == num::cast(20f)));\n+    fail_unless!((20i8 == num::cast(20f32)));\n+    fail_unless!((20i8 == num::cast(20f64)));\n }"}, {"sha": "f007cc5b119fb873375c2a1ba3eff608ba70037d", "filename": "src/libcore/num/int-template/int.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template%2Fint.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -40,21 +40,21 @@ mod inst {\n \n     #[test]\n     fn test_pow() {\n-        assert (pow(0, 0u) == 1);\n-        assert (pow(0, 1u) == 0);\n-        assert (pow(0, 2u) == 0);\n-        assert (pow(-1, 0u) == 1);\n-        assert (pow(1, 0u) == 1);\n-        assert (pow(-3, 2u) == 9);\n-        assert (pow(-3, 3u) == -27);\n-        assert (pow(4, 9u) == 262144);\n+        fail_unless!((pow(0, 0u) == 1));\n+        fail_unless!((pow(0, 1u) == 0));\n+        fail_unless!((pow(0, 2u) == 0));\n+        fail_unless!((pow(-1, 0u) == 1));\n+        fail_unless!((pow(1, 0u) == 1));\n+        fail_unless!((pow(-3, 2u) == 9));\n+        fail_unless!((pow(-3, 3u) == -27));\n+        fail_unless!((pow(4, 9u) == 262144));\n     }\n \n     #[test]\n     fn test_overflows() {\n-        assert (::int::max_value > 0);\n-        assert (::int::min_value <= 0);\n-        assert (::int::min_value + ::int::max_value + 1 == 0);\n+        fail_unless!((::int::max_value > 0));\n+        fail_unless!((::int::min_value <= 0));\n+        fail_unless!((::int::min_value + ::int::max_value + 1 == 0));\n     }\n }\n \n@@ -84,45 +84,45 @@ impl NumCast for int {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20i.to_uint());\n-    assert (20u8  == 20i.to_u8());\n-    assert (20u16 == 20i.to_u16());\n-    assert (20u32 == 20i.to_u32());\n-    assert (20u64 == 20i.to_u64());\n-    assert (20i   == 20i.to_int());\n-    assert (20i8  == 20i.to_i8());\n-    assert (20i16 == 20i.to_i16());\n-    assert (20i32 == 20i.to_i32());\n-    assert (20i64 == 20i.to_i64());\n-    assert (20f   == 20i.to_float());\n-    assert (20f32 == 20i.to_f32());\n-    assert (20f64 == 20i.to_f64());\n+    fail_unless!((20u   == 20i.to_uint()));\n+    fail_unless!((20u8  == 20i.to_u8()));\n+    fail_unless!((20u16 == 20i.to_u16()));\n+    fail_unless!((20u32 == 20i.to_u32()));\n+    fail_unless!((20u64 == 20i.to_u64()));\n+    fail_unless!((20i   == 20i.to_int()));\n+    fail_unless!((20i8  == 20i.to_i8()));\n+    fail_unless!((20i16 == 20i.to_i16()));\n+    fail_unless!((20i32 == 20i.to_i32()));\n+    fail_unless!((20i64 == 20i.to_i64()));\n+    fail_unless!((20f   == 20i.to_float()));\n+    fail_unless!((20f32 == 20i.to_f32()));\n+    fail_unless!((20f64 == 20i.to_f64()));\n \n-    assert (20i == NumCast::from(20u));\n-    assert (20i == NumCast::from(20u8));\n-    assert (20i == NumCast::from(20u16));\n-    assert (20i == NumCast::from(20u32));\n-    assert (20i == NumCast::from(20u64));\n-    assert (20i == NumCast::from(20i));\n-    assert (20i == NumCast::from(20i8));\n-    assert (20i == NumCast::from(20i16));\n-    assert (20i == NumCast::from(20i32));\n-    assert (20i == NumCast::from(20i64));\n-    assert (20i == NumCast::from(20f));\n-    assert (20i == NumCast::from(20f32));\n-    assert (20i == NumCast::from(20f64));\n+    fail_unless!((20i == NumCast::from(20u)));\n+    fail_unless!((20i == NumCast::from(20u8)));\n+    fail_unless!((20i == NumCast::from(20u16)));\n+    fail_unless!((20i == NumCast::from(20u32)));\n+    fail_unless!((20i == NumCast::from(20u64)));\n+    fail_unless!((20i == NumCast::from(20i)));\n+    fail_unless!((20i == NumCast::from(20i8)));\n+    fail_unless!((20i == NumCast::from(20i16)));\n+    fail_unless!((20i == NumCast::from(20i32)));\n+    fail_unless!((20i == NumCast::from(20i64)));\n+    fail_unless!((20i == NumCast::from(20f)));\n+    fail_unless!((20i == NumCast::from(20f32)));\n+    fail_unless!((20i == NumCast::from(20f64)));\n \n-    assert (20i == num::cast(20u));\n-    assert (20i == num::cast(20u8));\n-    assert (20i == num::cast(20u16));\n-    assert (20i == num::cast(20u32));\n-    assert (20i == num::cast(20u64));\n-    assert (20i == num::cast(20i));\n-    assert (20i == num::cast(20i8));\n-    assert (20i == num::cast(20i16));\n-    assert (20i == num::cast(20i32));\n-    assert (20i == num::cast(20i64));\n-    assert (20i == num::cast(20f));\n-    assert (20i == num::cast(20f32));\n-    assert (20i == num::cast(20f64));\n+    fail_unless!((20i == num::cast(20u)));\n+    fail_unless!((20i == num::cast(20u8)));\n+    fail_unless!((20i == num::cast(20u16)));\n+    fail_unless!((20i == num::cast(20u32)));\n+    fail_unless!((20i == num::cast(20u64)));\n+    fail_unless!((20i == num::cast(20i)));\n+    fail_unless!((20i == num::cast(20i8)));\n+    fail_unless!((20i == num::cast(20i16)));\n+    fail_unless!((20i == num::cast(20i32)));\n+    fail_unless!((20i == num::cast(20i64)));\n+    fail_unless!((20i == num::cast(20f)));\n+    fail_unless!((20i == num::cast(20f32)));\n+    fail_unless!((20i == num::cast(20f64)));\n }"}, {"sha": "a462aed8be0d19004fb8af8d6b1489417d216815", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -55,7 +55,7 @@ pub enum RoundMode {\n  *\n  * ~~~\n  * let twenty: f32 = num::cast(0x14);\n- * assert twenty == 20f32;\n+ * fail_unless!(twenty == 20f32);\n  * ~~~\n  */\n #[inline(always)]"}, {"sha": "8346a45601ea5ec8c313d40dd3c8b4b54693ae76", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -238,102 +238,102 @@ impl ToStrRadix for T {\n \n #[test]\n pub fn test_to_str() {\n-    assert to_str_radix(0 as T, 10u) == ~\"0\";\n-    assert to_str_radix(1 as T, 10u) == ~\"1\";\n-    assert to_str_radix(2 as T, 10u) == ~\"2\";\n-    assert to_str_radix(11 as T, 10u) == ~\"11\";\n-    assert to_str_radix(11 as T, 16u) == ~\"b\";\n-    assert to_str_radix(255 as T, 16u) == ~\"ff\";\n-    assert to_str_radix(0xff as T, 10u) == ~\"255\";\n+    fail_unless!(to_str_radix(0 as T, 10u) == ~\"0\");\n+    fail_unless!(to_str_radix(1 as T, 10u) == ~\"1\");\n+    fail_unless!(to_str_radix(2 as T, 10u) == ~\"2\");\n+    fail_unless!(to_str_radix(11 as T, 10u) == ~\"11\");\n+    fail_unless!(to_str_radix(11 as T, 16u) == ~\"b\");\n+    fail_unless!(to_str_radix(255 as T, 16u) == ~\"ff\");\n+    fail_unless!(to_str_radix(0xff as T, 10u) == ~\"255\");\n }\n \n #[test]\n pub fn test_from_str() {\n-    assert from_str(~\"0\") == Some(0u as T);\n-    assert from_str(~\"3\") == Some(3u as T);\n-    assert from_str(~\"10\") == Some(10u as T);\n-    assert u32::from_str(~\"123456789\") == Some(123456789 as u32);\n-    assert from_str(~\"00100\") == Some(100u as T);\n+    fail_unless!(from_str(~\"0\") == Some(0u as T));\n+    fail_unless!(from_str(~\"3\") == Some(3u as T));\n+    fail_unless!(from_str(~\"10\") == Some(10u as T));\n+    fail_unless!(u32::from_str(~\"123456789\") == Some(123456789 as u32));\n+    fail_unless!(from_str(~\"00100\") == Some(100u as T));\n \n-    assert from_str(~\"\").is_none();\n-    assert from_str(~\" \").is_none();\n-    assert from_str(~\"x\").is_none();\n+    fail_unless!(from_str(~\"\").is_none());\n+    fail_unless!(from_str(~\" \").is_none());\n+    fail_unless!(from_str(~\"x\").is_none());\n }\n \n #[test]\n pub fn test_parse_bytes() {\n     use str::to_bytes;\n-    assert parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T);\n-    assert parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T);\n-    assert parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T);\n-    assert u16::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291u as u16);\n-    assert u16::parse_bytes(to_bytes(~\"ffff\"), 16u) == Some(65535u as u16);\n-    assert parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T);\n+    fail_unless!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T));\n+    fail_unless!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T));\n+    fail_unless!(u16::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291u as u16));\n+    fail_unless!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u) == Some(65535u as u16));\n+    fail_unless!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T));\n \n-    assert parse_bytes(to_bytes(~\"Z\"), 10u).is_none();\n-    assert parse_bytes(to_bytes(~\"_\"), 2u).is_none();\n+    fail_unless!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n+    fail_unless!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n }\n \n #[test]\n fn test_uint_to_str_overflow() {\n     let mut u8_val: u8 = 255_u8;\n-    assert (u8::to_str(u8_val) == ~\"255\");\n+    fail_unless!((u8::to_str(u8_val) == ~\"255\"));\n \n     u8_val += 1 as u8;\n-    assert (u8::to_str(u8_val) == ~\"0\");\n+    fail_unless!((u8::to_str(u8_val) == ~\"0\"));\n \n     let mut u16_val: u16 = 65_535_u16;\n-    assert (u16::to_str(u16_val) == ~\"65535\");\n+    fail_unless!((u16::to_str(u16_val) == ~\"65535\"));\n \n     u16_val += 1 as u16;\n-    assert (u16::to_str(u16_val) == ~\"0\");\n+    fail_unless!((u16::to_str(u16_val) == ~\"0\"));\n \n     let mut u32_val: u32 = 4_294_967_295_u32;\n-    assert (u32::to_str(u32_val) == ~\"4294967295\");\n+    fail_unless!((u32::to_str(u32_val) == ~\"4294967295\"));\n \n     u32_val += 1 as u32;\n-    assert (u32::to_str(u32_val) == ~\"0\");\n+    fail_unless!((u32::to_str(u32_val) == ~\"0\"));\n \n     let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-    assert (u64::to_str(u64_val) == ~\"18446744073709551615\");\n+    fail_unless!((u64::to_str(u64_val) == ~\"18446744073709551615\"));\n \n     u64_val += 1 as u64;\n-    assert (u64::to_str(u64_val) == ~\"0\");\n+    fail_unless!((u64::to_str(u64_val) == ~\"0\"));\n }\n \n #[test]\n fn test_uint_from_str_overflow() {\n     let mut u8_val: u8 = 255_u8;\n-    assert (u8::from_str(~\"255\") == Some(u8_val));\n-    assert (u8::from_str(~\"256\").is_none());\n+    fail_unless!((u8::from_str(~\"255\") == Some(u8_val)));\n+    fail_unless!((u8::from_str(~\"256\").is_none()));\n \n     u8_val += 1 as u8;\n-    assert (u8::from_str(~\"0\") == Some(u8_val));\n-    assert (u8::from_str(~\"-1\").is_none());\n+    fail_unless!((u8::from_str(~\"0\") == Some(u8_val)));\n+    fail_unless!((u8::from_str(~\"-1\").is_none()));\n \n     let mut u16_val: u16 = 65_535_u16;\n-    assert (u16::from_str(~\"65535\") == Some(u16_val));\n-    assert (u16::from_str(~\"65536\").is_none());\n+    fail_unless!((u16::from_str(~\"65535\") == Some(u16_val)));\n+    fail_unless!((u16::from_str(~\"65536\").is_none()));\n \n     u16_val += 1 as u16;\n-    assert (u16::from_str(~\"0\") == Some(u16_val));\n-    assert (u16::from_str(~\"-1\").is_none());\n+    fail_unless!((u16::from_str(~\"0\") == Some(u16_val)));\n+    fail_unless!((u16::from_str(~\"-1\").is_none()));\n \n     let mut u32_val: u32 = 4_294_967_295_u32;\n-    assert (u32::from_str(~\"4294967295\") == Some(u32_val));\n-    assert (u32::from_str(~\"4294967296\").is_none());\n+    fail_unless!((u32::from_str(~\"4294967295\") == Some(u32_val)));\n+    fail_unless!((u32::from_str(~\"4294967296\").is_none()));\n \n     u32_val += 1 as u32;\n-    assert (u32::from_str(~\"0\") == Some(u32_val));\n-    assert (u32::from_str(~\"-1\").is_none());\n+    fail_unless!((u32::from_str(~\"0\") == Some(u32_val)));\n+    fail_unless!((u32::from_str(~\"-1\").is_none()));\n \n     let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-    assert (u64::from_str(~\"18446744073709551615\") == Some(u64_val));\n-    assert (u64::from_str(~\"18446744073709551616\").is_none());\n+    fail_unless!((u64::from_str(~\"18446744073709551615\") == Some(u64_val)));\n+    fail_unless!((u64::from_str(~\"18446744073709551616\").is_none()));\n \n     u64_val += 1 as u64;\n-    assert (u64::from_str(~\"0\") == Some(u64_val));\n-    assert (u64::from_str(~\"-1\").is_none());\n+    fail_unless!((u64::from_str(~\"0\") == Some(u64_val)));\n+    fail_unless!((u64::from_str(~\"-1\").is_none()));\n }\n \n #[test]\n@@ -367,10 +367,10 @@ pub fn test_ranges() {\n         l.push(i);\n     }\n \n-    assert l == ~[0,1,2,\n-                  13,12,11,\n-                  20,22,24,\n-                  36,34,32];\n+    fail_unless!(l == ~[0,1,2,\n+                        13,12,11,\n+                        20,22,24,\n+                        36,34,32]);\n \n     // None of the `fail`s should execute.\n     for range(0,0) |_i| {\n@@ -392,11 +392,11 @@ pub fn test_num() {\n     let ten: T = num::cast(10);\n     let two: T = num::cast(2);\n \n-    assert (ten.add(&two)    == num::cast(12));\n-    assert (ten.sub(&two)    == num::cast(8));\n-    assert (ten.mul(&two)    == num::cast(20));\n-    assert (ten.div(&two)    == num::cast(5));\n-    assert (ten.modulo(&two) == num::cast(0));\n+    fail_unless!((ten.add(&two)    == num::cast(12)));\n+    fail_unless!((ten.sub(&two)    == num::cast(8)));\n+    fail_unless!((ten.mul(&two)    == num::cast(20)));\n+    fail_unless!((ten.div(&two)    == num::cast(5)));\n+    fail_unless!((ten.modulo(&two) == num::cast(0)));\n }\n \n #[test]"}, {"sha": "16a1d6209295a1407242885308889a4fc909a3e1", "filename": "src/libcore/num/uint-template/u16.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu16.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -45,45 +45,45 @@ impl NumCast for u16 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20u16.to_uint());\n-    assert (20u8  == 20u16.to_u8());\n-    assert (20u16 == 20u16.to_u16());\n-    assert (20u32 == 20u16.to_u32());\n-    assert (20u64 == 20u16.to_u64());\n-    assert (20i   == 20u16.to_int());\n-    assert (20i8  == 20u16.to_i8());\n-    assert (20i16 == 20u16.to_i16());\n-    assert (20i32 == 20u16.to_i32());\n-    assert (20i64 == 20u16.to_i64());\n-    assert (20f   == 20u16.to_float());\n-    assert (20f32 == 20u16.to_f32());\n-    assert (20f64 == 20u16.to_f64());\n+    fail_unless!((20u   == 20u16.to_uint()));\n+    fail_unless!((20u8  == 20u16.to_u8()));\n+    fail_unless!((20u16 == 20u16.to_u16()));\n+    fail_unless!((20u32 == 20u16.to_u32()));\n+    fail_unless!((20u64 == 20u16.to_u64()));\n+    fail_unless!((20i   == 20u16.to_int()));\n+    fail_unless!((20i8  == 20u16.to_i8()));\n+    fail_unless!((20i16 == 20u16.to_i16()));\n+    fail_unless!((20i32 == 20u16.to_i32()));\n+    fail_unless!((20i64 == 20u16.to_i64()));\n+    fail_unless!((20f   == 20u16.to_float()));\n+    fail_unless!((20f32 == 20u16.to_f32()));\n+    fail_unless!((20f64 == 20u16.to_f64()));\n \n-    assert (20u16 == NumCast::from(20u));\n-    assert (20u16 == NumCast::from(20u8));\n-    assert (20u16 == NumCast::from(20u16));\n-    assert (20u16 == NumCast::from(20u32));\n-    assert (20u16 == NumCast::from(20u64));\n-    assert (20u16 == NumCast::from(20i));\n-    assert (20u16 == NumCast::from(20i8));\n-    assert (20u16 == NumCast::from(20i16));\n-    assert (20u16 == NumCast::from(20i32));\n-    assert (20u16 == NumCast::from(20i64));\n-    assert (20u16 == NumCast::from(20f));\n-    assert (20u16 == NumCast::from(20f32));\n-    assert (20u16 == NumCast::from(20f64));\n+    fail_unless!((20u16 == NumCast::from(20u)));\n+    fail_unless!((20u16 == NumCast::from(20u8)));\n+    fail_unless!((20u16 == NumCast::from(20u16)));\n+    fail_unless!((20u16 == NumCast::from(20u32)));\n+    fail_unless!((20u16 == NumCast::from(20u64)));\n+    fail_unless!((20u16 == NumCast::from(20i)));\n+    fail_unless!((20u16 == NumCast::from(20i8)));\n+    fail_unless!((20u16 == NumCast::from(20i16)));\n+    fail_unless!((20u16 == NumCast::from(20i32)));\n+    fail_unless!((20u16 == NumCast::from(20i64)));\n+    fail_unless!((20u16 == NumCast::from(20f)));\n+    fail_unless!((20u16 == NumCast::from(20f32)));\n+    fail_unless!((20u16 == NumCast::from(20f64)));\n \n-    assert (20u16 == num::cast(20u));\n-    assert (20u16 == num::cast(20u8));\n-    assert (20u16 == num::cast(20u16));\n-    assert (20u16 == num::cast(20u32));\n-    assert (20u16 == num::cast(20u64));\n-    assert (20u16 == num::cast(20i));\n-    assert (20u16 == num::cast(20i8));\n-    assert (20u16 == num::cast(20i16));\n-    assert (20u16 == num::cast(20i32));\n-    assert (20u16 == num::cast(20i64));\n-    assert (20u16 == num::cast(20f));\n-    assert (20u16 == num::cast(20f32));\n-    assert (20u16 == num::cast(20f64));\n+    fail_unless!((20u16 == num::cast(20u)));\n+    fail_unless!((20u16 == num::cast(20u8)));\n+    fail_unless!((20u16 == num::cast(20u16)));\n+    fail_unless!((20u16 == num::cast(20u32)));\n+    fail_unless!((20u16 == num::cast(20u64)));\n+    fail_unless!((20u16 == num::cast(20i)));\n+    fail_unless!((20u16 == num::cast(20i8)));\n+    fail_unless!((20u16 == num::cast(20i16)));\n+    fail_unless!((20u16 == num::cast(20i32)));\n+    fail_unless!((20u16 == num::cast(20i64)));\n+    fail_unless!((20u16 == num::cast(20f)));\n+    fail_unless!((20u16 == num::cast(20f32)));\n+    fail_unless!((20u16 == num::cast(20f64)));\n }"}, {"sha": "cf92feb6427f402c2525e96a523314a9499a7ebb", "filename": "src/libcore/num/uint-template/u32.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu32.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -45,45 +45,45 @@ impl NumCast for u32 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20u64.to_uint());\n-    assert (20u8  == 20u64.to_u8());\n-    assert (20u16 == 20u64.to_u16());\n-    assert (20u32 == 20u64.to_u32());\n-    assert (20u64 == 20u64.to_u64());\n-    assert (20i   == 20u64.to_int());\n-    assert (20i8  == 20u64.to_i8());\n-    assert (20i16 == 20u64.to_i16());\n-    assert (20i32 == 20u64.to_i32());\n-    assert (20i64 == 20u64.to_i64());\n-    assert (20f   == 20u64.to_float());\n-    assert (20f32 == 20u64.to_f32());\n-    assert (20f64 == 20u64.to_f64());\n+    fail_unless!((20u   == 20u64.to_uint()));\n+    fail_unless!((20u8  == 20u64.to_u8()));\n+    fail_unless!((20u16 == 20u64.to_u16()));\n+    fail_unless!((20u32 == 20u64.to_u32()));\n+    fail_unless!((20u64 == 20u64.to_u64()));\n+    fail_unless!((20i   == 20u64.to_int()));\n+    fail_unless!((20i8  == 20u64.to_i8()));\n+    fail_unless!((20i16 == 20u64.to_i16()));\n+    fail_unless!((20i32 == 20u64.to_i32()));\n+    fail_unless!((20i64 == 20u64.to_i64()));\n+    fail_unless!((20f   == 20u64.to_float()));\n+    fail_unless!((20f32 == 20u64.to_f32()));\n+    fail_unless!((20f64 == 20u64.to_f64()));\n \n-    assert (20u64 == NumCast::from(20u));\n-    assert (20u64 == NumCast::from(20u8));\n-    assert (20u64 == NumCast::from(20u16));\n-    assert (20u64 == NumCast::from(20u32));\n-    assert (20u64 == NumCast::from(20u64));\n-    assert (20u64 == NumCast::from(20i));\n-    assert (20u64 == NumCast::from(20i8));\n-    assert (20u64 == NumCast::from(20i16));\n-    assert (20u64 == NumCast::from(20i32));\n-    assert (20u64 == NumCast::from(20i64));\n-    assert (20u64 == NumCast::from(20f));\n-    assert (20u64 == NumCast::from(20f32));\n-    assert (20u64 == NumCast::from(20f64));\n+    fail_unless!((20u64 == NumCast::from(20u)));\n+    fail_unless!((20u64 == NumCast::from(20u8)));\n+    fail_unless!((20u64 == NumCast::from(20u16)));\n+    fail_unless!((20u64 == NumCast::from(20u32)));\n+    fail_unless!((20u64 == NumCast::from(20u64)));\n+    fail_unless!((20u64 == NumCast::from(20i)));\n+    fail_unless!((20u64 == NumCast::from(20i8)));\n+    fail_unless!((20u64 == NumCast::from(20i16)));\n+    fail_unless!((20u64 == NumCast::from(20i32)));\n+    fail_unless!((20u64 == NumCast::from(20i64)));\n+    fail_unless!((20u64 == NumCast::from(20f)));\n+    fail_unless!((20u64 == NumCast::from(20f32)));\n+    fail_unless!((20u64 == NumCast::from(20f64)));\n \n-    assert (20u64 == num::cast(20u));\n-    assert (20u64 == num::cast(20u8));\n-    assert (20u64 == num::cast(20u16));\n-    assert (20u64 == num::cast(20u32));\n-    assert (20u64 == num::cast(20u64));\n-    assert (20u64 == num::cast(20i));\n-    assert (20u64 == num::cast(20i8));\n-    assert (20u64 == num::cast(20i16));\n-    assert (20u64 == num::cast(20i32));\n-    assert (20u64 == num::cast(20i64));\n-    assert (20u64 == num::cast(20f));\n-    assert (20u64 == num::cast(20f32));\n-    assert (20u64 == num::cast(20f64));\n+    fail_unless!((20u64 == num::cast(20u)));\n+    fail_unless!((20u64 == num::cast(20u8)));\n+    fail_unless!((20u64 == num::cast(20u16)));\n+    fail_unless!((20u64 == num::cast(20u32)));\n+    fail_unless!((20u64 == num::cast(20u64)));\n+    fail_unless!((20u64 == num::cast(20i)));\n+    fail_unless!((20u64 == num::cast(20i8)));\n+    fail_unless!((20u64 == num::cast(20i16)));\n+    fail_unless!((20u64 == num::cast(20i32)));\n+    fail_unless!((20u64 == num::cast(20i64)));\n+    fail_unless!((20u64 == num::cast(20f)));\n+    fail_unless!((20u64 == num::cast(20f32)));\n+    fail_unless!((20u64 == num::cast(20f64)));\n }"}, {"sha": "269d8e185f37bd4c936bb7e4da452cabc1ff860b", "filename": "src/libcore/num/uint-template/u64.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu64.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -45,45 +45,45 @@ impl NumCast for u64 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20u64.to_uint());\n-    assert (20u8  == 20u64.to_u8());\n-    assert (20u16 == 20u64.to_u16());\n-    assert (20u32 == 20u64.to_u32());\n-    assert (20u64 == 20u64.to_u64());\n-    assert (20i   == 20u64.to_int());\n-    assert (20i8  == 20u64.to_i8());\n-    assert (20i16 == 20u64.to_i16());\n-    assert (20i32 == 20u64.to_i32());\n-    assert (20i64 == 20u64.to_i64());\n-    assert (20f   == 20u64.to_float());\n-    assert (20f32 == 20u64.to_f32());\n-    assert (20f64 == 20u64.to_f64());\n+    fail_unless!((20u   == 20u64.to_uint()));\n+    fail_unless!((20u8  == 20u64.to_u8()));\n+    fail_unless!((20u16 == 20u64.to_u16()));\n+    fail_unless!((20u32 == 20u64.to_u32()));\n+    fail_unless!((20u64 == 20u64.to_u64()));\n+    fail_unless!((20i   == 20u64.to_int()));\n+    fail_unless!((20i8  == 20u64.to_i8()));\n+    fail_unless!((20i16 == 20u64.to_i16()));\n+    fail_unless!((20i32 == 20u64.to_i32()));\n+    fail_unless!((20i64 == 20u64.to_i64()));\n+    fail_unless!((20f   == 20u64.to_float()));\n+    fail_unless!((20f32 == 20u64.to_f32()));\n+    fail_unless!((20f64 == 20u64.to_f64()));\n \n-    assert (20u64 == NumCast::from(20u));\n-    assert (20u64 == NumCast::from(20u8));\n-    assert (20u64 == NumCast::from(20u16));\n-    assert (20u64 == NumCast::from(20u32));\n-    assert (20u64 == NumCast::from(20u64));\n-    assert (20u64 == NumCast::from(20i));\n-    assert (20u64 == NumCast::from(20i8));\n-    assert (20u64 == NumCast::from(20i16));\n-    assert (20u64 == NumCast::from(20i32));\n-    assert (20u64 == NumCast::from(20i64));\n-    assert (20u64 == NumCast::from(20f));\n-    assert (20u64 == NumCast::from(20f32));\n-    assert (20u64 == NumCast::from(20f64));\n+    fail_unless!((20u64 == NumCast::from(20u)));\n+    fail_unless!((20u64 == NumCast::from(20u8)));\n+    fail_unless!((20u64 == NumCast::from(20u16)));\n+    fail_unless!((20u64 == NumCast::from(20u32)));\n+    fail_unless!((20u64 == NumCast::from(20u64)));\n+    fail_unless!((20u64 == NumCast::from(20i)));\n+    fail_unless!((20u64 == NumCast::from(20i8)));\n+    fail_unless!((20u64 == NumCast::from(20i16)));\n+    fail_unless!((20u64 == NumCast::from(20i32)));\n+    fail_unless!((20u64 == NumCast::from(20i64)));\n+    fail_unless!((20u64 == NumCast::from(20f)));\n+    fail_unless!((20u64 == NumCast::from(20f32)));\n+    fail_unless!((20u64 == NumCast::from(20f64)));\n \n-    assert (20u64 == num::cast(20u));\n-    assert (20u64 == num::cast(20u8));\n-    assert (20u64 == num::cast(20u16));\n-    assert (20u64 == num::cast(20u32));\n-    assert (20u64 == num::cast(20u64));\n-    assert (20u64 == num::cast(20i));\n-    assert (20u64 == num::cast(20i8));\n-    assert (20u64 == num::cast(20i16));\n-    assert (20u64 == num::cast(20i32));\n-    assert (20u64 == num::cast(20i64));\n-    assert (20u64 == num::cast(20f));\n-    assert (20u64 == num::cast(20f32));\n-    assert (20u64 == num::cast(20f64));\n+    fail_unless!((20u64 == num::cast(20u)));\n+    fail_unless!((20u64 == num::cast(20u8)));\n+    fail_unless!((20u64 == num::cast(20u16)));\n+    fail_unless!((20u64 == num::cast(20u32)));\n+    fail_unless!((20u64 == num::cast(20u64)));\n+    fail_unless!((20u64 == num::cast(20i)));\n+    fail_unless!((20u64 == num::cast(20i8)));\n+    fail_unless!((20u64 == num::cast(20i16)));\n+    fail_unless!((20u64 == num::cast(20i32)));\n+    fail_unless!((20u64 == num::cast(20i64)));\n+    fail_unless!((20u64 == num::cast(20f)));\n+    fail_unless!((20u64 == num::cast(20f32)));\n+    fail_unless!((20u64 == num::cast(20f64)));\n }"}, {"sha": "44428abdb4ff078a0fd20cee94c605374fa37903", "filename": "src/libcore/num/uint-template/u8.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fu8.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -52,45 +52,45 @@ impl NumCast for u8 {\n \n #[test]\n fn test_numcast() {\n-    assert (20u     == 20u8.to_uint());\n-    assert (20u8    == 20u8.to_u8());\n-    assert (20u16   == 20u8.to_u16());\n-    assert (20u32   == 20u8.to_u32());\n-    assert (20u64   == 20u8.to_u64());\n-    assert (20i     == 20u8.to_int());\n-    assert (20i8    == 20u8.to_i8());\n-    assert (20i16   == 20u8.to_i16());\n-    assert (20i32   == 20u8.to_i32());\n-    assert (20i64   == 20u8.to_i64());\n-    assert (20f     == 20u8.to_float());\n-    assert (20f32   == 20u8.to_f32());\n-    assert (20f64   == 20u8.to_f64());\n+    fail_unless!((20u     == 20u8.to_uint()));\n+    fail_unless!((20u8    == 20u8.to_u8()));\n+    fail_unless!((20u16   == 20u8.to_u16()));\n+    fail_unless!((20u32   == 20u8.to_u32()));\n+    fail_unless!((20u64   == 20u8.to_u64()));\n+    fail_unless!((20i     == 20u8.to_int()));\n+    fail_unless!((20i8    == 20u8.to_i8()));\n+    fail_unless!((20i16   == 20u8.to_i16()));\n+    fail_unless!((20i32   == 20u8.to_i32()));\n+    fail_unless!((20i64   == 20u8.to_i64()));\n+    fail_unless!((20f     == 20u8.to_float()));\n+    fail_unless!((20f32   == 20u8.to_f32()));\n+    fail_unless!((20f64   == 20u8.to_f64()));\n \n-    assert (20u8 == NumCast::from(20u));\n-    assert (20u8 == NumCast::from(20u8));\n-    assert (20u8 == NumCast::from(20u16));\n-    assert (20u8 == NumCast::from(20u32));\n-    assert (20u8 == NumCast::from(20u64));\n-    assert (20u8 == NumCast::from(20i));\n-    assert (20u8 == NumCast::from(20i8));\n-    assert (20u8 == NumCast::from(20i16));\n-    assert (20u8 == NumCast::from(20i32));\n-    assert (20u8 == NumCast::from(20i64));\n-    assert (20u8 == NumCast::from(20f));\n-    assert (20u8 == NumCast::from(20f32));\n-    assert (20u8 == NumCast::from(20f64));\n+    fail_unless!((20u8 == NumCast::from(20u)));\n+    fail_unless!((20u8 == NumCast::from(20u8)));\n+    fail_unless!((20u8 == NumCast::from(20u16)));\n+    fail_unless!((20u8 == NumCast::from(20u32)));\n+    fail_unless!((20u8 == NumCast::from(20u64)));\n+    fail_unless!((20u8 == NumCast::from(20i)));\n+    fail_unless!((20u8 == NumCast::from(20i8)));\n+    fail_unless!((20u8 == NumCast::from(20i16)));\n+    fail_unless!((20u8 == NumCast::from(20i32)));\n+    fail_unless!((20u8 == NumCast::from(20i64)));\n+    fail_unless!((20u8 == NumCast::from(20f)));\n+    fail_unless!((20u8 == NumCast::from(20f32)));\n+    fail_unless!((20u8 == NumCast::from(20f64)));\n \n-    assert (20u8 == num::cast(20u));\n-    assert (20u8 == num::cast(20u8));\n-    assert (20u8 == num::cast(20u16));\n-    assert (20u8 == num::cast(20u32));\n-    assert (20u8 == num::cast(20u64));\n-    assert (20u8 == num::cast(20i));\n-    assert (20u8 == num::cast(20i8));\n-    assert (20u8 == num::cast(20i16));\n-    assert (20u8 == num::cast(20i32));\n-    assert (20u8 == num::cast(20i64));\n-    assert (20u8 == num::cast(20f));\n-    assert (20u8 == num::cast(20f32));\n-    assert (20u8 == num::cast(20f64));\n+    fail_unless!((20u8 == num::cast(20u)));\n+    fail_unless!((20u8 == num::cast(20u8)));\n+    fail_unless!((20u8 == num::cast(20u16)));\n+    fail_unless!((20u8 == num::cast(20u32)));\n+    fail_unless!((20u8 == num::cast(20u64)));\n+    fail_unless!((20u8 == num::cast(20i)));\n+    fail_unless!((20u8 == num::cast(20i8)));\n+    fail_unless!((20u8 == num::cast(20i16)));\n+    fail_unless!((20u8 == num::cast(20i32)));\n+    fail_unless!((20u8 == num::cast(20i64)));\n+    fail_unless!((20u8 == num::cast(20f)));\n+    fail_unless!((20u8 == num::cast(20f32)));\n+    fail_unless!((20u8 == num::cast(20f64)));\n }"}, {"sha": "6814b0e7541990e6bb88220cd4ad0068ed809df4", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -143,61 +143,61 @@ pub mod inst {\n \n     #[test]\n     fn test_next_power_of_two() {\n-        assert (next_power_of_two(0u) == 0u);\n-        assert (next_power_of_two(1u) == 1u);\n-        assert (next_power_of_two(2u) == 2u);\n-        assert (next_power_of_two(3u) == 4u);\n-        assert (next_power_of_two(4u) == 4u);\n-        assert (next_power_of_two(5u) == 8u);\n-        assert (next_power_of_two(6u) == 8u);\n-        assert (next_power_of_two(7u) == 8u);\n-        assert (next_power_of_two(8u) == 8u);\n-        assert (next_power_of_two(9u) == 16u);\n-        assert (next_power_of_two(10u) == 16u);\n-        assert (next_power_of_two(11u) == 16u);\n-        assert (next_power_of_two(12u) == 16u);\n-        assert (next_power_of_two(13u) == 16u);\n-        assert (next_power_of_two(14u) == 16u);\n-        assert (next_power_of_two(15u) == 16u);\n-        assert (next_power_of_two(16u) == 16u);\n-        assert (next_power_of_two(17u) == 32u);\n-        assert (next_power_of_two(18u) == 32u);\n-        assert (next_power_of_two(19u) == 32u);\n-        assert (next_power_of_two(20u) == 32u);\n-        assert (next_power_of_two(21u) == 32u);\n-        assert (next_power_of_two(22u) == 32u);\n-        assert (next_power_of_two(23u) == 32u);\n-        assert (next_power_of_two(24u) == 32u);\n-        assert (next_power_of_two(25u) == 32u);\n-        assert (next_power_of_two(26u) == 32u);\n-        assert (next_power_of_two(27u) == 32u);\n-        assert (next_power_of_two(28u) == 32u);\n-        assert (next_power_of_two(29u) == 32u);\n-        assert (next_power_of_two(30u) == 32u);\n-        assert (next_power_of_two(31u) == 32u);\n-        assert (next_power_of_two(32u) == 32u);\n-        assert (next_power_of_two(33u) == 64u);\n-        assert (next_power_of_two(34u) == 64u);\n-        assert (next_power_of_two(35u) == 64u);\n-        assert (next_power_of_two(36u) == 64u);\n-        assert (next_power_of_two(37u) == 64u);\n-        assert (next_power_of_two(38u) == 64u);\n-        assert (next_power_of_two(39u) == 64u);\n+        fail_unless!((next_power_of_two(0u) == 0u));\n+        fail_unless!((next_power_of_two(1u) == 1u));\n+        fail_unless!((next_power_of_two(2u) == 2u));\n+        fail_unless!((next_power_of_two(3u) == 4u));\n+        fail_unless!((next_power_of_two(4u) == 4u));\n+        fail_unless!((next_power_of_two(5u) == 8u));\n+        fail_unless!((next_power_of_two(6u) == 8u));\n+        fail_unless!((next_power_of_two(7u) == 8u));\n+        fail_unless!((next_power_of_two(8u) == 8u));\n+        fail_unless!((next_power_of_two(9u) == 16u));\n+        fail_unless!((next_power_of_two(10u) == 16u));\n+        fail_unless!((next_power_of_two(11u) == 16u));\n+        fail_unless!((next_power_of_two(12u) == 16u));\n+        fail_unless!((next_power_of_two(13u) == 16u));\n+        fail_unless!((next_power_of_two(14u) == 16u));\n+        fail_unless!((next_power_of_two(15u) == 16u));\n+        fail_unless!((next_power_of_two(16u) == 16u));\n+        fail_unless!((next_power_of_two(17u) == 32u));\n+        fail_unless!((next_power_of_two(18u) == 32u));\n+        fail_unless!((next_power_of_two(19u) == 32u));\n+        fail_unless!((next_power_of_two(20u) == 32u));\n+        fail_unless!((next_power_of_two(21u) == 32u));\n+        fail_unless!((next_power_of_two(22u) == 32u));\n+        fail_unless!((next_power_of_two(23u) == 32u));\n+        fail_unless!((next_power_of_two(24u) == 32u));\n+        fail_unless!((next_power_of_two(25u) == 32u));\n+        fail_unless!((next_power_of_two(26u) == 32u));\n+        fail_unless!((next_power_of_two(27u) == 32u));\n+        fail_unless!((next_power_of_two(28u) == 32u));\n+        fail_unless!((next_power_of_two(29u) == 32u));\n+        fail_unless!((next_power_of_two(30u) == 32u));\n+        fail_unless!((next_power_of_two(31u) == 32u));\n+        fail_unless!((next_power_of_two(32u) == 32u));\n+        fail_unless!((next_power_of_two(33u) == 64u));\n+        fail_unless!((next_power_of_two(34u) == 64u));\n+        fail_unless!((next_power_of_two(35u) == 64u));\n+        fail_unless!((next_power_of_two(36u) == 64u));\n+        fail_unless!((next_power_of_two(37u) == 64u));\n+        fail_unless!((next_power_of_two(38u) == 64u));\n+        fail_unless!((next_power_of_two(39u) == 64u));\n     }\n \n     #[test]\n     fn test_overflows() {\n         use uint;\n-        assert (uint::max_value > 0u);\n-        assert (uint::min_value <= 0u);\n-        assert (uint::min_value + uint::max_value + 1u == 0u);\n+        fail_unless!((uint::max_value > 0u));\n+        fail_unless!((uint::min_value <= 0u));\n+        fail_unless!((uint::min_value + uint::max_value + 1u == 0u));\n     }\n \n     #[test]\n     fn test_div() {\n-        assert(div_floor(3u, 4u) == 0u);\n-        assert(div_ceil(3u, 4u)  == 1u);\n-        assert(div_round(3u, 4u) == 1u);\n+        fail_unless!((div_floor(3u, 4u) == 0u));\n+        fail_unless!((div_ceil(3u, 4u)  == 1u));\n+        fail_unless!((div_round(3u, 4u) == 1u));\n     }\n \n     #[test]\n@@ -206,7 +206,7 @@ pub mod inst {\n         let ten = 10 as uint;\n         let mut accum = 0;\n         for ten.times { accum += 1; }\n-        assert (accum == 10);\n+        fail_unless!((accum == 10));\n     }\n }\n \n@@ -236,45 +236,45 @@ impl NumCast for uint {\n \n #[test]\n fn test_numcast() {\n-    assert (20u   == 20u.to_uint());\n-    assert (20u8  == 20u.to_u8());\n-    assert (20u16 == 20u.to_u16());\n-    assert (20u32 == 20u.to_u32());\n-    assert (20u64 == 20u.to_u64());\n-    assert (20i   == 20u.to_int());\n-    assert (20i8  == 20u.to_i8());\n-    assert (20i16 == 20u.to_i16());\n-    assert (20i32 == 20u.to_i32());\n-    assert (20i64 == 20u.to_i64());\n-    assert (20f   == 20u.to_float());\n-    assert (20f32 == 20u.to_f32());\n-    assert (20f64 == 20u.to_f64());\n+    fail_unless!((20u   == 20u.to_uint()));\n+    fail_unless!((20u8  == 20u.to_u8()));\n+    fail_unless!((20u16 == 20u.to_u16()));\n+    fail_unless!((20u32 == 20u.to_u32()));\n+    fail_unless!((20u64 == 20u.to_u64()));\n+    fail_unless!((20i   == 20u.to_int()));\n+    fail_unless!((20i8  == 20u.to_i8()));\n+    fail_unless!((20i16 == 20u.to_i16()));\n+    fail_unless!((20i32 == 20u.to_i32()));\n+    fail_unless!((20i64 == 20u.to_i64()));\n+    fail_unless!((20f   == 20u.to_float()));\n+    fail_unless!((20f32 == 20u.to_f32()));\n+    fail_unless!((20f64 == 20u.to_f64()));\n \n-    assert (20u == NumCast::from(20u));\n-    assert (20u == NumCast::from(20u8));\n-    assert (20u == NumCast::from(20u16));\n-    assert (20u == NumCast::from(20u32));\n-    assert (20u == NumCast::from(20u64));\n-    assert (20u == NumCast::from(20i));\n-    assert (20u == NumCast::from(20i8));\n-    assert (20u == NumCast::from(20i16));\n-    assert (20u == NumCast::from(20i32));\n-    assert (20u == NumCast::from(20i64));\n-    assert (20u == NumCast::from(20f));\n-    assert (20u == NumCast::from(20f32));\n-    assert (20u == NumCast::from(20f64));\n+    fail_unless!((20u == NumCast::from(20u)));\n+    fail_unless!((20u == NumCast::from(20u8)));\n+    fail_unless!((20u == NumCast::from(20u16)));\n+    fail_unless!((20u == NumCast::from(20u32)));\n+    fail_unless!((20u == NumCast::from(20u64)));\n+    fail_unless!((20u == NumCast::from(20i)));\n+    fail_unless!((20u == NumCast::from(20i8)));\n+    fail_unless!((20u == NumCast::from(20i16)));\n+    fail_unless!((20u == NumCast::from(20i32)));\n+    fail_unless!((20u == NumCast::from(20i64)));\n+    fail_unless!((20u == NumCast::from(20f)));\n+    fail_unless!((20u == NumCast::from(20f32)));\n+    fail_unless!((20u == NumCast::from(20f64)));\n \n-    assert (20u == num::cast(20u));\n-    assert (20u == num::cast(20u8));\n-    assert (20u == num::cast(20u16));\n-    assert (20u == num::cast(20u32));\n-    assert (20u == num::cast(20u64));\n-    assert (20u == num::cast(20i));\n-    assert (20u == num::cast(20i8));\n-    assert (20u == num::cast(20i16));\n-    assert (20u == num::cast(20i32));\n-    assert (20u == num::cast(20i64));\n-    assert (20u == num::cast(20f));\n-    assert (20u == num::cast(20f32));\n-    assert (20u == num::cast(20f64));\n+    fail_unless!((20u == num::cast(20u)));\n+    fail_unless!((20u == num::cast(20u8)));\n+    fail_unless!((20u == num::cast(20u16)));\n+    fail_unless!((20u == num::cast(20u32)));\n+    fail_unless!((20u == num::cast(20u64)));\n+    fail_unless!((20u == num::cast(20i)));\n+    fail_unless!((20u == num::cast(20i8)));\n+    fail_unless!((20u == num::cast(20i16)));\n+    fail_unless!((20u == num::cast(20i32)));\n+    fail_unless!((20u == num::cast(20i64)));\n+    fail_unless!((20u == num::cast(20f)));\n+    fail_unless!((20u == num::cast(20f32)));\n+    fail_unless!((20u == num::cast(20f64)));\n }"}, {"sha": "7b0e4d07b53b819320a8319fd23a56b892dc2a61", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -437,7 +437,7 @@ fn test_unwrap_ptr() {\n     let opt = Some(x);\n     let y = unwrap(opt);\n     let addr_y = ptr::addr_of(&(*y));\n-    assert addr_x == addr_y;\n+    fail_unless!(addr_x == addr_y);\n }\n \n #[test]\n@@ -447,7 +447,7 @@ fn test_unwrap_str() {\n     let opt = Some(x);\n     let y = unwrap(opt);\n     let addr_y = str::as_buf(y, |buf, _len| buf);\n-    assert addr_x == addr_y;\n+    fail_unless!(addr_x == addr_y);\n }\n \n #[test]\n@@ -472,7 +472,7 @@ fn test_unwrap_resource() {\n         let opt = Some(x);\n         let _y = unwrap(opt);\n     }\n-    assert *i == 1;\n+    fail_unless!(*i == 1);\n }\n \n #[test]\n@@ -483,8 +483,8 @@ fn test_option_dance() {\n     for x.each |_x| {\n         y2 = swap_unwrap(&mut y);\n     }\n-    assert y2 == 5;\n-    assert y.is_none();\n+    fail_unless!(y2 == 5);\n+    fail_unless!(y.is_none());\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_option_too_much_dance() {\n@@ -504,15 +504,15 @@ fn test_option_while_some() {\n             None\n         }\n     }\n-    assert i == 11;\n+    fail_unless!(i == 11);\n }\n \n #[test]\n fn test_get_or_zero() {\n     let some_stuff = Some(42);\n-    assert some_stuff.get_or_zero() == 42;\n+    fail_unless!(some_stuff.get_or_zero() == 42);\n     let no_stuff: Option<int> = None;\n-    assert no_stuff.get_or_zero() == 0;\n+    fail_unless!(no_stuff.get_or_zero() == 0);\n }\n \n // Local Variables:"}, {"sha": "97715c41f9204832051ce2689264316e2b1c9bfb", "filename": "src/libcore/os.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -173,7 +173,7 @@ pub fn env() -> ~[(~str,~str)] {\n             let mut pairs = ~[];\n             for vec::each(rust_env_pairs()) |p| {\n                 let vs = str::splitn_char(*p, '=', 1u);\n-                assert vec::len(vs) == 2u;\n+                fail_unless!(vec::len(vs) == 2u);\n                 pairs.push((copy vs[0], copy vs[1]));\n             }\n             pairs\n@@ -313,7 +313,7 @@ pub fn waitpid(pid: pid_t) -> c_int {\n         use libc::funcs::posix01::wait::*;\n         let mut status = 0 as c_int;\n \n-        assert (waitpid(pid, &mut status, 0 as c_int) != (-1 as c_int));\n+        fail_unless!((waitpid(pid, &mut status, 0 as c_int) != (-1 as c_int)));\n         return status;\n     }\n }\n@@ -326,7 +326,7 @@ pub fn pipe() -> Pipe {\n     unsafe {\n         let mut fds = Pipe {in: 0 as c_int,\n                         out: 0 as c_int };\n-        assert (libc::pipe(&mut fds.in) == (0 as c_int));\n+        fail_unless!((libc::pipe(&mut fds.in) == (0 as c_int)));\n         return Pipe {in: fds.in, out: fds.out};\n     }\n }\n@@ -345,9 +345,9 @@ pub fn pipe() -> Pipe {\n                     out: 0 as c_int };\n         let res = libc::pipe(&mut fds.in, 1024 as c_uint,\n                              (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n-        assert (res == 0 as c_int);\n-        assert (fds.in != -1 as c_int && fds.in != 0 as c_int);\n-        assert (fds.out != -1 as c_int && fds.in != 0 as c_int);\n+        fail_unless!((res == 0 as c_int));\n+        fail_unless!((fds.in != -1 as c_int && fds.in != 0 as c_int));\n+        fail_unless!((fds.out != -1 as c_int && fds.in != 0 as c_int));\n         return Pipe {in: fds.in, out: fds.out};\n     }\n }\n@@ -1142,21 +1142,21 @@ mod tests {\n     #[test]\n     pub fn test_args() {\n         let a = real_args();\n-        assert a.len() >= 1;\n+        fail_unless!(a.len() >= 1);\n     }\n \n     fn make_rand_name() -> ~str {\n         let rng: rand::Rng = rand::Rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n-        assert getenv(n).is_none();\n+        fail_unless!(getenv(n).is_none());\n         n\n     }\n \n     #[test]\n     fn test_setenv() {\n         let n = make_rand_name();\n         setenv(n, ~\"VALUE\");\n-        assert getenv(n) == option::Some(~\"VALUE\");\n+        fail_unless!(getenv(n) == option::Some(~\"VALUE\"));\n     }\n \n     #[test]\n@@ -1166,9 +1166,9 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, ~\"1\");\n         setenv(n, ~\"2\");\n-        assert getenv(n) == option::Some(~\"2\");\n+        fail_unless!(getenv(n) == option::Some(~\"2\"));\n         setenv(n, ~\"\");\n-        assert getenv(n) == option::Some(~\"\");\n+        fail_unless!(getenv(n) == option::Some(~\"\"));\n     }\n \n     // Windows GetEnvironmentVariable requires some extra work to make sure\n@@ -1183,33 +1183,33 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, s);\n         log(debug, copy s);\n-        assert getenv(n) == option::Some(s);\n+        fail_unless!(getenv(n) == option::Some(s));\n     }\n \n     #[test]\n     fn test_self_exe_path() {\n         let path = os::self_exe_path();\n-        assert path.is_some();\n+        fail_unless!(path.is_some());\n         let path = path.get();\n         log(debug, copy path);\n \n         // Hard to test this function\n-        assert path.is_absolute;\n+        fail_unless!(path.is_absolute);\n     }\n \n     #[test]\n     #[ignore]\n     fn test_env_getenv() {\n         let e = env();\n-        assert vec::len(e) > 0u;\n+        fail_unless!(vec::len(e) > 0u);\n         for vec::each(e) |p| {\n             let (n, v) = copy *p;\n             log(debug, copy n);\n             let v2 = getenv(n);\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            assert v2.is_none() || v2 == option::Some(v);\n+            fail_unless!(v2.is_none() || v2 == option::Some(v));\n         }\n     }\n \n@@ -1219,15 +1219,15 @@ mod tests {\n \n         let mut e = env();\n         setenv(n, ~\"VALUE\");\n-        assert !vec::contains(e, &(copy n, ~\"VALUE\"));\n+        fail_unless!(!vec::contains(e, &(copy n, ~\"VALUE\")));\n \n         e = env();\n-        assert vec::contains(e, &(n, ~\"VALUE\"));\n+        fail_unless!(vec::contains(e, &(n, ~\"VALUE\")));\n     }\n \n     #[test]\n     fn test() {\n-        assert (!Path(\"test-path\").is_absolute);\n+        fail_unless!((!Path(\"test-path\").is_absolute));\n \n         log(debug, ~\"Current working directory: \" + getcwd().to_str());\n \n@@ -1241,10 +1241,10 @@ mod tests {\n         let oldhome = getenv(~\"HOME\");\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n+        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"\");\n-        assert os::homedir().is_none();\n+        fail_unless!(os::homedir().is_none());\n \n         for oldhome.each |s| { setenv(~\"HOME\", *s) }\n     }\n@@ -1259,19 +1259,19 @@ mod tests {\n         setenv(~\"HOME\", ~\"\");\n         setenv(~\"USERPROFILE\", ~\"\");\n \n-        assert os::homedir().is_none();\n+        fail_unless!(os::homedir().is_none());\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n-        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n+        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"\");\n \n         setenv(~\"USERPROFILE\", ~\"/home/MountainView\");\n-        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n+        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         setenv(~\"HOME\", ~\"/home/MountainView\");\n         setenv(~\"USERPROFILE\", ~\"/home/PaloAlto\");\n-        assert os::homedir() == Some(Path(\"/home/MountainView\"));\n+        fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n         option::iter(&oldhome, |s| setenv(~\"HOME\", *s));\n         option::iter(&olduserprofile,\n@@ -1280,7 +1280,7 @@ mod tests {\n \n     #[test]\n     fn tmpdir() {\n-        assert !str::is_empty(os::tmpdir().to_str());\n+        fail_unless!(!str::is_empty(os::tmpdir().to_str()));\n     }\n \n     // Issue #712\n@@ -1293,7 +1293,7 @@ mod tests {\n     fn list_dir() {\n         let dirs = os::list_dir(&Path(\".\"));\n         // Just assuming that we've got some contents in the current directory\n-        assert (vec::len(dirs) > 0u);\n+        fail_unless!((vec::len(dirs) > 0u));\n \n         for vec::each(dirs) |dir| {\n             log(debug, copy *dir);\n@@ -1302,29 +1302,29 @@ mod tests {\n \n     #[test]\n     fn path_is_dir() {\n-        assert (os::path_is_dir(&Path(\".\")));\n-        assert (!os::path_is_dir(&Path(\"test/stdtest/fs.rs\")));\n+        fail_unless!((os::path_is_dir(&Path(\".\"))));\n+        fail_unless!((!os::path_is_dir(&Path(\"test/stdtest/fs.rs\"))));\n     }\n \n     #[test]\n     fn path_exists() {\n-        assert (os::path_exists(&Path(\".\")));\n-        assert (!os::path_exists(&Path(\"test/nonexistent-bogus-path\")));\n+        fail_unless!((os::path_exists(&Path(\".\"))));\n+        fail_unless!((!os::path_exists(&Path(\"test/nonexistent-bogus-path\"))));\n     }\n \n     #[test]\n     fn copy_file_does_not_exist() {\n-      assert !os::copy_file(&Path(\"test/nonexistent-bogus-path\"),\n-                            &Path(\"test/other-bogus-path\"));\n-      assert !os::path_exists(&Path(\"test/other-bogus-path\"));\n+      fail_unless!(!os::copy_file(&Path(\"test/nonexistent-bogus-path\"),\n+                            &Path(\"test/other-bogus-path\")));\n+      fail_unless!(!os::path_exists(&Path(\"test/other-bogus-path\")));\n     }\n \n     #[test]\n     fn copy_file_ok() {\n         unsafe {\n           let tempdir = getcwd(); // would like to use $TMPDIR,\n                                   // doesn't seem to work on Linux\n-          assert (str::len(tempdir.to_str()) > 0u);\n+          fail_unless!((str::len(tempdir.to_str()) > 0u));\n           let in = tempdir.push(\"in.txt\");\n           let out = tempdir.push(\"out.txt\");\n \n@@ -1334,23 +1334,24 @@ mod tests {\n                     libc::fopen(fromp, modebuf)\n                 }\n           };\n-          assert (ostream as uint != 0u);\n+          fail_unless!((ostream as uint != 0u));\n           let s = ~\"hello\";\n           let mut buf = str::to_bytes(s) + ~[0 as u8];\n           do vec::as_mut_buf(buf) |b, _len| {\n-              assert (libc::fwrite(b as *c_void, 1u as size_t,\n+              fail_unless!((libc::fwrite(b as *c_void, 1u as size_t,\n                                    (str::len(s) + 1u) as size_t, ostream)\n-                      == buf.len() as size_t)};\n-          assert (libc::fclose(ostream) == (0u as c_int));\n+                      == buf.len() as size_t))\n+          }\n+          fail_unless!((libc::fclose(ostream) == (0u as c_int)));\n           let rs = os::copy_file(&in, &out);\n           if (!os::path_exists(&in)) {\n             fail!(fmt!(\"%s doesn't exist\", in.to_str()));\n           }\n-          assert(rs);\n+          fail_unless!((rs));\n           let rslt = run::run_program(~\"diff\", ~[in.to_str(), out.to_str()]);\n-          assert (rslt == 0);\n-          assert (remove_file(&in));\n-          assert (remove_file(&out));\n+          fail_unless!((rslt == 0));\n+          fail_unless!((remove_file(&in)));\n+          fail_unless!((remove_file(&out)));\n         }\n     }\n }"}, {"sha": "c688607400719aaed88ca2a7f45910c190e8a546", "filename": "src/libcore/path.rs", "status": "modified", "additions": 50, "deletions": 44, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -439,7 +439,7 @@ impl GenericPath for PosixPath {\n \n     pure fn with_filename(&self, f: &str) -> PosixPath {\n         unsafe {\n-            assert ! str::any(f, |c| windows::is_sep(c as u8));\n+            fail_unless!(! str::any(f, |c| windows::is_sep(c as u8)));\n             self.dir_path().push(f)\n         }\n     }\n@@ -484,7 +484,7 @@ impl GenericPath for PosixPath {\n     }\n \n     pure fn push_rel(&self, other: &PosixPath) -> PosixPath {\n-        assert !other.is_absolute;\n+        fail_unless!(!other.is_absolute);\n         self.push_many(other.components)\n     }\n \n@@ -650,7 +650,7 @@ impl GenericPath for WindowsPath {\n     }\n \n     pure fn with_filename(&self, f: &str) -> WindowsPath {\n-        assert ! str::any(f, |c| windows::is_sep(c as u8));\n+        fail_unless!(! str::any(f, |c| windows::is_sep(c as u8)));\n         self.dir_path().push(f)\n     }\n \n@@ -697,7 +697,7 @@ impl GenericPath for WindowsPath {\n     }\n \n     pure fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n-        assert !other.is_absolute;\n+        fail_unless!(!other.is_absolute);\n         self.push_many(other.components)\n     }\n \n@@ -880,30 +880,30 @@ mod tests {\n         let path = PosixPath(\"tmp/\");\n         let path = path.push(\"/hmm\");\n         let path = path.normalize();\n-        assert ~\"tmp/hmm\" == path.to_str();\n+        fail_unless!(~\"tmp/hmm\" == path.to_str());\n \n         let path = WindowsPath(\"tmp/\");\n         let path = path.push(\"/hmm\");\n         let path = path.normalize();\n-        assert ~\"tmp\\\\hmm\" == path.to_str();\n+        fail_unless!(~\"tmp\\\\hmm\" == path.to_str());\n     }\n \n     #[test]\n     fn test_filetype_foo_bar() {\n         let wp = PosixPath(\"foo.bar\");\n-        assert wp.filetype() == Some(~\".bar\");\n+        fail_unless!(wp.filetype() == Some(~\".bar\"));\n \n         let wp = WindowsPath(\"foo.bar\");\n-        assert wp.filetype() == Some(~\".bar\");\n+        fail_unless!(wp.filetype() == Some(~\".bar\"));\n     }\n \n     #[test]\n     fn test_filetype_foo() {\n         let wp = PosixPath(\"foo\");\n-        assert wp.filetype() == None;\n+        fail_unless!(wp.filetype() == None);\n \n         let wp = WindowsPath(\"foo\");\n-        assert wp.filetype() == None;\n+        fail_unless!(wp.filetype() == None);\n     }\n \n     #[test]\n@@ -914,7 +914,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                assert ss == sss;\n+                fail_unless!(ss == sss);\n             }\n         }\n \n@@ -972,7 +972,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                assert ss == sss;\n+                fail_unless!(ss == sss);\n             }\n         }\n \n@@ -988,37 +988,43 @@ mod tests {\n \n     #[test]\n     fn test_extract_unc_prefixes() {\n-        assert windows::extract_unc_prefix(\"\\\\\\\\\").is_none();\n-        assert windows::extract_unc_prefix(\"//\").is_none();\n-        assert windows::extract_unc_prefix(\"\\\\\\\\hi\").is_none();\n-        assert windows::extract_unc_prefix(\"//hi\").is_none();\n-        assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\\") ==\n-            Some((~\"hi\", ~\"\\\\\"));\n-        assert windows::extract_unc_prefix(\"//hi\\\\\") ==\n-            Some((~\"hi\", ~\"\\\\\"));\n-        assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n-            Some((~\"hi\", ~\"\\\\there\"));\n-        assert windows::extract_unc_prefix(\"//hi/there\") ==\n-            Some((~\"hi\", ~\"/there\"));\n-        assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n-            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n-        assert windows::extract_unc_prefix(\"//hi\\\\there\\\\friends.txt\") ==\n-            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n+        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\\").is_none());\n+        fail_unless!(windows::extract_unc_prefix(\"//\").is_none());\n+        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\hi\").is_none());\n+        fail_unless!(windows::extract_unc_prefix(\"//hi\").is_none());\n+        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\hi\\\\\") ==\n+            Some((~\"hi\", ~\"\\\\\")));\n+        fail_unless!(windows::extract_unc_prefix(\"//hi\\\\\") ==\n+            Some((~\"hi\", ~\"\\\\\")));\n+        fail_unless!(windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n+            Some((~\"hi\", ~\"\\\\there\")));\n+        fail_unless!(windows::extract_unc_prefix(\"//hi/there\") ==\n+            Some((~\"hi\", ~\"/there\")));\n+        fail_unless!(windows::extract_unc_prefix(\n+            \"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n+            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\")));\n+        fail_unless!(windows::extract_unc_prefix(\n+            \"//hi\\\\there\\\\friends.txt\") ==\n+            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\")));\n     }\n \n     #[test]\n     fn test_extract_drive_prefixes() {\n-        assert windows::extract_drive_prefix(\"c\").is_none();\n-        assert windows::extract_drive_prefix(\"c:\") == Some((~\"c\", ~\"\"));\n-        assert windows::extract_drive_prefix(\"d:\") == Some((~\"d\", ~\"\"));\n-        assert windows::extract_drive_prefix(\"z:\") == Some((~\"z\", ~\"\"));\n-        assert windows::extract_drive_prefix(\"c:\\\\hi\") ==\n-            Some((~\"c\", ~\"\\\\hi\"));\n-        assert windows::extract_drive_prefix(\"d:hi\") == Some((~\"d\", ~\"hi\"));\n-        assert windows::extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n-            Some((~\"c\", ~\"hi\\\\there.txt\"));\n-        assert windows::extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n-            Some((~\"c\", ~\"\\\\hi\\\\there.txt\"));\n+        fail_unless!(windows::extract_drive_prefix(\"c\").is_none());\n+        fail_unless!(windows::extract_drive_prefix(\"c:\") ==\n+                     Some((~\"c\", ~\"\")));\n+        fail_unless!(windows::extract_drive_prefix(\"d:\") ==\n+                     Some((~\"d\", ~\"\")));\n+        fail_unless!(windows::extract_drive_prefix(\"z:\") ==\n+                     Some((~\"z\", ~\"\")));\n+        fail_unless!(windows::extract_drive_prefix(\"c:\\\\hi\") ==\n+                     Some((~\"c\", ~\"\\\\hi\")));\n+        fail_unless!(windows::extract_drive_prefix(\"d:hi\") ==\n+                     Some((~\"d\", ~\"hi\")));\n+        fail_unless!(windows::extract_drive_prefix(\"c:hi\\\\there.txt\") ==\n+                     Some((~\"c\", ~\"hi\\\\there.txt\")));\n+        fail_unless!(windows::extract_drive_prefix(\"c:\\\\hi\\\\there.txt\") ==\n+                     Some((~\"c\", ~\"\\\\hi\\\\there.txt\")));\n     }\n \n     #[test]\n@@ -1029,7 +1035,7 @@ mod tests {\n             if (ss != sss) {\n                 debug!(\"got %s\", ss);\n                 debug!(\"expected %s\", sss);\n-                assert ss == sss;\n+                fail_unless!(ss == sss);\n             }\n         }\n \n@@ -1114,9 +1120,9 @@ mod tests {\n \n     #[test]\n     fn test_windows_path_restrictions() {\n-        assert WindowsPath(\"hi\").is_restricted() == false;\n-        assert WindowsPath(\"C:\\\\NUL\").is_restricted() == true;\n-        assert WindowsPath(\"C:\\\\COM1.TXT\").is_restricted() == true;\n-        assert WindowsPath(\"c:\\\\prn.exe\").is_restricted() == true;\n+        fail_unless!(WindowsPath(\"hi\").is_restricted() == false);\n+        fail_unless!(WindowsPath(\"C:\\\\NUL\").is_restricted() == true);\n+        fail_unless!(WindowsPath(\"C:\\\\COM1.TXT\").is_restricted() == true);\n+        fail_unless!(WindowsPath(\"c:\\\\prn.exe\").is_restricted() == true);\n     }\n }"}, {"sha": "afb7aef25a3a08bd641b54f2ff89b170c41099fb", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -161,7 +161,7 @@ pub impl PacketHeader {\n     unsafe fn mark_blocked(&self, this: *rust_task) -> State {\n         rustrt::rust_task_ref(this);\n         let old_task = swap_task(&mut self.blocked_task, this);\n-        assert old_task.is_null();\n+        fail_unless!(old_task.is_null());\n         swap_state_acq(&mut self.state, Blocked)\n     }\n \n@@ -183,7 +183,7 @@ pub impl PacketHeader {\n     // continuum. It ends making multiple unique pointers to the same\n     // thing. You'll proobably want to forget them when you're done.\n     unsafe fn buf_header(&self) -> ~BufferHeader {\n-        assert self.buffer.is_not_null();\n+        fail_unless!(self.buffer.is_not_null());\n         reinterpret_cast(&self.buffer)\n     }\n \n@@ -386,8 +386,8 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n-    assert ptr::addr_of(&(p.header)) == header;\n-    assert p.payload.is_none();\n+    fail_unless!(ptr::addr_of(&(p.header)) == header);\n+    fail_unless!(p.payload.is_none());\n     p.payload = Some(payload);\n     let old_state = swap_state_rel(&mut p.header.state, Full);\n     match old_state {\n@@ -488,7 +488,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     debug!(\"blocked = %x this = %x old_task = %x\",\n            p.header.blocked_task as uint,\n            this as uint, old_task as uint);\n-    assert old_task.is_null();\n+    fail_unless!(old_task.is_null());\n     let mut first = true;\n     let mut count = SPIN_COUNT;\n     loop {\n@@ -533,7 +533,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n           Terminated => {\n             // This assert detects when we've accidentally unsafely\n             // casted too big of a number to a state.\n-            assert old_state == Terminated;\n+            fail_unless!(old_state == Terminated);\n \n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n@@ -582,7 +582,7 @@ fn sender_terminate<T:Owned>(p: *Packet<T>) {\n         fail!(~\"you dun goofed\")\n       }\n       Terminated => {\n-        assert p.header.blocked_task.is_null();\n+        fail_unless!(p.header.blocked_task.is_null());\n         // I have to clean up, use drop_glue\n       }\n     }\n@@ -593,20 +593,20 @@ fn receiver_terminate<T:Owned>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n-        assert p.header.blocked_task.is_null();\n+        fail_unless!(p.header.blocked_task.is_null());\n         // the sender will clean up\n       }\n       Blocked => {\n         let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n         if !old_task.is_null() {\n             unsafe {\n                 rustrt::rust_task_deref(old_task);\n-                assert old_task == rustrt::rust_get_task();\n+                fail_unless!(old_task == rustrt::rust_get_task());\n             }\n         }\n       }\n       Terminated | Full => {\n-        assert p.header.blocked_task.is_null();\n+        fail_unless!(p.header.blocked_task.is_null());\n         // I have to clean up, use drop_glue\n       }\n     }\n@@ -669,8 +669,8 @@ pub fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n     debug!(\"%?, %?\", ready_packet, pkts[ready_packet]);\n \n     unsafe {\n-        assert (*pkts[ready_packet].header()).state == Full\n-            || (*pkts[ready_packet].header()).state == Terminated;\n+        fail_unless!((*pkts[ready_packet].header()).state == Full\n+                     || (*pkts[ready_packet].header()).state == Terminated);\n     }\n \n     ready_packet\n@@ -999,6 +999,6 @@ pub mod test {\n             let _chan = chan;\n         }\n \n-        assert !port.peek();\n+        fail_unless!(!port.peek());\n     }\n }"}, {"sha": "49dd3443443d5e6f628f50bd7656acbb453e2364", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -310,28 +310,28 @@ pub fn test() {\n         let mut p = Pair {fst: 10, snd: 20};\n         let pptr: *mut Pair = &mut p;\n         let iptr: *mut int = cast::reinterpret_cast(&pptr);\n-        assert (*iptr == 10);;\n+        fail_unless!((*iptr == 10));;\n         *iptr = 30;\n-        assert (*iptr == 30);\n-        assert (p.fst == 30);;\n+        fail_unless!((*iptr == 30));\n+        fail_unless!((p.fst == 30));;\n \n         *pptr = Pair {fst: 50, snd: 60};\n-        assert (*iptr == 50);\n-        assert (p.fst == 50);\n-        assert (p.snd == 60);\n+        fail_unless!((*iptr == 50));\n+        fail_unless!((p.fst == 50));\n+        fail_unless!((p.snd == 60));\n \n         let mut v0 = ~[32000u16, 32001u16, 32002u16];\n         let mut v1 = ~[0u16, 0u16, 0u16];\n \n         copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n                     offset(vec::raw::to_ptr(v0), 1u), 1u);\n-        assert (v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n+        fail_unless!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n         copy_memory(vec::raw::to_mut_ptr(v1),\n                     offset(vec::raw::to_ptr(v0), 2u), 1u);\n-        assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16);\n+        fail_unless!((v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n         copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n                     vec::raw::to_ptr(v0), 1u);\n-        assert (v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16);\n+        fail_unless!((v1[0] == 32002u16 && v1[1] == 32001u16 && v1[2] == 32000u16));\n     }\n }\n \n@@ -342,9 +342,9 @@ pub fn test_position() {\n \n     let s = ~\"hello\";\n     unsafe {\n-        assert 2u == as_c_str(s, |p| position(p, |c| *c == 'l' as c_char));\n-        assert 4u == as_c_str(s, |p| position(p, |c| *c == 'o' as c_char));\n-        assert 5u == as_c_str(s, |p| position(p, |c| *c == 0 as c_char));\n+        fail_unless!(2u == as_c_str(s, |p| position(p, |c| *c == 'l' as c_char)));\n+        fail_unless!(4u == as_c_str(s, |p| position(p, |c| *c == 'o' as c_char)));\n+        fail_unless!(5u == as_c_str(s, |p| position(p, |c| *c == 0 as c_char)));\n     }\n }\n \n@@ -358,8 +358,8 @@ pub fn test_buf_len() {\n             do str::as_c_str(s2) |p2| {\n                 let v = ~[p0, p1, p2, null()];\n                 do vec::as_imm_buf(v) |vp, len| {\n-                    assert unsafe { buf_len(vp) } == 3u;\n-                    assert len == 4u;\n+                    fail_unless!(unsafe { buf_len(vp) } == 3u);\n+                    fail_unless!(len == 4u);\n                 }\n             }\n         }\n@@ -369,18 +369,18 @@ pub fn test_buf_len() {\n #[test]\n pub fn test_is_null() {\n    let p: *int = null();\n-   assert p.is_null();\n-   assert !p.is_not_null();\n+   fail_unless!(p.is_null());\n+   fail_unless!(!p.is_not_null());\n \n    let q = offset(p, 1u);\n-   assert !q.is_null();\n-   assert q.is_not_null();\n+   fail_unless!(!q.is_null());\n+   fail_unless!(q.is_not_null());\n \n    let mp: *mut int = mut_null();\n-   assert mp.is_null();\n-   assert !mp.is_not_null();\n+   fail_unless!(mp.is_null());\n+   fail_unless!(!mp.is_not_null());\n \n    let mq = mp.offset(1u);\n-   assert !mq.is_null();\n-   assert mq.is_not_null();\n+   fail_unless!(!mq.is_null());\n+   fail_unless!(mq.is_not_null());\n }"}, {"sha": "cf90edf86f4216f6d9bd1d12d6f7b9e4cfa925da", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -162,7 +162,7 @@ pub impl Rng {\n      * failing if start >= end\n      */\n     fn gen_int_range(&self, start: int, end: int) -> int {\n-        assert start < end;\n+        fail_unless!(start < end);\n         start + int::abs(self.gen_int() % (end - start))\n     }\n \n@@ -196,7 +196,7 @@ pub impl Rng {\n      * failing if start >= end\n      */\n     fn gen_uint_range(&self, start: uint, end: uint) -> uint {\n-        assert start < end;\n+        fail_unless!(start < end);\n         start + (self.gen_uint() % (end - start))\n     }\n \n@@ -248,7 +248,7 @@ pub impl Rng {\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n     fn gen_char_from(&self, chars: &str) -> char {\n-        assert !chars.is_empty();\n+        fail_unless!(!chars.is_empty());\n         self.choose(str::chars(chars))\n     }\n \n@@ -503,7 +503,7 @@ pub mod tests {\n         let seed = rand::seed();\n         let ra = rand::seeded_rng(seed);\n         let rb = rand::seeded_rng(seed);\n-        assert ra.gen_str(100u) == rb.gen_str(100u);\n+        fail_unless!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n@@ -512,7 +512,7 @@ pub mod tests {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n         let ra = rand::seeded_rng(seed);\n         let rb = rand::seeded_rng(seed);\n-        assert ra.gen_str(100u) == rb.gen_str(100u);\n+        fail_unless!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n@@ -522,17 +522,17 @@ pub mod tests {\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n         error!(\"%?\", r);\n-        assert r == 890007737u32 // on x86_64\n-            || r == 2935188040u32; // on x86\n+        fail_unless!(r == 890007737u32 // on x86_64\n+                     || r == 2935188040u32); // on x86\n     }\n \n     #[test]\n     pub fn gen_int_range() {\n         let r = rand::Rng();\n         let a = r.gen_int_range(-3, 42);\n-        assert a >= -3 && a < 42;\n-        assert r.gen_int_range(0, 1) == 0;\n-        assert r.gen_int_range(-12, -11) == -12;\n+        fail_unless!(a >= -3 && a < 42);\n+        fail_unless!(r.gen_int_range(0, 1) == 0);\n+        fail_unless!(r.gen_int_range(-12, -11) == -12);\n     }\n \n     #[test]\n@@ -546,9 +546,9 @@ pub mod tests {\n     pub fn gen_uint_range() {\n         let r = rand::Rng();\n         let a = r.gen_uint_range(3u, 42u);\n-        assert a >= 3u && a < 42u;\n-        assert r.gen_uint_range(0u, 1u) == 0u;\n-        assert r.gen_uint_range(12u, 13u) == 12u;\n+        fail_unless!(a >= 3u && a < 42u);\n+        fail_unless!(r.gen_uint_range(0u, 1u) == 0u);\n+        fail_unless!(r.gen_uint_range(12u, 13u) == 12u);\n     }\n \n     #[test]\n@@ -569,8 +569,8 @@ pub mod tests {\n     #[test]\n     pub fn gen_weighted_bool() {\n         let r = rand::Rng();\n-        assert r.gen_weighted_bool(0u) == true;\n-        assert r.gen_weighted_bool(1u) == true;\n+        fail_unless!(r.gen_weighted_bool(0u) == true);\n+        fail_unless!(r.gen_weighted_bool(1u) == true);\n     }\n \n     #[test]\n@@ -579,85 +579,85 @@ pub mod tests {\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n-        assert r.gen_str(0u).len() == 0u;\n-        assert r.gen_str(10u).len() == 10u;\n-        assert r.gen_str(16u).len() == 16u;\n+        fail_unless!(r.gen_str(0u).len() == 0u);\n+        fail_unless!(r.gen_str(10u).len() == 10u);\n+        fail_unless!(r.gen_str(16u).len() == 16u);\n     }\n \n     #[test]\n     pub fn gen_bytes() {\n         let r = rand::Rng();\n-        assert r.gen_bytes(0u).len() == 0u;\n-        assert r.gen_bytes(10u).len() == 10u;\n-        assert r.gen_bytes(16u).len() == 16u;\n+        fail_unless!(r.gen_bytes(0u).len() == 0u);\n+        fail_unless!(r.gen_bytes(10u).len() == 10u);\n+        fail_unless!(r.gen_bytes(16u).len() == 16u);\n     }\n \n     #[test]\n     pub fn choose() {\n         let r = rand::Rng();\n-        assert r.choose([1, 1, 1]) == 1;\n+        fail_unless!(r.choose([1, 1, 1]) == 1);\n     }\n \n     #[test]\n     pub fn choose_option() {\n         let r = rand::Rng();\n         let x: Option<int> = r.choose_option([]);\n-        assert x.is_none();\n-        assert r.choose_option([1, 1, 1]) == Some(1);\n+        fail_unless!(x.is_none());\n+        fail_unless!(r.choose_option([1, 1, 1]) == Some(1));\n     }\n \n     #[test]\n     pub fn choose_weighted() {\n         let r = rand::Rng();\n-        assert r.choose_weighted(~[\n+        fail_unless!(r.choose_weighted(~[\n             rand::Weighted { weight: 1u, item: 42 },\n-        ]) == 42;\n-        assert r.choose_weighted(~[\n+        ]) == 42);\n+        fail_unless!(r.choose_weighted(~[\n             rand::Weighted { weight: 0u, item: 42 },\n             rand::Weighted { weight: 1u, item: 43 },\n-        ]) == 43;\n+        ]) == 43);\n     }\n \n     #[test]\n     pub fn choose_weighted_option() {\n         let r = rand::Rng();\n-        assert r.choose_weighted_option(~[\n+        fail_unless!(r.choose_weighted_option(~[\n             rand::Weighted { weight: 1u, item: 42 },\n-        ]) == Some(42);\n-        assert r.choose_weighted_option(~[\n+        ]) == Some(42));\n+        fail_unless!(r.choose_weighted_option(~[\n             rand::Weighted { weight: 0u, item: 42 },\n             rand::Weighted { weight: 1u, item: 43 },\n-        ]) == Some(43);\n+        ]) == Some(43));\n         let v: Option<int> = r.choose_weighted_option([]);\n-        assert v.is_none();\n+        fail_unless!(v.is_none());\n     }\n \n     #[test]\n     pub fn weighted_vec() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n-        assert r.weighted_vec(~[]) == empty;\n-        assert r.weighted_vec(~[\n+        fail_unless!(r.weighted_vec(~[]) == empty);\n+        fail_unless!(r.weighted_vec(~[\n             rand::Weighted { weight: 0u, item: 3u },\n             rand::Weighted { weight: 1u, item: 2u },\n             rand::Weighted { weight: 2u, item: 1u },\n-        ]) == ~[2u, 1u, 1u];\n+        ]) == ~[2u, 1u, 1u]);\n     }\n \n     #[test]\n     pub fn shuffle() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n-        assert r.shuffle(~[]) == empty;\n-        assert r.shuffle(~[1, 1, 1]) == ~[1, 1, 1];\n+        fail_unless!(r.shuffle(~[]) == empty);\n+        fail_unless!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n     }\n \n     #[test]\n     pub fn task_rng() {\n         let r = rand::task_rng();\n         r.gen_int();\n-        assert r.shuffle(~[1, 1, 1]) == ~[1, 1, 1];\n-        assert r.gen_uint_range(0u, 1u) == 0u;\n+        fail_unless!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n+        fail_unless!(r.gen_uint_range(0u, 1u) == 0u);\n     }\n \n     #[test]"}, {"sha": "eaae9d03e8ea86df9047013ec83289635ead100e", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -231,7 +231,7 @@ pub impl ReprVisitor {\n         } else if mtbl == 1 {\n             // skip, this is ast::m_imm\n         } else {\n-            assert mtbl == 2;\n+            fail_unless!(mtbl == 2);\n             self.writer.write_str(\"const \");\n         }\n     }\n@@ -590,7 +590,7 @@ fn test_repr() {\n             error!(\"expected '%s', got '%s'\",\n                    e, s);\n         }\n-        assert s == e;\n+        fail_unless!(s == e);\n     }\n \n "}, {"sha": "dd9b55e6725804152876c107f7c6dbdd2c752950", "filename": "src/libcore/result.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -294,7 +294,7 @@ pub impl<T, E: Copy> Result<T, E> {\n  *         else { return ok(x+1u); }\n  *     }\n  *     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n- *         assert incd == ~[2u, 3u, 4u];\n+ *         fail_unless!(incd == ~[2u, 3u, 4u]);\n  *     }\n  */\n #[inline(always)]\n@@ -337,7 +337,7 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n                 op: fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n-    assert vec::same_length(ss, ts);\n+    fail_unless!(vec::same_length(ss, ts));\n     let n = vec::len(ts);\n     let mut vs = vec::with_capacity(n);\n     let mut i = 0u;\n@@ -360,7 +360,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n                          op: fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n \n-    assert vec::same_length(ss, ts);\n+    fail_unless!(vec::same_length(ss, ts));\n     let n = vec::len(ts);\n     let mut i = 0u;\n     while i < n {\n@@ -407,50 +407,50 @@ mod tests {\n \n     #[test]\n     pub fn chain_success() {\n-        assert get(&chain(op1(), op2)) == 667u;\n+        fail_unless!(get(&chain(op1(), op2)) == 667u);\n     }\n \n     #[test]\n     pub fn chain_failure() {\n-        assert get_err(&chain(op3(), op2)) == ~\"sadface\";\n+        fail_unless!(get_err(&chain(op3(), op2)) == ~\"sadface\");\n     }\n \n     #[test]\n     pub fn test_impl_iter() {\n         let mut valid = false;\n         Ok::<~str, ~str>(~\"a\").iter(|_x| valid = true);\n-        assert valid;\n+        fail_unless!(valid);\n \n         Err::<~str, ~str>(~\"b\").iter(|_x| valid = false);\n-        assert valid;\n+        fail_unless!(valid);\n     }\n \n     #[test]\n     pub fn test_impl_iter_err() {\n         let mut valid = true;\n         Ok::<~str, ~str>(~\"a\").iter_err(|_x| valid = false);\n-        assert valid;\n+        fail_unless!(valid);\n \n         valid = false;\n         Err::<~str, ~str>(~\"b\").iter_err(|_x| valid = true);\n-        assert valid;\n+        fail_unless!(valid);\n     }\n \n     #[test]\n     pub fn test_impl_map() {\n-        assert Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Ok(~\"b\");\n-        assert Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Err(~\"a\");\n+        fail_unless!(Ok::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Ok(~\"b\"));\n+        fail_unless!(Err::<~str, ~str>(~\"a\").map(|_x| ~\"b\") == Err(~\"a\"));\n     }\n \n     #[test]\n     pub fn test_impl_map_err() {\n-        assert Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Ok(~\"a\");\n-        assert Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Err(~\"b\");\n+        fail_unless!(Ok::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Ok(~\"a\"));\n+        fail_unless!(Err::<~str, ~str>(~\"a\").map_err(|_x| ~\"b\") == Err(~\"b\"));\n     }\n \n     #[test]\n     pub fn test_get_ref_method() {\n         let foo: Result<int, ()> = Ok(100);\n-        assert *foo.get_ref() == 100;\n+        fail_unless!(*foo.get_ref() == 100);\n     }\n }"}, {"sha": "bebcc909dc6582c51cfccb6517cfed059afc3170", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -496,7 +496,7 @@ mod tests {\n \n         log(debug, copy expected);\n         log(debug, copy actual);\n-        assert (expected == actual);\n+        fail_unless!((expected == actual));\n     }\n \n     #[test]\n@@ -505,7 +505,7 @@ mod tests {\n                                      &None, &None,\n                                      0i32, 0i32, 0i32);\n         let status = run::waitpid(pid);\n-        assert status == 1;\n+        fail_unless!(status == 1);\n     }\n \n }"}, {"sha": "a6c893f2104882b28432a4fab4766cc22ebe38e5", "filename": "src/libcore/str.rs", "status": "modified", "additions": 370, "deletions": 366, "changes": 736, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -43,7 +43,7 @@ Section: Creating a string\n  * Fails if invalid UTF-8\n  */\n pub pure fn from_bytes(vv: &[const u8]) -> ~str {\n-    assert is_utf8(vv);\n+    fail_unless!(is_utf8(vv));\n     return unsafe { raw::from_bytes(vv) };\n }\n \n@@ -60,7 +60,7 @@ pub pure fn from_slice(s: &str) -> ~str {\n  * Fails if invalid UTF-8\n  */\n pub pure fn from_byte(b: u8) -> ~str {\n-    assert b < 128u8;\n+    fail_unless!(b < 128u8);\n     unsafe { ::cast::transmute(~[b, 0u8]) }\n }\n \n@@ -249,7 +249,7 @@ Section: Adding to and removing from a string\n  */\n pub fn pop_char(s: &mut ~str) -> char {\n     let end = len(*s);\n-    assert end > 0u;\n+    fail_unless!(end > 0u);\n     let CharRange {ch, next} = char_range_at_reverse(*s, end);\n     unsafe { raw::set_len(s, next); }\n     return ch;\n@@ -417,8 +417,8 @@ pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n  * beyond the last character of the string\n  */\n pub pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n-    assert is_char_boundary(s, begin);\n-    assert is_char_boundary(s, end);\n+    fail_unless!(is_char_boundary(s, begin));\n+    fail_unless!(is_char_boundary(s, end));\n     unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n@@ -429,8 +429,8 @@ pub pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n  * the last character of the string\n  */\n pub pure fn view(s: &a/str, begin: uint, end: uint) -> &a/str {\n-    assert is_char_boundary(s, begin);\n-    assert is_char_boundary(s, end);\n+    fail_unless!(is_char_boundary(s, begin));\n+    fail_unless!(is_char_boundary(s, end));\n     unsafe { raw::view_bytes(s, begin, end) }\n }\n \n@@ -528,7 +528,7 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n // See Issue #1932 for why this is a naive search\n pure fn iter_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n-    assert sep_len > 0u;\n+    fail_unless!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n \n     while i < l {\n@@ -568,7 +568,7 @@ pure fn iter_between_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n  * # Example\n  *\n  * ~~~\n- * assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\")\n+ * fail_unless!([\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\"))\n  * ~~~\n  */\n pub pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n@@ -1088,8 +1088,8 @@ pub pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n pub pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n-        assert start <= end;\n-        assert end <= len(s);\n+        fail_unless!(start <= end);\n+        fail_unless!(end <= len(s));\n         let mut i = start;\n         let b = c as u8;\n         while i < end {\n@@ -1167,8 +1167,8 @@ pub pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n pub pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n-        assert start >= end;\n-        assert start <= len(s);\n+        fail_unless!(start >= end);\n+        fail_unless!(start <= len(s));\n         let mut i = start;\n         let b = c as u8;\n         while i > end {\n@@ -1248,9 +1248,9 @@ pub pure fn find_from(s: &str, start: uint, f: fn(char)\n  */\n pub pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n     -> Option<uint> {\n-    assert start <= end;\n-    assert end <= len(s);\n-    assert is_char_boundary(s, start);\n+    fail_unless!(start <= end);\n+    fail_unless!(end <= len(s));\n+    fail_unless!(is_char_boundary(s, start));\n     let mut i = start;\n     while i < end {\n         let CharRange {ch, next} = char_range_at(s, i);\n@@ -1328,9 +1328,9 @@ pub pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n pub pure fn rfind_between(s: &str, start: uint, end: uint,\n                           f: fn(char) -> bool)\n     -> Option<uint> {\n-    assert start >= end;\n-    assert start <= len(s);\n-    assert is_char_boundary(s, start);\n+    fail_unless!(start >= end);\n+    fail_unless!(start <= len(s));\n+    fail_unless!(is_char_boundary(s, start));\n     let mut i = start;\n     while i > end {\n         let CharRange {ch, next: prev} = char_range_at_reverse(s, i);\n@@ -1412,7 +1412,7 @@ pub pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n                          end:uint)\n   -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n-    assert end <= len(haystack);\n+    fail_unless!(end <= len(haystack));\n     let needle_len = len(needle);\n     if needle_len == 0u { return Some(start); }\n     if needle_len > end { return None; }\n@@ -1574,11 +1574,11 @@ pub pure fn to_utf16(s: &str) -> ~[u16] {\n             if (ch & 0xFFFF_u32) == ch {\n                 // The BMP falls through (assuming non-surrogate, as it\n                 // should)\n-                assert ch <= 0xD7FF_u32 || ch >= 0xE000_u32;\n+                fail_unless!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n                 u.push(ch as u16)\n             } else {\n                 // Supplementary planes break into surrogates.\n-                assert ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32;\n+                fail_unless!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n                 ch -= 0x1_0000_u32;\n                 let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n                 let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n@@ -1601,8 +1601,8 @@ pub pure fn utf16_chars(v: &[u16], f: fn(char)) {\n \n         } else {\n             let u2 = v[i+1u];\n-            assert u >= 0xD800_u16 && u <= 0xDBFF_u16;\n-            assert u2 >= 0xDC00_u16 && u2 <= 0xDFFF_u16;\n+            fail_unless!(u >= 0xD800_u16 && u <= 0xDBFF_u16);\n+            fail_unless!(u2 >= 0xDC00_u16 && u2 <= 0xDFFF_u16);\n             let mut c = (u - 0xD800_u16) as char;\n             c = c << 10;\n             c |= (u2 - 0xDC00_u16) as char;\n@@ -1643,8 +1643,8 @@ pub pure fn with_capacity(capacity: uint) -> ~str {\n  * The number of Unicode characters in `s` between the given indices.\n  */\n pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n-    assert is_char_boundary(s, start);\n-    assert is_char_boundary(s, end);\n+    fail_unless!(is_char_boundary(s, start));\n+    fail_unless!(is_char_boundary(s, end));\n     let mut i = start, len = 0u;\n     while i < end {\n         let next = char_range_at(s, i).next;\n@@ -1656,11 +1656,11 @@ pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n \n /// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n pub pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n-    assert is_char_boundary(s, start);\n+    fail_unless!(is_char_boundary(s, start));\n     let mut end = start, cnt = n;\n     let l = len(s);\n     while cnt > 0u {\n-        assert end < l;\n+        fail_unless!(end < l);\n         let next = char_range_at(s, end).next;\n         cnt -= 1u;\n         end = next;\n@@ -1743,14 +1743,14 @@ pub pure fn is_char_boundary(s: &str, index: uint) -> bool {\n pub pure fn char_range_at(s: &str, i: uint) -> CharRange {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n-    assert (w != 0u);\n+    fail_unless!((w != 0u));\n     if w == 1u { return CharRange {ch: b0 as char, next: i + 1u}; }\n     let mut val = 0u;\n     let end = i + w;\n     let mut i = i + 1u;\n     while i < end {\n         let byte = s[i];\n-        assert (byte & 192u8 == tag_cont_u8);\n+        fail_unless!((byte & 192u8 == tag_cont_u8));\n         val <<= 6u;\n         val += (byte & 63u8) as uint;\n         i += 1u;\n@@ -1816,7 +1816,7 @@ pure fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n  */\n pub pure fn all_between(s: &str, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n-    assert is_char_boundary(s, start);\n+    fail_unless!(is_char_boundary(s, start));\n     let mut i = start;\n     while i < end {\n         let CharRange {ch, next} = char_range_at(s, i);\n@@ -1924,7 +1924,7 @@ pub pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n pub pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n     do as_buf(s) |buf, len| {\n         // NB: len includes the trailing null.\n-        assert len > 0;\n+        fail_unless!(len > 0);\n         if unsafe { *(ptr::offset(buf,len-1)) != 0 } {\n             as_c_str(from_slice(s), f)\n         } else {\n@@ -2005,7 +2005,7 @@ pub fn reserve_at_least(s: &mut ~str, n: uint) {\n pub pure fn capacity(s: &const ~str) -> uint {\n     do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n-        assert vcap > 0u;\n+        fail_unless!(vcap > 0u);\n         vcap - 1u\n     }\n }\n@@ -2062,7 +2062,7 @@ pub mod raw {\n         vec::raw::set_len(&mut v, len);\n         v.push(0u8);\n \n-        assert is_utf8(v);\n+        fail_unless!(is_utf8(v));\n         return ::cast::transmute(v);\n     }\n \n@@ -2090,7 +2090,7 @@ pub mod raw {\n     pub unsafe fn buf_as_slice<T>(buf: *u8, len: uint,\n                               f: fn(v: &str) -> T) -> T {\n         let v = (buf, len + 1);\n-        assert is_utf8(::cast::reinterpret_cast(&v));\n+        fail_unless!(is_utf8(::cast::reinterpret_cast(&v)));\n         f(::cast::transmute(v))\n     }\n \n@@ -2106,8 +2106,8 @@ pub mod raw {\n      */\n     pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> ~str {\n         do as_buf(s) |sbuf, n| {\n-            assert (begin <= end);\n-            assert (end <= n);\n+            fail_unless!((begin <= end));\n+            fail_unless!((end <= n));\n \n             let mut v = vec::with_capacity(end - begin + 1u);\n             unsafe {\n@@ -2136,8 +2136,8 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn view_bytes(s: &str, begin: uint, end: uint) -> &str {\n         do as_buf(s) |sbuf, n| {\n-             assert (begin <= end);\n-             assert (end <= n);\n+             fail_unless!((begin <= end));\n+             fail_unless!((end <= n));\n \n              let tuple = (ptr::offset(sbuf, begin), end - begin + 1);\n              ::cast::reinterpret_cast(&tuple)\n@@ -2165,7 +2165,7 @@ pub mod raw {\n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n     pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n-        assert (len > 0u);\n+        fail_unless!((len > 0u));\n         let b = s[len - 1u];\n         unsafe { set_len(s, len - 1u) };\n         return b;\n@@ -2174,7 +2174,7 @@ pub mod raw {\n     /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n     pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n-        assert (len > 0u);\n+        fail_unless!((len > 0u));\n         let b = s[0];\n         *s = unsafe { raw::slice_bytes(*s, 1u, len) };\n         return b;\n@@ -2196,7 +2196,7 @@ pub mod raw {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::raw::to_ptr(a);\n             let c = from_buf_len(b, 3u);\n-            assert (c == ~\"AAA\");\n+            fail_unless!((c == ~\"AAA\"));\n         }\n     }\n \n@@ -2441,69 +2441,69 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        assert (eq(&~\"\", &~\"\"));\n-        assert (eq(&~\"foo\", &~\"foo\"));\n-        assert (!eq(&~\"foo\", &~\"bar\"));\n+        fail_unless!((eq(&~\"\", &~\"\")));\n+        fail_unless!((eq(&~\"foo\", &~\"foo\")));\n+        fail_unless!((!eq(&~\"foo\", &~\"bar\")));\n     }\n \n     #[test]\n     fn test_eq_slice() {\n-        assert (eq_slice(view(\"foobar\", 0, 3), \"foo\"));\n-        assert (eq_slice(view(\"barfoo\", 3, 6), \"foo\"));\n-        assert (!eq_slice(\"foo1\", \"foo2\"));\n+        fail_unless!((eq_slice(view(\"foobar\", 0, 3), \"foo\")));\n+        fail_unless!((eq_slice(view(\"barfoo\", 3, 6), \"foo\")));\n+        fail_unless!((!eq_slice(\"foo1\", \"foo2\")));\n     }\n \n     #[test]\n     fn test_le() {\n-        assert (le(&\"\", &\"\"));\n-        assert (le(&\"\", &\"foo\"));\n-        assert (le(&\"foo\", &\"foo\"));\n-        assert (!eq(&~\"foo\", &~\"bar\"));\n+        fail_unless!((le(&\"\", &\"\")));\n+        fail_unless!((le(&\"\", &\"foo\")));\n+        fail_unless!((le(&\"foo\", &\"foo\")));\n+        fail_unless!((!eq(&~\"foo\", &~\"bar\")));\n     }\n \n     #[test]\n     fn test_len() {\n-        assert (len(~\"\") == 0u);\n-        assert (len(~\"hello world\") == 11u);\n-        assert (len(~\"\\x63\") == 1u);\n-        assert (len(~\"\\xa2\") == 2u);\n-        assert (len(~\"\\u03c0\") == 2u);\n-        assert (len(~\"\\u2620\") == 3u);\n-        assert (len(~\"\\U0001d11e\") == 4u);\n+        fail_unless!((len(~\"\") == 0u));\n+        fail_unless!((len(~\"hello world\") == 11u));\n+        fail_unless!((len(~\"\\x63\") == 1u));\n+        fail_unless!((len(~\"\\xa2\") == 2u));\n+        fail_unless!((len(~\"\\u03c0\") == 2u));\n+        fail_unless!((len(~\"\\u2620\") == 3u));\n+        fail_unless!((len(~\"\\U0001d11e\") == 4u));\n \n-        assert (char_len(~\"\") == 0u);\n-        assert (char_len(~\"hello world\") == 11u);\n-        assert (char_len(~\"\\x63\") == 1u);\n-        assert (char_len(~\"\\xa2\") == 1u);\n-        assert (char_len(~\"\\u03c0\") == 1u);\n-        assert (char_len(~\"\\u2620\") == 1u);\n-        assert (char_len(~\"\\U0001d11e\") == 1u);\n-        assert (char_len(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u);\n+        fail_unless!((char_len(~\"\") == 0u));\n+        fail_unless!((char_len(~\"hello world\") == 11u));\n+        fail_unless!((char_len(~\"\\x63\") == 1u));\n+        fail_unless!((char_len(~\"\\xa2\") == 1u));\n+        fail_unless!((char_len(~\"\\u03c0\") == 1u));\n+        fail_unless!((char_len(~\"\\u2620\") == 1u));\n+        fail_unless!((char_len(~\"\\U0001d11e\") == 1u));\n+        fail_unless!((char_len(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u));\n     }\n \n     #[test]\n     fn test_rfind_char() {\n-        assert rfind_char(~\"hello\", 'l') == Some(3u);\n-        assert rfind_char(~\"hello\", 'o') == Some(4u);\n-        assert rfind_char(~\"hello\", 'h') == Some(0u);\n-        assert rfind_char(~\"hello\", 'z').is_none();\n-        assert rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == Some(30u);\n+        fail_unless!(rfind_char(~\"hello\", 'l') == Some(3u));\n+        fail_unless!(rfind_char(~\"hello\", 'o') == Some(4u));\n+        fail_unless!(rfind_char(~\"hello\", 'h') == Some(0u));\n+        fail_unless!(rfind_char(~\"hello\", 'z').is_none());\n+        fail_unless!(rfind_char(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == Some(30u));\n     }\n \n     #[test]\n     fn test_pop_char() {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n         let cc = pop_char(&mut data);\n-        assert ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data;\n-        assert '\u534e' == cc;\n+        fail_unless!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\" == data);\n+        fail_unless!('\u534e' == cc);\n     }\n \n     #[test]\n     fn test_pop_char_2() {\n         let mut data2 = ~\"\u534e\";\n         let cc2 = pop_char(&mut data2);\n-        assert ~\"\" == data2;\n-        assert '\u534e' == cc2;\n+        fail_unless!(~\"\" == data2);\n+        fail_unless!('\u534e' == cc2);\n     }\n \n     #[test]\n@@ -2520,27 +2520,27 @@ mod tests {\n             log(debug, ~\"split_byte: \" + s);\n             let v = split_char(s, c);\n             debug!(\"split_byte to: %?\", v);\n-            assert vec::all2(v, u, |a,b| a == b);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n         t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n         t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        assert ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]\n-            == split_char(~\"...hello.there.\", '.');\n+        fail_unless!(~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]\n+                     == split_char(~\"...hello.there.\", '.'));\n \n-        assert ~[~\"\"] == split_char(~\"\", 'z');\n-        assert ~[~\"\",~\"\"] == split_char(~\"z\", 'z');\n-        assert ~[~\"ok\"] == split_char(~\"ok\", 'z');\n+        fail_unless!(~[~\"\"] == split_char(~\"\", 'z'));\n+        fail_unless!(~[~\"\",~\"\"] == split_char(~\"z\", 'z'));\n+        fail_unless!(~[~\"ok\"] == split_char(~\"ok\", 'z'));\n     }\n \n     #[test]\n     fn test_split_char_2() {\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n-            == split_char(data, 'V');\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n-            == split_char(data, '\u0e17');\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n+                     == split_char(data, 'V'));\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+                     == split_char(data, '\u0e17'));\n     }\n \n     #[test]\n@@ -2550,7 +2550,7 @@ mod tests {\n             let v = splitn_char(s, c, n);\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            assert vec::all2(v, u, |a,b| a == b);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', 0u, ~[~\"abc.hello.there\"]);\n         t(~\"abc.hello.there\", '.', 1u, ~[~\"abc\", ~\"hello.there\"]);\n@@ -2562,35 +2562,35 @@ mod tests {\n         t(~\"...hello.there.\", '.', 5u,\n           ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        assert ~[~\"\"] == splitn_char(~\"\", 'z', 5u);\n-        assert ~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u);\n-        assert ~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u);\n-        assert ~[~\"z\"] == splitn_char(~\"z\", 'z', 0u);\n-        assert ~[~\"w.x.y\"] == splitn_char(~\"w.x.y\", '.', 0u);\n-        assert ~[~\"w\",~\"x.y\"] == splitn_char(~\"w.x.y\", '.', 1u);\n+        fail_unless!(~[~\"\"] == splitn_char(~\"\", 'z', 5u));\n+        fail_unless!(~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u));\n+        fail_unless!(~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u));\n+        fail_unless!(~[~\"z\"] == splitn_char(~\"z\", 'z', 0u));\n+        fail_unless!(~[~\"w.x.y\"] == splitn_char(~\"w.x.y\", '.', 0u));\n+        fail_unless!(~[~\"w\",~\"x.y\"] == splitn_char(~\"w.x.y\", '.', 1u));\n     }\n \n     #[test]\n     fn test_splitn_char_2 () {\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n-            == splitn_char(data, '\u534e', 1u);\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n+                     == splitn_char(data, '\u534e', 1u));\n \n-        assert ~[~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]\n-            == splitn_char(~\"zzXXXzYYYzWWWz\", 'z', 3u);\n-        assert ~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u);\n-        assert ~[~\"\"] == splitn_char(~\"\", 'z', 5u);\n-        assert ~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u);\n+        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]\n+                     == splitn_char(~\"zzXXXzYYYzWWWz\", 'z', 3u));\n+        fail_unless!(~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u));\n+        fail_unless!(~[~\"\"] == splitn_char(~\"\", 'z', 5u));\n+        fail_unless!(~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u));\n     }\n \n \n     #[test]\n     fn test_splitn_char_3() {\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n-            == splitn_char(data, 'V', 1u);\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n-            == splitn_char(data, '\u0e17', 1u);\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n+                     == splitn_char(data, 'V', 1u));\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+                     == splitn_char(data, '\u0e17', 1u));\n \n     }\n \n@@ -2599,7 +2599,7 @@ mod tests {\n         fn t(s: &str, sep: &a/str, i: int, k: &str) {\n             fn borrow(x: &a/str) -> &a/str { x }\n             let v = split_str(s, sep);\n-            assert borrow(v[i]) == k;\n+            fail_unless!(borrow(v[i]) == k);\n         }\n \n         t(~\"--1233345--\", ~\"12345\", 0, ~\"--1233345--\");\n@@ -2611,146 +2611,148 @@ mod tests {\n         t(~\"::hello::there::\", ~\"::\", 3, ~\"\");\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]\n-            == split_str (data, ~\"\u4e2d\u534e\");\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]\n+                     == split_str (data, ~\"\u4e2d\u534e\"));\n \n-        assert ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n-            == split_str(~\"zzXXXzzYYYzz\", ~\"zz\");\n+        fail_unless!(~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n+                     == split_str(~\"zzXXXzzYYYzz\", ~\"zz\"));\n \n-        assert ~[~\"zz\", ~\"zYYYz\"]\n-            == split_str(~\"zzXXXzYYYz\", ~\"XXX\");\n+        fail_unless!(~[~\"zz\", ~\"zYYYz\"] == split_str(~\"zzXXXzYYYz\", ~\"XXX\"));\n \n \n-        assert ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"] == split_str(~\".XXX.YYY.\", ~\".\");\n-        assert ~[~\"\"] == split_str(~\"\", ~\".\");\n-        assert ~[~\"\",~\"\"] == split_str(~\"zz\", ~\"zz\");\n-        assert ~[~\"ok\"] == split_str(~\"ok\", ~\"z\");\n-        assert ~[~\"\",~\"z\"] == split_str(~\"zzz\", ~\"zz\");\n-        assert ~[~\"\",~\"\",~\"z\"] == split_str(~\"zzzzz\", ~\"zz\");\n+        fail_unless!(~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"] ==\n+                     split_str(~\".XXX.YYY.\", ~\".\"));\n+        fail_unless!(~[~\"\"] == split_str(~\"\", ~\".\"));\n+        fail_unless!(~[~\"\",~\"\"] == split_str(~\"zz\", ~\"zz\"));\n+        fail_unless!(~[~\"ok\"] == split_str(~\"ok\", ~\"z\"));\n+        fail_unless!(~[~\"\",~\"z\"] == split_str(~\"zzz\", ~\"zz\"));\n+        fail_unless!(~[~\"\",~\"\",~\"z\"] == split_str(~\"zzzzz\", ~\"zz\"));\n     }\n \n \n     #[test]\n     fn test_split() {\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n-            == split (data, |cc| cc == '\u534e');\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n+                     == split (data, |cc| cc == '\u534e'));\n \n-        assert ~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n-            == split(~\"zzXXXzYYYz\", char::is_lowercase);\n+        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n+                     == split(~\"zzXXXzYYYz\", char::is_lowercase));\n \n-        assert ~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n-            == split(~\"zzXXXzYYYz\", char::is_uppercase);\n+        fail_unless!(~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n+                     == split(~\"zzXXXzYYYz\", char::is_uppercase));\n \n-        assert ~[~\"\",~\"\"] == split(~\"z\", |cc| cc == 'z');\n-        assert ~[~\"\"] == split(~\"\", |cc| cc == 'z');\n-        assert ~[~\"ok\"] == split(~\"ok\", |cc| cc == 'z');\n+        fail_unless!(~[~\"\",~\"\"] == split(~\"z\", |cc| cc == 'z'));\n+        fail_unless!(~[~\"\"] == split(~\"\", |cc| cc == 'z'));\n+        fail_unless!(~[~\"ok\"] == split(~\"ok\", |cc| cc == 'z'));\n     }\n \n     #[test]\n     fn test_lines() {\n         let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n         let crlf = ~\"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n-        assert ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n-            == lines(lf);\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+                     == lines(lf));\n \n-        assert ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n-            == lines_any(lf);\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+                     == lines_any(lf));\n \n-        assert ~[~\"\\r\", ~\"Mary had a little lamb\\r\", ~\"Little lamb\\r\", ~\"\"]\n-            == lines(crlf);\n+        fail_unless!(~[~\"\\r\", ~\"Mary had a little lamb\\r\",\n+                       ~\"Little lamb\\r\", ~\"\"]\n+            == lines(crlf));\n \n-        assert ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n-            == lines_any(crlf);\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+            == lines_any(crlf));\n \n-        assert ~[~\"\"] == lines    (~\"\");\n-        assert ~[~\"\"] == lines_any(~\"\");\n-        assert ~[~\"\",~\"\"] == lines    (~\"\\n\");\n-        assert ~[~\"\",~\"\"] == lines_any(~\"\\n\");\n-        assert ~[~\"banana\"] == lines    (~\"banana\");\n-        assert ~[~\"banana\"] == lines_any(~\"banana\");\n+        fail_unless!(~[~\"\"] == lines    (~\"\"));\n+        fail_unless!(~[~\"\"] == lines_any(~\"\"));\n+        fail_unless!(~[~\"\",~\"\"] == lines    (~\"\\n\"));\n+        fail_unless!(~[~\"\",~\"\"] == lines_any(~\"\\n\"));\n+        fail_unless!(~[~\"banana\"] == lines    (~\"banana\"));\n+        fail_unless!(~[~\"banana\"] == lines_any(~\"banana\"));\n     }\n \n     #[test]\n     fn test_words () {\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        assert ~[~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]\n-            == words(data);\n+        fail_unless!(~[\n+            ~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]\n+            == words(data));\n \n-        assert ~[~\"ok\"] == words(~\"ok\");\n-        assert ~[] == words(~\"\");\n+        fail_unless!(~[~\"ok\"] == words(~\"ok\"));\n+        fail_unless!(~[] == words(~\"\"));\n     }\n \n     #[test]\n     fn test_split_within() {\n-        assert split_within(~\"\", 0) == ~[];\n-        assert split_within(~\"\", 15) == ~[];\n-        assert split_within(~\"hello\", 15) == ~[~\"hello\"];\n+        fail_unless!(split_within(~\"\", 0) == ~[]);\n+        fail_unless!(split_within(~\"\", 15) == ~[]);\n+        fail_unless!(split_within(~\"hello\", 15) == ~[~\"hello\"]);\n \n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n         error!(\"~~~~ %?\", split_within(data, 15));\n-        assert split_within(data, 15) == ~[~\"Mary had a\",\n-                                           ~\"little lamb\",\n-                                           ~\"Little lamb\"];\n+        fail_unless!(split_within(data, 15) == ~[~\"Mary had a\",\n+                                                 ~\"little lamb\",\n+                                                 ~\"Little lamb\"]);\n     }\n \n     #[test]\n     fn test_find_str() {\n         // byte positions\n-        assert find_str(~\"banana\", ~\"apple pie\").is_none();\n-        assert find_str(~\"\", ~\"\") == Some(0u);\n+        fail_unless!(find_str(~\"banana\", ~\"apple pie\").is_none());\n+        fail_unless!(find_str(~\"\", ~\"\") == Some(0u));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert find_str(data, ~\"\")     == Some(0u);\n-        assert find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\") == Some( 0u);\n-        assert find_str(data, ~\"\u0e30\u0e40\")   == Some( 6u);\n-        assert find_str(data, ~\"\u4e2d\u534e\") == Some(27u);\n-        assert find_str(data, ~\"\u0e44\u0e17\u534e\").is_none();\n+        fail_unless!(find_str(data, ~\"\")     == Some(0u));\n+        fail_unless!(find_str(data, ~\"\u0e1b\u0e23\u0e30\u0e40\") == Some( 0u));\n+        fail_unless!(find_str(data, ~\"\u0e30\u0e40\")   == Some( 6u));\n+        fail_unless!(find_str(data, ~\"\u4e2d\u534e\") == Some(27u));\n+        fail_unless!(find_str(data, ~\"\u0e44\u0e17\u534e\").is_none());\n     }\n \n     #[test]\n     fn test_find_str_between() {\n         // byte positions\n-        assert find_str_between(~\"\", ~\"\", 0u, 0u) == Some(0u);\n+        fail_unless!(find_str_between(~\"\", ~\"\", 0u, 0u) == Some(0u));\n \n         let data = ~\"abcabc\";\n-        assert find_str_between(data, ~\"ab\", 0u, 6u) == Some(0u);\n-        assert find_str_between(data, ~\"ab\", 2u, 6u) == Some(3u);\n-        assert find_str_between(data, ~\"ab\", 2u, 4u).is_none();\n+        fail_unless!(find_str_between(data, ~\"ab\", 0u, 6u) == Some(0u));\n+        fail_unless!(find_str_between(data, ~\"ab\", 2u, 6u) == Some(3u));\n+        fail_unless!(find_str_between(data, ~\"ab\", 2u, 4u).is_none());\n \n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         data = data + data;\n-        assert find_str_between(data, ~\"\", 0u, 43u) == Some(0u);\n-        assert find_str_between(data, ~\"\", 6u, 43u) == Some(6u);\n+        fail_unless!(find_str_between(data, ~\"\", 0u, 43u) == Some(0u));\n+        fail_unless!(find_str_between(data, ~\"\", 6u, 43u) == Some(6u));\n \n-        assert find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u) == Some( 0u);\n-        assert find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u) == Some(12u);\n-        assert find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u) == Some(24u);\n-        assert find_str_between(data, ~\"i\u1ec7t\", 0u, 43u) == Some(34u);\n-        assert find_str_between(data, ~\"Nam\", 0u, 43u) == Some(40u);\n+        fail_unless!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 0u, 43u) == Some( 0u));\n+        fail_unless!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 0u, 43u) == Some(12u));\n+        fail_unless!(find_str_between(data, ~\"\u0e22\u4e2d\", 0u, 43u) == Some(24u));\n+        fail_unless!(find_str_between(data, ~\"i\u1ec7t\", 0u, 43u) == Some(34u));\n+        fail_unless!(find_str_between(data, ~\"Nam\", 0u, 43u) == Some(40u));\n \n-        assert find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u) == Some(43u);\n-        assert find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u) == Some(55u);\n-        assert find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u) == Some(67u);\n-        assert find_str_between(data, ~\"i\u1ec7t\", 43u, 86u) == Some(77u);\n-        assert find_str_between(data, ~\"Nam\", 43u, 86u) == Some(83u);\n+        fail_unless!(find_str_between(data, ~\"\u0e1b\u0e23\u0e30\", 43u, 86u) == Some(43u));\n+        fail_unless!(find_str_between(data, ~\"\u0e17\u0e28\u0e44\", 43u, 86u) == Some(55u));\n+        fail_unless!(find_str_between(data, ~\"\u0e22\u4e2d\", 43u, 86u) == Some(67u));\n+        fail_unless!(find_str_between(data, ~\"i\u1ec7t\", 43u, 86u) == Some(77u));\n+        fail_unless!(find_str_between(data, ~\"Nam\", 43u, 86u) == Some(83u));\n     }\n \n     #[test]\n     fn test_substr() {\n         fn t(a: &str, b: &str, start: int) {\n-            assert substr(a, start as uint, len(b)) == b.to_str();\n+            fail_unless!(substr(a, start as uint, len(b)) == b.to_str());\n         }\n         t(~\"hello\", ~\"llo\", 2);\n         t(~\"hello\", ~\"el\", 1);\n-        assert ~\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u);\n+        fail_unless!(~\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u));\n     }\n \n     #[test]\n     fn test_concat() {\n         fn t(v: &[~str], s: &str) {\n-            assert concat(v) == s.to_str();\n+            fail_unless!(concat(v) == s.to_str());\n         }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"], ~\"youknowI'mnogood\");\n         let v: ~[~str] = ~[];\n@@ -2761,7 +2763,7 @@ mod tests {\n     #[test]\n     fn test_connect() {\n         fn t(v: &[~str], sep: &str, s: &str) {\n-            assert connect(v, sep) == s.to_str();\n+            fail_unless!(connect(v, sep) == s.to_str());\n         }\n         t(~[~\"you\", ~\"know\", ~\"I'm\", ~\"no\", ~\"good\"],\n           ~\" \", ~\"you know I'm no good\");\n@@ -2773,7 +2775,7 @@ mod tests {\n     #[test]\n     fn test_connect_slices() {\n         fn t(v: &[&str], sep: &str, s: &str) {\n-            assert connect_slices(v, sep) == s.to_str();\n+            fail_unless!(connect_slices(v, sep) == s.to_str());\n         }\n         t([\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n           \" \", \"you know I'm no good\");\n@@ -2783,11 +2785,11 @@ mod tests {\n \n     #[test]\n     fn test_repeat() {\n-        assert repeat(~\"x\", 4) == ~\"xxxx\";\n-        assert repeat(~\"hi\", 4) == ~\"hihihihi\";\n-        assert repeat(~\"\u0e44\u0e17\u534e\", 3) == ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\";\n-        assert repeat(~\"\", 4) == ~\"\";\n-        assert repeat(~\"hi\", 0) == ~\"\";\n+        fail_unless!(repeat(~\"x\", 4) == ~\"xxxx\");\n+        fail_unless!(repeat(~\"hi\", 4) == ~\"hihihihi\");\n+        fail_unless!(repeat(~\"\u0e44\u0e17\u534e\", 3) == ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\");\n+        fail_unless!(repeat(~\"\", 4) == ~\"\");\n+        fail_unless!(repeat(~\"hi\", 0) == ~\"\");\n     }\n \n     #[test]\n@@ -2799,24 +2801,24 @@ mod tests {\n         let input = ~\"abcDEF\" + unicode + ~\"xyz:.;\";\n         let expected = ~\"ABCDEF\" + unicode + ~\"XYZ:.;\";\n         let actual = to_upper(input);\n-        assert expected == actual;\n+        fail_unless!(expected == actual);\n     }\n \n     #[test]\n     fn test_to_lower() {\n         unsafe {\n-            assert ~\"\" == map(~\"\", |c| libc::tolower(c as c_char) as char);\n-            assert ~\"ymca\" == map(~\"YMCA\",\n-                                 |c| libc::tolower(c as c_char) as char);\n+            fail_unless!(~\"\" == map(~\"\", |c| libc::tolower(c as c_char) as char));\n+            fail_unless!(~\"ymca\" == map(~\"YMCA\",\n+                                 |c| libc::tolower(c as c_char) as char));\n         }\n     }\n \n     #[test]\n     fn test_unsafe_slice() {\n         unsafe {\n-            assert ~\"ab\" == raw::slice_bytes(~\"abc\", 0, 2);\n-            assert ~\"bc\" == raw::slice_bytes(~\"abc\", 1, 3);\n-            assert ~\"\" == raw::slice_bytes(~\"abc\", 1, 1);\n+            fail_unless!(~\"ab\" == raw::slice_bytes(~\"abc\", 0, 2));\n+            fail_unless!(~\"bc\" == raw::slice_bytes(~\"abc\", 1, 3));\n+            fail_unless!(~\"\" == raw::slice_bytes(~\"abc\", 1, 1));\n             fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n@@ -2829,44 +2831,44 @@ mod tests {\n                 while i < 100000 { push_str(&mut rs, ~\"aaaaa\"); i += 1; }\n                 rs\n             }\n-            assert half_a_million_letter_a() ==\n-                raw::slice_bytes(a_million_letter_a(), 0u, 500000);\n+            fail_unless!(half_a_million_letter_a() ==\n+                raw::slice_bytes(a_million_letter_a(), 0u, 500000));\n         }\n     }\n \n     #[test]\n     fn test_starts_with() {\n-        assert (starts_with(~\"\", ~\"\"));\n-        assert (starts_with(~\"abc\", ~\"\"));\n-        assert (starts_with(~\"abc\", ~\"a\"));\n-        assert (!starts_with(~\"a\", ~\"abc\"));\n-        assert (!starts_with(~\"\", ~\"abc\"));\n+        fail_unless!((starts_with(~\"\", ~\"\")));\n+        fail_unless!((starts_with(~\"abc\", ~\"\")));\n+        fail_unless!((starts_with(~\"abc\", ~\"a\")));\n+        fail_unless!((!starts_with(~\"a\", ~\"abc\")));\n+        fail_unless!((!starts_with(~\"\", ~\"abc\")));\n     }\n \n     #[test]\n     fn test_ends_with() {\n-        assert (ends_with(~\"\", ~\"\"));\n-        assert (ends_with(~\"abc\", ~\"\"));\n-        assert (ends_with(~\"abc\", ~\"c\"));\n-        assert (!ends_with(~\"a\", ~\"abc\"));\n-        assert (!ends_with(~\"\", ~\"abc\"));\n+        fail_unless!((ends_with(~\"\", ~\"\")));\n+        fail_unless!((ends_with(~\"abc\", ~\"\")));\n+        fail_unless!((ends_with(~\"abc\", ~\"c\")));\n+        fail_unless!((!ends_with(~\"a\", ~\"abc\")));\n+        fail_unless!((!ends_with(~\"\", ~\"abc\")));\n     }\n \n     #[test]\n     fn test_is_empty() {\n-        assert (is_empty(~\"\"));\n-        assert (!is_empty(~\"a\"));\n+        fail_unless!((is_empty(~\"\")));\n+        fail_unless!((!is_empty(~\"a\")));\n     }\n \n     #[test]\n     fn test_replace() {\n         let a = ~\"a\";\n-        assert replace(~\"\", a, ~\"b\") == ~\"\";\n-        assert replace(~\"a\", a, ~\"b\") == ~\"b\";\n-        assert replace(~\"ab\", a, ~\"b\") == ~\"bb\";\n+        fail_unless!(replace(~\"\", a, ~\"b\") == ~\"\");\n+        fail_unless!(replace(~\"a\", a, ~\"b\") == ~\"b\");\n+        fail_unless!(replace(~\"ab\", a, ~\"b\") == ~\"bb\");\n         let test = ~\"test\";\n-        assert replace(~\" test test \", test, ~\"toast\") == ~\" toast toast \";\n-        assert replace(~\" test test \", test, ~\"\") == ~\"   \";\n+        fail_unless!(replace(~\" test test \", test, ~\"toast\") == ~\" toast toast \");\n+        fail_unless!(replace(~\" test test \", test, ~\"\") == ~\"   \");\n     }\n \n     #[test]\n@@ -2876,7 +2878,7 @@ mod tests {\n \n         let a = ~\"\u0e1b\u0e23\u0e30\u0e40\";\n         let A = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert (replace(data, a, repl) ==  A);\n+        fail_unless!((replace(data, a, repl) ==  A));\n     }\n \n     #[test]\n@@ -2886,7 +2888,7 @@ mod tests {\n \n         let b = ~\"\u0e30\u0e40\";\n         let B = ~\"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert (replace(data, b,   repl) ==  B);\n+        fail_unless!((replace(data, b,   repl) ==  B));\n     }\n \n     #[test]\n@@ -2896,7 +2898,7 @@ mod tests {\n \n         let c = ~\"\u4e2d\u534e\";\n         let C = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-        assert (replace(data, c, repl) ==  C);\n+        fail_unless!((replace(data, c, repl) ==  C));\n     }\n \n     #[test]\n@@ -2905,21 +2907,21 @@ mod tests {\n         let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let d = ~\"\u0e44\u0e17\u534e\";\n-        assert (replace(data, d, repl) == data);\n+        fail_unless!((replace(data, d, repl) == data));\n     }\n \n     #[test]\n     fn test_slice() {\n-        assert ~\"ab\" == slice(~\"abc\", 0, 2);\n-        assert ~\"bc\" == slice(~\"abc\", 1, 3);\n-        assert ~\"\" == slice(~\"abc\", 1, 1);\n-        assert ~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0, 3);\n+        fail_unless!(~\"ab\" == slice(~\"abc\", 0, 2));\n+        fail_unless!(~\"bc\" == slice(~\"abc\", 1, 3));\n+        fail_unless!(~\"\" == slice(~\"abc\", 1, 1));\n+        fail_unless!(~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0, 3));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert ~\"\u0e1b\" == slice(data, 0, 3);\n-        assert ~\"\u0e23\" == slice(data, 3, 6);\n-        assert ~\"\" == slice(data, 3, 3);\n-        assert ~\"\u534e\" == slice(data, 30, 33);\n+        fail_unless!(~\"\u0e1b\" == slice(data, 0, 3));\n+        fail_unless!(~\"\u0e23\" == slice(data, 3, 6));\n+        fail_unless!(~\"\" == slice(data, 3, 3));\n+        fail_unless!(~\"\u534e\" == slice(data, 30, 33));\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n@@ -2936,24 +2938,24 @@ mod tests {\n             while i < 100000 { push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n             rs\n         }\n-        assert half_a_million_letter_X() ==\n-            slice(a_million_letter_X(), 0u, 3u * 500000u);\n+        fail_unless!(half_a_million_letter_X() ==\n+            slice(a_million_letter_X(), 0u, 3u * 500000u));\n     }\n \n     #[test]\n     fn test_slice_2() {\n         let ss = ~\"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        assert ~\"\u534e\" == slice(ss, 3u, 6u);\n-        assert ~\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u);\n+        fail_unless!(~\"\u534e\" == slice(ss, 3u, 6u));\n+        fail_unless!(~\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u));\n \n-        assert ~\"ab\" == slice(~\"abc\", 0u, 2u);\n-        assert ~\"bc\" == slice(~\"abc\", 1u, 3u);\n-        assert ~\"\" == slice(~\"abc\", 1u, 1u);\n+        fail_unless!(~\"ab\" == slice(~\"abc\", 0u, 2u));\n+        fail_unless!(~\"bc\" == slice(~\"abc\", 1u, 3u));\n+        fail_unless!(~\"\" == slice(~\"abc\", 1u, 1u));\n \n-        assert ~\"\u4e2d\" == slice(ss, 0u, 3u);\n-        assert ~\"\u534eV\" == slice(ss, 3u, 7u);\n-        assert ~\"\" == slice(ss, 3u, 3u);\n+        fail_unless!(~\"\u4e2d\" == slice(ss, 0u, 3u));\n+        fail_unless!(~\"\u534eV\" == slice(ss, 3u, 7u));\n+        fail_unless!(~\"\" == slice(ss, 3u, 3u));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -2975,95 +2977,95 @@ mod tests {\n \n     #[test]\n     fn test_trim_left_chars() {\n-        assert trim_left_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \";\n-        assert trim_left_chars(~\" *** foo *** \", ~['*', ' ']) == ~\"foo *** \";\n-        assert trim_left_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\";\n-        assert trim_left_chars(~\"foo *** \", ~['*', ' ']) == ~\"foo *** \";\n+        fail_unless!(trim_left_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \");\n+        fail_unless!(trim_left_chars(~\" *** foo *** \", ~['*', ' ']) == ~\"foo *** \");\n+        fail_unless!(trim_left_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\");\n+        fail_unless!(trim_left_chars(~\"foo *** \", ~['*', ' ']) == ~\"foo *** \");\n     }\n \n     #[test]\n     fn test_trim_right_chars() {\n-        assert trim_right_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \";\n-        assert trim_right_chars(~\" *** foo *** \", ~['*', ' ']) == ~\" *** foo\";\n-        assert trim_right_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\";\n-        assert trim_right_chars(~\" *** foo\", ~['*', ' ']) == ~\" *** foo\";\n+        fail_unless!(trim_right_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \");\n+        fail_unless!(trim_right_chars(~\" *** foo *** \", ~['*', ' ']) == ~\" *** foo\");\n+        fail_unless!(trim_right_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\");\n+        fail_unless!(trim_right_chars(~\" *** foo\", ~['*', ' ']) == ~\" *** foo\");\n     }\n \n     #[test]\n     fn test_trim_chars() {\n-        assert trim_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \";\n-        assert trim_chars(~\" *** foo *** \", ~['*', ' ']) == ~\"foo\";\n-        assert trim_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\";\n-        assert trim_chars(~\"foo\", ~['*', ' ']) == ~\"foo\";\n+        fail_unless!(trim_chars(~\" *** foo *** \", ~[]) == ~\" *** foo *** \");\n+        fail_unless!(trim_chars(~\" *** foo *** \", ~['*', ' ']) == ~\"foo\");\n+        fail_unless!(trim_chars(~\" ***  *** \", ~['*', ' ']) == ~\"\");\n+        fail_unless!(trim_chars(~\"foo\", ~['*', ' ']) == ~\"foo\");\n     }\n \n     #[test]\n     fn test_trim_left() {\n-        assert (trim_left(~\"\") == ~\"\");\n-        assert (trim_left(~\"a\") == ~\"a\");\n-        assert (trim_left(~\"    \") == ~\"\");\n-        assert (trim_left(~\"     blah\") == ~\"blah\");\n-        assert (trim_left(~\"   \\u3000  wut\") == ~\"wut\");\n-        assert (trim_left(~\"hey \") == ~\"hey \");\n+        fail_unless!((trim_left(~\"\") == ~\"\"));\n+        fail_unless!((trim_left(~\"a\") == ~\"a\"));\n+        fail_unless!((trim_left(~\"    \") == ~\"\"));\n+        fail_unless!((trim_left(~\"     blah\") == ~\"blah\"));\n+        fail_unless!((trim_left(~\"   \\u3000  wut\") == ~\"wut\"));\n+        fail_unless!((trim_left(~\"hey \") == ~\"hey \"));\n     }\n \n     #[test]\n     fn test_trim_right() {\n-        assert (trim_right(~\"\") == ~\"\");\n-        assert (trim_right(~\"a\") == ~\"a\");\n-        assert (trim_right(~\"    \") == ~\"\");\n-        assert (trim_right(~\"blah     \") == ~\"blah\");\n-        assert (trim_right(~\"wut   \\u3000  \") == ~\"wut\");\n-        assert (trim_right(~\" hey\") == ~\" hey\");\n+        fail_unless!((trim_right(~\"\") == ~\"\"));\n+        fail_unless!((trim_right(~\"a\") == ~\"a\"));\n+        fail_unless!((trim_right(~\"    \") == ~\"\"));\n+        fail_unless!((trim_right(~\"blah     \") == ~\"blah\"));\n+        fail_unless!((trim_right(~\"wut   \\u3000  \") == ~\"wut\"));\n+        fail_unless!((trim_right(~\" hey\") == ~\" hey\"));\n     }\n \n     #[test]\n     fn test_trim() {\n-        assert (trim(~\"\") == ~\"\");\n-        assert (trim(~\"a\") == ~\"a\");\n-        assert (trim(~\"    \") == ~\"\");\n-        assert (trim(~\"    blah     \") == ~\"blah\");\n-        assert (trim(~\"\\nwut   \\u3000  \") == ~\"wut\");\n-        assert (trim(~\" hey dude \") == ~\"hey dude\");\n+        fail_unless!((trim(~\"\") == ~\"\"));\n+        fail_unless!((trim(~\"a\") == ~\"a\"));\n+        fail_unless!((trim(~\"    \") == ~\"\"));\n+        fail_unless!((trim(~\"    blah     \") == ~\"blah\"));\n+        fail_unless!((trim(~\"\\nwut   \\u3000  \") == ~\"wut\"));\n+        fail_unless!((trim(~\" hey dude \") == ~\"hey dude\"));\n     }\n \n     #[test]\n     fn test_is_whitespace() {\n-        assert (is_whitespace(~\"\"));\n-        assert (is_whitespace(~\" \"));\n-        assert (is_whitespace(~\"\\u2009\")); // Thin space\n-        assert (is_whitespace(~\"  \\n\\t   \"));\n-        assert (!is_whitespace(~\"   _   \"));\n+        fail_unless!((is_whitespace(~\"\")));\n+        fail_unless!((is_whitespace(~\" \")));\n+        fail_unless!((is_whitespace(~\"\\u2009\"))); // Thin space\n+        fail_unless!((is_whitespace(~\"  \\n\\t   \")));\n+        fail_unless!((!is_whitespace(~\"   _   \")));\n     }\n \n     #[test]\n     fn test_is_ascii() {\n-        assert (is_ascii(~\"\"));\n-        assert (is_ascii(~\"a\"));\n-        assert (!is_ascii(~\"\\u2009\"));\n+        fail_unless!((is_ascii(~\"\")));\n+        fail_unless!((is_ascii(~\"a\")));\n+        fail_unless!((!is_ascii(~\"\\u2009\")));\n     }\n \n     #[test]\n     fn test_shift_byte() {\n         let mut s = ~\"ABC\";\n         let b = unsafe { raw::shift_byte(&mut s) };\n-        assert (s == ~\"BC\");\n-        assert (b == 65u8);\n+        fail_unless!((s == ~\"BC\"));\n+        fail_unless!((b == 65u8));\n     }\n \n     #[test]\n     fn test_pop_byte() {\n         let mut s = ~\"ABC\";\n         let b = unsafe { raw::pop_byte(&mut s) };\n-        assert (s == ~\"AB\");\n-        assert (b == 67u8);\n+        fail_unless!((s == ~\"AB\"));\n+        fail_unless!((b == 67u8));\n     }\n \n     #[test]\n     fn test_unsafe_from_bytes() {\n         let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8];\n         let b = unsafe { raw::from_bytes(a) };\n-        assert (b == ~\"AAAAAAA\");\n+        fail_unless!((b == ~\"AAAAAAA\"));\n     }\n \n     #[test]\n@@ -3080,7 +3082,7 @@ mod tests {\n                   0x20_u8, 0x4e_u8, 0x61_u8,\n                   0x6d_u8];\n \n-        assert ss == from_bytes(bb);\n+        fail_unless!(ss == from_bytes(bb));\n     }\n \n     #[test]\n@@ -3107,7 +3109,7 @@ mod tests {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = vec::raw::to_ptr(a);\n             let c = raw::from_buf(b);\n-            assert (c == ~\"AAAAAAA\");\n+            fail_unless!((c == ~\"AAAAAAA\"));\n         }\n     }\n \n@@ -3123,20 +3125,20 @@ mod tests {\n     fn test_as_buf() {\n         let a = ~\"Abcdefg\";\n         let b = as_buf(a, |buf, _l| {\n-            assert unsafe { *buf } == 65u8;\n+            fail_unless!(unsafe { *buf } == 65u8);\n             100\n         });\n-        assert (b == 100);\n+        fail_unless!((b == 100));\n     }\n \n     #[test]\n     fn test_as_buf_small() {\n         let a = ~\"A\";\n         let b = as_buf(a, |buf, _l| {\n-            assert unsafe { *buf } == 65u8;\n+            fail_unless!(unsafe { *buf } == 65u8);\n             100\n         });\n-        assert (b == 100);\n+        fail_unless!((b == 100));\n     }\n \n     #[test]\n@@ -3145,7 +3147,7 @@ mod tests {\n             let s = ~\"hello\";\n             let sb = as_buf(s, |b, _l| b);\n             let s_cstr = raw::from_buf(sb);\n-            assert s_cstr == s;\n+            fail_unless!(s_cstr == s);\n         }\n     }\n \n@@ -3154,11 +3156,11 @@ mod tests {\n         let a = ~\"hello\";\n         do as_buf(a) |buf, len| {\n             unsafe {\n-                assert a[0] == 'h' as u8;\n-                assert *buf == 'h' as u8;\n-                assert len == 6u;\n-                assert *ptr::offset(buf,4u) == 'o' as u8;\n-                assert *ptr::offset(buf,5u) == 0u8;\n+                fail_unless!(a[0] == 'h' as u8);\n+                fail_unless!(*buf == 'h' as u8);\n+                fail_unless!(len == 6u);\n+                fail_unless!(*ptr::offset(buf,4u) == 'o' as u8);\n+                fail_unless!(*ptr::offset(buf,5u) == 0u8);\n             }\n         }\n     }\n@@ -3172,50 +3174,50 @@ mod tests {\n         let mut i: uint = 0u;\n         let n1: uint = len(s1);\n         let n2: uint = vec::len::<u8>(v);\n-        assert (n1 == n2);\n+        fail_unless!((n1 == n2));\n         while i < n1 {\n             let a: u8 = s1[i];\n             let b: u8 = s2[i];\n             log(debug, a);\n             log(debug, b);\n-            assert (a == b);\n+            fail_unless!((a == b));\n             i += 1u;\n         }\n     }\n \n     #[test]\n     fn test_contains() {\n-        assert contains(~\"abcde\", ~\"bcd\");\n-        assert contains(~\"abcde\", ~\"abcd\");\n-        assert contains(~\"abcde\", ~\"bcde\");\n-        assert contains(~\"abcde\", ~\"\");\n-        assert contains(~\"\", ~\"\");\n-        assert !contains(~\"abcde\", ~\"def\");\n-        assert !contains(~\"\", ~\"a\");\n+        fail_unless!(contains(~\"abcde\", ~\"bcd\"));\n+        fail_unless!(contains(~\"abcde\", ~\"abcd\"));\n+        fail_unless!(contains(~\"abcde\", ~\"bcde\"));\n+        fail_unless!(contains(~\"abcde\", ~\"\"));\n+        fail_unless!(contains(~\"\", ~\"\"));\n+        fail_unless!(!contains(~\"abcde\", ~\"def\"));\n+        fail_unless!(!contains(~\"\", ~\"a\"));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert  contains(data, ~\"\u0e1b\u0e23\u0e30\u0e40\");\n-        assert  contains(data, ~\"\u0e30\u0e40\");\n-        assert  contains(data, ~\"\u4e2d\u534e\");\n-        assert !contains(data, ~\"\u0e44\u0e17\u534e\");\n+        fail_unless!(contains(data, ~\"\u0e1b\u0e23\u0e30\u0e40\"));\n+        fail_unless!(contains(data, ~\"\u0e30\u0e40\"));\n+        fail_unless!(contains(data, ~\"\u4e2d\u534e\"));\n+        fail_unless!(!contains(data, ~\"\u0e44\u0e17\u534e\"));\n     }\n \n     #[test]\n     fn test_contains_char() {\n-        assert contains_char(~\"abc\", 'b');\n-        assert contains_char(~\"a\", 'a');\n-        assert !contains_char(~\"abc\", 'd');\n-        assert !contains_char(~\"\", 'a');\n+        fail_unless!(contains_char(~\"abc\", 'b'));\n+        fail_unless!(contains_char(~\"a\", 'a'));\n+        fail_unless!(!contains_char(~\"abc\", 'd'));\n+        fail_unless!(!contains_char(~\"\", 'a'));\n     }\n \n     #[test]\n     fn test_chars_each() {\n         let mut i = 0;\n         for chars_each(~\"x\\u03c0y\") |ch| {\n             match i {\n-              0 => assert ch == 'x',\n-              1 => assert ch == '\\u03c0',\n-              2 => assert ch == 'y',\n+              0 => fail_unless!(ch == 'x'),\n+              1 => fail_unless!(ch == '\\u03c0'),\n+              2 => fail_unless!(ch == 'y'),\n               _ => fail!(~\"test_chars_each failed\")\n             }\n             i += 1;\n@@ -3230,16 +3232,16 @@ mod tests {\n \n         for bytes_each(~\"xyz\") |bb| {\n             match i {\n-              0 => assert bb == 'x' as u8,\n-              1 => assert bb == 'y' as u8,\n-              2 => assert bb == 'z' as u8,\n+              0 => fail_unless!(bb == 'x' as u8),\n+              1 => fail_unless!(bb == 'y' as u8),\n+              2 => fail_unless!(bb == 'z' as u8),\n               _ => fail!(~\"test_bytes_each failed\")\n             }\n             i += 1;\n         }\n \n         for bytes_each(~\"\") |bb| {\n-            assert bb == 0u8;\n+            fail_unless!(bb == 0u8);\n         }\n     }\n \n@@ -3251,10 +3253,10 @@ mod tests {\n \n         for split_char_each(data, ' ') |xx| {\n             match ii {\n-              0 => assert \"\\nMary\" == xx,\n-              1 => assert \"had\"    == xx,\n-              2 => assert \"a\"      == xx,\n-              3 => assert \"little\" == xx,\n+              0 => fail_unless!(\"\\nMary\" == xx),\n+              1 => fail_unless!(\"had\"    == xx),\n+              2 => fail_unless!(\"a\"      == xx),\n+              3 => fail_unless!(\"little\" == xx),\n               _ => ()\n             }\n             ii += 1;\n@@ -3269,9 +3271,9 @@ mod tests {\n \n         for splitn_char_each(data, ' ', 2u) |xx| {\n             match ii {\n-              0 => assert \"\\nMary\" == xx,\n-              1 => assert \"had\"    == xx,\n-              2 => assert \"a little lamb\\nLittle lamb\\n\" == xx,\n+              0 => fail_unless!(\"\\nMary\" == xx),\n+              1 => fail_unless!(\"had\"    == xx),\n+              2 => fail_unless!(\"a little lamb\\nLittle lamb\\n\" == xx),\n               _ => ()\n             }\n             ii += 1;\n@@ -3286,10 +3288,10 @@ mod tests {\n \n         for words_each(data) |ww| {\n             match ii {\n-              0 => assert \"Mary\"   == ww,\n-              1 => assert \"had\"    == ww,\n-              2 => assert \"a\"      == ww,\n-              3 => assert \"little\" == ww,\n+              0 => fail_unless!(\"Mary\"   == ww),\n+              1 => fail_unless!(\"had\"    == ww),\n+              2 => fail_unless!(\"a\"      == ww),\n+              3 => fail_unless!(\"little\" == ww),\n               _ => ()\n             }\n             ii += 1;\n@@ -3306,10 +3308,10 @@ mod tests {\n \n         for lines_each(lf) |x| {\n             match ii {\n-                0 => assert \"\" == x,\n-                1 => assert \"Mary had a little lamb\" == x,\n-                2 => assert \"Little lamb\" == x,\n-                3 => assert \"\" == x,\n+                0 => fail_unless!(\"\" == x),\n+                1 => fail_unless!(\"Mary had a little lamb\" == x),\n+                2 => fail_unless!(\"Little lamb\" == x),\n+                3 => fail_unless!(\"\" == x),\n                 _ => ()\n             }\n             ii += 1;\n@@ -3319,35 +3321,36 @@ mod tests {\n     #[test]\n     fn test_map() {\n         unsafe {\n-            assert ~\"\" == map(~\"\", |c| libc::toupper(c as c_char) as char);\n-            assert ~\"YMCA\" == map(~\"ymca\",\n-                                  |c| libc::toupper(c as c_char) as char);\n+            fail_unless!(~\"\" == map(~\"\", |c| libc::toupper(c as c_char) as char));\n+            fail_unless!(~\"YMCA\" == map(~\"ymca\",\n+                                  |c| libc::toupper(c as c_char) as char));\n         }\n     }\n \n     #[test]\n     fn test_all() {\n-        assert true  == all(~\"\", char::is_uppercase);\n-        assert false == all(~\"ymca\", char::is_uppercase);\n-        assert true  == all(~\"YMCA\", char::is_uppercase);\n-        assert false == all(~\"yMCA\", char::is_uppercase);\n-        assert false == all(~\"YMCy\", char::is_uppercase);\n+        fail_unless!(true  == all(~\"\", char::is_uppercase));\n+        fail_unless!(false == all(~\"ymca\", char::is_uppercase));\n+        fail_unless!(true  == all(~\"YMCA\", char::is_uppercase));\n+        fail_unless!(false == all(~\"yMCA\", char::is_uppercase));\n+        fail_unless!(false == all(~\"YMCy\", char::is_uppercase));\n     }\n \n     #[test]\n     fn test_any() {\n-        assert false  == any(~\"\", char::is_uppercase);\n-        assert false == any(~\"ymca\", char::is_uppercase);\n-        assert true  == any(~\"YMCA\", char::is_uppercase);\n-        assert true == any(~\"yMCA\", char::is_uppercase);\n-        assert true == any(~\"Ymcy\", char::is_uppercase);\n+        fail_unless!(false  == any(~\"\", char::is_uppercase));\n+        fail_unless!(false == any(~\"ymca\", char::is_uppercase));\n+        fail_unless!(true  == any(~\"YMCA\", char::is_uppercase));\n+        fail_unless!(true == any(~\"yMCA\", char::is_uppercase));\n+        fail_unless!(true == any(~\"Ymcy\", char::is_uppercase));\n     }\n \n     #[test]\n     fn test_chars() {\n         let ss = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m']\n-            == chars(ss);\n+        fail_unless!(~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a',\n+                       'm']\n+            == chars(ss));\n     }\n \n     #[test]\n@@ -3391,10 +3394,10 @@ mod tests {\n \n         for vec::each(pairs) |p| {\n             let (s, u) = copy *p;\n-            assert to_utf16(s) == u;\n-            assert from_utf16(u) == s;\n-            assert from_utf16(to_utf16(s)) == s;\n-            assert to_utf16(from_utf16(u)) == u;\n+            fail_unless!(to_utf16(s) == u);\n+            fail_unless!(from_utf16(u) == s);\n+            fail_unless!(from_utf16(to_utf16(s)) == s);\n+            fail_unless!(to_utf16(from_utf16(u)) == u);\n         }\n     }\n \n@@ -3408,40 +3411,41 @@ mod tests {\n                 break;\n             }\n         }\n-        assert found_b;\n+        fail_unless!(found_b);\n     }\n \n     #[test]\n     fn test_escape_unicode() {\n-        assert escape_unicode(~\"abc\") == ~\"\\\\x61\\\\x62\\\\x63\";\n-        assert escape_unicode(~\"a c\") == ~\"\\\\x61\\\\x20\\\\x63\";\n-        assert escape_unicode(~\"\\r\\n\\t\") == ~\"\\\\x0d\\\\x0a\\\\x09\";\n-        assert escape_unicode(~\"'\\\"\\\\\") == ~\"\\\\x27\\\\x22\\\\x5c\";\n-        assert escape_unicode(~\"\\x00\\x01\\xfe\\xff\") == ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\";\n-        assert escape_unicode(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\";\n-        assert escape_unicode(~\"\\U00010000\\U0010ffff\") ==\n-            ~\"\\\\U00010000\\\\U0010ffff\";\n-        assert escape_unicode(~\"ab\\ufb00\") == ~\"\\\\x61\\\\x62\\\\ufb00\";\n-        assert escape_unicode(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\x0d\";\n+        fail_unless!(escape_unicode(~\"abc\") == ~\"\\\\x61\\\\x62\\\\x63\");\n+        fail_unless!(escape_unicode(~\"a c\") == ~\"\\\\x61\\\\x20\\\\x63\");\n+        fail_unless!(escape_unicode(~\"\\r\\n\\t\") == ~\"\\\\x0d\\\\x0a\\\\x09\");\n+        fail_unless!(escape_unicode(~\"'\\\"\\\\\") == ~\"\\\\x27\\\\x22\\\\x5c\");\n+        fail_unless!(escape_unicode(~\"\\x00\\x01\\xfe\\xff\") ==\n+                     ~\"\\\\x00\\\\x01\\\\xfe\\\\xff\");\n+        fail_unless!(escape_unicode(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\");\n+        fail_unless!(escape_unicode(~\"\\U00010000\\U0010ffff\") ==\n+            ~\"\\\\U00010000\\\\U0010ffff\");\n+        fail_unless!(escape_unicode(~\"ab\\ufb00\") == ~\"\\\\x61\\\\x62\\\\ufb00\");\n+        fail_unless!(escape_unicode(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\x0d\");\n     }\n \n     #[test]\n     fn test_escape_default() {\n-        assert escape_default(~\"abc\") == ~\"abc\";\n-        assert escape_default(~\"a c\") == ~\"a c\";\n-        assert escape_default(~\"\\r\\n\\t\") == ~\"\\\\r\\\\n\\\\t\";\n-        assert escape_default(~\"'\\\"\\\\\") == ~\"\\\\'\\\\\\\"\\\\\\\\\";\n-        assert escape_default(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\";\n-        assert escape_default(~\"\\U00010000\\U0010ffff\") ==\n-            ~\"\\\\U00010000\\\\U0010ffff\";\n-        assert escape_default(~\"ab\\ufb00\") == ~\"ab\\\\ufb00\";\n-        assert escape_default(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\r\";\n+        fail_unless!(escape_default(~\"abc\") == ~\"abc\");\n+        fail_unless!(escape_default(~\"a c\") == ~\"a c\");\n+        fail_unless!(escape_default(~\"\\r\\n\\t\") == ~\"\\\\r\\\\n\\\\t\");\n+        fail_unless!(escape_default(~\"'\\\"\\\\\") == ~\"\\\\'\\\\\\\"\\\\\\\\\");\n+        fail_unless!(escape_default(~\"\\u0100\\uffff\") == ~\"\\\\u0100\\\\uffff\");\n+        fail_unless!(escape_default(~\"\\U00010000\\U0010ffff\") ==\n+            ~\"\\\\U00010000\\\\U0010ffff\");\n+        fail_unless!(escape_default(~\"ab\\ufb00\") == ~\"ab\\\\ufb00\");\n+        fail_unless!(escape_default(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\r\");\n     }\n \n     #[test]\n     fn test_to_managed() {\n-        assert (~\"abc\").to_managed() == @\"abc\";\n-        assert view(\"abcdef\", 1, 5).to_managed() == @\"bcde\";\n+        fail_unless!((~\"abc\").to_managed() == @\"abc\");\n+        fail_unless!(view(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n     }\n \n     #[test]"}, {"sha": "d4db61f4519c3acb79410380f11832391db5bc89", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -156,64 +156,71 @@ pub pure fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     }\n }\n \n+pub pure fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n+    unsafe {\n+        let (msg, file) = (msg.to_owned(), file.to_owned());\n+        begin_unwind(~\"assertion failed: \" + msg, file, line)\n+    }\n+}\n+\n #[cfg(test)]\n pub mod tests {\n     use cast;\n     use sys::{Closure, pref_align_of, size_of, nonzero_size_of};\n \n     #[test]\n     pub fn size_of_basic() {\n-        assert size_of::<u8>() == 1u;\n-        assert size_of::<u16>() == 2u;\n-        assert size_of::<u32>() == 4u;\n-        assert size_of::<u64>() == 8u;\n+        fail_unless!(size_of::<u8>() == 1u);\n+        fail_unless!(size_of::<u16>() == 2u);\n+        fail_unless!(size_of::<u32>() == 4u);\n+        fail_unless!(size_of::<u64>() == 8u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n     pub fn size_of_32() {\n-        assert size_of::<uint>() == 4u;\n-        assert size_of::<*uint>() == 4u;\n+        fail_unless!(size_of::<uint>() == 4u);\n+        fail_unless!(size_of::<*uint>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     pub fn size_of_64() {\n-        assert size_of::<uint>() == 8u;\n-        assert size_of::<*uint>() == 8u;\n+        fail_unless!(size_of::<uint>() == 8u);\n+        fail_unless!(size_of::<*uint>() == 8u);\n     }\n \n     #[test]\n     pub fn nonzero_size_of_basic() {\n         type Z = [i8 * 0];\n-        assert size_of::<Z>() == 0u;\n-        assert nonzero_size_of::<Z>() == 1u;\n-        assert nonzero_size_of::<uint>() == size_of::<uint>();\n+        fail_unless!(size_of::<Z>() == 0u);\n+        fail_unless!(nonzero_size_of::<Z>() == 1u);\n+        fail_unless!(nonzero_size_of::<uint>() == size_of::<uint>());\n     }\n \n     #[test]\n     pub fn align_of_basic() {\n-        assert pref_align_of::<u8>() == 1u;\n-        assert pref_align_of::<u16>() == 2u;\n-        assert pref_align_of::<u32>() == 4u;\n+        fail_unless!(pref_align_of::<u8>() == 1u);\n+        fail_unless!(pref_align_of::<u16>() == 2u);\n+        fail_unless!(pref_align_of::<u32>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n     pub fn align_of_32() {\n-        assert pref_align_of::<uint>() == 4u;\n-        assert pref_align_of::<*uint>() == 4u;\n+        fail_unless!(pref_align_of::<uint>() == 4u);\n+        fail_unless!(pref_align_of::<*uint>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     pub fn align_of_64() {\n-        assert pref_align_of::<uint>() == 8u;\n-        assert pref_align_of::<*uint>() == 8u;\n+        fail_unless!(pref_align_of::<uint>() == 8u);\n+        fail_unless!(pref_align_of::<*uint>() == 8u);\n     }\n \n     #[test]\n@@ -222,7 +229,7 @@ pub mod tests {\n             let x = 10;\n             let f: fn(int) -> int = |y| x + y;\n \n-            assert f(20) == 30;\n+            fail_unless!(f(20) == 30);\n \n             let original_closure: Closure = cast::transmute(f);\n \n@@ -235,7 +242,7 @@ pub mod tests {\n             };\n \n             let new_f: fn(int) -> int = cast::transmute(new_closure);\n-            assert new_f(20) == 30;\n+            fail_unless!(new_f(20) == 30);\n         }\n     }\n }"}, {"sha": "b0b597182e195944c9edb38c0335f6eefd6fcac5", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -92,16 +92,16 @@ fn test_tls_multitask() {\n         do task::spawn {\n             unsafe {\n                 // TLS shouldn't carry over.\n-                assert local_data_get(my_key).is_none();\n+                fail_unless!(local_data_get(my_key).is_none());\n                 local_data_set(my_key, @~\"child data\");\n-                assert *(local_data_get(my_key).get()) == ~\"child data\";\n+                fail_unless!(*(local_data_get(my_key).get()) == ~\"child data\");\n                 // should be cleaned up for us\n             }\n         }\n         // Must work multiple times\n-        assert *(local_data_get(my_key).get()) == ~\"parent data\";\n-        assert *(local_data_get(my_key).get()) == ~\"parent data\";\n-        assert *(local_data_get(my_key).get()) == ~\"parent data\";\n+        fail_unless!(*(local_data_get(my_key).get()) == ~\"parent data\");\n+        fail_unless!(*(local_data_get(my_key).get()) == ~\"parent data\");\n+        fail_unless!(*(local_data_get(my_key).get()) == ~\"parent data\");\n     }\n }\n \n@@ -111,7 +111,7 @@ fn test_tls_overwrite() {\n         fn my_key(_x: @~str) { }\n         local_data_set(my_key, @~\"first data\");\n         local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n-        assert *(local_data_get(my_key).get()) == ~\"next data\";\n+        fail_unless!(*(local_data_get(my_key).get()) == ~\"next data\");\n     }\n }\n \n@@ -120,9 +120,9 @@ fn test_tls_pop() {\n     unsafe {\n         fn my_key(_x: @~str) { }\n         local_data_set(my_key, @~\"weasel\");\n-        assert *(local_data_pop(my_key).get()) == ~\"weasel\";\n+        fail_unless!(*(local_data_pop(my_key).get()) == ~\"weasel\");\n         // Pop must remove the data from the map.\n-        assert local_data_pop(my_key).is_none();\n+        fail_unless!(local_data_pop(my_key).is_none());\n     }\n }\n \n@@ -143,7 +143,7 @@ fn test_tls_modify() {\n                 None                 => fail!(~\"missing value\")\n             }\n         });\n-        assert *(local_data_pop(my_key).get()) == ~\"next data\";\n+        fail_unless!(*(local_data_pop(my_key).get()) == ~\"next data\");\n     }\n }\n "}, {"sha": "cb1283019ebaa6102d7ed1dcb2f4da421464332a", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -43,7 +43,7 @@ type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n \n extern fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n-        assert !map_ptr.is_null();\n+        fail_unless!(!map_ptr.is_null());\n         // Get and keep the single reference that was created at the\n         // beginning.\n         let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);"}, {"sha": "a6aa365ac33593c26d3b39705bb4ff88f6f82e3d", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -848,14 +848,14 @@ fn test_add_wrapper() {\n fn test_future_result() {\n     let mut result = None;\n     do task().future_result(|+r| { result = Some(r); }).spawn { }\n-    assert option::unwrap(result).recv() == Success;\n+    fail_unless!(option::unwrap(result).recv() == Success);\n \n     result = None;\n     do task().future_result(|+r|\n         { result = Some(r); }).unlinked().spawn {\n         fail!();\n     }\n-    assert option::unwrap(result).recv() == Failure;\n+    fail_unless!(option::unwrap(result).recv() == Failure);\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -901,7 +901,7 @@ fn test_spawn_sched() {\n \n         do spawn_sched(SingleThreaded) {\n             let child_sched_id = unsafe { rt::rust_get_sched_id() };\n-            assert parent_sched_id != child_sched_id;\n+            fail_unless!(parent_sched_id != child_sched_id);\n \n             if (i == 0) {\n                 ch.send(());\n@@ -929,8 +929,8 @@ fn test_spawn_sched_childs_on_default_sched() {\n         do spawn {\n             let ch = ch.f.swap_unwrap();\n             let child_sched_id = unsafe { rt::rust_get_sched_id() };\n-            assert parent_sched_id != child_sched_id;\n-            assert child_sched_id == default_id;\n+            fail_unless!(parent_sched_id != child_sched_id);\n+            fail_unless!(child_sched_id == default_id);\n             ch.send(());\n         };\n     };\n@@ -1022,7 +1022,7 @@ fn avoid_copying_the_body(spawnfn: &fn(v: ~fn())) {\n     }\n \n     let x_in_child = p.recv();\n-    assert x_in_parent == x_in_child;\n+    fail_unless!(x_in_parent == x_in_child);\n }\n \n #[test]\n@@ -1177,7 +1177,7 @@ fn test_sched_thread_per_core() {\n         unsafe {\n             let cores = rt::rust_num_threads();\n             let reported_threads = rt::rust_sched_threads();\n-            assert(cores as uint == reported_threads as uint);\n+            fail_unless!((cores as uint == reported_threads as uint));\n             chan.send(());\n         }\n     }\n@@ -1192,9 +1192,9 @@ fn test_spawn_thread_on_demand() {\n     do spawn_sched(ManualThreads(2)) || {\n         unsafe {\n             let max_threads = rt::rust_sched_threads();\n-            assert(max_threads as int == 2);\n+            fail_unless!((max_threads as int == 2));\n             let running_threads = rt::rust_sched_current_nonlazy_threads();\n-            assert(running_threads as int == 1);\n+            fail_unless!((running_threads as int == 1));\n \n             let (port2, chan2) = comm::stream();\n \n@@ -1203,7 +1203,7 @@ fn test_spawn_thread_on_demand() {\n             }\n \n             let running_threads2 = rt::rust_sched_current_nonlazy_threads();\n-            assert(running_threads2 as int == 2);\n+            fail_unless!((running_threads2 as int == 2));\n \n             port2.recv();\n             chan.send(());"}, {"sha": "7b7ec769fa9a76b6909e2505db77fcd70f259ec5", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -102,11 +102,11 @@ fn new_taskset() -> TaskSet {\n }\n fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task);\n-    assert didnt_overwrite;\n+    fail_unless!(didnt_overwrite);\n }\n fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n-    assert was_present;\n+    fail_unless!(was_present);\n }\n pub fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n     tasks.each(|k| blk(*k))\n@@ -230,7 +230,7 @@ fn each_ancestor(list:        &mut AncestorList,\n             // NB: Takes a lock! (this ancestor node)\n             do access_ancestors(ancestor_arc) |nobe| {\n                 // Check monotonicity\n-                assert last_generation > nobe.generation;\n+                fail_unless!(last_generation > nobe.generation);\n                 /*##########################################################*\n                  * Step 1: Look at this ancestor group (call iterator block).\n                  *##########################################################*/\n@@ -422,7 +422,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n                 }\n             }\n             for taskset_each(&group.descendants) |child| {\n-                assert child != me;\n+                fail_unless!(child != me);\n                 rt::rust_task_kill_other(child);\n             }\n             // Only one task should ever do this.\n@@ -497,7 +497,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                         }\n                         None => 0 // the actual value doesn't really matter.\n                     };\n-                assert new_generation < uint::max_value;\n+                fail_unless!(new_generation < uint::max_value);\n                 // Build a new node in the ancestor list.\n                 AncestorList(Some(unstable::exclusive(AncestorNode {\n                     generation: new_generation,\n@@ -544,7 +544,7 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n                 DefaultScheduler => rt::new_task(),\n                 _ => new_task_in_sched(opts.sched)\n             };\n-            assert !new_task.is_null();\n+            fail_unless!(!new_task.is_null());\n             // Getting killed after here would leak the task.\n             let mut notify_chan = if opts.notify_chan.is_none() {\n                 None\n@@ -716,7 +716,7 @@ fn test_spawn_raw_notify_success() {\n     };\n     do spawn_raw(opts) {\n     }\n-    assert notify_po.recv() == Success;\n+    fail_unless!(notify_po.recv() == Success);\n }\n \n #[test]\n@@ -733,5 +733,5 @@ fn test_spawn_raw_notify_failure() {\n     do spawn_raw(opts) {\n         fail!();\n     }\n-    assert notify_po.recv() == Failure;\n+    fail_unless!(notify_po.recv() == Failure);\n }"}, {"sha": "8215152ef74e9c35bbb4e9133475ae82143d9edf", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -140,31 +140,31 @@ impl<A:ToStr> ToStr for @[A] {\n mod tests {\n     #[test]\n     fn test_simple_types() {\n-        assert 1i.to_str() == ~\"1\";\n-        assert (-1i).to_str() == ~\"-1\";\n-        assert 200u.to_str() == ~\"200\";\n-        assert 2u8.to_str() == ~\"2\";\n-        assert true.to_str() == ~\"true\";\n-        assert false.to_str() == ~\"false\";\n-        assert ().to_str() == ~\"()\";\n-        assert (~\"hi\").to_str() == ~\"hi\";\n-        assert (@\"hi\").to_str() == ~\"hi\";\n+        fail_unless!(1i.to_str() == ~\"1\");\n+        fail_unless!((-1i).to_str() == ~\"-1\");\n+        fail_unless!(200u.to_str() == ~\"200\");\n+        fail_unless!(2u8.to_str() == ~\"2\");\n+        fail_unless!(true.to_str() == ~\"true\");\n+        fail_unless!(false.to_str() == ~\"false\");\n+        fail_unless!(().to_str() == ~\"()\");\n+        fail_unless!((~\"hi\").to_str() == ~\"hi\");\n+        fail_unless!((@\"hi\").to_str() == ~\"hi\");\n     }\n \n     #[test]\n     fn test_tuple_types() {\n-        assert (1, 2).to_str() == ~\"(1, 2)\";\n-        assert (~\"a\", ~\"b\", false).to_str() == ~\"(a, b, false)\";\n-        assert ((), ((), 100)).to_str() == ~\"((), ((), 100))\";\n+        fail_unless!((1, 2).to_str() == ~\"(1, 2)\");\n+        fail_unless!((~\"a\", ~\"b\", false).to_str() == ~\"(a, b, false)\");\n+        fail_unless!(((), ((), 100)).to_str() == ~\"((), ((), 100))\");\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: ~[int] = ~[];\n-        assert x.to_str() == ~\"[]\";\n-        assert (~[1]).to_str() == ~\"[1]\";\n-        assert (~[1, 2, 3]).to_str() == ~\"[1, 2, 3]\";\n-        assert (~[~[], ~[1], ~[1, 1]]).to_str() ==\n-               ~\"[[], [1], [1, 1]]\";\n+        fail_unless!(x.to_str() == ~\"[]\");\n+        fail_unless!((~[1]).to_str() == ~\"[1]\");\n+        fail_unless!((~[1, 2, 3]).to_str() == ~\"[1, 2, 3]\");\n+        fail_unless!((~[~[], ~[1], ~[1, 1]]).to_str() ==\n+               ~\"[[], [1], [1, 1]]\");\n     }\n }"}, {"sha": "395772df57179efeff398beb802cd1f1afc183c2", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -327,7 +327,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n \n #[cfg(test)]\n pub fn check_integrity<T>(trie: &TrieNode<T>) {\n-    assert trie.count != 0;\n+    fail_unless!(trie.count != 0);\n \n     let mut sum = 0;\n \n@@ -342,7 +342,7 @@ pub fn check_integrity<T>(trie: &TrieNode<T>) {\n         }\n     }\n \n-    assert sum == trie.count;\n+    fail_unless!(sum == trie.count);\n }\n \n #[cfg(test)]\n@@ -356,32 +356,32 @@ mod tests {\n         let n = 300;\n \n         for uint::range_step(1, n, 2) |x| {\n-            assert trie.insert(x, x + 1);\n-            assert trie.contains_key(&x);\n+            fail_unless!(trie.insert(x, x + 1));\n+            fail_unless!(trie.contains_key(&x));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range_step(0, n, 2) |x| {\n-            assert !trie.contains_key(&x);\n-            assert trie.insert(x, x + 1);\n+            fail_unless!(!trie.contains_key(&x));\n+            fail_unless!(trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range(0, n) |x| {\n-            assert trie.contains_key(&x);\n-            assert !trie.insert(x, x + 1);\n+            fail_unless!(trie.contains_key(&x));\n+            fail_unless!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range_step(1, n, 2) |x| {\n-            assert trie.remove(&x);\n-            assert !trie.contains_key(&x);\n+            fail_unless!(trie.remove(&x));\n+            fail_unless!(!trie.contains_key(&x));\n             check_integrity(&trie.root);\n         }\n \n         for uint::range_step(0, n, 2) |x| {\n-            assert trie.contains_key(&x);\n-            assert !trie.insert(x, x + 1);\n+            fail_unless!(trie.contains_key(&x));\n+            fail_unless!(!trie.insert(x, x + 1));\n             check_integrity(&trie.root);\n         }\n     }\n@@ -390,16 +390,16 @@ mod tests {\n     fn test_each() {\n         let mut m = TrieMap::new();\n \n-        assert m.insert(3, 6);\n-        assert m.insert(0, 0);\n-        assert m.insert(4, 8);\n-        assert m.insert(2, 4);\n-        assert m.insert(1, 2);\n+        fail_unless!(m.insert(3, 6));\n+        fail_unless!(m.insert(0, 0));\n+        fail_unless!(m.insert(4, 8));\n+        fail_unless!(m.insert(2, 4));\n+        fail_unless!(m.insert(1, 2));\n \n         let mut n = 0;\n         for m.each |&(k, v)| {\n-            assert k == n;\n-            assert *v == n * 2;\n+            fail_unless!(k == n);\n+            fail_unless!(*v == n * 2);\n             n += 1;\n         }\n     }\n@@ -415,10 +415,10 @@ mod tests {\n         let mut n = uint::max_value - 9999;\n         for m.each |&(k, v)| {\n             if n == uint::max_value - 5000 { break }\n-            assert n < uint::max_value - 5000;\n+            fail_unless!(n < uint::max_value - 5000);\n \n-            assert k == n;\n-            assert *v == n / 2;\n+            fail_unless!(k == n);\n+            fail_unless!(*v == n / 2);\n             n += 1;\n         }\n     }\n@@ -427,16 +427,16 @@ mod tests {\n     fn test_each_reverse() {\n         let mut m = TrieMap::new();\n \n-        assert m.insert(3, 6);\n-        assert m.insert(0, 0);\n-        assert m.insert(4, 8);\n-        assert m.insert(2, 4);\n-        assert m.insert(1, 2);\n+        fail_unless!(m.insert(3, 6));\n+        fail_unless!(m.insert(0, 0));\n+        fail_unless!(m.insert(4, 8));\n+        fail_unless!(m.insert(2, 4));\n+        fail_unless!(m.insert(1, 2));\n \n         let mut n = 4;\n         for m.each_reverse |&(k, v)| {\n-            assert k == n;\n-            assert *v == n * 2;\n+            fail_unless!(k == n);\n+            fail_unless!(*v == n * 2);\n             n -= 1;\n         }\n     }\n@@ -452,10 +452,10 @@ mod tests {\n         let mut n = uint::max_value;\n         for m.each_reverse |&(k, v)| {\n             if n == uint::max_value - 5000 { break }\n-            assert n > uint::max_value - 5000;\n+            fail_unless!(n > uint::max_value - 5000);\n \n-            assert k == n;\n-            assert *v == n / 2;\n+            fail_unless!(k == n);\n+            fail_unless!(*v == n / 2);\n             n -= 1;\n         }\n     }"}, {"sha": "e41ff424012b233b18d8b72e819583b02e9103c0", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -202,15 +202,15 @@ impl<A:Ord,B:Ord,C:Ord> Ord for (A, B, C) {\n #[test]\n fn test_tuple_ref() {\n     let x = (~\"foo\", ~\"bar\");\n-    assert x.first_ref() == &~\"foo\";\n-    assert x.second_ref() == &~\"bar\";\n+    fail_unless!(x.first_ref() == &~\"foo\");\n+    fail_unless!(x.second_ref() == &~\"bar\");\n }\n \n #[test]\n #[allow(non_implicitly_copyable_typarams)]\n fn test_tuple() {\n-    assert (948, 4039.48).first() == 948;\n-    assert (34.5, ~\"foo\").second() == ~\"foo\";\n-    assert ('a', 2).swap() == (2, 'a');\n+    fail_unless!((948, 4039.48).first() == 948);\n+    fail_unless!((34.5, ~\"foo\").second() == ~\"foo\");\n+    fail_unless!(('a', 2).swap() == (2, 'a'));\n }\n "}, {"sha": "96cd732d815d5bb4c4bbd8893a1273cdb198c174", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -83,7 +83,7 @@ fn test_run_in_bare_thread() {\n     unsafe {\n         let i = 100;\n         do run_in_bare_thread {\n-            assert i == 100;\n+            fail_unless!(i == 100);\n         }\n     }\n }\n@@ -94,7 +94,7 @@ fn test_run_in_bare_thread_exchange() {\n         // Does the exchange heap work without the runtime?\n         let i = ~100;\n         do run_in_bare_thread {\n-            assert i == ~100;\n+            fail_unless!(i == ~100);\n         }\n     }\n }\n@@ -127,7 +127,7 @@ impl<T> Drop for ArcDestruct<T>{\n                 let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n                 let new_count =\n                     intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n-                assert new_count >= 0;\n+                fail_unless!(new_count >= 0);\n                 if new_count == 0 {\n                     // drop glue takes over.\n                 } else {\n@@ -167,7 +167,7 @@ pub unsafe fn get_shared_mutable_state<T:Owned>(\n {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        assert ptr.count > 0;\n+        fail_unless!(ptr.count > 0);\n         let r = cast::transmute(option::get_ref(&ptr.data));\n         cast::forget(ptr);\n         return r;\n@@ -178,7 +178,7 @@ pub unsafe fn get_shared_immutable_state<T:Owned>(\n         rc: &a/SharedMutableState<T>) -> &a/T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        assert ptr.count > 0;\n+        fail_unless!(ptr.count > 0);\n         // Cast us back into the correct region\n         let r = cast::transmute_region(option::get_ref(&ptr.data));\n         cast::forget(ptr);\n@@ -191,7 +191,7 @@ pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n-        assert new_count >= 2;\n+        fail_unless!(new_count >= 2);\n         cast::forget(ptr);\n     }\n     ArcDestruct((*rc).data)\n@@ -342,7 +342,7 @@ pub mod tests {\n         for futures.each |f| { f.recv() }\n \n         do total.with |total| {\n-            assert **total == num_tasks * count\n+            fail_unless!(**total == num_tasks * count)\n         };\n     }\n \n@@ -354,11 +354,11 @@ pub mod tests {\n         let x2 = x.clone();\n         do task::try || {\n             do x2.with |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do x.with |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n }"}, {"sha": "f878161eca19cfec838b76c4b3b9257c6aa177ab", "filename": "src/libcore/unstable/at_exit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fat_exit.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -79,7 +79,7 @@ fn test_at_exit() {\n     let i = 10;\n     do at_exit {\n         debug!(\"at_exit1\");\n-        assert i == 10;\n+        fail_unless!(i == 10);\n     }\n }\n \n@@ -89,8 +89,8 @@ fn test_at_exit_many() {\n     for uint::range(20, 100) |j| {\n         do at_exit {\n             debug!(\"at_exit2\");\n-            assert i == 10;\n-            assert j > i;\n+            fail_unless!(i == 10);\n+            fail_unless!(j > i);\n         }\n     }\n }"}, {"sha": "a2815cebc51aa39f5a1d95c305966c62a6a9d0ae", "filename": "src/libcore/unstable/exchange_alloc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fexchange_alloc.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -20,11 +20,11 @@ use intrinsic::TyDesc;\n \n pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n     unsafe {\n-        assert td.is_not_null();\n+        fail_unless!(td.is_not_null());\n \n         let total_size = get_box_size(size, (*td).align);\n         let p = c_malloc(total_size as size_t);\n-        assert p.is_not_null();\n+        fail_unless!(p.is_not_null());\n \n         // FIXME #3475: Converting between our two different tydesc types\n         let td: *TyDesc = transmute(td);\n@@ -46,7 +46,7 @@ pub unsafe fn free(ptr: *c_void) {\n     let exchange_count = &mut *rust_get_exchange_count_ptr();\n     atomic_xsub(exchange_count, 1);\n \n-    assert ptr.is_not_null();\n+    fail_unless!(ptr.is_not_null());\n     c_free(ptr);\n }\n \n@@ -60,7 +60,7 @@ fn get_box_size(body_size: uint, body_align: uint) -> uint {\n // Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n // of two.\n fn align_to(size: uint, align: uint) -> uint {\n-    assert align != 0;\n+    fail_unless!(align != 0);\n     (size + align - 1) & !(align - 1)\n }\n "}, {"sha": "b682f88b70e534bbfa7a948ac955a3986f4e1755", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -340,11 +340,11 @@ pub mod ct {\n             parse_count(s, 0, s.len()) == Parsed::new(count, next)\n         }\n \n-        assert test(\"\", CountImplied, 0);\n-        assert test(\"*\", CountIsNextParam, 1);\n-        assert test(\"*1\", CountIsNextParam, 1);\n-        assert test(\"*1$\", CountIsParam(1), 3);\n-        assert test(\"123\", CountIs(123), 3);\n+        fail_unless!(test(\"\", CountImplied, 0));\n+        fail_unless!(test(\"*\", CountIsNextParam, 1));\n+        fail_unless!(test(\"*1\", CountIsNextParam, 1));\n+        fail_unless!(test(\"*1$\", CountIsParam(1), 3));\n+        fail_unless!(test(\"123\", CountIs(123), 3));\n     }\n \n     #[test]\n@@ -355,8 +355,8 @@ pub mod ct {\n \n         fn test(s: &str, flags: &[Flag], next: uint) {\n             let f = parse_flags(s, 0, s.len());\n-            assert pack(f.val) == pack(flags);\n-            assert f.next == next;\n+            fail_unless!(pack(f.val) == pack(flags));\n+            fail_unless!(f.next == next);\n         }\n \n         test(\"\", [], 0);\n@@ -367,7 +367,7 @@ pub mod ct {\n \n     #[test]\n     fn test_parse_fmt_string() {\n-        assert parse_fmt_string(\"foo %s bar\", die) == ~[\n+        fail_unless!(parse_fmt_string(\"foo %s bar\", die) == ~[\n             PieceString(~\"foo \"),\n             PieceConv(Conv {\n                 param: None,\n@@ -376,19 +376,19 @@ pub mod ct {\n                 precision: CountImplied,\n                 ty: TyStr,\n             }),\n-            PieceString(~\" bar\")];\n+            PieceString(~\" bar\")]);\n \n-        assert parse_fmt_string(\"%s\", die) == ~[\n+        fail_unless!(parse_fmt_string(\"%s\", die) == ~[\n             PieceConv(Conv {\n                 param: None,\n                 flags: ~[],\n                 width: CountImplied,\n                 precision: CountImplied,\n                 ty: TyStr,\n-            })];\n+            })]);\n \n-        assert parse_fmt_string(\"%%%%\", die) == ~[\n-            PieceString(~\"%\"), PieceString(~\"%\")];\n+        fail_unless!(parse_fmt_string(\"%%%%\", die) == ~[\n+            PieceString(~\"%\"), PieceString(~\"%\")]);\n     }\n \n     #[test]\n@@ -397,10 +397,10 @@ pub mod ct {\n             parse_parameter(s, 0, s.len()) == Parsed::new(param, next)\n         }\n \n-        assert test(\"\", None, 0);\n-        assert test(\"foo\", None, 0);\n-        assert test(\"123\", None, 0);\n-        assert test(\"123$\", Some(123), 4);\n+        fail_unless!(test(\"\", None, 0));\n+        fail_unless!(test(\"foo\", None, 0));\n+        fail_unless!(test(\"123\", None, 0));\n+        fail_unless!(test(\"123$\", Some(123), 4));\n     }\n \n     #[test]\n@@ -409,12 +409,12 @@ pub mod ct {\n             parse_precision(s, 0, s.len()) == Parsed::new(count, next)\n         }\n \n-        assert test(\"\", CountImplied, 0);\n-        assert test(\".\", CountIs(0), 1);\n-        assert test(\".*\", CountIsNextParam, 2);\n-        assert test(\".*1\", CountIsNextParam, 2);\n-        assert test(\".*1$\", CountIsParam(1), 4);\n-        assert test(\".123\", CountIs(123), 4);\n+        fail_unless!(test(\"\", CountImplied, 0));\n+        fail_unless!(test(\".\", CountIs(0), 1));\n+        fail_unless!(test(\".*\", CountIsNextParam, 2));\n+        fail_unless!(test(\".*1\", CountIsNextParam, 2));\n+        fail_unless!(test(\".*1$\", CountIsParam(1), 4));\n+        fail_unless!(test(\".123\", CountIs(123), 4));\n     }\n \n     #[test]\n@@ -423,17 +423,17 @@ pub mod ct {\n             parse_type(s, 0, s.len(), die) == Parsed::new(ty, 1)\n         }\n \n-        assert test(\"b\", TyBool);\n-        assert test(\"c\", TyChar);\n-        assert test(\"d\", TyInt(Signed));\n-        assert test(\"f\", TyFloat);\n-        assert test(\"i\", TyInt(Signed));\n-        assert test(\"o\", TyOctal);\n-        assert test(\"s\", TyStr);\n-        assert test(\"t\", TyBits);\n-        assert test(\"x\", TyHex(CaseLower));\n-        assert test(\"X\", TyHex(CaseUpper));\n-        assert test(\"?\", TyPoly);\n+        fail_unless!(test(\"b\", TyBool));\n+        fail_unless!(test(\"c\", TyChar));\n+        fail_unless!(test(\"d\", TyInt(Signed)));\n+        fail_unless!(test(\"f\", TyFloat));\n+        fail_unless!(test(\"i\", TyInt(Signed)));\n+        fail_unless!(test(\"o\", TyOctal));\n+        fail_unless!(test(\"s\", TyStr));\n+        fail_unless!(test(\"t\", TyBits));\n+        fail_unless!(test(\"x\", TyHex(CaseLower)));\n+        fail_unless!(test(\"X\", TyHex(CaseUpper)));\n+        fail_unless!(test(\"?\", TyPoly));\n     }\n \n     #[test]\n@@ -453,16 +453,16 @@ pub mod ct {\n     #[test]\n     fn test_peek_num() {\n         let s1 = \"\";\n-        assert peek_num(s1, 0, s1.len()).is_none();\n+        fail_unless!(peek_num(s1, 0, s1.len()).is_none());\n \n         let s2 = \"foo\";\n-        assert peek_num(s2, 0, s2.len()).is_none();\n+        fail_unless!(peek_num(s2, 0, s2.len()).is_none());\n \n         let s3 = \"123\";\n-        assert peek_num(s3, 0, s3.len()) == Some(Parsed::new(123, 3));\n+        fail_unless!(peek_num(s3, 0, s3.len()) == Some(Parsed::new(123, 3)));\n \n         let s4 = \"123foo\";\n-        assert peek_num(s4, 0, s4.len()) == Some(Parsed::new(123, 3));\n+        fail_unless!(peek_num(s4, 0, s4.len()) == Some(Parsed::new(123, 3)));\n     }\n }\n "}, {"sha": "5089470e6efbe7651c3383fb921fc0ae1313981b", "filename": "src/libcore/unstable/finally.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Ffinally.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -57,11 +57,11 @@ fn test_success() {\n     do (|| {\n         i = 10;\n     }).finally {\n-        assert !failing();\n-        assert i == 10;\n+        fail_unless!(!failing());\n+        fail_unless!(i == 10);\n         i = 20;\n     }\n-    assert i == 20;\n+    fail_unless!(i == 20);\n }\n \n #[test]\n@@ -73,16 +73,16 @@ fn test_fail() {\n         i = 10;\n         fail!();\n     }).finally {\n-        assert failing();\n-        assert i == 10;\n+        fail_unless!(failing());\n+        fail_unless!(i == 10);\n     }\n }\n \n #[test]\n fn test_retval() {\n     let closure: &fn() -> int = || 10;\n     let i = do closure.finally { };\n-    assert i == 10;\n+    fail_unless!(i == 10);\n }\n \n #[test]"}, {"sha": "654bf18a5b6b9ffbf232a0a5a318ccf398df523b", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -187,7 +187,7 @@ fn get_global_state() -> Exclusive<GlobalState> {\n         let prev_i = unsafe { atomic_cxchg(&mut *global_ptr, 0, state_i) };\n \n         // Sanity check that we're not trying to reinitialize after shutdown\n-        assert prev_i != POISON;\n+        fail_unless!(prev_i != POISON);\n \n         if prev_i == 0 {\n             // Successfully installed the global pointer\n@@ -201,7 +201,7 @@ fn get_global_state() -> Exclusive<GlobalState> {\n                 let prev_i = unsafe {\n                     atomic_cxchg(&mut *global_ptr, state_i, POISON)\n                 };\n-                assert prev_i == state_i;\n+                fail_unless!(prev_i == state_i);\n \n                 // Capture the global state object in the at_exit closure\n                 // so that it is destroyed at the right time\n@@ -245,7 +245,7 @@ fn test_clone_rc() {\n                     ~shared_mutable_state(10)\n                 };\n \n-                assert get_shared_immutable_state(&val) == &10;\n+                fail_unless!(get_shared_immutable_state(&val) == &10);\n             }\n         }\n     }\n@@ -273,7 +273,7 @@ fn test_modify() {\n             match v {\n                 Some(sms) => {\n                     let v = get_shared_immutable_state(sms);\n-                    assert *v == 10;\n+                    fail_unless!(*v == 10);\n                     None\n                 },\n                 _ => fail!()"}, {"sha": "7e9742fecbba461a4894b7acf764c9ceeaa0917b", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -40,7 +40,7 @@ pub unsafe fn weaken_task(f: &fn(Port<ShutdownMsg>)) {\n     let shutdown_port = Cell(shutdown_port);\n     let task = get_task_id();\n     // Expect the weak task service to be alive\n-    assert service.try_send(RegisterWeakTask(task, shutdown_chan));\n+    fail_unless!(service.try_send(RegisterWeakTask(task, shutdown_chan)));\n     unsafe { rust_dec_kernel_live_count(); }\n     do (|| {\n         f(shutdown_port.take())\n@@ -102,7 +102,7 @@ fn run_weak_task_service(port: Port<ServiceMsg>) {\n             RegisterWeakTask(task, shutdown_chan) => {\n                 let previously_unregistered =\n                     shutdown_map.insert(task, shutdown_chan);\n-                assert previously_unregistered;\n+                fail_unless!(previously_unregistered);\n             }\n             UnregisterWeakTask(task) => {\n                 match shutdown_map.pop(&task) {"}, {"sha": "214a9dea8d18c12ebf2210484259776b32ab606f", "filename": "src/libcore/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -82,7 +82,7 @@ terminate normally, but instead directly return from a function.\n \n ~~~\n fn choose_weighted_item(v: &[Item]) -> Item {\n-    assert !v.is_empty();\n+    fail_unless!(!v.is_empty());\n     let mut so_far = 0u;\n     for v.each |item| {\n         so_far += item.weight;\n@@ -110,23 +110,23 @@ mod tests {\n     pub fn identity_crisis() {\n         // Writing a test for the identity function. How did it come to this?\n         let x = ~[(5, false)];\n-        //FIXME #3387 assert x.eq(id(copy x));\n+        //FIXME #3387 fail_unless!(x.eq(id(copy x)));\n         let y = copy x;\n-        assert x.eq(&id(y));\n+        fail_unless!(x.eq(&id(y)));\n     }\n     #[test]\n     pub fn test_swap() {\n         let mut x = 31337;\n         let mut y = 42;\n         swap(&mut x, &mut y);\n-        assert x == 42;\n-        assert y == 31337;\n+        fail_unless!(x == 42);\n+        fail_unless!(y == 31337);\n     }\n     #[test]\n     pub fn test_replace() {\n         let mut x = Some(NonCopyable());\n         let y = replace(&mut x, None);\n-        assert x.is_none();\n-        assert y.is_some();\n+        fail_unless!(x.is_none());\n+        fail_unless!(y.is_some());\n     }\n }"}, {"sha": "1a8a2518ab0841be6dc40ad283393ef65fa0ba40", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 358, "deletions": 358, "changes": 716, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -257,8 +257,8 @@ pub pure fn last_opt<T>(v: &r/[T]) -> Option<&r/T> {\n /// Return a slice that points into another slice.\n #[inline(always)]\n pub pure fn slice<T>(v: &r/[T], start: uint, end: uint) -> &r/[T] {\n-    assert (start <= end);\n-    assert (end <= len(v));\n+    fail_unless!((start <= end));\n+    fail_unless!((end <= len(v)));\n     do as_imm_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -274,8 +274,8 @@ pub pure fn mut_slice<T>(v: &r/mut [T],\n                          start: uint,\n                          end: uint)\n                       -> &r/mut [T] {\n-    assert (start <= end);\n-    assert (end <= len(v));\n+    fail_unless!((start <= end));\n+    fail_unless!((end <= len(v)));\n     do as_mut_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -291,8 +291,8 @@ pub pure fn const_slice<T>(v: &r/[const T],\n                            start: uint,\n                            end: uint)\n                         -> &r/[const T] {\n-    assert (start <= end);\n-    assert (end <= len(v));\n+    fail_unless!((start <= end));\n+    fail_unless!((end <= len(v)));\n     do as_const_buf(v) |p, _len| {\n         unsafe {\n             ::cast::reinterpret_cast(\n@@ -448,7 +448,7 @@ pub pure fn partitioned<T:Copy>(v: &[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n /// Removes the first element from a vector and return it\n pub fn shift<T>(v: &mut ~[T]) -> T {\n     unsafe {\n-        assert !v.is_empty();\n+        fail_unless!(!v.is_empty());\n \n         if v.len() == 1 { return v.pop() }\n \n@@ -465,7 +465,7 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         // Save the last element. We're going to overwrite its position\n         let mut work_elt = v.pop();\n         // We still should have room to work where what last element was\n-        assert capacity(v) >= ln;\n+        fail_unless!(capacity(v) >= ln);\n         // Pretend like we have the original length so we can use\n         // the vector copy_memory to overwrite the hole we just made\n         raw::set_len(&mut *v, ln);\n@@ -511,7 +511,7 @@ pub fn unshift<T>(v: &mut ~[T], x: T) {\n /// elements after position i one position to the right.\n pub fn insert<T>(v: &mut ~[T], i: uint, x: T) {\n     let len = v.len();\n-    assert i <= len;\n+    fail_unless!(i <= len);\n \n     v.push(x);\n     let mut j = len;\n@@ -525,7 +525,7 @@ pub fn insert<T>(v: &mut ~[T], i: uint, x: T) {\n /// all elements after position i one position to the left.\n pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n     let len = v.len();\n-    assert i < len;\n+    fail_unless!(i < len);\n \n     let mut j = i;\n     while j < len - 1 {\n@@ -650,7 +650,7 @@ pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n /// Shorten a vector, dropping excess elements.\n pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n     do as_mut_buf(*v) |p, oldlen| {\n-        assert(newlen <= oldlen);\n+        fail_unless!((newlen <= oldlen));\n         unsafe {\n             // This loop is optimized out for non-drop types.\n             for uint::range(newlen, oldlen) |i| {\n@@ -1148,8 +1148,8 @@ pub pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n  */\n pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n                             f: fn(t: &T) -> bool) -> Option<uint> {\n-    assert start <= end;\n-    assert end <= len(v);\n+    fail_unless!(start <= end);\n+    fail_unless!(end <= len(v));\n     let mut i = start;\n     while i < end { if f(&v[i]) { return Some::<uint>(i); } i += 1u; }\n     return None;\n@@ -1181,8 +1181,8 @@ pub pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n  */\n pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n                              f: fn(t: &T) -> bool) -> Option<uint> {\n-    assert start <= end;\n-    assert end <= len(v);\n+    fail_unless!(start <= end);\n+    fail_unless!(end <= len(v));\n     let mut i = end;\n     while i > start {\n         if f(&v[i - 1u]) { return Some::<uint>(i - 1u); }\n@@ -1238,7 +1238,7 @@ pub pure fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n     let mut zipped = ~[];\n     let sz = len(v);\n     let mut i = 0u;\n-    assert sz == len(u);\n+    fail_unless!(sz == len(u));\n     while i < sz {\n         unsafe { zipped.push((v[i], u[i])); i += 1u; }\n     }\n@@ -1253,7 +1253,7 @@ pub pure fn zip_slice<T:Copy,U:Copy>(v: &[const T], u: &[const U])\n  */\n pub pure fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n     let mut i = len(v);\n-    assert i == len(u);\n+    fail_unless!(i == len(u));\n     let mut w = with_capacity(i);\n     while i > 0 {\n         unsafe { w.push((v.pop(),u.pop())); }\n@@ -1432,7 +1432,7 @@ pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n  */\n #[inline]\n pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n-    assert len(v1) == len(v2);\n+    fail_unless!(len(v1) == len(v2));\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n             return;\n@@ -1476,7 +1476,7 @@ pub pure fn each_permutation<T:Copy>(v: &[T], put: fn(ts: &[T]) -> bool) {\n \n pub pure fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n-    assert 1u <= nn;\n+    fail_unless!(1u <= nn);\n     for vec::eachi (xx) |ii, _x| {\n         let len = vec::len(xx);\n         if ii+nn <= len {\n@@ -2195,8 +2195,8 @@ pub mod raw {\n     #[inline(always)]\n     pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[const T],\n                                  count: uint) {\n-        assert dst.len() >= count;\n-        assert src.len() >= count;\n+        fail_unless!(dst.len() >= count);\n+        fail_unless!(src.len() >= count);\n \n         do as_mut_buf(dst) |p_dst, _len_dst| {\n             do as_const_buf(src) |p_src, _len_src| {\n@@ -2522,65 +2522,65 @@ mod tests {\n             let a = ~[1, 2, 3];\n             let mut ptr = raw::to_ptr(a);\n             let b = from_buf(ptr, 3u);\n-            assert (len(b) == 3u);\n-            assert (b[0] == 1);\n-            assert (b[1] == 2);\n-            assert (b[2] == 3);\n+            fail_unless!((len(b) == 3u));\n+            fail_unless!((b[0] == 1));\n+            fail_unless!((b[1] == 2));\n+            fail_unless!((b[2] == 3));\n \n             // Test on-heap copy-from-buf.\n             let c = ~[1, 2, 3, 4, 5];\n             ptr = raw::to_ptr(c);\n             let d = from_buf(ptr, 5u);\n-            assert (len(d) == 5u);\n-            assert (d[0] == 1);\n-            assert (d[1] == 2);\n-            assert (d[2] == 3);\n-            assert (d[3] == 4);\n-            assert (d[4] == 5);\n+            fail_unless!((len(d) == 5u));\n+            fail_unless!((d[0] == 1));\n+            fail_unless!((d[1] == 2));\n+            fail_unless!((d[2] == 3));\n+            fail_unless!((d[3] == 4));\n+            fail_unless!((d[4] == 5));\n         }\n     }\n \n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n         let mut v = from_fn(3u, square);\n-        assert (len(v) == 3u);\n-        assert (v[0] == 0u);\n-        assert (v[1] == 1u);\n-        assert (v[2] == 4u);\n+        fail_unless!((len(v) == 3u));\n+        fail_unless!((v[0] == 0u));\n+        fail_unless!((v[1] == 1u));\n+        fail_unless!((v[2] == 4u));\n \n         // Test on-heap from_fn.\n         v = from_fn(5u, square);\n-        assert (len(v) == 5u);\n-        assert (v[0] == 0u);\n-        assert (v[1] == 1u);\n-        assert (v[2] == 4u);\n-        assert (v[3] == 9u);\n-        assert (v[4] == 16u);\n+        fail_unless!((len(v) == 5u));\n+        fail_unless!((v[0] == 0u));\n+        fail_unless!((v[1] == 1u));\n+        fail_unless!((v[2] == 4u));\n+        fail_unless!((v[3] == 9u));\n+        fail_unless!((v[4] == 16u));\n     }\n \n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n         let mut v = from_elem(2u, 10u);\n-        assert (len(v) == 2u);\n-        assert (v[0] == 10u);\n-        assert (v[1] == 10u);\n+        fail_unless!((len(v) == 2u));\n+        fail_unless!((v[0] == 10u));\n+        fail_unless!((v[1] == 10u));\n \n         // Test on-heap from_elem.\n         v = from_elem(6u, 20u);\n-        assert (v[0] == 20u);\n-        assert (v[1] == 20u);\n-        assert (v[2] == 20u);\n-        assert (v[3] == 20u);\n-        assert (v[4] == 20u);\n-        assert (v[5] == 20u);\n+        fail_unless!((v[0] == 20u));\n+        fail_unless!((v[1] == 20u));\n+        fail_unless!((v[2] == 20u));\n+        fail_unless!((v[3] == 20u));\n+        fail_unless!((v[4] == 20u));\n+        fail_unless!((v[5] == 20u));\n     }\n \n     #[test]\n     fn test_is_empty() {\n-        assert (is_empty::<int>(~[]));\n-        assert (!is_empty(~[0]));\n+        fail_unless!((is_empty::<int>(~[])));\n+        fail_unless!((!is_empty(~[0])));\n     }\n \n     #[test]\n@@ -2589,18 +2589,18 @@ mod tests {\n         let v0 : &[Z] = &[];\n         let v1 : &[Z] = &[[]];\n         let v2 : &[Z] = &[[], []];\n-        assert(sys::size_of::<Z>() == 0);\n-        assert(len(v0) == 0);\n-        assert(len(v1) == 1);\n-        assert(len(v2) == 2);\n+        fail_unless!((sys::size_of::<Z>() == 0));\n+        fail_unless!((len(v0) == 0));\n+        fail_unless!((len(v1) == 1));\n+        fail_unless!((len(v2) == 2));\n     }\n \n     #[test]\n     fn test_head() {\n         let mut a = ~[11];\n-        assert a.head() == &11;\n+        fail_unless!(a.head() == &11);\n         a = ~[11, 12];\n-        assert a.head() == &11;\n+        fail_unless!(a.head() == &11);\n     }\n \n     #[test]\n@@ -2614,19 +2614,19 @@ mod tests {\n     #[test]\n     fn test_head_opt() {\n         let mut a = ~[];\n-        assert a.head_opt() == None;\n+        fail_unless!(a.head_opt() == None);\n         a = ~[11];\n-        assert a.head_opt().unwrap() == &11;\n+        fail_unless!(a.head_opt().unwrap() == &11);\n         a = ~[11, 12];\n-        assert a.head_opt().unwrap() == &11;\n+        fail_unless!(a.head_opt().unwrap() == &11);\n     }\n \n     #[test]\n     fn test_tail() {\n         let mut a = ~[11];\n-        assert a.tail() == &[];\n+        fail_unless!(a.tail() == &[]);\n         a = ~[11, 12];\n-        assert a.tail() == &[12];\n+        fail_unless!(a.tail() == &[12]);\n     }\n \n     #[test]\n@@ -2640,9 +2640,9 @@ mod tests {\n     #[test]\n     fn test_tailn() {\n         let mut a = ~[11, 12, 13];\n-        assert a.tailn(0) == &[11, 12, 13];\n+        fail_unless!(a.tailn(0) == &[11, 12, 13]);\n         a = ~[11, 12, 13];\n-        assert a.tailn(2) == &[13];\n+        fail_unless!(a.tailn(2) == &[13]);\n     }\n \n     #[test]\n@@ -2656,9 +2656,9 @@ mod tests {\n     #[test]\n     fn test_init() {\n         let mut a = ~[11];\n-        assert a.init() == &[];\n+        fail_unless!(a.init() == &[]);\n         a = ~[11, 12];\n-        assert a.init() == &[11];\n+        fail_unless!(a.init() == &[11]);\n     }\n \n     #[init]\n@@ -2672,9 +2672,9 @@ mod tests {\n     #[test]\n     fn test_initn() {\n         let mut a = ~[11, 12, 13];\n-        assert a.initn(0) == &[11, 12, 13];\n+        fail_unless!(a.initn(0) == &[11, 12, 13]);\n         a = ~[11, 12, 13];\n-        assert a.initn(2) == &[11];\n+        fail_unless!(a.initn(2) == &[11]);\n     }\n \n     #[init]\n@@ -2688,9 +2688,9 @@ mod tests {\n     #[test]\n     fn test_last() {\n         let mut a = ~[11];\n-        assert a.last() == &11;\n+        fail_unless!(a.last() == &11);\n         a = ~[11, 12];\n-        assert a.last() == &12;\n+        fail_unless!(a.last() == &12);\n     }\n \n     #[test]\n@@ -2703,75 +2703,75 @@ mod tests {\n     #[test]\n     fn test_last_opt() {\n         let mut a = ~[];\n-        assert a.last_opt() == None;\n+        fail_unless!(a.last_opt() == None);\n         a = ~[11];\n-        assert a.last_opt().unwrap() == &11;\n+        fail_unless!(a.last_opt().unwrap() == &11);\n         a = ~[11, 12];\n-        assert a.last_opt().unwrap() == &12;\n+        fail_unless!(a.last_opt().unwrap() == &12);\n     }\n \n     #[test]\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1, 2, 3, 4];\n         let v_a = slice(vec_fixed, 1u, len(vec_fixed)).to_vec();\n-        assert (len(v_a) == 3u);\n-        assert (v_a[0] == 2);\n-        assert (v_a[1] == 3);\n-        assert (v_a[2] == 4);\n+        fail_unless!((len(v_a) == 3u));\n+        fail_unless!((v_a[0] == 2));\n+        fail_unless!((v_a[1] == 3));\n+        fail_unless!((v_a[2] == 4));\n \n         // Test on stack.\n         let vec_stack = &[1, 2, 3];\n         let v_b = slice(vec_stack, 1u, 3u).to_vec();\n-        assert (len(v_b) == 2u);\n-        assert (v_b[0] == 2);\n-        assert (v_b[1] == 3);\n+        fail_unless!((len(v_b) == 2u));\n+        fail_unless!((v_b[0] == 2));\n+        fail_unless!((v_b[1] == 3));\n \n         // Test on managed heap.\n         let vec_managed = @[1, 2, 3, 4, 5];\n         let v_c = slice(vec_managed, 0u, 3u).to_vec();\n-        assert (len(v_c) == 3u);\n-        assert (v_c[0] == 1);\n-        assert (v_c[1] == 2);\n-        assert (v_c[2] == 3);\n+        fail_unless!((len(v_c) == 3u));\n+        fail_unless!((v_c[0] == 1));\n+        fail_unless!((v_c[1] == 2));\n+        fail_unless!((v_c[2] == 3));\n \n         // Test on exchange heap.\n         let vec_unique = ~[1, 2, 3, 4, 5, 6];\n         let v_d = slice(vec_unique, 1u, 6u).to_vec();\n-        assert (len(v_d) == 5u);\n-        assert (v_d[0] == 2);\n-        assert (v_d[1] == 3);\n-        assert (v_d[2] == 4);\n-        assert (v_d[3] == 5);\n-        assert (v_d[4] == 6);\n+        fail_unless!((len(v_d) == 5u));\n+        fail_unless!((v_d[0] == 2));\n+        fail_unless!((v_d[1] == 3));\n+        fail_unless!((v_d[2] == 4));\n+        fail_unless!((v_d[3] == 5));\n+        fail_unless!((v_d[4] == 6));\n     }\n \n     #[test]\n     fn test_pop() {\n         // Test on-heap pop.\n         let mut v = ~[1, 2, 3, 4, 5];\n         let e = v.pop();\n-        assert (len(v) == 4u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 2);\n-        assert (v[2] == 3);\n-        assert (v[3] == 4);\n-        assert (e == 5);\n+        fail_unless!((len(v) == 4u));\n+        fail_unless!((v[0] == 1));\n+        fail_unless!((v[1] == 2));\n+        fail_unless!((v[2] == 3));\n+        fail_unless!((v[3] == 4));\n+        fail_unless!((e == 5));\n     }\n \n     #[test]\n     fn test_swap_remove() {\n         let mut v = ~[1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n-        assert (len(v) == 4);\n-        assert e == 1;\n-        assert (v[0] == 5);\n+        fail_unless!((len(v) == 4));\n+        fail_unless!(e == 1);\n+        fail_unless!((v[0] == 5));\n         e = v.swap_remove(3);\n-        assert (len(v) == 3);\n-        assert e == 4;\n-        assert (v[0] == 5);\n-        assert (v[1] == 2);\n-        assert (v[2] == 3);\n+        fail_unless!((len(v) == 3));\n+        fail_unless!(e == 4);\n+        fail_unless!((v[0] == 5));\n+        fail_unless!((v[1] == 2));\n+        fail_unless!((v[2] == 3));\n     }\n \n     #[test]\n@@ -2780,83 +2780,83 @@ mod tests {\n         let mut v = ~[::unstable::exclusive(()), ::unstable::exclusive(()),\n                       ::unstable::exclusive(())];\n         let mut _e = v.swap_remove(0);\n-        assert (len(v) == 2);\n+        fail_unless!((len(v) == 2));\n         _e = v.swap_remove(1);\n-        assert (len(v) == 1);\n+        fail_unless!((len(v) == 1));\n         _e = v.swap_remove(0);\n-        assert (len(v) == 0);\n+        fail_unless!((len(v) == 0));\n     }\n \n     #[test]\n     fn test_push() {\n         // Test on-stack push().\n         let mut v = ~[];\n         v.push(1);\n-        assert (len(v) == 1u);\n-        assert (v[0] == 1);\n+        fail_unless!((len(v) == 1u));\n+        fail_unless!((v[0] == 1));\n \n         // Test on-heap push().\n         v.push(2);\n-        assert (len(v) == 2u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 2);\n+        fail_unless!((len(v) == 2u));\n+        fail_unless!((v[0] == 1));\n+        fail_unless!((v[1] == 2));\n     }\n \n     #[test]\n     fn test_grow() {\n         // Test on-stack grow().\n         let mut v = ~[];\n         v.grow(2u, &1);\n-        assert (len(v) == 2u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 1);\n+        fail_unless!((len(v) == 2u));\n+        fail_unless!((v[0] == 1));\n+        fail_unless!((v[1] == 1));\n \n         // Test on-heap grow().\n         v.grow(3u, &2);\n-        assert (len(v) == 5u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 1);\n-        assert (v[2] == 2);\n-        assert (v[3] == 2);\n-        assert (v[4] == 2);\n+        fail_unless!((len(v) == 5u));\n+        fail_unless!((v[0] == 1));\n+        fail_unless!((v[1] == 1));\n+        fail_unless!((v[2] == 2));\n+        fail_unless!((v[3] == 2));\n+        fail_unless!((v[4] == 2));\n     }\n \n     #[test]\n     fn test_grow_fn() {\n         let mut v = ~[];\n         v.grow_fn(3u, square);\n-        assert (len(v) == 3u);\n-        assert (v[0] == 0u);\n-        assert (v[1] == 1u);\n-        assert (v[2] == 4u);\n+        fail_unless!((len(v) == 3u));\n+        fail_unless!((v[0] == 0u));\n+        fail_unless!((v[1] == 1u));\n+        fail_unless!((v[2] == 4u));\n     }\n \n     #[test]\n     fn test_grow_set() {\n         let mut v = ~[1, 2, 3];\n         v.grow_set(4u, &4, 5);\n-        assert (len(v) == 5u);\n-        assert (v[0] == 1);\n-        assert (v[1] == 2);\n-        assert (v[2] == 3);\n-        assert (v[3] == 4);\n-        assert (v[4] == 5);\n+        fail_unless!((len(v) == 5u));\n+        fail_unless!((v[0] == 1));\n+        fail_unless!((v[1] == 2));\n+        fail_unless!((v[2] == 3));\n+        fail_unless!((v[3] == 4));\n+        fail_unless!((v[4] == 5));\n     }\n \n     #[test]\n     fn test_truncate() {\n         let mut v = ~[@6,@5,@4];\n         v.truncate(1);\n-        assert(v.len() == 1);\n-        assert(*(v[0]) == 6);\n+        fail_unless!((v.len() == 1));\n+        fail_unless!((*(v[0]) == 6));\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut v = ~[@6,@5,@4];\n         v.clear();\n-        assert(v.len() == 0);\n+        fail_unless!((v.len() == 0));\n         // If the unsafe block didn't drop things properly, we blow up here.\n     }\n \n@@ -2865,7 +2865,7 @@ mod tests {\n         fn case(a: ~[uint], b: ~[uint]) {\n             let mut v = a;\n             v.dedup();\n-            assert(v == b);\n+            fail_unless!((v == b));\n         }\n         case(~[], ~[]);\n         case(~[1], ~[1]);\n@@ -2910,20 +2910,20 @@ mod tests {\n         // Test on-stack map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = map(v, square_ref);\n-        assert (len(w) == 3u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 4u);\n-        assert (w[2] == 9u);\n+        fail_unless!((len(w) == 3u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 4u));\n+        fail_unless!((w[2] == 9u));\n \n         // Test on-heap map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = map(v, square_ref);\n-        assert (len(w) == 5u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 4u);\n-        assert (w[2] == 9u);\n-        assert (w[3] == 16u);\n-        assert (w[4] == 25u);\n+        fail_unless!((len(w) == 5u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 4u));\n+        fail_unless!((w[2] == 9u));\n+        fail_unless!((w[3] == 16u));\n+        fail_unless!((w[4] == 25u));\n     }\n \n     #[test]\n@@ -2934,25 +2934,25 @@ mod tests {\n         let v1 = ~[5, 4, 3, 2, 1];\n         let u = map2::<int, int, int>(v0, v1, f);\n         let mut i = 0;\n-        while i < 5 { assert (v0[i] * v1[i] == u[i]); i += 1; }\n+        while i < 5 { fail_unless!((v0[i] * v1[i] == u[i])); i += 1; }\n     }\n \n     #[test]\n     fn test_filter_mapped() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = filter_mapped(v, square_if_odd_r);\n-        assert (len(w) == 2u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 9u);\n+        fail_unless!((len(w) == 2u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 9u));\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = filter_mapped(v, square_if_odd_r);\n-        assert (len(w) == 3u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 9u);\n-        assert (w[2] == 25u);\n+        fail_unless!((len(w) == 3u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 9u));\n+        fail_unless!((w[2] == 25u));\n \n         fn halve(i: &int) -> Option<int> {\n             if *i % 2 == 0 {\n@@ -2967,29 +2967,29 @@ mod tests {\n         let all_odd2: ~[int] = ~[];\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert (filter_mapped(all_even, halve) ==\n-                map(all_even, halve_for_sure));\n-        assert (filter_mapped(all_odd1, halve) == ~[]);\n-        assert (filter_mapped(all_odd2, halve) == ~[]);\n-        assert (filter_mapped(mix, halve) == mix_dest);\n+        fail_unless!(filter_mapped(all_even, halve) ==\n+                     map(all_even, halve_for_sure));\n+        fail_unless!((filter_mapped(all_odd1, halve) == ~[]));\n+        fail_unless!((filter_mapped(all_odd2, halve) == ~[]));\n+        fail_unless!((filter_mapped(mix, halve) == mix_dest));\n     }\n \n     #[test]\n     fn test_filter_map() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n         let mut w = filter_map(v, square_if_odd_v);\n-        assert (len(w) == 2u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 9u);\n+        fail_unless!((len(w) == 2u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 9u));\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         w = filter_map(v, square_if_odd_v);\n-        assert (len(w) == 3u);\n-        assert (w[0] == 1u);\n-        assert (w[1] == 9u);\n-        assert (w[2] == 25u);\n+        fail_unless!((len(w) == 3u));\n+        fail_unless!((w[0] == 1u));\n+        fail_unless!((w[1] == 9u));\n+        fail_unless!((w[2] == 25u));\n \n         fn halve(i: int) -> Option<int> {\n             if i % 2 == 0 {\n@@ -3005,37 +3005,37 @@ mod tests {\n         let all_odd2: ~[int] = ~[];\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert (filter_map(all_even, halve) ==\n-                map(all_even0, halve_for_sure));\n-        assert (filter_map(all_odd1, halve) == ~[]);\n-        assert (filter_map(all_odd2, halve) == ~[]);\n-        assert (filter_map(mix, halve) == mix_dest);\n+        fail_unless!(filter_map(all_even, halve) ==\n+                     map(all_even0, halve_for_sure));\n+        fail_unless!((filter_map(all_odd1, halve) == ~[]));\n+        fail_unless!((filter_map(all_odd2, halve) == ~[]));\n+        fail_unless!((filter_map(mix, halve) == mix_dest));\n     }\n \n     #[test]\n     fn test_filter() {\n-        assert filter(~[1u, 2u, 3u], is_odd) == ~[1u, 3u];\n-        assert filter(~[1u, 2u, 4u, 8u, 16u], is_three) == ~[];\n+        fail_unless!(filter(~[1u, 2u, 3u], is_odd) == ~[1u, 3u]);\n+        fail_unless!(filter(~[1u, 2u, 4u, 8u, 16u], is_three) == ~[]);\n     }\n \n     #[test]\n     fn test_retain() {\n         let mut v = ~[1, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        assert v == ~[1, 3, 5];\n+        fail_unless!(v == ~[1, 3, 5]);\n     }\n \n     #[test]\n     fn test_foldl() {\n         // Test on-stack fold.\n         let mut v = ~[1u, 2u, 3u];\n         let mut sum = foldl(0u, v, add);\n-        assert (sum == 6u);\n+        fail_unless!((sum == 6u));\n \n         // Test on-heap fold.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n         sum = foldl(0u, v, add);\n-        assert (sum == 15u);\n+        fail_unless!((sum == 15u));\n     }\n \n     #[test]\n@@ -3045,7 +3045,7 @@ mod tests {\n         }\n         let mut v = ~[1, 2, 3, 4];\n         let sum = foldl(0, v, sub);\n-        assert sum == -10;\n+        fail_unless!(sum == -10);\n     }\n \n     #[test]\n@@ -3055,7 +3055,7 @@ mod tests {\n         }\n         let mut v = ~[1, 2, 3, 4];\n         let sum = foldr(v, 0, sub);\n-        assert sum == -2;\n+        fail_unless!(sum == -2);\n     }\n \n     #[test]\n@@ -3071,18 +3071,18 @@ mod tests {\n         for each(~[1, 2, 3]) |v| {\n             i += *v;\n         }\n-        assert i == 6;\n+        fail_unless!(i == 6);\n     }\n \n     #[test]\n     fn test_iteri() {\n         let mut i = 0;\n         for eachi(~[1, 2, 3]) |j, v| {\n-            if i == 0 { assert *v == 1; }\n-            assert j + 1u == *v as uint;\n+            if i == 0 { fail_unless!(*v == 1); }\n+            fail_unless!(j + 1u == *v as uint);\n             i += *v;\n         }\n-        assert i == 6;\n+        fail_unless!(i == 6);\n     }\n \n     #[test]\n@@ -3096,21 +3096,21 @@ mod tests {\n     fn test_reach_nonempty() {\n         let mut i = 0;\n         for rev_each(~[1, 2, 3]) |v| {\n-            if i == 0 { assert *v == 3; }\n+            if i == 0 { fail_unless!(*v == 3); }\n             i += *v\n         }\n-        assert i == 6;\n+        fail_unless!(i == 6);\n     }\n \n     #[test]\n     fn test_reachi() {\n         let mut i = 0;\n         for rev_eachi(~[0, 1, 2]) |j, v| {\n-            if i == 0 { assert *v == 2; }\n-            assert j == *v as uint;\n+            if i == 0 { fail_unless!(*v == 2); }\n+            fail_unless!(j == *v as uint);\n             i += *v;\n         }\n-        assert i == 3;\n+        fail_unless!(i == 3);\n     }\n \n     #[test]\n@@ -3119,47 +3119,47 @@ mod tests {\n \n         results = ~[];\n         for each_permutation(~[]) |v| { results.push(from_slice(v)); }\n-        assert results == ~[~[]];\n+        fail_unless!(results == ~[~[]]);\n \n         results = ~[];\n         for each_permutation(~[7]) |v| { results.push(from_slice(v)); }\n-        assert results == ~[~[7]];\n+        fail_unless!(results == ~[~[7]]);\n \n         results = ~[];\n         for each_permutation(~[1,1]) |v| { results.push(from_slice(v)); }\n-        assert results == ~[~[1,1],~[1,1]];\n+        fail_unless!(results == ~[~[1,1],~[1,1]]);\n \n         results = ~[];\n         for each_permutation(~[5,2,0]) |v| { results.push(from_slice(v)); }\n-        assert results ==\n-            ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]];\n+        fail_unless!(results ==\n+            ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }\n \n     #[test]\n     fn test_any_and_all() {\n-        assert (any(~[1u, 2u, 3u], is_three));\n-        assert (!any(~[0u, 1u, 2u], is_three));\n-        assert (any(~[1u, 2u, 3u, 4u, 5u], is_three));\n-        assert (!any(~[1u, 2u, 4u, 5u, 6u], is_three));\n+        fail_unless!((any(~[1u, 2u, 3u], is_three)));\n+        fail_unless!((!any(~[0u, 1u, 2u], is_three)));\n+        fail_unless!((any(~[1u, 2u, 3u, 4u, 5u], is_three)));\n+        fail_unless!((!any(~[1u, 2u, 4u, 5u, 6u], is_three)));\n \n-        assert (all(~[3u, 3u, 3u], is_three));\n-        assert (!all(~[3u, 3u, 2u], is_three));\n-        assert (all(~[3u, 3u, 3u, 3u, 3u], is_three));\n-        assert (!all(~[3u, 3u, 0u, 1u, 2u], is_three));\n+        fail_unless!((all(~[3u, 3u, 3u], is_three)));\n+        fail_unless!((!all(~[3u, 3u, 2u], is_three)));\n+        fail_unless!((all(~[3u, 3u, 3u, 3u, 3u], is_three)));\n+        fail_unless!((!all(~[3u, 3u, 0u, 1u, 2u], is_three)));\n     }\n \n     #[test]\n     fn test_any2_and_all2() {\n \n-        assert (any2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n-        assert (any2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n-        assert (!any2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n-        assert (any2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n+        fail_unless!((any2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal)));\n+        fail_unless!((any2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal)));\n+        fail_unless!((!any2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal)));\n+        fail_unless!((any2(~[2u, 4u, 6u], ~[2u, 4u], is_equal)));\n \n-        assert (all2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal));\n-        assert (!all2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal));\n-        assert (!all2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal));\n-        assert (!all2(~[2u, 4u, 6u], ~[2u, 4u], is_equal));\n+        fail_unless!((all2(~[2u, 4u, 6u], ~[2u, 4u, 6u], is_equal)));\n+        fail_unless!((!all2(~[1u, 2u, 3u], ~[4u, 5u, 3u], is_equal)));\n+        fail_unless!((!all2(~[1u, 2u, 3u], ~[4u, 5u, 6u], is_equal)));\n+        fail_unless!((!all2(~[2u, 4u, 6u], ~[2u, 4u], is_equal)));\n     }\n \n     #[test]\n@@ -3169,301 +3169,301 @@ mod tests {\n \n         let z1 = zip(v1, v2);\n \n-        assert ((1, 4) == z1[0]);\n-        assert ((2, 5) == z1[1]);\n-        assert ((3, 6) == z1[2]);\n+        fail_unless!(((1, 4) == z1[0]));\n+        fail_unless!(((2, 5) == z1[1]));\n+        fail_unless!(((3, 6) == z1[2]));\n \n         let (left, right) = unzip(z1);\n \n-        assert ((1, 4) == (left[0], right[0]));\n-        assert ((2, 5) == (left[1], right[1]));\n-        assert ((3, 6) == (left[2], right[2]));\n+        fail_unless!(((1, 4) == (left[0], right[0])));\n+        fail_unless!(((2, 5) == (left[1], right[1])));\n+        fail_unless!(((3, 6) == (left[2], right[2])));\n     }\n \n     #[test]\n     fn test_position_elem() {\n-        assert position_elem(~[], &1).is_none();\n+        fail_unless!(position_elem(~[], &1).is_none());\n \n         let v1 = ~[1, 2, 3, 3, 2, 5];\n-        assert position_elem(v1, &1) == Some(0u);\n-        assert position_elem(v1, &2) == Some(1u);\n-        assert position_elem(v1, &5) == Some(5u);\n-        assert position_elem(v1, &4).is_none();\n+        fail_unless!(position_elem(v1, &1) == Some(0u));\n+        fail_unless!(position_elem(v1, &2) == Some(1u));\n+        fail_unless!(position_elem(v1, &5) == Some(5u));\n+        fail_unless!(position_elem(v1, &4).is_none());\n     }\n \n     #[test]\n     fn test_position() {\n         fn less_than_three(i: &int) -> bool { return *i < 3; }\n         fn is_eighteen(i: &int) -> bool { return *i == 18; }\n \n-        assert position(~[], less_than_three).is_none();\n+        fail_unless!(position(~[], less_than_three).is_none());\n \n         let v1 = ~[5, 4, 3, 2, 1];\n-        assert position(v1, less_than_three) == Some(3u);\n-        assert position(v1, is_eighteen).is_none();\n+        fail_unless!(position(v1, less_than_three) == Some(3u));\n+        fail_unless!(position(v1, is_eighteen).is_none());\n     }\n \n     #[test]\n     fn test_position_between() {\n-        assert position_between(~[], 0u, 0u, f).is_none();\n+        fail_unless!(position_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert position_between(v, 0u, 0u, f).is_none();\n-        assert position_between(v, 0u, 1u, f).is_none();\n-        assert position_between(v, 0u, 2u, f) == Some(1u);\n-        assert position_between(v, 0u, 3u, f) == Some(1u);\n-        assert position_between(v, 0u, 4u, f) == Some(1u);\n+        fail_unless!(position_between(v, 0u, 0u, f).is_none());\n+        fail_unless!(position_between(v, 0u, 1u, f).is_none());\n+        fail_unless!(position_between(v, 0u, 2u, f) == Some(1u));\n+        fail_unless!(position_between(v, 0u, 3u, f) == Some(1u));\n+        fail_unless!(position_between(v, 0u, 4u, f) == Some(1u));\n \n-        assert position_between(v, 1u, 1u, f).is_none();\n-        assert position_between(v, 1u, 2u, f) == Some(1u);\n-        assert position_between(v, 1u, 3u, f) == Some(1u);\n-        assert position_between(v, 1u, 4u, f) == Some(1u);\n+        fail_unless!(position_between(v, 1u, 1u, f).is_none());\n+        fail_unless!(position_between(v, 1u, 2u, f) == Some(1u));\n+        fail_unless!(position_between(v, 1u, 3u, f) == Some(1u));\n+        fail_unless!(position_between(v, 1u, 4u, f) == Some(1u));\n \n-        assert position_between(v, 2u, 2u, f).is_none();\n-        assert position_between(v, 2u, 3u, f).is_none();\n-        assert position_between(v, 2u, 4u, f) == Some(3u);\n+        fail_unless!(position_between(v, 2u, 2u, f).is_none());\n+        fail_unless!(position_between(v, 2u, 3u, f).is_none());\n+        fail_unless!(position_between(v, 2u, 4u, f) == Some(3u));\n \n-        assert position_between(v, 3u, 3u, f).is_none();\n-        assert position_between(v, 3u, 4u, f) == Some(3u);\n+        fail_unless!(position_between(v, 3u, 3u, f).is_none());\n+        fail_unless!(position_between(v, 3u, 4u, f) == Some(3u));\n \n-        assert position_between(v, 4u, 4u, f).is_none();\n+        fail_unless!(position_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn test_find() {\n-        assert find(~[], f).is_none();\n+        fail_unless!(find(~[], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert find(v, f) == Some((1, 'b'));\n-        assert find(v, g).is_none();\n+        fail_unless!(find(v, f) == Some((1, 'b')));\n+        fail_unless!(find(v, g).is_none());\n     }\n \n     #[test]\n     fn test_find_between() {\n-        assert find_between(~[], 0u, 0u, f).is_none();\n+        fail_unless!(find_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert find_between(v, 0u, 0u, f).is_none();\n-        assert find_between(v, 0u, 1u, f).is_none();\n-        assert find_between(v, 0u, 2u, f) == Some((1, 'b'));\n-        assert find_between(v, 0u, 3u, f) == Some((1, 'b'));\n-        assert find_between(v, 0u, 4u, f) == Some((1, 'b'));\n+        fail_unless!(find_between(v, 0u, 0u, f).is_none());\n+        fail_unless!(find_between(v, 0u, 1u, f).is_none());\n+        fail_unless!(find_between(v, 0u, 2u, f) == Some((1, 'b')));\n+        fail_unless!(find_between(v, 0u, 3u, f) == Some((1, 'b')));\n+        fail_unless!(find_between(v, 0u, 4u, f) == Some((1, 'b')));\n \n-        assert find_between(v, 1u, 1u, f).is_none();\n-        assert find_between(v, 1u, 2u, f) == Some((1, 'b'));\n-        assert find_between(v, 1u, 3u, f) == Some((1, 'b'));\n-        assert find_between(v, 1u, 4u, f) == Some((1, 'b'));\n+        fail_unless!(find_between(v, 1u, 1u, f).is_none());\n+        fail_unless!(find_between(v, 1u, 2u, f) == Some((1, 'b')));\n+        fail_unless!(find_between(v, 1u, 3u, f) == Some((1, 'b')));\n+        fail_unless!(find_between(v, 1u, 4u, f) == Some((1, 'b')));\n \n-        assert find_between(v, 2u, 2u, f).is_none();\n-        assert find_between(v, 2u, 3u, f).is_none();\n-        assert find_between(v, 2u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(find_between(v, 2u, 2u, f).is_none());\n+        fail_unless!(find_between(v, 2u, 3u, f).is_none());\n+        fail_unless!(find_between(v, 2u, 4u, f) == Some((3, 'b')));\n \n-        assert find_between(v, 3u, 3u, f).is_none();\n-        assert find_between(v, 3u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(find_between(v, 3u, 3u, f).is_none());\n+        fail_unless!(find_between(v, 3u, 4u, f) == Some((3, 'b')));\n \n-        assert find_between(v, 4u, 4u, f).is_none();\n+        fail_unless!(find_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn test_rposition() {\n-        assert find(~[], f).is_none();\n+        fail_unless!(find(~[], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert position(v, f) == Some(1u);\n-        assert position(v, g).is_none();\n+        fail_unless!(position(v, f) == Some(1u));\n+        fail_unless!(position(v, g).is_none());\n     }\n \n     #[test]\n     fn test_rposition_between() {\n-        assert rposition_between(~[], 0u, 0u, f).is_none();\n+        fail_unless!(rposition_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert rposition_between(v, 0u, 0u, f).is_none();\n-        assert rposition_between(v, 0u, 1u, f).is_none();\n-        assert rposition_between(v, 0u, 2u, f) == Some(1u);\n-        assert rposition_between(v, 0u, 3u, f) == Some(1u);\n-        assert rposition_between(v, 0u, 4u, f) == Some(3u);\n+        fail_unless!(rposition_between(v, 0u, 0u, f).is_none());\n+        fail_unless!(rposition_between(v, 0u, 1u, f).is_none());\n+        fail_unless!(rposition_between(v, 0u, 2u, f) == Some(1u));\n+        fail_unless!(rposition_between(v, 0u, 3u, f) == Some(1u));\n+        fail_unless!(rposition_between(v, 0u, 4u, f) == Some(3u));\n \n-        assert rposition_between(v, 1u, 1u, f).is_none();\n-        assert rposition_between(v, 1u, 2u, f) == Some(1u);\n-        assert rposition_between(v, 1u, 3u, f) == Some(1u);\n-        assert rposition_between(v, 1u, 4u, f) == Some(3u);\n+        fail_unless!(rposition_between(v, 1u, 1u, f).is_none());\n+        fail_unless!(rposition_between(v, 1u, 2u, f) == Some(1u));\n+        fail_unless!(rposition_between(v, 1u, 3u, f) == Some(1u));\n+        fail_unless!(rposition_between(v, 1u, 4u, f) == Some(3u));\n \n-        assert rposition_between(v, 2u, 2u, f).is_none();\n-        assert rposition_between(v, 2u, 3u, f).is_none();\n-        assert rposition_between(v, 2u, 4u, f) == Some(3u);\n+        fail_unless!(rposition_between(v, 2u, 2u, f).is_none());\n+        fail_unless!(rposition_between(v, 2u, 3u, f).is_none());\n+        fail_unless!(rposition_between(v, 2u, 4u, f) == Some(3u));\n \n-        assert rposition_between(v, 3u, 3u, f).is_none();\n-        assert rposition_between(v, 3u, 4u, f) == Some(3u);\n+        fail_unless!(rposition_between(v, 3u, 3u, f).is_none());\n+        fail_unless!(rposition_between(v, 3u, 4u, f) == Some(3u));\n \n-        assert rposition_between(v, 4u, 4u, f).is_none();\n+        fail_unless!(rposition_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn test_rfind() {\n-        assert rfind(~[], f).is_none();\n+        fail_unless!(rfind(~[], f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert rfind(v, f) == Some((3, 'b'));\n-        assert rfind(v, g).is_none();\n+        fail_unless!(rfind(v, f) == Some((3, 'b')));\n+        fail_unless!(rfind(v, g).is_none());\n     }\n \n     #[test]\n     fn test_rfind_between() {\n-        assert rfind_between(~[], 0u, 0u, f).is_none();\n+        fail_unless!(rfind_between(~[], 0u, 0u, f).is_none());\n \n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         let mut v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n-        assert rfind_between(v, 0u, 0u, f).is_none();\n-        assert rfind_between(v, 0u, 1u, f).is_none();\n-        assert rfind_between(v, 0u, 2u, f) == Some((1, 'b'));\n-        assert rfind_between(v, 0u, 3u, f) == Some((1, 'b'));\n-        assert rfind_between(v, 0u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(rfind_between(v, 0u, 0u, f).is_none());\n+        fail_unless!(rfind_between(v, 0u, 1u, f).is_none());\n+        fail_unless!(rfind_between(v, 0u, 2u, f) == Some((1, 'b')));\n+        fail_unless!(rfind_between(v, 0u, 3u, f) == Some((1, 'b')));\n+        fail_unless!(rfind_between(v, 0u, 4u, f) == Some((3, 'b')));\n \n-        assert rfind_between(v, 1u, 1u, f).is_none();\n-        assert rfind_between(v, 1u, 2u, f) == Some((1, 'b'));\n-        assert rfind_between(v, 1u, 3u, f) == Some((1, 'b'));\n-        assert rfind_between(v, 1u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(rfind_between(v, 1u, 1u, f).is_none());\n+        fail_unless!(rfind_between(v, 1u, 2u, f) == Some((1, 'b')));\n+        fail_unless!(rfind_between(v, 1u, 3u, f) == Some((1, 'b')));\n+        fail_unless!(rfind_between(v, 1u, 4u, f) == Some((3, 'b')));\n \n-        assert rfind_between(v, 2u, 2u, f).is_none();\n-        assert rfind_between(v, 2u, 3u, f).is_none();\n-        assert rfind_between(v, 2u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(rfind_between(v, 2u, 2u, f).is_none());\n+        fail_unless!(rfind_between(v, 2u, 3u, f).is_none());\n+        fail_unless!(rfind_between(v, 2u, 4u, f) == Some((3, 'b')));\n \n-        assert rfind_between(v, 3u, 3u, f).is_none();\n-        assert rfind_between(v, 3u, 4u, f) == Some((3, 'b'));\n+        fail_unless!(rfind_between(v, 3u, 3u, f).is_none());\n+        fail_unless!(rfind_between(v, 3u, 4u, f) == Some((3, 'b')));\n \n-        assert rfind_between(v, 4u, 4u, f).is_none();\n+        fail_unless!(rfind_between(v, 4u, 4u, f).is_none());\n     }\n \n     #[test]\n     fn reverse_and_reversed() {\n         let mut v: ~[int] = ~[10, 20];\n-        assert (v[0] == 10);\n-        assert (v[1] == 20);\n+        fail_unless!((v[0] == 10));\n+        fail_unless!((v[1] == 20));\n         reverse(v);\n-        assert (v[0] == 20);\n-        assert (v[1] == 10);\n+        fail_unless!((v[0] == 20));\n+        fail_unless!((v[1] == 10));\n         let v2 = reversed::<int>(~[10, 20]);\n-        assert (v2[0] == 20);\n-        assert (v2[1] == 10);\n+        fail_unless!((v2[0] == 20));\n+        fail_unless!((v2[1] == 10));\n         v[0] = 30;\n-        assert (v2[0] == 20);\n+        fail_unless!((v2[0] == 20));\n         // Make sure they work with 0-length vectors too.\n \n         let v4 = reversed::<int>(~[]);\n-        assert (v4 == ~[]);\n+        fail_unless!((v4 == ~[]));\n         let mut v3: ~[int] = ~[];\n         reverse::<int>(v3);\n     }\n \n     #[test]\n     fn reversed_mut() {\n         let mut v2 = reversed::<int>(~[10, 20]);\n-        assert (v2[0] == 20);\n-        assert (v2[1] == 10);\n+        fail_unless!((v2[0] == 20));\n+        fail_unless!((v2[1] == 10));\n     }\n \n     #[test]\n     fn test_split() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert split(~[], f) == ~[];\n-        assert split(~[1, 2], f) == ~[~[1, 2]];\n-        assert split(~[3, 1, 2], f) == ~[~[], ~[1, 2]];\n-        assert split(~[1, 2, 3], f) == ~[~[1, 2], ~[]];\n-        assert split(~[1, 2, 3, 4, 3, 5], f) == ~[~[1, 2], ~[4], ~[5]];\n+        fail_unless!(split(~[], f) == ~[]);\n+        fail_unless!(split(~[1, 2], f) == ~[~[1, 2]]);\n+        fail_unless!(split(~[3, 1, 2], f) == ~[~[], ~[1, 2]]);\n+        fail_unless!(split(~[1, 2, 3], f) == ~[~[1, 2], ~[]]);\n+        fail_unless!(split(~[1, 2, 3, 4, 3, 5], f) == ~[~[1, 2], ~[4], ~[5]]);\n     }\n \n     #[test]\n     fn test_splitn() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert splitn(~[], 1u, f) == ~[];\n-        assert splitn(~[1, 2], 1u, f) == ~[~[1, 2]];\n-        assert splitn(~[3, 1, 2], 1u, f) == ~[~[], ~[1, 2]];\n-        assert splitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]];\n-        assert splitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n-                      ~[~[1, 2], ~[4, 3, 5]];\n+        fail_unless!(splitn(~[], 1u, f) == ~[]);\n+        fail_unless!(splitn(~[1, 2], 1u, f) == ~[~[1, 2]]);\n+        fail_unless!(splitn(~[3, 1, 2], 1u, f) == ~[~[], ~[1, 2]]);\n+        fail_unless!(splitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]]);\n+        fail_unless!(splitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n+                      ~[~[1, 2], ~[4, 3, 5]]);\n     }\n \n     #[test]\n     fn test_rsplit() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert rsplit(~[], f) == ~[];\n-        assert rsplit(~[1, 2], f) == ~[~[1, 2]];\n-        assert rsplit(~[1, 2, 3], f) == ~[~[1, 2], ~[]];\n-        assert rsplit(~[1, 2, 3, 4, 3, 5], f) == ~[~[1, 2], ~[4], ~[5]];\n+        fail_unless!(rsplit(~[], f) == ~[]);\n+        fail_unless!(rsplit(~[1, 2], f) == ~[~[1, 2]]);\n+        fail_unless!(rsplit(~[1, 2, 3], f) == ~[~[1, 2], ~[]]);\n+        fail_unless!(rsplit(~[1, 2, 3, 4, 3, 5], f) == ~[~[1, 2], ~[4], ~[5]]);\n     }\n \n     #[test]\n     fn test_rsplitn() {\n         fn f(x: &int) -> bool { *x == 3 }\n \n-        assert rsplitn(~[], 1u, f) == ~[];\n-        assert rsplitn(~[1, 2], 1u, f) == ~[~[1, 2]];\n-        assert rsplitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]];\n-        assert rsplitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n-                       ~[~[1, 2, 3, 4], ~[5]];\n+        fail_unless!(rsplitn(~[], 1u, f) == ~[]);\n+        fail_unless!(rsplitn(~[1, 2], 1u, f) == ~[~[1, 2]]);\n+        fail_unless!(rsplitn(~[1, 2, 3], 1u, f) == ~[~[1, 2], ~[]]);\n+        fail_unless!(rsplitn(~[1, 2, 3, 4, 3, 5], 1u, f) ==\n+                       ~[~[1, 2, 3, 4], ~[5]]);\n     }\n \n     #[test]\n     fn test_partition() {\n         // FIXME (#4355 maybe): using v.partition here crashes\n-        assert partition(~[], |x: &int| *x < 3) == (~[], ~[]);\n-        assert partition(~[1, 2, 3], |x: &int| *x < 4) == (~[1, 2, 3], ~[]);\n-        assert partition(~[1, 2, 3], |x: &int| *x < 2) == (~[1], ~[2, 3]);\n-        assert partition(~[1, 2, 3], |x: &int| *x < 0) == (~[], ~[1, 2, 3]);\n+        fail_unless!(partition(~[], |x: &int| *x < 3) == (~[], ~[]));\n+        fail_unless!(partition(~[1, 2, 3], |x: &int| *x < 4) == (~[1, 2, 3], ~[]));\n+        fail_unless!(partition(~[1, 2, 3], |x: &int| *x < 2) == (~[1], ~[2, 3]));\n+        fail_unless!(partition(~[1, 2, 3], |x: &int| *x < 0) == (~[], ~[1, 2, 3]));\n     }\n \n     #[test]\n     fn test_partitioned() {\n-        assert (~[]).partitioned(|x: &int| *x < 3) == (~[], ~[]);\n-        assert (~[1, 2, 3]).partitioned(|x: &int| *x < 4) ==\n-               (~[1, 2, 3], ~[]);\n-        assert (~[1, 2, 3]).partitioned(|x: &int| *x < 2) ==\n-               (~[1], ~[2, 3]);\n-        assert (~[1, 2, 3]).partitioned(|x: &int| *x < 0) ==\n-               (~[], ~[1, 2, 3]);\n+        fail_unless!((~[]).partitioned(|x: &int| *x < 3) == (~[], ~[]));\n+        fail_unless!((~[1, 2, 3]).partitioned(|x: &int| *x < 4) ==\n+                     (~[1, 2, 3], ~[]));\n+        fail_unless!((~[1, 2, 3]).partitioned(|x: &int| *x < 2) ==\n+                     (~[1], ~[2, 3]));\n+        fail_unless!((~[1, 2, 3]).partitioned(|x: &int| *x < 0) ==\n+                     (~[], ~[1, 2, 3]));\n     }\n \n     #[test]\n     fn test_concat() {\n-        assert concat(~[~[1], ~[2,3]]) == ~[1, 2, 3];\n+        fail_unless!(concat(~[~[1], ~[2,3]]) == ~[1, 2, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n-        assert connect(~[], &0) == ~[];\n-        assert connect(~[~[1], ~[2, 3]], &0) == ~[1, 0, 2, 3];\n-        assert connect(~[~[1], ~[2], ~[3]], &0) == ~[1, 0, 2, 0, 3];\n+        fail_unless!(connect(~[], &0) == ~[]);\n+        fail_unless!(connect(~[~[1], ~[2, 3]], &0) == ~[1, 0, 2, 3]);\n+        fail_unless!(connect(~[~[1], ~[2], ~[3]], &0) == ~[1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_windowed () {\n-        assert ~[~[1u,2u,3u],~[2u,3u,4u],~[3u,4u,5u],~[4u,5u,6u]]\n-            == windowed (3u, ~[1u,2u,3u,4u,5u,6u]);\n+        fail_unless!(~[~[1u,2u,3u],~[2u,3u,4u],~[3u,4u,5u],~[4u,5u,6u]]\n+                     == windowed (3u, ~[1u,2u,3u,4u,5u,6u]));\n \n-        assert ~[~[1u,2u,3u,4u],~[2u,3u,4u,5u],~[3u,4u,5u,6u]]\n-            == windowed (4u, ~[1u,2u,3u,4u,5u,6u]);\n+        fail_unless!(~[~[1u,2u,3u,4u],~[2u,3u,4u,5u],~[3u,4u,5u,6u]]\n+                     == windowed (4u, ~[1u,2u,3u,4u,5u,6u]));\n \n-        assert ~[] == windowed (7u, ~[1u,2u,3u,4u,5u,6u]);\n+        fail_unless!(~[] == windowed (7u, ~[1u,2u,3u,4u,5u,6u]));\n     }\n \n     #[test]\n@@ -3477,26 +3477,26 @@ mod tests {\n     fn test_unshift() {\n         let mut x = ~[1, 2, 3];\n         x.unshift(0);\n-        assert x == ~[0, 1, 2, 3];\n+        fail_unless!(x == ~[0, 1, 2, 3]);\n     }\n \n     #[test]\n     fn test_insert() {\n         let mut a = ~[1, 2, 4];\n         a.insert(2, 3);\n-        assert a == ~[1, 2, 3, 4];\n+        fail_unless!(a == ~[1, 2, 3, 4]);\n \n         let mut a = ~[1, 2, 3];\n         a.insert(0, 0);\n-        assert a == ~[0, 1, 2, 3];\n+        fail_unless!(a == ~[0, 1, 2, 3]);\n \n         let mut a = ~[1, 2, 3];\n         a.insert(3, 4);\n-        assert a == ~[1, 2, 3, 4];\n+        fail_unless!(a == ~[1, 2, 3, 4]);\n \n         let mut a = ~[];\n         a.insert(0, 1);\n-        assert a == ~[1];\n+        fail_unless!(a == ~[1]);\n     }\n \n     #[test]\n@@ -3511,15 +3511,15 @@ mod tests {\n     fn test_remove() {\n         let mut a = ~[1, 2, 3, 4];\n         a.remove(2);\n-        assert a == ~[1, 2, 4];\n+        fail_unless!(a == ~[1, 2, 4]);\n \n         let mut a = ~[1, 2, 3];\n         a.remove(0);\n-        assert a == ~[2, 3];\n+        fail_unless!(a == ~[2, 3]);\n \n         let mut a = ~[1];\n         a.remove(0);\n-        assert a == ~[];\n+        fail_unless!(a == ~[]);\n     }\n \n     #[test]\n@@ -3534,19 +3534,19 @@ mod tests {\n     fn test_capacity() {\n         let mut v = ~[0u64];\n         reserve(&mut v, 10u);\n-        assert capacity(&v) == 10u;\n+        fail_unless!(capacity(&v) == 10u);\n         let mut v = ~[0u32];\n         reserve(&mut v, 10u);\n-        assert capacity(&v) == 10u;\n+        fail_unless!(capacity(&v) == 10u);\n     }\n \n     #[test]\n     fn test_view() {\n         let v = ~[1, 2, 3, 4, 5];\n         let v = v.view(1u, 3u);\n-        assert(len(v) == 2u);\n-        assert(v[0] == 2);\n-        assert(v[1] == 3);\n+        fail_unless!((len(v) == 2u));\n+        fail_unless!((v[0] == 2));\n+        fail_unless!((v[1] == 3));\n     }\n \n "}, {"sha": "81048a69ca91d848fa6130e0b4b4fff53a24a0fe", "filename": "src/libfuzzer/ast_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibfuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibfuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fast_match.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -29,13 +29,13 @@ pure fn builtin_equal<T>(&&a: T, &&b: T) -> bool { return a == b; }\n pure fn builtin_equal_int(&&a: int, &&b: int) -> bool { return a == b; }\n \n fn main() {\n-    assert (builtin_equal(5, 5));\n-    assert (!builtin_equal(5, 4));\n-    assert (!vec_equal(~[5, 5], ~[5], bind builtin_equal(_, _)));\n-    assert (!vec_equal(~[5, 5], ~[5], builtin_equal_int));\n-    assert (!vec_equal(~[5, 5], ~[5, 4], builtin_equal_int));\n-    assert (!vec_equal(~[5, 5], ~[4, 5], builtin_equal_int));\n-    assert (vec_equal(~[5, 5], ~[5, 5], builtin_equal_int));\n+    fail_unless!((builtin_equal(5, 5)));\n+    fail_unless!((!builtin_equal(5, 4)));\n+    fail_unless!((!vec_equal(~[5, 5], ~[5], bind builtin_equal(_, _))));\n+    fail_unless!((!vec_equal(~[5, 5], ~[5], builtin_equal_int)));\n+    fail_unless!((!vec_equal(~[5, 5], ~[5, 4], builtin_equal_int)));\n+    fail_unless!((!vec_equal(~[5, 5], ~[4, 5], builtin_equal_int)));\n+    fail_unless!((vec_equal(~[5, 5], ~[5, 5], builtin_equal_int)));\n \n     error!(\"Pass\");\n }"}, {"sha": "7ea74b369404c149190ab11834ed393d2dc3919c", "filename": "src/libfuzzer/cycles.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibfuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibfuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fcycles.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -14,12 +14,12 @@ use uint::range;\n \n // random uint less than n\n fn under(r : rand::rng, n : uint) -> uint {\n-    assert n != 0u; r.next() as uint % n\n+    fail_unless!(n != 0u); r.next() as uint % n\n }\n \n // random choice from a vec\n fn choice<T:copy>(r : rand::rng, v : ~[const T]) -> T {\n-    assert vec::len(v) != 0u; v[under(r, vec::len(v))]\n+    fail_unless!(vec::len(v) != 0u); v[under(r, vec::len(v))]\n }\n \n // k in n chance of being true"}, {"sha": "8257af5760f93012170f9766c58fabe8032189a0", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -371,13 +371,13 @@ pub fn check_whole_compiler(code: ~str, suggested_filename_prefix: &Path,\n \n pub fn removeIfExists(filename: &Path) {\n     // So sketchy!\n-    assert !contains(filename.to_str(), ~\" \");\n+    fail_unless!(!contains(filename.to_str(), ~\" \"));\n     run::program_output(~\"bash\", ~[~\"-c\", ~\"rm \" + filename.to_str()]);\n }\n \n pub fn removeDirIfExists(filename: &Path) {\n     // So sketchy!\n-    assert !contains(filename.to_str(), ~\" \");\n+    fail_unless!(!contains(filename.to_str(), ~\" \"));\n     run::program_output(~\"bash\", ~[~\"-c\", ~\"rm -r \" + filename.to_str()]);\n }\n "}, {"sha": "25b1669d86f75854bcbf39d35f49e1416bb5810c", "filename": "src/libfuzzer/rand_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibfuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibfuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Frand_util.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -13,12 +13,12 @@ use std::rand;\n \n // random uint less than n\n fn under(r : rand::rng, n : uint) -> uint {\n-    assert n != 0u; r.next() as uint % n\n+    fail_unless!(n != 0u); r.next() as uint % n\n }\n \n // random choice from a vec\n fn choice<T:copy>(r : rand::rng, v : ~[T]) -> T {\n-    assert vec::len(v) != 0u; v[under(r, vec::len(v))]\n+    fail_unless!(vec::len(v) != 0u); v[under(r, vec::len(v))]\n }\n \n // 1 in n chance of being true\n@@ -49,12 +49,12 @@ fn shuffled<T:copy>(r : rand::rng, v : ~[T]) -> ~[T] {\n // * weighted_vec is O(total weight) space\n type weighted<T> = { weight: uint, item: T };\n fn weighted_choice<T:copy>(r : rand::rng, v : ~[weighted<T>]) -> T {\n-    assert vec::len(v) != 0u;\n+    fail_unless!(vec::len(v) != 0u);\n     let total = 0u;\n     for {weight: weight, item: _} in v {\n         total += weight;\n     }\n-    assert total >= 0u;\n+    fail_unless!(total >= 0u);\n     let chosen = under(r, total);\n     let so_far = 0u;\n     for {weight: weight, item: item} in v {"}, {"sha": "2d98a84aee9172b4323b4adf2208d277e2c7ea88", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -118,7 +118,7 @@ pub fn get_rpath_relative_to_output(os: session::os,\n                                  -> Path {\n     use core::os;\n \n-    assert not_win32(os);\n+    fail_unless!(not_win32(os));\n \n     // Mac doesn't appear to support $ORIGIN\n     let prefix = match os {\n@@ -134,8 +134,8 @@ pub fn get_rpath_relative_to_output(os: session::os,\n \n // Find the relative path from one file to another\n pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n-    assert abs1.is_absolute;\n-    assert abs2.is_absolute;\n+    fail_unless!(abs1.is_absolute);\n+    fail_unless!(abs2.is_absolute);\n     let abs1 = abs1.normalize();\n     let abs2 = abs2.normalize();\n     debug!(\"finding relative path from %s to %s\",\n@@ -144,8 +144,8 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n     let split2 = /*bad*/copy abs2.components;\n     let len1 = vec::len(split1);\n     let len2 = vec::len(split2);\n-    assert len1 > 0;\n-    assert len2 > 0;\n+    fail_unless!(len1 > 0);\n+    fail_unless!(len2 > 0);\n \n     let max_common_path = uint::min(len1, len2) - 1;\n     let mut start_idx = 0;\n@@ -215,7 +215,7 @@ mod test {\n     pub fn test_rpaths_to_flags() {\n         let flags = rpaths_to_flags(~[Path(\"path1\"),\n                                       Path(\"path2\")]);\n-        assert flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"];\n+        fail_unless!(flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n     }\n \n     #[test]\n@@ -226,21 +226,21 @@ mod test {\n         debug!(\"test_prefix_path: %s vs. %s\",\n                res.to_str(),\n                d.to_str());\n-        assert str::ends_with(res.to_str(), d.to_str());\n+        fail_unless!(str::ends_with(res.to_str(), d.to_str()));\n     }\n \n     #[test]\n     pub fn test_prefix_rpath_abs() {\n         let res = get_install_prefix_rpath(\"triple\");\n-        assert res.is_absolute;\n+        fail_unless!(res.is_absolute);\n     }\n \n     #[test]\n     pub fn test_minimize1() {\n         let res = minimize_rpaths([Path(\"rpath1\"),\n                                    Path(\"rpath2\"),\n                                    Path(\"rpath1\")]);\n-        assert res == ~[Path(\"rpath1\"), Path(\"rpath2\")];\n+        fail_unless!(res == ~[Path(\"rpath1\"), Path(\"rpath2\")]);\n     }\n \n     #[test]\n@@ -249,63 +249,63 @@ mod test {\n                                     Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n                                     Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n                                     Path(\"3\")]);\n-        assert res == ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")];\n+        fail_unless!(res == ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")]);\n     }\n \n     #[test]\n     pub fn test_relative_to1() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"../lib\");\n+        fail_unless!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n     pub fn test_relative_to2() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/bin/../lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"../lib\");\n+        fail_unless!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n     pub fn test_relative_to3() {\n         let p1 = Path(\"/usr/bin/whatever/rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"../../lib/whatever\");\n+        fail_unless!(res == Path(\"../../lib/whatever\"));\n     }\n \n     #[test]\n     pub fn test_relative_to4() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"../lib/whatever\");\n+        fail_unless!(res == Path(\"../lib/whatever\"));\n     }\n \n     #[test]\n     pub fn test_relative_to5() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/../mylib\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"../lib\");\n+        fail_unless!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n     pub fn test_relative_to6() {\n         let p1 = Path(\"/1\");\n         let p2 = Path(\"/2/3\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"2\");\n+        fail_unless!(res == Path(\"2\"));\n     }\n \n     #[test]\n     pub fn test_relative_to7() {\n         let p1 = Path(\"/1/2\");\n         let p2 = Path(\"/3\");\n         let res = get_relative_to(&p1, &p2);\n-        assert res == Path(\"..\");\n+        fail_unless!(res == Path(\"..\"));\n     }\n \n     #[test]\n@@ -318,7 +318,7 @@ mod test {\n         debug!(\"test_relative_tu8: %s vs. %s\",\n                res.to_str(),\n                Path(\".\").to_str());\n-        assert res == Path(\".\");\n+        fail_unless!(res == Path(\".\"));\n     }\n \n     #[test]\n@@ -328,7 +328,7 @@ mod test {\n       let o = session::os_linux;\n       let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n-      assert res.to_str() == ~\"$ORIGIN/../lib\";\n+      fail_unless!(res.to_str() == ~\"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -337,7 +337,7 @@ mod test {\n         let o = session::os_freebsd;\n         let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n-        assert res.to_str() == ~\"$ORIGIN/../lib\";\n+        fail_unless!(res.to_str() == ~\"$ORIGIN/../lib\");\n     }\n \n     #[test]\n@@ -348,7 +348,7 @@ mod test {\n         let res = get_rpath_relative_to_output(o,\n                                                &Path(\"bin/rustc\"),\n                                                &Path(\"lib/libstd.so\"));\n-        assert res.to_str() == ~\"@executable_path/../lib\";\n+        fail_unless!(res.to_str() == ~\"@executable_path/../lib\");\n     }\n \n     #[test]\n@@ -358,6 +358,6 @@ mod test {\n                res.to_str(),\n                os::make_absolute(&Path(\"lib\")).to_str());\n \n-        assert res == os::make_absolute(&Path(\"lib\"));\n+        fail_unless!(res == os::make_absolute(&Path(\"lib\")));\n     }\n }"}, {"sha": "e7e29ec6c72d5b35c8fb18a5c49390b2860ae469", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -902,7 +902,7 @@ pub mod test {\n             ~\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n-        assert (attr::contains_name(cfg, ~\"test\"));\n+        fail_unless!((attr::contains_name(cfg, ~\"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -922,7 +922,7 @@ pub mod test {\n         let sess = build_session(sessopts, diagnostic::emit);\n         let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n         let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n-        assert (vec::len(test_items) == 1u);\n+        fail_unless!((vec::len(test_items) == 1u));\n     }\n }\n "}, {"sha": "52426401d7927b1eec627a47173722fb1c449843", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -378,43 +378,43 @@ pub mod test {\n     #[test]\n     pub fn bin_crate_type_attr_results_in_bin_output() {\n         let crate = make_crate(true, false);\n-        assert !building_library(unknown_crate, crate, false);\n+        fail_unless!(!building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n     pub fn lib_crate_type_attr_results_in_lib_output() {\n         let crate = make_crate(false, true);\n-        assert building_library(unknown_crate, crate, false);\n+        fail_unless!(building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n     pub fn bin_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n-        assert !building_library(bin_crate, crate, false);\n+        fail_unless!(!building_library(bin_crate, crate, false));\n     }\n \n     #[test]\n     pub fn lib_option_overrides_bin_crate_type() {\n         let crate = make_crate(true, false);\n-        assert building_library(lib_crate, crate, false);\n+        fail_unless!(building_library(lib_crate, crate, false));\n     }\n \n     #[test]\n     pub fn bin_crate_type_is_default() {\n         let crate = make_crate(false, false);\n-        assert !building_library(unknown_crate, crate, false);\n+        fail_unless!(!building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n     pub fn test_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n-        assert !building_library(unknown_crate, crate, true);\n+        fail_unless!(!building_library(unknown_crate, crate, true));\n     }\n \n     #[test]\n     pub fn test_option_does_not_override_requested_lib_type() {\n         let crate = make_crate(false, false);\n-        assert building_library(lib_crate, crate, true);\n+        fail_unless!(building_library(lib_crate, crate, true));\n     }\n }\n "}, {"sha": "4cb018ebdd1f6deb5d83c90649d2279bafaaa3e0", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1460,8 +1460,8 @@ pub struct TypeNames {\n }\n \n pub fn associate_type(tn: @TypeNames, s: @str, t: TypeRef) {\n-    assert tn.type_names.insert(t, s);\n-    assert tn.named_types.insert(s, t);\n+    fail_unless!(tn.type_names.insert(t, s));\n+    fail_unless!(tn.named_types.insert(s, t));\n }\n \n pub fn type_has_name(tn: @TypeNames, t: TypeRef) -> Option<@str> {"}, {"sha": "890a58243a1cdaa0da52be60dc6f51fa8e0148f2", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -95,7 +95,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n                 }\n             }));\n \n-        assert !matches.is_empty();\n+        fail_unless!(!matches.is_empty());\n \n         if matches.len() != 1u {\n             diag.handler().warn("}, {"sha": "2f82d99420c1a992e4753cb5d1bb39e707623e8d", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -106,7 +106,7 @@ pub fn get_used_crate_files(cstore: @mut CStore) -> ~[Path] {\n }\n \n pub fn add_used_library(cstore: @mut CStore, lib: @~str) -> bool {\n-    assert *lib != ~\"\";\n+    fail_unless!(*lib != ~\"\");\n \n     if cstore.used_libraries.contains(&*lib) { return false; }\n     cstore.used_libraries.push(/*bad*/ copy *lib);"}, {"sha": "8554f40b4b10137ccea55075886b041a7bdbd96d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1000,7 +1000,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n-            assert (vec::len(meta_items) == 1u);\n+            fail_unless!((vec::len(meta_items) == 1u));\n             let meta_item = meta_items[0];\n             attrs.push(\n                 codemap::spanned {"}, {"sha": "9a90b5f364c25c08bc4b46453ecf6c0d1c8abece", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1064,7 +1064,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n         ebml_w.start_tag(tag_index_buckets_bucket);\n         for vec::each(**bucket) |elt| {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n-            assert elt.pos < 0xffff_ffff;\n+            fail_unless!(elt.pos < 0xffff_ffff);\n             writer.write_be_u32(elt.pos as u32);\n             write_fn(writer, elt.val);\n             ebml_w.end_tag();\n@@ -1074,7 +1074,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_index_table);\n     for bucket_locs.each |pos| {\n-        assert *pos < 0xffff_ffff;\n+        fail_unless!(*pos < 0xffff_ffff);\n         writer.write_be_u32(*pos as u32);\n     }\n     ebml_w.end_tag();\n@@ -1084,7 +1084,7 @@ fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n fn write_str(writer: io::Writer, &&s: ~str) { writer.write_str(s); }\n \n fn write_int(writer: io::Writer, &&n: int) {\n-    assert n < 0x7fff_ffff;\n+    fail_unless!(n < 0x7fff_ffff);\n     writer.write_be_u32(n as u32);\n }\n \n@@ -1145,8 +1145,8 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n     fn synthesize_link_attr(ecx: @EncodeContext, +items: ~[@meta_item]) ->\n        attribute {\n \n-        assert !ecx.link_meta.name.is_empty();\n-        assert !ecx.link_meta.vers.is_empty();\n+        fail_unless!(!ecx.link_meta.name.is_empty());\n+        fail_unless!(!ecx.link_meta.vers.is_empty());\n \n         let name_item =\n             attr::mk_name_value_item_str(@~\"name\",\n@@ -1212,7 +1212,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n         for deps.each |n| {\n-            assert (n.cnum == expected_cnum);\n+            fail_unless!((n.cnum == expected_cnum));\n             expected_cnum += 1;\n         }\n "}, {"sha": "08b9facf4861368c03c1cb262496aad5572f1c65", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -140,12 +140,12 @@ fn parse_sigil(st: @mut PState) -> ast::Sigil {\n }\n \n fn parse_vstore(st: @mut PState) -> ty::vstore {\n-    assert next(st) == '/';\n+    fail_unless!(next(st) == '/');\n \n     let c = peek(st);\n     if '0' <= c && c <= '9' {\n         let n = parse_int(st) as uint;\n-        assert next(st) == '|';\n+        fail_unless!(next(st) == '|');\n         return ty::vstore_fixed(n);\n     }\n \n@@ -162,7 +162,7 @@ fn parse_substs(st: @mut PState, conv: conv_did) -> ty::substs {\n \n     let self_ty = parse_opt(st, || parse_ty(st, conv) );\n \n-    assert next(st) == '[';\n+    fail_unless!(next(st) == '[');\n     let mut params: ~[ty::t] = ~[];\n     while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n     st.pos = st.pos + 1u;\n@@ -179,13 +179,13 @@ fn parse_bound_region(st: @mut PState) -> ty::bound_region {\n       's' => ty::br_self,\n       'a' => {\n         let id = parse_int(st) as uint;\n-        assert next(st) == '|';\n+        fail_unless!(next(st) == '|');\n         ty::br_anon(id)\n       }\n       '[' => ty::br_named(st.tcx.sess.ident_of(parse_str(st, ']'))),\n       'c' => {\n         let id = parse_int(st);\n-        assert next(st) == '|';\n+        fail_unless!(next(st) == '|');\n         ty::br_cap_avoid(id, @parse_bound_region(st))\n       },\n       _ => fail!(~\"parse_bound_region: bad input\")\n@@ -198,16 +198,16 @@ fn parse_region(st: @mut PState) -> ty::Region {\n         ty::re_bound(parse_bound_region(st))\n       }\n       'f' => {\n-        assert next(st) == '[';\n+        fail_unless!(next(st) == '[');\n         let id = parse_int(st);\n-        assert next(st) == '|';\n+        fail_unless!(next(st) == '|');\n         let br = parse_bound_region(st);\n-        assert next(st) == ']';\n+        fail_unless!(next(st) == ']');\n         ty::re_free(id, br)\n       }\n       's' => {\n         let id = parse_int(st);\n-        assert next(st) == '|';\n+        fail_unless!(next(st) == '|');\n         ty::re_scope(id)\n       }\n       't' => {\n@@ -259,18 +259,18 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       'c' => return ty::mk_char(st.tcx),\n       't' => {\n-        assert (next(st) == '[');\n+        fail_unless!((next(st) == '['));\n         let def = parse_def(st, NominalType, conv);\n         let substs = parse_substs(st, conv);\n-        assert next(st) == ']';\n+        fail_unless!(next(st) == ']');\n         return ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' => {\n-        assert next(st) == '[';\n+        fail_unless!(next(st) == '[');\n         let def = parse_def(st, NominalType, conv);\n         let substs = parse_substs(st, conv);\n         let vstore = parse_vstore(st);\n-        assert next(st) == ']';\n+        fail_unless!(next(st) == ']');\n         return ty::mk_trait(st.tcx, def, substs, vstore);\n       }\n       'p' => {\n@@ -300,7 +300,7 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n         return ty::mk_estr(st.tcx, v);\n       }\n       'T' => {\n-        assert (next(st) == '[');\n+        fail_unless!((next(st) == '['));\n         let mut params = ~[];\n         while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n         st.pos = st.pos + 1u;\n@@ -319,9 +319,9 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       '#' => {\n         let pos = parse_hex(st);\n-        assert (next(st) == ':');\n+        fail_unless!((next(st) == ':'));\n         let len = parse_hex(st);\n-        assert (next(st) == '#');\n+        fail_unless!((next(st) == '#'));\n         let key = ty::creader_cache_key {cnum: st.crate,\n                                          pos: pos,\n                                          len: len };\n@@ -342,10 +342,10 @@ fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n-          assert (next(st) == '[');\n+          fail_unless!((next(st) == '['));\n           let did = parse_def(st, NominalType, conv);\n           let substs = parse_substs(st, conv);\n-          assert (next(st) == ']');\n+          fail_unless!((next(st) == ']'));\n           return ty::mk_struct(st.tcx, did, substs);\n       }\n       c => { error!(\"unexpected char in type string: %c\", c); fail!();}\n@@ -460,7 +460,7 @@ fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n }\n \n fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n-    assert (next(st) == '[');\n+    fail_unless!((next(st) == '['));\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n         let mode = parse_mode(st);"}, {"sha": "49a5be5468474903e054b4100a060998b1988215", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -176,7 +176,7 @@ pub impl ExtendedDecodeContext {\n          */\n \n         // from_id_range should be non-empty\n-        assert !ast_util::empty(self.from_id_range);\n+        fail_unless!(!ast_util::empty(self.from_id_range));\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n     fn tr_def_id(&self, did: ast::def_id) -> ast::def_id {\n@@ -213,7 +213,7 @@ pub impl ExtendedDecodeContext {\n          * refer to the current crate and to the new, inlined node-id.\n          */\n \n-        assert did.crate == ast::local_crate;\n+        fail_unless!(did.crate == ast::local_crate);\n         ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n     }\n     fn tr_span(&self, _span: span) -> span {\n@@ -1231,7 +1231,7 @@ fn roundtrip(in_item: Option<@ast::item>) {\n     debug!(\"expected string: %s\", exp_str);\n     debug!(\"actual string  : %s\", out_str);\n \n-    assert exp_str == out_str;\n+    fail_unless!(exp_str == out_str);\n }\n \n #[test]\n@@ -1278,8 +1278,10 @@ fn test_simplification() {\n     ).get());\n     match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n-        assert pprust::item_to_str(item_out, ext_cx.parse_sess().interner)\n-            == pprust::item_to_str(item_exp, ext_cx.parse_sess().interner);\n+        fail_unless!(pprust::item_to_str(item_out,\n+                                         ext_cx.parse_sess().interner)\n+                     == pprust::item_to_str(item_exp,\n+                                            ext_cx.parse_sess().interner));\n       }\n       _ => fail!()\n     }"}, {"sha": "a60b0332b8fb4d485a60e9b694aea10ddedbfffa", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -132,7 +132,7 @@ pub fn raw_pat(p: @pat) -> @pat {\n }\n \n pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n-    assert(!pats.is_empty());\n+    fail_unless!((!pats.is_empty()));\n     let ext = match is_useful(cx, &pats.map(|p| ~[*p]), ~[wild()]) {\n         not_useful => {\n             // This is good, wildcard pattern isn't reachable"}, {"sha": "2bd08f109812fc64348b2db6157300999026dc6e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -872,7 +872,7 @@ fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n-        assert !ident.is_empty();\n+        fail_unless!(!ident.is_empty());\n         let ident = ident_without_trailing_underscores(*ident);\n         let ident = ident_without_leading_underscores(ident);\n         char::is_uppercase(str::char_at(ident, 0)) &&"}, {"sha": "473fad5ee25729d52b3acf9fbd2276cc71e7af81", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -777,7 +777,7 @@ pub impl Liveness {\n     fn live_on_entry(&self, ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n-        assert ln.is_valid();\n+        fail_unless!(ln.is_valid());\n         let reader = self.users[self.idx(ln, var)].reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n@@ -792,14 +792,14 @@ pub impl Liveness {\n     }\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n-        assert ln.is_valid();\n+        fail_unless!(ln.is_valid());\n         self.users[self.idx(ln, var)].used\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n-        assert ln.is_valid();\n+        fail_unless!(ln.is_valid());\n         let writer = self.users[self.idx(ln, var)].writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n@@ -1493,11 +1493,11 @@ pub impl Liveness {\n         // repeat until fixed point is reached:\n         while self.merge_from_succ(ln, body_ln, first_merge) {\n             first_merge = false;\n-            assert cond_ln == self.propagate_through_opt_expr(cond, ln);\n+            fail_unless!(cond_ln == self.propagate_through_opt_expr(cond, ln));\n             assert body_ln == self.with_loop_nodes(expr.id, succ, ln,\n             || {\n                 self.propagate_through_block(body, cond_ln)\n-            });\n+            }));\n         }\n \n         cond_ln"}, {"sha": "866ec0ab515efccf791a2dc2abed3f7196dd5b7e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -463,7 +463,7 @@ pub impl DetermineRpCtxt {\n     /// variance `variance`.  If `id` was already parameterized, then\n     /// the new variance is joined with the old variance.\n     fn add_rp(&mut self, id: ast::node_id, variance: region_variance) {\n-        assert id != 0;\n+        fail_unless!(id != 0);\n         let old_variance = self.region_paramd_items.find(&id);\n         let joined_variance = match old_variance {\n           None => variance,"}, {"sha": "1ca3c045f57ecc182a13837a5dfa7829ad2697e7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1411,7 +1411,7 @@ pub impl Resolver {\n                     match view_path.node {\n                         view_path_simple(_, full_path, _, _) => {\n                             let path_len = full_path.idents.len();\n-                            assert path_len != 0;\n+                            fail_unless!(path_len != 0);\n \n                             for full_path.idents.eachi |i, ident| {\n                                 if i != path_len - 1 {\n@@ -2107,7 +2107,7 @@ pub impl Resolver {\n         // Decrement the count of unresolved imports.\n         match resolution_result {\n             Success(()) => {\n-                assert self.unresolved_imports >= 1;\n+                fail_unless!(self.unresolved_imports >= 1);\n                 self.unresolved_imports -= 1;\n             }\n             _ => {\n@@ -2123,7 +2123,7 @@ pub impl Resolver {\n         if !resolution_result.indeterminate() {\n             match *import_directive.subclass {\n                 GlobImport => {\n-                    assert module_.glob_count >= 1;\n+                    fail_unless!(module_.glob_count >= 1);\n                     module_.glob_count -= 1;\n                 }\n                 SingleImport(*) => {\n@@ -2258,7 +2258,7 @@ pub impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert module_.import_resolutions.contains_key(&target);\n+        fail_unless!(module_.import_resolutions.contains_key(&target));\n         let import_resolution = module_.import_resolutions.get(&target);\n \n         match value_result {\n@@ -2320,7 +2320,7 @@ pub impl Resolver {\n             }\n         }\n \n-        assert import_resolution.outstanding_references >= 1;\n+        fail_unless!(import_resolution.outstanding_references >= 1);\n         import_resolution.outstanding_references -= 1;\n \n         debug!(\"(resolving single import) successfully resolved import\");\n@@ -2417,7 +2417,7 @@ pub impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert module_.import_resolutions.contains_key(&target);\n+        fail_unless!(module_.import_resolutions.contains_key(&target));\n         let import_resolution = module_.import_resolutions.get(&target);\n \n         match module_result {\n@@ -2442,7 +2442,7 @@ pub impl Resolver {\n           return Failed;\n         }\n \n-        assert import_resolution.outstanding_references >= 1;\n+        fail_unless!(import_resolution.outstanding_references >= 1);\n         import_resolution.outstanding_references -= 1;\n \n         debug!(\"(resolving single module import) successfully resolved \\\n@@ -2476,7 +2476,7 @@ pub impl Resolver {\n             return Indeterminate;\n         }\n \n-        assert containing_module.glob_count == 0;\n+        fail_unless!(containing_module.glob_count == 0);\n \n         // Add all resolved imports from the containing module.\n         for containing_module.import_resolutions.each\n@@ -2664,7 +2664,7 @@ pub impl Resolver {\n                                       span: span)\n                                    -> ResolveResult<@mut Module> {\n         let module_path_len = module_path.len();\n-        assert module_path_len > 0;\n+        fail_unless!(module_path_len > 0);\n \n         debug!(\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n@@ -3016,7 +3016,7 @@ pub impl Resolver {\n         // If this is a search of all imports, we should be done with glob\n         // resolution at this point.\n         if name_search_type == SearchItemsAndAllImports {\n-            assert module_.glob_count == 0;\n+            fail_unless!(module_.glob_count == 0);\n         }\n \n         // Check the list of resolved imports."}, {"sha": "072a52a96b80921e5adc0eedce49f4c29a652075", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1219,7 +1219,7 @@ pub fn compile_submatch(bcx: block,\n     /*\n       For an empty match, a fall-through case must exist\n      */\n-    assert(m.len() > 0u || chk.is_some());\n+    fail_unless!((m.len() > 0u || chk.is_some()));\n     let _icx = bcx.insn_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;"}, {"sha": "7af1fcc7e779b9927bcc6a85b4507372ccd2bcea", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -306,8 +306,8 @@ pub fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n     unsafe {\n         debug!(\"non_gc_box_cast\");\n         add_comment(bcx, ~\"non_gc_box_cast\");\n-        assert(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n-                gc_box_addrspace || bcx.unreachable);\n+        fail_unless!(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n+                     gc_box_addrspace || bcx.unreachable);\n         let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n         PointerCast(bcx, val, non_gc_t)\n     }\n@@ -479,7 +479,7 @@ pub fn get_res_dtor(ccx: @CrateContext, did: ast::def_id,\n         let did = if did.crate != ast::local_crate {\n             inline::maybe_instantiate_inline(ccx, did, true)\n         } else { did };\n-        assert did.crate == ast::local_crate;\n+        fail_unless!(did.crate == ast::local_crate);\n         let (val, _) =\n             monomorphize::monomorphic_fn(ccx, did, substs, None, None, None);\n \n@@ -1301,7 +1301,7 @@ pub fn cleanup_and_leave(bcx: block,\n         }\n         cur = match cur.parent {\n           Some(next) => next,\n-          None => { assert upto.is_none(); break; }\n+          None => { fail_unless!(upto.is_none()); break; }\n         };\n     }\n     match leave {\n@@ -1488,7 +1488,7 @@ pub fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n     let ccx = bcx.ccx();\n     let llty = type_of::type_of(ccx, t);\n     if ty::type_has_params(t) { log(error, ty_to_str(ccx.tcx, t)); }\n-    assert !ty::type_has_params(t);\n+    fail_unless!(!ty::type_has_params(t));\n     let val = alloca(bcx, llty);\n     return val;\n }\n@@ -2443,7 +2443,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             // Want parent_id and not id, because id is the dtor's type\n             let class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n             // This code shouldn't be reached if the class is generic\n-            assert !ty::type_has_params(class_ty);\n+            fail_unless!(!ty::type_has_params(class_ty));\n             let lldty = unsafe {\n                 T_fn(~[\n                     T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n@@ -2463,7 +2463,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             let llfn;\n             match /*bad*/copy (*v).node.kind {\n                 ast::tuple_variant_kind(args) => {\n-                    assert args.len() != 0u;\n+                    fail_unless!(args.len() != 0u);\n                     let pth = vec::append(/*bad*/copy *pth,\n                                           ~[path_name(enm.ident),\n                                             path_name((*v).node.name)]);"}, {"sha": "45104480b4c9d79eabd1d6661345f6711ccf2392", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -814,7 +814,7 @@ pub fn Phi(cx: block, Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef])\n     -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-        assert vals.len() == bbs.len();\n+        fail_unless!(vals.len() == bbs.len());\n         let phi = EmptyPhi(cx, Ty);\n         count_insn(cx, \"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n@@ -1008,7 +1008,7 @@ pub fn Trap(cx: block) {\n         let T: ValueRef = str::as_c_str(~\"llvm.trap\", |buf| {\n             llvm::LLVMGetNamedFunction(M, buf)\n         });\n-        assert (T as int != 0);\n+        fail_unless!((T as int != 0));\n         let Args: ~[ValueRef] = ~[];\n         unsafe {\n             count_insn(cx, \"trap\");\n@@ -1022,7 +1022,7 @@ pub fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n     unsafe {\n         check_not_terminated(cx);\n-        assert !cx.unreachable;\n+        fail_unless!(!cx.unreachable);\n         count_insn(cx, \"landingpad\");\n         return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n                                       NumClauses as c_uint, noname());"}, {"sha": "ba1c753729c5c8e63902ce3bec7d2748d137a01c", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -130,9 +130,9 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n             }\n             ast::def_variant(tid, vid) => {\n                 // nullary variants are not callable\n-                assert ty::enum_variant_with_id(bcx.tcx(),\n-                                                tid,\n-                                                vid).args.len() > 0u;\n+                fail_unless!(ty::enum_variant_with_id(bcx.tcx(),\n+                                                      tid,\n+                                                      vid).args.len() > 0u);\n                 fn_callee(bcx, trans_fn_ref(bcx, vid, ref_expr.id))\n             }\n             ast::def_struct(def_id) => {\n@@ -280,7 +280,7 @@ pub fn trans_fn_ref_with_vtables(\n     // Create a monomorphic verison of generic functions\n     if must_monomorphise {\n         // Should be either intra-crate or inlined.\n-        assert def_id.crate == ast::local_crate;\n+        fail_unless!(def_id.crate == ast::local_crate);\n \n         let mut (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, type_params,\n@@ -704,7 +704,7 @@ pub fn trans_arg_expr(bcx: block,\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n             DoAutorefArg => {\n-                assert !bcx.ccx().maps.moves_map.contains_key(&arg_expr.id);\n+                fail_unless!(!bcx.ccx().maps.moves_map.contains_key(&arg_expr.id));\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {\n@@ -722,8 +722,8 @@ pub fn trans_arg_expr(bcx: block,\n                     ast::by_val => {\n                         // NB: avoid running the take glue.\n \n-                        assert !bcx.ccx().maps.moves_map.contains_key(\n-                            &arg_expr.id);\n+                        fail_unless!(!bcx.ccx().maps.moves_map.contains_key(\n+                            &arg_expr.id));\n                         val = arg_datum.to_value_llval(bcx);\n                     }\n "}, {"sha": "b7a8e38dbb873e35e18889014af9dfa596223de6", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -271,7 +271,7 @@ pub fn build_closure(bcx0: block,\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n-                assert sigil == ast::BorrowedSigil;\n+                fail_unless!(sigil == ast::BorrowedSigil);\n                 env_vals.push(EnvValue {action: EnvRef,\n                                         datum: datum});\n             }"}, {"sha": "c4b80c504dabc2245899736038e613cefaa5992e", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1339,7 +1339,7 @@ pub fn monomorphize_type(bcx: block, t: ty::t) -> ty::t {\n         Some(substs) => {\n             ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n         }\n-        _ => { assert !ty::type_has_params(t); t }\n+        _ => { fail_unless!(!ty::type_has_params(t)); t }\n     }\n }\n "}, {"sha": "8971d9f56699e1ccd70571096a2745ab29a33b37", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -70,7 +70,7 @@ pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n pub fn const_ptrcast(cx: @CrateContext, a: ValueRef, t: TypeRef) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, T_ptr(t));\n-        assert cx.const_globals.insert(b as int, a);\n+        fail_unless!(cx.const_globals.insert(b as int, a));\n         b\n     }\n }\n@@ -100,7 +100,7 @@ pub fn const_deref(cx: @CrateContext, v: ValueRef) -> ValueRef {\n             Some(v) => v,\n             None => v\n         };\n-        assert llvm::LLVMIsGlobalConstant(v) == True;\n+        fail_unless!(llvm::LLVMIsGlobalConstant(v) == True);\n         let v = llvm::LLVMGetInitializer(v);\n         v\n     }\n@@ -290,7 +290,7 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n               let len = match ty::get(bt).sty {\n-                  ty::ty_estr(*) => {assert len > 0; len - 1},\n+                  ty::ty_estr(*) => {fail_unless!(len > 0); len - 1},\n                   _ => len\n               };\n               if iv >= len {\n@@ -417,14 +417,14 @@ fn const_expr_unchecked(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_path(pth) => {\n-            assert pth.types.len() == 0;\n+            fail_unless!(pth.types.len() == 0);\n             match cx.tcx.def_map.find(&e.id) {\n                 Some(ast::def_fn(def_id, _purity)) => {\n                     let f = if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx, def_id).ty;\n                         base::trans_external_path(cx, def_id, ty)\n                     } else {\n-                        assert ast_util::is_local(def_id);\n+                        fail_unless!(ast_util::is_local(def_id));\n                         base::get_item_val(cx, def_id.node)\n                     };\n                     let ety = ty::expr_ty_adjusted(cx.tcx, e);"}, {"sha": "59c143ebce710fc13bbcee6c6b53e8f9af951140", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -48,7 +48,7 @@ pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n             bcx = expr::trans_into(bcx, e, dest);\n         }\n         None => {\n-            assert dest == expr::Ignore || bcx.unreachable;\n+            fail_unless!(dest == expr::Ignore || bcx.unreachable);\n         }\n     }\n     return bcx;"}, {"sha": "556c15c446d2f6f4b83e57efc2e26f5c5d0d371c", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -253,19 +253,19 @@ pub impl Datum {\n                       action: CopyAction, datum: Datum) -> block {\n         debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n-        assert datum.mode.is_by_ref();\n+        fail_unless!(datum.mode.is_by_ref());\n         self.store_to(bcx, id, action, datum.val)\n     }\n \n     fn move_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n                     -> block {\n-        assert datum.mode.is_by_ref();\n+        fail_unless!(datum.mode.is_by_ref());\n         self.move_to(bcx, action, datum.val)\n     }\n \n     fn copy_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n                     -> block {\n-        assert datum.mode.is_by_ref();\n+        fail_unless!(datum.mode.is_by_ref());\n         self.copy_to(bcx, action, datum.val)\n     }\n \n@@ -378,7 +378,7 @@ pub impl Datum {\n          * Schedules this datum for cleanup in `bcx`.  The datum\n          * must be an rvalue. */\n \n-        assert self.source == RevokeClean;\n+        fail_unless!(self.source == RevokeClean);\n         match self.mode {\n             ByValue => {\n                 add_clean_temp_immediate(bcx, self.val, self.ty);\n@@ -399,7 +399,7 @@ pub impl Datum {\n                     // Lvalues which potentially need to be dropped\n                     // must be passed by ref, so that we can zero them\n                     // out.\n-                    assert self.mode.is_by_ref();\n+                    fail_unless!(self.mode.is_by_ref());\n                     zero_mem(bcx, self.val, self.ty);\n                 }\n             }\n@@ -705,7 +705,7 @@ pub impl Datum {\n                         // changing the type, so I am putting this\n                         // code in place here to do the right\n                         // thing if this change ever goes through.\n-                        assert ty::type_is_immediate(ty);\n+                        fail_unless!(ty::type_is_immediate(ty));\n                         (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 };\n@@ -746,7 +746,7 @@ pub impl Datum {\n                         // except for changing the type, so I am putting this\n                         // code in place here to do the right thing if this\n                         // change ever goes through.\n-                        assert ty::type_is_immediate(ty);\n+                        fail_unless!(ty::type_is_immediate(ty));\n                         (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 }\n@@ -806,7 +806,7 @@ pub impl Datum {\n         // either we were asked to deref a specific number of times,\n         // in which case we should have, or we asked to deref as many\n         // times as we can\n-        assert derefs == max || max == uint::max_value;\n+        fail_unless!(derefs == max || max == uint::max_value);\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n \n@@ -826,7 +826,7 @@ pub impl DatumBlock {\n     }\n \n     fn assert_by_ref(&self) -> DatumBlock {\n-        assert self.datum.mode.is_by_ref();\n+        fail_unless!(self.datum.mode.is_by_ref());\n         *self\n     }\n "}, {"sha": "7f9ff2a244ba388947c44ae42d886895ee27fce5", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -286,7 +286,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         debug!(\"add_env(closure_ty=%s)\", ty_to_str(tcx, closure_ty));\n         let scratch = scratch_datum(bcx, closure_ty, false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n-        assert datum.appropriate_mode() == ByValue;\n+        fail_unless!(datum.appropriate_mode() == ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n         let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n         Store(bcx, base::null_env_ptr(bcx), llenv);\n@@ -465,7 +465,7 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         }\n         ast::expr_binary(op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n-            assert !bcx.ccx().maps.method_map.contains_key(&expr.id);\n+            fail_unless!(!bcx.ccx().maps.method_map.contains_key(&expr.id));\n \n             return trans_binary(bcx, expr, op, lhs, rhs);\n         }\n@@ -1318,10 +1318,10 @@ fn trans_unary_datum(bcx: block,\n     let _icx = bcx.insn_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n-    assert op != ast::deref;\n+    fail_unless!(op != ast::deref);\n \n     // if overloaded, would be RvalueDpsExpr\n-    assert !bcx.ccx().maps.method_map.contains_key(&un_expr.id);\n+    fail_unless!(!bcx.ccx().maps.method_map.contains_key(&un_expr.id));\n \n     let un_ty = expr_ty(bcx, un_expr);\n     let sub_ty = expr_ty(bcx, sub_expr);"}, {"sha": "7f860bc0c855683d864992e82b1c658c91fb2993", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -398,7 +398,7 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     let ty_visitor_name = special_idents::ty_visitor;\n-    assert bcx.ccx().tcx.intrinsic_defs.contains_key(&ty_visitor_name);\n+    fail_unless!(bcx.ccx().tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n     let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(&ty_visitor_name);\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n     bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n@@ -486,7 +486,7 @@ pub fn trans_struct_drop(bcx: block,\n         // Class dtors have no explicit args, so the params should\n         // just consist of the output pointer and the environment\n         // (self)\n-        assert(params.len() == 2);\n+        fail_unless!((params.len() == 2));\n \n         // If we need to take a reference to the class (because it's using\n         // the Drop trait), do so now.\n@@ -670,7 +670,7 @@ pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n-    assert !*ccx.finished_tydescs;\n+    fail_unless!(!*ccx.finished_tydescs);\n \n     let llty = type_of(ccx, t);\n "}, {"sha": "f970d8f26b33b8bb1ed9290f11c55ebb19138493", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -56,8 +56,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         }\n     });\n \n-    for real_substs.each() |s| { assert !ty::type_has_params(*s); }\n-    for substs.each() |s| { assert !ty::type_has_params(*s); }\n+    for real_substs.each() |s| { fail_unless!(!ty::type_has_params(*s)); }\n+    for substs.each() |s| { fail_unless!(!ty::type_has_params(*s)); }\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     // XXX: Bad copy.\n     let hash_id = make_mono_id(ccx, fn_id, copy substs, vtables, impl_did_opt,"}, {"sha": "85c0bc80292b6c44357a5a213082e55b9a922c32", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -336,7 +336,7 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n                                  -> block {\n     use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n-    assert bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc);\n+    fail_unless!(bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc));\n     let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(&tydesc);\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n     let mut r = Reflector {"}, {"sha": "68eb0852445e08be83132babdbebeef253960881", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -70,7 +70,7 @@ pub fn type_of_fn_from_ty(cx: @CrateContext, fty: ty::t) -> TypeRef {\n }\n \n pub fn type_of_non_gc_box(cx: @CrateContext, t: ty::t) -> TypeRef {\n-    assert !ty::type_needs_infer(t);\n+    fail_unless!(!ty::type_needs_infer(t));\n \n     let t_norm = ty::normalize_ty(cx.tcx, t);\n     if t != t_norm {"}, {"sha": "350c1526ce0df72ed7d41f9911bf6eb69455a603", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1981,7 +1981,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // If this assertion failures, it is likely because of a\n                 // failure in the cross-crate inlining code to translate a\n                 // def-id.\n-                assert p.def_id.crate == ast::local_crate;\n+                fail_unless!(p.def_id.crate == ast::local_crate);\n \n                 param_bounds_to_contents(\n                     cx, cx.ty_param_bounds.get(&p.def_id.node))\n@@ -3519,7 +3519,7 @@ pub fn trait_supertraits(cx: ctxt,\n \n     // Not in the cache. It had better be in the metadata, which means it\n     // shouldn't be local.\n-    assert !is_local(id);\n+    fail_unless!(!is_local(id));\n \n     // Get the supertraits out of the metadata and create the\n     // InstantiatedTraitRef for each.\n@@ -3551,7 +3551,7 @@ pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n         // If the lookup in trait_method_cache fails, assume that the trait\n         // method we're trying to look up is in a different crate, and look\n         // for it there.\n-        assert id.crate != ast::local_crate;\n+        fail_unless!(id.crate != ast::local_crate);\n         let result = csearch::get_trait_methods(cx, id);\n \n         // Store the trait method in the local trait_method_cache so that\n@@ -3872,7 +3872,7 @@ pub fn lookup_item_type(cx: ctxt,\n         return tpt;\n       }\n       None => {\n-        assert did.crate != ast::local_crate;\n+        fail_unless!(did.crate != ast::local_crate);\n         let tyt = csearch::get_type(cx, did);\n         cx.tcache.insert(did, tyt);\n         return tyt;"}, {"sha": "65646cfcbb1d5e1018684fdd4da058742ba1fedc", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1806,7 +1806,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         if check_completeness {\n             // Make sure the programmer specified all the fields.\n-            assert fields_found <= field_types.len();\n+            fail_unless!(fields_found <= field_types.len());\n             if fields_found < field_types.len() {\n                 let mut missing_fields = ~[];\n                 for field_types.each |class_field| {\n@@ -3175,8 +3175,8 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n       ~\"visit_tydesc\" => {\n           let tydesc_name = special_idents::tydesc;\n           let ty_visitor_name = tcx.sess.ident_of(~\"TyVisitor\");\n-          assert tcx.intrinsic_defs.contains_key(&tydesc_name);\n-          assert ccx.tcx.intrinsic_defs.contains_key(&ty_visitor_name);\n+          fail_unless!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n+          fail_unless!(ccx.tcx.intrinsic_defs.contains_key(&ty_visitor_name));\n           let (_, tydesc_ty) = tcx.intrinsic_defs.get(&tydesc_name);\n           let (_, visitor_trait) = tcx.intrinsic_defs.get(&ty_visitor_name);\n           let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,"}, {"sha": "392182bee3f547de06738f3df11c10ecf113e1ac", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -712,8 +712,8 @@ pub mod guarantor {\n             ast::expr_copy(*) |\n             ast::expr_repeat(*) |\n             ast::expr_vec(*) => {\n-                assert !ty::expr_is_lval(\n-                    rcx.fcx.tcx(), rcx.fcx.ccx.method_map, expr);\n+                fail_unless!(!ty::expr_is_lval(\n+                    rcx.fcx.tcx(), rcx.fcx.ccx.method_map, expr));\n                 None\n             }\n         }"}, {"sha": "7c9ca4ba85a4cb3eb0c7737b7e774b87bdbd93c7", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -178,7 +178,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n         Some(ty) => ty,\n         None => {\n             // fixup_ty can only fail if this is early resolution\n-            assert is_early;\n+            fail_unless!(is_early);\n             // The type has unconstrained type variables in it, so we can't\n             // do early resolution on it. Return some completely bogus vtable\n             // information: we aren't storing it anyways.\n@@ -355,7 +355,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n                                                               is_early) {\n                                 Some(ref substs) => (/*bad*/copy *substs),\n                                 None => {\n-                                    assert is_early;\n+                                    fail_unless!(is_early);\n                                     // Bail out with a bogus answer\n                                     return Some(vtable_param(0, 0));\n                                 }"}, {"sha": "8abbb7a9909ff1002d578a5917f73d4395184575", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -811,7 +811,7 @@ pub impl CoherenceChecker {\n     }\n \n     fn span_of_impl(&self, implementation: @Impl) -> span {\n-        assert implementation.did.crate == local_crate;\n+        fail_unless!(implementation.did.crate == local_crate);\n         match self.crate_context.tcx.items.find(&implementation.did.node) {\n             Some(node_item(item, _)) => {\n                 return item.span;"}, {"sha": "9cb6c473d586ba9a464cc34904c3ef382a54dcb9", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -585,7 +585,7 @@ pub impl @mut InferCtxt {\n \n     /// Execute `f` and commit the bindings if successful\n     fn commit<T,E>(f: fn() -> Result<T,E>) -> Result<T,E> {\n-        assert !self.in_snapshot();\n+        fail_unless!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n         do indent {\n@@ -678,9 +678,9 @@ pub impl @mut InferCtxt {\n         let region_var = self.next_region_var_nb(span);\n \n         // add lb_region as a lower bound on the newly built variable\n-        assert self.region_vars.make_subregion(span,\n-                                               lb_region,\n-                                               region_var).is_ok();\n+        fail_unless!(self.region_vars.make_subregion(span,\n+                                                     lb_region,\n+                                                     region_var).is_ok());\n \n         return region_var;\n     }"}, {"sha": "e9843c8a075a07adb5a544cce9bf087c23187ea6", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -701,7 +701,7 @@ pub impl RegionVarBindings {\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n-                assert self.var_spans.len() == *vid + 1;\n+                fail_unless!(self.var_spans.len() == *vid + 1);\n                 self.var_spans.pop();\n               }\n               AddConstraint(ref constraint) => {\n@@ -758,7 +758,7 @@ pub impl RegionVarBindings {\n \n     fn add_constraint(&mut self, +constraint: Constraint, span: span) {\n         // cannot add constraints once regions are resolved\n-        assert self.values.is_empty();\n+        fail_unless!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: add_constraint(%?)\", constraint);\n \n@@ -774,7 +774,7 @@ pub impl RegionVarBindings {\n                       sub: Region,\n                       sup: Region) -> cres<()> {\n         // cannot add constraints once regions are resolved\n-        assert self.values.is_empty();\n+        fail_unless!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: make_subregion(%?, %?)\", sub, sup);\n         match (sub, sup) {\n@@ -816,7 +816,7 @@ pub impl RegionVarBindings {\n                    b: Region)\n                 -> cres<Region> {\n         // cannot add constraints once regions are resolved\n-        assert self.values.is_empty();\n+        fail_unless!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: lub_regions(%?, %?)\", a, b);\n         match (a, b) {\n@@ -842,7 +842,7 @@ pub impl RegionVarBindings {\n                    b: Region)\n                 -> cres<Region> {\n         // cannot add constraints once regions are resolved\n-        assert self.values.is_empty();\n+        fail_unless!(self.values.is_empty());\n \n         debug!(\"RegionVarBindings: glb_regions(%?, %?)\", a, b);\n         match (a, b) {\n@@ -1376,7 +1376,7 @@ pub impl RegionVarBindings {\n \n         return match a_node.value {\n             NoValue => {\n-                assert a_node.classification == Contracting;\n+                fail_unless!(a_node.classification == Contracting);\n                 a_node.value = Value(b_region);\n                 true // changed\n             }\n@@ -1634,15 +1634,15 @@ pub impl RegionVarBindings {\n                   }\n \n                   ConstrainRegSubVar(region, _) => {\n-                    assert dir == Incoming;\n+                    fail_unless!(dir == Incoming);\n                     result.push(SpannedRegion {\n                         region: region,\n                         span: edge.span\n                     });\n                   }\n \n                   ConstrainVarSubReg(_, region) => {\n-                    assert dir == Outgoing;\n+                    fail_unless!(dir == Outgoing);\n                     result.push(SpannedRegion {\n                         region: region,\n                         span: edge.span"}, {"sha": "bcbe08c28811089460748634f53a4afeae0037e1", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -114,9 +114,9 @@ pub impl ResolveState {\n         // n.b. This is a hokey mess because the current fold doesn't\n         // allow us to pass back errors in any useful way.\n \n-        assert vec::is_empty(self.v_seen);\n+        fail_unless!(vec::is_empty(self.v_seen));\n         let rty = indent(|| self.resolve_type(typ) );\n-        assert vec::is_empty(self.v_seen);\n+        fail_unless!(vec::is_empty(self.v_seen));\n         match self.err {\n           None => {\n             debug!(\"Resolved to %s + %s (modes=%x)\","}, {"sha": "867bcc30fa4ea30ab0a6441ee40374a7edfd5654", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -110,7 +110,7 @@ pub impl Env {\n                       m: &ast::_mod,\n                       idx: uint,\n                       names: &[~str]) -> Option<ast::node_id> {\n-            assert idx < names.len();\n+            fail_unless!(idx < names.len());\n             for m.items.each |item| {\n                 if self.tcx.sess.str_of(item.ident) == names[idx] {\n                     return search(self, *item, idx+1, names);"}, {"sha": "d692a66f69919af0dc547e43deaae61fb9dfa634", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -131,7 +131,7 @@ pub impl InferCtxt {\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n-            assert node_a.rank == node_b.rank;\n+            fail_unless!(node_a.rank == node_b.rank);\n             self.set(node_b.root, Redirect(node_a.root));\n             (node_a.root, node_a.rank + 1)\n         }"}, {"sha": "f0fc173101f2f7910427ea245295aded19ce59b6", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -59,8 +59,8 @@ impl region_scope for MethodRscope {\n         })\n     }\n     fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n-        assert self.region_parameterization.is_some() ||\n-            self.self_ty.is_borrowed();\n+        fail_unless!(self.region_parameterization.is_some() ||\n+            self.self_ty.is_borrowed());\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n     fn named_region(&self, span: span, id: ast::ident)\n@@ -94,7 +94,7 @@ impl region_scope for type_rscope {\n     fn self_region(&self, _span: span) -> Result<ty::Region, RegionError> {\n         // if the self region is used, region parameterization should\n         // have inferred that this type is RP\n-        assert self.is_some();\n+        fail_unless!(self.is_some());\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n     fn named_region(&self, span: span, id: ast::ident)"}, {"sha": "b5793cc0abde28d644f6c1b1f9c80a8b145dd592", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -145,7 +145,7 @@ fn should_prune_unconfigured_items() {\n     let source = ~\"#[cfg(shut_up_and_leave_me_alone)]fn a() { }\";\n     do from_str(source) |srv| {\n         do exec(srv) |ctxt| {\n-            assert vec::is_empty(ctxt.ast.node.module.items);\n+            fail_unless!(vec::is_empty(ctxt.ast.node.module.items));\n         }\n     }\n }\n@@ -155,7 +155,7 @@ fn srv_should_build_ast_map() {\n     let source = ~\"fn a() { }\";\n     do from_str(source) |srv| {\n         do exec(srv) |ctxt| {\n-            assert !ctxt.ast_map.is_empty()\n+            fail_unless!(!ctxt.ast_map.is_empty())\n         };\n     }\n }\n@@ -171,6 +171,6 @@ fn srv_should_return_request_result() {\n     let source = ~\"fn a() { }\";\n     do from_str(source) |srv| {\n         let result = exec(srv, |_ctxt| 1000 );\n-        assert result == 1000;\n+        fail_unless!(result == 1000);\n     }\n }"}, {"sha": "32966156eb108903765165dfb48970e98955a004", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -71,23 +71,23 @@ fn should_extract_crate_name_from_link_attribute() {\n     let source = ~\"#[link(name = \\\"snuggles\\\")]\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_crate(attrs);\n-    assert attrs.name == Some(~\"snuggles\");\n+    fail_unless!(attrs.name == Some(~\"snuggles\"));\n }\n \n #[test]\n fn should_not_extract_crate_name_if_no_link_attribute() {\n     let source = ~\"\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_crate(attrs);\n-    assert attrs.name == None;\n+    fail_unless!(attrs.name == None);\n }\n \n #[test]\n fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n     let source = ~\"#[link(whatever)]\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_crate(attrs);\n-    assert attrs.name == None;\n+    fail_unless!(attrs.name == None);\n }\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n@@ -106,15 +106,15 @@ fn parse_desc_should_handle_undocumented_mods() {\n     let source = ~\"\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_desc(attrs);\n-    assert attrs == None;\n+    fail_unless!(attrs == None);\n }\n \n #[test]\n fn parse_desc_should_parse_simple_doc_attributes() {\n     let source = ~\"#[doc = \\\"basic\\\"]\";\n     let attrs = test::parse_attributes(source);\n     let attrs = parse_desc(attrs);\n-    assert attrs == Some(~\"basic\");\n+    fail_unless!(attrs == Some(~\"basic\"));\n }\n \n pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n@@ -133,28 +133,28 @@ pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n fn should_parse_hidden_attribute() {\n     let source = ~\"#[doc(hidden)]\";\n     let attrs = test::parse_attributes(source);\n-    assert parse_hidden(attrs) == true;\n+    fail_unless!(parse_hidden(attrs) == true);\n }\n \n #[test]\n fn should_parse_hidden_attribute_with_other_docs() {\n     let source = ~\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n     let attrs = test::parse_attributes(source);\n-    assert parse_hidden(attrs) == true;\n+    fail_unless!(parse_hidden(attrs) == true);\n }\n \n #[test]\n fn should_not_parse_non_hidden_attribute() {\n     let source = ~\"#[doc = \\\"\\\"]\";\n     let attrs = test::parse_attributes(source);\n-    assert parse_hidden(attrs) == false;\n+    fail_unless!(parse_hidden(attrs) == false);\n }\n \n #[test]\n fn should_concatenate_multiple_doc_comments() {\n     let source = ~\"/// foo\\n/// bar\";\n     let desc = parse_desc(test::parse_attributes(source));\n-    assert desc == Some(~\"foo\\nbar\");\n+    fail_unless!(desc == Some(~\"foo\\nbar\"));\n }\n \n "}, {"sha": "5e3fdf19ad3d8a608e110776f983f64a45b18c56", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -83,7 +83,7 @@ fn fold_crate(\n #[test]\n fn should_replace_top_module_name_with_crate_name() {\n     let doc = test::mk_doc(~\"#[link(name = \\\"bond\\\")];\");\n-    assert doc.cratemod().name() == ~\"bond\";\n+    fail_unless!(doc.cratemod().name() == ~\"bond\");\n }\n \n fn fold_item(\n@@ -126,25 +126,25 @@ fn parse_item_attrs<T:Owned>(\n #[test]\n fn should_should_extract_mod_attributes() {\n     let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] mod a { }\");\n-    assert doc.cratemod().mods()[0].desc() == Some(~\"test\");\n+    fail_unless!(doc.cratemod().mods()[0].desc() == Some(~\"test\"));\n }\n \n #[test]\n fn should_extract_top_mod_attributes() {\n     let doc = test::mk_doc(~\"#[doc = \\\"test\\\"];\");\n-    assert doc.cratemod().desc() == Some(~\"test\");\n+    fail_unless!(doc.cratemod().desc() == Some(~\"test\"));\n }\n \n #[test]\n fn should_extract_foreign_fn_attributes() {\n     let doc = test::mk_doc(~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\");\n+    fail_unless!(doc.cratemod().nmods()[0].fns[0].desc() == Some(~\"test\"));\n }\n \n #[test]\n fn should_extract_fn_attributes() {\n     let doc = test::mk_doc(~\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n-    assert doc.cratemod().fns()[0].desc() == Some(~\"test\");\n+    fail_unless!(doc.cratemod().fns()[0].desc() == Some(~\"test\"));\n }\n \n fn fold_enum(\n@@ -196,13 +196,13 @@ fn fold_enum(\n fn should_extract_enum_docs() {\n     let doc = test::mk_doc(~\"#[doc = \\\"b\\\"]\\\n                             enum a { v }\");\n-    assert doc.cratemod().enums()[0].desc() == Some(~\"b\");\n+    fail_unless!(doc.cratemod().enums()[0].desc() == Some(~\"b\"));\n }\n \n #[test]\n fn should_extract_variant_docs() {\n     let doc = test::mk_doc(~\"enum a { #[doc = \\\"c\\\"] v }\");\n-    assert doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\");\n+    fail_unless!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"c\"));\n }\n \n fn fold_trait(\n@@ -255,7 +255,7 @@ fn merge_method_attrs(\n     };\n \n     do vec::map2(docs, attrs) |doc, attrs| {\n-        assert doc.name == attrs.first();\n+        fail_unless!(doc.name == attrs.first());\n         let desc = attrs.second();\n \n         doc::MethodDoc {\n@@ -268,7 +268,7 @@ fn merge_method_attrs(\n #[test]\n fn should_extract_trait_docs() {\n     let doc = test::mk_doc(~\"#[doc = \\\"whatever\\\"] trait i { fn a(); }\");\n-    assert doc.cratemod().traits()[0].desc() == Some(~\"whatever\");\n+    fail_unless!(doc.cratemod().traits()[0].desc() == Some(~\"whatever\"));\n }\n \n #[test]\n@@ -278,7 +278,7 @@ fn should_extract_trait_method_docs() {\n          #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool;\\\n          }\");\n-    assert doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"desc\"));\n }\n \n \n@@ -299,7 +299,7 @@ fn fold_impl(\n fn should_extract_impl_docs() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\"whatever\\\"] impl int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].desc() == Some(~\"whatever\");\n+    fail_unless!(doc.cratemod().impls()[0].desc() == Some(~\"whatever\"));\n }\n \n #[test]\n@@ -309,7 +309,7 @@ fn should_extract_impl_method_docs() {\n          #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool { }\\\n          }\");\n-    assert doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"desc\"));\n }\n \n #[cfg(test)]"}, {"sha": "956d6ba2c5bfdf7ccf5b78193132eff7276a18c6", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -266,7 +266,7 @@ fn should_find_pandoc() {\n         ProgramOutput { status: 0, out: ~\"pandoc 1.8.2.1\", err: ~\"\" }\n     };\n     let result = maybe_find_pandoc(&config, None, mock_program_output);\n-    assert result == result::Ok(Some(~\"pandoc\"));\n+    fail_unless!(result == result::Ok(Some(~\"pandoc\")));\n }\n \n #[test]\n@@ -279,7 +279,7 @@ fn should_error_with_no_pandoc() {\n         ProgramOutput { status: 1, out: ~\"\", err: ~\"\" }\n     };\n     let result = maybe_find_pandoc(&config, None, mock_program_output);\n-    assert result == result::Err(~\"couldn't find pandoc\");\n+    fail_unless!(result == result::Err(~\"couldn't find pandoc\"));\n }\n \n #[cfg(test)]\n@@ -296,100 +296,100 @@ mod test {\n #[test]\n fn should_error_with_no_crates() {\n     let config = test::parse_config(~[~\"rustdoc\"]);\n-    assert config.get_err() == ~\"no crates specified\";\n+    fail_unless!(config.get_err() == ~\"no crates specified\");\n }\n \n #[test]\n fn should_error_with_multiple_crates() {\n     let config =\n         test::parse_config(~[~\"rustdoc\", ~\"crate1.rc\", ~\"crate2.rc\"]);\n-    assert config.get_err() == ~\"multiple crates specified\";\n+    fail_unless!(config.get_err() == ~\"multiple crates specified\");\n }\n \n #[test]\n fn should_set_output_dir_to_cwd_if_not_provided() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert config.get().output_dir == Path(\".\");\n+    fail_unless!(config.get().output_dir == Path(\".\"));\n }\n \n #[test]\n fn should_set_output_dir_if_provided() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-dir\", ~\"snuggles\"\n     ]);\n-    assert config.get().output_dir == Path(\"snuggles\");\n+    fail_unless!(config.get().output_dir == Path(\"snuggles\"));\n }\n \n #[test]\n fn should_set_output_format_to_pandoc_html_if_not_provided() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert config.get().output_format == PandocHtml;\n+    fail_unless!(config.get().output_format == PandocHtml);\n }\n \n #[test]\n fn should_set_output_format_to_markdown_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"markdown\"\n     ]);\n-    assert config.get().output_format == Markdown;\n+    fail_unless!(config.get().output_format == Markdown);\n }\n \n #[test]\n fn should_set_output_format_to_pandoc_html_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"html\"\n     ]);\n-    assert config.get().output_format == PandocHtml;\n+    fail_unless!(config.get().output_format == PandocHtml);\n }\n \n #[test]\n fn should_error_on_bogus_format() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-format\", ~\"bogus\"\n     ]);\n-    assert config.get_err() == ~\"unknown output format 'bogus'\";\n+    fail_unless!(config.get_err() == ~\"unknown output format 'bogus'\");\n }\n \n #[test]\n fn should_set_output_style_to_doc_per_mod_by_default() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert config.get().output_style == DocPerMod;\n+    fail_unless!(config.get().output_style == DocPerMod);\n }\n \n #[test]\n fn should_set_output_style_to_one_doc_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-crate\"\n     ]);\n-    assert config.get().output_style == DocPerCrate;\n+    fail_unless!(config.get().output_style == DocPerCrate);\n }\n \n #[test]\n fn should_set_output_style_to_doc_per_mod_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"doc-per-mod\"\n     ]);\n-    assert config.get().output_style == DocPerMod;\n+    fail_unless!(config.get().output_style == DocPerMod);\n }\n \n #[test]\n fn should_error_on_bogus_output_style() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--output-style\", ~\"bogus\"\n     ]);\n-    assert config.get_err() == ~\"unknown output style 'bogus'\";\n+    fail_unless!(config.get_err() == ~\"unknown output style 'bogus'\");\n }\n \n #[test]\n fn should_set_pandoc_command_if_requested() {\n     let config = test::parse_config(~[\n         ~\"rustdoc\", ~\"crate.rc\", ~\"--pandoc-cmd\", ~\"panda-bear-doc\"\n     ]);\n-    assert config.get().pandoc_cmd == Some(~\"panda-bear-doc\");\n+    fail_unless!(config.get().pandoc_cmd == Some(~\"panda-bear-doc\"));\n }\n \n #[test]\n fn should_set_pandoc_command_when_using_pandoc() {\n     let config = test::parse_config(~[~\"rustdoc\", ~\"crate.rc\"]);\n-    assert config.get().pandoc_cmd == Some(~\"pandoc\");\n+    fail_unless!(config.get().pandoc_cmd == Some(~\"pandoc\"));\n }"}, {"sha": "a0733121b7cb6116c8002b44ba5f3a1f178194a3", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -84,20 +84,20 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n #[test]\n fn should_promote_desc() {\n     let doc = test::mk_doc(~\"#[doc = \\\"desc\\\"] mod m { }\");\n-    assert doc.cratemod().mods()[0].brief() == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().mods()[0].brief() == Some(~\"desc\"));\n }\n \n #[test]\n fn should_promote_trait_method_desc() {\n     let doc = test::mk_doc(~\"trait i { #[doc = \\\"desc\\\"] fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].brief == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].brief == Some(~\"desc\"));\n }\n \n #[test]\n fn should_promote_impl_method_desc() {\n     let doc = test::mk_doc(\n         ~\"impl int { #[doc = \\\"desc\\\"] fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"desc\"));\n }\n \n #[cfg(test)]\n@@ -221,20 +221,20 @@ fn paragraphs(s: &str) -> ~[~str] {\n #[test]\n fn test_paragraphs_1() {\n     let paras = paragraphs(~\"1\\n\\n2\");\n-    assert paras == ~[~\"1\", ~\"2\"];\n+    fail_unless!(paras == ~[~\"1\", ~\"2\"]);\n }\n \n #[test]\n fn test_paragraphs_2() {\n     let paras = paragraphs(~\"\\n\\n1\\n1\\n\\n2\\n\\n\");\n-    assert paras == ~[~\"1\\n1\", ~\"2\"];\n+    fail_unless!(paras == ~[~\"1\\n1\", ~\"2\"]);\n }\n \n #[test]\n fn should_promote_short_descs() {\n     let desc = Some(~\"desc\");\n     let brief = extract(copy desc);\n-    assert brief == desc;\n+    fail_unless!(brief == desc);\n }\n \n #[test]\n@@ -248,7 +248,7 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    assert brief == None;\n+    fail_unless!(brief == None);\n }\n \n #[test]\n@@ -262,8 +262,8 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    assert brief == Some(\n-        ~\"Warkworth Castle is a ruined medieval building in the town\");\n+    fail_unless!(brief == Some(\n+        ~\"Warkworth Castle is a ruined medieval building in the town\"));\n }\n \n #[test]\n@@ -277,8 +277,8 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    assert brief == Some(\n-        ~\"Warkworth..Castle is a ruined medieval building in the town\");\n+    fail_unless!(brief == Some(\n+        ~\"Warkworth..Castle is a ruined medieval building in the town\"));\n }\n \n #[test]\n@@ -292,6 +292,6 @@ Scotland in the mid 12th century, although it may have been built by\n King Henry II of England when he took control of England'snorthern\n counties.\");\n     let brief = extract(desc);\n-    assert brief == Some(\n-        ~\"Warkworth... Castle is a ruined medieval building in the town\");\n+    fail_unless!(brief == Some(\n+        ~\"Warkworth... Castle is a ruined medieval building in the town\"));\n }"}, {"sha": "1eb8c0e6eca596c6311ca4dcb6839a8d4a8d6837", "filename": "src/librustdoc/escape_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fescape_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fescape_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fescape_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -27,5 +27,5 @@ fn escape(s: &str) -> ~str {\n fn should_escape_backslashes() {\n     let s = ~\"\\\\n\";\n     let r = escape(s);\n-    assert r == ~\"\\\\\\\\n\";\n+    fail_unless!(r == ~\"\\\\\\\\n\");\n }"}, {"sha": "ba6e102785aed3241a60c52b24be1f3e77e2894e", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -185,8 +185,8 @@ fn constdoc_from_const(itemdoc: doc::ItemDoc) -> doc::ConstDoc {\n #[test]\n fn should_extract_const_name_and_id() {\n     let doc = test::mk_doc(~\"const a: int = 0;\");\n-    assert doc.cratemod().consts()[0].id() != 0;\n-    assert doc.cratemod().consts()[0].name() == ~\"a\";\n+    fail_unless!(doc.cratemod().consts()[0].id() != 0);\n+    fail_unless!(doc.cratemod().consts()[0].name() == ~\"a\");\n }\n \n fn enumdoc_from_enum(\n@@ -216,14 +216,14 @@ fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n #[test]\n fn should_extract_enums() {\n     let doc = test::mk_doc(~\"enum e { v }\");\n-    assert doc.cratemod().enums()[0].id() != 0;\n-    assert doc.cratemod().enums()[0].name() == ~\"e\";\n+    fail_unless!(doc.cratemod().enums()[0].id() != 0);\n+    fail_unless!(doc.cratemod().enums()[0].name() == ~\"e\");\n }\n \n #[test]\n fn should_extract_enum_variants() {\n     let doc = test::mk_doc(~\"enum e { v }\");\n-    assert doc.cratemod().enums()[0].variants[0].name == ~\"v\";\n+    fail_unless!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n }\n \n fn traitdoc_from_trait(\n@@ -262,13 +262,13 @@ fn traitdoc_from_trait(\n #[test]\n fn should_extract_traits() {\n     let doc = test::mk_doc(~\"trait i { fn f(); }\");\n-    assert doc.cratemod().traits()[0].name() == ~\"i\";\n+    fail_unless!(doc.cratemod().traits()[0].name() == ~\"i\");\n }\n \n #[test]\n fn should_extract_trait_methods() {\n     let doc = test::mk_doc(~\"trait i { fn f(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].name == ~\"f\";\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n }\n \n fn impldoc_from_impl(\n@@ -295,7 +295,7 @@ fn impldoc_from_impl(\n #[test]\n fn should_extract_impl_methods() {\n     let doc = test::mk_doc(~\"impl int { fn f() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].name == ~\"f\";\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n }\n \n fn tydoc_from_ty(\n@@ -310,7 +310,7 @@ fn tydoc_from_ty(\n #[test]\n fn should_extract_tys() {\n     let doc = test::mk_doc(~\"type a = int;\");\n-    assert doc.cratemod().types()[0].name() == ~\"a\";\n+    fail_unless!(doc.cratemod().types()[0].name() == ~\"a\");\n }\n \n fn structdoc_from_struct(\n@@ -333,13 +333,13 @@ fn structdoc_from_struct(\n #[test]\n fn should_extract_structs() {\n     let doc = test::mk_doc(~\"struct Foo { field: () }\");\n-    assert doc.cratemod().structs()[0].name() == ~\"Foo\";\n+    fail_unless!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n }\n \n #[test]\n fn should_extract_struct_fields() {\n     let doc = test::mk_doc(~\"struct Foo { field: () }\");\n-    assert doc.cratemod().structs()[0].fields[0] == ~\"field\";\n+    fail_unless!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n }\n \n #[cfg(test)]\n@@ -359,34 +359,34 @@ mod test {\n     #[test]\n     pub fn extract_empty_crate() {\n         let doc = mk_doc(~\"\");\n-        assert vec::is_empty(doc.cratemod().mods());\n-        assert vec::is_empty(doc.cratemod().fns());\n+        fail_unless!(vec::is_empty(doc.cratemod().mods()));\n+        fail_unless!(vec::is_empty(doc.cratemod().fns()));\n     }\n \n     #[test]\n     pub fn extract_mods() {\n         let doc = mk_doc(~\"mod a { mod b { } mod c { } }\");\n-        assert doc.cratemod().mods()[0].name() == ~\"a\";\n-        assert doc.cratemod().mods()[0].mods()[0].name() == ~\"b\";\n-        assert doc.cratemod().mods()[0].mods()[1].name() == ~\"c\";\n+        fail_unless!(doc.cratemod().mods()[0].name() == ~\"a\");\n+        fail_unless!(doc.cratemod().mods()[0].mods()[0].name() == ~\"b\");\n+        fail_unless!(doc.cratemod().mods()[0].mods()[1].name() == ~\"c\");\n     }\n \n     #[test]\n     pub fn extract_fns_from_foreign_mods() {\n         let doc = mk_doc(~\"extern { fn a(); }\");\n-        assert doc.cratemod().nmods()[0].fns[0].name() == ~\"a\";\n+        fail_unless!(doc.cratemod().nmods()[0].fns[0].name() == ~\"a\");\n     }\n \n     #[test]\n     pub fn extract_mods_deep() {\n         let doc = mk_doc(~\"mod a { mod b { mod c { } } }\");\n-        assert doc.cratemod().mods()[0].mods()[0].mods()[0].name() == ~\"c\";\n+        fail_unless!(doc.cratemod().mods()[0].mods()[0].mods()[0].name() == ~\"c\");\n     }\n \n     #[test]\n     pub fn extract_should_set_mod_ast_id() {\n         let doc = mk_doc(~\"mod a { }\");\n-        assert doc.cratemod().mods()[0].id() != 0;\n+        fail_unless!(doc.cratemod().mods()[0].id() != 0);\n     }\n \n     #[test]\n@@ -395,30 +395,30 @@ mod test {\n             ~\"fn a() { } \\\n               mod b { fn c() {\n              } }\");\n-        assert doc.cratemod().fns()[0].name() == ~\"a\";\n-        assert doc.cratemod().mods()[0].fns()[0].name() == ~\"c\";\n+        fail_unless!(doc.cratemod().fns()[0].name() == ~\"a\");\n+        fail_unless!(doc.cratemod().mods()[0].fns()[0].name() == ~\"c\");\n     }\n \n     #[test]\n     pub fn extract_should_set_fn_ast_id() {\n         let doc = mk_doc(~\"fn a() { }\");\n-        assert doc.cratemod().fns()[0].id() != 0;\n+        fail_unless!(doc.cratemod().fns()[0].id() != 0);\n     }\n \n     #[test]\n     pub fn extract_should_use_default_crate_name() {\n         let source = ~\"\";\n         let ast = parse::from_str(source);\n         let doc = extract(ast, ~\"burp\");\n-        assert doc.cratemod().name() == ~\"burp\";\n+        fail_unless!(doc.cratemod().name() == ~\"burp\");\n     }\n \n     #[test]\n     pub fn extract_from_seq_srv() {\n         let source = ~\"\";\n         do astsrv::from_str(source) |srv| {\n             let doc = from_srv(srv, ~\"name\");\n-            assert doc.cratemod().name() == ~\"name\";\n+            fail_unless!(doc.cratemod().name() == ~\"name\");\n         }\n     }\n }"}, {"sha": "e9d9732d51fd33a961357da61bc35f615f135a4d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -373,7 +373,7 @@ fn default_fold_should_produce_same_doc() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert doc == folded;\n+    fail_unless!(doc == folded);\n }\n \n #[test]\n@@ -383,7 +383,7 @@ fn default_fold_should_produce_same_consts() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert doc == folded;\n+    fail_unless!(doc == folded);\n }\n \n #[test]\n@@ -393,7 +393,7 @@ fn default_fold_should_produce_same_enums() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert doc == folded;\n+    fail_unless!(doc == folded);\n }\n \n #[test]\n@@ -403,5 +403,5 @@ fn default_parallel_fold_should_produce_same_doc() {\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_par_fold(());\n     let folded = (fld.fold_doc)(&fld, copy doc);\n-    assert doc == folded;\n+    fail_unless!(doc == folded);\n }"}, {"sha": "b18694d00dbee0b40382faf44438a77f8797223d", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -160,15 +160,15 @@ fn pandoc_header_id(header: &str) -> ~str {\n \n #[test]\n fn should_remove_punctuation_from_headers() {\n-    assert pandoc_header_id(~\"impl foo of bar<A>\") == ~\"impl-foo-of-bara\";\n-    assert pandoc_header_id(~\"impl of num::num for int\")\n-        == ~\"impl-of-numnum-for-int\";\n-    assert pandoc_header_id(~\"impl of num::num for int/&\")\n-        == ~\"impl-of-numnum-for-int\";\n-    assert pandoc_header_id(~\"impl of num::num for ^int\")\n-        == ~\"impl-of-numnum-for-int\";\n-    assert pandoc_header_id(~\"impl for & condvar\")\n-        == ~\"impl-for-condvar\";\n+    fail_unless!(pandoc_header_id(~\"impl foo of bar<A>\") == ~\"impl-foo-of-bara\");\n+    fail_unless!(pandoc_header_id(~\"impl of num::num for int\")\n+        == ~\"impl-of-numnum-for-int\");\n+    fail_unless!(pandoc_header_id(~\"impl of num::num for int/&\")\n+        == ~\"impl-of-numnum-for-int\");\n+    fail_unless!(pandoc_header_id(~\"impl of num::num for ^int\")\n+        == ~\"impl-of-numnum-for-int\");\n+    fail_unless!(pandoc_header_id(~\"impl for & condvar\")\n+        == ~\"impl-for-condvar\");\n }\n \n #[test]\n@@ -177,18 +177,18 @@ fn should_index_mod_contents() {\n         config::DocPerCrate,\n         ~\"mod a { } fn b() { }\"\n     );\n-    assert (&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+    fail_unless!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n         kind: ~\"Module\",\n         name: ~\"a\",\n         brief: None,\n         link: ~\"#module-a\"\n-    };\n-    assert (&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+    });\n+    fail_unless!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,\n         link: ~\"#function-b\"\n-    };\n+    });\n }\n \n #[test]\n@@ -197,18 +197,18 @@ fn should_index_mod_contents_multi_page() {\n         config::DocPerMod,\n         ~\"mod a { } fn b() { }\"\n     );\n-    assert (&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+    fail_unless!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n         kind: ~\"Module\",\n         name: ~\"a\",\n         brief: None,\n         link: ~\"a.html\"\n-    };\n-    assert (&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+    });\n+    fail_unless!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,\n         link: ~\"#function-b\"\n-    };\n+    });\n }\n \n #[test]\n@@ -217,12 +217,12 @@ fn should_index_foreign_mod_pages() {\n         config::DocPerMod,\n         ~\"extern mod a { }\"\n     );\n-    assert (&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+    fail_unless!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n         kind: ~\"Foreign module\",\n         name: ~\"a\",\n         brief: None,\n         link: ~\"a.html\"\n-    };\n+    });\n }\n \n #[test]\n@@ -231,8 +231,8 @@ fn should_add_brief_desc_to_index() {\n         config::DocPerMod,\n         ~\"#[doc = \\\"test\\\"] mod a { }\"\n     );\n-    assert (&doc.cratemod().index).get().entries[0].brief\n-        == Some(~\"test\");\n+    fail_unless!((&doc.cratemod().index).get().entries[0].brief\n+        == Some(~\"test\"));\n }\n \n #[test]\n@@ -241,13 +241,13 @@ fn should_index_foreign_mod_contents() {\n         config::DocPerCrate,\n         ~\"extern mod a { fn b(); }\"\n     );\n-    assert (&doc.cratemod().nmods()[0].index).get().entries[0]\n+    fail_unless!((&doc.cratemod().nmods()[0].index).get().entries[0]\n         == doc::IndexEntry {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,\n         link: ~\"#function-b\"\n-    };\n+    });\n }\n \n #[cfg(test)]"}, {"sha": "888814f9e7b98bdf4b21b9ba0c6c34401b9775c9", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -91,9 +91,9 @@ fn should_write_modules_last() {\n     let idx_c = str::find_str(markdown, ~\"# Module `c`\").get();\n     let idx_d = str::find_str(markdown, ~\"## Function `d`\").get();\n \n-    assert idx_b < idx_d;\n-    assert idx_d < idx_a;\n-    assert idx_a < idx_c;\n+    fail_unless!(idx_b < idx_d);\n+    fail_unless!(idx_d < idx_a);\n+    fail_unless!(idx_a < idx_c);\n }\n \n struct Ctxt {\n@@ -175,10 +175,10 @@ fn should_write_title_for_each_page() {\n         let (page, markdown) = po.recv();\n         match page {\n           doc::CratePage(_) => {\n-            assert str::contains(markdown, ~\"% Crate core\");\n+            fail_unless!(str::contains(markdown, ~\"% Crate core\"));\n           }\n           doc::ItemPage(_) => {\n-            assert str::contains(markdown, ~\"% Module a\");\n+            fail_unless!(str::contains(markdown, ~\"% Module a\"));\n           }\n         }\n     }\n@@ -248,7 +248,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n         fullpath\n       }\n       &doc::ImplTag(ref doc) => {\n-        assert doc.self_ty.is_some();\n+        fail_unless!(doc.self_ty.is_some());\n         let self_ty = (&doc.self_ty).get();\n         let mut trait_part = ~\"\";\n         for doc.trait_types.eachi |i, trait_type| {\n@@ -314,7 +314,7 @@ fn write_mod(\n #[test]\n fn should_write_full_path_to_mod() {\n     let markdown = test::render(~\"mod a { mod b { mod c { } } }\");\n-    assert str::contains(markdown, ~\"# Module `a::b::c`\");\n+    fail_unless!(str::contains(markdown, ~\"# Module `a::b::c`\"));\n }\n \n fn write_common(\n@@ -359,7 +359,7 @@ fn should_write_sections() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"#### Header\\n\\nBody\\n\\n\"));\n }\n \n fn write_mod_contents(\n@@ -416,7 +416,7 @@ fn item_header_lvl(doc: &doc::ItemTag) -> Hlvl {\n #[test]\n fn should_write_crate_description() {\n     let markdown = test::render(~\"#[doc = \\\"this is the crate\\\"];\");\n-    assert str::contains(markdown, ~\"this is the crate\");\n+    fail_unless!(str::contains(markdown, ~\"this is the crate\"));\n }\n \n fn write_index(ctxt: &Ctxt, index: doc::Index) {\n@@ -440,32 +440,32 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n #[test]\n fn should_write_index() {\n     let markdown = test::render(~\"mod a { } mod b { }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         markdown,\n         ~\"\\n\\n* [Module `a`](#module-a)\\n\\\n          * [Module `b`](#module-b)\\n\\n\"\n-    );\n+    ));\n }\n \n #[test]\n fn should_write_index_brief() {\n     let markdown = test::render(~\"#[doc = \\\"test\\\"] mod a { }\");\n-    assert str::contains(markdown, ~\"(#module-a) - test\\n\");\n+    fail_unless!(str::contains(markdown, ~\"(#module-a) - test\\n\"));\n }\n \n #[test]\n fn should_not_write_index_if_no_entries() {\n     let markdown = test::render(~\"\");\n-    assert !str::contains(markdown, ~\"\\n\\n\\n\");\n+    fail_unless!(!str::contains(markdown, ~\"\\n\\n\\n\"));\n }\n \n #[test]\n fn should_write_index_for_foreign_mods() {\n     let markdown = test::render(~\"extern mod a { fn a(); }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         markdown,\n         ~\"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n-    );\n+    ));\n }\n \n fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n@@ -483,22 +483,22 @@ fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n #[test]\n fn should_write_foreign_mods() {\n     let markdown = test::render(~\"#[doc = \\\"test\\\"] extern mod a { }\");\n-    assert str::contains(markdown, ~\"Foreign module `a`\");\n-    assert str::contains(markdown, ~\"test\");\n+    fail_unless!(str::contains(markdown, ~\"Foreign module `a`\"));\n+    fail_unless!(str::contains(markdown, ~\"test\"));\n }\n \n #[test]\n fn should_write_foreign_fns() {\n     let markdown = test::render(\n         ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert str::contains(markdown, ~\"test\");\n+    fail_unless!(str::contains(markdown, ~\"test\"));\n }\n \n #[test]\n fn should_write_foreign_fn_headers() {\n     let markdown = test::render(\n         ~\"extern mod a { #[doc = \\\"test\\\"] fn a(); }\");\n-    assert str::contains(markdown, ~\"## Function `a`\");\n+    fail_unless!(str::contains(markdown, ~\"## Function `a`\"));\n }\n \n fn write_fn(\n@@ -542,19 +542,19 @@ fn code_block_indent(s: ~str) -> ~str {\n #[test]\n fn write_markdown_should_write_function_header() {\n     let markdown = test::render(~\"fn func() { }\");\n-    assert str::contains(markdown, ~\"## Function `func`\");\n+    fail_unless!(str::contains(markdown, ~\"## Function `func`\"));\n }\n \n #[test]\n fn should_write_the_function_signature() {\n     let markdown = test::render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-    assert str::contains(markdown, ~\"\\n    fn a()\\n\");\n+    fail_unless!(str::contains(markdown, ~\"\\n    fn a()\\n\"));\n }\n \n #[test]\n fn should_insert_blank_line_after_fn_signature() {\n     let markdown = test::render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-    assert str::contains(markdown, ~\"fn a()\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"fn a()\\n\\n\"));\n }\n \n #[test]\n@@ -575,13 +575,13 @@ fn should_correctly_indent_fn_signature() {\n         ]\n     };\n     let markdown = test::write_markdown_str(doc);\n-    assert str::contains(markdown, ~\"    line 1\\n    line 2\");\n+    fail_unless!(str::contains(markdown, ~\"    line 1\\n    line 2\"));\n }\n \n #[test]\n fn should_leave_blank_line_between_fn_header_and_sig() {\n     let markdown = test::render(~\"fn a() { }\");\n-    assert str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\");\n+    fail_unless!(str::contains(markdown, ~\"Function `a`\\n\\n    fn a()\"));\n }\n \n fn write_const(\n@@ -595,15 +595,15 @@ fn write_const(\n #[test]\n fn should_write_const_header() {\n     let markdown = test::render(~\"const a: bool = true;\");\n-    assert str::contains(markdown, ~\"## Const `a`\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"## Const `a`\\n\\n\"));\n }\n \n #[test]\n fn should_write_const_description() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"b\\\"]\\\n          const a: bool = true;\");\n-    assert str::contains(markdown, ~\"\\n\\nb\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n }\n \n fn write_enum(\n@@ -617,14 +617,14 @@ fn write_enum(\n #[test]\n fn should_write_enum_header() {\n     let markdown = test::render(~\"enum a { b }\");\n-    assert str::contains(markdown, ~\"## Enum `a`\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"## Enum `a`\\n\\n\"));\n }\n \n #[test]\n fn should_write_enum_description() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"b\\\"] enum a { b }\");\n-    assert str::contains(markdown, ~\"\\n\\nb\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"\\n\\nb\\n\\n\"));\n }\n \n fn write_variants(\n@@ -645,7 +645,7 @@ fn write_variants(\n }\n \n fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n-    assert doc.sig.is_some();\n+    fail_unless!(doc.sig.is_some());\n     let sig = (&doc.sig).get();\n     match copy doc.desc {\n       Some(desc) => {\n@@ -663,31 +663,31 @@ fn should_write_variant_list() {\n         ~\"enum a { \\\n          #[doc = \\\"test\\\"] b, \\\n          #[doc = \\\"test\\\"] c }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         markdown,\n         ~\"\\n\\n#### Variants\\n\\\n          \\n* `b` - test\\\n-         \\n* `c` - test\\n\\n\");\n+         \\n* `c` - test\\n\\n\"));\n }\n \n #[test]\n fn should_write_variant_list_without_descs() {\n     let markdown = test::render(~\"enum a { b, c }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         markdown,\n         ~\"\\n\\n#### Variants\\n\\\n          \\n* `b`\\\n-         \\n* `c`\\n\\n\");\n+         \\n* `c`\\n\\n\"));\n }\n \n #[test]\n fn should_write_variant_list_with_signatures() {\n     let markdown = test::render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         markdown,\n         ~\"\\n\\n#### Variants\\n\\\n          \\n* `b(int)`\\\n-         \\n* `c(int)` - a\\n\\n\");\n+         \\n* `c(int)` - a\\n\\n\"));\n }\n \n fn write_trait(ctxt: &Ctxt, doc: doc::TraitDoc) {\n@@ -714,28 +714,28 @@ fn write_method(ctxt: &Ctxt, doc: doc::MethodDoc) {\n #[test]\n fn should_write_trait_header() {\n     let markdown = test::render(~\"trait i { fn a(); }\");\n-    assert str::contains(markdown, ~\"## Trait `i`\");\n+    fail_unless!(str::contains(markdown, ~\"## Trait `i`\"));\n }\n \n #[test]\n fn should_write_trait_desc() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n-    assert str::contains(markdown, ~\"desc\");\n+    fail_unless!(str::contains(markdown, ~\"desc\"));\n }\n \n #[test]\n fn should_write_trait_method_header() {\n     let markdown = test::render(\n         ~\"trait i { fn a(); }\");\n-    assert str::contains(markdown, ~\"### Method `a`\");\n+    fail_unless!(str::contains(markdown, ~\"### Method `a`\"));\n }\n \n #[test]\n fn should_write_trait_method_signature() {\n     let markdown = test::render(\n         ~\"trait i { fn a(); }\");\n-    assert str::contains(markdown, ~\"\\n    fn a()\");\n+    fail_unless!(str::contains(markdown, ~\"\\n    fn a()\"));\n }\n \n fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n@@ -746,34 +746,34 @@ fn write_impl(ctxt: &Ctxt, doc: doc::ImplDoc) {\n #[test]\n fn should_write_impl_header() {\n     let markdown = test::render(~\"impl int { fn a() { } }\");\n-    assert str::contains(markdown, ~\"## Implementation for `int`\");\n+    fail_unless!(str::contains(markdown, ~\"## Implementation for `int`\"));\n }\n \n #[test]\n fn should_write_impl_header_with_trait() {\n     let markdown = test::render(~\"impl j for int { fn a() { } }\");\n-    assert str::contains(markdown, ~\"## Implementation of `j` for `int`\");\n+    fail_unless!(str::contains(markdown, ~\"## Implementation of `j` for `int`\"));\n }\n \n #[test]\n fn should_write_impl_desc() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n-    assert str::contains(markdown, ~\"desc\");\n+    fail_unless!(str::contains(markdown, ~\"desc\"));\n }\n \n #[test]\n fn should_write_impl_method_header() {\n     let markdown = test::render(\n         ~\"impl int { fn a() { } }\");\n-    assert str::contains(markdown, ~\"### Method `a`\");\n+    fail_unless!(str::contains(markdown, ~\"### Method `a`\"));\n }\n \n #[test]\n fn should_write_impl_method_signature() {\n     let markdown = test::render(\n         ~\"impl int { fn a() { } }\");\n-    assert str::contains(markdown, ~\"\\n    fn a()\");\n+    fail_unless!(str::contains(markdown, ~\"\\n    fn a()\"));\n }\n \n fn write_type(\n@@ -787,20 +787,20 @@ fn write_type(\n #[test]\n fn should_write_type_header() {\n     let markdown = test::render(~\"type t = int;\");\n-    assert str::contains(markdown, ~\"## Type `t`\");\n+    fail_unless!(str::contains(markdown, ~\"## Type `t`\"));\n }\n \n #[test]\n fn should_write_type_desc() {\n     let markdown = test::render(\n         ~\"#[doc = \\\"desc\\\"] type t = int;\");\n-    assert str::contains(markdown, ~\"\\n\\ndesc\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"\\n\\ndesc\\n\\n\"));\n }\n \n #[test]\n fn should_write_type_signature() {\n     let markdown = test::render(~\"type t = int;\");\n-    assert str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"\\n\\n    type t = int\\n\\n\"));\n }\n \n fn write_struct(\n@@ -814,7 +814,7 @@ fn write_struct(\n #[test]\n fn should_write_struct_header() {\n     let markdown = test::render(~\"struct S { field: () }\");\n-    assert str::contains(markdown, ~\"## Struct `S`\\n\\n\");\n+    fail_unless!(str::contains(markdown, ~\"## Struct `S`\\n\\n\"));\n }\n \n #[cfg(test)]\n@@ -901,12 +901,12 @@ mod test {\n     #[test]\n     pub fn write_markdown_should_write_mod_headers() {\n         let markdown = render(~\"mod moo { }\");\n-        assert str::contains(markdown, ~\"# Module `moo`\");\n+        fail_unless!(str::contains(markdown, ~\"# Module `moo`\"));\n     }\n \n     #[test]\n     pub fn should_leave_blank_line_after_header() {\n         let markdown = render(~\"mod morp { }\");\n-        assert str::contains(markdown, ~\"Module `morp`\\n\\n\");\n+        fail_unless!(str::contains(markdown, ~\"Module `morp`\\n\\n\"));\n     }\n }"}, {"sha": "45fef5b80b8148f8a41366313d4f3f199e98940e", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -92,7 +92,7 @@ fn pandoc_writer(\n     config: config::Config,\n     page: doc::Page\n ) -> Writer {\n-    assert config.pandoc_cmd.is_some();\n+    fail_unless!(config.pandoc_cmd.is_some());\n     let pandoc_cmd = (&config.pandoc_cmd).get();\n     let filename = make_local_filename(config, page);\n \n@@ -201,7 +201,7 @@ pub fn make_filename(\n                 config.output_style == config::DocPerMod {\n                 ~\"index\"\n             } else {\n-                assert doc.topmod.name() != ~\"\";\n+                fail_unless!(doc.topmod.name() != ~\"\");\n                 doc.topmod.name()\n             }\n           }\n@@ -229,7 +229,7 @@ fn should_use_markdown_file_name_based_off_crate() {\n     let doc = test::mk_doc(~\"test\", ~\"\");\n     let page = doc::CratePage(doc.CrateDoc());\n     let filename = make_local_filename(config, page);\n-    assert filename.to_str() == ~\"output/dir/test.md\";\n+    fail_unless!(filename.to_str() == ~\"output/dir/test.md\");\n }\n \n #[test]\n@@ -243,7 +243,7 @@ fn should_name_html_crate_file_name_index_html_when_doc_per_mod() {\n     let doc = test::mk_doc(~\"\", ~\"\");\n     let page = doc::CratePage(doc.CrateDoc());\n     let filename = make_local_filename(config, page);\n-    assert filename.to_str() == ~\"output/dir/index.html\";\n+    fail_unless!(filename.to_str() == ~\"output/dir/index.html\");\n }\n \n #[test]\n@@ -258,7 +258,7 @@ fn should_name_mod_file_names_by_path() {\n     let modb = copy doc.cratemod().mods()[0].mods()[0];\n     let page = doc::ItemPage(doc::ModTag(modb));\n     let filename = make_local_filename(config, page);\n-    assert  filename == Path(\"output/dir/a_b.html\");\n+    fail_unless!(filename == Path(\"output/dir/a_b.html\"));\n }\n \n #[cfg(test)]"}, {"sha": "d5e877de71253b3deaf33cad2730ff87d3e0bcb0", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -154,19 +154,19 @@ fn should_not_split_the_doc_into_pages_for_doc_per_crate() {\n         config::DocPerCrate,\n         ~\"mod a { } mod b { mod c { } }\"\n     );\n-    assert doc.pages.len() == 1u;\n+    fail_unless!(doc.pages.len() == 1u);\n }\n \n #[test]\n fn should_make_a_page_for_every_mod() {\n     let doc = test::mk_doc(~\"mod a { }\");\n-    assert doc.pages.mods()[0].name() == ~\"a\";\n+    fail_unless!(doc.pages.mods()[0].name() == ~\"a\");\n }\n \n #[test]\n fn should_remove_mods_from_containing_mods() {\n     let doc = test::mk_doc(~\"mod a { }\");\n-    assert vec::is_empty(doc.cratemod().mods());\n+    fail_unless!(vec::is_empty(doc.cratemod().mods()));\n }\n \n #[cfg(test)]"}, {"sha": "7b80b0b4ae8c921e16ff7dd17a6114c9cef234f1", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -93,6 +93,6 @@ fn test_run_passes() {\n         ];\n         let doc = extract::from_srv(srv.clone(), ~\"one\");\n         let doc = run_passes(srv, doc, passes);\n-        assert doc.cratemod().name() == ~\"onetwothree\";\n+        fail_unless!(doc.cratemod().name() == ~\"onetwothree\");\n     }\n }"}, {"sha": "58b25446dc1b37c0ea711d7e54617f618a7cb06b", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -98,10 +98,10 @@ fn should_record_mod_paths() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = run(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].mods()[0].mods()[0].path()\n-            == ~[~\"a\", ~\"b\"];\n-        assert doc.cratemod().mods()[0].mods()[1].mods()[0].path()\n-            == ~[~\"a\", ~\"d\"];\n+        fail_unless!(doc.cratemod().mods()[0].mods()[0].mods()[0].path()\n+            == ~[~\"a\", ~\"b\"]);\n+        fail_unless!(doc.cratemod().mods()[0].mods()[1].mods()[0].path()\n+            == ~[~\"a\", ~\"d\"]);\n     }\n }\n \n@@ -111,7 +111,7 @@ fn should_record_fn_paths() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = run(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].fns()[0].path() == ~[~\"a\"];\n+        fail_unless!(doc.cratemod().mods()[0].fns()[0].path() == ~[~\"a\"]);\n     }\n }\n "}, {"sha": "bbd975dd55ace9a26b8fbbcef7fb6e4c9aa7bcc2", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -66,7 +66,7 @@ fn should_prune_hidden_items() {\n     use core::vec;\n \n     let doc = test::mk_doc(~\"#[doc(hidden)] mod a { }\");\n-    assert vec::is_empty(doc.cratemod().mods())\n+    fail_unless!(vec::is_empty(doc.cratemod().mods()))\n }\n \n #[cfg(test)]"}, {"sha": "17f11de8aebfcdc62885d9a3e11eda9bd6cd2541", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -69,7 +69,7 @@ fn is_visible(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n #[test]\n fn should_prune_items_without_pub_modifier() {\n     let doc = test::mk_doc(~\"mod a { }\");\n-    assert vec::is_empty(doc.cratemod().mods());\n+    fail_unless!(vec::is_empty(doc.cratemod().mods()));\n }\n \n #[cfg(test)]"}, {"sha": "e64d4ccf69e7c33eb46f81f5f94d04a98a7d0e05", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -168,9 +168,9 @@ fn should_create_section_headers() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         doc.cratemod().mods()[0].item.sections[0].header,\n-        ~\"Header\");\n+        ~\"Header\"));\n }\n \n #[test]\n@@ -181,9 +181,9 @@ fn should_create_section_bodies() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert str::contains(\n+    fail_unless!(str::contains(\n         doc.cratemod().mods()[0].item.sections[0].body,\n-        ~\"Body\");\n+        ~\"Body\"));\n }\n \n #[test]\n@@ -194,7 +194,7 @@ fn should_not_create_sections_from_indented_headers() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert vec::is_empty(doc.cratemod().mods()[0].item.sections);\n+    fail_unless!(vec::is_empty(doc.cratemod().mods()[0].item.sections));\n }\n \n #[test]\n@@ -206,12 +206,12 @@ fn should_remove_section_text_from_main_desc() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert !str::contains(\n+    fail_unless!(!str::contains(\n         doc.cratemod().mods()[0].desc().get(),\n-        ~\"Header\");\n-    assert !str::contains(\n+        ~\"Header\"));\n+    fail_unless!(!str::contains(\n         doc.cratemod().mods()[0].desc().get(),\n-        ~\"Body\");\n+        ~\"Body\"));\n }\n \n #[test]\n@@ -222,7 +222,7 @@ fn should_eliminate_desc_if_it_is_just_whitespace() {\n          Body\\\"]\\\n          mod a {\n          }\");\n-    assert doc.cratemod().mods()[0].desc() == None;\n+    fail_unless!(doc.cratemod().mods()[0].desc() == None);\n }\n \n #[test]\n@@ -233,7 +233,7 @@ fn should_sectionalize_trait_methods() {\n          # Header\\n\\\n          Body\\\"]\\\n          fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].sections.len() == 1u;\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].sections.len() == 1u);\n }\n \n #[test]\n@@ -244,7 +244,7 @@ fn should_sectionalize_impl_methods() {\n          # Header\\n\\\n          Body\\\"]\\\n          fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].sections.len() == 1u;\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].sections.len() == 1u);\n }\n \n #[cfg(test)]"}, {"sha": "0e6d83fa45f3b399e0bd1ee67c8295c74c5880c2", "filename": "src/librustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_name_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -31,7 +31,7 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n-        assert doc.cratemod().items[0].name() == ~\"y\";\n-        assert doc.cratemod().items[1].name() == ~\"z\";\n+        fail_unless!(doc.cratemod().items[0].name() == ~\"y\");\n+        fail_unless!(doc.cratemod().items[1].name() == ~\"z\");\n     }\n }"}, {"sha": "cddd5068816cd424b713f392e42946f7a9c249f3", "filename": "src/librustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_item_type_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -55,14 +55,14 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass().f)(srv.clone(), doc);\n-        assert doc.cratemod().items[0].name() == ~\"iconst\";\n-        assert doc.cratemod().items[1].name() == ~\"itype\";\n-        assert doc.cratemod().items[2].name() == ~\"ienum\";\n-        assert doc.cratemod().items[3].name() == ~\"istruct\";\n-        assert doc.cratemod().items[4].name() == ~\"itrait\";\n-        assert doc.cratemod().items[5].name() == ~\"__extensions__\";\n-        assert doc.cratemod().items[6].name() == ~\"ifn\";\n-        assert doc.cratemod().items[7].name() == ~\"imod\";\n-        assert doc.cratemod().items[8].name() == ~\"inmod\";\n+        fail_unless!(doc.cratemod().items[0].name() == ~\"iconst\");\n+        fail_unless!(doc.cratemod().items[1].name() == ~\"itype\");\n+        fail_unless!(doc.cratemod().items[2].name() == ~\"ienum\");\n+        fail_unless!(doc.cratemod().items[3].name() == ~\"istruct\");\n+        fail_unless!(doc.cratemod().items[4].name() == ~\"itrait\");\n+        fail_unless!(doc.cratemod().items[5].name() == ~\"__extensions__\");\n+        fail_unless!(doc.cratemod().items[6].name() == ~\"ifn\");\n+        fail_unless!(doc.cratemod().items[7].name() == ~\"imod\");\n+        fail_unless!(doc.cratemod().items[8].name() == ~\"inmod\");\n     }\n }"}, {"sha": "4f4c5ea65d4d8a8d1f2a5932a2bae81572df315e", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -67,10 +67,10 @@ fn test() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass(~\"\", name_lteq).f)(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].name() == ~\"w\";\n-        assert doc.cratemod().mods()[1].items[0].name() == ~\"x\";\n-        assert doc.cratemod().mods()[1].items[1].name() == ~\"y\";\n-        assert doc.cratemod().mods()[1].name() == ~\"z\";\n+        fail_unless!(doc.cratemod().mods()[0].name() == ~\"w\");\n+        fail_unless!(doc.cratemod().mods()[1].items[0].name() == ~\"x\");\n+        fail_unless!(doc.cratemod().mods()[1].items[1].name() == ~\"y\");\n+        fail_unless!(doc.cratemod().mods()[1].name() == ~\"z\");\n     }\n }\n \n@@ -84,10 +84,10 @@ fn should_be_stable() {\n     do astsrv::from_str(source) |srv| {\n         let doc = extract::from_srv(srv.clone(), ~\"\");\n         let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].items[0].name() == ~\"b\";\n-        assert doc.cratemod().mods()[1].items[0].name() == ~\"d\";\n+        fail_unless!(doc.cratemod().mods()[0].items[0].name() == ~\"b\");\n+        fail_unless!(doc.cratemod().mods()[1].items[0].name() == ~\"d\");\n         let doc = (mk_pass(~\"\", always_eq).f)(srv.clone(), doc);\n-        assert doc.cratemod().mods()[0].items[0].name() == ~\"b\";\n-        assert doc.cratemod().mods()[1].items[0].name() == ~\"d\";\n+        fail_unless!(doc.cratemod().mods()[0].items[0].name() == ~\"b\");\n+        fail_unless!(doc.cratemod().mods()[1].items[0].name() == ~\"d\");\n     }\n }"}, {"sha": "1bd833756076131fd58119faffc30a5d39535a0e", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -140,89 +140,89 @@ fn fold_impl(\n #[test]\n fn should_execute_op_on_enum_brief() {\n     let doc = test::mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-    assert doc.cratemod().enums()[0].brief() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().enums()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_enum_desc() {\n     let doc = test::mk_doc(~\"#[doc = \\\" a \\\"] enum a { b }\");\n-    assert doc.cratemod().enums()[0].desc() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().enums()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_variant_desc() {\n     let doc = test::mk_doc(~\"enum a { #[doc = \\\" a \\\"] b }\");\n-    assert doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\");\n+    fail_unless!(doc.cratemod().enums()[0].variants[0].desc == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_brief() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-    assert doc.cratemod().traits()[0].brief() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().traits()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_desc() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] trait i { fn a(); }\");\n-    assert doc.cratemod().traits()[0].desc() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().traits()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_method_brief() {\n     let doc = test::mk_doc(\n         ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\");\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].brief == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_trait_method_desc() {\n     let doc = test::mk_doc(\n         ~\"trait i { #[doc = \\\" a \\\"] fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\");\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].desc == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_brief() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].brief() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().impls()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_desc() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] impl int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].desc() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().impls()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_method_brief() {\n     let doc = test::mk_doc(\n         ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\");\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].brief == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_impl_method_desc() {\n     let doc = test::mk_doc(\n         ~\"impl int { #[doc = \\\" a \\\"] fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\");\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].desc == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_type_brief() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] type t = int;\");\n-    assert doc.cratemod().types()[0].brief() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().types()[0].brief() == Some(~\"a\"));\n }\n \n #[test]\n fn should_execute_op_on_type_desc() {\n     let doc = test::mk_doc(\n         ~\"#[doc = \\\" a \\\"] type t = int;\");\n-    assert doc.cratemod().types()[0].desc() == Some(~\"a\");\n+    fail_unless!(doc.cratemod().types()[0].desc() == Some(~\"a\"));\n }\n \n #[test]\n@@ -232,7 +232,7 @@ fn should_execute_on_item_section_headers() {\n          #    Header    \\n\\\n          Body\\\"]\\\n          fn a() { }\");\n-    assert doc.cratemod().fns()[0].sections()[0].header == ~\"Header\";\n+    fail_unless!(doc.cratemod().fns()[0].sections()[0].header == ~\"Header\");\n }\n \n #[test]\n@@ -242,7 +242,7 @@ fn should_execute_on_item_section_bodies() {\n          # Header\\n\\\n          Body      \\\"]\\\n          fn a() { }\");\n-    assert doc.cratemod().fns()[0].sections()[0].body == ~\"Body\";\n+    fail_unless!(doc.cratemod().fns()[0].sections()[0].body == ~\"Body\");\n }\n \n #[test]\n@@ -253,8 +253,8 @@ fn should_execute_on_trait_method_section_headers() {\n          # Header    \\n\\\n          Body\\\"]\\\n          fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].sections[0].header\n-        == ~\"Header\";\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].sections[0].header\n+        == ~\"Header\");\n }\n \n #[test]\n@@ -265,7 +265,7 @@ fn should_execute_on_trait_method_section_bodies() {\n          # Header\\n\\\n          Body     \\\"]\\\n          fn a(); }\");\n-    assert doc.cratemod().traits()[0].methods[0].sections[0].body == ~\"Body\";\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].sections[0].body == ~\"Body\");\n }\n \n #[test]\n@@ -276,8 +276,8 @@ fn should_execute_on_impl_method_section_headers() {\n          # Header   \\n\\\n          Body\\\"]\\\n          fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].sections[0].header\n-        == ~\"Header\";\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].sections[0].header\n+        == ~\"Header\");\n }\n \n #[test]\n@@ -288,7 +288,7 @@ fn should_execute_on_impl_method_section_bodies() {\n          # Header\\n\\\n          Body    \\\"]\\\n          fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].sections[0].body == ~\"Body\";\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].sections[0].body == ~\"Body\");\n }\n \n #[cfg(test)]"}, {"sha": "58d629163e2ea93f17465f80849f31bd62f059a6", "filename": "src/librustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftrim_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -31,7 +31,7 @@ fn should_trim_text() {\n     let doc = test::mk_doc(~\"#[doc = \\\" desc \\\"] \\\n                             mod m {\n                             }\");\n-    assert doc.cratemod().mods()[0].desc() == Some(~\"desc\");\n+    fail_unless!(doc.cratemod().mods()[0].desc() == Some(~\"desc\"));\n }\n \n #[cfg(test)]"}, {"sha": "2765a844f30e47f22206bedf3e4ab0038ddaaf6f", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -86,13 +86,13 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n #[test]\n fn should_add_fn_sig() {\n     let doc = test::mk_doc(~\"fn a<T>() -> int { }\");\n-    assert doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\");\n+    fail_unless!(doc.cratemod().fns()[0].sig == Some(~\"fn a<T>() -> int\"));\n }\n \n #[test]\n fn should_add_foreign_fn_sig() {\n     let doc = test::mk_doc(~\"extern mod a { fn a<T>() -> int; }\");\n-    assert doc.cratemod().nmods()[0].fns[0].sig == Some(~\"fn a<T>() -> int\");\n+    fail_unless!(doc.cratemod().nmods()[0].fns[0].sig == Some(~\"fn a<T>() -> int\"));\n }\n \n fn fold_const(\n@@ -121,7 +121,7 @@ fn fold_const(\n #[test]\n fn should_add_const_types() {\n     let doc = test::mk_doc(~\"const a: bool = true;\");\n-    assert doc.cratemod().consts()[0].sig == Some(~\"bool\");\n+    fail_unless!(doc.cratemod().consts()[0].sig == Some(~\"bool\"));\n }\n \n fn fold_enum(\n@@ -165,7 +165,7 @@ fn fold_enum(\n #[test]\n fn should_add_variant_sigs() {\n     let doc = test::mk_doc(~\"enum a { b(int) }\");\n-    assert doc.cratemod().enums()[0].variants[0].sig == Some(~\"b(int)\");\n+    fail_unless!(doc.cratemod().enums()[0].variants[0].sig == Some(~\"b(int)\"));\n }\n \n fn fold_trait(\n@@ -255,8 +255,8 @@ fn get_method_sig(\n #[test]\n fn should_add_trait_method_sigs() {\n     let doc = test::mk_doc(~\"trait i { fn a<T>() -> int; }\");\n-    assert doc.cratemod().traits()[0].methods[0].sig\n-        == Some(~\"fn a<T>() -> int\");\n+    fail_unless!(doc.cratemod().traits()[0].methods[0].sig\n+        == Some(~\"fn a<T>() -> int\"));\n }\n \n fn fold_impl(\n@@ -296,26 +296,26 @@ fn fold_impl(\n #[test]\n fn should_add_impl_trait_types() {\n     let doc = test::mk_doc(~\"impl j for int { fn a<T>() { } }\");\n-    assert doc.cratemod().impls()[0].trait_types[0] == ~\"j\";\n+    fail_unless!(doc.cratemod().impls()[0].trait_types[0] == ~\"j\");\n }\n \n #[test]\n fn should_not_add_impl_trait_types_if_none() {\n     let doc = test::mk_doc(~\"impl int { fn a() { } }\");\n-    assert vec::len(doc.cratemod().impls()[0].trait_types) == 0;\n+    fail_unless!(vec::len(doc.cratemod().impls()[0].trait_types) == 0);\n }\n \n #[test]\n fn should_add_impl_self_ty() {\n     let doc = test::mk_doc(~\"impl int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].self_ty == Some(~\"int\");\n+    fail_unless!(doc.cratemod().impls()[0].self_ty == Some(~\"int\"));\n }\n \n #[test]\n fn should_add_impl_method_sigs() {\n     let doc = test::mk_doc(~\"impl int { fn a<T>() -> int { fail!() } }\");\n-    assert doc.cratemod().impls()[0].methods[0].sig\n-        == Some(~\"fn a<T>() -> int\");\n+    fail_unless!(doc.cratemod().impls()[0].methods[0].sig\n+        == Some(~\"fn a<T>() -> int\"));\n }\n \n fn fold_type(\n@@ -354,7 +354,7 @@ fn fold_type(\n #[test]\n fn should_add_type_signatures() {\n     let doc = test::mk_doc(~\"type t<T> = int;\");\n-    assert doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\");\n+    fail_unless!(doc.cratemod().types()[0].sig == Some(~\"type t<T> = int\"));\n }\n \n fn fold_struct(\n@@ -407,21 +407,21 @@ fn strip_struct_extra_stuff(item: @ast::item) -> @ast::item {\n #[test]\n fn should_add_struct_defs() {\n     let doc = test::mk_doc(~\"struct S { field: () }\");\n-    assert (&doc.cratemod().structs()[0].sig).get().contains(\"struct S {\");\n+    fail_unless!((&doc.cratemod().structs()[0].sig).get().contains(\"struct S {\"));\n }\n \n #[test]\n fn should_not_serialize_struct_drop_blocks() {\n     // All we care about are the fields\n     let doc = test::mk_doc(~\"struct S { field: (), drop { } }\");\n-    assert !(&doc.cratemod().structs()[0].sig).get().contains(\"drop\");\n+    fail_unless!(!(&doc.cratemod().structs()[0].sig).get().contains(\"drop\"));\n }\n \n #[test]\n fn should_not_serialize_struct_attrs() {\n     // All we care about are the fields\n     let doc = test::mk_doc(~\"#[wut] struct S { field: () }\");\n-    assert !(&doc.cratemod().structs()[0].sig).get().contains(\"wut\");\n+    fail_unless!(!(&doc.cratemod().structs()[0].sig).get().contains(\"wut\"));\n }\n \n #[cfg(test)]"}, {"sha": "6edf53785cbb9b1a7e7da54c346a14b6afc885cd", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -83,7 +83,7 @@ fn unindent(s: &str) -> ~str {\n             if str::is_whitespace(*line) {\n                 copy *line\n             } else {\n-                assert str::len(*line) >= min_indent;\n+                fail_unless!(str::len(*line) >= min_indent);\n                 str::slice(*line, min_indent, str::len(*line))\n             }\n         };\n@@ -97,14 +97,14 @@ fn unindent(s: &str) -> ~str {\n fn should_unindent() {\n     let s = ~\"    line1\\n    line2\";\n     let r = unindent(s);\n-    assert r == ~\"line1\\nline2\";\n+    fail_unless!(r == ~\"line1\\nline2\");\n }\n \n #[test]\n fn should_unindent_multiple_paragraphs() {\n     let s = ~\"    line1\\n\\n    line2\";\n     let r = unindent(s);\n-    assert r == ~\"line1\\n\\nline2\";\n+    fail_unless!(r == ~\"line1\\n\\nline2\");\n }\n \n #[test]\n@@ -113,7 +113,7 @@ fn should_leave_multiple_indent_levels() {\n     // base indentation and should be preserved\n     let s = ~\"    line1\\n\\n        line2\";\n     let r = unindent(s);\n-    assert r == ~\"line1\\n\\n    line2\";\n+    fail_unless!(r == ~\"line1\\n\\n    line2\");\n }\n \n #[test]\n@@ -125,12 +125,12 @@ fn should_ignore_first_line_indent() {\n     //          and continue here\"]\n     let s = ~\"line1\\n    line2\";\n     let r = unindent(s);\n-    assert r == ~\"line1\\nline2\";\n+    fail_unless!(r == ~\"line1\\nline2\");\n }\n \n #[test]\n fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n     let s = ~\"line1\\n\\n    line2\";\n     let r = unindent(s);\n-    assert r == ~\"line1\\n\\n    line2\";\n+    fail_unless!(r == ~\"line1\\n\\n    line2\");\n }"}, {"sha": "b63a0a92e6c15b72104bef0c2e1ac5a86fc331e1", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -787,19 +787,19 @@ pub fn link_exe(src: &Path, dest: &Path) -> bool {\n \n #[test]\n fn test_is_cmd() {\n-    assert is_cmd(~\"build\");\n-    assert is_cmd(~\"clean\");\n-    assert is_cmd(~\"do\");\n-    assert is_cmd(~\"info\");\n-    assert is_cmd(~\"install\");\n-    assert is_cmd(~\"prefer\");\n-    assert is_cmd(~\"test\");\n-    assert is_cmd(~\"uninstall\");\n-    assert is_cmd(~\"unprefer\");\n+    fail_unless!(is_cmd(~\"build\"));\n+    fail_unless!(is_cmd(~\"clean\"));\n+    fail_unless!(is_cmd(~\"do\"));\n+    fail_unless!(is_cmd(~\"info\"));\n+    fail_unless!(is_cmd(~\"install\"));\n+    fail_unless!(is_cmd(~\"prefer\"));\n+    fail_unless!(is_cmd(~\"test\"));\n+    fail_unless!(is_cmd(~\"uninstall\"));\n+    fail_unless!(is_cmd(~\"unprefer\"));\n }\n \n #[test]\n fn test_parse_name() {\n-    assert parse_name(~\"org.mozilla.servo\").get() == ~\"servo\";\n-    assert parse_name(~\"org. mozilla.servo 2131\").is_err();\n+    fail_unless!(parse_name(~\"org.mozilla.servo\").get() == ~\"servo\");\n+    fail_unless!(parse_name(~\"org. mozilla.servo 2131\").is_err());\n }"}, {"sha": "84b24efac964f231590fe57beff758b074155232", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -44,7 +44,7 @@ pub impl Condvar/&self {\n      */\n     #[inline(always)]\n     fn wait_on(&self, condvar_id: uint) {\n-        assert !*self.failed;\n+        fail_unless!(!*self.failed);\n         self.cond.wait_on(condvar_id);\n         // This is why we need to wrap sync::condvar.\n         check_poison(self.is_mutex, *self.failed);\n@@ -60,7 +60,7 @@ pub impl Condvar/&self {\n      */\n     #[inline(always)]\n     fn signal_on(&self, condvar_id: uint) -> bool {\n-        assert !*self.failed;\n+        fail_unless!(!*self.failed);\n         self.cond.signal_on(condvar_id)\n     }\n \n@@ -74,7 +74,7 @@ pub impl Condvar/&self {\n      */\n     #[inline(always)]\n     fn broadcast_on(&self, condvar_id: uint) -> uint {\n-        assert !*self.failed;\n+        fail_unless!(!*self.failed);\n         self.cond.broadcast_on(condvar_id)\n     }\n }\n@@ -230,7 +230,7 @@ struct PoisonOnFail {\n impl Drop for PoisonOnFail {\n     fn finalize(&self) {\n         unsafe {\n-            /* assert !*self.failed;\n+            /* fail_unless!(!*self.failed);\n                -- might be false in case of cond.wait() */\n             if task::failing() {\n                 *self.failed = true;\n@@ -384,7 +384,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n         // of this cast is removing the mutability.)\n         let new_data = unsafe { cast::transmute_immut(data) };\n         // Downgrade ensured the token belonged to us. Just a sanity check.\n-        assert ptr::ref_eq(&state.data, new_data);\n+        fail_unless!(ptr::ref_eq(&state.data, new_data));\n         // Produce new token\n         RWReadMode((new_data, new_token))\n     }\n@@ -476,13 +476,13 @@ mod tests {\n             let arc_v = p.recv();\n \n             let v = *arc::get::<~[int]>(&arc_v);\n-            assert v[3] == 4;\n+            fail_unless!(v[3] == 4);\n         };\n \n         let c = p.recv();\n         c.send(arc::clone(&arc_v));\n \n-        assert (*arc::get(&arc_v))[2] == 3;\n+        fail_unless!((*arc::get(&arc_v))[2] == 3);\n \n         log(info, arc_v);\n     }\n@@ -503,7 +503,7 @@ mod tests {\n         }\n         do arc.access_cond |state, cond| {\n             comm::send_one(c.take(), ());\n-            assert !*state;\n+            fail_unless!(!*state);\n             while !*state {\n                 cond.wait();\n             }\n@@ -519,7 +519,7 @@ mod tests {\n             let _ = p.recv();\n             do arc2.access_cond |one, cond| {\n                 cond.signal();\n-                assert *one == 0; // Parent should fail when it wakes up.\n+                fail_unless!(*one == 0); // Parent should fail when it wakes up.\n             }\n         }\n \n@@ -536,11 +536,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.access |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do arc.access |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -549,11 +549,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.write |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do arc.read |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -562,11 +562,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.write |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do arc.write |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -576,12 +576,12 @@ mod tests {\n         do task::try || {\n             do arc2.write_downgrade |write_mode| {\n                 do (&write_mode).write |one| {\n-                    assert *one == 2;\n+                    fail_unless!(*one == 2);\n                 }\n             }\n         };\n         do arc.write |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -590,11 +590,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.read |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do arc.read |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -603,11 +603,11 @@ mod tests {\n         let arc2 = ~arc.clone();\n         do task::try || {\n             do arc2.read |one| {\n-                assert *one == 2;\n+                fail_unless!(*one == 2);\n             }\n         };\n         do arc.write |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -618,12 +618,12 @@ mod tests {\n             do arc2.write_downgrade |write_mode| {\n                 let read_mode = arc2.downgrade(write_mode);\n                 do (&read_mode).read |one| {\n-                    assert *one == 2;\n+                    fail_unless!(*one == 2);\n                 }\n             }\n         };\n         do arc.write |one| {\n-            assert *one == 1;\n+            fail_unless!(*one == 1);\n         }\n     }\n     #[test]\n@@ -651,7 +651,7 @@ mod tests {\n             do task::task().future_result(|+r| children.push(r)).spawn\n                 || {\n                 do arc3.read |num| {\n-                    assert *num >= 0;\n+                    fail_unless!(*num >= 0);\n                 }\n             }\n         }\n@@ -661,7 +661,7 @@ mod tests {\n \n         // Wait for writer to finish\n         p.recv();\n-        do arc.read |num| { assert *num == 10; }\n+        do arc.read |num| { fail_unless!(*num == 10); }\n     }\n     #[test]\n     pub fn test_rw_downgrade() {\n@@ -682,7 +682,7 @@ mod tests {\n             do task::spawn || {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 do arcn.read |state| {\n-                    assert *state == 31337;\n+                    fail_unless!(*state == 31337);\n                     rc2.send(());\n                 }\n             }\n@@ -694,15 +694,15 @@ mod tests {\n         do task::spawn || {\n             wp1.recv();\n             do arc2.write_cond |state, cond| {\n-                assert *state == 0;\n+                fail_unless!(*state == 0);\n                 *state = 42;\n                 cond.signal();\n             }\n             wp1.recv();\n             do arc2.write |state| {\n                 // This shouldn't happen until after the downgrade read\n                 // section, and all other readers, finish.\n-                assert *state == 31337;\n+                fail_unless!(*state == 31337);\n                 *state = 42;\n             }\n             wc2.send(());\n@@ -715,7 +715,7 @@ mod tests {\n                 while *state == 0 {\n                     cond.wait();\n                 }\n-                assert *state == 42;\n+                fail_unless!(*state == 42);\n                 *state = 31337;\n                 // send to other readers\n                 for vec::each(reader_convos) |x| {\n@@ -733,7 +733,7 @@ mod tests {\n                     }\n                 }\n                 wc1.send(()); // tell writer to try again\n-                assert *state == 31337;\n+                fail_unless!(*state == 31337);\n             }\n         }\n "}, {"sha": "0bd9e1eac51a381cb5137ae679c89965810b2b48", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -153,23 +153,23 @@ mod tests {\n \n     #[test]\n     pub fn test_to_base64() {\n-        assert (~\"\").to_base64()       == ~\"\";\n-        assert (~\"f\").to_base64()      == ~\"Zg==\";\n-        assert (~\"fo\").to_base64()     == ~\"Zm8=\";\n-        assert (~\"foo\").to_base64()    == ~\"Zm9v\";\n-        assert (~\"foob\").to_base64()   == ~\"Zm9vYg==\";\n-        assert (~\"fooba\").to_base64()  == ~\"Zm9vYmE=\";\n-        assert (~\"foobar\").to_base64() == ~\"Zm9vYmFy\";\n+        fail_unless!((~\"\").to_base64()       == ~\"\");\n+        fail_unless!((~\"f\").to_base64()      == ~\"Zg==\");\n+        fail_unless!((~\"fo\").to_base64()     == ~\"Zm8=\");\n+        fail_unless!((~\"foo\").to_base64()    == ~\"Zm9v\");\n+        fail_unless!((~\"foob\").to_base64()   == ~\"Zm9vYg==\");\n+        fail_unless!((~\"fooba\").to_base64()  == ~\"Zm9vYmE=\");\n+        fail_unless!((~\"foobar\").to_base64() == ~\"Zm9vYmFy\");\n     }\n \n     #[test]\n     pub fn test_from_base64() {\n-        assert (~\"\").from_base64() == str::to_bytes(~\"\");\n-        assert (~\"Zg==\").from_base64() == str::to_bytes(~\"f\");\n-        assert (~\"Zm8=\").from_base64() == str::to_bytes(~\"fo\");\n-        assert (~\"Zm9v\").from_base64() == str::to_bytes(~\"foo\");\n-        assert (~\"Zm9vYg==\").from_base64() == str::to_bytes(~\"foob\");\n-        assert (~\"Zm9vYmE=\").from_base64() == str::to_bytes(~\"fooba\");\n-        assert (~\"Zm9vYmFy\").from_base64() == str::to_bytes(~\"foobar\");\n+        fail_unless!((~\"\").from_base64() == str::to_bytes(~\"\"));\n+        fail_unless!((~\"Zg==\").from_base64() == str::to_bytes(~\"f\"));\n+        fail_unless!((~\"Zm8=\").from_base64() == str::to_bytes(~\"fo\"));\n+        fail_unless!((~\"Zm9v\").from_base64() == str::to_bytes(~\"foo\"));\n+        fail_unless!((~\"Zm9vYg==\").from_base64() == str::to_bytes(~\"foob\"));\n+        fail_unless!((~\"Zm9vYmE=\").from_base64() == str::to_bytes(~\"fooba\"));\n+        fail_unless!((~\"Zm9vYmFy\").from_base64() == str::to_bytes(~\"foobar\"));\n     }\n }"}, {"sha": "5c3f37faca71ec73c3ab7c816b98036d6f94003d", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 135, "deletions": 135, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -162,7 +162,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n             lo\n         };\n \n-        assert borrow == 0;     // <=> assert (self >= other);\n+        fail_unless!(borrow == 0);     // <=> fail_unless!((self >= other));\n         return BigUint::new(diff);\n     }\n }\n@@ -351,7 +351,7 @@ pub impl BigUint {\n             n <<= 1;\n             shift += 1;\n         }\n-        assert shift < BigDigit::bits;\n+        fail_unless!(shift < BigDigit::bits);\n         let (d, m) = divmod_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n@@ -390,7 +390,7 @@ pub impl BigUint {\n             for vec::rev_each(an) |elt| {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n-                assert di < BigDigit::base;\n+                fail_unless!(di < BigDigit::base);\n                 carry = (ai % (bn as uint)) as BigDigit;\n                 d = ~[di as BigDigit] + d;\n             }\n@@ -434,7 +434,7 @@ pub impl BigUint {\n     }\n \n     pure fn to_str_radix(&self, radix: uint) -> ~str {\n-        assert 1 < radix && radix <= 16;\n+        fail_unless!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n         if base == BigDigit::base {\n             return fill_concat(self.data, radix, max_len)\n@@ -509,7 +509,7 @@ pub impl BigUint {\n \n #[cfg(target_arch = \"x86_64\")]\n priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n-    assert 1 < radix && radix <= 16;\n+    fail_unless!(1 < radix && radix <= 16);\n     match radix {\n         2  => (4294967296, 32),\n         3  => (3486784401, 20),\n@@ -534,7 +534,7 @@ priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n-    assert 1 < radix && radix <= 16;\n+    fail_unless!(1 < radix && radix <= 16);\n     match radix {\n         2  => (65536, 16),\n         3  => (59049, 10),\n@@ -787,7 +787,7 @@ pub impl BigInt {\n         if ss < os { return -1; }\n         if ss > os { return  1; }\n \n-        assert ss == os;\n+        fail_unless!(ss == os);\n         match ss {\n             Zero  => 0,\n             Plus  => self.data.cmp(&other.data),\n@@ -874,7 +874,7 @@ mod biguint_tests {\n     #[test]\n     fn test_from_slice() {\n         fn check(slice: &[BigDigit], data: &[BigDigit]) {\n-            assert data == BigUint::from_slice(slice).data;\n+            fail_unless!(data == BigUint::from_slice(slice).data);\n         }\n         check(~[1], ~[1]);\n         check(~[0, 0, 0], ~[]);\n@@ -892,30 +892,30 @@ mod biguint_tests {\n             for vec::slice(data, i, data.len()).eachi |j0, nj| {\n                 let j = j0 + i;\n                 if i == j {\n-                    assert ni.cmp(nj) == 0;\n-                    assert nj.cmp(ni) == 0;\n-                    assert ni == nj;\n-                    assert !(ni != nj);\n-                    assert ni <= nj;\n-                    assert ni >= nj;\n-                    assert !(ni < nj);\n-                    assert !(ni > nj);\n+                    fail_unless!(ni.cmp(nj) == 0);\n+                    fail_unless!(nj.cmp(ni) == 0);\n+                    fail_unless!(ni == nj);\n+                    fail_unless!(!(ni != nj));\n+                    fail_unless!(ni <= nj);\n+                    fail_unless!(ni >= nj);\n+                    fail_unless!(!(ni < nj));\n+                    fail_unless!(!(ni > nj));\n                 } else {\n-                    assert ni.cmp(nj) < 0;\n-                    assert nj.cmp(ni) > 0;\n+                    fail_unless!(ni.cmp(nj) < 0);\n+                    fail_unless!(nj.cmp(ni) > 0);\n \n-                    assert !(ni == nj);\n-                    assert ni != nj;\n+                    fail_unless!(!(ni == nj));\n+                    fail_unless!(ni != nj);\n \n-                    assert ni <= nj;\n-                    assert !(ni >= nj);\n-                    assert ni < nj;\n-                    assert !(ni > nj);\n+                    fail_unless!(ni <= nj);\n+                    fail_unless!(!(ni >= nj));\n+                    fail_unless!(ni < nj);\n+                    fail_unless!(!(ni > nj));\n \n-                    assert !(nj <= ni);\n-                    assert nj >= ni;\n-                    assert !(nj < ni);\n-                    assert nj > ni;\n+                    fail_unless!(!(nj <= ni));\n+                    fail_unless!(nj >= ni);\n+                    fail_unless!(!(nj < ni));\n+                    fail_unless!(nj > ni);\n                 }\n             }\n         }\n@@ -924,7 +924,7 @@ mod biguint_tests {\n     #[test]\n     fn test_shl() {\n         fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n-            assert BigUint::new(v) << shift == BigUint::new(ans);\n+            fail_unless!(BigUint::new(v) << shift == BigUint::new(ans));\n         }\n \n         check(~[], 3, ~[]);\n@@ -969,7 +969,7 @@ mod biguint_tests {\n     #[ignore(cfg(target_arch = \"mips\"))]\n     fn test_shr() {\n         fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n-            assert BigUint::new(v) >> shift == BigUint::new(ans);\n+            fail_unless!(BigUint::new(v) >> shift == BigUint::new(ans));\n         }\n \n         check(~[], 3, ~[]);\n@@ -1011,8 +1011,8 @@ mod biguint_tests {\n     fn test_convert_int() {\n         fn check(v: ~[BigDigit], i: int) {\n             let b = BigUint::new(v);\n-            assert b == IntConvertible::from_int(i);\n-            assert b.to_int() == i;\n+            fail_unless!(b == IntConvertible::from_int(i));\n+            fail_unless!(b.to_int() == i);\n         }\n \n         check(~[], 0);\n@@ -1021,17 +1021,17 @@ mod biguint_tests {\n         check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n         check(~[-1, -1 >> 1], int::max_value);\n \n-        assert BigUint::new(~[0, -1]).to_int() == int::max_value;\n-        assert BigUint::new(~[0, 0, 1]).to_int() == int::max_value;\n-        assert BigUint::new(~[0, 0, -1]).to_int() == int::max_value;\n+        fail_unless!(BigUint::new(~[0, -1]).to_int() == int::max_value);\n+        fail_unless!(BigUint::new(~[0, 0, 1]).to_int() == int::max_value);\n+        fail_unless!(BigUint::new(~[0, 0, -1]).to_int() == int::max_value);\n     }\n \n     #[test]\n     fn test_convert_uint() {\n         fn check(v: ~[BigDigit], u: uint) {\n             let b = BigUint::new(v);\n-            assert b == BigUint::from_uint(u);\n-            assert b.to_uint() == u;\n+            fail_unless!(b == BigUint::from_uint(u));\n+            fail_unless!(b.to_uint() == u);\n         }\n \n         check(~[], 0);\n@@ -1041,8 +1041,8 @@ mod biguint_tests {\n         check(~[ 0, -1], uint::max_value << BigDigit::bits);\n         check(~[-1, -1], uint::max_value);\n \n-        assert BigUint::new(~[0, 0, 1]).to_uint()  == uint::max_value;\n-        assert BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value;\n+        fail_unless!(BigUint::new(~[0, 0, 1]).to_uint()  == uint::max_value);\n+        fail_unless!(BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value);\n     }\n \n     const sum_triples: &static/[(&static/[BigDigit],\n@@ -1067,8 +1067,8 @@ mod biguint_tests {\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n-            assert a + b == c;\n-            assert b + a == c;\n+            fail_unless!(a + b == c);\n+            fail_unless!(b + a == c);\n         }\n     }\n \n@@ -1080,8 +1080,8 @@ mod biguint_tests {\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n-            assert c - a == b;\n-            assert c - b == a;\n+            fail_unless!(c - a == b);\n+            fail_unless!(c - b == a);\n         }\n     }\n \n@@ -1131,8 +1131,8 @@ mod biguint_tests {\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n-            assert a * b == c;\n-            assert b * a == c;\n+            fail_unless!(a * b == c);\n+            fail_unless!(b * a == c);\n         }\n \n         for divmod_quadruples.each |elm| {\n@@ -1142,8 +1142,8 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n             let d = BigUint::from_slice(dVec);\n \n-            assert a == b * c + d;\n-            assert a == c * b + d;\n+            fail_unless!(a == b * c + d);\n+            fail_unless!(a == c * b + d);\n         }\n     }\n \n@@ -1156,10 +1156,10 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n \n             if a.is_not_zero() {\n-                assert c.divmod(&a) == (b, Zero::zero());\n+                fail_unless!(c.divmod(&a) == (b, Zero::zero()));\n             }\n             if b.is_not_zero() {\n-                assert c.divmod(&b) == (a, Zero::zero());\n+                fail_unless!(c.divmod(&b) == (a, Zero::zero()));\n             }\n         }\n \n@@ -1170,7 +1170,7 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n             let d = BigUint::from_slice(dVec);\n \n-            if b.is_not_zero() { assert a.divmod(&b) == (c, d); }\n+            if b.is_not_zero() { fail_unless!(a.divmod(&b) == (c, d)); }\n         }\n     }\n \n@@ -1237,7 +1237,7 @@ mod biguint_tests {\n             let &(n, rs) = num_pair;\n             for rs.each |str_pair| {\n                 let &(radix, str) = str_pair;\n-                assert n.to_str_radix(radix) == str;\n+                fail_unless!(n.to_str_radix(radix) == str);\n             }\n         }\n     }\n@@ -1248,13 +1248,13 @@ mod biguint_tests {\n             let &(n, rs) = num_pair;\n             for rs.each |str_pair| {\n                 let &(radix, str) = str_pair;\n-                assert Some(n) == BigUint::from_str_radix(str, radix);\n+                fail_unless!(Some(n) == BigUint::from_str_radix(str, radix));\n             }\n         }\n \n-        assert BigUint::from_str_radix(~\"Z\", 10) == None;\n-        assert BigUint::from_str_radix(~\"_\", 2) == None;\n-        assert BigUint::from_str_radix(~\"-1\", 10) == None;\n+        fail_unless!(BigUint::from_str_radix(~\"Z\", 10) == None);\n+        fail_unless!(BigUint::from_str_radix(~\"_\", 2) == None);\n+        fail_unless!(BigUint::from_str_radix(~\"-1\", 10) == None);\n     }\n \n     #[test]\n@@ -1272,7 +1272,7 @@ mod biguint_tests {\n             let ans = match BigUint::from_str_radix(s, 10) {\n                 Some(x) => x, None => fail!()\n             };\n-            assert n == ans;\n+            fail_unless!(n == ans);\n         }\n \n         check(3, \"6\");\n@@ -1294,7 +1294,7 @@ mod bigint_tests {\n         fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) {\n             let inp = BigInt::from_biguint(inp_s, BigUint::from_uint(inp_n));\n             let ans = BigInt { sign: ans_s, data: BigUint::from_uint(ans_n)};\n-            assert inp == ans;\n+            fail_unless!(inp == ans);\n         }\n         check(Plus, 1, Plus, 1);\n         check(Plus, 0, Zero, 0);\n@@ -1314,30 +1314,30 @@ mod bigint_tests {\n             for vec::slice(nums, i, nums.len()).eachi |j0, nj| {\n                 let j = i + j0;\n                 if i == j {\n-                    assert ni.cmp(nj) == 0;\n-                    assert nj.cmp(ni) == 0;\n-                    assert ni == nj;\n-                    assert !(ni != nj);\n-                    assert ni <= nj;\n-                    assert ni >= nj;\n-                    assert !(ni < nj);\n-                    assert !(ni > nj);\n+                    fail_unless!(ni.cmp(nj) == 0);\n+                    fail_unless!(nj.cmp(ni) == 0);\n+                    fail_unless!(ni == nj);\n+                    fail_unless!(!(ni != nj));\n+                    fail_unless!(ni <= nj);\n+                    fail_unless!(ni >= nj);\n+                    fail_unless!(!(ni < nj));\n+                    fail_unless!(!(ni > nj));\n                 } else {\n-                    assert ni.cmp(nj) < 0;\n-                    assert nj.cmp(ni) > 0;\n+                    fail_unless!(ni.cmp(nj) < 0);\n+                    fail_unless!(nj.cmp(ni) > 0);\n \n-                    assert !(ni == nj);\n-                    assert ni != nj;\n+                    fail_unless!(!(ni == nj));\n+                    fail_unless!(ni != nj);\n \n-                    assert ni <= nj;\n-                    assert !(ni >= nj);\n-                    assert ni < nj;\n-                    assert !(ni > nj);\n+                    fail_unless!(ni <= nj);\n+                    fail_unless!(!(ni >= nj));\n+                    fail_unless!(ni < nj);\n+                    fail_unless!(!(ni > nj));\n \n-                    assert !(nj <= ni);\n-                    assert nj >= ni;\n-                    assert !(nj < ni);\n-                    assert nj > ni;\n+                    fail_unless!(!(nj <= ni));\n+                    fail_unless!(nj >= ni);\n+                    fail_unless!(!(nj < ni));\n+                    fail_unless!(nj > ni);\n                 }\n             }\n         }\n@@ -1346,8 +1346,8 @@ mod bigint_tests {\n     #[test]\n     fn test_convert_int() {\n         fn check(b: BigInt, i: int) {\n-            assert b == IntConvertible::from_int(i);\n-            assert b.to_int() == i;\n+            fail_unless!(b == IntConvertible::from_int(i));\n+            fail_unless!(b.to_int() == i);\n         }\n \n         check(Zero::zero(), 0);\n@@ -1356,29 +1356,29 @@ mod bigint_tests {\n             Plus, BigUint::from_uint(int::max_value as uint)\n         ), int::max_value);\n \n-        assert BigInt::from_biguint(\n+        fail_unless!(BigInt::from_biguint(\n             Plus, BigUint::from_uint(int::max_value as uint + 1)\n-        ).to_int() == int::max_value;\n-        assert BigInt::from_biguint(\n+        ).to_int() == int::max_value);\n+        fail_unless!(BigInt::from_biguint(\n             Plus, BigUint::new(~[1, 2, 3])\n-        ).to_int() == int::max_value;\n+        ).to_int() == int::max_value);\n \n         check(BigInt::from_biguint(\n             Minus, BigUint::from_uint(-int::min_value as uint)\n         ), int::min_value);\n-        assert BigInt::from_biguint(\n+        fail_unless!(BigInt::from_biguint(\n             Minus, BigUint::from_uint(-int::min_value as uint + 1)\n-        ).to_int() == int::min_value;\n-        assert BigInt::from_biguint(\n+        ).to_int() == int::min_value);\n+        fail_unless!(BigInt::from_biguint(\n             Minus, BigUint::new(~[1, 2, 3])\n-        ).to_int() == int::min_value;\n+        ).to_int() == int::min_value);\n     }\n \n     #[test]\n     fn test_convert_uint() {\n         fn check(b: BigInt, u: uint) {\n-            assert b == BigInt::from_uint(u);\n-            assert b.to_uint() == u;\n+            fail_unless!(b == BigInt::from_uint(u));\n+            fail_unless!(b.to_uint() == u);\n         }\n \n         check(Zero::zero(), 0);\n@@ -1387,16 +1387,16 @@ mod bigint_tests {\n         check(\n             BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n             uint::max_value);\n-        assert BigInt::from_biguint(\n+        fail_unless!(BigInt::from_biguint(\n             Plus, BigUint::new(~[1, 2, 3])\n-        ).to_uint() == uint::max_value;\n+        ).to_uint() == uint::max_value);\n \n-        assert BigInt::from_biguint(\n+        fail_unless!(BigInt::from_biguint(\n             Minus, BigUint::from_uint(uint::max_value)\n-        ).to_uint() == 0;\n-        assert BigInt::from_biguint(\n+        ).to_uint() == 0);\n+        fail_unless!(BigInt::from_biguint(\n             Minus, BigUint::new(~[1, 2, 3])\n-        ).to_uint() == 0;\n+        ).to_uint() == 0);\n     }\n \n     const sum_triples: &static/[(&static/[BigDigit],\n@@ -1421,14 +1421,14 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            assert a + b == c;\n-            assert b + a == c;\n-            assert c + (-a) == b;\n-            assert c + (-b) == a;\n-            assert a + (-c) == (-b);\n-            assert b + (-c) == (-a);\n-            assert (-a) + (-b) == (-c);\n-            assert a + (-a) == Zero::zero();\n+            fail_unless!(a + b == c);\n+            fail_unless!(b + a == c);\n+            fail_unless!(c + (-a) == b);\n+            fail_unless!(c + (-b) == a);\n+            fail_unless!(a + (-c) == (-b));\n+            fail_unless!(b + (-c) == (-a));\n+            fail_unless!((-a) + (-b) == (-c));\n+            fail_unless!(a + (-a) == Zero::zero());\n         }\n     }\n \n@@ -1440,14 +1440,14 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            assert c - a == b;\n-            assert c - b == a;\n-            assert (-b) - a == (-c);\n-            assert (-a) - b == (-c);\n-            assert b - (-a) == c;\n-            assert a - (-b) == c;\n-            assert (-c) - (-a) == (-b);\n-            assert a - a == Zero::zero();\n+            fail_unless!(c - a == b);\n+            fail_unless!(c - b == a);\n+            fail_unless!((-b) - a == (-c));\n+            fail_unless!((-a) - b == (-c));\n+            fail_unless!(b - (-a) == c);\n+            fail_unless!(a - (-b) == c);\n+            fail_unless!((-c) - (-a) == (-b));\n+            fail_unless!(a - a == Zero::zero());\n         }\n     }\n \n@@ -1497,11 +1497,11 @@ mod bigint_tests {\n             let b = BigInt::from_slice(Plus, bVec);\n             let c = BigInt::from_slice(Plus, cVec);\n \n-            assert a * b == c;\n-            assert b * a == c;\n+            fail_unless!(a * b == c);\n+            fail_unless!(b * a == c);\n \n-            assert (-a) * b == -c;\n-            assert (-b) * a == -c;\n+            fail_unless!((-a) * b == -c);\n+            fail_unless!((-b) * a == -c);\n         }\n \n         for divmod_quadruples.each |elm| {\n@@ -1511,8 +1511,8 @@ mod bigint_tests {\n             let c = BigInt::from_slice(Plus, cVec);\n             let d = BigInt::from_slice(Plus, dVec);\n \n-            assert a == b * c + d;\n-            assert a == c * b + d;\n+            fail_unless!(a == b * c + d);\n+            fail_unless!(a == c * b + d);\n         }\n     }\n \n@@ -1521,12 +1521,12 @@ mod bigint_tests {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n             let (d, m) = a.divmod(b);\n             if m.is_not_zero() {\n-                assert m.sign == b.sign;\n+                fail_unless!(m.sign == b.sign);\n             }\n-            assert m.abs() <= b.abs();\n-            assert *a == b * d + m;\n-            assert d == *ans_d;\n-            assert m == *ans_m;\n+            fail_unless!(m.abs() <= b.abs());\n+            fail_unless!(*a == b * d + m);\n+            fail_unless!(d == *ans_d);\n+            fail_unless!(m == *ans_m);\n         }\n \n         fn check(a: &BigInt, b: &BigInt, d: &BigInt, m: &BigInt) {\n@@ -1572,12 +1572,12 @@ mod bigint_tests {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n             let (q, r) = a.quotrem(b);\n             if r.is_not_zero() {\n-                assert r.sign == a.sign;\n+                fail_unless!(r.sign == a.sign);\n             }\n-            assert r.abs() <= b.abs();\n-            assert *a == b * q + r;\n-            assert q == *ans_q;\n-            assert r == *ans_r;\n+            fail_unless!(r.abs() <= b.abs());\n+            fail_unless!(*a == b * q + r);\n+            fail_unless!(q == *ans_q);\n+            fail_unless!(r == *ans_r);\n         }\n \n         fn check(a: &BigInt, b: &BigInt, q: &BigInt, r: &BigInt) {\n@@ -1612,8 +1612,8 @@ mod bigint_tests {\n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n-            assert ans == IntConvertible::from_int::<BigInt>(\n-                n).to_str_radix(10);\n+            fail_unless!(ans == IntConvertible::from_int::<BigInt>(\n+                n).to_str_radix(10));\n         }\n         check(10, \"10\");\n         check(1, \"1\");\n@@ -1627,7 +1627,7 @@ mod bigint_tests {\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n             let ans = ans.map(|&n| IntConvertible::from_int(n));\n-            assert BigInt::from_str_radix(s, 10) == ans;\n+            fail_unless!(BigInt::from_str_radix(s, 10) == ans);\n         }\n         check(\"10\", Some(10));\n         check(\"1\", Some(1));\n@@ -1640,11 +1640,11 @@ mod bigint_tests {\n \n     #[test]\n     fn test_neg() {\n-        assert -BigInt::new(Plus,  ~[1, 1, 1]) ==\n-            BigInt::new(Minus, ~[1, 1, 1]);\n-        assert -BigInt::new(Minus, ~[1, 1, 1]) ==\n-            BigInt::new(Plus,  ~[1, 1, 1]);\n-        assert -Zero::zero::<BigInt>() == Zero::zero::<BigInt>();\n+        fail_unless!(-BigInt::new(Plus,  ~[1, 1, 1]) ==\n+            BigInt::new(Minus, ~[1, 1, 1]));\n+        fail_unless!(-BigInt::new(Minus, ~[1, 1, 1]) ==\n+            BigInt::new(Plus,  ~[1, 1, 1]));\n+        fail_unless!(-Zero::zero::<BigInt>() == Zero::zero::<BigInt>());\n     }\n }\n "}, {"sha": "b54c50da35c61be5d091bff73b77af5f902d693c", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -132,7 +132,7 @@ pub impl BigBitv {\n     fn process(&mut self, b: &BigBitv, nbits: uint,\n                op: fn(uint, uint) -> uint) -> bool {\n         let len = b.storage.len();\n-        assert (self.storage.len() == len);\n+        fail_unless!((self.storage.len() == len));\n         let mut changed = false;\n         for uint::range(0, len) |i| {\n             let mask = big_mask(nbits, i);\n@@ -300,7 +300,7 @@ pub impl Bitv {\n     /// Retrieve the value at index `i`\n     #[inline(always)]\n     pure fn get(&self, i: uint) -> bool {\n-       assert (i < self.nbits);\n+       fail_unless!((i < self.nbits));\n        match self.rep {\n          Big(ref b)   => b.get(i),\n          Small(ref s) => s.get(i)\n@@ -314,7 +314,7 @@ pub impl Bitv {\n      */\n     #[inline(always)]\n     fn set(&mut self, i: uint, x: bool) {\n-      assert (i < self.nbits);\n+      fail_unless!((i < self.nbits));\n       match self.rep {\n         Big(ref mut b)   => b.set(i, x),\n         Small(ref mut s) => s.set(i, x)\n@@ -482,7 +482,7 @@ pub impl Bitv {\n      * the bitvector and vector must have the same length\n      */\n     fn eq_vec(&self, v: ~[uint]) -> bool {\n-        assert self.nbits == v.len();\n+        fail_unless!(self.nbits == v.len());\n         let mut i = 0;\n         while i < self.nbits {\n             let w0 = self.get(i);\n@@ -723,7 +723,7 @@ impl Set<uint> for BitvSet {\n         let nbits = self.capacity();\n         if value >= nbits {\n             let newsize = uint::max(value, nbits * 2) / uint::bits + 1;\n-            assert newsize > self.bitv.storage.len();\n+            fail_unless!(newsize > self.bitv.storage.len());\n             self.bitv.storage.grow(newsize, &0);\n         }\n         self.size += 1;\n@@ -882,10 +882,10 @@ mod tests {\n     #[test]\n     pub fn test_to_str() {\n         let zerolen = Bitv::new(0u, false);\n-        assert zerolen.to_str() == ~\"\";\n+        fail_unless!(zerolen.to_str() == ~\"\");\n \n         let eightbits = Bitv::new(8u, false);\n-        assert eightbits.to_str() == ~\"00000000\";\n+        fail_unless!(eightbits.to_str() == ~\"00000000\");\n     }\n \n     #[test]\n@@ -894,24 +894,24 @@ mod tests {\n         let mut exp;\n         act = Bitv::new(0u, false);\n         exp = vec::from_elem::<uint>(0u, 0u);\n-        assert act.eq_vec(exp);\n+        fail_unless!(act.eq_vec(exp));\n     }\n \n     #[test]\n     pub fn test_1_element() {\n         let mut act;\n         act = Bitv::new(1u, false);\n-        assert act.eq_vec(~[0u]);\n+        fail_unless!(act.eq_vec(~[0u]));\n         act = Bitv::new(1u, true);\n-        assert act.eq_vec(~[1u]);\n+        fail_unless!(act.eq_vec(~[1u]));\n     }\n \n     #[test]\n     pub fn test_2_elements() {\n         let mut b = bitv::Bitv::new(2, false);\n         b.set(0, true);\n         b.set(1, false);\n-        assert b.to_str() == ~\"10\";\n+        fail_unless!(b.to_str() == ~\"10\");\n     }\n \n     #[test]\n@@ -920,11 +920,11 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(10u, false);\n-        assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+        fail_unless!((act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u])));\n         // all 1\n \n         act = Bitv::new(10u, true);\n-        assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n+        fail_unless!((act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u])));\n         // mixed\n \n         act = Bitv::new(10u, false);\n@@ -933,7 +933,7 @@ mod tests {\n         act.set(2u, true);\n         act.set(3u, true);\n         act.set(4u, true);\n-        assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n+        fail_unless!((act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u])));\n         // mixed\n \n         act = Bitv::new(10u, false);\n@@ -942,15 +942,15 @@ mod tests {\n         act.set(7u, true);\n         act.set(8u, true);\n         act.set(9u, true);\n-        assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n+        fail_unless!((act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u])));\n         // mixed\n \n         act = Bitv::new(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n         act.set(9u, true);\n-        assert (act.eq_vec(~[1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u]));\n+        fail_unless!((act.eq_vec(~[1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u])));\n     }\n \n     #[test]\n@@ -959,14 +959,14 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(31u, false);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = Bitv::new(31u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n@@ -981,7 +981,7 @@ mod tests {\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n@@ -996,7 +996,7 @@ mod tests {\n         act.set(21u, true);\n         act.set(22u, true);\n         act.set(23u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n@@ -1010,7 +1010,7 @@ mod tests {\n         act.set(28u, true);\n         act.set(29u, true);\n         act.set(30u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n@@ -1020,7 +1020,7 @@ mod tests {\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u]));\n@@ -1032,14 +1032,14 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(32u, false);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = Bitv::new(32u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n@@ -1054,7 +1054,7 @@ mod tests {\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1069,7 +1069,7 @@ mod tests {\n         act.set(21u, true);\n         act.set(22u, true);\n         act.set(23u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1084,7 +1084,7 @@ mod tests {\n         act.set(29u, true);\n         act.set(30u, true);\n         act.set(31u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n@@ -1095,7 +1095,7 @@ mod tests {\n         act.set(17u, true);\n         act.set(30u, true);\n         act.set(31u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 1u]));\n@@ -1107,14 +1107,14 @@ mod tests {\n         // all 0\n \n         act = Bitv::new(33u, false);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n         act = Bitv::new(33u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n@@ -1129,7 +1129,7 @@ mod tests {\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1144,7 +1144,7 @@ mod tests {\n         act.set(21u, true);\n         act.set(22u, true);\n         act.set(23u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n@@ -1159,7 +1159,7 @@ mod tests {\n         act.set(29u, true);\n         act.set(30u, true);\n         act.set(31u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n@@ -1171,7 +1171,7 @@ mod tests {\n         act.set(30u, true);\n         act.set(31u, true);\n         act.set(32u, true);\n-        assert (act.eq_vec(\n+        fail_unless!(act.eq_vec(\n                        ~[0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 1u, 1u, 1u]));\n@@ -1181,14 +1181,14 @@ mod tests {\n     pub fn test_equal_differing_sizes() {\n         let v0 = Bitv::new(10u, false);\n         let v1 = Bitv::new(11u, false);\n-        assert !v0.equal(&v1);\n+        fail_unless!(!v0.equal(&v1));\n     }\n \n     #[test]\n     pub fn test_equal_greatly_differing_sizes() {\n         let v0 = Bitv::new(10u, false);\n         let v1 = Bitv::new(110u, false);\n-        assert !v0.equal(&v1);\n+        fail_unless!(!v0.equal(&v1));\n     }\n \n     #[test]\n@@ -1199,7 +1199,7 @@ mod tests {\n         let mut b = bitv::Bitv::new(1, true);\n         b.set(0, true);\n \n-        assert a.equal(&b);\n+        fail_unless!(a.equal(&b));\n     }\n \n     #[test]\n@@ -1214,37 +1214,37 @@ mod tests {\n             b.set(i, true);\n         }\n \n-        assert a.equal(&b);\n+        fail_unless!(a.equal(&b));\n     }\n \n     #[test]\n     pub fn test_from_bytes() {\n         let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n         let str = ~\"10110110\" + ~\"00000000\" + ~\"11111111\";\n-        assert bitv.to_str() == str;\n+        fail_unless!(bitv.to_str() == str);\n     }\n \n     #[test]\n     pub fn test_to_bytes() {\n         let mut bv = Bitv::new(3, true);\n         bv.set(1, false);\n-        assert bv.to_bytes() == ~[0b10100000];\n+        fail_unless!(bv.to_bytes() == ~[0b10100000]);\n \n         let mut bv = Bitv::new(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n-        assert bv.to_bytes() == ~[0b00100000, 0b10000000];\n+        fail_unless!(bv.to_bytes() == ~[0b00100000, 0b10000000]);\n     }\n \n     #[test]\n     pub fn test_from_bools() {\n-        assert from_bools([true, false, true, true]).to_str() == ~\"1011\";\n+        fail_unless!(from_bools([true, false, true, true]).to_str() == ~\"1011\");\n     }\n \n     #[test]\n     pub fn test_to_bools() {\n         let bools = ~[false, false, true, false, false, true, true, false];\n-        assert from_bytes([0b00100110]).to_bools() == bools;\n+        fail_unless!(from_bytes([0b00100110]).to_bools() == bools);\n     }\n \n     #[test]\n@@ -1255,10 +1255,10 @@ mod tests {\n         b1.set(1, true);\n         b2.set(1, true);\n         b2.set(2, true);\n-        assert b1.difference(&b2);\n-        assert b1[0];\n-        assert !b1[1];\n-        assert !b1[2];\n+        fail_unless!(b1.difference(&b2));\n+        fail_unless!(b1[0]);\n+        fail_unless!(!b1[1]);\n+        fail_unless!(!b1[2]);\n     }\n \n     #[test]\n@@ -1269,10 +1269,10 @@ mod tests {\n         b1.set(40, true);\n         b2.set(40, true);\n         b2.set(80, true);\n-        assert b1.difference(&b2);\n-        assert b1[0];\n-        assert !b1[40];\n-        assert !b1[80];\n+        fail_unless!(b1.difference(&b2));\n+        fail_unless!(b1[0]);\n+        fail_unless!(!b1[40]);\n+        fail_unless!(!b1[80]);\n     }\n \n     #[test]\n@@ -1296,131 +1296,131 @@ mod tests {\n     #[test]\n     pub fn test_bitv_set_basic() {\n         let mut b = BitvSet::new();\n-        assert b.insert(3);\n-        assert !b.insert(3);\n-        assert b.contains(&3);\n-        assert b.insert(400);\n-        assert !b.insert(400);\n-        assert b.contains(&400);\n-        assert b.len() == 2;\n+        fail_unless!(b.insert(3));\n+        fail_unless!(!b.insert(3));\n+        fail_unless!(b.contains(&3));\n+        fail_unless!(b.insert(400));\n+        fail_unless!(!b.insert(400));\n+        fail_unless!(b.contains(&400));\n+        fail_unless!(b.len() == 2);\n     }\n \n     #[test]\n     fn test_bitv_set_intersection() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n \n-        assert a.insert(11);\n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(77);\n-        assert a.insert(103);\n-        assert a.insert(5);\n+        fail_unless!(a.insert(11));\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(77));\n+        fail_unless!(a.insert(103));\n+        fail_unless!(a.insert(5));\n \n-        assert b.insert(2);\n-        assert b.insert(11);\n-        assert b.insert(77);\n-        assert b.insert(5);\n-        assert b.insert(3);\n+        fail_unless!(b.insert(2));\n+        fail_unless!(b.insert(11));\n+        fail_unless!(b.insert(77));\n+        fail_unless!(b.insert(5));\n+        fail_unless!(b.insert(3));\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n         for a.intersection(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     fn test_bitv_set_difference() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n \n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(200);\n-        assert a.insert(500);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(200));\n+        fail_unless!(a.insert(500));\n \n-        assert b.insert(3);\n-        assert b.insert(200);\n+        fail_unless!(b.insert(3));\n+        fail_unless!(b.insert(200));\n \n         let mut i = 0;\n         let expected = [1, 5, 500];\n         for a.difference(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     fn test_bitv_set_symmetric_difference() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n \n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(9);\n-        assert a.insert(11);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(9));\n+        fail_unless!(a.insert(11));\n \n-        assert b.insert(3);\n-        assert b.insert(9);\n-        assert b.insert(14);\n-        assert b.insert(220);\n+        fail_unless!(b.insert(3));\n+        fail_unless!(b.insert(9));\n+        fail_unless!(b.insert(14));\n+        fail_unless!(b.insert(220));\n \n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 220];\n         for a.symmetric_difference(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     pub fn test_bitv_set_union() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(9);\n-        assert a.insert(11);\n-        assert a.insert(160);\n-        assert a.insert(19);\n-        assert a.insert(24);\n-\n-        assert b.insert(1);\n-        assert b.insert(5);\n-        assert b.insert(9);\n-        assert b.insert(13);\n-        assert b.insert(19);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(9));\n+        fail_unless!(a.insert(11));\n+        fail_unless!(a.insert(160));\n+        fail_unless!(a.insert(19));\n+        fail_unless!(a.insert(24));\n+\n+        fail_unless!(b.insert(1));\n+        fail_unless!(b.insert(5));\n+        fail_unless!(b.insert(9));\n+        fail_unless!(b.insert(13));\n+        fail_unless!(b.insert(19));\n \n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n         for a.union(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     pub fn test_bitv_remove() {\n         let mut a = BitvSet::new();\n \n-        assert a.insert(1);\n-        assert a.remove(&1);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.remove(&1));\n \n-        assert a.insert(100);\n-        assert a.remove(&100);\n+        fail_unless!(a.insert(100));\n+        fail_unless!(a.remove(&100));\n \n-        assert a.insert(1000);\n-        assert a.remove(&1000);\n-        assert a.capacity() == uint::bits;\n+        fail_unless!(a.insert(1000));\n+        fail_unless!(a.remove(&1000));\n+        fail_unless!(a.capacity() == uint::bits);\n     }\n \n     fn rng() -> rand::Rng {"}, {"sha": "8e75f694fa3d4698adab5e959945fa9215fbd632", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -119,7 +119,7 @@ pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n pub fn get<T:Copy>(t: CVec<T>, ofs: uint) -> T {\n-    assert ofs < len(t);\n+    fail_unless!(ofs < len(t));\n     return unsafe { *ptr::mut_offset(t.base, ofs) };\n }\n \n@@ -129,7 +129,7 @@ pub fn get<T:Copy>(t: CVec<T>, ofs: uint) -> T {\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n pub fn set<T:Copy>(t: CVec<T>, ofs: uint, v: T) {\n-    assert ofs < len(t);\n+    fail_unless!(ofs < len(t));\n     unsafe { *ptr::mut_offset(t.base, ofs) = v };\n }\n \n@@ -156,7 +156,7 @@ mod tests {\n         unsafe {\n             let mem = libc::malloc(n);\n \n-            assert mem as int != 0;\n+            fail_unless!(mem as int != 0);\n \n             return unsafe { c_vec_with_dtor(mem as *mut u8, n as uint,\n                                          || unsafe { free(mem) }) };\n@@ -169,9 +169,9 @@ mod tests {\n \n         set(cv, 3u, 8u8);\n         set(cv, 4u, 9u8);\n-        assert get(cv, 3u) == 8u8;\n-        assert get(cv, 4u) == 9u8;\n-        assert len(cv) == 16u;\n+        fail_unless!(get(cv, 3u) == 8u8);\n+        fail_unless!(get(cv, 4u) == 9u8);\n+        fail_unless!(len(cv) == 16u);\n     }\n \n     #[test]\n@@ -199,7 +199,7 @@ mod tests {\n \n         set(cv, 0u, 32u8);\n         set(cv, 1u, 33u8);\n-        assert unsafe { *p } == 32u8;\n+        fail_unless!(unsafe { *p } == 32u8);\n         set(cv, 2u, 34u8); /* safety */\n     }\n "}, {"sha": "b6362f83f4426386088612a02259594db7d720f3", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -53,15 +53,15 @@ impl FuzzyEq<f64> for f64 {\n \n #[test]\n fn test_fuzzy_equals() {\n-    assert (&1.0f).fuzzy_eq(&1.0);\n-    assert (&1.0f32).fuzzy_eq(&1.0f32);\n-    assert (&1.0f64).fuzzy_eq(&1.0f64);\n+    fail_unless!((&1.0f).fuzzy_eq(&1.0));\n+    fail_unless!((&1.0f32).fuzzy_eq(&1.0f32));\n+    fail_unless!((&1.0f64).fuzzy_eq(&1.0f64));\n }\n \n #[test]\n fn test_fuzzy_eq_eps() {\n-    assert (&1.2f).fuzzy_eq_eps(&0.9, &0.5);\n-    assert !(&1.5f).fuzzy_eq_eps(&0.9, &0.5);\n+    fail_unless!((&1.2f).fuzzy_eq_eps(&0.9, &0.5));\n+    fail_unless!(!(&1.5f).fuzzy_eq_eps(&0.9, &0.5));\n }\n \n #[test]\n@@ -87,16 +87,16 @@ mod test_complex{\n         let a = Complex {r: 0.9, i: 0.9};\n         let b = Complex {r: 0.9, i: 0.9};\n \n-        assert (a.fuzzy_eq(&b));\n+        fail_unless!((a.fuzzy_eq(&b)));\n     }\n \n     #[test]\n     fn test_fuzzy_eq_eps() {\n         let other = Complex {r: 0.9, i: 0.9};\n \n-        assert (&Complex {r: 0.9, i: 1.2}).fuzzy_eq_eps(&other, &0.5);\n-        assert (&Complex {r: 1.2, i: 0.9}).fuzzy_eq_eps(&other, &0.5);\n-        assert !(&Complex {r: 0.9, i: 1.5}).fuzzy_eq_eps(&other, &0.5);\n-        assert !(&Complex {r: 1.5, i: 0.9}).fuzzy_eq_eps(&other, &0.5);\n+        fail_unless!((&Complex {r: 0.9, i: 1.2}).fuzzy_eq_eps(&other, &0.5));\n+        fail_unless!((&Complex {r: 1.2, i: 0.9}).fuzzy_eq_eps(&other, &0.5));\n+        fail_unless!(!(&Complex {r: 0.9, i: 1.5}).fuzzy_eq_eps(&other, &0.5));\n+        fail_unless!(!(&Complex {r: 1.5, i: 0.9}).fuzzy_eq_eps(&other, &0.5));\n     }\n }"}, {"sha": "99f6fa4c8cf59124b5c292bd471929d5b0fe48c5", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -107,7 +107,7 @@ mod test {\n         left.send(~\"abc\");\n         right.send(123);\n \n-        assert left.recv() == 123;\n-        assert right.recv() == ~\"abc\";\n+        fail_unless!(left.recv() == 123);\n+        fail_unless!(right.recv() == ~\"abc\");\n     }\n }"}, {"sha": "33b0fd4eb6819c8db025443280bbf56d3f2ce6da", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -95,7 +95,7 @@ pub impl<T> Deque<T> {\n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere.\n fn grow<T>(nelts: uint, lo: uint, elts: &mut [Option<T>]) -> ~[Option<T>] {\n-    assert nelts == elts.len();\n+    fail_unless!(nelts == elts.len());\n     let mut rv = ~[];\n \n     do rv.grow_fn(nelts + 1) |i| {\n@@ -121,46 +121,46 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         let mut d = Deque::new();\n-        assert d.len() == 0u;\n+        fail_unless!(d.len() == 0u);\n         d.add_front(17);\n         d.add_front(42);\n         d.add_back(137);\n-        assert d.len() == 3u;\n+        fail_unless!(d.len() == 3u);\n         d.add_back(137);\n-        assert d.len() == 4u;\n+        fail_unless!(d.len() == 4u);\n         log(debug, d.peek_front());\n-        assert *d.peek_front() == 42;\n+        fail_unless!(*d.peek_front() == 42);\n         log(debug, d.peek_back());\n-        assert *d.peek_back() == 137;\n+        fail_unless!(*d.peek_back() == 137);\n         let mut i: int = d.pop_front();\n         log(debug, i);\n-        assert i == 42;\n+        fail_unless!(i == 42);\n         i = d.pop_back();\n         log(debug, i);\n-        assert i == 137;\n+        fail_unless!(i == 137);\n         i = d.pop_back();\n         log(debug, i);\n-        assert i == 137;\n+        fail_unless!(i == 137);\n         i = d.pop_back();\n         log(debug, i);\n-        assert i == 17;\n-        assert d.len() == 0u;\n+        fail_unless!(i == 17);\n+        fail_unless!(d.len() == 0u);\n         d.add_back(3);\n-        assert d.len() == 1u;\n+        fail_unless!(d.len() == 1u);\n         d.add_front(2);\n-        assert d.len() == 2u;\n+        fail_unless!(d.len() == 2u);\n         d.add_back(4);\n-        assert d.len() == 3u;\n+        fail_unless!(d.len() == 3u);\n         d.add_front(1);\n-        assert d.len() == 4u;\n+        fail_unless!(d.len() == 4u);\n         log(debug, d.get(0));\n         log(debug, d.get(1));\n         log(debug, d.get(2));\n         log(debug, d.get(3));\n-        assert *d.get(0) == 1;\n-        assert *d.get(1) == 2;\n-        assert *d.get(2) == 3;\n-        assert *d.get(3) == 4;\n+        fail_unless!(*d.get(0) == 1);\n+        fail_unless!(*d.get(1) == 2);\n+        fail_unless!(*d.get(2) == 3);\n+        fail_unless!(*d.get(3) == 4);\n     }\n \n     #[test]\n@@ -171,62 +171,62 @@ mod tests {\n         let d: @int = @175;\n \n         let mut deq = Deque::new();\n-        assert deq.len() == 0;\n+        fail_unless!(deq.len() == 0);\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        assert deq.len() == 3;\n+        fail_unless!(deq.len() == 3);\n         deq.add_back(d);\n-        assert deq.len() == 4;\n-        assert *deq.peek_front() == b;\n-        assert *deq.peek_back() == d;\n-        assert deq.pop_front() == b;\n-        assert deq.pop_back() == d;\n-        assert deq.pop_back() == c;\n-        assert deq.pop_back() == a;\n-        assert deq.len() == 0;\n+        fail_unless!(deq.len() == 4);\n+        fail_unless!(*deq.peek_front() == b);\n+        fail_unless!(*deq.peek_back() == d);\n+        fail_unless!(deq.pop_front() == b);\n+        fail_unless!(deq.pop_back() == d);\n+        fail_unless!(deq.pop_back() == c);\n+        fail_unless!(deq.pop_back() == a);\n+        fail_unless!(deq.len() == 0);\n         deq.add_back(c);\n-        assert deq.len() == 1;\n+        fail_unless!(deq.len() == 1);\n         deq.add_front(b);\n-        assert deq.len() == 2;\n+        fail_unless!(deq.len() == 2);\n         deq.add_back(d);\n-        assert deq.len() == 3;\n+        fail_unless!(deq.len() == 3);\n         deq.add_front(a);\n-        assert deq.len() == 4;\n-        assert *deq.get(0) == a;\n-        assert *deq.get(1) == b;\n-        assert *deq.get(2) == c;\n-        assert *deq.get(3) == d;\n+        fail_unless!(deq.len() == 4);\n+        fail_unless!(*deq.get(0) == a);\n+        fail_unless!(*deq.get(1) == b);\n+        fail_unless!(*deq.get(2) == c);\n+        fail_unless!(*deq.get(3) == d);\n     }\n \n     fn test_parameterized<T:Copy + Eq + Durable>(a: T, b: T, c: T, d: T) {\n         let mut deq = Deque::new();\n-        assert deq.len() == 0;\n+        fail_unless!(deq.len() == 0);\n         deq.add_front(a);\n         deq.add_front(b);\n         deq.add_back(c);\n-        assert deq.len() == 3;\n+        fail_unless!(deq.len() == 3);\n         deq.add_back(d);\n-        assert deq.len() == 4;\n-        assert *deq.peek_front() == b;\n-        assert *deq.peek_back() == d;\n-        assert deq.pop_front() == b;\n-        assert deq.pop_back() == d;\n-        assert deq.pop_back() == c;\n-        assert deq.pop_back() == a;\n-        assert deq.len() == 0;\n+        fail_unless!(deq.len() == 4);\n+        fail_unless!(*deq.peek_front() == b);\n+        fail_unless!(*deq.peek_back() == d);\n+        fail_unless!(deq.pop_front() == b);\n+        fail_unless!(deq.pop_back() == d);\n+        fail_unless!(deq.pop_back() == c);\n+        fail_unless!(deq.pop_back() == a);\n+        fail_unless!(deq.len() == 0);\n         deq.add_back(c);\n-        assert deq.len() == 1;\n+        fail_unless!(deq.len() == 1);\n         deq.add_front(b);\n-        assert deq.len() == 2;\n+        fail_unless!(deq.len() == 2);\n         deq.add_back(d);\n-        assert deq.len() == 3;\n+        fail_unless!(deq.len() == 3);\n         deq.add_front(a);\n-        assert deq.len() == 4;\n-        assert *deq.get(0) == a;\n-        assert *deq.get(1) == b;\n-        assert *deq.get(2) == c;\n-        assert *deq.get(3) == d;\n+        fail_unless!(deq.len() == 4);\n+        fail_unless!(*deq.get(0) == a);\n+        fail_unless!(*deq.get(1) == b);\n+        fail_unless!(*deq.get(2) == c);\n+        fail_unless!(*deq.get(3) == d);\n     }\n \n     #[deriving_eq]"}, {"sha": "44461ae06fff401908bb3e16f3a6aa22e8c7db15", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -182,22 +182,22 @@ pub mod reader {\n     pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n-        assert d.end == d.start + 1u;\n+        fail_unless!(d.end == d.start + 1u);\n         (*d.data)[d.start]\n     }\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n-        assert d.end == d.start + 2u;\n+        fail_unless!(d.end == d.start + 2u);\n         io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n-        assert d.end == d.start + 4u;\n+        fail_unless!(d.end == d.start + 4u);\n         io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n-        assert d.end == d.start + 8u;\n+        fail_unless!(d.end == d.start + 8u);\n         io::u64_from_be_bytes(*d.data, d.start, 8u)\n     }\n \n@@ -550,7 +550,7 @@ pub mod writer {\n     priv impl Encoder {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&self, t: EbmlEncoderTag, v: uint) {\n-            assert v <= 0xFFFF_FFFF_u;\n+            fail_unless!(v <= 0xFFFF_FFFF_u);\n             self.wr_tagged_u32(t as uint, v as u32);\n         }\n \n@@ -694,7 +694,7 @@ mod tests {\n             let deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&deser);\n             debug!(\"v1 == %?\", v1);\n-            assert v == v1;\n+            fail_unless!(v == v1);\n         }\n \n         test_v(Some(22));"}, {"sha": "734e6e835815c29377eee549eff4cc4039d1334a", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -358,8 +358,8 @@ pub mod flatteners {\n \n     impl<T:Copy + Owned> Unflattener<T> for PodUnflattener<T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n-            assert size_of::<T>() != 0;\n-            assert size_of::<T>() == buf.len();\n+            fail_unless!(size_of::<T>() != 0);\n+            fail_unless!(size_of::<T>() == buf.len());\n             let addr_of_init: &u8 = unsafe { &*vec::raw::to_ptr(buf) };\n             let addr_of_value: &T = unsafe { cast::transmute(addr_of_init) };\n             copy *addr_of_value\n@@ -368,7 +368,7 @@ pub mod flatteners {\n \n     impl<T:Copy + Owned> Flattener<T> for PodFlattener<T> {\n         fn flatten(&self, val: T) -> ~[u8] {\n-            assert size_of::<T>() != 0;\n+            fail_unless!(size_of::<T>() != 0);\n             let val: *T = ptr::to_unsafe_ptr(&val);\n             let byte_value = val as *u8;\n             unsafe { vec::from_buf(byte_value, size_of::<T>()) }\n@@ -521,11 +521,11 @@ pub mod bytepipes {\n             let mut left = count;\n             let mut bytes = ~[];\n             while !self.reader.eof() && left > 0 {\n-                assert left <= count;\n-                assert left > 0;\n+                fail_unless!(left <= count);\n+                fail_unless!(left > 0);\n                 let new_bytes = self.reader.read_bytes(left);\n                 bytes.push_all(new_bytes);\n-                assert new_bytes.len() <= left;\n+                fail_unless!(new_bytes.len() <= left);\n                 left -= new_bytes.len();\n             }\n \n@@ -578,7 +578,7 @@ pub mod bytepipes {\n                 return Some(bytes);\n             } else if self.buf.len() > 0 {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n-                assert count > bytes.len();\n+                fail_unless!(count > bytes.len());\n                 match self.try_recv(count - bytes.len()) {\n                     Some(rest) => {\n                         bytes.push_all(rest);\n@@ -589,7 +589,7 @@ pub mod bytepipes {\n             } else if self.buf.is_empty() {\n                 match self.port.try_recv() {\n                     Some(buf) => {\n-                        assert !buf.is_empty();\n+                        fail_unless!(!buf.is_empty());\n                         self.buf = buf;\n                         return self.try_recv(count);\n                     }\n@@ -657,7 +657,7 @@ mod test {\n         let port = serial::reader_port(reader);\n \n         let res: int = port.recv();\n-        assert res == 10i;\n+        fail_unless!(res == 10i);\n     }\n \n     #[test]\n@@ -671,7 +671,7 @@ mod test {\n         }\n \n         for int::range(0, 10) |i| {\n-            assert i == port.recv()\n+            fail_unless!(i == port.recv())\n         }\n     }\n \n@@ -686,7 +686,7 @@ mod test {\n         }\n \n         for int::range(0, 10) |i| {\n-            assert @i == port.recv()\n+            fail_unless!(@i == port.recv())\n         }\n     }\n \n@@ -703,7 +703,7 @@ mod test {\n         let port = pod::reader_port(reader);\n \n         let res: int = port.recv();\n-        assert res == 10;\n+        fail_unless!(res == 10);\n     }\n \n     #[test]\n@@ -717,7 +717,7 @@ mod test {\n         }\n \n         for int::range(0, 10) |i| {\n-            assert i == port.recv()\n+            fail_unless!(i == port.recv())\n         }\n     }\n \n@@ -801,7 +801,7 @@ mod test {\n                 kill_ch.send(None)\n             };\n \n-            assert listen_res.is_ok();\n+            fail_unless!(listen_res.is_ok());\n         }\n \n         // Client task\n@@ -814,7 +814,7 @@ mod test {\n             debug!(\"connecting\");\n             let iotask = &uv::global_loop::get();\n             let connect_result = tcp::connect(copy addr, port, iotask);\n-            assert connect_result.is_ok();\n+            fail_unless!(connect_result.is_ok());\n             let sock = result::unwrap(connect_result);\n             let socket_buf: tcp::TcpSocketBuf = tcp::socket_buf(sock);\n \n@@ -835,7 +835,7 @@ mod test {\n             debug!(\"accepting connection\");\n             let accept_result = tcp::accept(conn);\n             debug!(\"accepted\");\n-            assert accept_result.is_ok();\n+            fail_unless!(accept_result.is_ok());\n             let sock = result::unwrap(accept_result);\n             res_chan.send(());\n \n@@ -847,7 +847,7 @@ mod test {\n             for int::range(0, 10) |i| {\n                 let j = port.recv();\n                 debug!(\"receieved %?\", j);\n-                assert i == j;\n+                fail_unless!(i == j);\n             }\n \n             // The test is over!\n@@ -893,7 +893,7 @@ mod test {\n             let bytes = ~[];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n-            assert res.is_none();\n+            fail_unless!(res.is_none());\n         }\n \n         #[test]\n@@ -910,7 +910,7 @@ mod test {\n             let bytes = ~[0];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n-            assert res.is_none();\n+            fail_unless!(res.is_none());\n         }\n \n         #[test]\n@@ -928,7 +928,7 @@ mod test {\n             let bytes = CONTINUE.to_vec() + ~[0];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n-            assert res.is_none();\n+            fail_unless!(res.is_none());\n         }\n \n         #[test]\n@@ -941,7 +941,7 @@ mod test {\n         }\n \n         fn test_try_recv_none4<P:BytePort>(+loader: PortLoader<P>) {\n-            assert do task::try || {\n+            fail_unless!(do task::try || {\n                 const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n                 // The control word is followed by a valid length,\n                 // then undeserializable garbage\n@@ -954,7 +954,7 @@ mod test {\n                 let port = loader(bytes);\n \n                 let _res: Option<int> = port.try_recv();\n-            }.is_err();\n+            }.is_err());\n         }\n \n         #[test]"}, {"sha": "5dc264cb8784b8360087e0a86434808af315f541", "filename": "src/libstd/future.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -154,39 +154,39 @@ pub mod test {\n     #[test]\n     pub fn test_from_value() {\n         let f = from_value(~\"snail\");\n-        assert f.get() == ~\"snail\";\n+        fail_unless!(f.get() == ~\"snail\");\n     }\n \n     #[test]\n     pub fn test_from_port() {\n         let (ch, po) = oneshot::init();\n         send_one(ch, ~\"whale\");\n         let f = from_port(po);\n-        assert f.get() == ~\"whale\";\n+        fail_unless!(f.get() == ~\"whale\");\n     }\n \n     #[test]\n     pub fn test_from_fn() {\n         let f = from_fn(|| ~\"brail\");\n-        assert f.get() == ~\"brail\";\n+        fail_unless!(f.get() == ~\"brail\");\n     }\n \n     #[test]\n     pub fn test_interface_get() {\n         let f = from_value(~\"fail\");\n-        assert f.get() == ~\"fail\";\n+        fail_unless!(f.get() == ~\"fail\");\n     }\n \n     #[test]\n     pub fn test_get_ref_method() {\n         let f = from_value(22);\n-        assert *f.get_ref() == 22;\n+        fail_unless!(*f.get_ref() == 22);\n     }\n \n     #[test]\n     pub fn test_spawn() {\n         let f = spawn(|| ~\"bale\");\n-        assert f.get() == ~\"bale\";\n+        fail_unless!(f.get() == ~\"bale\");\n     }\n \n     #[test]\n@@ -203,7 +203,7 @@ pub mod test {\n         let f = do spawn { copy expected };\n         do task::spawn || {\n             let actual = f.get();\n-            assert actual == expected;\n+            fail_unless!(actual == expected);\n         }\n     }\n }"}, {"sha": "2090a3728db52c8d953f654a55e37c2e7f3f774d", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -480,7 +480,7 @@ pub mod groups {\n     pub fn reqopt(short_name: &str, long_name: &str,\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        assert len == 1 || len == 0;\n+        fail_unless!(len == 1 || len == 0);\n         return OptGroup { short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -493,7 +493,7 @@ pub mod groups {\n     pub fn optopt(short_name: &str, long_name: &str,\n                   desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        assert len == 1 || len == 0;\n+        fail_unless!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -506,7 +506,7 @@ pub mod groups {\n     pub fn optflag(short_name: &str, long_name: &str,\n                    desc: &str) -> OptGroup {\n         let len = short_name.len();\n-        assert len == 1 || len == 0;\n+        fail_unless!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: ~\"\",\n@@ -519,7 +519,7 @@ pub mod groups {\n     pub fn optflagopt(short_name: &str, long_name: &str,\n                       desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        assert len == 1 || len == 0;\n+        fail_unless!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -535,7 +535,7 @@ pub mod groups {\n     pub fn optmulti(short_name: &str, long_name: &str,\n                     desc: &str, hint: &str) -> OptGroup {\n         let len = short_name.len();\n-        assert len == 1 || len == 0;\n+        fail_unless!(len == 1 || len == 0);\n         return OptGroup {short_name: str::from_slice(short_name),\n                 long_name: str::from_slice(long_name),\n                 hint: str::from_slice(hint),\n@@ -647,11 +647,11 @@ mod tests {\n \n     pub fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {\n-          ArgumentMissing(_) => assert ft == ArgumentMissing_,\n-          UnrecognizedOption(_) => assert ft == UnrecognizedOption_,\n-          OptionMissing(_) => assert ft == OptionMissing_,\n-          OptionDuplicated(_) => assert ft == OptionDuplicated_,\n-          UnexpectedArgument(_) => assert ft == UnexpectedArgument_\n+          ArgumentMissing(_) => fail_unless!(ft == ArgumentMissing_),\n+          UnrecognizedOption(_) => fail_unless!(ft == UnrecognizedOption_),\n+          OptionMissing(_) => fail_unless!(ft == OptionMissing_),\n+          OptionDuplicated(_) => fail_unless!(ft == OptionDuplicated_),\n+          UnexpectedArgument(_) => fail_unless!(ft == UnexpectedArgument_)\n         }\n     }\n \n@@ -664,8 +664,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"test\"));\n-            assert (opt_str(m, ~\"test\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"test\")));\n+            fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n           }\n           _ => { fail!(~\"test_reqopt_long failed\"); }\n         }\n@@ -711,8 +711,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"t\"));\n-            assert (opt_str(m, ~\"t\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"t\")));\n+            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -760,8 +760,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"test\"));\n-            assert (opt_str(m, ~\"test\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"test\")));\n+            fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -773,7 +773,7 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"test\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -807,8 +807,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"t\"));\n-            assert (opt_str(m, ~\"t\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"t\")));\n+            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -820,7 +820,7 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"t\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -855,7 +855,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (opt_present(m, ~\"test\")),\n+          Ok(ref m) => fail_unless!(opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -866,7 +866,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"test\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -902,7 +902,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (opt_present(m, ~\"t\")),\n+          Ok(ref m) => fail_unless!(opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -913,7 +913,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"t\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -927,7 +927,7 @@ mod tests {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            assert (m.free[0] == ~\"20\");\n+            fail_unless!((m.free[0] == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -952,7 +952,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_count(m, ~\"v\") == 1);\n+            fail_unless!((opt_count(m, ~\"v\") == 1));\n           }\n           _ => fail!()\n         }\n@@ -965,7 +965,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_count(m, ~\"v\") == 2);\n+            fail_unless!((opt_count(m, ~\"v\") == 2));\n           }\n           _ => fail!()\n         }\n@@ -978,7 +978,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_count(m, ~\"v\") == 2);\n+            fail_unless!((opt_count(m, ~\"v\") == 2));\n           }\n           _ => fail!()\n         }\n@@ -991,7 +991,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_count(m, ~\"verbose\") == 1);\n+            fail_unless!((opt_count(m, ~\"verbose\") == 1));\n           }\n           _ => fail!()\n         }\n@@ -1004,7 +1004,7 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_count(m, ~\"verbose\") == 2);\n+            fail_unless!((opt_count(m, ~\"verbose\") == 2));\n           }\n           _ => fail!()\n         }\n@@ -1018,8 +1018,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"test\"));\n-            assert (opt_str(m, ~\"test\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"test\")));\n+            fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -1031,7 +1031,7 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"test\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"test\")),\n           _ => fail!()\n         }\n     }\n@@ -1054,11 +1054,11 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-              assert (opt_present(m, ~\"test\"));\n-              assert (opt_str(m, ~\"test\") == ~\"20\");\n+              fail_unless!((opt_present(m, ~\"test\")));\n+              fail_unless!((opt_str(m, ~\"test\") == ~\"20\"));\n               let pair = opt_strs(m, ~\"test\");\n-              assert (pair[0] == ~\"20\");\n-              assert (pair[1] == ~\"30\");\n+              fail_unless!((pair[0] == ~\"20\"));\n+              fail_unless!((pair[1] == ~\"30\"));\n           }\n           _ => fail!()\n         }\n@@ -1071,8 +1071,8 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"t\"));\n-            assert (opt_str(m, ~\"t\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"t\")));\n+            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n           }\n           _ => fail!()\n         }\n@@ -1084,7 +1084,7 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert (!opt_present(m, ~\"t\")),\n+          Ok(ref m) => fail_unless!(!opt_present(m, ~\"t\")),\n           _ => fail!()\n         }\n     }\n@@ -1107,11 +1107,11 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (opt_present(m, ~\"t\"));\n-            assert (opt_str(m, ~\"t\") == ~\"20\");\n+            fail_unless!((opt_present(m, ~\"t\")));\n+            fail_unless!((opt_str(m, ~\"t\") == ~\"20\"));\n             let pair = opt_strs(m, ~\"t\");\n-            assert (pair[0] == ~\"20\");\n-            assert (pair[1] == ~\"30\");\n+            fail_unless!((pair[0] == ~\"20\"));\n+            fail_unless!((pair[1] == ~\"30\"));\n           }\n           _ => fail!()\n         }\n@@ -1152,20 +1152,20 @@ mod tests {\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert (m.free[0] == ~\"prog\");\n-            assert (m.free[1] == ~\"free1\");\n-            assert (opt_str(m, ~\"s\") == ~\"20\");\n-            assert (m.free[2] == ~\"free2\");\n-            assert (opt_present(m, ~\"flag\"));\n-            assert (opt_str(m, ~\"long\") == ~\"30\");\n-            assert (opt_present(m, ~\"f\"));\n+            fail_unless!((m.free[0] == ~\"prog\"));\n+            fail_unless!((m.free[1] == ~\"free1\"));\n+            fail_unless!((opt_str(m, ~\"s\") == ~\"20\"));\n+            fail_unless!((m.free[2] == ~\"free2\"));\n+            fail_unless!((opt_present(m, ~\"flag\")));\n+            fail_unless!((opt_str(m, ~\"long\") == ~\"30\"));\n+            fail_unless!((opt_present(m, ~\"f\")));\n             let pair = opt_strs(m, ~\"m\");\n-            assert (pair[0] == ~\"40\");\n-            assert (pair[1] == ~\"50\");\n+            fail_unless!((pair[0] == ~\"40\"));\n+            fail_unless!((pair[1] == ~\"50\"));\n             let pair = opt_strs(m, ~\"n\");\n-            assert (pair[0] == ~\"-A B\");\n-            assert (pair[1] == ~\"-60 70\");\n-            assert (!opt_present(m, ~\"notpresent\"));\n+            fail_unless!((pair[0] == ~\"-A B\"));\n+            fail_unless!((pair[1] == ~\"-60 70\"));\n+            fail_unless!((!opt_present(m, ~\"notpresent\")));\n           }\n           _ => fail!()\n         }\n@@ -1179,17 +1179,17 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert opts_present(matches, ~[~\"e\"]);\n-        assert opts_present(matches, ~[~\"encrypt\"]);\n-        assert opts_present(matches, ~[~\"encrypt\", ~\"e\"]);\n-        assert opts_present(matches, ~[~\"e\", ~\"encrypt\"]);\n-        assert !opts_present(matches, ~[~\"thing\"]);\n-        assert !opts_present(matches, ~[]);\n+        fail_unless!(opts_present(matches, ~[~\"e\"]));\n+        fail_unless!(opts_present(matches, ~[~\"encrypt\"]));\n+        fail_unless!(opts_present(matches, ~[~\"encrypt\", ~\"e\"]));\n+        fail_unless!(opts_present(matches, ~[~\"e\", ~\"encrypt\"]));\n+        fail_unless!(!opts_present(matches, ~[~\"thing\"]));\n+        fail_unless!(!opts_present(matches, ~[]));\n \n-        assert opts_str(matches, ~[~\"e\"]) == ~\"foo\";\n-        assert opts_str(matches, ~[~\"encrypt\"]) == ~\"foo\";\n-        assert opts_str(matches, ~[~\"e\", ~\"encrypt\"]) == ~\"foo\";\n-        assert opts_str(matches, ~[~\"encrypt\", ~\"e\"]) == ~\"foo\";\n+        fail_unless!(opts_str(matches, ~[~\"e\"]) == ~\"foo\");\n+        fail_unless!(opts_str(matches, ~[~\"encrypt\"]) == ~\"foo\");\n+        fail_unless!(opts_str(matches, ~[~\"e\", ~\"encrypt\"]) == ~\"foo\");\n+        fail_unless!(opts_str(matches, ~[~\"encrypt\", ~\"e\"]) == ~\"foo\");\n     }\n \n     #[test]\n@@ -1200,68 +1200,68 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert opts_present(matches, ~[~\"L\"]);\n-        assert opts_str(matches, ~[~\"L\"]) == ~\"foo\";\n-        assert opts_present(matches, ~[~\"M\"]);\n-        assert opts_str(matches, ~[~\"M\"]) == ~\".\";\n+        fail_unless!(opts_present(matches, ~[~\"L\"]));\n+        fail_unless!(opts_str(matches, ~[~\"L\"]) == ~\"foo\");\n+        fail_unless!(opts_present(matches, ~[~\"M\"]));\n+        fail_unless!(opts_str(matches, ~[~\"M\"]) == ~\".\");\n \n     }\n \n     #[test]\n     pub fn test_groups_reqopt() {\n         let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n-        assert opt == OptGroup { short_name: ~\"b\",\n+        fail_unless!(opt == OptGroup { short_name: ~\"b\",\n                         long_name: ~\"banana\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some bananas\",\n                         hasarg: Yes,\n-                        occur: Req }\n+                        occur: Req })\n     }\n \n     #[test]\n     pub fn test_groups_optopt() {\n         let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n-        assert opt == OptGroup { short_name: ~\"a\",\n+        fail_unless!(opt == OptGroup { short_name: ~\"a\",\n                         long_name: ~\"apple\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some apples\",\n                         hasarg: Yes,\n-                        occur: Optional }\n+                        occur: Optional })\n     }\n \n     #[test]\n     pub fn test_groups_optflag() {\n         let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n-        assert opt == OptGroup { short_name: ~\"k\",\n+        fail_unless!(opt == OptGroup { short_name: ~\"k\",\n                         long_name: ~\"kiwi\",\n                         hint: ~\"\",\n                         desc: ~\"some kiwis\",\n                         hasarg: No,\n-                        occur: Optional }\n+                        occur: Optional })\n     }\n \n     #[test]\n     pub fn test_groups_optflagopt() {\n         let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n                                        ~\"some pineapples\", ~\"VAL\");\n-        assert opt == OptGroup { short_name: ~\"p\",\n+        fail_unless!(opt == OptGroup { short_name: ~\"p\",\n                         long_name: ~\"pineapple\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some pineapples\",\n                         hasarg: Maybe,\n-                        occur: Optional }\n+                        occur: Optional })\n     }\n \n     #[test]\n     pub fn test_groups_optmulti() {\n         let opt = groups::optmulti(~\"l\", ~\"lime\",\n                                      ~\"some limes\", ~\"VAL\");\n-        assert opt == OptGroup { short_name: ~\"l\",\n+        fail_unless!(opt == OptGroup { short_name: ~\"l\",\n                         long_name: ~\"lime\",\n                         hint: ~\"VAL\",\n                         desc: ~\"some limes\",\n                         hasarg: Yes,\n-                        occur: Multi }\n+                        occur: Multi })\n     }\n \n     #[test]\n@@ -1270,7 +1270,7 @@ mod tests {\n         let verbose = groups::reqopt(~\"b\", ~\"banana\",\n                                        ~\"some bananas\", ~\"VAL\");\n \n-        assert groups::long_to_short(&verbose) == short;\n+        fail_unless!(groups::long_to_short(&verbose) == short);\n     }\n \n     #[test]\n@@ -1295,8 +1295,8 @@ mod tests {\n                             ~\"-p\", ~\"16\", ~\"l\", ~\"35\"];\n \n         // FIXME #4681: sort options here?\n-        assert getopts(sample_args, short)\n-            == groups::getopts(sample_args, verbose);\n+        fail_unless!(getopts(sample_args, short)\n+            == groups::getopts(sample_args, verbose));\n     }\n \n     #[test]\n@@ -1327,7 +1327,7 @@ Options:\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", generated_usage);\n-        assert generated_usage == expected;\n+        fail_unless!(generated_usage == expected);\n     }\n \n     #[test]\n@@ -1356,7 +1356,7 @@ Options:\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", usage);\n-        assert usage == expected\n+        fail_unless!(usage == expected)\n     }\n }\n "}, {"sha": "01e0b58f77e5cbb2077b3c5e7a15d4bcf028d77b", "filename": "src/libstd/json.rs", "status": "modified", "additions": 177, "deletions": 144, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1229,45 +1229,45 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        assert to_str(&Null) == ~\"null\";\n+        fail_unless!(to_str(&Null) == ~\"null\");\n     }\n \n     #[test]\n     fn test_write_number() {\n-        assert to_str(&Number(3f)) == ~\"3\";\n-        assert to_str(&Number(3.1f)) == ~\"3.1\";\n-        assert to_str(&Number(-1.5f)) == ~\"-1.5\";\n-        assert to_str(&Number(0.5f)) == ~\"0.5\";\n+        fail_unless!(to_str(&Number(3f)) == ~\"3\");\n+        fail_unless!(to_str(&Number(3.1f)) == ~\"3.1\");\n+        fail_unless!(to_str(&Number(-1.5f)) == ~\"-1.5\");\n+        fail_unless!(to_str(&Number(0.5f)) == ~\"0.5\");\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert to_str(&String(~\"\")) == ~\"\\\"\\\"\";\n-        assert to_str(&String(~\"foo\")) == ~\"\\\"foo\\\"\";\n+        fail_unless!(to_str(&String(~\"\")) == ~\"\\\"\\\"\");\n+        fail_unless!(to_str(&String(~\"foo\")) == ~\"\\\"foo\\\"\");\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert to_str(&Boolean(true)) == ~\"true\";\n-        assert to_str(&Boolean(false)) == ~\"false\";\n+        fail_unless!(to_str(&Boolean(true)) == ~\"true\");\n+        fail_unless!(to_str(&Boolean(false)) == ~\"false\");\n     }\n \n     #[test]\n     fn test_write_list() {\n-        assert to_str(&List(~[])) == ~\"[]\";\n-        assert to_str(&List(~[Boolean(true)])) == ~\"[true]\";\n-        assert to_str(&List(~[\n+        fail_unless!(to_str(&List(~[])) == ~\"[]\");\n+        fail_unless!(to_str(&List(~[Boolean(true)])) == ~\"[true]\");\n+        fail_unless!(to_str(&List(~[\n             Boolean(false),\n             Null,\n             List(~[String(~\"foo\\nbar\"), Number(3.5f)])\n-        ])) == ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\";\n+        ])) == ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n     }\n \n     #[test]\n     fn test_write_object() {\n-        assert to_str(&mk_object(~[])) == ~\"{}\";\n-        assert to_str(&mk_object(~[(~\"a\", Boolean(true))]))\n-            == ~\"{\\\"a\\\":true}\";\n+        fail_unless!(to_str(&mk_object(~[])) == ~\"{}\");\n+        fail_unless!(to_str(&mk_object(~[(~\"a\", Boolean(true))]))\n+            == ~\"{\\\"a\\\":true}\");\n         let a = mk_object(~[\n             (~\"a\", Boolean(true)),\n             (~\"b\", List(~[\n@@ -1278,7 +1278,7 @@ mod tests {\n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n         let b = result::unwrap(from_str(to_str(&a)));\n-        assert a == b;\n+        fail_unless!(a == b);\n     }\n \n     // two fns copied from libsyntax/util/testing.rs.\n@@ -1347,165 +1347,195 @@ mod tests {\n \n     #[test]\n     fn test_trailing_characters() {\n-        assert from_str(~\"nulla\") ==\n-            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"});\n-        assert from_str(~\"truea\") ==\n-            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"});\n-        assert from_str(~\"falsea\") ==\n-            Err(Error {line: 1u, col: 6u, msg: @~\"trailing characters\"});\n-        assert from_str(~\"1a\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"trailing characters\"});\n-        assert from_str(~\"[]a\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"});\n-        assert from_str(~\"{}a\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"});\n+        fail_unless!(from_str(~\"nulla\") ==\n+            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n+        fail_unless!(from_str(~\"truea\") ==\n+            Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n+        fail_unless!(from_str(~\"falsea\") ==\n+            Err(Error {line: 1u, col: 6u, msg: @~\"trailing characters\"}));\n+        fail_unless!(from_str(~\"1a\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"trailing characters\"}));\n+        fail_unless!(from_str(~\"[]a\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n+        fail_unless!(from_str(~\"{}a\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n-        assert from_str(~\"n\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n-        assert from_str(~\"nul\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+        fail_unless!(from_str(~\"n\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n+        fail_unless!(from_str(~\"nul\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n \n-        assert from_str(~\"t\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n-        assert from_str(~\"truz\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n+        fail_unless!(from_str(~\"t\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n+        fail_unless!(from_str(~\"truz\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n \n-        assert from_str(~\"f\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"});\n-        assert from_str(~\"faz\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"invalid syntax\"});\n+        fail_unless!(from_str(~\"f\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n+        fail_unless!(from_str(~\"faz\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"invalid syntax\"}));\n \n-        assert from_str(~\"null\") == Ok(Null);\n-        assert from_str(~\"true\") == Ok(Boolean(true));\n-        assert from_str(~\"false\") == Ok(Boolean(false));\n-        assert from_str(~\" null \") == Ok(Null);\n-        assert from_str(~\" true \") == Ok(Boolean(true));\n-        assert from_str(~\" false \") == Ok(Boolean(false));\n+        fail_unless!(from_str(~\"null\") == Ok(Null));\n+        fail_unless!(from_str(~\"true\") == Ok(Boolean(true)));\n+        fail_unless!(from_str(~\"false\") == Ok(Boolean(false)));\n+        fail_unless!(from_str(~\" null \") == Ok(Null));\n+        fail_unless!(from_str(~\" true \") == Ok(Boolean(true)));\n+        fail_unless!(from_str(~\" false \") == Ok(Boolean(false)));\n     }\n \n     #[test]\n     fn test_read_number() {\n-        assert from_str(~\"+\") ==\n-            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n-        assert from_str(~\".\") ==\n-            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"});\n-\n-        assert from_str(~\"-\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"});\n-        assert from_str(~\"00\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"});\n-        assert from_str(~\"1.\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"});\n-        assert from_str(~\"1e\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"});\n-        assert from_str(~\"1e+\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid number\"});\n-\n-        assert from_str(~\"3\") == Ok(Number(3f));\n-        assert from_str(~\"3.1\") == Ok(Number(3.1f));\n-        assert from_str(~\"-1.2\") == Ok(Number(-1.2f));\n-        assert from_str(~\"0.4\") == Ok(Number(0.4f));\n-        assert from_str(~\"0.4e5\") == Ok(Number(0.4e5f));\n-        assert from_str(~\"0.4e+15\") == Ok(Number(0.4e15f));\n-        assert from_str(~\"0.4e-01\") == Ok(Number(0.4e-01f));\n-        assert from_str(~\" 3 \") == Ok(Number(3f));\n+        fail_unless!(from_str(~\"+\") ==\n+            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n+        fail_unless!(from_str(~\".\") ==\n+            Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n+\n+        fail_unless!(from_str(~\"-\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n+        fail_unless!(from_str(~\"00\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n+        fail_unless!(from_str(~\"1.\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n+        fail_unless!(from_str(~\"1e\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n+        fail_unless!(from_str(~\"1e+\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid number\"}));\n+\n+        fail_unless!(from_str(~\"3\") == Ok(Number(3f)));\n+        fail_unless!(from_str(~\"3.1\") == Ok(Number(3.1f)));\n+        fail_unless!(from_str(~\"-1.2\") == Ok(Number(-1.2f)));\n+        fail_unless!(from_str(~\"0.4\") == Ok(Number(0.4f)));\n+        fail_unless!(from_str(~\"0.4e5\") == Ok(Number(0.4e5f)));\n+        fail_unless!(from_str(~\"0.4e+15\") == Ok(Number(0.4e15f)));\n+        fail_unless!(from_str(~\"0.4e-01\") == Ok(Number(0.4e-01f)));\n+        fail_unless!(from_str(~\" 3 \") == Ok(Number(3f)));\n     }\n \n     #[test]\n     fn test_read_str() {\n-        assert from_str(~\"\\\"\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing string\"});\n-        assert from_str(~\"\\\"lol\") ==\n-            Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing string\"});\n-\n-        assert from_str(~\"\\\"\\\"\") == Ok(String(~\"\"));\n-        assert from_str(~\"\\\"foo\\\"\") == Ok(String(~\"foo\"));\n-        assert from_str(~\"\\\"\\\\\\\"\\\"\") == Ok(String(~\"\\\"\"));\n-        assert from_str(~\"\\\"\\\\b\\\"\") == Ok(String(~\"\\x08\"));\n-        assert from_str(~\"\\\"\\\\n\\\"\") == Ok(String(~\"\\n\"));\n-        assert from_str(~\"\\\"\\\\r\\\"\") == Ok(String(~\"\\r\"));\n-        assert from_str(~\"\\\"\\\\t\\\"\") == Ok(String(~\"\\t\"));\n-        assert from_str(~\" \\\"foo\\\" \") == Ok(String(~\"foo\"));\n+        fail_unless!(from_str(~\"\\\"\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing string\"\n+        }));\n+        fail_unless!(from_str(~\"\\\"lol\") ==\n+            Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing string\"\n+        }));\n+\n+        fail_unless!(from_str(~\"\\\"\\\"\") == Ok(String(~\"\")));\n+        fail_unless!(from_str(~\"\\\"foo\\\"\") == Ok(String(~\"foo\")));\n+        fail_unless!(from_str(~\"\\\"\\\\\\\"\\\"\") == Ok(String(~\"\\\"\")));\n+        fail_unless!(from_str(~\"\\\"\\\\b\\\"\") == Ok(String(~\"\\x08\")));\n+        fail_unless!(from_str(~\"\\\"\\\\n\\\"\") == Ok(String(~\"\\n\")));\n+        fail_unless!(from_str(~\"\\\"\\\\r\\\"\") == Ok(String(~\"\\r\")));\n+        fail_unless!(from_str(~\"\\\"\\\\t\\\"\") == Ok(String(~\"\\t\")));\n+        fail_unless!(from_str(~\" \\\"foo\\\" \") == Ok(String(~\"foo\")));\n     }\n \n     #[test]\n     fn test_unicode_hex_escapes_in_str() {\n-        assert from_str(~\"\\\"\\\\u12ab\\\"\") == Ok(String(~\"\\u12ab\"));\n-        assert from_str(~\"\\\"\\\\uAB12\\\"\") == Ok(String(~\"\\uAB12\"));\n+        fail_unless!(from_str(~\"\\\"\\\\u12ab\\\"\") == Ok(String(~\"\\u12ab\")));\n+        fail_unless!(from_str(~\"\\\"\\\\uAB12\\\"\") == Ok(String(~\"\\uAB12\")));\n     }\n \n     #[test]\n     fn test_read_list() {\n-        assert from_str(~\"[\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing value\"});\n-        assert from_str(~\"[1\") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing list\"});\n-        assert from_str(~\"[1,\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"EOF while parsing value\"});\n-        assert from_str(~\"[1,]\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"});\n-        assert from_str(~\"[6 7]\") ==\n-            Err(Error {line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"});\n-\n-        assert from_str(~\"[]\") == Ok(List(~[]));\n-        assert from_str(~\"[ ]\") == Ok(List(~[]));\n-        assert from_str(~\"[true]\") == Ok(List(~[Boolean(true)]));\n-        assert from_str(~\"[ false ]\") == Ok(List(~[Boolean(false)]));\n-        assert from_str(~\"[null]\") == Ok(List(~[Null]));\n-        assert from_str(~\"[3, 1]\") == Ok(List(~[Number(3f), Number(1f)]));\n-        assert from_str(~\"\\n[3, 2]\\n\") == Ok(List(~[Number(3f), Number(2f)]));\n-        assert from_str(~\"[2, [4, 1]]\") ==\n-               Ok(List(~[Number(2f), List(~[Number(4f), Number(1f)])]));\n+        fail_unless!(from_str(~\"[\") ==\n+            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing value\"}));\n+        fail_unless!(from_str(~\"[1\") ==\n+            Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing list\"}));\n+        fail_unless!(from_str(~\"[1,\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"EOF while parsing value\"}));\n+        fail_unless!(from_str(~\"[1,]\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n+        fail_unless!(from_str(~\"[6 7]\") ==\n+            Err(Error {line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"}));\n+\n+        fail_unless!(from_str(~\"[]\") == Ok(List(~[])));\n+        fail_unless!(from_str(~\"[ ]\") == Ok(List(~[])));\n+        fail_unless!(from_str(~\"[true]\") == Ok(List(~[Boolean(true)])));\n+        fail_unless!(from_str(~\"[ false ]\") == Ok(List(~[Boolean(false)])));\n+        fail_unless!(from_str(~\"[null]\") == Ok(List(~[Null])));\n+        fail_unless!(from_str(~\"[3, 1]\") ==\n+                     Ok(List(~[Number(3f), Number(1f)])));\n+        fail_unless!(from_str(~\"\\n[3, 2]\\n\") ==\n+                     Ok(List(~[Number(3f), Number(2f)])));\n+        fail_unless!(from_str(~\"[2, [4, 1]]\") ==\n+               Ok(List(~[Number(2f), List(~[Number(4f), Number(1f)])])));\n     }\n \n     #[test]\n     fn test_read_object() {\n-        assert from_str(~\"{\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing object\"});\n-        assert from_str(~\"{ \") ==\n-            Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing object\"});\n-        assert from_str(~\"{1\") ==\n-            Err(Error {line: 1u, col: 2u, msg: @~\"key must be a string\"});\n-        assert from_str(~\"{ \\\"a\\\"\") ==\n-            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n-        assert from_str(~\"{\\\"a\\\"\") ==\n-            Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing object\"});\n-        assert from_str(~\"{\\\"a\\\" \") ==\n-            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing object\"});\n-\n-        assert from_str(~\"{\\\"a\\\" 1\") ==\n-            Err(Error {line: 1u, col: 6u, msg: @~\"expected `:`\"});\n-        assert from_str(~\"{\\\"a\\\":\") ==\n-            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing value\"});\n-        assert from_str(~\"{\\\"a\\\":1\") ==\n-            Err(Error {line: 1u, col: 7u, msg: @~\"EOF while parsing object\"});\n-        assert from_str(~\"{\\\"a\\\":1 1\") ==\n-            Err(Error {line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"});\n-        assert from_str(~\"{\\\"a\\\":1,\") ==\n-            Err(Error {line: 1u, col: 8u, msg: @~\"EOF while parsing object\"});\n-\n-        assert result::unwrap(from_str(~\"{}\")) == mk_object(~[]);\n-        assert result::unwrap(from_str(~\"{\\\"a\\\": 3}\")) ==\n-                  mk_object(~[(~\"a\", Number(3.0f))]);\n-\n-        assert result::unwrap(from_str(~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")) ==\n+        fail_unless!(from_str(~\"{\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 2u,\n+                msg: @~\"EOF while parsing object\"}));\n+        fail_unless!(from_str(~\"{ \") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 3u,\n+                msg: @~\"EOF while parsing object\"}));\n+        fail_unless!(from_str(~\"{1\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 2u,\n+                msg: @~\"key must be a string\"}));\n+        fail_unless!(from_str(~\"{ \\\"a\\\"\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 6u,\n+                msg: @~\"EOF while parsing object\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\"\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 5u,\n+                msg: @~\"EOF while parsing object\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\" \") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 6u,\n+                msg: @~\"EOF while parsing object\"}));\n+\n+        fail_unless!(from_str(~\"{\\\"a\\\" 1\") ==\n+            Err(Error {line: 1u, col: 6u, msg: @~\"expected `:`\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\":\") ==\n+            Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing value\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\":1\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 7u,\n+                msg: @~\"EOF while parsing object\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\":1 1\") ==\n+            Err(Error {line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"}));\n+        fail_unless!(from_str(~\"{\\\"a\\\":1,\") ==\n+            Err(Error {\n+                line: 1u,\n+                col: 8u,\n+                msg: @~\"EOF while parsing object\"}));\n+\n+        fail_unless!(result::unwrap(from_str(~\"{}\")) == mk_object(~[]));\n+        fail_unless!(result::unwrap(from_str(~\"{\\\"a\\\": 3}\")) ==\n+                  mk_object(~[(~\"a\", Number(3.0f))]));\n+\n+        fail_unless!(result::unwrap(from_str(\n+                ~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")) ==\n                   mk_object(~[\n                       (~\"a\", Null),\n-                      (~\"b\", Boolean(true))]);\n-        assert result::unwrap(\n+                      (~\"b\", Boolean(true))]));\n+        fail_unless!(result::unwrap(\n                       from_str(~\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")) ==\n                   mk_object(~[\n                       (~\"a\", Null),\n-                      (~\"b\", Boolean(true))]);\n-        assert result::unwrap(from_str(~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")) ==\n+                      (~\"b\", Boolean(true))]));\n+        fail_unless!(result::unwrap(from_str(\n+                ~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")) ==\n                   mk_object(~[\n                       (~\"a\", Number(1.0)),\n                       (~\"b\", List(~[Boolean(true)]))\n-                  ]);\n-        assert result::unwrap(from_str(\n+                  ]));\n+        fail_unless!(result::unwrap(from_str(\n                       ~\"{\" +\n                           ~\"\\\"a\\\": 1.0, \" +\n                           ~\"\\\"b\\\": [\" +\n@@ -1523,12 +1553,15 @@ mod tests {\n                               (~\"c\", mk_object(~[(~\"d\", Null)]))\n                           ])\n                       ]))\n-                  ]);\n+                  ]));\n     }\n \n     #[test]\n     fn test_multiline_errors() {\n-        assert from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n-            Err(Error {line: 3u, col: 8u, msg: @~\"EOF while parsing object\"});\n+        fail_unless!(from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n+            Err(Error {\n+                line: 3u,\n+                col: 8u,\n+                msg: @~\"EOF while parsing object\"}));\n     }\n }"}, {"sha": "5ab1722ae8399731177641613bcf659ae26e8caf", "filename": "src/libstd/list.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -165,37 +165,37 @@ mod tests {\n         let full1 = from_vec(~[1]);\n         let full2 = from_vec(~['r', 'u']);\n \n-        assert is_empty(empty);\n-        assert !is_empty(full1);\n-        assert !is_empty(full2);\n+        fail_unless!(is_empty(empty));\n+        fail_unless!(!is_empty(full1));\n+        fail_unless!(!is_empty(full2));\n     }\n \n     #[test]\n     pub fn test_from_vec() {\n         let l = from_vec(~[0, 1, 2]);\n \n-        assert (head(l) == 0);\n+        fail_unless!((head(l) == 0));\n \n         let tail_l = tail(l);\n-        assert (head(tail_l) == 1);\n+        fail_unless!((head(tail_l) == 1));\n \n         let tail_tail_l = tail(tail_l);\n-        assert (head(tail_tail_l) == 2);\n+        fail_unless!((head(tail_tail_l) == 2));\n     }\n \n     #[test]\n     pub fn test_from_vec_empty() {\n         let empty : @list::List<int> = from_vec(~[]);\n-        assert (empty == @list::Nil::<int>);\n+        fail_unless!((empty == @list::Nil::<int>));\n     }\n \n     #[test]\n     pub fn test_foldl() {\n         fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n         let l = from_vec(~[0, 1, 2, 3, 4]);\n         let empty = @list::Nil::<int>;\n-        assert (list::foldl(0u, l, add) == 10u);\n-        assert (list::foldl(0u, empty, add) == 0u);\n+        fail_unless!((list::foldl(0u, l, add) == 10u));\n+        fail_unless!((list::foldl(0u, empty, add) == 0u));\n     }\n \n     #[test]\n@@ -204,47 +204,47 @@ mod tests {\n             *a - *b\n         }\n         let l = from_vec(~[1, 2, 3, 4]);\n-        assert (list::foldl(0, l, sub) == -10);\n+        fail_unless!((list::foldl(0, l, sub) == -10));\n     }\n \n     #[test]\n     pub fn test_find_success() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n-        assert (list::find(l, match_) == option::Some(2));\n+        fail_unless!((list::find(l, match_) == option::Some(2)));\n     }\n \n     #[test]\n     pub fn test_find_fail() {\n         fn match_(_i: &int) -> bool { return false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        assert (list::find(l, match_) == option::None::<int>);\n-        assert (list::find(empty, match_) == option::None::<int>);\n+        fail_unless!((list::find(l, match_) == option::None::<int>));\n+        fail_unless!((list::find(empty, match_) == option::None::<int>));\n     }\n \n     #[test]\n     pub fn test_has() {\n         let l = from_vec(~[5, 8, 6]);\n         let empty = @list::Nil::<int>;\n-        assert (list::has(l, 5));\n-        assert (!list::has(l, 7));\n-        assert (list::has(l, 8));\n-        assert (!list::has(empty, 5));\n+        fail_unless!((list::has(l, 5)));\n+        fail_unless!((!list::has(l, 7)));\n+        fail_unless!((list::has(l, 8)));\n+        fail_unless!((!list::has(empty, 5)));\n     }\n \n     #[test]\n     pub fn test_len() {\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n-        assert (list::len(l) == 3u);\n-        assert (list::len(empty) == 0u);\n+        fail_unless!((list::len(l) == 3u));\n+        fail_unless!((list::len(empty) == 0u));\n     }\n \n     #[test]\n     pub fn test_append() {\n-        assert from_vec(~[1,2,3,4])\n-            == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4]));\n+        fail_unless!(from_vec(~[1,2,3,4])\n+            == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4])));\n     }\n }\n "}, {"sha": "3dc669da57121ed1ef86b9e106e1f0805f7926c2", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -125,15 +125,16 @@ pub pure fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n \n #[test]\n fn test_md4() {\n-    assert md4_text(~\"\") == ~\"31d6cfe0d16ae931b73c59d7e0c089c0\";\n-    assert md4_text(~\"a\") == ~\"bde52cb31de33e46245e05fbdbd6fb24\";\n-    assert md4_text(~\"abc\") == ~\"a448017aaf21d8525fc10ae87aa6729d\";\n-    assert md4_text(~\"message digest\") == ~\"d9130a8164549fe818874806e1c7014b\";\n-    assert md4_text(~\"abcdefghijklmnopqrstuvwxyz\") ==\n-        ~\"d79e1c308aa5bbcdeea8ed63df412da9\";\n-    assert md4_text(~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n-                     0123456789\") == ~\"043f8582f241db351ce627e153e7f0e4\";\n-    assert md4_text(~\"1234567890123456789012345678901234567890123456789\\\n+    fail_unless!(md4_text(~\"\") == ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n+    fail_unless!(md4_text(~\"a\") == ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n+    fail_unless!(md4_text(~\"abc\") == ~\"a448017aaf21d8525fc10ae87aa6729d\");\n+    fail_unless!(md4_text(~\"message digest\") == ~\"d9130a8164549fe818874806e1c7014b\");\n+    fail_unless!(md4_text(~\"abcdefghijklmnopqrstuvwxyz\") ==\n+        ~\"d79e1c308aa5bbcdeea8ed63df412da9\");\n+    fail_unless!(md4_text(\n+        ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n+        0123456789\") == ~\"043f8582f241db351ce627e153e7f0e4\");\n+    fail_unless!(md4_text(~\"1234567890123456789012345678901234567890123456789\\\n                      0123456789012345678901234567890\") ==\n-        ~\"e33b4ddc9c38f2199c3e7b164fcc0536\";\n+        ~\"e33b4ddc9c38f2199c3e7b164fcc0536\");\n }"}, {"sha": "8021162188f7931c77051185e46ba6391c50c9f7", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -377,7 +377,7 @@ mod test {\n     #[test]\n     fn test_ip_ipv4_parse_and_format_ip() {\n         let localhost_str = ~\"127.0.0.1\";\n-        assert (format_addr(&v4::parse_addr(localhost_str))\n+        fail_unless!(format_addr(&v4::parse_addr(localhost_str))\n                 == localhost_str)\n     }\n     #[test]\n@@ -386,14 +386,14 @@ mod test {\n         let format_result = format_addr(&v6::parse_addr(localhost_str));\n         log(debug, fmt!(\"results: expected: '%s' actual: '%s'\",\n             localhost_str, format_result));\n-        assert format_result == localhost_str;\n+        fail_unless!(format_result == localhost_str);\n     }\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n         match v4::try_parse_addr(~\"b4df00d\") {\n           result::Err(ref err_info) => {\n             log(debug, fmt!(\"got error as expected %?\", err_info));\n-            assert true;\n+            fail_unless!(true);\n           }\n           result::Ok(ref addr) => {\n             fail!(fmt!(\"Expected failure, but got addr %?\", addr));\n@@ -406,7 +406,7 @@ mod test {\n         match v6::try_parse_addr(~\"::,~2234k;\") {\n           result::Err(ref err_info) => {\n             log(debug, fmt!(\"got error as expected %?\", err_info));\n-            assert true;\n+            fail_unless!(true);\n           }\n           result::Ok(ref addr) => {\n             fail!(fmt!(\"Expected failure, but got addr %?\", addr));\n@@ -437,14 +437,14 @@ mod test {\n         }\n         // at least one result.. this is going to vary from system\n         // to system, based on stuff like the contents of /etc/hosts\n-        assert !results.is_empty();\n+        fail_unless!(!results.is_empty());\n     }\n     #[test]\n     #[ignore(reason = \"valgrind says it's leaky\")]\n     fn test_ip_get_addr_bad_input() {\n         let localhost_name = ~\"sjkl234m,./sdf\";\n         let iotask = &uv::global_loop::get();\n         let ga_result = get_addr(localhost_name, iotask);\n-        assert result::is_err(&ga_result);\n+        fail_unless!(result::is_err(&ga_result));\n     }\n }"}, {"sha": "5328975f82abaf6cdfef54bb1498b185e40fd2e3", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -875,7 +875,7 @@ impl io::Reader for TcpSocketBuf {\n         let mut count: uint = 0;\n \n         loop {\n-          assert count < len;\n+          fail_unless!(count < len);\n \n           // If possible, copy up to `len` bytes from the internal\n           // `data.buf` into `buf`\n@@ -895,7 +895,7 @@ impl io::Reader for TcpSocketBuf {\n                 }\n           }\n \n-          assert count <= len;\n+          fail_unless!(count <= len);\n           if count == len {\n               break;\n           }\n@@ -1587,15 +1587,15 @@ pub mod test {\n             server_port,\n             expected_req,\n             hl_loop);\n-        assert actual_resp_result.is_ok();\n+        fail_unless!(actual_resp_result.is_ok());\n         let actual_resp = actual_resp_result.get();\n         let actual_req = server_result_po.recv();\n         debug!(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp);\n-        assert str::contains(actual_req, expected_req);\n-        assert str::contains(actual_resp, expected_resp);\n+        fail_unless!(str::contains(actual_req, expected_req));\n+        fail_unless!(str::contains(actual_resp, expected_resp));\n     }\n     pub fn impl_gl_tcp_ipv4_get_peer_addr() {\n         let hl_loop = &uv::global_loop::get();\n@@ -1628,9 +1628,9 @@ pub mod test {\n \n         debug!(\"testing peer address\");\n         // This is what we are actually testing!\n-        assert net::ip::format_addr(&sock.get_peer_addr()) ==\n-            ~\"127.0.0.1\";\n-        assert net::ip::get_port(&sock.get_peer_addr()) == 8887;\n+        fail_unless!(net::ip::format_addr(&sock.get_peer_addr()) ==\n+            ~\"127.0.0.1\");\n+        fail_unless!(net::ip::get_port(&sock.get_peer_addr()) == 8887);\n \n         // Fulfill the protocol the test server expects\n         let resp_bytes = str::to_bytes(~\"ping\");\n@@ -1691,7 +1691,7 @@ pub mod test {\n             hl_loop);\n         match listen_err {\n           AddressInUse => {\n-            assert true;\n+            fail_unless!(true);\n           }\n           _ => {\n             fail!(~\"expected address_in_use listen error,\"+\n@@ -1710,7 +1710,7 @@ pub mod test {\n                             hl_loop);\n         match listen_err {\n           AccessDenied => {\n-            assert true;\n+            fail_unless!(true);\n           }\n           _ => {\n             fail!(~\"expected address_in_use listen error,\"+\n@@ -1747,7 +1747,7 @@ pub mod test {\n         let server_addr = ip::v4::parse_addr(server_ip);\n         let conn_result = connect(server_addr, server_port, iotask);\n         if result::is_err(&conn_result) {\n-            assert false;\n+            fail_unless!(false);\n         }\n         let sock_buf = @socket_buf(result::unwrap(conn_result));\n         buf_write(sock_buf, expected_req);\n@@ -1762,8 +1762,8 @@ pub mod test {\n                        expected_req, actual_req));\n         log(debug, fmt!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp));\n-        assert str::contains(actual_req, expected_req);\n-        assert str::contains(actual_resp, expected_resp);\n+        fail_unless!(str::contains(actual_req, expected_req));\n+        fail_unless!(str::contains(actual_resp, expected_resp));\n     }\n \n     pub fn impl_tcp_socket_impl_reader_handles_eof() {\n@@ -1794,15 +1794,15 @@ pub mod test {\n         let server_addr = ip::v4::parse_addr(server_ip);\n         let conn_result = connect(server_addr, server_port, hl_loop);\n         if result::is_err(&conn_result) {\n-            assert false;\n+            fail_unless!(false);\n         }\n         let sock_buf = @socket_buf(result::unwrap(conn_result));\n         buf_write(sock_buf, expected_req);\n \n         let buf_reader = sock_buf as Reader;\n         let actual_response = str::from_bytes(buf_reader.read_whole_stream());\n         debug!(\"Actual response: %s\", actual_response);\n-        assert expected_resp == actual_response;\n+        fail_unless!(expected_resp == actual_response);\n     }\n \n     fn buf_write<W:io::Writer>(w: &W, val: &str) {"}, {"sha": "0739f624882647dd808c5d02d0da0522d9b7a791", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 167, "deletions": 167, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -733,83 +733,83 @@ impl to_bytes::IterBytes for Url {\n #[test]\n fn test_split_char_first() {\n     let (u,v) = split_char_first(~\"hello, sweet world\", ',');\n-    assert u == ~\"hello\";\n-    assert v == ~\" sweet world\";\n+    fail_unless!(u == ~\"hello\");\n+    fail_unless!(v == ~\" sweet world\");\n \n     let (u,v) = split_char_first(~\"hello sweet world\", ',');\n-    assert u == ~\"hello sweet world\";\n-    assert v == ~\"\";\n+    fail_unless!(u == ~\"hello sweet world\");\n+    fail_unless!(v == ~\"\");\n }\n \n #[test]\n fn test_get_authority() {\n     let (u, h, p, r) = get_authority(\n         \"//user:pass@rust-lang.org/something\").unwrap();\n-    assert u == Some(UserInfo::new(~\"user\", Some(~\"pass\")));\n-    assert h == ~\"rust-lang.org\";\n-    assert p.is_none();\n-    assert r == ~\"/something\";\n+    fail_unless!(u == Some(UserInfo::new(~\"user\", Some(~\"pass\"))));\n+    fail_unless!(h == ~\"rust-lang.org\");\n+    fail_unless!(p.is_none());\n+    fail_unless!(r == ~\"/something\");\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org:8000?something\").unwrap();\n-    assert u.is_none();\n-    assert h == ~\"rust-lang.org\";\n-    assert p == Some(~\"8000\");\n-    assert r == ~\"?something\";\n+    fail_unless!(u.is_none());\n+    fail_unless!(h == ~\"rust-lang.org\");\n+    fail_unless!(p == Some(~\"8000\"));\n+    fail_unless!(r == ~\"?something\");\n \n     let (u, h, p, r) = get_authority(\n         \"//rust-lang.org#blah\").unwrap();\n-    assert u.is_none();\n-    assert h == ~\"rust-lang.org\";\n-    assert p.is_none();\n-    assert r == ~\"#blah\";\n+    fail_unless!(u.is_none());\n+    fail_unless!(h == ~\"rust-lang.org\");\n+    fail_unless!(p.is_none());\n+    fail_unless!(r == ~\"#blah\");\n \n     // ipv6 tests\n     let (_, h, _, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n+    fail_unless!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n \n     let (_, h, p, _) = get_authority(\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n-    assert p == Some(~\"8000\");\n+    fail_unless!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    fail_unless!(p == Some(~\"8000\"));\n \n     let (u, h, p, _) = get_authority(\n         \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n     ).unwrap();\n-    assert u == Some(UserInfo::new(~\"us\", Some(~\"p\")));\n-    assert h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\";\n-    assert p == Some(~\"8000\");\n+    fail_unless!(u == Some(UserInfo::new(~\"us\", Some(~\"p\"))));\n+    fail_unless!(h == ~\"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n+    fail_unless!(p == Some(~\"8000\"));\n \n     // invalid authorities;\n-    assert get_authority(\"//user:pass@rust-lang:something\").is_err();\n-    assert get_authority(\"//user@rust-lang:something:/path\").is_err();\n-    assert get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err();\n-    assert get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err();\n+    fail_unless!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n+    fail_unless!(get_authority(\"//user@rust-lang:something:/path\").is_err());\n+    fail_unless!(get_authority(\n+        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err());\n+    fail_unless!(get_authority(\n+        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err());\n \n     // these parse as empty, because they don't start with '//'\n     let (_, h, _, _) = get_authority(~\"user:pass@rust-lang\").unwrap();\n-    assert h == ~\"\";\n+    fail_unless!(h == ~\"\");\n     let (_, h, _, _) = get_authority(~\"rust-lang.org\").unwrap();\n-    assert h == ~\"\";\n+    fail_unless!(h == ~\"\");\n }\n \n #[test]\n fn test_get_path() {\n     let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n-    assert p == ~\"/something+ orother\";\n-    assert r == ~\"\";\n+    fail_unless!(p == ~\"/something+ orother\");\n+    fail_unless!(r == ~\"\");\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n-    assert p == ~\"test@email.com\";\n-    assert r == ~\"#fragment\";\n+    fail_unless!(p == ~\"test@email.com\");\n+    fail_unless!(r == ~\"#fragment\");\n     let (p, r) = get_path(~\"/gen/:addr=?q=v\", false).unwrap();\n-    assert p == ~\"/gen/:addr=\";\n-    assert r == ~\"?q=v\";\n+    fail_unless!(p == ~\"/gen/:addr=\");\n+    fail_unless!(r == ~\"?q=v\");\n \n     //failure cases\n-    assert get_path(~\"something?q\", true).is_err();\n+    fail_unless!(get_path(~\"something?q\", true).is_err());\n }\n \n #[cfg(test)]\n@@ -826,260 +826,260 @@ mod tests {\n \n         let up = from_str(url);\n         let u = up.unwrap();\n-        assert u.scheme == ~\"http\";\n+        fail_unless!(u.scheme == ~\"http\");\n         let userinfo = u.user.get_ref();\n-        assert userinfo.user == ~\"user\";\n-        assert userinfo.pass.get_ref() == &~\"pass\";\n-        assert u.host == ~\"rust-lang.org\";\n-        assert u.path == ~\"/doc\";\n-        assert u.query == ~[(~\"s\", ~\"v\")];\n-        assert u.fragment.get_ref() == &~\"something\";\n+        fail_unless!(userinfo.user == ~\"user\");\n+        fail_unless!(userinfo.pass.get_ref() == &~\"pass\");\n+        fail_unless!(u.host == ~\"rust-lang.org\");\n+        fail_unless!(u.path == ~\"/doc\");\n+        fail_unless!(u.query == ~[(~\"s\", ~\"v\")]);\n+        fail_unless!(u.fragment.get_ref() == &~\"something\");\n     }\n \n     #[test]\n     pub fn test_url_parse_host_slash() {\n         let urlstr = ~\"http://0.42.42.42/\";\n         let url = from_str(urlstr).unwrap();\n-        assert url.host == ~\"0.42.42.42\";\n-        assert url.path == ~\"/\";\n+        fail_unless!(url.host == ~\"0.42.42.42\");\n+        fail_unless!(url.path == ~\"/\");\n     }\n \n     #[test]\n     pub fn test_url_with_underscores() {\n         let urlstr = ~\"http://dotcom.com/file_name.html\";\n         let url = from_str(urlstr).unwrap();\n-        assert url.path == ~\"/file_name.html\";\n+        fail_unless!(url.path == ~\"/file_name.html\");\n     }\n \n     #[test]\n     pub fn test_url_with_dashes() {\n         let urlstr = ~\"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).unwrap();\n-        assert url.path == ~\"/file-name.html\";\n+        fail_unless!(url.path == ~\"/file-name.html\");\n     }\n \n     #[test]\n     pub fn test_no_scheme() {\n-        assert get_scheme(\"noschemehere.html\").is_err();\n+        fail_unless!(get_scheme(\"noschemehere.html\").is_err());\n     }\n \n     #[test]\n     pub fn test_invalid_scheme_errors() {\n-        assert from_str(\"99://something\").is_err();\n-        assert from_str(\"://something\").is_err();\n+        fail_unless!(from_str(\"99://something\").is_err());\n+        fail_unless!(from_str(\"://something\").is_err());\n     }\n \n     #[test]\n     pub fn test_full_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_userless_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc?s=v#something\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_queryless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_empty_query_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n         let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n-        assert from_str(url).unwrap().to_str() == should_be;\n+        fail_unless!(from_str(url).unwrap().to_str() == should_be);\n     }\n \n     #[test]\n     pub fn test_fragmentless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_minimal_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_scheme_host_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_pathless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_scheme_host_fragment_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org#something\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_url_component_encoding() {\n         let url = ~\"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n         let u = from_str(url).unwrap();\n-        assert u.path == ~\"/doc uments\";\n-        assert u.query == ~[(~\"ba%d \", ~\"#&+\")];\n+        fail_unless!(u.path == ~\"/doc uments\");\n+        fail_unless!(u.query == ~[(~\"ba%d \", ~\"#&+\")]);\n     }\n \n     #[test]\n     pub fn test_url_without_authority() {\n         let url = ~\"mailto:test@email.com\";\n-        assert from_str(url).unwrap().to_str() == url;\n+        fail_unless!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n     pub fn test_encode() {\n-        assert encode(\"\") == ~\"\";\n-        assert encode(\"http://example.com\") == ~\"http://example.com\";\n-        assert encode(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\";\n-        assert encode(\" \") == ~\"%20\";\n-        assert encode(\"!\") == ~\"!\";\n-        assert encode(\"\\\"\") == ~\"\\\"\";\n-        assert encode(\"#\") == ~\"#\";\n-        assert encode(\"$\") == ~\"$\";\n-        assert encode(\"%\") == ~\"%25\";\n-        assert encode(\"&\") == ~\"&\";\n-        assert encode(\"'\") == ~\"%27\";\n-        assert encode(\"(\") == ~\"(\";\n-        assert encode(\")\") == ~\")\";\n-        assert encode(\"*\") == ~\"*\";\n-        assert encode(\"+\") == ~\"+\";\n-        assert encode(\",\") == ~\",\";\n-        assert encode(\"/\") == ~\"/\";\n-        assert encode(\":\") == ~\":\";\n-        assert encode(\";\") == ~\";\";\n-        assert encode(\"=\") == ~\"=\";\n-        assert encode(\"?\") == ~\"?\";\n-        assert encode(\"@\") == ~\"@\";\n-        assert encode(\"[\") == ~\"[\";\n-        assert encode(\"]\") == ~\"]\";\n+        fail_unless!(encode(\"\") == ~\"\");\n+        fail_unless!(encode(\"http://example.com\") == ~\"http://example.com\");\n+        fail_unless!(encode(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\");\n+        fail_unless!(encode(\" \") == ~\"%20\");\n+        fail_unless!(encode(\"!\") == ~\"!\");\n+        fail_unless!(encode(\"\\\"\") == ~\"\\\"\");\n+        fail_unless!(encode(\"#\") == ~\"#\");\n+        fail_unless!(encode(\"$\") == ~\"$\");\n+        fail_unless!(encode(\"%\") == ~\"%25\");\n+        fail_unless!(encode(\"&\") == ~\"&\");\n+        fail_unless!(encode(\"'\") == ~\"%27\");\n+        fail_unless!(encode(\"(\") == ~\"(\");\n+        fail_unless!(encode(\")\") == ~\")\");\n+        fail_unless!(encode(\"*\") == ~\"*\");\n+        fail_unless!(encode(\"+\") == ~\"+\");\n+        fail_unless!(encode(\",\") == ~\",\");\n+        fail_unless!(encode(\"/\") == ~\"/\");\n+        fail_unless!(encode(\":\") == ~\":\");\n+        fail_unless!(encode(\";\") == ~\";\");\n+        fail_unless!(encode(\"=\") == ~\"=\");\n+        fail_unless!(encode(\"?\") == ~\"?\");\n+        fail_unless!(encode(\"@\") == ~\"@\");\n+        fail_unless!(encode(\"[\") == ~\"[\");\n+        fail_unless!(encode(\"]\") == ~\"]\");\n     }\n \n     #[test]\n     pub fn test_encode_component() {\n-        assert encode_component(\"\") == ~\"\";\n-        assert encode_component(\"http://example.com\") ==\n-            ~\"http%3A%2F%2Fexample.com\";\n-        assert encode_component(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\";\n-        assert encode_component(\" \") == ~\"%20\";\n-        assert encode_component(\"!\") == ~\"%21\";\n-        assert encode_component(\"#\") == ~\"%23\";\n-        assert encode_component(\"$\") == ~\"%24\";\n-        assert encode_component(\"%\") == ~\"%25\";\n-        assert encode_component(\"&\") == ~\"%26\";\n-        assert encode_component(\"'\") == ~\"%27\";\n-        assert encode_component(\"(\") == ~\"%28\";\n-        assert encode_component(\")\") == ~\"%29\";\n-        assert encode_component(\"*\") == ~\"%2A\";\n-        assert encode_component(\"+\") == ~\"%2B\";\n-        assert encode_component(\",\") == ~\"%2C\";\n-        assert encode_component(\"/\") == ~\"%2F\";\n-        assert encode_component(\":\") == ~\"%3A\";\n-        assert encode_component(\";\") == ~\"%3B\";\n-        assert encode_component(\"=\") == ~\"%3D\";\n-        assert encode_component(\"?\") == ~\"%3F\";\n-        assert encode_component(\"@\") == ~\"%40\";\n-        assert encode_component(\"[\") == ~\"%5B\";\n-        assert encode_component(\"]\") == ~\"%5D\";\n+        fail_unless!(encode_component(\"\") == ~\"\");\n+        fail_unless!(encode_component(\"http://example.com\") ==\n+            ~\"http%3A%2F%2Fexample.com\");\n+        fail_unless!(encode_component(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\");\n+        fail_unless!(encode_component(\" \") == ~\"%20\");\n+        fail_unless!(encode_component(\"!\") == ~\"%21\");\n+        fail_unless!(encode_component(\"#\") == ~\"%23\");\n+        fail_unless!(encode_component(\"$\") == ~\"%24\");\n+        fail_unless!(encode_component(\"%\") == ~\"%25\");\n+        fail_unless!(encode_component(\"&\") == ~\"%26\");\n+        fail_unless!(encode_component(\"'\") == ~\"%27\");\n+        fail_unless!(encode_component(\"(\") == ~\"%28\");\n+        fail_unless!(encode_component(\")\") == ~\"%29\");\n+        fail_unless!(encode_component(\"*\") == ~\"%2A\");\n+        fail_unless!(encode_component(\"+\") == ~\"%2B\");\n+        fail_unless!(encode_component(\",\") == ~\"%2C\");\n+        fail_unless!(encode_component(\"/\") == ~\"%2F\");\n+        fail_unless!(encode_component(\":\") == ~\"%3A\");\n+        fail_unless!(encode_component(\";\") == ~\"%3B\");\n+        fail_unless!(encode_component(\"=\") == ~\"%3D\");\n+        fail_unless!(encode_component(\"?\") == ~\"%3F\");\n+        fail_unless!(encode_component(\"@\") == ~\"%40\");\n+        fail_unless!(encode_component(\"[\") == ~\"%5B\");\n+        fail_unless!(encode_component(\"]\") == ~\"%5D\");\n     }\n \n     #[test]\n     pub fn test_decode() {\n-        assert decode(\"\") == ~\"\";\n-        assert decode(\"abc/def 123\") == ~\"abc/def 123\";\n-        assert decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\";\n-        assert decode(\"%20\") == ~\" \";\n-        assert decode(\"%21\") == ~\"%21\";\n-        assert decode(\"%22\") == ~\"%22\";\n-        assert decode(\"%23\") == ~\"%23\";\n-        assert decode(\"%24\") == ~\"%24\";\n-        assert decode(\"%25\") == ~\"%\";\n-        assert decode(\"%26\") == ~\"%26\";\n-        assert decode(\"%27\") == ~\"'\";\n-        assert decode(\"%28\") == ~\"%28\";\n-        assert decode(\"%29\") == ~\"%29\";\n-        assert decode(\"%2A\") == ~\"%2A\";\n-        assert decode(\"%2B\") == ~\"%2B\";\n-        assert decode(\"%2C\") == ~\"%2C\";\n-        assert decode(\"%2F\") == ~\"%2F\";\n-        assert decode(\"%3A\") == ~\"%3A\";\n-        assert decode(\"%3B\") == ~\"%3B\";\n-        assert decode(\"%3D\") == ~\"%3D\";\n-        assert decode(\"%3F\") == ~\"%3F\";\n-        assert decode(\"%40\") == ~\"%40\";\n-        assert decode(\"%5B\") == ~\"%5B\";\n-        assert decode(\"%5D\") == ~\"%5D\";\n+        fail_unless!(decode(\"\") == ~\"\");\n+        fail_unless!(decode(\"abc/def 123\") == ~\"abc/def 123\");\n+        fail_unless!(decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\");\n+        fail_unless!(decode(\"%20\") == ~\" \");\n+        fail_unless!(decode(\"%21\") == ~\"%21\");\n+        fail_unless!(decode(\"%22\") == ~\"%22\");\n+        fail_unless!(decode(\"%23\") == ~\"%23\");\n+        fail_unless!(decode(\"%24\") == ~\"%24\");\n+        fail_unless!(decode(\"%25\") == ~\"%\");\n+        fail_unless!(decode(\"%26\") == ~\"%26\");\n+        fail_unless!(decode(\"%27\") == ~\"'\");\n+        fail_unless!(decode(\"%28\") == ~\"%28\");\n+        fail_unless!(decode(\"%29\") == ~\"%29\");\n+        fail_unless!(decode(\"%2A\") == ~\"%2A\");\n+        fail_unless!(decode(\"%2B\") == ~\"%2B\");\n+        fail_unless!(decode(\"%2C\") == ~\"%2C\");\n+        fail_unless!(decode(\"%2F\") == ~\"%2F\");\n+        fail_unless!(decode(\"%3A\") == ~\"%3A\");\n+        fail_unless!(decode(\"%3B\") == ~\"%3B\");\n+        fail_unless!(decode(\"%3D\") == ~\"%3D\");\n+        fail_unless!(decode(\"%3F\") == ~\"%3F\");\n+        fail_unless!(decode(\"%40\") == ~\"%40\");\n+        fail_unless!(decode(\"%5B\") == ~\"%5B\");\n+        fail_unless!(decode(\"%5D\") == ~\"%5D\");\n     }\n \n     #[test]\n     pub fn test_decode_component() {\n-        assert decode_component(\"\") == ~\"\";\n-        assert decode_component(\"abc/def 123\") == ~\"abc/def 123\";\n-        assert decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\";\n-        assert decode_component(\"%20\") == ~\" \";\n-        assert decode_component(\"%21\") == ~\"!\";\n-        assert decode_component(\"%22\") == ~\"\\\"\";\n-        assert decode_component(\"%23\") == ~\"#\";\n-        assert decode_component(\"%24\") == ~\"$\";\n-        assert decode_component(\"%25\") == ~\"%\";\n-        assert decode_component(\"%26\") == ~\"&\";\n-        assert decode_component(\"%27\") == ~\"'\";\n-        assert decode_component(\"%28\") == ~\"(\";\n-        assert decode_component(\"%29\") == ~\")\";\n-        assert decode_component(\"%2A\") == ~\"*\";\n-        assert decode_component(\"%2B\") == ~\"+\";\n-        assert decode_component(\"%2C\") == ~\",\";\n-        assert decode_component(\"%2F\") == ~\"/\";\n-        assert decode_component(\"%3A\") == ~\":\";\n-        assert decode_component(\"%3B\") == ~\";\";\n-        assert decode_component(\"%3D\") == ~\"=\";\n-        assert decode_component(\"%3F\") == ~\"?\";\n-        assert decode_component(\"%40\") == ~\"@\";\n-        assert decode_component(\"%5B\") == ~\"[\";\n-        assert decode_component(\"%5D\") == ~\"]\";\n+        fail_unless!(decode_component(\"\") == ~\"\");\n+        fail_unless!(decode_component(\"abc/def 123\") == ~\"abc/def 123\");\n+        fail_unless!(decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\");\n+        fail_unless!(decode_component(\"%20\") == ~\" \");\n+        fail_unless!(decode_component(\"%21\") == ~\"!\");\n+        fail_unless!(decode_component(\"%22\") == ~\"\\\"\");\n+        fail_unless!(decode_component(\"%23\") == ~\"#\");\n+        fail_unless!(decode_component(\"%24\") == ~\"$\");\n+        fail_unless!(decode_component(\"%25\") == ~\"%\");\n+        fail_unless!(decode_component(\"%26\") == ~\"&\");\n+        fail_unless!(decode_component(\"%27\") == ~\"'\");\n+        fail_unless!(decode_component(\"%28\") == ~\"(\");\n+        fail_unless!(decode_component(\"%29\") == ~\")\");\n+        fail_unless!(decode_component(\"%2A\") == ~\"*\");\n+        fail_unless!(decode_component(\"%2B\") == ~\"+\");\n+        fail_unless!(decode_component(\"%2C\") == ~\",\");\n+        fail_unless!(decode_component(\"%2F\") == ~\"/\");\n+        fail_unless!(decode_component(\"%3A\") == ~\":\");\n+        fail_unless!(decode_component(\"%3B\") == ~\";\");\n+        fail_unless!(decode_component(\"%3D\") == ~\"=\");\n+        fail_unless!(decode_component(\"%3F\") == ~\"?\");\n+        fail_unless!(decode_component(\"%40\") == ~\"@\");\n+        fail_unless!(decode_component(\"%5B\") == ~\"[\");\n+        fail_unless!(decode_component(\"%5D\") == ~\"]\");\n     }\n \n     #[test]\n     pub fn test_encode_form_urlencoded() {\n         let mut m = LinearMap::new();\n-        assert encode_form_urlencoded(&m) == ~\"\";\n+        fail_unless!(encode_form_urlencoded(&m) == ~\"\");\n \n         m.insert(~\"\", ~[]);\n         m.insert(~\"foo\", ~[]);\n-        assert encode_form_urlencoded(&m) == ~\"\";\n+        fail_unless!(encode_form_urlencoded(&m) == ~\"\");\n \n         let mut m = LinearMap::new();\n         m.insert(~\"foo\", ~[~\"bar\", ~\"123\"]);\n-        assert encode_form_urlencoded(&m) == ~\"foo=bar&foo=123\";\n+        fail_unless!(encode_form_urlencoded(&m) == ~\"foo=bar&foo=123\");\n \n         let mut m = LinearMap::new();\n         m.insert(~\"foo bar\", ~[~\"abc\", ~\"12 = 34\"]);\n-        assert encode_form_urlencoded(&m) == ~\"foo+bar=abc&foo+bar=12+%3D+34\";\n+        fail_unless!(encode_form_urlencoded(&m) == ~\"foo+bar=abc&foo+bar=12+%3D+34\");\n     }\n \n     #[test]\n     pub fn test_decode_form_urlencoded() {\n         // FIXME #4449: Commented out because this causes an ICE, but only\n         // on FreeBSD\n         /*\n-        assert decode_form_urlencoded(~[]).len() == 0;\n+        fail_unless!(decode_form_urlencoded(~[]).len() == 0);\n \n         let s = str::to_bytes(\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n         let form = decode_form_urlencoded(s);\n-        assert form.len() == 2;\n-        assert form.get_ref(&~\"a\") == &~[~\"1\"];\n-        assert form.get_ref(&~\"foo bar\") == &~[~\"abc\", ~\"12 = 34\"];\n+        fail_unless!(form.len() == 2);\n+        fail_unless!(form.get_ref(&~\"a\") == &~[~\"1\"]);\n+        fail_unless!(form.get_ref(&~\"foo bar\") == &~[~\"abc\", ~\"12 = 34\"]);\n         */\n     }\n }"}, {"sha": "0f6434f1b2ba5f3adaddaf9faa563ccba494a7df", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -427,59 +427,59 @@ mod tests {\n         debug!(\"uint -> uint\");\n         let hm_uu: HashMap<uint, uint> =\n             HashMap::<uint, uint>();\n-        assert (hm_uu.insert(10u, 12u));\n-        assert (hm_uu.insert(11u, 13u));\n-        assert (hm_uu.insert(12u, 14u));\n-        assert (hm_uu.get(&11) == 13u);\n-        assert (hm_uu.get(&12) == 14u);\n-        assert (hm_uu.get(&10) == 12u);\n-        assert (!hm_uu.insert(12u, 14u));\n-        assert (hm_uu.get(&12) == 14u);\n-        assert (!hm_uu.insert(12u, 12u));\n-        assert (hm_uu.get(&12) == 12u);\n+        fail_unless!((hm_uu.insert(10u, 12u)));\n+        fail_unless!((hm_uu.insert(11u, 13u)));\n+        fail_unless!((hm_uu.insert(12u, 14u)));\n+        fail_unless!((hm_uu.get(&11) == 13u));\n+        fail_unless!((hm_uu.get(&12) == 14u));\n+        fail_unless!((hm_uu.get(&10) == 12u));\n+        fail_unless!((!hm_uu.insert(12u, 14u)));\n+        fail_unless!((hm_uu.get(&12) == 14u));\n+        fail_unless!((!hm_uu.insert(12u, 12u)));\n+        fail_unless!((hm_uu.get(&12) == 12u));\n         let ten: ~str = ~\"ten\";\n         let eleven: ~str = ~\"eleven\";\n         let twelve: ~str = ~\"twelve\";\n         debug!(\"str -> uint\");\n         let hm_su: HashMap<~str, uint> =\n             HashMap::<~str, uint>();\n-        assert (hm_su.insert(~\"ten\", 12u));\n-        assert (hm_su.insert(eleven, 13u));\n-        assert (hm_su.insert(~\"twelve\", 14u));\n-        assert (hm_su.get(&eleven) == 13u);\n-        assert (hm_su.get(&~\"eleven\") == 13u);\n-        assert (hm_su.get(&~\"twelve\") == 14u);\n-        assert (hm_su.get(&~\"ten\") == 12u);\n-        assert (!hm_su.insert(~\"twelve\", 14u));\n-        assert (hm_su.get(&~\"twelve\") == 14u);\n-        assert (!hm_su.insert(~\"twelve\", 12u));\n-        assert (hm_su.get(&~\"twelve\") == 12u);\n+        fail_unless!((hm_su.insert(~\"ten\", 12u)));\n+        fail_unless!((hm_su.insert(eleven, 13u)));\n+        fail_unless!((hm_su.insert(~\"twelve\", 14u)));\n+        fail_unless!((hm_su.get(&eleven) == 13u));\n+        fail_unless!((hm_su.get(&~\"eleven\") == 13u));\n+        fail_unless!((hm_su.get(&~\"twelve\") == 14u));\n+        fail_unless!((hm_su.get(&~\"ten\") == 12u));\n+        fail_unless!((!hm_su.insert(~\"twelve\", 14u)));\n+        fail_unless!((hm_su.get(&~\"twelve\") == 14u));\n+        fail_unless!((!hm_su.insert(~\"twelve\", 12u)));\n+        fail_unless!((hm_su.get(&~\"twelve\") == 12u));\n         debug!(\"uint -> str\");\n         let hm_us: HashMap<uint, ~str> =\n             HashMap::<uint, ~str>();\n-        assert (hm_us.insert(10u, ~\"twelve\"));\n-        assert (hm_us.insert(11u, ~\"thirteen\"));\n-        assert (hm_us.insert(12u, ~\"fourteen\"));\n-        assert hm_us.get(&11) == ~\"thirteen\";\n-        assert hm_us.get(&12) == ~\"fourteen\";\n-        assert hm_us.get(&10) == ~\"twelve\";\n-        assert (!hm_us.insert(12u, ~\"fourteen\"));\n-        assert hm_us.get(&12) == ~\"fourteen\";\n-        assert (!hm_us.insert(12u, ~\"twelve\"));\n-        assert hm_us.get(&12) == ~\"twelve\";\n+        fail_unless!((hm_us.insert(10u, ~\"twelve\")));\n+        fail_unless!((hm_us.insert(11u, ~\"thirteen\")));\n+        fail_unless!((hm_us.insert(12u, ~\"fourteen\")));\n+        fail_unless!(hm_us.get(&11) == ~\"thirteen\");\n+        fail_unless!(hm_us.get(&12) == ~\"fourteen\");\n+        fail_unless!(hm_us.get(&10) == ~\"twelve\");\n+        fail_unless!((!hm_us.insert(12u, ~\"fourteen\")));\n+        fail_unless!(hm_us.get(&12) == ~\"fourteen\");\n+        fail_unless!((!hm_us.insert(12u, ~\"twelve\")));\n+        fail_unless!(hm_us.get(&12) == ~\"twelve\");\n         debug!(\"str -> str\");\n         let hm_ss: HashMap<~str, ~str> =\n             HashMap::<~str, ~str>();\n-        assert (hm_ss.insert(ten, ~\"twelve\"));\n-        assert (hm_ss.insert(eleven, ~\"thirteen\"));\n-        assert (hm_ss.insert(twelve, ~\"fourteen\"));\n-        assert hm_ss.get(&~\"eleven\") == ~\"thirteen\";\n-        assert hm_ss.get(&~\"twelve\") == ~\"fourteen\";\n-        assert hm_ss.get(&~\"ten\") == ~\"twelve\";\n-        assert (!hm_ss.insert(~\"twelve\", ~\"fourteen\"));\n-        assert hm_ss.get(&~\"twelve\") == ~\"fourteen\";\n-        assert (!hm_ss.insert(~\"twelve\", ~\"twelve\"));\n-        assert hm_ss.get(&~\"twelve\") == ~\"twelve\";\n+        fail_unless!((hm_ss.insert(ten, ~\"twelve\")));\n+        fail_unless!((hm_ss.insert(eleven, ~\"thirteen\")));\n+        fail_unless!((hm_ss.insert(twelve, ~\"fourteen\")));\n+        fail_unless!(hm_ss.get(&~\"eleven\") == ~\"thirteen\");\n+        fail_unless!(hm_ss.get(&~\"twelve\") == ~\"fourteen\");\n+        fail_unless!(hm_ss.get(&~\"ten\") == ~\"twelve\");\n+        fail_unless!((!hm_ss.insert(~\"twelve\", ~\"fourteen\")));\n+        fail_unless!(hm_ss.get(&~\"twelve\") == ~\"fourteen\");\n+        fail_unless!((!hm_ss.insert(~\"twelve\", ~\"twelve\")));\n+        fail_unless!(hm_ss.get(&~\"twelve\") == ~\"twelve\");\n         debug!(\"*** finished test_simple\");\n     }\n \n@@ -498,33 +498,33 @@ mod tests {\n             HashMap::<uint, uint>();\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n-            assert (hm_uu.insert(i, i * i));\n+            fail_unless!((hm_uu.insert(i, i * i)));\n             debug!(\"inserting %u -> %u\", i, i*i);\n             i += 1u;\n         }\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm_uu.get(&i));\n-            assert (hm_uu.get(&i) == i * i);\n+            fail_unless!((hm_uu.get(&i) == i * i));\n             i += 1u;\n         }\n-        assert (hm_uu.insert(num_to_insert, 17u));\n-        assert (hm_uu.get(&num_to_insert) == 17u);\n+        fail_unless!((hm_uu.insert(num_to_insert, 17u)));\n+        fail_unless!((hm_uu.get(&num_to_insert) == 17u));\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm_uu.get(&i));\n-            assert (hm_uu.get(&i) == i * i);\n+            fail_unless!((hm_uu.get(&i) == i * i));\n             i += 1u;\n         }\n         debug!(\"str -> str\");\n         let hm_ss: HashMap<~str, ~str> =\n             HashMap::<~str, ~str>();\n         i = 0u;\n         while i < num_to_insert {\n-            assert hm_ss.insert(uint::to_str_radix(i, 2u),\n-                                uint::to_str_radix(i * i, 2u));\n+            fail_unless!(hm_ss.insert(uint::to_str_radix(i, 2u),\n+                                uint::to_str_radix(i * i, 2u)));\n             debug!(\"inserting \\\"%s\\\" -> \\\"%s\\\"\",\n                    uint::to_str_radix(i, 2u),\n                    uint::to_str_radix(i*i, 2u));\n@@ -536,22 +536,22 @@ mod tests {\n             debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str_radix(i, 2u),\n                    hm_ss.get(&uint::to_str_radix(i, 2u)));\n-            assert hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n-                             uint::to_str_radix(i * i, 2u);\n+            fail_unless!(hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n+                             uint::to_str_radix(i * i, 2u));\n             i += 1u;\n         }\n-        assert (hm_ss.insert(uint::to_str_radix(num_to_insert, 2u),\n+        fail_unless!(hm_ss.insert(uint::to_str_radix(num_to_insert, 2u),\n                              uint::to_str_radix(17u, 2u)));\n-        assert hm_ss.get(&uint::to_str_radix(num_to_insert, 2u)) ==\n-            uint::to_str_radix(17u, 2u);\n+        fail_unless!(hm_ss.get(&uint::to_str_radix(num_to_insert, 2u)) ==\n+            uint::to_str_radix(17u, 2u));\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str_radix(i, 2u),\n                    hm_ss.get(&uint::to_str_radix(i, 2u)));\n-            assert hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n-                             uint::to_str_radix(i * i, 2u);\n+            fail_unless!(hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n+                             uint::to_str_radix(i * i, 2u));\n             i += 1u;\n         }\n         debug!(\"*** finished test_growth\");\n@@ -565,55 +565,55 @@ mod tests {\n             HashMap::<uint, uint>();\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n-            assert (hm.insert(i, i * i));\n+            fail_unless!((hm.insert(i, i * i)));\n             debug!(\"inserting %u -> %u\", i, i*i);\n             i += 1u;\n         }\n-        assert (hm.len() == num_to_insert);\n+        fail_unless!((hm.len() == num_to_insert));\n         debug!(\"-----\");\n         debug!(\"removing evens\");\n         i = 0u;\n         while i < num_to_insert {\n             let v = hm.remove(&i);\n-            assert v;\n+            fail_unless!(v);\n             i += 2u;\n         }\n-        assert (hm.len() == num_to_insert / 2u);\n+        fail_unless!((hm.len() == num_to_insert / 2u));\n         debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            fail_unless!((hm.get(&i) == i * i));\n             i += 2u;\n         }\n         debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            fail_unless!((hm.get(&i) == i * i));\n             i += 2u;\n         }\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            assert (hm.insert(i, i * i));\n+            fail_unless!((hm.insert(i, i * i)));\n             debug!(\"inserting %u -> %u\", i, i*i);\n             i += 2u;\n         }\n-        assert (hm.len() == num_to_insert);\n+        fail_unless!((hm.len() == num_to_insert));\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            fail_unless!((hm.get(&i) == i * i));\n             i += 1u;\n         }\n         debug!(\"-----\");\n-        assert (hm.len() == num_to_insert);\n+        fail_unless!((hm.len() == num_to_insert));\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(%u) = %u\", i, hm.get(&i));\n-            assert (hm.get(&i) == i * i);\n+            fail_unless!((hm.get(&i) == i * i));\n             i += 1u;\n         }\n         debug!(\"*** finished test_removal\");\n@@ -623,30 +623,30 @@ mod tests {\n     fn test_contains_key() {\n         let key = ~\"k\";\n         let map = HashMap::<~str, ~str>();\n-        assert (!map.contains_key(&key));\n+        fail_unless!((!map.contains_key(&key)));\n         map.insert(key, ~\"val\");\n-        assert (map.contains_key(&key));\n+        fail_unless!((map.contains_key(&key)));\n     }\n \n     #[test]\n     fn test_find() {\n         let key = ~\"k\";\n         let map = HashMap::<~str, ~str>();\n-        assert map.find(&key).is_none();\n+        fail_unless!(map.find(&key).is_none());\n         map.insert(key, ~\"val\");\n-        assert map.find(&key).get() == ~\"val\";\n+        fail_unless!(map.find(&key).get() == ~\"val\");\n     }\n \n     #[test]\n     fn test_clear() {\n         let key = ~\"k\";\n         let mut map = HashMap::<~str, ~str>();\n         map.insert(key, ~\"val\");\n-        assert (map.len() == 1);\n-        assert (map.contains_key(&key));\n+        fail_unless!((map.len() == 1));\n+        fail_unless!((map.contains_key(&key)));\n         map.clear();\n-        assert (map.len() == 0);\n-        assert (!map.contains_key(&key));\n+        fail_unless!((map.len() == 0));\n+        fail_unless!((!map.contains_key(&key)));\n     }\n \n     #[test]\n@@ -656,10 +656,10 @@ mod tests {\n             (~\"b\", 2),\n             (~\"c\", 3)\n         ]);\n-        assert map.len() == 3u;\n-        assert map.get(&~\"a\") == 1;\n-        assert map.get(&~\"b\") == 2;\n-        assert map.get(&~\"c\") == 3;\n+        fail_unless!(map.len() == 3u);\n+        fail_unless!(map.get(&~\"a\") == 1);\n+        fail_unless!(map.get(&~\"b\") == 2);\n+        fail_unless!(map.get(&~\"c\") == 3);\n     }\n \n     #[test]\n@@ -685,11 +685,11 @@ mod tests {\n         map.update_with_key(~\"cat\",      2, addMoreToCount);\n \n         // check the total counts\n-        assert map.find(&~\"cat\").get() == 10;\n-        assert map.find(&~\"ferret\").get() == 3;\n-        assert map.find(&~\"mongoose\").get() == 1;\n+        fail_unless!(map.find(&~\"cat\").get() == 10);\n+        fail_unless!(map.find(&~\"ferret\").get() == 3);\n+        fail_unless!(map.find(&~\"mongoose\").get() == 1);\n \n         // sadly, no mythical animals were counted!\n-        assert map.find(&~\"unicorn\").is_none();\n+        fail_unless!(map.find(&~\"unicorn\").is_none());\n     }\n }"}, {"sha": "a33effba8e0cf86f35b71830479784fdbac51916", "filename": "src/libstd/par.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -68,7 +68,7 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n                             cast::reinterpret_cast(&slice);\n                         log(info, fmt!(\"slice: %?\",\n                                        (base, vec::len(slice), end - base)));\n-                        assert(vec::len(slice) == end - base);\n+                        fail_unless!((vec::len(slice) == end - base));\n                         f(base, slice)\n                     }\n                 };\n@@ -79,12 +79,12 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n         log(info, ~\"tasks spawned\");\n \n         log(info, fmt!(\"num_tasks: %?\", (num_tasks, futures.len())));\n-        assert(num_tasks == futures.len());\n+        fail_unless!((num_tasks == futures.len()));\n \n         let r = do futures.map() |ys| {\n             ys.get()\n         };\n-        assert(r.len() == futures.len());\n+        fail_unless!((r.len() == futures.len()));\n         r\n     }\n }\n@@ -115,7 +115,7 @@ pub fn mapi<A:Copy + Owned,B:Copy + Owned>(\n     });\n     let r = vec::concat(slices);\n     log(info, (r.len(), xs.len()));\n-    assert(r.len() == xs.len());\n+    fail_unless!((r.len() == xs.len()));\n     r\n }\n "}, {"sha": "676bc68e4e513af44be76e6295478a385747915a", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -197,87 +197,87 @@ mod tests {\n         let mut sorted = merge_sort(data, le);\n         let mut heap = from_vec(data);\n         while !heap.is_empty() {\n-            assert heap.top() == sorted.last();\n-            assert heap.pop() == sorted.pop();\n+            fail_unless!(heap.top() == sorted.last());\n+            fail_unless!(heap.pop() == sorted.pop());\n         }\n     }\n \n     #[test]\n     fn test_push() {\n         let mut heap = from_vec(~[2, 4, 9]);\n-        assert heap.len() == 3;\n-        assert *heap.top() == 9;\n+        fail_unless!(heap.len() == 3);\n+        fail_unless!(*heap.top() == 9);\n         heap.push(11);\n-        assert heap.len() == 4;\n-        assert *heap.top() == 11;\n+        fail_unless!(heap.len() == 4);\n+        fail_unless!(*heap.top() == 11);\n         heap.push(5);\n-        assert heap.len() == 5;\n-        assert *heap.top() == 11;\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(*heap.top() == 11);\n         heap.push(27);\n-        assert heap.len() == 6;\n-        assert *heap.top() == 27;\n+        fail_unless!(heap.len() == 6);\n+        fail_unless!(*heap.top() == 27);\n         heap.push(3);\n-        assert heap.len() == 7;\n-        assert *heap.top() == 27;\n+        fail_unless!(heap.len() == 7);\n+        fail_unless!(*heap.top() == 27);\n         heap.push(103);\n-        assert heap.len() == 8;\n-        assert *heap.top() == 103;\n+        fail_unless!(heap.len() == 8);\n+        fail_unless!(*heap.top() == 103);\n     }\n \n     #[test]\n     fn test_push_unique() {\n         let mut heap = from_vec(~[~2, ~4, ~9]);\n-        assert heap.len() == 3;\n-        assert *heap.top() == ~9;\n+        fail_unless!(heap.len() == 3);\n+        fail_unless!(*heap.top() == ~9);\n         heap.push(~11);\n-        assert heap.len() == 4;\n-        assert *heap.top() == ~11;\n+        fail_unless!(heap.len() == 4);\n+        fail_unless!(*heap.top() == ~11);\n         heap.push(~5);\n-        assert heap.len() == 5;\n-        assert *heap.top() == ~11;\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(*heap.top() == ~11);\n         heap.push(~27);\n-        assert heap.len() == 6;\n-        assert *heap.top() == ~27;\n+        fail_unless!(heap.len() == 6);\n+        fail_unless!(*heap.top() == ~27);\n         heap.push(~3);\n-        assert heap.len() == 7;\n-        assert *heap.top() == ~27;\n+        fail_unless!(heap.len() == 7);\n+        fail_unless!(*heap.top() == ~27);\n         heap.push(~103);\n-        assert heap.len() == 8;\n-        assert *heap.top() == ~103;\n+        fail_unless!(heap.len() == 8);\n+        fail_unless!(*heap.top() == ~103);\n     }\n \n     #[test]\n     fn test_push_pop() {\n         let mut heap = from_vec(~[5, 5, 2, 1, 3]);\n-        assert heap.len() == 5;\n-        assert heap.push_pop(6) == 6;\n-        assert heap.len() == 5;\n-        assert heap.push_pop(0) == 5;\n-        assert heap.len() == 5;\n-        assert heap.push_pop(4) == 5;\n-        assert heap.len() == 5;\n-        assert heap.push_pop(1) == 4;\n-        assert heap.len() == 5;\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.push_pop(6) == 6);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.push_pop(0) == 5);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.push_pop(4) == 5);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.push_pop(1) == 4);\n+        fail_unless!(heap.len() == 5);\n     }\n \n     #[test]\n     fn test_replace() {\n         let mut heap = from_vec(~[5, 5, 2, 1, 3]);\n-        assert heap.len() == 5;\n-        assert heap.replace(6) == 5;\n-        assert heap.len() == 5;\n-        assert heap.replace(0) == 6;\n-        assert heap.len() == 5;\n-        assert heap.replace(4) == 5;\n-        assert heap.len() == 5;\n-        assert heap.replace(1) == 4;\n-        assert heap.len() == 5;\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.replace(6) == 5);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.replace(0) == 6);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.replace(4) == 5);\n+        fail_unless!(heap.len() == 5);\n+        fail_unless!(heap.replace(1) == 4);\n+        fail_unless!(heap.len() == 5);\n     }\n \n     fn check_to_vec(data: ~[int]) {\n         let heap = from_vec(data);\n-        assert merge_sort(heap.to_vec(), le) == merge_sort(data, le);\n-        assert heap.to_sorted_vec() == merge_sort(data, le);\n+        fail_unless!(merge_sort(heap.to_vec(), le) == merge_sort(data, le));\n+        fail_unless!(heap.to_sorted_vec() == merge_sort(data, le));\n     }\n \n     #[test]\n@@ -305,7 +305,7 @@ mod tests {\n     #[test]\n     fn test_empty_maybe_pop() {\n         let mut heap = new::<int>();\n-        assert heap.maybe_pop().is_none();\n+        fail_unless!(heap.maybe_pop().is_none());\n     }\n \n     #[test]\n@@ -316,7 +316,7 @@ mod tests {\n     #[test]\n     fn test_empty_maybe_top() {\n         let empty = new::<int>();\n-        assert empty.maybe_top().is_none();\n+        fail_unless!(empty.maybe_top().is_none());\n     }\n \n     #[test]"}, {"sha": "d511ac9744eb385bd0dd9de5be9492c25e0276d8", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -704,7 +704,7 @@ pub mod node {\n      */\n     pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n                              char_len: uint) -> @Node {\n-        assert(byte_start + byte_len <= str::len(*str));\n+        fail_unless!((byte_start + byte_len <= str::len(*str)));\n         let candidate = @Leaf(Leaf {\n             byte_offset: byte_start,\n             byte_len: byte_len,\n@@ -1313,17 +1313,17 @@ mod tests {\n \n     #[test]\n     fn trivial() {\n-        assert char_len(empty()) == 0u;\n-        assert byte_len(empty()) == 0u;\n+        fail_unless!(char_len(empty()) == 0u);\n+        fail_unless!(byte_len(empty()) == 0u);\n     }\n \n     #[test]\n     fn of_string1() {\n         let sample = @~\"0123456789ABCDE\";\n         let r      = of_str(sample);\n \n-        assert char_len(r) == str::char_len(*sample);\n-        assert rope_to_string(r) == *sample;\n+        fail_unless!(char_len(r) == str::char_len(*sample));\n+        fail_unless!(rope_to_string(r) == *sample);\n     }\n \n     #[test]\n@@ -1338,8 +1338,8 @@ mod tests {\n         }\n         let sample = @*buf;\n         let r      = of_str(sample);\n-        assert char_len(r) == str::char_len(*sample);\n-        assert rope_to_string(r) == *sample;\n+        fail_unless!(char_len(r) == str::char_len(*sample));\n+        fail_unless!(rope_to_string(r) == *sample);\n \n         let mut string_iter = 0u;\n         let string_len  = str::len(*sample);\n@@ -1359,7 +1359,7 @@ mod tests {\n             }\n         }\n \n-        assert equal;\n+        fail_unless!(equal);\n     }\n \n     #[test]\n@@ -1384,7 +1384,7 @@ mod tests {\n             }\n         }\n \n-        assert len == str::char_len(*sample);\n+        fail_unless!(len == str::char_len(*sample));\n     }\n \n     #[test]\n@@ -1405,11 +1405,11 @@ mod tests {\n         while i < 8 { r2 = append_rope(r2, r2); i+= 1;}\n \n \n-        assert eq(r1, r2);\n+        fail_unless!(eq(r1, r2));\n         let r3 = bal(r2);\n-        assert char_len(r1) == char_len(r3);\n+        fail_unless!(char_len(r1) == char_len(r3));\n \n-        assert eq(r1, r3);\n+        fail_unless!(eq(r1, r3));\n     }\n \n     #[test]\n@@ -1426,23 +1426,23 @@ mod tests {\n         for uint::range(0u, char_len(r)) |i| {\n             r2 = append_char(r2, char_at(r, i));\n         }\n-        assert eq(r, r2);\n+        fail_unless!(eq(r, r2));\n \n         let mut r3 = empty();\n         for uint::range(0u, char_len(r)) |i| {\n             r3 = prepend_char(r3, char_at(r, char_len(r) - i - 1u));\n         }\n-        assert eq(r, r3);\n+        fail_unless!(eq(r, r3));\n \n         //Additional sanity checks\n         let balr = bal(r);\n         let bal2 = bal(r2);\n         let bal3 = bal(r3);\n-        assert eq(r, balr);\n-        assert eq(r, bal2);\n-        assert eq(r, bal3);\n-        assert eq(r2, r3);\n-        assert eq(bal2, bal3);\n+        fail_unless!(eq(r, balr));\n+        fail_unless!(eq(r, bal2));\n+        fail_unless!(eq(r, bal3));\n+        fail_unless!(eq(r2, r3));\n+        fail_unless!(eq(bal2, bal3));\n     }\n \n     #[test]\n@@ -1457,6 +1457,6 @@ mod tests {\n         //Same rope, obtained with rope::concat\n         let r2 = concat(vec::from_elem(10u, chunk));\n \n-        assert eq(r, r2);\n+        fail_unless!(eq(r, r2));\n     }\n }"}, {"sha": "bf4091e1e902d593d4a17fa84803121172df5cac", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -240,135 +240,135 @@ pub fn parse(s: &str) -> Option<Version> {\n \n #[test]\n fn test_parse() {\n-    assert parse(\"\") == None;\n-    assert parse(\"  \") == None;\n-    assert parse(\"1\") == None;\n-    assert parse(\"1.2\") == None;\n-    assert parse(\"1.2\") == None;\n-    assert parse(\"1\") == None;\n-    assert parse(\"1.2\") == None;\n-    assert parse(\"1.2.3-\") == None;\n-    assert parse(\"a.b.c\") == None;\n-    assert parse(\"1.2.3 abc\") == None;\n-\n-    assert parse(\"1.2.3\") == Some(Version {\n+    fail_unless!(parse(\"\") == None);\n+    fail_unless!(parse(\"  \") == None);\n+    fail_unless!(parse(\"1\") == None);\n+    fail_unless!(parse(\"1.2\") == None);\n+    fail_unless!(parse(\"1.2\") == None);\n+    fail_unless!(parse(\"1\") == None);\n+    fail_unless!(parse(\"1.2\") == None);\n+    fail_unless!(parse(\"1.2.3-\") == None);\n+    fail_unless!(parse(\"a.b.c\") == None);\n+    fail_unless!(parse(\"1.2.3 abc\") == None);\n+\n+    fail_unless!(parse(\"1.2.3\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[],\n         build: ~[],\n-    });\n-    assert parse(\"  1.2.3  \") == Some(Version {\n+    }));\n+    fail_unless!(parse(\"  1.2.3  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[],\n         build: ~[],\n-    });\n-    assert parse(\"1.2.3-alpha1\") == Some(Version {\n+    }));\n+    fail_unless!(parse(\"1.2.3-alpha1\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[AlphaNumeric(~\"alpha1\")],\n         build: ~[]\n-    });\n-    assert parse(\"  1.2.3-alpha1  \") == Some(Version {\n+    }));\n+    fail_unless!(parse(\"  1.2.3-alpha1  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[AlphaNumeric(~\"alpha1\")],\n         build: ~[]\n-    });\n-    assert parse(\"1.2.3+build5\") == Some(Version {\n+    }));\n+    fail_unless!(parse(\"1.2.3+build5\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[],\n         build: ~[AlphaNumeric(~\"build5\")]\n-    });\n-    assert parse(\"  1.2.3+build5  \") == Some(Version {\n+    }));\n+    fail_unless!(parse(\"  1.2.3+build5  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[],\n         build: ~[AlphaNumeric(~\"build5\")]\n-    });\n-    assert parse(\"1.2.3-alpha1+build5\") == Some(Version {\n+    }));\n+    fail_unless!(parse(\"1.2.3-alpha1+build5\") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[AlphaNumeric(~\"alpha1\")],\n         build: ~[AlphaNumeric(~\"build5\")]\n-    });\n-    assert parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n+    }));\n+    fail_unless!(parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[AlphaNumeric(~\"alpha1\")],\n         build: ~[AlphaNumeric(~\"build5\")]\n-    });\n-    assert parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n+    }));\n+    fail_unless!(parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n         major: 1u,\n         minor: 2u,\n         patch: 3u,\n         pre: ~[Numeric(1),AlphaNumeric(~\"alpha1\"),Numeric(9)],\n         build: ~[AlphaNumeric(~\"build5\"),\n                  Numeric(7),\n                  AlphaNumeric(~\"3aedf\")]\n-    });\n+    }));\n \n }\n \n #[test]\n fn test_eq() {\n-    assert parse(\"1.2.3\")        == parse(\"1.2.3\");\n-    assert parse(\"1.2.3-alpha1\") == parse(\"1.2.3-alpha1\");\n+    fail_unless!(parse(\"1.2.3\")        == parse(\"1.2.3\"));\n+    fail_unless!(parse(\"1.2.3-alpha1\") == parse(\"1.2.3-alpha1\"));\n }\n \n #[test]\n fn test_ne() {\n-    assert parse(\"0.0.0\")       != parse(\"0.0.1\");\n-    assert parse(\"0.0.0\")       != parse(\"0.1.0\");\n-    assert parse(\"0.0.0\")       != parse(\"1.0.0\");\n-    assert parse(\"1.2.3-alpha\") != parse(\"1.2.3-beta\");\n+    fail_unless!(parse(\"0.0.0\")       != parse(\"0.0.1\"));\n+    fail_unless!(parse(\"0.0.0\")       != parse(\"0.1.0\"));\n+    fail_unless!(parse(\"0.0.0\")       != parse(\"1.0.0\"));\n+    fail_unless!(parse(\"1.2.3-alpha\") != parse(\"1.2.3-beta\"));\n }\n \n #[test]\n fn test_lt() {\n-    assert parse(\"0.0.0\")        < parse(\"1.2.3-alpha2\");\n-    assert parse(\"1.0.0\")        < parse(\"1.2.3-alpha2\");\n-    assert parse(\"1.2.0\")        < parse(\"1.2.3-alpha2\");\n-    assert parse(\"1.2.3-alpha1\") < parse(\"1.2.3\");\n-    assert parse(\"1.2.3-alpha1\") < parse(\"1.2.3-alpha2\");\n-    assert !(parse(\"1.2.3-alpha2\") < parse(\"1.2.3-alpha2\"));\n+    fail_unless!(parse(\"0.0.0\")        < parse(\"1.2.3-alpha2\"));\n+    fail_unless!(parse(\"1.0.0\")        < parse(\"1.2.3-alpha2\"));\n+    fail_unless!(parse(\"1.2.0\")        < parse(\"1.2.3-alpha2\"));\n+    fail_unless!(parse(\"1.2.3-alpha1\") < parse(\"1.2.3\"));\n+    fail_unless!(parse(\"1.2.3-alpha1\") < parse(\"1.2.3-alpha2\"));\n+    fail_unless!(!(parse(\"1.2.3-alpha2\") < parse(\"1.2.3-alpha2\")));\n }\n \n #[test]\n fn test_le() {\n-    assert parse(\"0.0.0\")        <= parse(\"1.2.3-alpha2\");\n-    assert parse(\"1.0.0\")        <= parse(\"1.2.3-alpha2\");\n-    assert parse(\"1.2.0\")        <= parse(\"1.2.3-alpha2\");\n-    assert parse(\"1.2.3-alpha1\") <= parse(\"1.2.3-alpha2\");\n-    assert parse(\"1.2.3-alpha2\") <= parse(\"1.2.3-alpha2\");\n+    fail_unless!(parse(\"0.0.0\")        <= parse(\"1.2.3-alpha2\"));\n+    fail_unless!(parse(\"1.0.0\")        <= parse(\"1.2.3-alpha2\"));\n+    fail_unless!(parse(\"1.2.0\")        <= parse(\"1.2.3-alpha2\"));\n+    fail_unless!(parse(\"1.2.3-alpha1\") <= parse(\"1.2.3-alpha2\"));\n+    fail_unless!(parse(\"1.2.3-alpha2\") <= parse(\"1.2.3-alpha2\"));\n }\n \n #[test]\n fn test_gt() {\n-    assert parse(\"1.2.3-alpha2\") > parse(\"0.0.0\");\n-    assert parse(\"1.2.3-alpha2\") > parse(\"1.0.0\");\n-    assert parse(\"1.2.3-alpha2\") > parse(\"1.2.0\");\n-    assert parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha1\");\n-    assert parse(\"1.2.3\")        > parse(\"1.2.3-alpha2\");\n-    assert !(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha2\"));\n+    fail_unless!(parse(\"1.2.3-alpha2\") > parse(\"0.0.0\"));\n+    fail_unless!(parse(\"1.2.3-alpha2\") > parse(\"1.0.0\"));\n+    fail_unless!(parse(\"1.2.3-alpha2\") > parse(\"1.2.0\"));\n+    fail_unless!(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha1\"));\n+    fail_unless!(parse(\"1.2.3\")        > parse(\"1.2.3-alpha2\"));\n+    fail_unless!(!(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha2\")));\n }\n \n #[test]\n fn test_ge() {\n-    assert parse(\"1.2.3-alpha2\") >= parse(\"0.0.0\");\n-    assert parse(\"1.2.3-alpha2\") >= parse(\"1.0.0\");\n-    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.0\");\n-    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha1\");\n-    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha2\");\n+    fail_unless!(parse(\"1.2.3-alpha2\") >= parse(\"0.0.0\"));\n+    fail_unless!(parse(\"1.2.3-alpha2\") >= parse(\"1.0.0\"));\n+    fail_unless!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.0\"));\n+    fail_unless!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha1\"));\n+    fail_unless!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha2\"));\n }\n \n #[test]\n@@ -389,7 +389,7 @@ fn test_spec_order() {\n     while i < vs.len() {\n         let a = parse(vs[i-1]).get();\n         let b = parse(vs[i]).get();\n-        assert a < b;\n+        fail_unless!(a < b);\n         i += 1;\n     }\n }"}, {"sha": "b1ef0233d97e2e4afe7bd3e9c3dde0047c4e6573", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -74,7 +74,7 @@ pub fn sha1() -> @Sha1 {\n           work_buf: @mut ~[u32]};\n \n     fn add_input(st: &mut Sha1State, msg: &[const u8]) {\n-        assert (!st.computed);\n+        fail_unless!((!st.computed));\n         for vec::each_const(msg) |element| {\n             st.msg_block[st.msg_block_idx] = *element;\n             st.msg_block_idx += 1u;\n@@ -90,8 +90,8 @@ pub fn sha1() -> @Sha1 {\n         }\n     }\n     fn process_msg_block(st: &mut Sha1State) {\n-        assert (vec::len(st.h) == digest_buf_len);\n-        assert (vec::len(*st.work_buf) == work_buf_len);\n+        fail_unless!((vec::len(st.h) == digest_buf_len));\n+        fail_unless!((vec::len(*st.work_buf) == work_buf_len));\n         let mut t: int; // Loop counter\n         let mut w = st.work_buf;\n \n@@ -192,7 +192,7 @@ pub fn sha1() -> @Sha1 {\n      * can be assumed that the message digest has been computed.\n      */\n     fn pad_msg(st: &mut Sha1State) {\n-        assert (vec::len((*st).msg_block) == msg_block_len);\n+        fail_unless!((vec::len((*st).msg_block) == msg_block_len));\n \n         /*\n          * Check to see if the current message block is too small to hold\n@@ -230,7 +230,7 @@ pub fn sha1() -> @Sha1 {\n \n     impl Sha1 for Sha1State {\n         fn reset(&mut self) {\n-            assert (vec::len(self.h) == digest_buf_len);\n+            fail_unless!((vec::len(self.h) == digest_buf_len));\n             self.len_low = 0u32;\n             self.len_high = 0u32;\n             self.msg_block_idx = 0u;\n@@ -366,13 +366,13 @@ mod tests {\n             ];\n             let tests = fips_180_1_tests + wikipedia_tests;\n             fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-                assert (vec::len::<u8>(v0) == vec::len::<u8>(v1));\n+                fail_unless!((vec::len::<u8>(v0) == vec::len::<u8>(v1)));\n                 let len = vec::len::<u8>(v0);\n                 let mut i = 0u;\n                 while i < len {\n                     let a = v0[i];\n                     let b = v1[i];\n-                    assert (a == b);\n+                    fail_unless!((a == b));\n                     i += 1u;\n                 }\n             }\n@@ -385,8 +385,8 @@ mod tests {\n                 check_vec_eq(t.output, out);\n \n                 let out_str = sh.result_str();\n-                assert(out_str.len() == 40);\n-                assert(out_str == t.output_str);\n+                fail_unless!((out_str.len() == 40));\n+                fail_unless!((out_str == t.output_str));\n \n                 sh.reset();\n             }\n@@ -406,8 +406,8 @@ mod tests {\n                 check_vec_eq(t.output, out);\n \n                 let out_str = sh.result_str();\n-                assert(out_str.len() == 40);\n-                assert(out_str == t.output_str);\n+                fail_unless!((out_str.len() == 40));\n+                fail_unless!((out_str == t.output_str));\n \n                 sh.reset();\n             }"}, {"sha": "84600ac74eeb94da3d488605f4dbfcb293402a2f", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -153,30 +153,30 @@ mod tests {\n     #[test]\n     fn test_len() {\n         let mut map = SmallIntMap::new();\n-        assert map.len() == 0;\n-        assert map.is_empty();\n-        assert map.insert(5, 20);\n-        assert map.len() == 1;\n-        assert !map.is_empty();\n-        assert map.insert(11, 12);\n-        assert map.len() == 2;\n-        assert !map.is_empty();\n-        assert map.insert(14, 22);\n-        assert map.len() == 3;\n-        assert !map.is_empty();\n+        fail_unless!(map.len() == 0);\n+        fail_unless!(map.is_empty());\n+        fail_unless!(map.insert(5, 20));\n+        fail_unless!(map.len() == 1);\n+        fail_unless!(!map.is_empty());\n+        fail_unless!(map.insert(11, 12));\n+        fail_unless!(map.len() == 2);\n+        fail_unless!(!map.is_empty());\n+        fail_unless!(map.insert(14, 22));\n+        fail_unless!(map.len() == 3);\n+        fail_unless!(!map.is_empty());\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut map = SmallIntMap::new();\n-        assert map.insert(5, 20);\n-        assert map.insert(11, 12);\n-        assert map.insert(14, 22);\n+        fail_unless!(map.insert(5, 20));\n+        fail_unless!(map.insert(11, 12));\n+        fail_unless!(map.insert(14, 22));\n         map.clear();\n-        assert map.is_empty();\n-        assert map.find(&5).is_none();\n-        assert map.find(&11).is_none();\n-        assert map.find(&14).is_none();\n+        fail_unless!(map.is_empty());\n+        fail_unless!(map.find(&5).is_none());\n+        fail_unless!(map.find(&11).is_none());\n+        fail_unless!(map.find(&14).is_none());\n     }\n \n     #[test]\n@@ -201,11 +201,11 @@ mod tests {\n         map.update_with_key(3, 2, addMoreToCount);\n \n         // check the total counts\n-        assert map.find(&3).get() == &10;\n-        assert map.find(&5).get() == &3;\n-        assert map.find(&9).get() == &1;\n+        fail_unless!(map.find(&3).get() == &10);\n+        fail_unless!(map.find(&5).get() == &3);\n+        fail_unless!(map.find(&9).get() == &1);\n \n         // sadly, no sevens were counted\n-        assert map.find(&7).is_none();\n+        fail_unless!(map.find(&7).is_none());\n     }\n }"}, {"sha": "37be1c86e917b3a6166eff58004bad367eb38bb9", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -219,15 +219,15 @@ pub fn tim_sort<T:Copy + Ord>(array: &mut [T]) {\n fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n     let size = array.len();\n     let mut start = start;\n-    assert start <= size;\n+    fail_unless!(start <= size);\n \n     if start == 0 { start += 1; }\n \n     while start < size {\n         let pivot = array[start];\n         let mut left = 0;\n         let mut right = start;\n-        assert left <= right;\n+        fail_unless!(left <= right);\n \n         while left < right {\n             let mid = (left + right) >> 1;\n@@ -237,7 +237,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n                 left = mid+1;\n             }\n         }\n-        assert left == right;\n+        fail_unless!(left == right);\n         let mut n = start-left;\n \n         copy_vec(array, left+1, array, left, n);\n@@ -268,7 +268,7 @@ pure fn min_run_length(n: uint) -> uint {\n \n fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n     let size = array.len();\n-    assert size > 0;\n+    fail_unless!(size > 0);\n     if size == 1 { return 1; }\n \n     let mut run = 2;\n@@ -289,7 +289,7 @@ fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n pure fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n-    assert size != 0 && hint < size;\n+    fail_unless!(size != 0 && hint < size);\n \n     let mut last_ofs = 0;\n     let mut ofs = 1;\n@@ -320,7 +320,7 @@ pure fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n         last_ofs = hint - ofs;\n         ofs = hint - tmp;\n     }\n-    assert (last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size;\n+    fail_unless!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n \n     last_ofs += 1;\n     while last_ofs < ofs {\n@@ -331,14 +331,14 @@ pure fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n             ofs = m;\n         }\n     }\n-    assert last_ofs == ofs;\n+    fail_unless!(last_ofs == ofs);\n     return ofs;\n }\n \n pure fn gallop_right<T:Copy + Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n-    assert size != 0 && hint < size;\n+    fail_unless!(size != 0 && hint < size);\n \n     let mut last_ofs = 0;\n     let mut ofs = 1;\n@@ -370,7 +370,7 @@ pure fn gallop_right<T:Copy + Ord>(key: &const T, array: &[const T],\n         ofs = hint - tmp;\n     }\n \n-    assert (last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size;\n+    fail_unless!((last_ofs < ofs || last_ofs+1 < ofs+1) && ofs <= size);\n \n     last_ofs += 1;\n     while last_ofs < ofs {\n@@ -382,7 +382,7 @@ pure fn gallop_right<T:Copy + Ord>(key: &const T, array: &[const T],\n             ofs = m;\n         }\n     }\n-    assert last_ofs == ofs;\n+    fail_unless!(last_ofs == ofs);\n     return ofs;\n }\n \n@@ -412,8 +412,8 @@ pub impl<T:Copy + Ord> MergeState<T> {\n \n     fn merge_at(&self, n: uint, array: &mut [T]) {\n         let mut size = self.runs.len();\n-        assert size >= 2;\n-        assert n == size-2 || n == size-3;\n+        fail_unless!(size >= 2);\n+        fail_unless!(n == size-2 || n == size-3);\n \n         do self.runs.borrow_mut |arr| {\n \n@@ -422,8 +422,8 @@ pub impl<T:Copy + Ord> MergeState<T> {\n             let b2 = arr[n+1].base;\n             let l2 = arr[n+1].len;\n \n-            assert l1 > 0 && l2 > 0;\n-            assert b1 + l1 == b2;\n+            fail_unless!(l1 > 0 && l2 > 0);\n+            fail_unless!(b1 + l1 == b2);\n \n             arr[n].len = l1 + l2;\n             if n == size-3 {\n@@ -453,7 +453,7 @@ pub impl<T:Copy + Ord> MergeState<T> {\n \n     fn merge_lo(&self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n-        assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n+        fail_unless!(len1 != 0 && len2 != 0 && base1+len1 == base2);\n \n         let mut tmp = vec::slice(array, base1, base1+len1).to_vec();\n \n@@ -483,7 +483,7 @@ pub impl<T:Copy + Ord> MergeState<T> {\n             let mut break_outer = false;\n \n             loop {\n-                assert len1 > 1 && len2 != 0;\n+                fail_unless!(len1 > 1 && len2 != 0);\n                 if array[c2] < tmp[c1] {\n                     array[dest] <-> array[c2];\n                     dest += 1; c2 += 1; len2 -= 1;\n@@ -507,7 +507,7 @@ pub impl<T:Copy + Ord> MergeState<T> {\n \n             // Start to gallop\n             loop {\n-                assert len1 > 1 && len2 != 0;\n+                fail_unless!(len1 > 1 && len2 != 0);\n \n                 let tmp_view = vec::const_slice(tmp, c1, c1+len1);\n                 count1 = gallop_right(&const array[c2], tmp_view, 0);\n@@ -542,21 +542,21 @@ pub impl<T:Copy + Ord> MergeState<T> {\n         self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n \n         if len1 == 1 {\n-            assert len2 > 0;\n+            fail_unless!(len2 > 0);\n             copy_vec(array, dest, array, c2, len2);\n             array[dest+len2] <-> tmp[c1];\n         } else if len1 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n-            assert len2 == 0;\n-            assert len1 > 1;\n+            fail_unless!(len2 == 0);\n+            fail_unless!(len1 > 1);\n             copy_vec(array, dest, tmp, c1, len1);\n         }\n     }\n \n     fn merge_hi(&self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n-        assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n+        fail_unless!(len1 != 1 && len2 != 0 && base1 + len1 == base2);\n \n         let mut tmp = vec::slice(array, base2, base2+len2).to_vec();\n \n@@ -588,7 +588,7 @@ pub impl<T:Copy + Ord> MergeState<T> {\n             let mut break_outer = false;\n \n             loop {\n-                assert len1 != 0 && len2 > 1;\n+                fail_unless!(len1 != 0 && len2 > 1);\n                 if tmp[c2] < array[c1] {\n                     array[dest] <-> array[c1];\n                     dest -= 1; c1 -= 1; len1 -= 1;\n@@ -612,7 +612,7 @@ pub impl<T:Copy + Ord> MergeState<T> {\n \n             // Start to gallop\n             loop {\n-                assert len2 > 1 && len1 != 0;\n+                fail_unless!(len2 > 1 && len1 != 0);\n \n                 let tmp_view = vec::mut_slice(array, base1, base1+len1);\n                 count1 = len1 - gallop_right(\n@@ -658,16 +658,16 @@ pub impl<T:Copy + Ord> MergeState<T> {\n         self.min_gallop = if min_gallop < 1 { 1 } else { min_gallop };\n \n         if len2 == 1 {\n-            assert len1 > 0;\n+            fail_unless!(len1 > 0);\n             dest -= len1;\n             c1 -= len1;\n             copy_vec(array, dest+1, array, c1+1, len1);\n             array[dest] <-> tmp[c2];\n         } else if len2 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n-            assert len1 == 0;\n-            assert len2 != 0;\n+            fail_unless!(len1 == 0);\n+            fail_unless!(len2 != 0);\n             copy_vec(array, dest-(len2-1), tmp, 0, len2);\n         }\n     }\n@@ -708,7 +708,7 @@ pub impl<T:Copy + Ord> MergeState<T> {\n #[inline(always)]\n fn copy_vec<T:Copy>(dest: &mut [T], s1: uint,\n                     from: &[const T], s2: uint, len: uint) {\n-    assert s1+len <= dest.len() && s2+len <= from.len();\n+    fail_unless!(s1+len <= dest.len() && s2+len <= from.len());\n \n     let slice = vec::slice(from, s2, s2+len).to_vec();\n     for slice.eachi |i, v| {\n@@ -730,7 +730,7 @@ mod test_qsort3 {\n         let mut i = 0;\n         while i < len {\n             log(debug, v2[i]);\n-            assert (v2[i] == v1[i]);\n+            fail_unless!((v2[i] == v1[i]));\n             i += 1;\n         }\n     }\n@@ -777,7 +777,7 @@ mod test_qsort {\n         let mut i = 0u;\n         while i < len {\n             log(debug, v2[i]);\n-            assert (v2[i] == v1[i]);\n+            fail_unless!((v2[i] == v1[i]));\n             i += 1;\n         }\n     }\n@@ -822,7 +822,7 @@ mod test_qsort {\n         for vec::each(pairs) |p| {\n             let (a, b) = *p;\n             debug!(\"%d %d\", a, b);\n-            assert (a == b);\n+            fail_unless!((a == b));\n         }\n     }\n }\n@@ -843,7 +843,7 @@ mod tests {\n         let mut i = 0u;\n         while i < len {\n             log(debug, v3[i]);\n-            assert (v3[i] == v2[i]);\n+            fail_unless!((v3[i] == v2[i]));\n             i += 1;\n         }\n     }\n@@ -870,7 +870,7 @@ mod tests {\n         pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let mut v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n-        assert v2 == ~[1, 2, 3];\n+        fail_unless!(v2 == ~[1, 2, 3]);\n     }\n \n     #[test]\n@@ -891,7 +891,7 @@ mod tests {\n         let names2 = ~[\"Alex Andy\", \"Jack Brown\", \"joe bob\", \"Joe Bob\",\n                        \"JOE Bob\", \"JOE BOB\", \"Sally Mae\"];\n         let names3 = merge_sort(names1, ile);\n-        assert names3 == names2;\n+        fail_unless!(names3 == names2);\n     }\n }\n \n@@ -927,7 +927,7 @@ mod test_tim_sort {\n         let mut i = 0u;\n         while i < len {\n             log(debug, v2[i]);\n-            assert (v2[i] == v1[i]);\n+            fail_unless!((v2[i] == v1[i]));\n             i += 1u;\n         }\n     }"}, {"sha": "2a62ebadd2b73d5b31498084cf1a278fb6b48231", "filename": "src/libstd/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstats.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -36,22 +36,22 @@ impl Stats for &self/[f64] {\n     }\n \n     fn min(self) -> f64 {\n-        assert self.len() != 0;\n+        fail_unless!(self.len() != 0);\n         vec::foldl(self[0], self, |p,q| cmp::min(p, *q))\n     }\n \n     fn max(self) -> f64 {\n-        assert self.len() != 0;\n+        fail_unless!(self.len() != 0);\n         vec::foldl(self[0], self, |p,q| cmp::max(p, *q))\n     }\n \n     fn mean(self) -> f64 {\n-        assert self.len() != 0;\n+        fail_unless!(self.len() != 0);\n         self.sum() / (self.len() as f64)\n     }\n \n     fn median(self) -> f64 {\n-        assert self.len() != 0;\n+        fail_unless!(self.len() != 0);\n         let mut tmp = vec::from_slice(self);\n         sort::tim_sort(tmp);\n         if tmp.len() & 1 == 0 {"}, {"sha": "d143c665d8310a22c6b078cdf9d55c33e27db878", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -588,7 +588,7 @@ pub impl RWlock {\n             do task::unkillable {\n                 let mut first_reader = false;\n                 do self.state.with |state| {\n-                    assert !state.read_mode;\n+                    fail_unless!(!state.read_mode);\n                     state.read_mode = true;\n                     first_reader = (state.read_count == 0);\n                     state.read_count += 1;\n@@ -618,8 +618,8 @@ impl Drop for RWlockReleaseRead/&self {\n             do task::unkillable {\n                 let mut last_reader = false;\n                 do self.lock.state.with |state| {\n-                    assert state.read_mode;\n-                    assert state.read_count > 0;\n+                    fail_unless!(state.read_mode);\n+                    fail_unless!(state.read_count > 0);\n                     state.read_count -= 1;\n                     if state.read_count == 0 {\n                         last_reader = true;\n@@ -653,7 +653,7 @@ impl Drop for RWlockReleaseDowngrade/&self {\n                 let mut writer_or_last_reader = false;\n                 do self.lock.state.with |state| {\n                     if state.read_mode {\n-                        assert state.read_count > 0;\n+                        fail_unless!(state.read_count > 0);\n                         state.read_count -= 1;\n                         if state.read_count == 0 {\n                             // Case 1: Writer downgraded & was the last reader\n@@ -839,7 +839,7 @@ mod tests {\n         access_shared(sharedstate, m, 10);\n         let _ = p.recv();\n \n-        assert *sharedstate == 20;\n+        fail_unless!(*sharedstate == 20);\n \n         fn access_shared(sharedstate: &mut int, m: &Mutex, n: uint) {\n             for n.times {\n@@ -861,7 +861,7 @@ mod tests {\n             do task::spawn || {\n                 do m2.lock_cond |cond| {\n                     let woken = cond.signal();\n-                    assert woken;\n+                    fail_unless!(woken);\n                 }\n             }\n             cond.wait();\n@@ -879,7 +879,7 @@ mod tests {\n         let _ = port.recv(); // Wait until child gets in the mutex\n         do m.lock_cond |cond| {\n             let woken = cond.signal();\n-            assert woken;\n+            fail_unless!(woken);\n         }\n         let _ = port.recv(); // Wait until child wakes up\n     }\n@@ -905,7 +905,7 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n         do m.lock_cond |cond| {\n             let num_woken = cond.broadcast();\n-            assert num_woken == num_waiters;\n+            fail_unless!(num_woken == num_waiters);\n         }\n         // wait until all children wake up\n         for ports.each |port| { let _ = port.recv(); }\n@@ -926,7 +926,7 @@ mod tests {\n             do m.lock_cond |_x| { }\n         };\n         do m2.lock_cond |cond| {\n-            assert !cond.signal();\n+            fail_unless!(!cond.signal());\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -940,7 +940,7 @@ mod tests {\n                 fail!();\n             }\n         };\n-        assert result.is_err();\n+        fail_unless!(result.is_err());\n         // child task must have finished by the time try returns\n         do m.lock { }\n     }\n@@ -963,11 +963,11 @@ mod tests {\n                 cond.wait(); // block forever\n             }\n         };\n-        assert result.is_err();\n+        fail_unless!(result.is_err());\n         // child task must have finished by the time try returns\n         do m.lock_cond |cond| {\n             let woken = cond.signal();\n-            assert !woken;\n+            fail_unless!(!woken);\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n@@ -1000,12 +1000,12 @@ mod tests {\n             c.send(sibling_convos); // let parent wait on all children\n             fail!();\n         };\n-        assert result.is_err();\n+        fail_unless!(result.is_err());\n         // child task must have finished by the time try returns\n         for vec::each(p.recv()) |p| { p.recv(); } // wait on all its siblings\n         do m.lock_cond |cond| {\n             let woken = cond.broadcast();\n-            assert woken == 0;\n+            fail_unless!(woken == 0);\n         }\n         struct SendOnFailure {\n             c: comm::Chan<()>,\n@@ -1056,25 +1056,25 @@ mod tests {\n                 }\n             }\n         };\n-        assert result.is_err();\n+        fail_unless!(result.is_err());\n     }\n     #[test] #[ignore(cfg(windows))]\n     pub fn test_mutex_no_condvars() {\n         let result = do task::try {\n             let m = ~mutex_with_condvars(0);\n             do m.lock_cond |cond| { cond.wait(); }\n         };\n-        assert result.is_err();\n+        fail_unless!(result.is_err());\n         let result = do task::try {\n             let m = ~mutex_with_condvars(0);\n             do m.lock_cond |cond| { cond.signal(); }\n         };\n-        assert result.is_err();\n+        fail_unless!(result.is_err());\n         let result = do task::try {\n             let m = ~mutex_with_condvars(0);\n             do m.lock_cond |cond| { cond.broadcast(); }\n         };\n-        assert result.is_err();\n+        fail_unless!(result.is_err());\n     }\n     /************************************************************************\n      * Reader/writer lock tests\n@@ -1116,7 +1116,7 @@ mod tests {\n         access_shared(sharedstate, x, mode2, 10);\n         let _ = p.recv();\n \n-        assert *sharedstate == 20;\n+        fail_unless!(*sharedstate == 20);\n \n         fn access_shared(sharedstate: &mut int, x: &RWlock, mode: RWlockMode,\n                          n: uint) {\n@@ -1210,7 +1210,7 @@ mod tests {\n             do task::spawn || {\n                 do x2.write_cond |cond| {\n                     let woken = cond.signal();\n-                    assert woken;\n+                    fail_unless!(woken);\n                 }\n             }\n             cond.wait();\n@@ -1229,7 +1229,7 @@ mod tests {\n         do x.read { } // Must be able to get in as a reader in the meantime\n         do x.write_cond |cond| { // Or as another writer\n             let woken = cond.signal();\n-            assert woken;\n+            fail_unless!(woken);\n         }\n         let _ = port.recv(); // Wait until child wakes up\n         do x.read { } // Just for good measure\n@@ -1268,7 +1268,7 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n         do lock_cond(x, dg2) |cond| {\n             let num_woken = cond.broadcast();\n-            assert num_woken == num_waiters;\n+            fail_unless!(num_woken == num_waiters);\n         }\n         // wait until all children wake up\n         for ports.each |port| { let _ = port.recv(); }\n@@ -1295,7 +1295,7 @@ mod tests {\n                 fail!();\n             }\n         };\n-        assert result.is_err();\n+        fail_unless!(result.is_err());\n         // child task must have finished by the time try returns\n         do lock_rwlock_in_mode(x, mode2) { }\n     }"}, {"sha": "09cab72ab21735f6bc099d5b1a24e50898588cea", "filename": "src/libstd/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask_pool.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -45,7 +45,7 @@ pub impl<T> TaskPool<T> {\n     static fn new(n_tasks: uint,\n                   opt_sched_mode: Option<SchedMode>,\n                   init_fn_factory: ~fn() -> ~fn(uint) -> T) -> TaskPool<T> {\n-        assert n_tasks >= 1;\n+        fail_unless!(n_tasks >= 1);\n \n         let channels = do vec::from_fn(n_tasks) |i| {\n             let (port, chan) = comm::stream::<Msg<T>>();"}, {"sha": "cd023962c8846e49347038a975ef272f4a5db454", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -29,5 +29,5 @@ pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n fn test_mkdtemp() {\n     let p = mkdtemp(&Path(\".\"), \"foobar\").unwrap();\n     os::remove_dir(&p);\n-    assert str::ends_with(p.to_str(), \"foobar\");\n+    fail_unless!(str::ends_with(p.to_str(), \"foobar\"));\n }"}, {"sha": "fb63755a572ee555551a2bd0273dee1f5641e940", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -60,7 +60,7 @@ pub fn color_supported() -> bool {\n }\n \n pub fn set_color(writer: io::Writer, first_char: u8, color: u8) {\n-    assert (color < 16u8);\n+    fail_unless!((color < 16u8));\n     esc(writer);\n     let mut color = color;\n     if color >= 8u8 { writer.write(~['1' as u8, ';' as u8]); color -= 8u8; }"}, {"sha": "b43389b9da2e0a0ad6b4bacff01d46da850545b4", "filename": "src/libstd/test.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -283,8 +283,8 @@ pub fn run_tests_console(opts: &TestOpts,\n \n     run_tests(opts, tests, |x| callback(&x, st));\n \n-    assert (st.passed + st.failed +\n-            st.ignored + st.benchmarked == st.total);\n+    fail_unless!(st.passed + st.failed +\n+                 st.ignored + st.benchmarked == st.total);\n     let success = st.failed == 0u;\n \n     if !success {\n@@ -397,7 +397,7 @@ fn should_sort_failures_before_printing_them() {\n \n     let apos = str::find_str(s, ~\"a\").get();\n     let bpos = str::find_str(s, ~\"b\").get();\n-    assert apos < bpos;\n+    fail_unless!(apos < bpos);\n }\n \n fn use_color() -> bool { return get_concurrency() == 1; }\n@@ -791,7 +791,7 @@ mod tests {\n         let ch = SharedChan(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        assert res != TrOk;\n+        fail_unless!(res != TrOk);\n     }\n \n     #[test]\n@@ -809,7 +809,7 @@ mod tests {\n         let ch = SharedChan(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        assert res == TrIgnored;\n+        fail_unless!(res == TrIgnored);\n     }\n \n     #[test]\n@@ -828,7 +828,7 @@ mod tests {\n         let ch = SharedChan(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        assert res == TrOk;\n+        fail_unless!(res == TrOk);\n     }\n \n     #[test]\n@@ -846,7 +846,7 @@ mod tests {\n         let ch = SharedChan(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n-        assert res == TrFailed;\n+        fail_unless!(res == TrFailed);\n     }\n \n     #[test]\n@@ -856,7 +856,7 @@ mod tests {\n           either::Left(copy o) => o,\n           _ => fail!(~\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n-        assert ~\"filter\" == opts.filter.get();\n+        fail_unless!(~\"filter\" == opts.filter.get());\n     }\n \n     #[test]\n@@ -866,7 +866,7 @@ mod tests {\n           either::Left(copy o) => o,\n           _ => fail!(~\"Malformed arg in parse_ignored_flag\")\n         };\n-        assert (opts.run_ignored);\n+        fail_unless!((opts.run_ignored));\n     }\n \n     #[test]\n@@ -906,9 +906,9 @@ mod tests {\n         ];\n         let filtered = filter_tests(&opts, tests);\n \n-        assert (vec::len(filtered) == 1);\n-        assert (filtered[0].desc.name.to_str() == ~\"1\");\n-        assert (filtered[0].desc.ignore == false);\n+        fail_unless!((vec::len(filtered) == 1));\n+        fail_unless!((filtered[0].desc.name.to_str() == ~\"1\"));\n+        fail_unless!((filtered[0].desc.ignore == false));\n     }\n \n     #[test]\n@@ -962,7 +962,7 @@ mod tests {\n \n         for vec::each(pairs) |p| {\n             match *p {\n-                (ref a, ref b) => { assert (*a == b.desc.name.to_str()); }\n+                (ref a, ref b) => { fail_unless!((*a == b.desc.name.to_str())); }\n             }\n         }\n     }"}, {"sha": "d008ad150061662538af060ce8a5c4928008849b", "filename": "src/libstd/time.rs", "status": "modified", "additions": 184, "deletions": 184, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -56,7 +56,7 @@ pub struct Timespec { sec: i64, nsec: i32 }\n  */\n pub impl Timespec {\n     static pure fn new(sec: i64, nsec: i32) -> Timespec {\n-        assert nsec >= 0 && nsec < NSEC_PER_SEC;\n+        fail_unless!(nsec >= 0 && nsec < NSEC_PER_SEC);\n         Timespec { sec: sec, nsec: nsec }\n     }\n }\n@@ -910,17 +910,17 @@ mod tests {\n         let tv1 = get_time();\n         debug!(\"tv1=%? sec + %? nsec\", tv1.sec as uint, tv1.nsec as uint);\n \n-        assert tv1.sec > some_recent_date;\n-        assert tv1.nsec < 1000000000i32;\n+        fail_unless!(tv1.sec > some_recent_date);\n+        fail_unless!(tv1.nsec < 1000000000i32);\n \n         let tv2 = get_time();\n         debug!(\"tv2=%? sec + %? nsec\", tv2.sec as uint, tv2.nsec as uint);\n \n-        assert tv2.sec >= tv1.sec;\n-        assert tv2.sec < some_future_date;\n-        assert tv2.nsec < 1000000000i32;\n+        fail_unless!(tv2.sec >= tv1.sec);\n+        fail_unless!(tv2.sec < some_future_date);\n+        fail_unless!(tv2.nsec < 1000000000i32);\n         if tv2.sec == tv1.sec {\n-            assert tv2.nsec >= tv1.nsec;\n+            fail_unless!(tv2.nsec >= tv1.nsec);\n         }\n     }\n \n@@ -929,16 +929,16 @@ mod tests {\n         let ns1 = precise_time_ns();\n \n         debug!(\"s0=%s sec\", float::to_str_digits(s0, 9u));\n-        assert s0 > 0.;\n+        fail_unless!(s0 > 0.);\n         let ns0 = (s0 * 1000000000.) as u64;\n         debug!(\"ns0=%? ns\", ns0);\n \n         debug!(\"ns1=%? ns\", ns0);\n-        assert ns1 >= ns0;\n+        fail_unless!(ns1 >= ns0);\n \n         let ns2 = precise_time_ns();\n         debug!(\"ns2=%? ns\", ns0);\n-        assert ns2 >= ns1;\n+        fail_unless!(ns2 >= ns1);\n     }\n \n     pub fn test_at_utc() {\n@@ -948,18 +948,18 @@ mod tests {\n         let time = ::time::Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n-        assert utc.tm_sec == 30_i32;\n-        assert utc.tm_min == 31_i32;\n-        assert utc.tm_hour == 23_i32;\n-        assert utc.tm_mday == 13_i32;\n-        assert utc.tm_mon == 1_i32;\n-        assert utc.tm_year == 109_i32;\n-        assert utc.tm_wday == 5_i32;\n-        assert utc.tm_yday == 43_i32;\n-        assert utc.tm_isdst == 0_i32;\n-        assert utc.tm_gmtoff == 0_i32;\n-        assert utc.tm_zone == ~\"UTC\";\n-        assert utc.tm_nsec == 54321_i32;\n+        fail_unless!(utc.tm_sec == 30_i32);\n+        fail_unless!(utc.tm_min == 31_i32);\n+        fail_unless!(utc.tm_hour == 23_i32);\n+        fail_unless!(utc.tm_mday == 13_i32);\n+        fail_unless!(utc.tm_mon == 1_i32);\n+        fail_unless!(utc.tm_year == 109_i32);\n+        fail_unless!(utc.tm_wday == 5_i32);\n+        fail_unless!(utc.tm_yday == 43_i32);\n+        fail_unless!(utc.tm_isdst == 0_i32);\n+        fail_unless!(utc.tm_gmtoff == 0_i32);\n+        fail_unless!(utc.tm_zone == ~\"UTC\");\n+        fail_unless!(utc.tm_nsec == 54321_i32);\n     }\n \n     pub fn test_at() {\n@@ -971,23 +971,23 @@ mod tests {\n \n         error!(\"time_at: %?\", local);\n \n-        assert local.tm_sec == 30_i32;\n-        assert local.tm_min == 31_i32;\n-        assert local.tm_hour == 15_i32;\n-        assert local.tm_mday == 13_i32;\n-        assert local.tm_mon == 1_i32;\n-        assert local.tm_year == 109_i32;\n-        assert local.tm_wday == 5_i32;\n-        assert local.tm_yday == 43_i32;\n-        assert local.tm_isdst == 0_i32;\n-        assert local.tm_gmtoff == -28800_i32;\n+        fail_unless!(local.tm_sec == 30_i32);\n+        fail_unless!(local.tm_min == 31_i32);\n+        fail_unless!(local.tm_hour == 15_i32);\n+        fail_unless!(local.tm_mday == 13_i32);\n+        fail_unless!(local.tm_mon == 1_i32);\n+        fail_unless!(local.tm_year == 109_i32);\n+        fail_unless!(local.tm_wday == 5_i32);\n+        fail_unless!(local.tm_yday == 43_i32);\n+        fail_unless!(local.tm_isdst == 0_i32);\n+        fail_unless!(local.tm_gmtoff == -28800_i32);\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = &local.tm_zone;\n-        assert *zone == ~\"PST\" || *zone == ~\"Pacific Standard Time\";\n+        fail_unless!(*zone == ~\"PST\" || *zone == ~\"Pacific Standard Time\");\n \n-        assert local.tm_nsec == 54321_i32;\n+        fail_unless!(local.tm_nsec == 54321_i32);\n     }\n \n     pub fn test_to_timespec() {\n@@ -997,8 +997,8 @@ mod tests {\n         let time = ::time::Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n \n-        assert utc.to_timespec() == time;\n-        assert utc.to_local().to_timespec() == time;\n+        fail_unless!(utc.to_timespec() == time);\n+        fail_unless!(utc.to_local().to_timespec() == time);\n     }\n \n     pub fn test_conversions() {\n@@ -1009,12 +1009,12 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert local.to_local() == local;\n-        assert local.to_utc() == utc;\n-        assert local.to_utc().to_local() == local;\n-        assert utc.to_utc() == utc;\n-        assert utc.to_local() == local;\n-        assert utc.to_local().to_utc() == utc;\n+        fail_unless!(local.to_local() == local);\n+        fail_unless!(local.to_utc() == utc);\n+        fail_unless!(local.to_utc().to_local() == local);\n+        fail_unless!(utc.to_utc() == utc);\n+        fail_unless!(utc.to_local() == local);\n+        fail_unless!(utc.to_local().to_utc() == utc);\n     }\n \n     pub fn test_strptime() {\n@@ -1023,41 +1023,41 @@ mod tests {\n \n         match strptime(~\"\", ~\"\") {\n           Ok(ref tm) => {\n-            assert tm.tm_sec == 0_i32;\n-            assert tm.tm_min == 0_i32;\n-            assert tm.tm_hour == 0_i32;\n-            assert tm.tm_mday == 0_i32;\n-            assert tm.tm_mon == 0_i32;\n-            assert tm.tm_year == 0_i32;\n-            assert tm.tm_wday == 0_i32;\n-            assert tm.tm_isdst== 0_i32;\n-            assert tm.tm_gmtoff == 0_i32;\n-            assert tm.tm_zone == ~\"\";\n-            assert tm.tm_nsec == 0_i32;\n+            fail_unless!(tm.tm_sec == 0_i32);\n+            fail_unless!(tm.tm_min == 0_i32);\n+            fail_unless!(tm.tm_hour == 0_i32);\n+            fail_unless!(tm.tm_mday == 0_i32);\n+            fail_unless!(tm.tm_mon == 0_i32);\n+            fail_unless!(tm.tm_year == 0_i32);\n+            fail_unless!(tm.tm_wday == 0_i32);\n+            fail_unless!(tm.tm_isdst== 0_i32);\n+            fail_unless!(tm.tm_gmtoff == 0_i32);\n+            fail_unless!(tm.tm_zone == ~\"\");\n+            fail_unless!(tm.tm_nsec == 0_i32);\n           }\n           Err(_) => ()\n         }\n \n         let format = ~\"%a %b %e %T %Y\";\n-        assert strptime(~\"\", format) == Err(~\"Invalid time\");\n-        assert strptime(~\"Fri Feb 13 15:31:30\", format)\n-            == Err(~\"Invalid time\");\n+        fail_unless!(strptime(~\"\", format) == Err(~\"Invalid time\"));\n+        fail_unless!(strptime(~\"Fri Feb 13 15:31:30\", format)\n+            == Err(~\"Invalid time\"));\n \n         match strptime(~\"Fri Feb 13 15:31:30 2009\", format) {\n           Err(copy e) => fail!(e),\n           Ok(ref tm) => {\n-            assert tm.tm_sec == 30_i32;\n-            assert tm.tm_min == 31_i32;\n-            assert tm.tm_hour == 15_i32;\n-            assert tm.tm_mday == 13_i32;\n-            assert tm.tm_mon == 1_i32;\n-            assert tm.tm_year == 109_i32;\n-            assert tm.tm_wday == 5_i32;\n-            assert tm.tm_yday == 0_i32;\n-            assert tm.tm_isdst == 0_i32;\n-            assert tm.tm_gmtoff == 0_i32;\n-            assert tm.tm_zone == ~\"\";\n-            assert tm.tm_nsec == 0_i32;\n+            fail_unless!(tm.tm_sec == 30_i32);\n+            fail_unless!(tm.tm_min == 31_i32);\n+            fail_unless!(tm.tm_hour == 15_i32);\n+            fail_unless!(tm.tm_mday == 13_i32);\n+            fail_unless!(tm.tm_mon == 1_i32);\n+            fail_unless!(tm.tm_year == 109_i32);\n+            fail_unless!(tm.tm_wday == 5_i32);\n+            fail_unless!(tm.tm_yday == 0_i32);\n+            fail_unless!(tm.tm_isdst == 0_i32);\n+            fail_unless!(tm.tm_gmtoff == 0_i32);\n+            fail_unless!(tm.tm_zone == ~\"\");\n+            fail_unless!(tm.tm_nsec == 0_i32);\n           }\n         }\n \n@@ -1077,7 +1077,7 @@ mod tests {\n             ~\"Friday\",\n             ~\"Saturday\"\n         ]) |day| {\n-            assert test(*day, ~\"%A\");\n+            fail_unless!(test(*day, ~\"%A\"));\n         }\n \n         for vec::each([\n@@ -1089,7 +1089,7 @@ mod tests {\n             ~\"Fri\",\n             ~\"Sat\"\n         ]) |day| {\n-            assert test(*day, ~\"%a\");\n+            fail_unless!(test(*day, ~\"%a\"));\n         }\n \n         for vec::each([\n@@ -1106,7 +1106,7 @@ mod tests {\n             ~\"November\",\n             ~\"December\"\n         ]) |day| {\n-            assert test(*day, ~\"%B\");\n+            fail_unless!(test(*day, ~\"%B\"));\n         }\n \n         for vec::each([\n@@ -1123,52 +1123,52 @@ mod tests {\n             ~\"Nov\",\n             ~\"Dec\"\n         ]) |day| {\n-            assert test(*day, ~\"%b\");\n+            fail_unless!(test(*day, ~\"%b\"));\n         }\n \n-        assert test(~\"19\", ~\"%C\");\n-        assert test(~\"Fri Feb 13 23:31:30 2009\", ~\"%c\");\n-        assert test(~\"02/13/09\", ~\"%D\");\n-        assert test(~\"03\", ~\"%d\");\n-        assert test(~\"13\", ~\"%d\");\n-        assert test(~\" 3\", ~\"%e\");\n-        assert test(~\"13\", ~\"%e\");\n-        assert test(~\"2009-02-13\", ~\"%F\");\n-        assert test(~\"03\", ~\"%H\");\n-        assert test(~\"13\", ~\"%H\");\n-        assert test(~\"03\", ~\"%I\"); // FIXME (#2350): flesh out\n-        assert test(~\"11\", ~\"%I\"); // FIXME (#2350): flesh out\n-        assert test(~\"044\", ~\"%j\");\n-        assert test(~\" 3\", ~\"%k\");\n-        assert test(~\"13\", ~\"%k\");\n-        assert test(~\" 1\", ~\"%l\");\n-        assert test(~\"11\", ~\"%l\");\n-        assert test(~\"03\", ~\"%M\");\n-        assert test(~\"13\", ~\"%M\");\n-        assert test(~\"\\n\", ~\"%n\");\n-        assert test(~\"am\", ~\"%P\");\n-        assert test(~\"pm\", ~\"%P\");\n-        assert test(~\"AM\", ~\"%p\");\n-        assert test(~\"PM\", ~\"%p\");\n-        assert test(~\"23:31\", ~\"%R\");\n-        assert test(~\"11:31:30 AM\", ~\"%r\");\n-        assert test(~\"11:31:30 PM\", ~\"%r\");\n-        assert test(~\"03\", ~\"%S\");\n-        assert test(~\"13\", ~\"%S\");\n-        assert test(~\"15:31:30\", ~\"%T\");\n-        assert test(~\"\\t\", ~\"%t\");\n-        assert test(~\"1\", ~\"%u\");\n-        assert test(~\"7\", ~\"%u\");\n-        assert test(~\"13-Feb-2009\", ~\"%v\");\n-        assert test(~\"0\", ~\"%w\");\n-        assert test(~\"6\", ~\"%w\");\n-        assert test(~\"2009\", ~\"%Y\");\n-        assert test(~\"09\", ~\"%y\");\n-        assert result::unwrap(strptime(~\"UTC\", ~\"%Z\")).tm_zone == ~\"UTC\";\n-        assert result::unwrap(strptime(~\"PST\", ~\"%Z\")).tm_zone == ~\"\";\n-        assert result::unwrap(strptime(~\"-0000\", ~\"%z\")).tm_gmtoff == 0;\n-        assert result::unwrap(strptime(~\"-0800\", ~\"%z\")).tm_gmtoff == 0;\n-        assert test(~\"%\", ~\"%%\");\n+        fail_unless!(test(~\"19\", ~\"%C\"));\n+        fail_unless!(test(~\"Fri Feb 13 23:31:30 2009\", ~\"%c\"));\n+        fail_unless!(test(~\"02/13/09\", ~\"%D\"));\n+        fail_unless!(test(~\"03\", ~\"%d\"));\n+        fail_unless!(test(~\"13\", ~\"%d\"));\n+        fail_unless!(test(~\" 3\", ~\"%e\"));\n+        fail_unless!(test(~\"13\", ~\"%e\"));\n+        fail_unless!(test(~\"2009-02-13\", ~\"%F\"));\n+        fail_unless!(test(~\"03\", ~\"%H\"));\n+        fail_unless!(test(~\"13\", ~\"%H\"));\n+        fail_unless!(test(~\"03\", ~\"%I\")); // FIXME (#2350): flesh out\n+        fail_unless!(test(~\"11\", ~\"%I\")); // FIXME (#2350): flesh out\n+        fail_unless!(test(~\"044\", ~\"%j\"));\n+        fail_unless!(test(~\" 3\", ~\"%k\"));\n+        fail_unless!(test(~\"13\", ~\"%k\"));\n+        fail_unless!(test(~\" 1\", ~\"%l\"));\n+        fail_unless!(test(~\"11\", ~\"%l\"));\n+        fail_unless!(test(~\"03\", ~\"%M\"));\n+        fail_unless!(test(~\"13\", ~\"%M\"));\n+        fail_unless!(test(~\"\\n\", ~\"%n\"));\n+        fail_unless!(test(~\"am\", ~\"%P\"));\n+        fail_unless!(test(~\"pm\", ~\"%P\"));\n+        fail_unless!(test(~\"AM\", ~\"%p\"));\n+        fail_unless!(test(~\"PM\", ~\"%p\"));\n+        fail_unless!(test(~\"23:31\", ~\"%R\"));\n+        fail_unless!(test(~\"11:31:30 AM\", ~\"%r\"));\n+        fail_unless!(test(~\"11:31:30 PM\", ~\"%r\"));\n+        fail_unless!(test(~\"03\", ~\"%S\"));\n+        fail_unless!(test(~\"13\", ~\"%S\"));\n+        fail_unless!(test(~\"15:31:30\", ~\"%T\"));\n+        fail_unless!(test(~\"\\t\", ~\"%t\"));\n+        fail_unless!(test(~\"1\", ~\"%u\"));\n+        fail_unless!(test(~\"7\", ~\"%u\"));\n+        fail_unless!(test(~\"13-Feb-2009\", ~\"%v\"));\n+        fail_unless!(test(~\"0\", ~\"%w\"));\n+        fail_unless!(test(~\"6\", ~\"%w\"));\n+        fail_unless!(test(~\"2009\", ~\"%Y\"));\n+        fail_unless!(test(~\"09\", ~\"%y\"));\n+        fail_unless!(result::unwrap(strptime(~\"UTC\", ~\"%Z\")).tm_zone == ~\"UTC\");\n+        fail_unless!(result::unwrap(strptime(~\"PST\", ~\"%Z\")).tm_zone == ~\"\");\n+        fail_unless!(result::unwrap(strptime(~\"-0000\", ~\"%z\")).tm_gmtoff == 0);\n+        fail_unless!(result::unwrap(strptime(~\"-0800\", ~\"%z\")).tm_gmtoff == 0);\n+        fail_unless!(test(~\"%\", ~\"%%\"));\n     }\n \n     pub fn test_ctime() {\n@@ -1181,8 +1181,8 @@ mod tests {\n \n         error!(\"test_ctime: %? %?\", utc.ctime(), local.ctime());\n \n-        assert utc.ctime()   == ~\"Fri Feb 13 23:31:30 2009\";\n-        assert local.ctime() == ~\"Fri Feb 13 15:31:30 2009\";\n+        fail_unless!(utc.ctime()   == ~\"Fri Feb 13 23:31:30 2009\");\n+        fail_unless!(local.ctime() == ~\"Fri Feb 13 15:31:30 2009\");\n     }\n \n     pub fn test_strftime() {\n@@ -1193,69 +1193,69 @@ mod tests {\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert local.strftime(~\"\") == ~\"\";\n-        assert local.strftime(~\"%A\") == ~\"Friday\";\n-        assert local.strftime(~\"%a\") == ~\"Fri\";\n-        assert local.strftime(~\"%B\") == ~\"February\";\n-        assert local.strftime(~\"%b\") == ~\"Feb\";\n-        assert local.strftime(~\"%C\") == ~\"20\";\n-        assert local.strftime(~\"%c\") == ~\"Fri Feb 13 15:31:30 2009\";\n-        assert local.strftime(~\"%D\") == ~\"02/13/09\";\n-        assert local.strftime(~\"%d\") == ~\"13\";\n-        assert local.strftime(~\"%e\") == ~\"13\";\n-        assert local.strftime(~\"%F\") == ~\"2009-02-13\";\n-        // assert local.strftime(\"%G\") == \"2009\";\n-        // assert local.strftime(\"%g\") == \"09\";\n-        assert local.strftime(~\"%H\") == ~\"15\";\n-        assert local.strftime(~\"%I\") == ~\"03\";\n-        assert local.strftime(~\"%j\") == ~\"044\";\n-        assert local.strftime(~\"%k\") == ~\"15\";\n-        assert local.strftime(~\"%l\") == ~\" 3\";\n-        assert local.strftime(~\"%M\") == ~\"31\";\n-        assert local.strftime(~\"%m\") == ~\"02\";\n-        assert local.strftime(~\"%n\") == ~\"\\n\";\n-        assert local.strftime(~\"%P\") == ~\"pm\";\n-        assert local.strftime(~\"%p\") == ~\"PM\";\n-        assert local.strftime(~\"%R\") == ~\"15:31\";\n-        assert local.strftime(~\"%r\") == ~\"03:31:30 PM\";\n-        assert local.strftime(~\"%S\") == ~\"30\";\n-        assert local.strftime(~\"%s\") == ~\"1234567890\";\n-        assert local.strftime(~\"%T\") == ~\"15:31:30\";\n-        assert local.strftime(~\"%t\") == ~\"\\t\";\n-        // assert local.strftime(\"%U\") == \"06\";\n-        assert local.strftime(~\"%u\") == ~\"5\";\n-        // assert local.strftime(\"%V\") == \"07\";\n-        assert local.strftime(~\"%v\") == ~\"13-Feb-2009\";\n-        // assert local.strftime(\"%W\") == \"06\";\n-        assert local.strftime(~\"%w\") == ~\"5\";\n+        fail_unless!(local.strftime(~\"\") == ~\"\");\n+        fail_unless!(local.strftime(~\"%A\") == ~\"Friday\");\n+        fail_unless!(local.strftime(~\"%a\") == ~\"Fri\");\n+        fail_unless!(local.strftime(~\"%B\") == ~\"February\");\n+        fail_unless!(local.strftime(~\"%b\") == ~\"Feb\");\n+        fail_unless!(local.strftime(~\"%C\") == ~\"20\");\n+        fail_unless!(local.strftime(~\"%c\") == ~\"Fri Feb 13 15:31:30 2009\");\n+        fail_unless!(local.strftime(~\"%D\") == ~\"02/13/09\");\n+        fail_unless!(local.strftime(~\"%d\") == ~\"13\");\n+        fail_unless!(local.strftime(~\"%e\") == ~\"13\");\n+        fail_unless!(local.strftime(~\"%F\") == ~\"2009-02-13\");\n+        // fail_unless!(local.strftime(\"%G\") == \"2009\");\n+        // fail_unless!(local.strftime(\"%g\") == \"09\");\n+        fail_unless!(local.strftime(~\"%H\") == ~\"15\");\n+        fail_unless!(local.strftime(~\"%I\") == ~\"03\");\n+        fail_unless!(local.strftime(~\"%j\") == ~\"044\");\n+        fail_unless!(local.strftime(~\"%k\") == ~\"15\");\n+        fail_unless!(local.strftime(~\"%l\") == ~\" 3\");\n+        fail_unless!(local.strftime(~\"%M\") == ~\"31\");\n+        fail_unless!(local.strftime(~\"%m\") == ~\"02\");\n+        fail_unless!(local.strftime(~\"%n\") == ~\"\\n\");\n+        fail_unless!(local.strftime(~\"%P\") == ~\"pm\");\n+        fail_unless!(local.strftime(~\"%p\") == ~\"PM\");\n+        fail_unless!(local.strftime(~\"%R\") == ~\"15:31\");\n+        fail_unless!(local.strftime(~\"%r\") == ~\"03:31:30 PM\");\n+        fail_unless!(local.strftime(~\"%S\") == ~\"30\");\n+        fail_unless!(local.strftime(~\"%s\") == ~\"1234567890\");\n+        fail_unless!(local.strftime(~\"%T\") == ~\"15:31:30\");\n+        fail_unless!(local.strftime(~\"%t\") == ~\"\\t\");\n+        // fail_unless!(local.strftime(\"%U\") == \"06\");\n+        fail_unless!(local.strftime(~\"%u\") == ~\"5\");\n+        // fail_unless!(local.strftime(\"%V\") == \"07\");\n+        fail_unless!(local.strftime(~\"%v\") == ~\"13-Feb-2009\");\n+        // fail_unless!(local.strftime(\"%W\") == \"06\");\n+        fail_unless!(local.strftime(~\"%w\") == ~\"5\");\n         // handle \"%X\"\n         // handle \"%x\"\n-        assert local.strftime(~\"%Y\") == ~\"2009\";\n-        assert local.strftime(~\"%y\") == ~\"09\";\n+        fail_unless!(local.strftime(~\"%Y\") == ~\"2009\");\n+        fail_unless!(local.strftime(~\"%y\") == ~\"09\");\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let zone = local.strftime(~\"%Z\");\n-        assert zone == ~\"PST\" || zone == ~\"Pacific Standard Time\";\n+        fail_unless!(zone == ~\"PST\" || zone == ~\"Pacific Standard Time\");\n \n-        assert local.strftime(~\"%z\") == ~\"-0800\";\n-        assert local.strftime(~\"%%\") == ~\"%\";\n+        fail_unless!(local.strftime(~\"%z\") == ~\"-0800\");\n+        fail_unless!(local.strftime(~\"%%\") == ~\"%\");\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n         let rfc822 = local.rfc822();\n         let prefix = ~\"Fri, 13 Feb 2009 15:31:30 \";\n-        assert rfc822 == prefix + ~\"PST\" ||\n-               rfc822 == prefix + ~\"Pacific Standard Time\";\n+        fail_unless!(rfc822 == prefix + ~\"PST\" ||\n+                     rfc822 == prefix + ~\"Pacific Standard Time\");\n \n-        assert local.ctime() == ~\"Fri Feb 13 15:31:30 2009\";\n-        assert local.rfc822z() == ~\"Fri, 13 Feb 2009 15:31:30 -0800\";\n-        assert local.rfc3339() == ~\"2009-02-13T15:31:30-08:00\";\n+        fail_unless!(local.ctime() == ~\"Fri Feb 13 15:31:30 2009\");\n+        fail_unless!(local.rfc822z() == ~\"Fri, 13 Feb 2009 15:31:30 -0800\");\n+        fail_unless!(local.rfc3339() == ~\"2009-02-13T15:31:30-08:00\");\n \n-        assert utc.ctime() == ~\"Fri Feb 13 23:31:30 2009\";\n-        assert utc.rfc822() == ~\"Fri, 13 Feb 2009 23:31:30 GMT\";\n-        assert utc.rfc822z() == ~\"Fri, 13 Feb 2009 23:31:30 -0000\";\n-        assert utc.rfc3339() == ~\"2009-02-13T23:31:30Z\";\n+        fail_unless!(utc.ctime() == ~\"Fri Feb 13 23:31:30 2009\");\n+        fail_unless!(utc.rfc822() == ~\"Fri, 13 Feb 2009 23:31:30 GMT\");\n+        fail_unless!(utc.rfc822z() == ~\"Fri, 13 Feb 2009 23:31:30 -0000\");\n+        fail_unless!(utc.rfc3339() == ~\"2009-02-13T23:31:30Z\");\n     }\n \n     pub fn test_timespec_eq_ord() {\n@@ -1267,28 +1267,28 @@ mod tests {\n         let d = &Timespec::new(2, 1);\n         let e = &Timespec::new(2, 1);\n \n-        assert eq(d, e);\n-        assert ne(c, e);\n+        fail_unless!(eq(d, e));\n+        fail_unless!(ne(c, e));\n \n-        assert lt(a, b);\n-        assert lt(b, c);\n-        assert lt(c, d);\n+        fail_unless!(lt(a, b));\n+        fail_unless!(lt(b, c));\n+        fail_unless!(lt(c, d));\n \n-        assert le(a, b);\n-        assert le(b, c);\n-        assert le(c, d);\n-        assert le(d, e);\n-        assert le(e, d);\n+        fail_unless!(le(a, b));\n+        fail_unless!(le(b, c));\n+        fail_unless!(le(c, d));\n+        fail_unless!(le(d, e));\n+        fail_unless!(le(e, d));\n \n-        assert ge(b, a);\n-        assert ge(c, b);\n-        assert ge(d, c);\n-        assert ge(e, d);\n-        assert ge(d, e);\n+        fail_unless!(ge(b, a));\n+        fail_unless!(ge(c, b));\n+        fail_unless!(ge(d, c));\n+        fail_unless!(ge(e, d));\n+        fail_unless!(ge(d, e));\n \n-        assert gt(b, a);\n-        assert gt(c, b);\n-        assert gt(d, c);\n+        fail_unless!(gt(b, a));\n+        fail_unless!(gt(c, b));\n+        fail_unless!(gt(d, c));\n     }\n \n     #[test]"}, {"sha": "60469d0b0f2359ddc4ac78a395fd66084b0ea538", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -260,14 +260,14 @@ mod test {\n \n             match recv_timeout(hl_loop, 10u, &test_po) {\n               Some(val) => {\n-                assert val == expected;\n+                fail_unless!(val == expected);\n                 successes += 1;\n               }\n               _ => failures += 1\n             };\n         }\n \n-        assert successes > times / 2;\n+        fail_unless!(successes > times / 2);\n     }\n \n     #[test]\n@@ -291,6 +291,6 @@ mod test {\n             };\n         }\n \n-        assert successes > times / 2;\n+        fail_unless!(successes > times / 2);\n     }\n }"}, {"sha": "878696a9a909b50d0ffc7dced4f6a116a7c9b38f", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 214, "deletions": 214, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -697,39 +697,39 @@ mod test_treemap {\n \n     #[test]\n     fn find_empty() {\n-        let m = TreeMap::new::<int, int>(); assert m.find(&5) == None;\n+        let m = TreeMap::new::<int, int>(); fail_unless!(m.find(&5) == None);\n     }\n \n     #[test]\n     fn find_not_found() {\n         let mut m = TreeMap::new();\n-        assert m.insert(1, 2);\n-        assert m.insert(5, 3);\n-        assert m.insert(9, 3);\n-        assert m.find(&2) == None;\n+        fail_unless!(m.insert(1, 2));\n+        fail_unless!(m.insert(5, 3));\n+        fail_unless!(m.insert(9, 3));\n+        fail_unless!(m.find(&2) == None);\n     }\n \n     #[test]\n     fn insert_replace() {\n         let mut m = TreeMap::new();\n-        assert m.insert(5, 2);\n-        assert m.insert(2, 9);\n-        assert !m.insert(2, 11);\n-        assert m.find(&2).unwrap() == &11;\n+        fail_unless!(m.insert(5, 2));\n+        fail_unless!(m.insert(2, 9));\n+        fail_unless!(!m.insert(2, 11));\n+        fail_unless!(m.find(&2).unwrap() == &11);\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut m = TreeMap::new();\n         m.clear();\n-        assert m.insert(5, 11);\n-        assert m.insert(12, -3);\n-        assert m.insert(19, 2);\n+        fail_unless!(m.insert(5, 11));\n+        fail_unless!(m.insert(12, -3));\n+        fail_unless!(m.insert(19, 2));\n         m.clear();\n-        assert m.find(&5).is_none();\n-        assert m.find(&12).is_none();\n-        assert m.find(&19).is_none();\n-        assert m.is_empty();\n+        fail_unless!(m.find(&5).is_none());\n+        fail_unless!(m.find(&12).is_none());\n+        fail_unless!(m.find(&19).is_none());\n+        fail_unless!(m.is_empty());\n     }\n \n     #[test]\n@@ -744,41 +744,41 @@ mod test_treemap {\n         m.insert(copy k1, copy v1);\n         m.insert(copy k2, copy v2);\n \n-        assert m.find(&k2) == Some(&v2);\n-        assert m.find(&k1) == Some(&v1);\n+        fail_unless!(m.find(&k2) == Some(&v2));\n+        fail_unless!(m.find(&k1) == Some(&v1));\n     }\n \n     fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n-        assert ctrl.is_empty() == map.is_empty();\n+        fail_unless!(ctrl.is_empty() == map.is_empty());\n         for ctrl.each |x| {\n             let &(k, v) = x;\n-            assert map.find(&k).unwrap() == &v\n+            fail_unless!(map.find(&k).unwrap() == &v)\n         }\n         for map.each |&(map_k, map_v)| {\n             let mut found = false;\n             for ctrl.each |x| {\n                 let &(ctrl_k, ctrl_v) = x;\n                 if *map_k == ctrl_k {\n-                    assert *map_v == ctrl_v;\n+                    fail_unless!(*map_v == ctrl_v);\n                     found = true;\n                     break;\n                 }\n             }\n-            assert found;\n+            fail_unless!(found);\n         }\n     }\n \n     fn check_left<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,\n                                   parent: &~TreeNode<K, V>) {\n         match *node {\n           Some(ref r) => {\n-            assert r.key.cmp(&parent.key) == Less;\n-            assert r.level == parent.level - 1; // left is black\n+            fail_unless!(r.key.cmp(&parent.key) == Less);\n+            fail_unless!(r.level == parent.level - 1); // left is black\n             check_left(&r.left, r);\n             check_right(&r.right, r, false);\n           }\n-          None => assert parent.level == 1 // parent is leaf\n+          None => fail_unless!(parent.level == 1) // parent is leaf\n         }\n     }\n \n@@ -787,14 +787,14 @@ mod test_treemap {\n                                    parent_red: bool) {\n         match *node {\n           Some(ref r) => {\n-            assert r.key.cmp(&parent.key) == Greater;\n+            fail_unless!(r.key.cmp(&parent.key) == Greater);\n             let red = r.level == parent.level;\n-            if parent_red { assert !red } // no dual horizontal links\n-            assert red || r.level == parent.level - 1; // right red or black\n+            if parent_red { fail_unless!(!red) } // no dual horizontal links\n+            fail_unless!(red || r.level == parent.level - 1); // right red or black\n             check_left(&r.left, r);\n             check_right(&r.right, r, red);\n           }\n-          None => assert parent.level == 1 // parent is leaf\n+          None => fail_unless!(parent.level == 1) // parent is leaf\n         }\n     }\n \n@@ -814,7 +814,7 @@ mod test_treemap {\n         let mut ctrl = ~[];\n \n         check_equal(ctrl, &map);\n-        assert map.find(&5).is_none();\n+        fail_unless!(map.find(&5).is_none());\n \n         let rng = rand::seeded_rng(&[42]);\n \n@@ -823,7 +823,7 @@ mod test_treemap {\n                 let k = rng.gen_int();\n                 let v = rng.gen_int();\n                 if !ctrl.contains(&(k, v)) {\n-                    assert map.insert(k, v);\n+                    fail_unless!(map.insert(k, v));\n                     ctrl.push((k, v));\n                     check_structure(&map);\n                     check_equal(ctrl, &map);\n@@ -833,7 +833,7 @@ mod test_treemap {\n             for 30.times {\n                 let r = rng.gen_uint_range(0, ctrl.len());\n                 let (key, _) = vec::remove(&mut ctrl, r);\n-                assert map.remove(&key);\n+                fail_unless!(map.remove(&key));\n                 check_structure(&map);\n                 check_equal(ctrl, &map);\n             }\n@@ -843,36 +843,36 @@ mod test_treemap {\n     #[test]\n     fn test_len() {\n         let mut m = TreeMap::new();\n-        assert m.insert(3, 6);\n-        assert m.len() == 1;\n-        assert m.insert(0, 0);\n-        assert m.len() == 2;\n-        assert m.insert(4, 8);\n-        assert m.len() == 3;\n-        assert m.remove(&3);\n-        assert m.len() == 2;\n-        assert !m.remove(&5);\n-        assert m.len() == 2;\n-        assert m.insert(2, 4);\n-        assert m.len() == 3;\n-        assert m.insert(1, 2);\n-        assert m.len() == 4;\n+        fail_unless!(m.insert(3, 6));\n+        fail_unless!(m.len() == 1);\n+        fail_unless!(m.insert(0, 0));\n+        fail_unless!(m.len() == 2);\n+        fail_unless!(m.insert(4, 8));\n+        fail_unless!(m.len() == 3);\n+        fail_unless!(m.remove(&3));\n+        fail_unless!(m.len() == 2);\n+        fail_unless!(!m.remove(&5));\n+        fail_unless!(m.len() == 2);\n+        fail_unless!(m.insert(2, 4));\n+        fail_unless!(m.len() == 3);\n+        fail_unless!(m.insert(1, 2));\n+        fail_unless!(m.len() == 4);\n     }\n \n     #[test]\n     fn test_each() {\n         let mut m = TreeMap::new();\n \n-        assert m.insert(3, 6);\n-        assert m.insert(0, 0);\n-        assert m.insert(4, 8);\n-        assert m.insert(2, 4);\n-        assert m.insert(1, 2);\n+        fail_unless!(m.insert(3, 6));\n+        fail_unless!(m.insert(0, 0));\n+        fail_unless!(m.insert(4, 8));\n+        fail_unless!(m.insert(2, 4));\n+        fail_unless!(m.insert(1, 2));\n \n         let mut n = 0;\n         for m.each |&(k, v)| {\n-            assert *k == n;\n-            assert *v == n * 2;\n+            fail_unless!(*k == n);\n+            fail_unless!(*v == n * 2);\n             n += 1;\n         }\n     }\n@@ -881,16 +881,16 @@ mod test_treemap {\n     fn test_each_reverse() {\n         let mut m = TreeMap::new();\n \n-        assert m.insert(3, 6);\n-        assert m.insert(0, 0);\n-        assert m.insert(4, 8);\n-        assert m.insert(2, 4);\n-        assert m.insert(1, 2);\n+        fail_unless!(m.insert(3, 6));\n+        fail_unless!(m.insert(0, 0));\n+        fail_unless!(m.insert(4, 8));\n+        fail_unless!(m.insert(2, 4));\n+        fail_unless!(m.insert(1, 2));\n \n         let mut n = 4;\n         for m.each_reverse |&(k, v)| {\n-            assert *k == n;\n-            assert *v == n * 2;\n+            fail_unless!(*k == n);\n+            fail_unless!(*v == n * 2);\n             n -= 1;\n         }\n     }\n@@ -900,49 +900,49 @@ mod test_treemap {\n         let mut a = TreeMap::new();\n         let mut b = TreeMap::new();\n \n-        assert a == b;\n-        assert a.insert(0, 5);\n-        assert a != b;\n-        assert b.insert(0, 4);\n-        assert a != b;\n-        assert a.insert(5, 19);\n-        assert a != b;\n-        assert !b.insert(0, 5);\n-        assert a != b;\n-        assert b.insert(5, 19);\n-        assert a == b;\n+        fail_unless!(a == b);\n+        fail_unless!(a.insert(0, 5));\n+        fail_unless!(a != b);\n+        fail_unless!(b.insert(0, 4));\n+        fail_unless!(a != b);\n+        fail_unless!(a.insert(5, 19));\n+        fail_unless!(a != b);\n+        fail_unless!(!b.insert(0, 5));\n+        fail_unless!(a != b);\n+        fail_unless!(b.insert(5, 19));\n+        fail_unless!(a == b);\n     }\n \n     #[test]\n     fn test_lt() {\n         let mut a = TreeMap::new();\n         let mut b = TreeMap::new();\n \n-        assert !(a < b) && !(b < a);\n-        assert b.insert(0, 5);\n-        assert a < b;\n-        assert a.insert(0, 7);\n-        assert !(a < b) && !(b < a);\n-        assert b.insert(-2, 0);\n-        assert b < a;\n-        assert a.insert(-5, 2);\n-        assert a < b;\n-        assert a.insert(6, 2);\n-        assert a < b && !(b < a);\n+        fail_unless!(!(a < b) && !(b < a));\n+        fail_unless!(b.insert(0, 5));\n+        fail_unless!(a < b);\n+        fail_unless!(a.insert(0, 7));\n+        fail_unless!(!(a < b) && !(b < a));\n+        fail_unless!(b.insert(-2, 0));\n+        fail_unless!(b < a);\n+        fail_unless!(a.insert(-5, 2));\n+        fail_unless!(a < b);\n+        fail_unless!(a.insert(6, 2));\n+        fail_unless!(a < b && !(b < a));\n     }\n \n     #[test]\n     fn test_ord() {\n         let mut a = TreeMap::new();\n         let mut b = TreeMap::new();\n \n-        assert a <= b && a >= b;\n-        assert a.insert(1, 1);\n-        assert a > b && a >= b;\n-        assert b < a && b <= a;\n-        assert b.insert(2, 2);\n-        assert b > a && b >= a;\n-        assert a < b && a <= b;\n+        fail_unless!(a <= b && a >= b);\n+        fail_unless!(a.insert(1, 1));\n+        fail_unless!(a > b && a >= b);\n+        fail_unless!(b < a && b <= a);\n+        fail_unless!(b.insert(2, 2));\n+        fail_unless!(b > a && b >= a);\n+        fail_unless!(a < b && a <= b);\n     }\n \n     #[test]\n@@ -954,24 +954,24 @@ mod test_treemap {\n         let (x4, y4) = (29, 5);\n         let (x5, y5) = (103, 3);\n \n-        assert m.insert(x1, y1);\n-        assert m.insert(x2, y2);\n-        assert m.insert(x3, y3);\n-        assert m.insert(x4, y4);\n-        assert m.insert(x5, y5);\n+        fail_unless!(m.insert(x1, y1));\n+        fail_unless!(m.insert(x2, y2));\n+        fail_unless!(m.insert(x3, y3));\n+        fail_unless!(m.insert(x4, y4));\n+        fail_unless!(m.insert(x5, y5));\n \n         let m = m;\n         let mut a = m.iter();\n \n         // FIXME: #4492 (ICE): iter.get() == Some((&x1, &y1))\n \n-        assert map_next(&mut a).unwrap() == (&x1, &y1);\n-        assert map_next(&mut a).unwrap() == (&x2, &y2);\n-        assert map_next(&mut a).unwrap() == (&x3, &y3);\n-        assert map_next(&mut a).unwrap() == (&x4, &y4);\n-        assert map_next(&mut a).unwrap() == (&x5, &y5);\n+        fail_unless!(map_next(&mut a).unwrap() == (&x1, &y1));\n+        fail_unless!(map_next(&mut a).unwrap() == (&x2, &y2));\n+        fail_unless!(map_next(&mut a).unwrap() == (&x3, &y3));\n+        fail_unless!(map_next(&mut a).unwrap() == (&x4, &y4));\n+        fail_unless!(map_next(&mut a).unwrap() == (&x5, &y5));\n \n-        assert map_next(&mut a).is_none();\n+        fail_unless!(map_next(&mut a).is_none());\n \n         let mut b = m.iter();\n \n@@ -980,7 +980,7 @@ mod test_treemap {\n         let mut i = 0;\n \n         for map_advance(&mut b) |x| {\n-            assert expected[i] == x;\n+            fail_unless!(expected[i] == x);\n             i += 1;\n \n             if i == 2 {\n@@ -989,7 +989,7 @@ mod test_treemap {\n         }\n \n         for map_advance(&mut b) |x| {\n-            assert expected[i] == x;\n+            fail_unless!(expected[i] == x);\n             i += 1;\n         }\n     }\n@@ -1003,80 +1003,80 @@ mod test_set {\n     fn test_clear() {\n         let mut s = TreeSet::new();\n         s.clear();\n-        assert s.insert(5);\n-        assert s.insert(12);\n-        assert s.insert(19);\n+        fail_unless!(s.insert(5));\n+        fail_unless!(s.insert(12));\n+        fail_unless!(s.insert(19));\n         s.clear();\n-        assert !s.contains(&5);\n-        assert !s.contains(&12);\n-        assert !s.contains(&19);\n-        assert s.is_empty();\n+        fail_unless!(!s.contains(&5));\n+        fail_unless!(!s.contains(&12));\n+        fail_unless!(!s.contains(&19));\n+        fail_unless!(s.is_empty());\n     }\n \n     #[test]\n     fn test_disjoint() {\n         let mut xs = TreeSet::new();\n         let mut ys = TreeSet::new();\n-        assert xs.is_disjoint(&ys);\n-        assert ys.is_disjoint(&xs);\n-        assert xs.insert(5);\n-        assert ys.insert(11);\n-        assert xs.is_disjoint(&ys);\n-        assert ys.is_disjoint(&xs);\n-        assert xs.insert(7);\n-        assert xs.insert(19);\n-        assert xs.insert(4);\n-        assert ys.insert(2);\n-        assert ys.insert(-11);\n-        assert xs.is_disjoint(&ys);\n-        assert ys.is_disjoint(&xs);\n-        assert ys.insert(7);\n-        assert !xs.is_disjoint(&ys);\n-        assert !ys.is_disjoint(&xs);\n+        fail_unless!(xs.is_disjoint(&ys));\n+        fail_unless!(ys.is_disjoint(&xs));\n+        fail_unless!(xs.insert(5));\n+        fail_unless!(ys.insert(11));\n+        fail_unless!(xs.is_disjoint(&ys));\n+        fail_unless!(ys.is_disjoint(&xs));\n+        fail_unless!(xs.insert(7));\n+        fail_unless!(xs.insert(19));\n+        fail_unless!(xs.insert(4));\n+        fail_unless!(ys.insert(2));\n+        fail_unless!(ys.insert(-11));\n+        fail_unless!(xs.is_disjoint(&ys));\n+        fail_unless!(ys.is_disjoint(&xs));\n+        fail_unless!(ys.insert(7));\n+        fail_unless!(!xs.is_disjoint(&ys));\n+        fail_unless!(!ys.is_disjoint(&xs));\n     }\n \n     #[test]\n     fn test_subset_and_superset() {\n         let mut a = TreeSet::new();\n-        assert a.insert(0);\n-        assert a.insert(5);\n-        assert a.insert(11);\n-        assert a.insert(7);\n+        fail_unless!(a.insert(0));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(11));\n+        fail_unless!(a.insert(7));\n \n         let mut b = TreeSet::new();\n-        assert b.insert(0);\n-        assert b.insert(7);\n-        assert b.insert(19);\n-        assert b.insert(250);\n-        assert b.insert(11);\n-        assert b.insert(200);\n-\n-        assert !a.is_subset(&b);\n-        assert !a.is_superset(&b);\n-        assert !b.is_subset(&a);\n-        assert !b.is_superset(&a);\n-\n-        assert b.insert(5);\n-\n-        assert a.is_subset(&b);\n-        assert !a.is_superset(&b);\n-        assert !b.is_subset(&a);\n-        assert b.is_superset(&a);\n+        fail_unless!(b.insert(0));\n+        fail_unless!(b.insert(7));\n+        fail_unless!(b.insert(19));\n+        fail_unless!(b.insert(250));\n+        fail_unless!(b.insert(11));\n+        fail_unless!(b.insert(200));\n+\n+        fail_unless!(!a.is_subset(&b));\n+        fail_unless!(!a.is_superset(&b));\n+        fail_unless!(!b.is_subset(&a));\n+        fail_unless!(!b.is_superset(&a));\n+\n+        fail_unless!(b.insert(5));\n+\n+        fail_unless!(a.is_subset(&b));\n+        fail_unless!(!a.is_superset(&b));\n+        fail_unless!(!b.is_subset(&a));\n+        fail_unless!(b.is_superset(&a));\n     }\n \n     #[test]\n     fn test_each() {\n         let mut m = TreeSet::new();\n \n-        assert m.insert(3);\n-        assert m.insert(0);\n-        assert m.insert(4);\n-        assert m.insert(2);\n-        assert m.insert(1);\n+        fail_unless!(m.insert(3));\n+        fail_unless!(m.insert(0));\n+        fail_unless!(m.insert(4));\n+        fail_unless!(m.insert(2));\n+        fail_unless!(m.insert(1));\n \n         let mut n = 0;\n         for m.each |x| {\n-            assert *x == n;\n+            fail_unless!(*x == n);\n             n += 1\n         }\n     }\n@@ -1085,15 +1085,15 @@ mod test_set {\n     fn test_each_reverse() {\n         let mut m = TreeSet::new();\n \n-        assert m.insert(3);\n-        assert m.insert(0);\n-        assert m.insert(4);\n-        assert m.insert(2);\n-        assert m.insert(1);\n+        fail_unless!(m.insert(3));\n+        fail_unless!(m.insert(0));\n+        fail_unless!(m.insert(4));\n+        fail_unless!(m.insert(2));\n+        fail_unless!(m.insert(1));\n \n         let mut n = 4;\n         for m.each_reverse |x| {\n-            assert *x == n;\n+            fail_unless!(*x == n);\n             n -= 1\n         }\n     }\n@@ -1103,107 +1103,107 @@ mod test_set {\n         let mut a = TreeSet::new();\n         let mut b = TreeSet::new();\n \n-        assert a.insert(11);\n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(77);\n-        assert a.insert(103);\n-        assert a.insert(5);\n-        assert a.insert(-5);\n-\n-        assert b.insert(2);\n-        assert b.insert(11);\n-        assert b.insert(77);\n-        assert b.insert(-9);\n-        assert b.insert(-42);\n-        assert b.insert(5);\n-        assert b.insert(3);\n+        fail_unless!(a.insert(11));\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(77));\n+        fail_unless!(a.insert(103));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(-5));\n+\n+        fail_unless!(b.insert(2));\n+        fail_unless!(b.insert(11));\n+        fail_unless!(b.insert(77));\n+        fail_unless!(b.insert(-9));\n+        fail_unless!(b.insert(-42));\n+        fail_unless!(b.insert(5));\n+        fail_unless!(b.insert(3));\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n         for a.intersection(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     fn test_difference() {\n         let mut a = TreeSet::new();\n         let mut b = TreeSet::new();\n \n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(9);\n-        assert a.insert(11);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(9));\n+        fail_unless!(a.insert(11));\n \n-        assert b.insert(3);\n-        assert b.insert(9);\n+        fail_unless!(b.insert(3));\n+        fail_unless!(b.insert(9));\n \n         let mut i = 0;\n         let expected = [1, 5, 11];\n         for a.difference(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     fn test_symmetric_difference() {\n         let mut a = TreeSet::new();\n         let mut b = TreeSet::new();\n \n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(9);\n-        assert a.insert(11);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(9));\n+        fail_unless!(a.insert(11));\n \n-        assert b.insert(-2);\n-        assert b.insert(3);\n-        assert b.insert(9);\n-        assert b.insert(14);\n-        assert b.insert(22);\n+        fail_unless!(b.insert(-2));\n+        fail_unless!(b.insert(3));\n+        fail_unless!(b.insert(9));\n+        fail_unless!(b.insert(14));\n+        fail_unless!(b.insert(22));\n \n         let mut i = 0;\n         let expected = [-2, 1, 5, 11, 14, 22];\n         for a.symmetric_difference(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n \n     #[test]\n     fn test_union() {\n         let mut a = TreeSet::new();\n         let mut b = TreeSet::new();\n \n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(9);\n-        assert a.insert(11);\n-        assert a.insert(16);\n-        assert a.insert(19);\n-        assert a.insert(24);\n-\n-        assert b.insert(-2);\n-        assert b.insert(1);\n-        assert b.insert(5);\n-        assert b.insert(9);\n-        assert b.insert(13);\n-        assert b.insert(19);\n+        fail_unless!(a.insert(1));\n+        fail_unless!(a.insert(3));\n+        fail_unless!(a.insert(5));\n+        fail_unless!(a.insert(9));\n+        fail_unless!(a.insert(11));\n+        fail_unless!(a.insert(16));\n+        fail_unless!(a.insert(19));\n+        fail_unless!(a.insert(24));\n+\n+        fail_unless!(b.insert(-2));\n+        fail_unless!(b.insert(1));\n+        fail_unless!(b.insert(5));\n+        fail_unless!(b.insert(9));\n+        fail_unless!(b.insert(13));\n+        fail_unless!(b.insert(19));\n \n         let mut i = 0;\n         let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n         for a.union(&b) |x| {\n-            assert *x == expected[i];\n+            fail_unless!(*x == expected[i]);\n             i += 1\n         }\n-        assert i == expected.len();\n+        fail_unless!(i == expected.len());\n     }\n }"}, {"sha": "b3581e2690c8a0d9f5d689b2f06054c9b66e7732", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -224,25 +224,25 @@ mod tests {\n \n     #[test]\n     fn test_is_digit() {\n-        assert (unicode::icu::is_digit('0'));\n-        assert (!unicode::icu::is_digit('m'));\n+        fail_unless!((unicode::icu::is_digit('0')));\n+        fail_unless!((!unicode::icu::is_digit('m')));\n     }\n \n     #[test]\n     fn test_is_lower() {\n-        assert (unicode::icu::is_lower('m'));\n-        assert (!unicode::icu::is_lower('M'));\n+        fail_unless!((unicode::icu::is_lower('m')));\n+        fail_unless!((!unicode::icu::is_lower('M')));\n     }\n \n     #[test]\n     fn test_is_space() {\n-        assert (unicode::icu::is_space(' '));\n-        assert (!unicode::icu::is_space('m'));\n+        fail_unless!((unicode::icu::is_space(' ')));\n+        fail_unless!((!unicode::icu::is_space('m')));\n     }\n \n     #[test]\n     fn test_is_upper() {\n-        assert (unicode::icu::is_upper('M'));\n-        assert (!unicode::icu::is_upper('m'));\n+        fail_unless!((unicode::icu::is_upper('M')));\n+        fail_unless!((!unicode::icu::is_upper('m')));\n     }\n }"}, {"sha": "522a613f02d4fe0102779ec93779ad681ae625b4", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -188,7 +188,7 @@ extern fn tear_down_walk_cb(handle: *libc::c_void, arg: *libc::c_void) {\n     // pretty much, if we still have an active handle and it is *not*\n     // the async handle that facilities global loop communication, we\n     // want to barf out and fail\n-    assert handle == arg;\n+    fail_unless!(handle == arg);\n }\n \n extern fn tear_down_close_cb(handle: *ll::uv_async_t) {"}, {"sha": "a48dd7b4f86ef0309c609b4a6f0d95cb8c7f24b5", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1339,7 +1339,7 @@ pub mod test {\n                     stream as *libc::c_void);\n                 let err_msg = get_last_err_info(test_loop);\n                 log(debug, err_msg);\n-                assert false;\n+                fail_unless!(false);\n             }\n             log(debug, ~\"finishing on_connect_cb\");\n         }\n@@ -1411,12 +1411,12 @@ pub mod test {\n                 }\n                 else {\n                    log(debug, ~\"tcp_connect() failure\");\n-                   assert false;\n+                   fail_unless!(false);\n                 }\n             }\n             else {\n                 log(debug, ~\"tcp_init() failure\");\n-                assert false;\n+                fail_unless!(false);\n             }\n             loop_delete(test_loop);\n         }\n@@ -1493,7 +1493,7 @@ pub mod test {\n                         log(debug, get_last_err_info(\n                             get_loop_for_uv_handle(client_stream_ptr\n                                 as *libc::c_void)));\n-                        assert false;\n+                        fail_unless!(false);\n                     }\n                 }\n                 else {\n@@ -1553,19 +1553,19 @@ pub mod test {\n                     else {\n                         log(debug, fmt!(\"server_connection_cb: bad read:%d\",\n                                         read_result as int));\n-                        assert false;\n+                        fail_unless!(false);\n                     }\n                 }\n                 else {\n                     log(debug, fmt!(\"server_connection_cb: bad accept: %d\",\n                                 accept_result as int));\n-                    assert false;\n+                    fail_unless!(false);\n                 }\n             }\n             else {\n                 log(debug, fmt!(\"server_connection_cb: bad client init: %d\",\n                             client_init_result as int));\n-                assert false;\n+                fail_unless!(false);\n             }\n         }\n     }\n@@ -1684,25 +1684,25 @@ pub mod test {\n                         else {\n                             log(debug, fmt!(\"uv_async_init failure: %d\",\n                                     async_result as int));\n-                            assert false;\n+                            fail_unless!(false);\n                         }\n                     }\n                     else {\n                         log(debug, fmt!(\"non-zero result on uv_listen: %d\",\n                                     listen_result as int));\n-                        assert false;\n+                        fail_unless!(false);\n                     }\n                 }\n                 else {\n                     log(debug, fmt!(\"non-zero result on uv_tcp_bind: %d\",\n                                 bind_result as int));\n-                    assert false;\n+                    fail_unless!(false);\n                 }\n             }\n             else {\n                 log(debug, fmt!(\"non-zero result on uv_tcp_init: %d\",\n                             tcp_init_result as int));\n-                assert false;\n+                fail_unless!(false);\n             }\n             loop_delete(test_loop);\n         }\n@@ -1747,8 +1747,8 @@ pub mod test {\n             let msg_from_client = server_port.recv();\n             let msg_from_server = client_port.recv();\n \n-            assert str::contains(msg_from_client, kill_server_msg);\n-            assert str::contains(msg_from_server, server_resp_msg);\n+            fail_unless!(str::contains(msg_from_client, kill_server_msg));\n+            fail_unless!(str::contains(msg_from_server, server_resp_msg));\n         }\n     }\n \n@@ -1794,7 +1794,7 @@ pub mod test {\n                     t_name, rust_size, foreign_size as uint);\n                 log(debug, output);\n             }\n-            assert sizes_match;\n+            fail_unless!(sizes_match);\n         }\n     }\n \n@@ -1859,7 +1859,7 @@ pub mod test {\n             // .. can't get the uv::ll::sockaddr_in6 to == 28 :/\n             // .. so the type always appears to be 32 in size.. which is\n             // good, i guess.. better too big than too little\n-            assert (4u+foreign_handle_size as uint) == rust_handle_size;\n+            fail_unless!((4u+foreign_handle_size as uint) == rust_handle_size);\n         }\n     }\n     #[test]\n@@ -1873,7 +1873,7 @@ pub mod test {\n                               foreign_handle_size as uint, rust_handle_size);\n             log(debug, output);\n             // FIXME #1645 .. see note above about struct padding\n-            assert (4u+foreign_handle_size as uint) == rust_handle_size;\n+            fail_unless!((4u+foreign_handle_size as uint) == rust_handle_size);\n         }\n     }\n "}, {"sha": "a525c0df5fa08eb38c4d1083cad22667a012e10d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -253,7 +253,7 @@ pub impl FileMap {\n     // about what ends a line between this file and parse.rs\n     fn next_line(&self, +pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n-        assert ((self.lines.len() == 0)\n+        fail_unless!((self.lines.len() == 0)\n                 || (self.lines[self.lines.len() - 1] < pos));\n         self.lines.push(pos);\n     }\n@@ -272,7 +272,7 @@ pub impl FileMap {\n     }\n \n     pub fn record_multibyte_char(&self, pos: BytePos, bytes: uint) {\n-        assert bytes >=2 && bytes <= 4;\n+        fail_unless!(bytes >=2 && bytes <= 4);\n         let mbc = MultiByteChar {\n             pos: pos,\n             bytes: bytes,\n@@ -393,7 +393,7 @@ pub impl CodeMap {\n     pub fn span_to_snippet(&self, sp: span) -> ~str {\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n-        assert begin.fm.start_pos == end.fm.start_pos;\n+        fail_unless!(begin.fm.start_pos == end.fm.start_pos);\n         return str::slice(*begin.fm.src,\n                           begin.pos.to_uint(), end.pos.to_uint());\n     }\n@@ -453,7 +453,7 @@ priv impl CodeMap {\n         debug!(\"codemap: char pos %? is on the line at char pos %?\",\n                chpos, linechpos);\n         debug!(\"codemap: byte is on line: %?\", line);\n-        assert chpos >= linechpos;\n+        fail_unless!(chpos >= linechpos);\n         return Loc {\n             file: f,\n             line: line,\n@@ -492,8 +492,8 @@ priv impl CodeMap {\n                 total_extra_bytes += mbc.bytes;\n                 // We should never see a byte position in the middle of a\n                 // character\n-                assert bpos == mbc.pos\n-                    || bpos.to_uint() >= mbc.pos.to_uint() + mbc.bytes;\n+                fail_unless!(bpos == mbc.pos\n+                    || bpos.to_uint() >= mbc.pos.to_uint() + mbc.bytes);\n             } else {\n                 break;\n             }"}, {"sha": "f76f10f3de16c4ee805f8f5b9cb02afcd71b1dd7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -430,7 +430,7 @@ pub fn core_macros() -> ~str {\n     macro_rules! fail_unless(\n         ($cond:expr) => {\n             if !$cond {\n-                fail!(~\\\"assertion failed: \\\" + stringify!($cond))\n+                ::core::sys::fail_assert(stringify!($cond), file!(), line!())\n             }\n         }\n     )"}, {"sha": "eafe871a2888eb59deebed665a134d6831b5e7fd", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -54,7 +54,7 @@ impl gen_send for message {\n           message(ref _id, span, ref tys, this, Some(ref next_state)) => {\n             debug!(\"pipec: next state exists\");\n             let next = this.proto.get_state(next_state.state);\n-            assert next_state.tys.len() == next.generics.ty_params.len();\n+            fail_unless!(next_state.tys.len() == next.generics.ty_params.len());\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n             let args_ast = vec::map2(arg_names, *tys, |n, t| cx.arg(*n, *t));\n "}, {"sha": "c66e726bbf772672570c17bea4e1884f87da56c3", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -410,7 +410,7 @@ pub fn parse(\n             }\n         }\n \n-        assert cur_eis.len() > 0u;\n+        fail_unless!(cur_eis.len() > 0u);\n     }\n }\n "}, {"sha": "494ef3a81a0d2aa641d4de91979f914aff041690", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -57,7 +57,7 @@ pub fn is_doc_comment(s: &str) -> bool {\n }\n \n pub fn doc_comment_style(comment: &str) -> ast::attr_style {\n-    assert is_doc_comment(comment);\n+    fail_unless!(is_doc_comment(comment));\n     if comment.starts_with(~\"//!\") || comment.starts_with(~\"/*!\") {\n         ast::attr_inner\n     } else {\n@@ -136,8 +136,8 @@ fn read_to_eol(rdr: @mut StringReader) -> ~str {\n \n fn read_one_line_comment(rdr: @mut StringReader) -> ~str {\n     let val = read_to_eol(rdr);\n-    assert ((val[0] == '/' as u8 && val[1] == '/' as u8) ||\n-            (val[0] == '#' as u8 && val[1] == '!' as u8));\n+    fail_unless!((val[0] == '/' as u8 && val[1] == '/' as u8) ||\n+                 (val[0] == '#' as u8 && val[1] == '!' as u8));\n     return val;\n }\n \n@@ -249,7 +249,7 @@ fn read_block_comment(rdr: @mut StringReader,\n             bump(rdr);\n         }\n         if !is_block_non_doc_comment(curr_line) { return; }\n-        assert !curr_line.contains_char('\\n');\n+        fail_unless!(!curr_line.contains_char('\\n'));\n         lines.push(curr_line);\n     } else {\n         let mut level: int = 1;"}, {"sha": "ab57d177112936cf81459bd4ba89cfe3155e89a4", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -187,7 +187,7 @@ pub fn bump(rdr: @mut StringReader) {\n     rdr.last_pos = rdr.pos;\n     let current_byte_offset = byte_offset(rdr).to_uint();;\n     if current_byte_offset < (*rdr.src).len() {\n-        assert rdr.curr != -1 as char;\n+        fail_unless!(rdr.curr != -1 as char);\n         let last_char = rdr.curr;\n         let next = str::char_range_at(*rdr.src, current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n@@ -314,7 +314,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n }\n \n pub pure fn is_block_non_doc_comment(s: &str) -> bool {\n-    assert s.len() >= 1u;\n+    fail_unless!(s.len() >= 1u);\n     str::all_between(s, 1u, s.len() - 1u, |ch| ch == '*')\n }\n \n@@ -872,29 +872,29 @@ pub mod test {\n         let env = setup(~\"'a'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        assert tok == token::LIT_INT('a' as i64, ast::ty_char);\n+        fail_unless!(tok == token::LIT_INT('a' as i64, ast::ty_char));\n     }\n \n     #[test] fn character_space() {\n         let env = setup(~\"' '\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        assert tok == token::LIT_INT(' ' as i64, ast::ty_char);\n+        fail_unless!(tok == token::LIT_INT(' ' as i64, ast::ty_char));\n     }\n \n     #[test] fn character_escaped() {\n         let env = setup(~\"'\\n'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        assert tok == token::LIT_INT('\\n' as i64, ast::ty_char);\n+        fail_unless!(tok == token::LIT_INT('\\n' as i64, ast::ty_char));\n     }\n \n     #[test] fn lifetime_name() {\n         let env = setup(~\"'abc\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         let id = env.interner.intern(@~\"abc\");\n-        assert tok == token::LIFETIME(id);\n+        fail_unless!(tok == token::LIFETIME(id));\n     }\n }\n "}, {"sha": "48d3fbe8889e1356018e35012083a3904dec0be3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -197,7 +197,7 @@ pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n     let rv = sess.next_id;\n     sess.next_id += 1;\n     // ID 0 is reserved for the crate and doesn't actually exist in the AST\n-    assert rv != 0;\n+    fail_unless!(rv != 0);\n     return rv;\n }\n "}, {"sha": "0dba2bd45e173fbc08041031072294d6ea53f77b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -2499,7 +2499,7 @@ pub impl Parser {\n \n     fn parse_block(&self) -> blk {\n         let (attrs, blk) = self.parse_inner_attrs_and_block(false);\n-        assert vec::is_empty(attrs);\n+        fail_unless!(vec::is_empty(attrs));\n         return blk;\n     }\n \n@@ -3846,7 +3846,7 @@ pub impl Parser {\n         foreign_items_allowed: bool,\n         macros_allowed: bool\n     ) -> item_or_view_item {\n-        assert items_allowed != foreign_items_allowed;\n+        fail_unless!(items_allowed != foreign_items_allowed);\n \n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n@@ -4215,11 +4215,11 @@ pub impl Parser {\n                     view_items.push(view_item);\n                 }\n                 iovi_item(item) => {\n-                    assert items_allowed;\n+                    fail_unless!(items_allowed);\n                     items.push(item)\n                 }\n                 iovi_foreign_item(foreign_item) => {\n-                    assert foreign_items_allowed;\n+                    fail_unless!(foreign_items_allowed);\n                     foreign_items.push(foreign_item);\n                 }\n             }"}, {"sha": "df658b96d7bf017e7665ca75e8ea9263871b41a0", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -117,7 +117,7 @@ pub fn tok_str(++t: token) -> ~str {\n pub fn buf_str(toks: ~[token], szs: ~[int], left: uint, right: uint,\n                lim: uint) -> ~str {\n     let n = vec::len(toks);\n-    assert (n == vec::len(szs));\n+    fail_unless!((n == vec::len(szs)));\n     let mut i = left;\n     let mut L = lim;\n     let mut s = ~\"[\";\n@@ -369,24 +369,24 @@ pub impl Printer {\n         } else {\n             self.top += 1u;\n             self.top %= self.buf_len;\n-            assert (self.top != self.bottom);\n+            fail_unless!((self.top != self.bottom));\n         }\n         self.scan_stack[self.top] = x;\n     }\n     fn scan_pop(&mut self) -> uint {\n-        assert (!self.scan_stack_empty);\n+        fail_unless!((!self.scan_stack_empty));\n         let x = self.scan_stack[self.top];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else { self.top += self.buf_len - 1u; self.top %= self.buf_len; }\n         return x;\n     }\n     fn scan_top(&mut self) -> uint {\n-        assert (!self.scan_stack_empty);\n+        fail_unless!((!self.scan_stack_empty));\n         return self.scan_stack[self.top];\n     }\n     fn scan_pop_bottom(&mut self) -> uint {\n-        assert (!self.scan_stack_empty);\n+        fail_unless!((!self.scan_stack_empty));\n         let x = self.scan_stack[self.bottom];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n@@ -396,7 +396,7 @@ pub impl Printer {\n     fn advance_right(&mut self) {\n         self.right += 1u;\n         self.right %= self.buf_len;\n-        assert (self.right != self.left);\n+        fail_unless!((self.right != self.left));\n     }\n     fn advance_left(&mut self, ++x: token, L: int) {\n         debug!(\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n@@ -405,7 +405,7 @@ pub impl Printer {\n             self.print(x, L);\n             match x {\n               BREAK(b) => self.left_total += b.blank_space,\n-              STRING(_, len) => { assert (len == L); self.left_total += len; }\n+              STRING(_, len) => { fail_unless!((len == L)); self.left_total += len; }\n               _ => ()\n             }\n             if self.left != self.right {\n@@ -494,7 +494,7 @@ pub impl Printer {\n           }\n           END => {\n             debug!(\"print END -> pop END\");\n-            assert (self.print_stack.len() != 0u);\n+            fail_unless!((self.print_stack.len() != 0u));\n             self.print_stack.pop();\n           }\n           BREAK(b) => {\n@@ -528,8 +528,8 @@ pub impl Printer {\n           }\n           STRING(s, len) => {\n             debug!(\"print STRING(%s)\", *s);\n-            assert (L == len);\n-            // assert L <= space;\n+            fail_unless!((L == len));\n+            // fail_unless!(L <= space);\n             self.space -= len;\n             self.print_str(*s);\n           }"}, {"sha": "d87238c720ed6fae1e31c023473d6e0c69eacce7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -1327,8 +1327,8 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         print_fn_block_args(s, decl);\n         space(s.s);\n         // }\n-        assert body.node.stmts.is_empty();\n-        assert body.node.expr.is_some();\n+        fail_unless!(body.node.stmts.is_empty());\n+        fail_unless!(body.node.expr.is_some());\n         // we extract the block, so as not to create another set of boxes\n         match body.node.expr.get().node {\n             ast::expr_block(ref blk) => {\n@@ -1460,7 +1460,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n \n         // if any are mut, all are mut\n         if vec::any(locs, |l| l.node.is_mutbl) {\n-            assert vec::all(locs, |l| l.node.is_mutbl);\n+            fail_unless!(vec::all(locs, |l| l.node.is_mutbl));\n             word_nbsp(s, ~\"mut\");\n         }\n \n@@ -2086,7 +2086,7 @@ pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n pub fn print_comment(s: @ps, cmnt: comments::cmnt) {\n     match cmnt.style {\n       comments::mixed => {\n-        assert (vec::len(cmnt.lines) == 1u);\n+        fail_unless!((vec::len(cmnt.lines) == 1u));\n         zerobreak(s.s);\n         word(s.s, cmnt.lines[0]);\n         zerobreak(s.s);"}, {"sha": "2c852084aa7eddfe463c8e683c0c5ecd0ac6f5b4", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -74,32 +74,32 @@ pub fn i1 () {\n pub fn i2 () {\n     let i : Interner<@~str> = Interner::new();\n     // first one is zero:\n-    assert i.intern (@~\"dog\") == 0;\n+    fail_unless!(i.intern (@~\"dog\") == 0);\n     // re-use gets the same entry:\n-    assert i.intern (@~\"dog\") == 0;\n+    fail_unless!(i.intern (@~\"dog\") == 0);\n     // different string gets a different #:\n-    assert i.intern (@~\"cat\") == 1;\n-    assert i.intern (@~\"cat\") == 1;\n+    fail_unless!(i.intern (@~\"cat\") == 1);\n+    fail_unless!(i.intern (@~\"cat\") == 1);\n     // dog is still at zero\n-    assert i.intern (@~\"dog\") == 0;\n+    fail_unless!(i.intern (@~\"dog\") == 0);\n     // gensym gets 3\n-    assert i.gensym (@~\"zebra\" ) == 2;\n+    fail_unless!(i.gensym (@~\"zebra\" ) == 2);\n     // gensym of same string gets new number :\n-    assert i.gensym (@~\"zebra\" ) == 3;\n+    fail_unless!(i.gensym (@~\"zebra\" ) == 3);\n     // gensym of *existing* string gets new number:\n-    assert i.gensym (@~\"dog\") == 4;\n-    assert i.get(0) == @~\"dog\";\n-    assert i.get(1) == @~\"cat\";\n-    assert i.get(2) == @~\"zebra\";\n-    assert i.get(3) == @~\"zebra\";\n-    assert i.get(4) == @~\"dog\";\n+    fail_unless!(i.gensym (@~\"dog\") == 4);\n+    fail_unless!(i.get(0) == @~\"dog\");\n+    fail_unless!(i.get(1) == @~\"cat\");\n+    fail_unless!(i.get(2) == @~\"zebra\");\n+    fail_unless!(i.get(3) == @~\"zebra\");\n+    fail_unless!(i.get(4) == @~\"dog\");\n }\n \n #[test]\n pub fn i3 () {\n     let i : Interner<@~str> = Interner::prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n-    assert i.get(0) == @~\"Alan\";\n-    assert i.get(1) == @~\"Bob\";\n-    assert i.get(2) == @~\"Carol\";\n-    assert i.intern(@~\"Bob\") == 1;\n+    fail_unless!(i.get(0) == @~\"Alan\");\n+    fail_unless!(i.get(1) == @~\"Bob\");\n+    fail_unless!(i.get(2) == @~\"Carol\");\n+    fail_unless!(i.intern(@~\"Bob\") == 1);\n }"}, {"sha": "a1896c660eb6f71392786bbf33600d49d43d6e3a", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -42,7 +42,7 @@ fn old_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n             }\n \n             for uint::range(0, num_keys) |i| {\n-                assert map.get(&i) == i+1;\n+                fail_unless!(map.get(&i) == i+1);\n             }\n         }\n     }\n@@ -64,7 +64,7 @@ fn old_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n \n         do timed(&mut results.delete_ints) {\n             for uint::range(0, num_keys) |i| {\n-                assert map.remove(&i);\n+                fail_unless!(map.remove(&i));\n             }\n         }\n     }\n@@ -81,7 +81,7 @@ fn old_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n \n             for uint::range(0, num_keys) |i| {\n                 let s = uint::to_str(i);\n-                assert map.get(&s) == i;\n+                fail_unless!(map.get(&s) == i);\n             }\n         }\n     }\n@@ -103,7 +103,7 @@ fn old_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n         }\n         do timed(&mut results.delete_strings) {\n             for uint::range(0, num_keys) |i| {\n-                assert map.remove(&uint::to_str(i));\n+                fail_unless!(map.remove(&uint::to_str(i)));\n             }\n         }\n     }\n@@ -118,7 +118,7 @@ fn linear_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results)\n             }\n \n             for uint::range(0, num_keys) |i| {\n-                assert map.find(&i).unwrap() == &(i+1);\n+                fail_unless!(map.find(&i).unwrap() == &(i+1));\n             }\n         }\n     }\n@@ -140,7 +140,7 @@ fn linear_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results)\n \n         do timed(&mut results.delete_ints) {\n             for uint::range(0, num_keys) |i| {\n-                assert map.remove(&i);\n+                fail_unless!(map.remove(&i));\n             }\n         }\n     }\n@@ -157,7 +157,7 @@ fn linear_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results)\n \n             for uint::range(0, num_keys) |i| {\n                 let s = uint::to_str(i);\n-                assert map.find(&s).unwrap() == &i;\n+                fail_unless!(map.find(&s).unwrap() == &i);\n             }\n         }\n     }\n@@ -179,7 +179,7 @@ fn linear_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results)\n         }\n         do timed(&mut results.delete_strings) {\n             for uint::range(0, num_keys) |i| {\n-                assert map.remove(&uint::to_str(i));\n+                fail_unless!(map.remove(&uint::to_str(i)));\n             }\n         }\n     }\n@@ -194,7 +194,7 @@ fn tree_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n             }\n \n             for uint::range(0, num_keys) |i| {\n-                assert map.find(&i).unwrap() == &(i+1);\n+                fail_unless!(map.find(&i).unwrap() == &(i+1));\n             }\n         }\n     }\n@@ -216,7 +216,7 @@ fn tree_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n \n         do timed(&mut results.delete_ints) {\n             for uint::range(0, num_keys) |i| {\n-                assert map.remove(&i);\n+                fail_unless!(map.remove(&i));\n             }\n         }\n     }\n@@ -233,7 +233,7 @@ fn tree_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n \n             for uint::range(0, num_keys) |i| {\n                 let s = uint::to_str(i);\n-                assert map.find(&s).unwrap() == &i;\n+                fail_unless!(map.find(&s).unwrap() == &i);\n             }\n         }\n     }\n@@ -255,7 +255,7 @@ fn tree_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n         }\n         do timed(&mut results.delete_strings) {\n             for uint::range(0, num_keys) |i| {\n-                assert map.remove(&uint::to_str(i));\n+                fail_unless!(map.remove(&uint::to_str(i)));\n             }\n         }\n     }"}, {"sha": "ab441277c62a3382739d9dc22aa43dcdf98a8aea", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -42,7 +42,7 @@ pub impl Results {\n                 }\n \n                 for uint::range(0, num_keys) |i| {\n-                    assert set.contains(&i);\n+                    fail_unless!(set.contains(&i));\n                 }\n             }\n         }\n@@ -64,7 +64,7 @@ pub impl Results {\n \n             do timed(&mut self.delete_ints) {\n                 for uint::range(0, num_keys) |i| {\n-                    assert set.remove(&i);\n+                    fail_unless!(set.remove(&i));\n                 }\n             }\n         }\n@@ -82,7 +82,7 @@ pub impl Results {\n \n                 for uint::range(0, num_keys) |i| {\n                     let s = uint::to_str(i);\n-                    assert set.contains(&s);\n+                    fail_unless!(set.contains(&s));\n                 }\n             }\n         }\n@@ -104,7 +104,7 @@ pub impl Results {\n             }\n             do timed(&mut self.delete_strings) {\n                 for uint::range(0, num_keys) |i| {\n-                    assert set.remove(&uint::to_str(i));\n+                    fail_unless!(set.remove(&uint::to_str(i)));\n                 }\n             }\n         }"}, {"sha": "4117add8926a0cda2058a8babc0917fe4c91d148", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -47,10 +47,10 @@ fn main() {\n     let end = std::time::precise_time_s();\n \n     // check each vector\n-    assert raw_v.len() == max;\n-    for raw_v.eachi |i, v| { assert i == *v; }\n-    assert dvec_v.len() == max;\n-    for dvec_v.eachi |i, v| { assert i == *v; }\n+    fail_unless!(raw_v.len() == max);\n+    for raw_v.eachi |i, v| { fail_unless!(i == *v); }\n+    fail_unless!(dvec_v.len() == max);\n+    for dvec_v.eachi |i, v| { fail_unless!(i == *v); }\n \n     let raw = mid - start;\n     let dvec = end - mid;"}, {"sha": "9efcc05e9964fcdb5017e12dd2b28c45581dd9cb", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -293,7 +293,7 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n             };\n             result\n         };\n-        assert(colors.len() == old_len);\n+        fail_unless!((colors.len() == old_len));\n     }\n \n     // Convert the results.\n@@ -461,7 +461,7 @@ fn main() {\n \n             if do_validate {\n                 let start = time::precise_time_s();\n-                assert(validate(copy edges, *root, bfs_tree));\n+                fail_unless!((validate(copy edges, *root, bfs_tree)));\n                 let stop = time::precise_time_s();\n \n                 io::stdout().write_line(\n@@ -481,7 +481,7 @@ fn main() {\n \n             if do_validate {\n                 let start = time::precise_time_s();\n-                assert(validate(copy edges, *root, bfs_tree));\n+                fail_unless!((validate(copy edges, *root, bfs_tree)));\n                 let stop = time::precise_time_s();\n \n                 io::stdout().write_line(\n@@ -501,7 +501,7 @@ fn main() {\n \n         if do_validate {\n             let start = time::precise_time_s();\n-            assert(validate(copy edges, *root, bfs_tree));\n+            fail_unless!((validate(copy edges, *root, bfs_tree)));\n             let stop = time::precise_time_s();\n \n             io::stdout().write_line(fmt!(\"Validation completed in %? seconds.\","}, {"sha": "5ae1f796304324470d4d6ca1b8603be2735d366f", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -95,7 +95,7 @@ fn run(args: &[~str]) {\n     io::stdout().write_str(fmt!(\"Test took %? seconds\\n\", elapsed));\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n     io::stdout().write_str(fmt!(\"Throughput=%f per sec\\n\", thruput));\n-    assert result == num_bytes * size;\n+    fail_unless!(result == num_bytes * size);\n }\n \n fn main() {"}, {"sha": "db1aaf9bcdbd4d185f7f75fb9ee5f414b8d28de5", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -92,7 +92,7 @@ fn run(args: &[~str]) {\n     io::stdout().write_str(fmt!(\"Test took %? seconds\\n\", elapsed));\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n     io::stdout().write_str(fmt!(\"Throughput=%f per sec\\n\", thruput));\n-    assert result == num_bytes * size;\n+    fail_unless!(result == num_bytes * size);\n }\n \n fn main() {"}, {"sha": "77cd7890f2987150b4f580de334a43dc4adb0779", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -73,7 +73,7 @@ fn stress_task(&&id: int) {\n     let mut i = 0;\n     loop {\n         let n = 15;\n-        assert (fib(n) == fib(n));\n+        fail_unless!((fib(n) == fib(n)));\n         i += 1;\n         error!(\"%d: Completed %d iterations\", id, i);\n     }"}, {"sha": "930e3d8a6089812b27593924be101cccc2bfc578", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -22,7 +22,7 @@ fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n \n fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n     for uint::range(min, max) |i| {\n-        assert *map.get(&i) == i + 22u;\n+        fail_unless!(*map.get(&i) == i + 22u);\n     }\n }\n "}, {"sha": "78234ca0dfa22197c3915cb5281a3f3e92dd72e0", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -40,7 +40,7 @@ pub enum grid_t { grid_ctor(grid), }\n \n // read a sudoku problem from file f\n pub fn read_grid(f: io::Reader) -> grid_t {\n-    assert f.read_line() == ~\"9,9\"; /* assert first line is exactly \"9,9\" */\n+    fail_unless!(f.read_line() == ~\"9,9\"); /* assert first line is exactly \"9,9\" */\n \n     let mut g = vec::from_fn(10u, {|_i|\n         vec::from_elem(10u, 0 as u8)"}, {"sha": "de58ae8ab0d3a24ecfa5834fd02e124799f1dd67", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -51,7 +51,7 @@ fn spawn_supervised_blocking(myname: &str, +f: ~fn()) {\n     task::task().future_result(|+r| res = Some(r)).supervised().spawn(f);\n     error!(\"%s group waiting\", myname);\n     let x = option::unwrap(res).recv();\n-    assert x == task::Success;\n+    fail_unless!(x == task::Success);\n }\n \n fn main() {\n@@ -81,5 +81,5 @@ fn main() {\n         error!(\"Grandparent group wakes up and fails\");\n         fail!();\n     };\n-    assert x.is_err();\n+    fail_unless!(x.is_err());\n }"}, {"sha": "1e21af7b3f054d8761ff0f94a21d283532b9affe", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -18,5 +18,5 @@ fn main() {\n         //~^ ERROR cannot infer an appropriate lifetime\n     }\n     // Adding this line causes a method unification failure instead\n-    // do (&option::unwrap(y)).read |state| { assert *state == 1; }\n+    // do (&option::unwrap(y)).read |state| { fail_unless!(*state == 1); }\n }"}, {"sha": "b1375cc7980c84c7cb0d7cf1cebd68487ca1dc7a", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -18,5 +18,5 @@ fn main() {\n         y = Some(write_mode);\n     }\n     // Adding this line causes a method unification failure instead\n-    // do (&option::unwrap(y)).write |state| { assert *state == 1; }\n+    // do (&option::unwrap(y)).write |state| { fail_unless!(*state == 1); }\n }"}, {"sha": "25ae03087321b8c59549e95edbbb556e4ad14b7c", "filename": "src/test/compile-fail/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fautoderef-full-lval.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -23,10 +23,10 @@ fn main() {\n     let b: clam = clam{x: @10, y: @20};\n     let z: int = a.x + b.y;\n     log(debug, z);\n-    assert (z == 21);\n+    fail_unless!((z == 21));\n     let forty: fish = fish{a: @40};\n     let two: fish = fish{a: @2};\n     let answer: int = forty.a + two.a;\n     log(debug, answer);\n-    assert (answer == 42);\n+    fail_unless!((answer == 42));\n }"}, {"sha": "4a90d2f4b7fcf7caef2bd5f3c2257c15ce0d2698", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     c.send(false);\n     match x {\n         Some(z) if z.recv() => { fail!() }, //~ ERROR cannot bind by-move into a pattern guard\n-        Some(z) => { assert !z.recv(); },\n+        Some(z) => { fail_unless!(!z.recv()); },\n         None => fail!()\n     }\n }"}, {"sha": "1ef5ae1607957e7655b99b1be657f9a4c2086fd7", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -19,5 +19,5 @@ fn compute1() -> float {\n fn main() {\n     let x = compute1();\n     log(debug, x);\n-    assert(x == -4f);\n+    fail_unless!((x == -4f));\n }"}, {"sha": "e56a179e7741e9bf23bcda8b5f0330cee1a35a14", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -16,8 +16,8 @@ fn box_imm() {\n     let mut v = ~3;\n     do borrow(v) |w| { //~ NOTE loan of mutable local variable granted here\n         v = ~4; //~ ERROR assigning to captured outer mutable variable in a stack closure prohibited due to outstanding loan\n-        assert *v == 3;\n-        assert *w == 4;\n+        fail_unless!(*v == 3);\n+        fail_unless!(*w == 4);\n     }\n }\n "}, {"sha": "b5c8f509167e324ffe2e74ad30b538254ddc43c9", "filename": "src/test/compile-fail/borrowck-ref-mut-of-imm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -16,5 +16,5 @@ fn destructure(x: Option<int>) -> int {\n }\n \n fn main() {\n-    assert destructure(Some(22)) == 22;\n+    fail_unless!(destructure(Some(22)) == 22);\n }"}, {"sha": "1c2a3e1742672239ecaa23882d86d1d87cf50765", "filename": "src/test/compile-fail/cast-from-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n // error-pattern: cast from nil: `()` as `u32`\n-fn main() { let u = (assert true) as u32; }\n+fn main() { let u = (fail_unless!(true) as u32); }"}, {"sha": "b8c2274076c3331cdc4204bf5c6b83e2a0ef2c82", "filename": "src/test/compile-fail/crateresolve5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcrateresolve5.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -18,5 +18,5 @@ extern mod cr5_2 (name = \"crateresolve5\", vers = \"0.2\");\n \n fn main() {\n     // Nominal types from two multiple versions of a crate are different types\n-    assert cr5_1::nominal() == cr5_2::nominal();\n+    fail_unless!(cr5_1::nominal() == cr5_2::nominal());\n }"}, {"sha": "89821f97513960e1f8c48520cd04ffa8648798ce", "filename": "src/test/compile-fail/do2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo2.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -11,6 +11,6 @@\n fn f(f: @fn(int) -> bool) -> bool { f(10i) }\n \n fn main() {\n-    assert do f() |i| { i == 10i } == 10i;\n+    fail_unless!(do f() |i| { i == 10i } == 10i);\n     //~^ ERROR: expected `bool` but found `int`\n }"}, {"sha": "bf130addb6bf6fb057d28a653adba25854d7795a", "filename": "src/test/compile-fail/issue-1896-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1896-1.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -20,5 +20,5 @@ fn main () {\n \n     let myInt: uint = (aFn.theFn)();\n \n-    assert myInt == 10;\n+    fail_unless!(myInt == 10);\n }"}, {"sha": "6d31deea3ff35ebcc29f7f25824b544e26d61b95", "filename": "src/test/compile-fail/issue-2467.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2467.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,5 +12,5 @@ enum test { thing = 3u } //~ ERROR mismatched types\n //~^ ERROR expected signed integer constant\n fn main() {\n     log(error, thing as int);\n-    assert(thing as int == 3);\n+    fail_unless!((thing as int == 3));\n }"}, {"sha": "83fdb86628b65415c1e8fffb1baedbd6d64b1430", "filename": "src/test/compile-fail/issue-2548.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -35,8 +35,8 @@ fn main() {\n \n         let mut v = ~[];\n         v = ~[(res)] + v; //~ instantiating a type parameter with an incompatible type `foo`, which does not fulfill `Copy`\n-        assert (v.len() == 2);\n+        fail_unless!((v.len() == 2));\n     }\n \n-    assert *x == 1;\n+    fail_unless!(*x == 1);\n }"}, {"sha": "5e6fa6e95f87d9d212ca5261d4fa58b2c69ad204", "filename": "src/test/compile-fail/issue-2969.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -15,5 +15,5 @@ fn main()\n    let mut x = [1, 2, 4];\n    let v : &int = &x[2];\n    x[2] = 6;\n-   assert *v == 6;\n+   fail_unless!(*v == 6);\n }"}, {"sha": "779265e5a292fe3a65f2574d2d1aedf582016494", "filename": "src/test/compile-fail/issue-3888.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -25,17 +25,17 @@ fn vec_peek<T>(v: &r/[T]) -> Option< (&r/T, &r/[T]) > {\n \n fn test_peek_empty_stack() {\n     let v : &[int] = &[];\n-    assert (None == vec_peek(v));\n+    fail_unless!((None == vec_peek(v)));\n }\n \n fn test_peek_empty_unique() {\n     let v : ~[int] = ~[];\n-    assert (None == vec_peek(v));\n+    fail_unless!((None == vec_peek(v)));\n }\n \n fn test_peek_empty_managed() {\n     let v : @[int] = @[];\n-    assert (None == vec_peek(v));\n+    fail_unless!((None == vec_peek(v)));\n }\n \n "}, {"sha": "632b15dadd46b1912cfefd4e2cf0e3df6665ba84", "filename": "src/test/compile-fail/issue-511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,7 +12,7 @@ extern mod std;\n use core::cmp::Eq;\n \n fn f<T:Eq>(o: &mut Option<T>) {\n-    assert *o == option::None;\n+    fail_unless!(*o == option::None);\n }\n \n fn main() {"}, {"sha": "0de7276fc8cd32ddb088645e922e1a5e10c90799", "filename": "src/test/compile-fail/issue-818.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-818.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fissue-818.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-818.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -20,5 +20,5 @@ mod ctr {\n fn main() {\n     let c = ctr::new(42);\n     let c2 = ctr::inc(c);\n-    assert *c2 == 5; //~ ERROR can only dereference enums with a single, public variant\n+    fail_unless!(*c2 == 5); //~ ERROR can only dereference enums with a single, public variant\n }"}, {"sha": "e0651a68fa9d45bca4f6c4dc73c13207b2e8e024", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -27,5 +27,5 @@ fn main() {\n         let x: &blk/int = &3;\n         repeater(@x)\n     };\n-    assert 3 == *(y.get()); //~ ERROR reference is not valid\n+    fail_unless!(3 == *(y.get())); //~ ERROR reference is not valid\n }"}, {"sha": "fbbac6e0a641a81e70bbdad5269c872b043f997e", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -27,7 +27,7 @@ fn to_foo<T:Copy>(t: T) {\n     let v = &3;\n     struct F<T> { f: T }\n     let x = @F {f:t} as foo;\n-    assert x.foo(v) == 3;\n+    fail_unless!(x.foo(v) == 3);\n }\n \n fn to_foo_2<T:Copy>(t: T) -> foo {"}, {"sha": "832e6d8a6a79a77f55835d3f0218dc1c6714119e", "filename": "src/test/compile-fail/mod_file_correct_spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_correct_spans.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -13,5 +13,5 @@\n mod mod_file_aux;\n \n fn main() {\n-    assert mod_file_aux::bar() == 10; //~ ERROR unresolved name\n+    fail_unless!(mod_file_aux::bar() == 10); //~ ERROR unresolved name\n }"}, {"sha": "d742ad04d768c18c38bc1b38d9371f762e6cf5f8", "filename": "src/test/compile-fail/mod_file_not_exist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_not_exist.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -11,5 +11,5 @@\n mod not_a_real_file; //~ ERROR not_a_real_file.rs\n \n fn main() {\n-    assert mod_file_aux::bar() == 10;\n+    fail_unless!(mod_file_aux::bar() == 10);\n }"}, {"sha": "2f71f4d22f903c8b567f3641f771412905dcf77f", "filename": "src/test/compile-fail/mod_file_with_path_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmod_file_with_path_attr.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,5 +12,5 @@\n mod m; //~ ERROR not_a_real_file.rs\n \n fn main() {\n-    assert m::foo() == 10;\n+    fail_unless!(m::foo() == 10);\n }"}, {"sha": "fd15321e1d02bfe7b3487c52c93c9ba767042e6f", "filename": "src/test/compile-fail/mode-inference-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -18,6 +18,6 @@ fn apply_int(f: fn(int) -> int, a: int) -> int { f(a) }\n \n fn main() {\n     let f = {|i| i};\n-    assert apply_int(f, 2) == 2;\n-    assert apply(f, 2) == 2; //~ ERROR expected argument mode &&\n+    fail_unless!(apply_int(f, 2) == 2);\n+    fail_unless!(apply(f, 2) == 2); //~ ERROR expected argument mode &&\n }"}, {"sha": "a0c1bf040e317668331dadf37f0814b04db32e52", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -19,10 +19,10 @@ fn main() {\n     \n     do task::spawn() {\n         let v = *arc::get(&arc_v);\n-        assert v[3] == 4;\n+        fail_unless!(v[3] == 4);\n     };\n \n-    assert (*arc::get(&arc_v))[2] == 3;\n+    fail_unless!((*arc::get(&arc_v))[2] == 3);\n \n     log(info, arc_v);\n }"}, {"sha": "4cb78e7032bcb698ccd62fbadc753d709475222d", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -17,10 +17,10 @@ fn main() {\n \n     do task::spawn() { //~ NOTE `arc_v` moved into closure environment here\n         let v = *arc::get(&arc_v);\n-        assert v[3] == 4;\n+        fail_unless!(v[3] == 4);\n     };\n \n-    assert (*arc::get(&arc_v))[2] == 3; //~ ERROR use of moved value: `arc_v`\n+    fail_unless!((*arc::get(&arc_v))[2] == 3); //~ ERROR use of moved value: `arc_v`\n \n     log(info, arc_v);\n }"}, {"sha": "0623f93a38bfb0a129ef7969d565669709f0c970", "filename": "src/test/compile-fail/noncopyable-match-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let x = Some(unstable::exclusive(false));\n     match x {\n         Some(copy z) => { //~ ERROR copying a value of non-copyable type\n-            do z.with |b| { assert !*b; }\n+            do z.with |b| { fail_unless!(!*b); }\n         }\n         None => fail!()\n     }"}, {"sha": "0ab53da0c4ae7fd08e9c5836b099d549677d66a4", "filename": "src/test/compile-fail/omitted-arg-wrong-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,9 +12,9 @@\n fn let_in<T>(x: T, f: &fn(T)) {}\n \n fn main() {\n-    let_in(3u, |i| { assert i == 3; });\n+    let_in(3u, |i| { fail_unless!(i == 3); });\n     //~^ ERROR expected `uint` but found `int`\n \n-    let_in(3, |i| { assert i == 3u; });\n+    let_in(3, |i| { fail_unless!(i == 3u); });\n     //~^ ERROR expected `int` but found `uint`\n }"}, {"sha": "1df102a751a3cc598298b9b602ec093ddfe4a8e1", "filename": "src/test/compile-fail/private-struct-field-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field-cross-crate.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -14,5 +14,5 @@ use cci_class::kitties::*;\n \n fn main() {\n   let nyan : cat = cat(52u, 99);\n-  assert (nyan.meows == 52u);   //~ ERROR field `meows` is private\n+  fail_unless!((nyan.meows == 52u));   //~ ERROR field `meows` is private\n }"}, {"sha": "86a14587006ecf8ae22279f6109bae3334de5f1c", "filename": "src/test/compile-fail/private-struct-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-struct-field.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -20,5 +20,5 @@ mod cat {\n \n fn main() {\n     let nyan = cat::new_cat();\n-    assert nyan.meows == 52;    //~ ERROR field `meows` is private\n+    fail_unless!(nyan.meows == 52);    //~ ERROR field `meows` is private\n }"}, {"sha": "f5e304dbe722c51c7e174aee637456992ff3562c", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -37,5 +37,5 @@ mod argparse {\n fn main () {\n     let f : argparse::Flag = argparse::flag(~\"flag\", ~\"My flag\");\n     let updated_flag = f.set_desc(~\"My new flag\");\n-    assert updated_flag.desc == \"My new flag\";\n+    fail_unless!(updated_flag.desc == \"My new flag\");\n }"}, {"sha": "063764eea0e52e1da09b9d56f47ff6862ebcce94", "filename": "src/test/compile-fail/regions-infer-borrow-scope-too-big.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-too-big.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -16,7 +16,7 @@ fn x_coord(p: &r/point) -> &r/int {\n \n fn foo(p: @point) -> &int {\n     let xc = x_coord(p); //~ ERROR illegal borrow\n-    assert *xc == 3;\n+    fail_unless!(*xc == 3);\n     return xc;\n }\n "}, {"sha": "59329195b712cacf9b96653ca0d5e38f40696a78", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -19,10 +19,10 @@ fn foo(cond: fn() -> bool, box: fn() -> @int) {\n \t// of this borrow is the fn body as a whole.\n         y = borrow(x); //~ ERROR illegal borrow: cannot root managed value long enough\n \n-        assert *x == *y;\n+        fail_unless!(*x == *y);\n         if cond() { break; }\n     }\n-    assert *y != 0;\n+    fail_unless!(*y != 0);\n }\n \n fn main() {}"}, {"sha": "f4e41d951aa2aab4d30c4fc5b5053f16f6ecef01", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -34,5 +34,5 @@ fn get_v(gc: get_ctxt) -> uint {\n fn main() {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n-    assert get_v(@hc as get_ctxt) == 22u;\n+    fail_unless!(get_v(@hc as get_ctxt) == 22u);\n }"}, {"sha": "cd395fe4dd15a6e5a73c1cfc5ada3e73153975b4", "filename": "src/test/compile-fail/regions-var-type-out-of-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-var-type-out-of-scope.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -15,7 +15,7 @@ fn foo(cond: bool) {\n \n     if cond {\n         x = &3; //~ ERROR illegal borrow: borrowed value does not live long enough\n-        assert (*x == 3);\n+        fail_unless!((*x == 3));\n     }\n }\n "}, {"sha": "b13835a89d4f834177fed8546755d8ec6dafa91f", "filename": "src/test/compile-fail/tag-type-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-type-args.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,6 +12,6 @@\n \n enum quux<T> { bar }\n \n-fn foo(c: quux) { assert (false); }\n+fn foo(c: quux) { fail_unless!((false)); }\n \n fn main() { fail!(); }"}, {"sha": "c825118fa984cacb69b8214e6d4642e7a4420b44", "filename": "src/test/compile-fail/vtable-res-trait-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvtable-res-trait-param.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -29,5 +29,5 @@ fn call_it<B:TraitB>(b: B)  -> int {\n \n fn main() {\n     let x = 3i;\n-    assert call_it(x) == 22;\n+    fail_unless!(call_it(x) == 22);\n }"}, {"sha": "73a5b864ea817a31296f41e30b44f9b0cf073a53", "filename": "src/test/pretty/alt-naked-expr-long.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -22,5 +22,5 @@ fn main() {\n               + ~\"very\" + ~\"very\" + ~\"long\" + ~\"string\",\n           None => ~\"none\"\n         };\n-    assert y == ~\"some(_)\";\n+    fail_unless!(y == ~\"some(_)\");\n }"}, {"sha": "3a92e3c28e72393a4454ec9a47a651563b914900", "filename": "src/test/pretty/alt-naked-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fpretty%2Falt-naked-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fpretty%2Falt-naked-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     let x = Some(3);\n     let y = match x { Some(_) => ~\"some(_)\", None => ~\"none\" };\n-    assert y == ~\"some(_)\";\n+    fail_unless!(y == ~\"some(_)\");\n }"}, {"sha": "fc80c75e53271ead9dcdce9a5e808477488e1621", "filename": "src/test/pretty/record-trailing-comma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fpretty%2Frecord-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Fpretty%2Frecord-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Frecord-trailing-comma.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -18,5 +18,5 @@ struct Thing {\n fn main() {\n     let sth = Thing{x: 0, y: 1,};\n     let sth2 = Thing{y: 9 , ..sth};\n-    assert sth.x + sth2.y == 9;\n+    fail_unless!(sth.x + sth2.y == 9);\n }"}, {"sha": "23207dcf43706523e703da703837cd75b0dc2fac", "filename": "src/test/run-fail/fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Ffail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Ffail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,4 +12,4 @@\n \n \n // error-pattern:1 == 2\n-fn main() { assert (1 == 2); }\n+fn main() { fail_unless!((1 == 2)); }"}, {"sha": "458ec11c674311603027884ebf925730fe0d4b21", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -13,7 +13,7 @@\n // error-pattern:1 == 2\n extern mod std;\n \n-fn child() { assert (1 == 2); }\n+fn child() { fail_unless!((1 == 2)); }\n \n fn main() {\n     let (p, _c) = comm::stream::<int>();"}, {"sha": "1955a29058fb7ea806a2d6a2b0e7ce42c672c267", "filename": "src/test/run-fail/linked-failure4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure4.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -11,7 +11,7 @@\n \n // error-pattern:1 == 2\n \n-fn child() { assert (1 == 2); }\n+fn child() { fail_unless!((1 == 2)); }\n \n fn parent() {\n     let (p, _c) = comm::stream::<int>();"}, {"sha": "f7ece96fd6e31fd7cdcbeb9aa41735798fda504a", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -15,5 +15,5 @@ fn main() {\n     let s: ~str = ~\"hello\";\n \n     // Bounds-check failure.\n-    assert (s[5] == 0x0 as u8);\n+    fail_unless!((s[5] == 0x0 as u8));\n }"}, {"sha": "17838348b82fec5038193db3a83c5efbfe4f53aa", "filename": "src/test/run-fail/task-spawn-barefn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -17,5 +17,5 @@ fn main() {\n }\n \n fn startfn() {\n-    assert str::is_empty(~\"Ensure that the child task runs by failing\");\n+    fail_unless!(str::is_empty(~\"Ensure that the child task runs by failing\"));\n }"}, {"sha": "035afa781dee5c7bea2ce546bc1eff1e978175d7", "filename": "src/test/run-fail/unwind-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-alt.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -16,7 +16,7 @@ fn test_box() {\n fn test_str() {\n   let res = match false { true => { ~\"happy\" },\n      _ => fail!(~\"non-exhaustive match failure\") };\n-  assert res == ~\"happy\";\n+  fail_unless!(res == ~\"happy\");\n }\n fn main() {\n     test_box();"}, {"sha": "1d5397e7d38896a4b9901665c0d02265f5f64d00", "filename": "src/test/run-fail/unwind-assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Funwind-assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Funwind-assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-assert.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     let a = @0;\n-    assert false;\n+    fail_unless!(false);\n }"}, {"sha": "461764252495281b05a977dac1e0914637143c57", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -14,8 +14,8 @@\n fn main() {\n     let v: ~[int] = ~[10];\n     let x: int = 0;\n-    assert (v[x] == 10);\n+    fail_unless!((v[x] == 10));\n     // Bounds-check failure.\n \n-    assert (v[x + 2] == 20);\n+    fail_unless!((v[x + 2] == 20));\n }"}, {"sha": "c01dbf03455cbbf861764bc325b99b71df8ce1a6", "filename": "src/test/run-fail/vec-underrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -14,8 +14,8 @@\n fn main() {\n     let v: ~[int] = ~[10, 20];\n     let x: int = 0;\n-    assert (v[x] == 10);\n+    fail_unless!((v[x] == 10));\n     // Bounds-check failure.\n \n-    assert (v[x - 1] == 20);\n+    fail_unless!((v[x - 1] == 20));\n }"}, {"sha": "311760b6aa5da918d9c7b1d985f86c64b3403dfa", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -15,15 +15,15 @@ extern mod std;\n use core::vec::{same_length, zip};\n \n fn enum_chars(start: u8, end: u8) -> ~[char] {\n-    assert start < end;\n+    fail_unless!(start < end);\n     let mut i = start;\n     let mut r = ~[];\n     while i <= end { r.push(i as char); i += 1 as u8; }\n     return r;\n }\n \n fn enum_uints(start: uint, end: uint) -> ~[uint] {\n-    assert start < end;\n+    fail_unless!(start < end);\n     let mut i = start;\n     let mut r = ~[];\n     while i <= end { r.push(i); i += 1; }\n@@ -35,7 +35,7 @@ fn main() {\n     let chars = enum_chars(a, j);\n     let ints = enum_uints(k, l);\n \n-    assert same_length(chars, ints);\n+    fail_unless!(same_length(chars, ints));\n     let ps = zip(chars, ints);\n     fail!(~\"the impossible happened\");\n }"}, {"sha": "92f80a9aa0d9be0add4db0253d25265820ef21c2", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -84,7 +84,7 @@ fn check_pp<T>(cx: fake_ext_ctxt,\n     stdout().write_line(s);\n     if expect != ~\"\" {\n         error!(\"expect: '%s', got: '%s'\", expect, s);\n-        assert s == expect;\n+        fail_unless!(s == expect);\n     }\n }\n "}, {"sha": "4c99e6f1a099cc5b8ff0003d67bc4f285076a5e7", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -20,6 +20,6 @@ fn f<A:Copy + &static>(a: A, b: u16) -> @fn() -> (A, u16) {\n pub fn main() {\n     let (a, b) = f(22_u64, 44u16)();\n     debug!(\"a=%? b=%?\", a, b);\n-    assert a == 22u64;\n-    assert b == 44u16;\n+    fail_unless!(a == 22u64);\n+    fail_unless!(b == 44u16);\n }"}, {"sha": "5bf8051cc1a4787521163db6b1a9ac0ec3c03b6e", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -35,6 +35,6 @@ pub fn main() {\n     make_cycle(z);\n     let (a, b) = z();\n     debug!(\"a=%u b=%u\", *a as uint, b as uint);\n-    assert *a == x;\n-    assert b == y;\n+    fail_unless!(*a == x);\n+    fail_unless!(b == y);\n }"}, {"sha": "c00b185d131aa636d957b561b01bd1682de2a083", "filename": "src/test/run-pass/alt-implicit-copy-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-implicit-copy-unique.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n     let mut x = ~Pair {a: ~10, b: ~20};\n     match x {\n       ~Pair {a: ref mut a, b: ref mut b} => {\n-        assert **a == 10; *a = ~30; assert **a == 30;\n+        fail_unless!(**a == 10); *a = ~30; fail_unless!(**a == 30);\n       }\n     }\n }"}, {"sha": "97b835f55be5e3eed92dea038c099888d99763f0", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -25,7 +25,7 @@ fn foo(s: @int) {\n       _ => { debug!(\"?\"); fail!(); }\n     }\n     log(debug, ::core::sys::refcount(s));\n-    assert (::core::sys::refcount(s) == count + 1u);\n+    fail_unless!((::core::sys::refcount(s) == count + 1u));\n     let _ = ::core::sys::refcount(s); // don't get bitten by last-use.\n }\n \n@@ -39,5 +39,5 @@ pub fn main() {\n     log(debug, ::core::sys::refcount(s));\n     let count2 = ::core::sys::refcount(s);\n     let _ = ::core::sys::refcount(s); // don't get bitten by last-use.\n-    assert count == count2;\n+    fail_unless!(count == count2);\n }"}, {"sha": "37f924dd1beb4b7cc56079e0c0f5270d7c5db78e", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -18,4 +18,4 @@ fn altlit(f: int) -> int {\n     }\n }\n \n-pub fn main() { assert (altlit(10) == 20); assert (altlit(11) == 22); }\n+pub fn main() { fail_unless!((altlit(10) == 20)); fail_unless!((altlit(11) == 22)); }"}, {"sha": "ece2943a1c12eb05d50b73f5d56ee664a4700c64", "filename": "src/test/run-pass/alt-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,7 +12,7 @@ pub fn main() {\n     let x = Some(unstable::exclusive(true));\n     match x {\n         Some(ref z) if z.with(|b| *b) => {\n-            do z.with |b| { assert *b; }\n+            do z.with |b| { fail_unless!(*b); }\n         },\n         _ => fail!()\n     }"}, {"sha": "f6c5e64b353619e2f60c7b7cd0407f1a3fe52bb9", "filename": "src/test/run-pass/alt-ref-binding-mut-option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut-option.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -14,5 +14,5 @@ pub fn main() {\n       None => {}\n       Some(ref mut p) => { *p += 1; }\n     }\n-    assert v == Some(23);\n+    fail_unless!(v == Some(23));\n }"}, {"sha": "c8b1822e5fad4cb7d56449e1f10e2044cc327d54", "filename": "src/test/run-pass/alt-ref-binding-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-mut.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -21,5 +21,5 @@ fn destructure(x: &mut Rec) {\n pub fn main() {\n     let mut v = Rec {f: 22};\n     destructure(&mut v);\n-    assert v.f == 23;\n+    fail_unless!(v.f == 23);\n }"}, {"sha": "8b25d329b9a38912fe69b6be5b020655104656ea", "filename": "src/test/run-pass/alt-ref-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -16,5 +16,5 @@ fn destructure(x: Option<int>) -> int {\n }\n \n pub fn main() {\n-    assert destructure(Some(22)) == 22;\n+    fail_unless!(destructure(Some(22)) == 22);\n }"}, {"sha": "4a362ca8e87839437b1a464439443035ee4b1439", "filename": "src/test/run-pass/alt-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-str.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -24,7 +24,7 @@ pub fn main() {\n     }\n \n     let x = match ~\"a\" { ~\"a\" => 1, ~\"b\" => 2, _ => fail!() };\n-    assert (x == 1);\n+    fail_unless!((x == 1));\n \n     match ~\"a\" { ~\"a\" => { } ~\"b\" => { }, _ => fail!() }\n "}, {"sha": "aff2d9ad56483ce8315453d2e4ed26724efb6b87", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -32,7 +32,7 @@ pub fn main() {\n     let gray: color = rgb(127, 127, 127);\n     let clear: color = rgba(50, 150, 250, 0);\n     let red: color = hsl(0, 255, 255);\n-    assert (process(gray) == 127);\n-    assert (process(clear) == 0);\n-    assert (process(red) == 255);\n+    fail_unless!((process(gray) == 127));\n+    fail_unless!((process(clear) == 0));\n+    fail_unless!((process(red) == 255));\n }"}, {"sha": "6412cc7ffd58a67a84e507fc0463cd2bf25aa929", "filename": "src/test/run-pass/alt-unique-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,7 +12,7 @@ pub fn main() {\n     match ~100 {\n       ~x => {\n         debug!(\"%?\", x);\n-        assert x == 100;\n+        fail_unless!(x == 100);\n       }\n     }\n }"}, {"sha": "ccdbc744ca33fa7528997c4665b8f07a9efd179f", "filename": "src/test/run-pass/alt-with-ret-arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-with-ret-arm.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -16,6 +16,6 @@ pub fn main() {\n         None => return (),\n         Some(num) => num as u32\n     };\n-    assert f == 1234u32;\n+    fail_unless!(f == 1234u32);\n     log(error, f)\n }"}, {"sha": "186fdb2849443da36ae0e57e934b566864ea9dea", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -23,9 +23,9 @@ fn f2(a: int, f: &fn(int)) -> int { f(1); return a; }\n \n pub fn main() {\n     let mut a = X {x: 1}, b = 2, c = 3;\n-    assert (f1(&mut a, &mut b, c) == 6);\n-    assert (a.x == 0);\n-    assert (b == 10);\n-    assert (f2(a.x, |x| a.x = 50) == 0);\n-    assert (a.x == 50);\n+    fail_unless!((f1(&mut a, &mut b, c) == 6));\n+    fail_unless!((a.x == 0));\n+    fail_unless!((b == 10));\n+    fail_unless!((f2(a.x, |x| a.x = 50) == 0));\n+    fail_unless!((a.x == 50));\n }"}, {"sha": "0725ac2e174ef97172610e4298280cec97894cb9", "filename": "src/test/run-pass/arith-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Farith-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Farith-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-0.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -13,5 +13,5 @@\n pub fn main() {\n     let a: int = 10;\n     log(debug, a);\n-    assert (a * (a - 1) == 90);\n+    fail_unless!((a * (a - 1) == 90));\n }"}, {"sha": "3dc60d63bbe9e4c97fdb553554950ec339b2c85a", "filename": "src/test/run-pass/arith-1.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Farith-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Farith-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-1.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -12,22 +12,22 @@\n \n pub fn main() {\n     let i32_a: int = 10;\n-    assert (i32_a == 10);\n-    assert (i32_a - 10 == 0);\n-    assert (i32_a / 10 == 1);\n-    assert (i32_a - 20 == -10);\n-    assert (i32_a << 10 == 10240);\n-    assert (i32_a << 16 == 655360);\n-    assert (i32_a * 16 == 160);\n-    assert (i32_a * i32_a * i32_a == 1000);\n-    assert (i32_a * i32_a * i32_a * i32_a == 10000);\n-    assert (i32_a * i32_a / i32_a * i32_a == 100);\n-    assert (i32_a * (i32_a - 1) << 2 + i32_a == 368640);\n+    fail_unless!((i32_a == 10));\n+    fail_unless!((i32_a - 10 == 0));\n+    fail_unless!((i32_a / 10 == 1));\n+    fail_unless!((i32_a - 20 == -10));\n+    fail_unless!((i32_a << 10 == 10240));\n+    fail_unless!((i32_a << 16 == 655360));\n+    fail_unless!((i32_a * 16 == 160));\n+    fail_unless!((i32_a * i32_a * i32_a == 1000));\n+    fail_unless!((i32_a * i32_a * i32_a * i32_a == 10000));\n+    fail_unless!((i32_a * i32_a / i32_a * i32_a == 100));\n+    fail_unless!((i32_a * (i32_a - 1) << 2 + i32_a == 368640));\n     let i32_b: int = 0x10101010;\n-    assert (i32_b + 1 - 1 == i32_b);\n-    assert (i32_b << 1 == i32_b << 1);\n-    assert (i32_b >> 1 == i32_b >> 1);\n-    assert (i32_b & i32_b << 1 == 0);\n+    fail_unless!((i32_b + 1 - 1 == i32_b));\n+    fail_unless!((i32_b << 1 == i32_b << 1));\n+    fail_unless!((i32_b >> 1 == i32_b >> 1));\n+    fail_unless!((i32_b & i32_b << 1 == 0));\n     log(debug, i32_b | i32_b << 1);\n-    assert (i32_b | i32_b << 1 == 0x30303030);\n+    fail_unless!((i32_b | i32_b << 1 == 0x30303030));\n }"}, {"sha": "45bd35a68af54423ee79e50b5bd856f2045552ce", "filename": "src/test/run-pass/arith-unsigned.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-unsigned.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -13,24 +13,24 @@\n \n // Unsigned integer operations\n pub fn main() {\n-    assert (0u8 < 255u8);\n-    assert (0u8 <= 255u8);\n-    assert (255u8 > 0u8);\n-    assert (255u8 >= 0u8);\n-    assert (250u8 / 10u8 == 25u8);\n-    assert (255u8 % 10u8 == 5u8);\n-    assert (0u16 < 60000u16);\n-    assert (0u16 <= 60000u16);\n-    assert (60000u16 > 0u16);\n-    assert (60000u16 >= 0u16);\n-    assert (60000u16 / 10u16 == 6000u16);\n-    assert (60005u16 % 10u16 == 5u16);\n-    assert (0u32 < 4000000000u32);\n-    assert (0u32 <= 4000000000u32);\n-    assert (4000000000u32 > 0u32);\n-    assert (4000000000u32 >= 0u32);\n-    assert (4000000000u32 / 10u32 == 400000000u32);\n-    assert (4000000005u32 % 10u32 == 5u32);\n+    fail_unless!((0u8 < 255u8));\n+    fail_unless!((0u8 <= 255u8));\n+    fail_unless!((255u8 > 0u8));\n+    fail_unless!((255u8 >= 0u8));\n+    fail_unless!((250u8 / 10u8 == 25u8));\n+    fail_unless!((255u8 % 10u8 == 5u8));\n+    fail_unless!((0u16 < 60000u16));\n+    fail_unless!((0u16 <= 60000u16));\n+    fail_unless!((60000u16 > 0u16));\n+    fail_unless!((60000u16 >= 0u16));\n+    fail_unless!((60000u16 / 10u16 == 6000u16));\n+    fail_unless!((60005u16 % 10u16 == 5u16));\n+    fail_unless!((0u32 < 4000000000u32));\n+    fail_unless!((0u32 <= 4000000000u32));\n+    fail_unless!((4000000000u32 > 0u32));\n+    fail_unless!((4000000000u32 >= 0u32));\n+    fail_unless!((4000000000u32 / 10u32 == 400000000u32));\n+    fail_unless!((4000000005u32 % 10u32 == 5u32));\n     // 64-bit numbers have some flakiness yet. Not tested\n \n }"}, {"sha": "e3159df8378527046df7ad6a5f65515beb1f5a23", "filename": "src/test/run-pass/artificial-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fartificial-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fartificial-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fartificial-block.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f", "patch": "@@ -10,4 +10,4 @@\n \n fn f() -> int { { return 3; } }\n \n-pub fn main() { assert (f() == 3); }\n+pub fn main() { fail_unless!((f() == 3)); }"}, {"sha": "f3a792d6cca6dca402a0c5a8e1c8aafb1c2dd8e5", "filename": "src/test/run-pass/assign-assign.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fassign-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fassign-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassign-assign.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "9f13147b276d159c88712fb26afc67a87828ccf5", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "f9e5ebf261c037fa890aacf0fb4af836b517a43e", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "42b175987e13b9368e656aa02a385530a83b7184", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "cdcf3c54c5838590aaaef09e419b48683d4dae6c", "filename": "src/test/run-pass/auto-ref-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "2d2e909a5f9878a6106c30cd9a3bede10a254b91", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "1ab760307b2722fb7e2e19508b52a2d72018bb5b", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "9cd4093787db97f756054c5593602569df64ea37", "filename": "src/test/run-pass/autoderef-method-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "3d64c5d0e42d330590501b18ba0dd46e3d1d7358", "filename": "src/test/run-pass/autoderef-method-on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "a3d4e28dec75eed4dfe367d4e8684d6a18c9f10a", "filename": "src/test/run-pass/autoderef-method-priority.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-priority.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "9a6469bbca83e904f75c937b4f7109c5f20d2061", "filename": "src/test/run-pass/autoderef-method-twice-but-not-thrice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "c44ded77ec8feae29dd10c4e78b3a0540dbd023f", "filename": "src/test/run-pass/autoderef-method-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "e6b05989903f528cdeac2c16fa555bb3fa8f7b89", "filename": "src/test/run-pass/autoderef-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "0b872569f19bc893b417ffb5596a54ef64229fcb", "filename": "src/test/run-pass/autoref-intermediate-types-issue-3585.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-intermediate-types-issue-3585.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "03c6a60016db07368cebbb63f2f80f774cb5fd47", "filename": "src/test/run-pass/big-literals.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fbig-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbig-literals.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "2153db5e40c8193ff0a61ff68c302ff4cc22b2d3", "filename": "src/test/run-pass/binary-minus-without-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "bcc76cc35858f36f5f466c75de29cf2860845035", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "a2caf5e97f57b9edb48c795225a12e613d888e35", "filename": "src/test/run-pass/bitwise.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fbitwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitwise.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "f0dafa0805ebc3f51955e9bc3872d09506a0f55b", "filename": "src/test/run-pass/block-arg-call-as.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "b46aad9984564313ea171a10717c3428b4bf87c1", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "94d568b71585d101ea3b1d43f9c8b4167fec1ea9", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "bbdbfc74b0e21c4613006583394b3e5098ef5021", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "f74c531503f5e5ae1cc90c56b921dd68d276360e", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "6d311a138288d2aff6d98c6b540f831ebd210efc", "filename": "src/test/run-pass/block-arg-used-as-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "6d26ede8e3abf104a553a3b5c8f6797ad4c4ac22", "filename": "src/test/run-pass/block-arg-used-as-lambda.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-lambda.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "fa4a61549dc67ce677468f6276054066b9219111", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "39e19cfec97a24adb8c8fb6dce9d90edd9379538", "filename": "src/test/run-pass/block-expr-precedence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-expr-precedence.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "4593934d523004279f7efe4255b516b03388f99e", "filename": "src/test/run-pass/block-fn-coerce.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "571e67b4e5b85104f25cd392305184dcb53a956f", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "1ec5c781807fd55f195c6fc0273bc2ef3591abea", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "24f990ef7cdcc7bca34777afa88821920f671019", "filename": "src/test/run-pass/block-vec-map2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "656abab0cc103b6e88718f6214295f5f2873b046", "filename": "src/test/run-pass/bool-not.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fbool-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fbool-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbool-not.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "6757f8655f11983f495f52c80b5661d44524ccdc", "filename": "src/test/run-pass/borrowck-borrow-from-at-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "f2bde5a9f4bd84e14d91d81ec1138cc70a8e4951", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "764f551048171d836ffd6dac5f10f43520861c5c", "filename": "src/test/run-pass/borrowck-fixed-length-vecs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-fixed-length-vecs.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "a90381ad63130c5cdca9ccf885ce0ea778b1cf2e", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "ba1c6aec215c8fffbcdda232b1d38c6b66d0f0d0", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}, {"sha": "0b84ba4ff59fb2e683e8d3f5e525d2a5b4124bff", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=d7e74b5e91b0b6b6a5613f54479d2ef9fe9c392f"}]}