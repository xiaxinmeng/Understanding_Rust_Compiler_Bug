{"sha": "da863487072bf94273862e7eb48bcc392c900234", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhODYzNDg3MDcyYmY5NDI3Mzg2MmU3ZWI0OGJjYzM5MmM5MDAyMzQ=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-04-01T20:32:25Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-04-01T20:49:31Z"}, "message": "Update test cases", "tree": {"sha": "c0a07b28313d1497d398f86739aa65f17374ece4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0a07b28313d1497d398f86739aa65f17374ece4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da863487072bf94273862e7eb48bcc392c900234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da863487072bf94273862e7eb48bcc392c900234", "html_url": "https://github.com/rust-lang/rust/commit/da863487072bf94273862e7eb48bcc392c900234", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da863487072bf94273862e7eb48bcc392c900234/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18af989c063efd759e03d6eebb7b18e2b03349a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/18af989c063efd759e03d6eebb7b18e2b03349a4", "html_url": "https://github.com/rust-lang/rust/commit/18af989c063efd759e03d6eebb7b18e2b03349a4"}], "stats": {"total": 630, "additions": 522, "deletions": 108}, "files": [{"sha": "3e3460789152c5df3102655314ac6b993bc0dc0e", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.fixed", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed?ref=da863487072bf94273862e7eb48bcc392c900234", "patch": "@@ -0,0 +1,133 @@\n+// run-rustfix\n+\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test cases for types that implement a insignificant drop (stlib defined)\n+\n+// `t` needs Drop because one of its elements needs drop,\n+// therefore precise capture might affect drop ordering\n+fn test1_all_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let t2 = (String::new(), String::new());\n+\n+    let c = || { let _ = (&t, &t1, &t2); {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP:` let _ = (&t, &t1, &t2)` causes `t`, `t1`, `t2` to be fully captured\n+\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2.0;\n+    } };\n+\n+    c();\n+}\n+\n+// String implements drop and therefore should be migrated.\n+// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n+fn test2_only_precise_paths_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let t2 = (String::new(), String::new());\n+\n+    let c = || { let _ = (&t, &t1); {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP:` let _ = (&t, &t1)` causes `t`, `t1` to be fully captured\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2;\n+    } };\n+\n+    c();\n+}\n+\n+// If a variable would've not been captured by value then it would've not been\n+// dropped with the closure and therefore doesn't need migration.\n+fn test3_only_by_value_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let c = || { let _ = &t; {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n+        let _t = t.0;\n+        println!(\"{}\", t1.1);\n+    } };\n+\n+    c();\n+}\n+\n+// Copy types get copied into the closure instead of move. Therefore we don't need to\n+// migrate then as their drop order isn't tied to the closure.\n+fn test4_only_non_copy_types_need_migration() {\n+    let t = (String::new(), String::new());\n+\n+    // `t1` is Copy because all of its elements are Copy\n+    let t1 = (0i32, 0i32);\n+\n+    let c = || { let _ = &t; {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+    } };\n+\n+    c();\n+}\n+\n+fn test5_only_drop_types_need_migration() {\n+    struct S(i32, i32);\n+\n+    let t = (String::new(), String::new());\n+\n+    // `s` doesn't implement Drop or any elements within it, and doesn't need migration\n+    let s = S(0i32, 0i32);\n+\n+    let c = || { let _ = &t; {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n+        let _t = t.0;\n+        let _s = s.0;\n+    } };\n+\n+    c();\n+}\n+\n+// Since we are using a move closure here, both `t` and `t1` get moved\n+// even though they are being used by ref inside the closure.\n+fn test6_move_closures_non_copy_types_might_need_migration() {\n+    let t = (String::new(), String::new());\n+    let t1 = (String::new(), String::new());\n+    let c = move || { let _ = (&t1, &t); {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = (&t1, &t)` causes `t1`, `t` to be fully captured\n+        println!(\"{} {}\", t1.1, t.1);\n+    } };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Drop + Non Drop aggregates.\n+// Note we need migration here only because the non-copy (because Drop type) is captured,\n+// otherwise we won't need to, since we can get away with just by ref capture in that case.\n+fn test7_drop_non_drop_aggregate_need_migration() {\n+    let t = (String::new(), String::new(), 0i32);\n+\n+    let c = || { let _ = &t; {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n+        let _t = t.0;\n+    } };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_all_need_migration();\n+    test2_only_precise_paths_need_migration();\n+    test3_only_by_value_need_migration();\n+    test4_only_non_copy_types_need_migration();\n+    test5_only_drop_types_need_migration();\n+    test6_move_closures_non_copy_types_might_need_migration();\n+    test7_drop_non_drop_aggregate_need_migration();\n+}"}, {"sha": "2472c8afc8729a246804118e22017f6dc4875c71", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=da863487072bf94273862e7eb48bcc392c900234", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![deny(disjoint_capture_drop_reorder)]\n //~^ NOTE: the lint level is defined here\n \n@@ -11,8 +13,9 @@ fn test1_all_need_migration() {\n     let t2 = (String::new(), String::new());\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t, t1, t2));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP:` let _ = (&t, &t1, &t2)` causes `t`, `t1`, `t2` to be fully captured\n+\n         let _t = t.0;\n         let _t1 = t1.0;\n         let _t2 = t2.0;\n@@ -29,8 +32,8 @@ fn test2_only_precise_paths_need_migration() {\n     let t2 = (String::new(), String::new());\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t, t1));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP:` let _ = (&t, &t1)` causes `t`, `t1` to be fully captured\n         let _t = t.0;\n         let _t1 = t1.0;\n         let _t2 = t2;\n@@ -45,8 +48,8 @@ fn test3_only_by_value_need_migration() {\n     let t = (String::new(), String::new());\n     let t1 = (String::new(), String::new());\n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n         let _t = t.0;\n         println!(\"{}\", t1.1);\n     };\n@@ -63,8 +66,8 @@ fn test4_only_non_copy_types_need_migration() {\n     let t1 = (0i32, 0i32);\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n         let _t = t.0;\n         let _t1 = t1.0;\n     };\n@@ -81,8 +84,8 @@ fn test5_only_drop_types_need_migration() {\n     let s = S(0i32, 0i32);\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n         let _t = t.0;\n         let _s = s.0;\n     };\n@@ -96,8 +99,8 @@ fn test6_move_closures_non_copy_types_might_need_migration() {\n     let t = (String::new(), String::new());\n     let t1 = (String::new(), String::new());\n     let c = move || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t1, t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = (&t1, &t)` causes `t1`, `t` to be fully captured\n         println!(\"{} {}\", t1.1, t.1);\n     };\n \n@@ -111,8 +114,8 @@ fn test7_drop_non_drop_aggregate_need_migration() {\n     let t = (String::new(), String::new(), 0i32);\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n         let _t = t.0;\n     };\n "}, {"sha": "925df1160c8a0038035312033cdb0b02e84061ef", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.stderr", "status": "modified", "additions": 71, "deletions": 17, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr?ref=da863487072bf94273862e7eb48bcc392c900234", "patch": "@@ -1,25 +1,33 @@\n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:13:13\n+  --> $DIR/insignificant_drop.rs:15:13\n    |\n LL |       let c = || {\n    |  _____________^\n LL | |\n LL | |\n-LL | |         let _t = t.0;\n-LL | |         let _t1 = t1.0;\n+LL | |\n+...  |\n LL | |         let _t2 = t2.0;\n LL | |     };\n    | |_____^\n    |\n note: the lint level is defined here\n-  --> $DIR/insignificant_drop.rs:1:9\n+  --> $DIR/insignificant_drop.rs:3:9\n    |\n LL | #![deny(disjoint_capture_drop_reorder)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: drop(&(t, t1, t2));\n+help: `let _ = (&t, &t1, &t2)` causes `t`, `t1`, `t2` to be fully captured\n+   |\n+LL |     let c = || { let _ = (&t, &t1, &t2); {\n+LL |\n+LL |\n+LL | \n+LL |         let _t = t.0;\n+LL |         let _t1 = t1.0;\n+ ...\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:31:13\n+  --> $DIR/insignificant_drop.rs:34:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -31,10 +39,18 @@ LL | |         let _t2 = t2;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t, t1));\n+help: `let _ = (&t, &t1)` causes `t`, `t1` to be fully captured\n+   |\n+LL |     let c = || { let _ = (&t, &t1); {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _t1 = t1.0;\n+LL |         let _t2 = t2;\n+ ...\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:47:13\n+  --> $DIR/insignificant_drop.rs:50:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -45,10 +61,18 @@ LL | |         println!(\"{}\", t1.1);\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: `let _ = &t` causes `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         println!(\"{}\", t1.1);\n+LL |     } };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:65:13\n+  --> $DIR/insignificant_drop.rs:68:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -59,10 +83,18 @@ LL | |         let _t1 = t1.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: `let _ = &t` causes `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _t1 = t1.0;\n+LL |     } };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:83:13\n+  --> $DIR/insignificant_drop.rs:86:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -73,10 +105,18 @@ LL | |         let _s = s.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: `let _ = &t` causes `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _s = s.0;\n+LL |     } };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:98:13\n+  --> $DIR/insignificant_drop.rs:101:13\n    |\n LL |       let c = move || {\n    |  _____________^\n@@ -86,10 +126,17 @@ LL | |         println!(\"{} {}\", t1.1, t.1);\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t1, t));\n+help: `let _ = (&t1, &t)` causes `t1`, `t` to be fully captured\n+   |\n+LL |     let c = move || { let _ = (&t1, &t); {\n+LL |\n+LL |\n+LL |         println!(\"{} {}\", t1.1, t.1);\n+LL |     } };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/insignificant_drop.rs:113:13\n+  --> $DIR/insignificant_drop.rs:116:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -99,7 +146,14 @@ LL | |         let _t = t.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: `let _ = &t` causes `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |     } };\n+   |\n \n error: aborting due to 7 previous errors\n "}, {"sha": "53793be8a6916bf38f01a698b0abfcfb41890e58", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.fixed", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.fixed?ref=da863487072bf94273862e7eb48bcc392c900234", "patch": "@@ -0,0 +1,56 @@\n+// run-rustfix\n+\n+#![deny(disjoint_capture_drop_reorder)]\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+struct ConstainsDropField(Foo, Foo);\n+\n+// Test that lint is triggered if a path that implements Drop is not captured by move\n+fn test_precise_analysis_drop_paths_not_captured_by_move() {\n+    let t = ConstainsDropField(Foo(10), Foo(20));\n+\n+    let c = || { let _ = &t; {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n+        let _t = t.0;\n+        let _t = &t.1;\n+    } };\n+\n+    c();\n+}\n+\n+struct S;\n+impl Drop for S {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+struct T(S, S);\n+struct U(T, T);\n+\n+// Test precise analysis for the lint works with paths longer than one.\n+fn test_precise_analysis_long_path_missing() {\n+    let u = U(T(S, S), T(S, S));\n+\n+    let c = || { let _ = &u; {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &u` causes `u` to be fully captured\n+        let _x = u.0.0;\n+        let _x = u.0.1;\n+        let _x = u.1.0;\n+    } };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test_precise_analysis_drop_paths_not_captured_by_move();\n+    test_precise_analysis_long_path_missing();\n+}"}, {"sha": "3661c2ca7ed17300434a3fd9e29c35eea9b0e6a3", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.rs?ref=da863487072bf94273862e7eb48bcc392c900234", "patch": "@@ -1,5 +1,6 @@\n+// run-rustfix\n+\n #![deny(disjoint_capture_drop_reorder)]\n-//~^ NOTE: the lint level is defined here\n \n #[derive(Debug)]\n struct Foo(i32);\n@@ -11,35 +12,13 @@ impl Drop for Foo {\n \n struct ConstainsDropField(Foo, Foo);\n \n-#[derive(Debug)]\n-struct ContainsAndImplsDrop(Foo);\n-impl Drop for ContainsAndImplsDrop {\n-    fn drop(&mut self) {\n-        println!(\"{:?} dropped\", self.0);\n-    }\n-}\n-\n-// Test that even if all paths starting at root variable that implement Drop are captured,\n-// the lint is triggered if the root variable implements drop and isn't captured.\n-fn test_precise_analysis_parent_root_impl_drop_not_captured() {\n-    let t = ContainsAndImplsDrop(Foo(10));\n-\n-    let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n-        let _t = t.0;\n-    };\n-\n-    c();\n-}\n-\n // Test that lint is triggered if a path that implements Drop is not captured by move\n fn test_precise_analysis_drop_paths_not_captured_by_move() {\n     let t = ConstainsDropField(Foo(10), Foo(20));\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n         let _t = t.0;\n         let _t = &t.1;\n     };\n@@ -61,8 +40,8 @@ fn test_precise_analysis_long_path_missing() {\n     let u = U(T(S, S), T(S, S));\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(u));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &u` causes `u` to be fully captured\n         let _x = u.0.0;\n         let _x = u.0.1;\n         let _x = u.1.0;\n@@ -72,7 +51,6 @@ fn test_precise_analysis_long_path_missing() {\n }\n \n fn main() {\n-    test_precise_analysis_parent_root_impl_drop_not_captured();\n     test_precise_analysis_drop_paths_not_captured_by_move();\n     test_precise_analysis_long_path_missing();\n }"}, {"sha": "4cd75a15adb1a4543c347f08f6ea426fba6e9c30", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/precise.stderr", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fprecise.stderr?ref=da863487072bf94273862e7eb48bcc392c900234", "patch": "@@ -1,37 +1,32 @@\n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/precise.rs:27:13\n+  --> $DIR/precise.rs:19:13\n    |\n LL |       let c = || {\n    |  _____________^\n LL | |\n LL | |\n LL | |         let _t = t.0;\n+LL | |         let _t = &t.1;\n LL | |     };\n    | |_____^\n    |\n note: the lint level is defined here\n-  --> $DIR/precise.rs:1:9\n+  --> $DIR/precise.rs:3:9\n    |\n LL | #![deny(disjoint_capture_drop_reorder)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: drop(&(t));\n-\n-error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/precise.rs:40:13\n+help: `let _ = &t` causes `t` to be fully captured\n    |\n-LL |       let c = || {\n-   |  _____________^\n-LL | |\n-LL | |\n-LL | |         let _t = t.0;\n-LL | |         let _t = &t.1;\n-LL | |     };\n-   | |_____^\n+LL |     let c = || { let _ = &t; {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _t = &t.1;\n+LL |     } };\n    |\n-   = note: drop(&(t));\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/precise.rs:63:13\n+  --> $DIR/precise.rs:42:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -43,7 +38,15 @@ LL | |         let _x = u.1.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(u));\n+help: `let _ = &u` causes `u` to be fully captured\n+   |\n+LL |     let c = || { let _ = &u; {\n+LL |\n+LL |\n+LL |         let _x = u.0.0;\n+LL |         let _x = u.0.1;\n+LL |         let _x = u.1.0;\n+ ...\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "82b9299c1f437b4f29750cb193dbdbb973413279", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.fixed", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed?ref=da863487072bf94273862e7eb48bcc392c900234", "patch": "@@ -0,0 +1,136 @@\n+// run-rustfix\n+#![deny(disjoint_capture_drop_reorder)]\n+//~^ NOTE: the lint level is defined here\n+\n+// Test cases for types that implement a significant drop (user defined)\n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ConstainsDropField(Foo, Foo);\n+\n+// `t` needs Drop because one of its elements needs drop,\n+// therefore precise capture might affect drop ordering\n+fn test1_all_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let t2 = (Foo(0), Foo(0));\n+\n+    let c = || { let _ = (&t, &t1, &t2); {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP:` let _ = (&t, &t1, &t2)` causes `t`, `t1`, `t2` to be fully captured\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2.0;\n+    } };\n+\n+    c();\n+}\n+\n+// String implements drop and therefore should be migrated.\n+// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n+fn test2_only_precise_paths_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let t2 = (Foo(0), Foo(0));\n+\n+    let c = || { let _ = (&t, &t1); {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP:` let _ = (&t, &t1)` causes `t`, `t1` to be fully captured\n+        let _t = t.0;\n+        let _t1 = t1.0;\n+        let _t2 = t2;\n+    } };\n+\n+    c();\n+}\n+\n+// If a variable would've not been captured by value then it would've not been\n+// dropped with the closure and therefore doesn't need migration.\n+fn test3_only_by_value_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0));\n+    let c = || { let _ = &t; {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n+        let _t = t.0;\n+        println!(\"{:?}\", t1.1);\n+    } };\n+\n+    c();\n+}\n+\n+// The root variable might not implement drop themselves but some path starting\n+// at the root variable might implement Drop.\n+//\n+// If this path isn't captured we need to migrate for the root variable.\n+fn test4_type_contains_drop_need_migration() {\n+    let t = ConstainsDropField(Foo(0), Foo(0));\n+\n+    let c = || { let _ = &t; {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n+        let _t = t.0;\n+    } };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Drop + Non Drop aggregates.\n+// Note we need migration here only because the non-copy (because Drop type) is captured,\n+// otherwise we won't need to, since we can get away with just by ref capture in that case.\n+fn test5_drop_non_drop_aggregate_need_migration() {\n+    let t = (Foo(0), Foo(0), 0i32);\n+\n+    let c = || { let _ = &t; {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n+        let _t = t.0;\n+    } };\n+\n+    c();\n+}\n+\n+// Test migration analysis in case of Significant and Insignificant Drop aggregates.\n+fn test6_significant_insignificant_drop_aggregate_need_migration() {\n+    let t = (Foo(0), String::new());\n+\n+    let c = || { let _ = &t; {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n+        let _t = t.1;\n+    } };\n+\n+    c();\n+}\n+\n+// Since we are using a move closure here, both `t` and `t1` get moved\n+// even though they are being used by ref inside the closure.\n+fn test7_move_closures_non_copy_types_might_need_migration() {\n+    let t = (Foo(0), Foo(0));\n+    let t1 = (Foo(0), Foo(0), Foo(0));\n+\n+    let c = move || { let _ = (&t1, &t); {\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = (&t1, &t)` causes `t1`, `t` to be fully captured\n+        println!(\"{:?} {:?}\", t1.1, t.1);\n+    } };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test1_all_need_migration();\n+    test2_only_precise_paths_need_migration();\n+    test3_only_by_value_need_migration();\n+    test4_type_contains_drop_need_migration();\n+    test5_drop_non_drop_aggregate_need_migration();\n+    test6_significant_insignificant_drop_aggregate_need_migration();\n+    test7_move_closures_non_copy_types_might_need_migration();\n+}"}, {"sha": "5cb2f611bc1e5e5800d79d2cb9763577b293578b", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs?ref=da863487072bf94273862e7eb48bcc392c900234", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n #![deny(disjoint_capture_drop_reorder)]\n //~^ NOTE: the lint level is defined here\n \n@@ -22,8 +23,8 @@ fn test1_all_need_migration() {\n     let t2 = (Foo(0), Foo(0));\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t, t1, t2));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP:` let _ = (&t, &t1, &t2)` causes `t`, `t1`, `t2` to be fully captured\n         let _t = t.0;\n         let _t1 = t1.0;\n         let _t2 = t2.0;\n@@ -40,8 +41,8 @@ fn test2_only_precise_paths_need_migration() {\n     let t2 = (Foo(0), Foo(0));\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t, t1));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP:` let _ = (&t, &t1)` causes `t`, `t1` to be fully captured\n         let _t = t.0;\n         let _t1 = t1.0;\n         let _t2 = t2;\n@@ -56,8 +57,8 @@ fn test3_only_by_value_need_migration() {\n     let t = (Foo(0), Foo(0));\n     let t1 = (Foo(0), Foo(0));\n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n         let _t = t.0;\n         println!(\"{:?}\", t1.1);\n     };\n@@ -73,8 +74,8 @@ fn test4_type_contains_drop_need_migration() {\n     let t = ConstainsDropField(Foo(0), Foo(0));\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n         let _t = t.0;\n     };\n \n@@ -88,8 +89,8 @@ fn test5_drop_non_drop_aggregate_need_migration() {\n     let t = (Foo(0), Foo(0), 0i32);\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n         let _t = t.0;\n     };\n \n@@ -98,13 +99,11 @@ fn test5_drop_non_drop_aggregate_need_migration() {\n \n // Test migration analysis in case of Significant and Insignificant Drop aggregates.\n fn test6_significant_insignificant_drop_aggregate_need_migration() {\n-    struct S(i32, i32);\n-\n     let t = (Foo(0), String::new());\n \n     let c = || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = &t` causes `t` to be fully captured\n         let _t = t.1;\n     };\n \n@@ -118,8 +117,8 @@ fn test7_move_closures_non_copy_types_might_need_migration() {\n     let t1 = (Foo(0), Foo(0), Foo(0));\n \n     let c = move || {\n-    //~^ERROR: drop order affected for closure because of `capture_disjoint_fields`\n-    //~| NOTE: drop(&(t1, t));\n+    //~^ ERROR: drop order affected for closure because of `capture_disjoint_fields`\n+    //~| HELP: `let _ = (&t1, &t)` causes `t1`, `t` to be fully captured\n         println!(\"{:?} {:?}\", t1.1, t.1);\n     };\n "}, {"sha": "fcf734020ce9d669e9060527f5a286c61bdec302", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.stderr", "status": "modified", "additions": 67, "deletions": 15, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da863487072bf94273862e7eb48bcc392c900234/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.stderr?ref=da863487072bf94273862e7eb48bcc392c900234", "patch": "@@ -1,5 +1,5 @@\n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:24:13\n+  --> $DIR/significant_drop.rs:25:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -12,14 +12,22 @@ LL | |     };\n    | |_____^\n    |\n note: the lint level is defined here\n-  --> $DIR/significant_drop.rs:1:9\n+  --> $DIR/significant_drop.rs:2:9\n    |\n LL | #![deny(disjoint_capture_drop_reorder)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: drop(&(t, t1, t2));\n+help: `let _ = (&t, &t1, &t2)` causes `t`, `t1`, `t2` to be fully captured\n+   |\n+LL |     let c = || { let _ = (&t, &t1, &t2); {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _t1 = t1.0;\n+LL |         let _t2 = t2.0;\n+ ...\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:42:13\n+  --> $DIR/significant_drop.rs:43:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -31,10 +39,18 @@ LL | |         let _t2 = t2;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t, t1));\n+help: `let _ = (&t, &t1)` causes `t`, `t1` to be fully captured\n+   |\n+LL |     let c = || { let _ = (&t, &t1); {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         let _t1 = t1.0;\n+LL |         let _t2 = t2;\n+ ...\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:58:13\n+  --> $DIR/significant_drop.rs:59:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -45,10 +61,18 @@ LL | |         println!(\"{:?}\", t1.1);\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: `let _ = &t` causes `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |         println!(\"{:?}\", t1.1);\n+LL |     } };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:75:13\n+  --> $DIR/significant_drop.rs:76:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -58,10 +82,17 @@ LL | |         let _t = t.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: `let _ = &t` causes `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |     } };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:90:13\n+  --> $DIR/significant_drop.rs:91:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -71,10 +102,17 @@ LL | |         let _t = t.0;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: `let _ = &t` causes `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; {\n+LL |\n+LL |\n+LL |         let _t = t.0;\n+LL |     } };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:105:13\n+  --> $DIR/significant_drop.rs:104:13\n    |\n LL |       let c = || {\n    |  _____________^\n@@ -84,10 +122,17 @@ LL | |         let _t = t.1;\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t));\n+help: `let _ = &t` causes `t` to be fully captured\n+   |\n+LL |     let c = || { let _ = &t; {\n+LL |\n+LL |\n+LL |         let _t = t.1;\n+LL |     } };\n+   |\n \n error: drop order affected for closure because of `capture_disjoint_fields`\n-  --> $DIR/significant_drop.rs:120:13\n+  --> $DIR/significant_drop.rs:119:13\n    |\n LL |       let c = move || {\n    |  _____________^\n@@ -97,7 +142,14 @@ LL | |         println!(\"{:?} {:?}\", t1.1, t.1);\n LL | |     };\n    | |_____^\n    |\n-   = note: drop(&(t1, t));\n+help: `let _ = (&t1, &t)` causes `t1`, `t` to be fully captured\n+   |\n+LL |     let c = move || { let _ = (&t1, &t); {\n+LL |\n+LL |\n+LL |         println!(\"{:?} {:?}\", t1.1, t.1);\n+LL |     } };\n+   |\n \n error: aborting due to 7 previous errors\n "}]}