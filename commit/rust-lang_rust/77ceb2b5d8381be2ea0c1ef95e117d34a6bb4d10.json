{"sha": "77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3Y2ViMmI1ZDgzODFiZTJlYTBjMWVmOTVlMTE3ZDM0YTZiYjRkMTA=", "commit": {"author": {"name": "Michiel De Muynck", "email": "michieldemuynck@gmail.com", "date": "2021-09-16T01:08:41Z"}, "committer": {"name": "Michiel De Muynck", "email": "michieldemuynck@gmail.com", "date": "2021-09-16T01:09:31Z"}, "message": "Make Duration's Debug format pad to width\n\nDuration's Debug formatting previously ignored the width parameter.\nThis commit fixes that.\n\nFixes issue #88059.", "tree": {"sha": "e4e9a4d7d968fbd005e8bfc5ce36a2479606404f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4e9a4d7d968fbd005e8bfc5ce36a2479606404f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10", "html_url": "https://github.com/rust-lang/rust/commit/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10/comments", "author": {"login": "Migi", "id": 706561, "node_id": "MDQ6VXNlcjcwNjU2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/706561?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Migi", "html_url": "https://github.com/Migi", "followers_url": "https://api.github.com/users/Migi/followers", "following_url": "https://api.github.com/users/Migi/following{/other_user}", "gists_url": "https://api.github.com/users/Migi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Migi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Migi/subscriptions", "organizations_url": "https://api.github.com/users/Migi/orgs", "repos_url": "https://api.github.com/users/Migi/repos", "events_url": "https://api.github.com/users/Migi/events{/privacy}", "received_events_url": "https://api.github.com/users/Migi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Migi", "id": 706561, "node_id": "MDQ6VXNlcjcwNjU2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/706561?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Migi", "html_url": "https://github.com/Migi", "followers_url": "https://api.github.com/users/Migi/followers", "following_url": "https://api.github.com/users/Migi/following{/other_user}", "gists_url": "https://api.github.com/users/Migi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Migi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Migi/subscriptions", "organizations_url": "https://api.github.com/users/Migi/orgs", "repos_url": "https://api.github.com/users/Migi/repos", "events_url": "https://api.github.com/users/Migi/events{/privacy}", "received_events_url": "https://api.github.com/users/Migi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bb77da74dac4768489127d21e32db19b59ada5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb77da74dac4768489127d21e32db19b59ada5b", "html_url": "https://github.com/rust-lang/rust/commit/9bb77da74dac4768489127d21e32db19b59ada5b"}], "stats": {"total": 136, "additions": 106, "deletions": 30}, "files": [{"sha": "8d6173dc899bcc09e55363a8434c59dafb0bf8db", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10", "patch": "@@ -1189,7 +1189,7 @@ unsafe fn getcount(args: &[ArgumentV1<'_>], cnt: &rt::v1::Count) -> Option<usize\n \n /// Padding after the end of something. Returned by `Formatter::padding`.\n #[must_use = \"don't forget to write the post padding\"]\n-struct PostPadding {\n+pub(crate) struct PostPadding {\n     fill: char,\n     padding: usize,\n }\n@@ -1200,9 +1200,9 @@ impl PostPadding {\n     }\n \n     /// Write this post padding.\n-    fn write(self, buf: &mut dyn Write) -> Result {\n+    pub(crate) fn write(self, f: &mut Formatter<'_>) -> Result {\n         for _ in 0..self.padding {\n-            buf.write_char(self.fill)?;\n+            f.buf.write_char(self.fill)?;\n         }\n         Ok(())\n     }\n@@ -1325,7 +1325,7 @@ impl<'a> Formatter<'a> {\n                 write_prefix(self, sign, prefix)?;\n                 let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                 self.buf.write_str(buf)?;\n-                post_padding.write(self.buf)?;\n+                post_padding.write(self)?;\n                 self.fill = old_fill;\n                 self.align = old_align;\n                 Ok(())\n@@ -1335,7 +1335,7 @@ impl<'a> Formatter<'a> {\n                 let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                 write_prefix(self, sign, prefix)?;\n                 self.buf.write_str(buf)?;\n-                post_padding.write(self.buf)\n+                post_padding.write(self)\n             }\n         }\n     }\n@@ -1410,7 +1410,7 @@ impl<'a> Formatter<'a> {\n                     let align = rt::v1::Alignment::Left;\n                     let post_padding = self.padding(width - chars_count, align)?;\n                     self.buf.write_str(s)?;\n-                    post_padding.write(self.buf)\n+                    post_padding.write(self)\n                 }\n             }\n         }\n@@ -1419,7 +1419,7 @@ impl<'a> Formatter<'a> {\n     /// Write the pre-padding and return the unwritten post-padding. Callers are\n     /// responsible for ensuring post-padding is written after the thing that is\n     /// being padded.\n-    fn padding(\n+    pub(crate) fn padding(\n         &mut self,\n         padding: usize,\n         default: rt::v1::Alignment,\n@@ -1474,7 +1474,7 @@ impl<'a> Formatter<'a> {\n             } else {\n                 let post_padding = self.padding(width - len, align)?;\n                 self.write_formatted_parts(&formatted)?;\n-                post_padding.write(self.buf)\n+                post_padding.write(self)\n             };\n             self.fill = old_fill;\n             self.align = old_align;"}, {"sha": "d1533b8d67a6bf97e1f3360dc3661bd7fcfd96c0", "filename": "library/core/src/time.rs", "status": "modified", "additions": 70, "deletions": 22, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10", "patch": "@@ -1049,11 +1049,16 @@ impl fmt::Debug for Duration {\n         /// `divisor` must not be above 100_000_000. It also should be a power\n         /// of 10, everything else doesn't make sense. `fractional_part` has\n         /// to be less than `10 * divisor`!\n+        ///\n+        /// A prefix and postfix may be added. The whole thing is padded\n+        /// to the formatter's `width`, if specified.\n         fn fmt_decimal(\n             f: &mut fmt::Formatter<'_>,\n             mut integer_part: u64,\n             mut fractional_part: u32,\n             mut divisor: u32,\n+            prefix: &str,\n+            postfix: &str,\n         ) -> fmt::Result {\n             // Encode the fractional part into a temporary buffer. The buffer\n             // only need to hold 9 elements, because `fractional_part` has to\n@@ -1114,48 +1119,91 @@ impl fmt::Debug for Duration {\n             // set, we only use all digits up to the last non-zero one.\n             let end = f.precision().map(|p| crate::cmp::min(p, 9)).unwrap_or(pos);\n \n-            // If we haven't emitted a single fractional digit and the precision\n-            // wasn't set to a non-zero value, we don't print the decimal point.\n-            if end == 0 {\n-                write!(f, \"{}\", integer_part)\n-            } else {\n-                // SAFETY: We are only writing ASCII digits into the buffer and it was\n-                // initialized with '0's, so it contains valid UTF8.\n-                let s = unsafe { crate::str::from_utf8_unchecked(&buf[..end]) };\n+            // This closure emits the formatted duration without emitting any\n+            // padding (padding is calculated below).\n+            let emit_without_padding = |f: &mut fmt::Formatter<'_>| {\n+                write!(f, \"{}{}\", prefix, integer_part)?;\n+\n+                // Write the decimal point and the fractional part (if any).\n+                if end > 0 {\n+                    // SAFETY: We are only writing ASCII digits into the buffer and\n+                    // it was initialized with '0's, so it contains valid UTF8.\n+                    let s = unsafe { crate::str::from_utf8_unchecked(&buf[..end]) };\n+\n+                    // If the user request a precision > 9, we pad '0's at the end.\n+                    let w = f.precision().unwrap_or(pos);\n+                    write!(f, \".{:0<width$}\", s, width = w)?;\n+                }\n \n-                // If the user request a precision > 9, we pad '0's at the end.\n-                let w = f.precision().unwrap_or(pos);\n-                write!(f, \"{}.{:0<width$}\", integer_part, s, width = w)\n+                write!(f, \"{}\", postfix)\n+            };\n+\n+            match f.width() {\n+                None => {\n+                    // No `width` specified. There's no need to calculate the\n+                    // length of the output in this case, just emit it.\n+                    emit_without_padding(f)\n+                }\n+                Some(requested_w) => {\n+                    // A `width` was specified. Calculate the actual width of\n+                    // the output in order to calculate the required padding.\n+                    // It consists of 4 parts:\n+                    // 1. The prefix: is either \"+\" or \"\", so we can just use len().\n+                    // 2. The postfix: can be \"\u00b5s\" so we have to count UTF8 characters.\n+                    let mut actual_w = prefix.len() + postfix.chars().count();\n+                    // 3. The integer part:\n+                    if let Some(log) = integer_part.checked_log10() {\n+                        // integer_part is > 0, so has length log10(x)+1\n+                        actual_w += 1 + log as usize;\n+                    } else {\n+                        // integer_part is 0, so has length 1.\n+                        actual_w += 1;\n+                    }\n+                    // 4. The fractional part (if any):\n+                    if end > 0 {\n+                        let frac_part_w = f.precision().unwrap_or(pos);\n+                        actual_w += 1 + frac_part_w;\n+                    }\n+\n+                    if requested_w <= actual_w {\n+                        // Output is already longer than `width`, so don't pad.\n+                        emit_without_padding(f)\n+                    } else {\n+                        // We need to add padding. Use the `Formatter::padding` helper function.\n+                        let default_align = crate::fmt::rt::v1::Alignment::Left;\n+                        let post_padding = f.padding(requested_w - actual_w, default_align)?;\n+                        emit_without_padding(f)?;\n+                        post_padding.write(f)\n+                    }\n+                }\n             }\n         }\n \n         // Print leading '+' sign if requested\n-        if f.sign_plus() {\n-            write!(f, \"+\")?;\n-        }\n+        let prefix = if f.sign_plus() { \"+\" } else { \"\" };\n \n         if self.secs > 0 {\n-            fmt_decimal(f, self.secs, self.nanos, NANOS_PER_SEC / 10)?;\n-            f.write_str(\"s\")\n+            fmt_decimal(f, self.secs, self.nanos, NANOS_PER_SEC / 10, prefix, \"s\")\n         } else if self.nanos >= NANOS_PER_MILLI {\n             fmt_decimal(\n                 f,\n                 (self.nanos / NANOS_PER_MILLI) as u64,\n                 self.nanos % NANOS_PER_MILLI,\n                 NANOS_PER_MILLI / 10,\n-            )?;\n-            f.write_str(\"ms\")\n+                prefix,\n+                \"ms\",\n+            )\n         } else if self.nanos >= NANOS_PER_MICRO {\n             fmt_decimal(\n                 f,\n                 (self.nanos / NANOS_PER_MICRO) as u64,\n                 self.nanos % NANOS_PER_MICRO,\n                 NANOS_PER_MICRO / 10,\n-            )?;\n-            f.write_str(\"\u00b5s\")\n+                prefix,\n+                \"\u00b5s\",\n+            )\n         } else {\n-            fmt_decimal(f, self.nanos as u64, 0, 1)?;\n-            f.write_str(\"ns\")\n+            fmt_decimal(f, self.nanos as u64, 0, 1, prefix, \"ns\")\n         }\n     }\n }"}, {"sha": "fe2d2f2412daa1fe79357396d0fb712f32eba761", "filename": "library/core/tests/time.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10/library%2Fcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10/library%2Fcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ftime.rs?ref=77ceb2b5d8381be2ea0c1ef95e117d34a6bb4d10", "patch": "@@ -313,6 +313,34 @@ fn debug_formatting_precision_two() {\n     assert_eq!(format!(\"{:.2?}\", Duration::new(8, 999_999_999)), \"9.00s\");\n }\n \n+#[test]\n+fn debug_formatting_padding() {\n+    assert_eq!(\"0ns      \", format!(\"{:<9?}\", Duration::new(0, 0)));\n+    assert_eq!(\"      0ns\", format!(\"{:>9?}\", Duration::new(0, 0)));\n+    assert_eq!(\"   0ns   \", format!(\"{:^9?}\", Duration::new(0, 0)));\n+    assert_eq!(\"123ns    \", format!(\"{:<9.0?}\", Duration::new(0, 123)));\n+    assert_eq!(\"    123ns\", format!(\"{:>9.0?}\", Duration::new(0, 123)));\n+    assert_eq!(\"  123ns  \", format!(\"{:^9.0?}\", Duration::new(0, 123)));\n+    assert_eq!(\"123.0ns  \", format!(\"{:<9.1?}\", Duration::new(0, 123)));\n+    assert_eq!(\"  123.0ns\", format!(\"{:>9.1?}\", Duration::new(0, 123)));\n+    assert_eq!(\" 123.0ns \", format!(\"{:^9.1?}\", Duration::new(0, 123)));\n+    assert_eq!(\"7.1\u00b5s    \", format!(\"{:<9?}\", Duration::new(0, 7_100)));\n+    assert_eq!(\"    7.1\u00b5s\", format!(\"{:>9?}\", Duration::new(0, 7_100)));\n+    assert_eq!(\"  7.1\u00b5s  \", format!(\"{:^9?}\", Duration::new(0, 7_100)));\n+    assert_eq!(\"999.123456ms\", format!(\"{:<9?}\", Duration::new(0, 999_123_456)));\n+    assert_eq!(\"999.123456ms\", format!(\"{:>9?}\", Duration::new(0, 999_123_456)));\n+    assert_eq!(\"999.123456ms\", format!(\"{:^9?}\", Duration::new(0, 999_123_456)));\n+    assert_eq!(\"5s       \", format!(\"{:<9?}\", Duration::new(5, 0)));\n+    assert_eq!(\"       5s\", format!(\"{:>9?}\", Duration::new(5, 0)));\n+    assert_eq!(\"   5s    \", format!(\"{:^9?}\", Duration::new(5, 0)));\n+    assert_eq!(\"5.000000000000s\", format!(\"{:<9.12?}\", Duration::new(5, 0)));\n+    assert_eq!(\"5.000000000000s\", format!(\"{:>9.12?}\", Duration::new(5, 0)));\n+    assert_eq!(\"5.000000000000s\", format!(\"{:^9.12?}\", Duration::new(5, 0)));\n+\n+    // default alignment is left:\n+    assert_eq!(\"5s       \", format!(\"{:9?}\", Duration::new(5, 0)));\n+}\n+\n #[test]\n fn debug_formatting_precision_high() {\n     assert_eq!(format!(\"{:.5?}\", Duration::new(0, 23_678)), \"23.67800\u00b5s\");"}]}