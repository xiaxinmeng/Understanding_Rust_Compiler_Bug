{"sha": "47e9775a9a529302d963937b558dd6691854e1cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZTk3NzVhOWE1MjkzMDJkOTYzOTM3YjU1OGRkNjY5MTg1NGUxY2Q=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2020-03-21T13:44:17Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2020-03-21T19:45:18Z"}, "message": "make some let-if-bindings more idiomatic (clippy::useless_let_if_seq)", "tree": {"sha": "fc099628f8ae3fb05d68a982e34353556f18eac3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc099628f8ae3fb05d68a982e34353556f18eac3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47e9775a9a529302d963937b558dd6691854e1cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47e9775a9a529302d963937b558dd6691854e1cd", "html_url": "https://github.com/rust-lang/rust/commit/47e9775a9a529302d963937b558dd6691854e1cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47e9775a9a529302d963937b558dd6691854e1cd/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6692b793542291c5bf935d50d9a44982d792719", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6692b793542291c5bf935d50d9a44982d792719", "html_url": "https://github.com/rust-lang/rust/commit/a6692b793542291c5bf935d50d9a44982d792719"}], "stats": {"total": 87, "additions": 41, "deletions": 46}, "files": [{"sha": "d66fcd3a20db92017521bde7569f5340244cd8dc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/47e9775a9a529302d963937b558dd6691854e1cd/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47e9775a9a529302d963937b558dd6691854e1cd/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=47e9775a9a529302d963937b558dd6691854e1cd", "patch": "@@ -381,12 +381,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // Field 5 would be the first element, so memory_index is i:\n         // Note: if we didn't optimize, it's already right.\n \n-        let memory_index;\n-        if optimize {\n-            memory_index = invert_mapping(&inverse_memory_index);\n-        } else {\n-            memory_index = inverse_memory_index;\n-        }\n+        let memory_index =\n+            if optimize { invert_mapping(&inverse_memory_index) } else { inverse_memory_index };\n \n         let size = min_size.align_to(align.abi);\n         let mut abi = Abi::Aggregate { sized };\n@@ -944,33 +940,33 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             let offset = st[i].fields.offset(field_index) + niche.offset;\n                             let size = st[i].size;\n \n-                            let mut abi = match st[i].abi {\n-                                Abi::Scalar(_) => Abi::Scalar(niche_scalar.clone()),\n-                                Abi::ScalarPair(ref first, ref second) => {\n-                                    // We need to use scalar_unit to reset the\n-                                    // valid range to the maximal one for that\n-                                    // primitive, because only the niche is\n-                                    // guaranteed to be initialised, not the\n-                                    // other primitive.\n-                                    if offset.bytes() == 0 {\n-                                        Abi::ScalarPair(\n-                                            niche_scalar.clone(),\n-                                            scalar_unit(second.value),\n-                                        )\n-                                    } else {\n-                                        Abi::ScalarPair(\n-                                            scalar_unit(first.value),\n-                                            niche_scalar.clone(),\n-                                        )\n+                            let abi = if st.iter().all(|v| v.abi.is_uninhabited()) {\n+                                Abi::Uninhabited\n+                            } else {\n+                                match st[i].abi {\n+                                    Abi::Scalar(_) => Abi::Scalar(niche_scalar.clone()),\n+                                    Abi::ScalarPair(ref first, ref second) => {\n+                                        // We need to use scalar_unit to reset the\n+                                        // valid range to the maximal one for that\n+                                        // primitive, because only the niche is\n+                                        // guaranteed to be initialised, not the\n+                                        // other primitive.\n+                                        if offset.bytes() == 0 {\n+                                            Abi::ScalarPair(\n+                                                niche_scalar.clone(),\n+                                                scalar_unit(second.value),\n+                                            )\n+                                        } else {\n+                                            Abi::ScalarPair(\n+                                                scalar_unit(first.value),\n+                                                niche_scalar.clone(),\n+                                            )\n+                                        }\n                                     }\n+                                    _ => Abi::Aggregate { sized: true },\n                                 }\n-                                _ => Abi::Aggregate { sized: true },\n                             };\n \n-                            if st.iter().all(|v| v.abi.is_uninhabited()) {\n-                                abi = Abi::Uninhabited;\n-                            }\n-\n                             let largest_niche =\n                                 Niche::from_scalar(dl, offset, niche_scalar.clone());\n "}, {"sha": "7b65a5a10986ab22f7591ee5e9ebacbabfda1ac3", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47e9775a9a529302d963937b558dd6691854e1cd/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47e9775a9a529302d963937b558dd6691854e1cd/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=47e9775a9a529302d963937b558dd6691854e1cd", "patch": "@@ -490,17 +490,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 {\n                     if pat_snippet.starts_with('&') {\n                         let pat_snippet = pat_snippet[1..].trim_start();\n-                        let suggestion;\n-                        let to_remove;\n-                        if pat_snippet.starts_with(\"mut\")\n+                        let (suggestion, to_remove) = if pat_snippet.starts_with(\"mut\")\n                             && pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n                         {\n-                            suggestion = pat_snippet[\"mut\".len()..].trim_start();\n-                            to_remove = \"&mut\";\n+                            (pat_snippet[\"mut\".len()..].trim_start(), \"&mut\")\n                         } else {\n-                            suggestion = pat_snippet;\n-                            to_remove = \"&\";\n-                        }\n+                            (pat_snippet, \"&\")\n+                        };\n                         suggestions.push((pat_span, to_remove, suggestion.to_owned()));\n                     }\n                 }"}, {"sha": "d66650329313b907e2fd390073a91c364d942ebf", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/47e9775a9a529302d963937b558dd6691854e1cd/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47e9775a9a529302d963937b558dd6691854e1cd/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=47e9775a9a529302d963937b558dd6691854e1cd", "patch": "@@ -637,11 +637,12 @@ where\n     );\n     assert_eq!(block, builder.return_block());\n \n-    let mut spread_arg = None;\n-    if abi == Abi::RustCall {\n+    let spread_arg = if abi == Abi::RustCall {\n         // RustCall pseudo-ABI untuples the last argument.\n-        spread_arg = Some(Local::new(arguments.len()));\n-    }\n+        Some(Local::new(arguments.len()))\n+    } else {\n+        None\n+    };\n     debug!(\"fn_id {:?} has attrs {:?}\", fn_def_id, tcx.get_attrs(fn_def_id));\n \n     let mut body = builder.finish();"}, {"sha": "77d6e4560ab9374960233e5dc814a713cfa92476", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47e9775a9a529302d963937b558dd6691854e1cd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47e9775a9a529302d963937b558dd6691854e1cd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=47e9775a9a529302d963937b558dd6691854e1cd", "patch": "@@ -750,14 +750,16 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if let Some(ctor_node_id) = vdata.ctor_id() {\n-                    let mut ctor_vis = vis;\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n-                    if vis == ty::Visibility::Public\n+                    let mut ctor_vis = if vis == ty::Visibility::Public\n                         && attr::contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n-                        ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                    }\n+                        ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+                    } else {\n+                        vis\n+                    };\n+\n                     for field in vdata.fields() {\n                         // NOTE: The field may be an expansion placeholder, but expansion sets\n                         // correct visibilities for unnamed field placeholders specifically, so the\n@@ -1166,7 +1168,7 @@ macro_rules! method {\n                 visit::$walk(self, node);\n             }\n         }\n-    }\n+    };\n }\n \n impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {"}]}