{"sha": "19508c7d531910c309cd63e9ade2fe1be80ff71b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NTA4YzdkNTMxOTEwYzMwOWNkNjNlOWFkZTJmZTFiZTgwZmY3MWI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-06T10:33:25Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-06T13:00:21Z"}, "message": "Make trans pass responsible for pulling in inlined functions\n\nThis makes the logic for finding the inlinable items much easier --\nthey are simply pulled in lazily when encountered.", "tree": {"sha": "6939af62adaf2bcf8f4515e4e372c286fefc0389", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6939af62adaf2bcf8f4515e4e372c286fefc0389"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19508c7d531910c309cd63e9ade2fe1be80ff71b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19508c7d531910c309cd63e9ade2fe1be80ff71b", "html_url": "https://github.com/rust-lang/rust/commit/19508c7d531910c309cd63e9ade2fe1be80ff71b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19508c7d531910c309cd63e9ade2fe1be80ff71b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b882197233c06454e376fd80adca7f4a80264ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b882197233c06454e376fd80adca7f4a80264ca", "html_url": "https://github.com/rust-lang/rust/commit/9b882197233c06454e376fd80adca7f4a80264ca"}], "stats": {"total": 284, "additions": 75, "deletions": 209}, "files": [{"sha": "eed65357449f8d68c64044bc0fa6614d7c10e258", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19508c7d531910c309cd63e9ade2fe1be80ff71b/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19508c7d531910c309cd63e9ade2fe1be80ff71b/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=19508c7d531910c309cd63e9ade2fe1be80ff71b", "patch": "@@ -6,7 +6,7 @@ import syntax::parse::{parser};\n import syntax::{ast, codemap};\n import front::attr;\n import middle::{trans, resolve, freevars, kind, ty, typeck, fn_usage,\n-                last_use, lint, inline};\n+                last_use, lint};\n import syntax::print::{pp, pprust};\n import util::{ppaux, filesearch};\n import back::link;\n@@ -177,16 +177,11 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                 last_uses: last_uses, impl_map: impl_map,\n                 method_map: method_map, dict_map: dict_map};\n \n-    let ienbld = sess.opts.inline;\n-    let inline_map =\n-        time(time_passes, \"inline\",\n-             bind inline::instantiate_inlines(ienbld, ty_cx, maps, crate));\n-\n     let (llmod, link_meta) =\n         time(time_passes, \"translation\",\n              bind trans::base::trans_crate(\n                  sess, crate, ty_cx, outputs.obj_filename,\n-                 exp_map, maps, inline_map));\n+                 exp_map, maps));\n     time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, outputs.obj_filename));\n "}, {"sha": "91d69168fafd710a0bb5c569aa69186bf4dcd39e", "filename": "src/rustc/middle/inline.rs", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9b882197233c06454e376fd80adca7f4a80264ca/src%2Frustc%2Fmiddle%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b882197233c06454e376fd80adca7f4a80264ca/src%2Frustc%2Fmiddle%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finline.rs?ref=9b882197233c06454e376fd80adca7f4a80264ca", "patch": "@@ -1,100 +0,0 @@\n-import std::map::hashmap;\n-import syntax::ast;\n-import syntax::ast_util;\n-import syntax::ast_util::inlined_item_methods;\n-import syntax::visit;\n-import middle::typeck::method_map;\n-import middle::trans::common::maps;\n-import metadata::csearch;\n-\n-export inline_map;\n-export instantiate_inlines;\n-\n-type inline_map = hashmap<ast::def_id, ast::inlined_item>;\n-\n-enum ctxt = {\n-    tcx: ty::ctxt,\n-    maps: maps,\n-    inline_map: inline_map,\n-    mut to_process: [ast::inlined_item]\n-};\n-\n-fn instantiate_inlines(enabled: bool,\n-                       tcx: ty::ctxt,\n-                       maps: maps,\n-                       crate: @ast::crate) -> inline_map {\n-    let vt = visit::mk_vt(@{\n-        visit_expr: fn@(e: @ast::expr, cx: ctxt, vt: visit::vt<ctxt>) {\n-            visit::visit_expr(e, cx, vt);\n-            cx.visit_expr(e);\n-        }\n-        with *visit::default_visitor::<ctxt>()\n-    });\n-    let inline_map = ast_util::new_def_id_hash();\n-    let cx = ctxt({tcx: tcx, maps: maps,\n-                   inline_map: inline_map, mutable to_process: []});\n-    if enabled { visit::visit_crate(*crate, cx, vt); }\n-    while !vec::is_empty(cx.to_process) {\n-        let to_process = [];\n-        to_process <-> cx.to_process;\n-        #debug[\"Recursively looking at inlined items\"];\n-        vec::iter(to_process) {|ii|\n-            ii.accept(cx, vt);\n-        }\n-    }\n-    ret inline_map;\n-}\n-\n-impl methods for ctxt {\n-    fn visit_expr(e: @ast::expr) {\n-\n-        // Look for fn items or methods that are referenced which\n-        // ought to be inlined.\n-\n-        alt e.node {\n-          ast::expr_path(_) {\n-            alt self.tcx.def_map.get(e.id) {\n-              ast::def_fn(did, _) {\n-                self.maybe_enqueue_fn(did);\n-              }\n-              _ { /* not a fn item, fallthrough */ }\n-            }\n-          }\n-          ast::expr_field(_, _, _) {\n-            alt self.maps.method_map.find(e.id) {\n-              some(origin) {\n-                self.maybe_enqueue_impl_method(origin);\n-              }\n-              _ { /* not an impl method, fallthrough */ }\n-            }\n-          }\n-          _ { /* fallthrough */ }\n-        }\n-    }\n-\n-    fn maybe_enqueue_fn(did: ast::def_id) {\n-        if did.crate == ast::local_crate { ret; }\n-        if self.inline_map.contains_key(did) { ret; }\n-        alt csearch::maybe_get_item_ast(self.tcx, self.maps, did) {\n-          none {\n-            /* no AST attached, do not inline */\n-            #debug[\"No AST attached to def %s\",\n-                   ty::item_path_str(self.tcx, did)];\n-          }\n-          some(ii) { /* Found an AST, add to table: */\n-            #debug[\"Inlining def %s\", ty::item_path_str(self.tcx, did)];\n-            self.to_process += [ii];\n-            self.inline_map.insert(did, ii);\n-          }\n-        }\n-    }\n-\n-    fn maybe_enqueue_impl_method(method_origin: typeck::method_origin) {\n-        alt method_origin {\n-          typeck::method_static(did) { self.maybe_enqueue_fn(did); }\n-          typeck::method_param(_, _, _, _) | typeck::method_iface(_, _) {\n-            /* fallthrough */\n-          }\n-        }\n-    }\n-}"}, {"sha": "5d36d077edf1841e538fb368e7bb2f55784a597e", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 67, "deletions": 97, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/19508c7d531910c309cd63e9ade2fe1be80ff71b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19508c7d531910c309cd63e9ade2fe1be80ff71b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=19508c7d531910c309cd63e9ade2fe1be80ff71b", "patch": "@@ -20,7 +20,6 @@ import std::map::{new_int_hash, new_str_hash};\n import driver::session;\n import session::session;\n import front::attr;\n-import middle::inline::inline_map;\n import back::{link, abi, upcall};\n import syntax::{ast, ast_util, codemap};\n import ast_util::inlined_item_methods;\n@@ -651,20 +650,11 @@ fn set_inline_hint(f: ValueRef) {\n                               0u as c_uint);\n }\n \n-fn set_inline_hint_if_appr(ccx: crate_ctxt,\n-                           attrs: [ast::attribute],\n-                           id: ast::node_id) {\n+fn set_inline_hint_if_appr(attrs: [ast::attribute],\n+                           llfn: ValueRef) {\n     alt attr::find_inline_attr(attrs) {\n-      attr::ia_hint {\n-        #debug[\"Setting inline mode for %s to 'hint'\",\n-               ty::item_path_str(ccx.tcx, ast_util::local_def(id))];\n-        set_inline_hint(ccx.item_ids.get(id))\n-      }\n-      attr::ia_always {\n-        #debug[\"Setting inline mode for %s to 'always'\",\n-               ty::item_path_str(ccx.tcx, ast_util::local_def(id))];\n-        set_always_inline(ccx.item_ids.get(id))\n-      }\n+      attr::ia_hint { set_inline_hint(llfn); }\n+      attr::ia_always { set_always_inline(llfn); }\n       attr::ia_none { /* fallthrough */ }\n     }\n }\n@@ -2152,6 +2142,40 @@ fn monomorphic_fn(ccx: crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n     some({llfn: lldecl, fty: mono_ty})\n }\n \n+// FIXME[mono] Only actually translate things that are not generic\n+fn maybe_instantiate_inline(ccx: crate_ctxt, fn_id: ast::def_id)\n+    -> ast::def_id {\n+    alt ccx.external.find(fn_id) {\n+      some(some(node_id)) { local_def(node_id) } // Already inline\n+      some(none) { fn_id } // Not inlinable\n+      none { // Not seen yet\n+        alt csearch::maybe_get_item_ast(ccx.tcx, ccx.maps, fn_id) {\n+          none { ccx.external.insert(fn_id, none); fn_id }\n+          some(ast::ii_item(item)) {\n+            ccx.external.insert(fn_id, some(item.id));\n+            collect_item(ccx, @mutable none, item);\n+            trans_item(ccx, *item);\n+            local_def(item.id)\n+          }\n+          some(ast::ii_method(impl_did, mth)) {\n+            ccx.external.insert(fn_id, some(mth.id));\n+            compute_ii_method_info(ccx, impl_did, mth) {|ty, bounds, path|\n+                let mth_ty = ty::node_id_to_type(ccx.tcx, mth.id);\n+                let llfn = register_fn_full(ccx, mth.span, path,\n+                                            \"impl_method\", bounds,\n+                                            mth.id, mth_ty);\n+                set_inline_hint_if_appr(mth.attrs, llfn);\n+                trans_fn(ccx, path, mth.decl, mth.body,\n+                         llfn, impl_self(ty), bounds,\n+                         none, mth.id, none);\n+            }\n+            local_def(mth.id)\n+          }\n+        }\n+      }\n+    }\n+}\n+\n fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                   substs: option<([ty::t], typeck::dict_res)>)\n     -> lval_maybe_callee {\n@@ -2162,22 +2186,9 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n \n     // Check whether this fn has an inlined copy and, if so, redirect fn_id to\n     // the local id of the inlined copy.\n-    let fn_id = {\n-        if fn_id.crate == ast::local_crate {\n-            fn_id\n-        } else {\n-            alt ccx.inline_map.find(fn_id) {\n-              none { fn_id }\n-              some(ii) {\n-                #debug[\"Found inlined version of %s with id %d\",\n-                       ty::item_path_str(tcx, fn_id),\n-                       ii.id()];\n-                {crate: ast::local_crate,\n-                 node: ii.id()}\n-              }\n-            }\n-        }\n-    };\n+    let fn_id = if fn_id.crate != ast::local_crate && ccx.sess.opts.inline {\n+        maybe_instantiate_inline(ccx, fn_id)\n+    } else { fn_id };\n \n     // The awkwardness below mostly stems from the fact that we're mixing\n     // monomorphized and non-monomorphized functions at the moment. If\n@@ -4478,35 +4489,17 @@ fn compute_ii_method_info(ccx: crate_ctxt,\n     f(impl_ty, m_bounds, m_path);\n }\n \n-fn trans_inlined_items(ccx: crate_ctxt, inline_map: inline_map) {\n-    inline_map.values {|ii|\n-        alt ii {\n-          ast::ii_item(item) {\n-            trans_item(ccx, *item)\n-          }\n-          ast::ii_method(impl_did, m) {\n-            compute_ii_method_info(ccx, impl_did, m) {\n-                |impl_ty, m_bounds, m_path|\n-                let llfndecl = ccx.item_ids.get(m.id);\n-                trans_fn(ccx, m_path, m.decl, m.body,\n-                         llfndecl, impl_self(impl_ty), m_bounds,\n-                         none, m.id, none);\n-            }\n-          }\n-        }\n-    }\n-}\n-\n fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the pair.\n     ret struct_elt(llpairty, 0u);\n }\n \n fn register_fn(ccx: crate_ctxt, sp: span, path: path, flav: str,\n-               ty_params: [ast::ty_param], node_id: ast::node_id) {\n+               ty_params: [ast::ty_param], node_id: ast::node_id)\n+    -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let bnds = param_bounds(ccx, ty_params);\n-    register_fn_full(ccx, sp, path, flav, bnds, node_id, t);\n+    register_fn_full(ccx, sp, path, flav, bnds, node_id, t)\n }\n \n fn param_bounds(ccx: crate_ctxt, tps: [ast::ty_param]) -> [ty::param_bounds] {\n@@ -4515,15 +4508,15 @@ fn param_bounds(ccx: crate_ctxt, tps: [ast::ty_param]) -> [ty::param_bounds] {\n \n fn register_fn_full(ccx: crate_ctxt, sp: span, path: path, flav: str,\n                     bnds: [ty::param_bounds], node_id: ast::node_id,\n-                    node_type: ty::t) {\n+                    node_type: ty::t) -> ValueRef {\n     let llfty = type_of_fn_from_ty(ccx, node_type, bnds);\n     register_fn_fuller(ccx, sp, path, flav, node_id, node_type,\n-                       lib::llvm::CCallConv, llfty);\n+                       lib::llvm::CCallConv, llfty)\n }\n \n fn register_fn_fuller(ccx: crate_ctxt, sp: span, path: path, _flav: str,\n                       node_id: ast::node_id, node_type: ty::t,\n-                      cc: lib::llvm::CallConv, llfty: TypeRef) {\n+                      cc: lib::llvm::CallConv, llfty: TypeRef) -> ValueRef {\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n     let llfn: ValueRef = decl_fn(ccx.llmod, ps, cc, llfty);\n     ccx.item_ids.insert(node_id, llfn);\n@@ -4534,6 +4527,7 @@ fn register_fn_fuller(ccx: crate_ctxt, sp: span, path: path, _flav: str,\n \n     let is_main = is_main_name(path) && !ccx.sess.building_library;\n     if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n+    llfn\n }\n \n // Create a _rust_main(args: [str]) function which will be called from the\n@@ -4713,39 +4707,39 @@ fn collect_item(ccx: crate_ctxt, abi: @mutable option<ast::native_abi>,\n         }\n       }\n       ast::item_fn(decl, tps, _) {\n-        if decl.purity != ast::crust_fn {\n-            register_fn(ccx, i.span, my_path, \"fn\", tps,\n-                        i.id);\n+        let llfn = if decl.purity != ast::crust_fn {\n+            register_fn(ccx, i.span, my_path, \"fn\", tps, i.id)\n         } else {\n-            native::register_crust_fn(ccx, i.span, my_path, i.id);\n-        }\n+            native::register_crust_fn(ccx, i.span, my_path, i.id)\n+        };\n \n-        set_inline_hint_if_appr(ccx, i.attrs, i.id);\n+        set_inline_hint_if_appr(i.attrs, llfn);\n       }\n       ast::item_impl(tps, _, _, methods) {\n         let path = my_path + [path_name(int::str(i.id))];\n         for m in methods {\n-            register_fn(ccx, i.span,\n-                        path + [path_name(m.ident)],\n-                        \"impl_method\", tps + m.tps, m.id);\n-\n-            set_inline_hint_if_appr(ccx, m.attrs, m.id);\n+            let llm  = register_fn(ccx, i.span,\n+                                   path + [path_name(m.ident)],\n+                                   \"impl_method\", tps + m.tps, m.id);\n+            set_inline_hint_if_appr(m.attrs, llm);\n         }\n       }\n       ast::item_res(_, tps, _, dtor_id, ctor_id) {\n-        register_fn(ccx, i.span, my_path, \"res_ctor\", tps, ctor_id);\n+        let llctor = register_fn(ccx, i.span, my_path, \"res_ctor\", tps,\n+                                 ctor_id);\n \n         // Note that the destructor is associated with the item's id, not\n         // the dtor_id. This is a bit counter-intuitive, but simplifies\n         // ty_res, which would have to carry around two def_ids otherwise\n         // -- one to identify the type, and one to find the dtor symbol.\n         let t = ty::node_id_to_type(ccx.tcx, dtor_id);\n-        register_fn_full(ccx, i.span, my_path + [path_name(\"dtor\")],\n-                         \"res_dtor\", param_bounds(ccx, tps), i.id, t);\n+        let lldtor = register_fn_full(ccx, i.span, my_path +\n+                                      [path_name(\"dtor\")], \"res_dtor\",\n+                                      param_bounds(ccx, tps), i.id, t);\n \n         // give hints that resource ctors/dtors ought to be inlined\n-        set_inline_hint(ccx.item_ids.get(ctor_id));\n-        set_inline_hint(ccx.item_ids.get(i.id));\n+        set_inline_hint(llctor);\n+        set_inline_hint(lldtor);\n       }\n       ast::item_enum(variants, tps) {\n         for variant in variants {\n@@ -4767,35 +4761,14 @@ fn collect_item(ccx: crate_ctxt, abi: @mutable option<ast::native_abi>,\n }\n \n fn collect_items(ccx: crate_ctxt, crate: @ast::crate) {\n-    let abi = @mutable none::<ast::native_abi>;\n+    let abi = @mutable none;\n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n         visit_native_item: bind collect_native_item(ccx, abi, _),\n         visit_item: bind collect_item(ccx, abi, _)\n         with *visit::default_simple_visitor()\n     }));\n }\n \n-fn collect_inlined_items(ccx: crate_ctxt, inline_map: inline::inline_map) {\n-    let abi = @mutable none::<ast::native_abi>;\n-    inline_map.values {|ii|\n-        alt ii {\n-          ast::ii_item(item) {\n-            collect_item(ccx, abi, item);\n-          }\n-\n-          ast::ii_method(impl_did, m) {\n-            compute_ii_method_info(ccx, impl_did, m) {\n-                |_impl_ty, m_bounds, m_path|\n-                let mthd_ty = ty::node_id_to_type(ccx.tcx, m.id);\n-                register_fn_full(ccx, m.span, m_path, \"impl_method\",\n-                                 m_bounds, m.id, mthd_ty);\n-                set_inline_hint_if_appr(ccx, m.attrs, m.id);\n-            }\n-          }\n-        }\n-    }\n-}\n-\n // The constant translation pass.\n fn trans_constant(ccx: crate_ctxt, it: @ast::item) {\n     alt it.node {\n@@ -4995,8 +4968,7 @@ fn write_abi_version(ccx: crate_ctxt) {\n }\n \n fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n-               output: str, emap: resolve::exp_map, maps: maps,\n-               inline_map: inline::inline_map)\n+               output: str, emap: resolve::exp_map, maps: maps)\n     -> (ModuleRef, link::link_meta) {\n     let sha = std::sha1::mk_sha1();\n     let link_meta = link::build_link_meta(sess, *crate, output, sha);\n@@ -5063,6 +5035,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           consts: new_int_hash::<ValueRef>(),\n           tydescs: ty::new_ty_hash(),\n           dicts: map::mk_hashmap(hash_dict_id, {|a, b| a == b}),\n+          external: util::common::new_def_hash(),\n           monomorphized: map::mk_hashmap(hash_mono_id, {|a, b| a == b}),\n           module_data: new_str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),\n@@ -5072,7 +5045,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           type_short_names: ty::new_ty_hash(),\n           tcx: tcx,\n           maps: maps,\n-          inline_map: inline_map,\n           stats:\n               {mutable n_static_tydescs: 0u,\n                mutable n_derived_tydescs: 0u,\n@@ -5094,10 +5066,8 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           dbg_cx: dbg_cx,\n           mutable do_not_commit_warning_issued: false};\n     collect_items(ccx, crate);\n-    collect_inlined_items(ccx, inline_map);\n     trans_constants(ccx, crate);\n     trans_mod(ccx, crate.node.module);\n-    trans_inlined_items(ccx, inline_map);\n     fill_crate_map(ccx, crate_map);\n     emit_tydescs(ccx);\n     gen_shape_tables(ccx);"}, {"sha": "5bb2dfb885feb279b43010017e6575799bb3288c", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19508c7d531910c309cd63e9ade2fe1be80ff71b/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19508c7d531910c309cd63e9ade2fe1be80ff71b/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=19508c7d531910c309cd63e9ade2fe1be80ff71b", "patch": "@@ -19,7 +19,6 @@ import lib::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef, BuilderRef};\n import lib::llvm::{True, False, Bool};\n import metadata::csearch;\n import ast_map::path;\n-import middle::inline::inline_map;\n \n type namegen = fn@(str) -> str;\n fn new_namegen() -> namegen {\n@@ -93,6 +92,9 @@ type crate_ctxt = @{\n      consts: hashmap<ast::node_id, ValueRef>,\n      tydescs: hashmap<ty::t, @tydesc_info>,\n      dicts: hashmap<dict_id, ValueRef>,\n+     // Track mapping of external ids to local items imported for inlining\n+     external: hashmap<ast::def_id, option<ast::node_id>>,\n+     // Cache instances of monomorphized functions\n      monomorphized: hashmap<mono_id, {llfn: ValueRef, fty: ty::t}>,\n      module_data: hashmap<str, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,\n@@ -102,7 +104,6 @@ type crate_ctxt = @{\n      type_short_names: hashmap<ty::t, str>,\n      tcx: ty::ctxt,\n      maps: maps,\n-     inline_map: inline_map,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      tydesc_type: TypeRef,"}, {"sha": "26621158f7779c65db5de5030b7a707b9ea4718c", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19508c7d531910c309cd63e9ade2fe1be80ff71b/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19508c7d531910c309cd63e9ade2fe1be80ff71b/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=19508c7d531910c309cd63e9ade2fe1be80ff71b", "patch": "@@ -351,10 +351,11 @@ fn trans_crust_fn(ccx: crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n }\n \n fn register_crust_fn(ccx: crate_ctxt, sp: span,\n-                     path: ast_map::path, node_id: ast::node_id) {\n+                     path: ast_map::path, node_id: ast::node_id)\n+    -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let (llargtys, llretty, _) = c_arg_and_ret_lltys(ccx, node_id);\n     let llfty = T_fn(llargtys, llretty);\n     register_fn_fuller(ccx, sp, path, \"crust fn\", node_id,\n-                       t, lib::llvm::CCallConv, llfty);\n+                       t, lib::llvm::CCallConv, llfty)\n }\n\\ No newline at end of file"}, {"sha": "a8b398066ecee74600f795bd9ee1c6e1b49577a9", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19508c7d531910c309cd63e9ade2fe1be80ff71b/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/19508c7d531910c309cd63e9ade2fe1be80ff71b/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=19508c7d531910c309cd63e9ade2fe1be80ff71b", "patch": "@@ -28,7 +28,6 @@ mod middle {\n         mod shape;\n         mod debuginfo;\n     }\n-    mod inline;\n     mod ty;\n     mod ast_map;\n     mod resolve;"}]}