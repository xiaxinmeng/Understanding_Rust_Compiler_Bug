{"sha": "3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYzNhZDExZTZmYWRjYmE0NDNjYzUwYmE2ZWQwM2FiMDRkMzQzNTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-15T10:06:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-15T10:06:58Z"}, "message": "Auto merge of #34819 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\n- Successful merges: #34456, #34733, #34777, #34794, #34799, #34804, #34818\n- Failed merges: #33951", "tree": {"sha": "8f740d9a475036c51e4524543e9571e4f9664354", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f740d9a475036c51e4524543e9571e4f9664354"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "html_url": "https://github.com/rust-lang/rust/commit/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6c1ef3745f707a0f76f17dc2b313b831ee1bfb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6c1ef3745f707a0f76f17dc2b313b831ee1bfb0", "html_url": "https://github.com/rust-lang/rust/commit/b6c1ef3745f707a0f76f17dc2b313b831ee1bfb0"}, {"sha": "89593741540e125c768432bd98dbd4fdd1abd286", "url": "https://api.github.com/repos/rust-lang/rust/commits/89593741540e125c768432bd98dbd4fdd1abd286", "html_url": "https://github.com/rust-lang/rust/commit/89593741540e125c768432bd98dbd4fdd1abd286"}], "stats": {"total": 280, "additions": 200, "deletions": 80}, "files": [{"sha": "3cbe5d6026774abca897db24797882d4065a95f6", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -183,8 +183,62 @@ pub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n }\n ```\n \n-For reference, the examples used here are also available as a [library on\n-GitHub](https://github.com/thestinger/rust-snappy).\n+Then, we can add some tests to show how to use them.\n+\n+```rust\n+# #![feature(libc)]\n+# extern crate libc;\n+# use libc::{c_int, size_t};\n+# unsafe fn snappy_compress(input: *const u8,\n+#                           input_length: size_t,\n+#                           compressed: *mut u8,\n+#                           compressed_length: *mut size_t)\n+#                           -> c_int { 0 }\n+# unsafe fn snappy_uncompress(compressed: *const u8,\n+#                             compressed_length: size_t,\n+#                             uncompressed: *mut u8,\n+#                             uncompressed_length: *mut size_t)\n+#                             -> c_int { 0 }\n+# unsafe fn snappy_max_compressed_length(source_length: size_t) -> size_t { 0 }\n+# unsafe fn snappy_uncompressed_length(compressed: *const u8,\n+#                                      compressed_length: size_t,\n+#                                      result: *mut size_t)\n+#                                      -> c_int { 0 }\n+# unsafe fn snappy_validate_compressed_buffer(compressed: *const u8,\n+#                                             compressed_length: size_t)\n+#                                             -> c_int { 0 }\n+# fn main() { }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn valid() {\n+        let d = vec![0xde, 0xad, 0xd0, 0x0d];\n+        let c: &[u8] = &compress(&d);\n+        assert!(validate_compressed_buffer(c));\n+        assert!(uncompress(c) == Some(d));\n+    }\n+\n+    #[test]\n+    fn invalid() {\n+        let d = vec![0, 0, 0, 0];\n+        assert!(!validate_compressed_buffer(&d));\n+        assert!(uncompress(&d).is_none());\n+    }\n+\n+    #[test]\n+    fn empty() {\n+        let d = vec![];\n+        assert!(!validate_compressed_buffer(&d));\n+        assert!(uncompress(&d).is_none());\n+        let c = compress(&d);\n+        assert!(validate_compressed_buffer(&c));\n+        assert!(uncompress(&c) == Some(d));\n+    }\n+}\n+```\n \n # Destructors\n "}, {"sha": "e762e4d8ce9a26a2d3690a40839d6e47ae280bd5", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -12,23 +12,11 @@\n \n //! Threadsafe reference-counted boxes (the `Arc<T>` type).\n //!\n-//! The `Arc<T>` type provides shared ownership of an immutable value.\n-//! Destruction is deterministic, and will occur as soon as the last owner is\n-//! gone. It is marked as `Send` because it uses atomic reference counting.\n-//!\n-//! If you do not need thread-safety, and just need shared ownership, consider\n-//! the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n-//! does not use atomics, making it both thread-unsafe as well as significantly\n-//! faster when updating the reference count.\n-//!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n-//! to the box. A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n-//! will return `None` if the value has already been dropped.\n-//!\n-//! For example, a tree with parent pointers can be represented by putting the\n-//! nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n-//! as `Weak<T>` pointers.\n+//! The `Arc<T>` type provides shared ownership of an immutable value through\n+//! atomic reference counting.\n //!\n+//! `Weak<T>` is a weak reference to the `Arc<T>` box, and it is created by\n+//! the `downgrade` method.\n //! # Examples\n //!\n //! Sharing some immutable data between threads:\n@@ -47,27 +35,6 @@\n //!     });\n //! }\n //! ```\n-//!\n-//! Sharing mutable data safely between threads with a `Mutex`:\n-//!\n-//! ```no_run\n-//! use std::sync::{Arc, Mutex};\n-//! use std::thread;\n-//!\n-//! let five = Arc::new(Mutex::new(5));\n-//!\n-//! for _ in 0..10 {\n-//!     let five = five.clone();\n-//!\n-//!     thread::spawn(move || {\n-//!         let mut number = five.lock().unwrap();\n-//!\n-//!         *number += 1;\n-//!\n-//!         println!(\"{}\", *number); // prints 6\n-//!     });\n-//! }\n-//! ```\n \n use boxed::Box;\n \n@@ -92,15 +59,19 @@ use heap::deallocate;\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n /// An atomically reference counted wrapper for shared state.\n+/// Destruction is deterministic, and will occur as soon as the last owner is\n+/// gone. It is marked as `Send` because it uses atomic reference counting.\n ///\n-/// # Examples\n+/// If you do not need thread-safety, and just need shared ownership, consider\n+/// the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n+/// does not use atomics, making it both thread-unsafe as well as significantly\n+/// faster when updating the reference count.\n ///\n-/// In this example, a large vector is shared between several threads.\n-/// With simple pipes, without `Arc`, a copy would have to be made for each\n-/// thread.\n+/// # Examples\n ///\n-/// When you clone an `Arc<T>`, it will create another pointer to the data and\n-/// increase the reference counter.\n+/// In this example, a large vector of data will be shared by several threads. First we\n+/// wrap it with a `Arc::new` and then clone the `Arc<T>` reference for every thread (which will\n+/// increase the reference count atomically).\n ///\n /// ```\n /// use std::sync::Arc;\n@@ -111,6 +82,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///     let shared_numbers = Arc::new(numbers);\n ///\n ///     for _ in 0..10 {\n+///         // prepare a copy of reference here and it will be moved to the thread\n ///         let child_numbers = shared_numbers.clone();\n ///\n ///         thread::spawn(move || {\n@@ -121,6 +93,29 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///     }\n /// }\n /// ```\n+/// You can also share mutable data between threads safely\n+/// by putting it inside `Mutex` and then share `Mutex` immutably\n+/// with `Arc<T>` as shown below.\n+///\n+/// ```\n+/// use std::sync::{Arc, Mutex};\n+/// use std::thread;\n+///\n+/// let five = Arc::new(Mutex::new(5));\n+///\n+/// for _ in 0..10 {\n+///     let five = five.clone();\n+///\n+///     thread::spawn(move || {\n+///         let mut number = five.lock().unwrap();\n+///\n+///         *number += 1;\n+///\n+///         println!(\"{}\", *number); // prints 6\n+///     });\n+/// }\n+/// ```\n+\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n@@ -139,6 +134,14 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n ///\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n /// used to break cycles between `Arc` pointers.\n+///\n+/// A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n+/// will return `None` if the value has already been dropped.\n+///\n+/// For example, a tree with parent pointers can be represented by putting the\n+/// nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n+/// as `Weak<T>` pointers.\n+\n #[unsafe_no_drop_flag]\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {"}, {"sha": "da56b21cf0c050c8a2c0bd3a1282e583e47f789f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -1603,6 +1603,12 @@ impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// An iterator that moves out of a vector.\n+///\n+/// This `struct` is created by the `into_iter` method on [`Vec`][`Vec`] (provided\n+/// by the [`IntoIterator`] trait).\n+///\n+/// [`Vec`]: struct.Vec.html\n+/// [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     _buf: RawVec<T>,\n@@ -1710,6 +1716,11 @@ impl<T> Drop for IntoIter<T> {\n }\n \n /// A draining iterator for `Vec<T>`.\n+///\n+/// This `struct` is created by the [`drain`] method on [`Vec`].\n+///\n+/// [`drain`]: struct.Vec.html#method.drain\n+/// [`Vec`]: struct.Vec.html\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, T: 'a> {\n     /// Index of tail to preserve"}, {"sha": "43868d124a22e00c69ac67e781e0d7b0c84ba114", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -238,6 +238,8 @@ macro_rules! write {\n }\n \n /// Use the `format!` syntax to write data into a buffer, appending a newline.\n+/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`)\n+/// alone (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n ///\n /// This macro is typically used with a buffer of `&mut `[`Write`][write].\n ///"}, {"sha": "fcdbde0d19f4f5a1808621423602e199918e1cd0", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -2308,26 +2308,45 @@ impl usize {\n ///\n /// [`f32::classify()`]: ../../std/primitive.f32.html#method.classify\n /// [`f64::classify()`]: ../../std/primitive.f64.html#method.classify\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::num::FpCategory;\n+/// use std::f32;\n+///\n+/// let num = 12.4_f32;\n+/// let inf = f32::INFINITY;\n+/// let zero = 0f32;\n+/// let sub: f32 = 0.000000000000000000000000000000000000011754942;\n+/// let nan = f32::NAN;\n+///\n+/// assert_eq!(num.classify(), FpCategory::Normal);\n+/// assert_eq!(inf.classify(), FpCategory::Infinite);\n+/// assert_eq!(zero.classify(), FpCategory::Zero);\n+/// assert_eq!(nan.classify(), FpCategory::Nan);\n+/// assert_eq!(sub.classify(), FpCategory::Subnormal);\n+/// ```\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum FpCategory {\n-    /// \"Not a Number\", often obtained by dividing by zero\n+    /// \"Not a Number\", often obtained by dividing by zero.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Nan,\n \n-    /// Positive or negative infinity\n+    /// Positive or negative infinity.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Infinite ,\n \n-    /// Positive or negative zero\n+    /// Positive or negative zero.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Zero,\n \n-    /// De-normalized floating point representation (less precise than `Normal`)\n+    /// De-normalized floating point representation (less precise than `Normal`).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Subnormal,\n \n-    /// A regular floating point number\n+    /// A regular floating point number.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Normal,\n }"}, {"sha": "3c46072e17e1a7753aa3939c7676efb8e54ff2bd", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -57,6 +57,7 @@\n #![allow(private_no_mangle_fns)]\n \n use core::any::Any;\n+use core::ptr;\n use alloc::boxed::Box;\n \n use unwind as uw;\n@@ -88,7 +89,7 @@ pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n }\n \n pub fn payload() -> *mut u8 {\n-    0 as *mut u8\n+    ptr::null_mut()\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {"}, {"sha": "56801e8cb6bcf3d5583a7ca409a2aac4a8db965d", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -18,6 +18,7 @@ use alloc::boxed::Box;\n \n use core::any::Any;\n use core::intrinsics;\n+use core::ptr;\n use dwarf::eh;\n use windows as c;\n \n@@ -50,7 +51,7 @@ pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n }\n \n pub fn payload() -> *mut u8 {\n-    0 as *mut u8\n+    ptr::null_mut()\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {"}, {"sha": "70d142e50edb921b3b7e7082f7b3540e5b690efa", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -96,6 +96,7 @@ use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n+use std::ptr;\n use std::rc::Rc;\n use std::str;\n use std::{i8, i16, i32, i64};\n@@ -2201,7 +2202,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n                                                  start_fn,\n                                                  args.as_ptr(),\n                                                  args.len() as c_uint,\n-                                                 0 as *mut _,\n+                                                 ptr::null_mut(),\n                                                  noname());\n \n             llvm::LLVMBuildRet(bld, result);"}, {"sha": "e88257dcd4cf874490d6186b6a0deee09306681b", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -177,7 +177,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         check_call(\"invoke\", llfn, args);\n \n-        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n+        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(ptr::null_mut());\n \n         unsafe {\n             llvm::LLVMRustBuildInvoke(self.llbuilder,\n@@ -859,7 +859,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         check_call(\"call\", llfn, args);\n \n-        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n+        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(ptr::null_mut());\n \n         unsafe {\n             llvm::LLVMRustBuildCall(self.llbuilder, llfn, args.as_ptr(),\n@@ -961,7 +961,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.count_insn(\"trap\");\n             llvm::LLVMRustBuildCall(self.llbuilder, t,\n                                     args.as_ptr(), args.len() as c_uint,\n-                                    0 as *mut _,\n+                                    ptr::null_mut(),\n                                     noname());\n         }\n     }\n@@ -1000,7 +1000,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                        parent: Option<ValueRef>,\n                        args: &[ValueRef]) -> ValueRef {\n         self.count_insn(\"cleanuppad\");\n-        let parent = parent.unwrap_or(0 as *mut _);\n+        let parent = parent.unwrap_or(ptr::null_mut());\n         let name = CString::new(\"cleanuppad\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupPad(self.llbuilder,\n@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn cleanup_ret(&self, cleanup: ValueRef,\n                        unwind: Option<BasicBlockRef>) -> ValueRef {\n         self.count_insn(\"cleanupret\");\n-        let unwind = unwind.unwrap_or(0 as *mut _);\n+        let unwind = unwind.unwrap_or(ptr::null_mut());\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupRet(self.llbuilder, cleanup, unwind)\n         };\n@@ -1052,8 +1052,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         unwind: Option<BasicBlockRef>,\n                         num_handlers: usize) -> ValueRef {\n         self.count_insn(\"catchswitch\");\n-        let parent = parent.unwrap_or(0 as *mut _);\n-        let unwind = unwind.unwrap_or(0 as *mut _);\n+        let parent = parent.unwrap_or(ptr::null_mut());\n+        let unwind = unwind.unwrap_or(ptr::null_mut());\n         let name = CString::new(\"catchswitch\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchSwitch(self.llbuilder, parent, unwind,"}, {"sha": "6f0f6ecab5ba8271c479a9d674b1dee8b76ae70c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -98,7 +98,9 @@ macro_rules! print {\n     ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));\n }\n \n-/// Macro for printing to the standard output, with a newline.\n+/// Macro for printing to the standard output, with a newline. On all\n+/// platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n+/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n ///\n /// Use the `format!` syntax to write data to the standard output.\n /// See `std::fmt` for more information."}, {"sha": "660c098d30bc29d157bfb8888ae6e145482aa152", "filename": "src/libstd/process.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -605,6 +605,23 @@ pub struct ExitStatus(imp::ExitStatus);\n impl ExitStatus {\n     /// Was termination successful? Signal termination not considered a success,\n     /// and success is defined as a zero exit status.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,no_run\n+    /// use std::process::Command;\n+    ///\n+    /// let status = Command::new(\"mkdir\")\n+    ///                      .arg(\"projects\")\n+    ///                      .status()\n+    ///                      .expect(\"failed to execute mkdir\");\n+    ///\n+    /// if status.success() {\n+    ///     println!(\"'projects/' directory created\");\n+    /// } else {\n+    ///     println!(\"failed to create 'projects/' directory\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn success(&self) -> bool {\n         self.0.success()"}, {"sha": "54c1fe6c5640cebcb7312d0ad67fe8233c316b92", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -65,6 +65,7 @@\n // it!\n \n use marker;\n+use ptr;\n use sync::atomic::{AtomicUsize, AtomicBool, Ordering};\n use thread::{self, Thread};\n \n@@ -297,7 +298,7 @@ impl Once {\n                     let mut node = Waiter {\n                         thread: Some(thread::current()),\n                         signaled: AtomicBool::new(false),\n-                        next: 0 as *mut Waiter,\n+                        next: ptr::null_mut(),\n                     };\n                     let me = &mut node as *mut Waiter as usize;\n                     assert!(me & STATE_MASK == 0);"}, {"sha": "63e13f0bb473849c6b8073190fcc8d8158fb9bc5", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -236,11 +236,11 @@ pub fn current_exe() -> io::Result<PathBuf> {\n                        libc::KERN_PROC_ARGV];\n         let mib = mib.as_mut_ptr();\n         let mut argv_len = 0;\n-        cvt(libc::sysctl(mib, 4, 0 as *mut _, &mut argv_len,\n-                         0 as *mut _, 0))?;\n+        cvt(libc::sysctl(mib, 4, ptr::null_mut(), &mut argv_len,\n+                         ptr::null_mut(), 0))?;\n         let mut argv = Vec::<*const libc::c_char>::with_capacity(argv_len as usize);\n         cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _,\n-                         &mut argv_len, 0 as *mut _, 0))?;\n+                         &mut argv_len, ptr::null_mut(), 0))?;\n         argv.set_len(argv_len as usize);\n         if argv[0].is_null() {\n             return Err(io::Error::new(io::ErrorKind::Other,"}, {"sha": "010594133387a4602261369cf4b0e89cfb81e642", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -14,6 +14,7 @@ use cmp;\n use io;\n use libc::{self, c_int};\n use mem;\n+use ptr;\n use sys::cvt_r;\n use sys::fd::FileDesc;\n \n@@ -92,8 +93,8 @@ pub fn read2(p1: AnonPipe,\n             let mut read: libc::fd_set = mem::zeroed();\n             libc::FD_SET(p1.raw(), &mut read);\n             libc::FD_SET(p2.raw(), &mut read);\n-            libc::select(max + 1, &mut read, 0 as *mut _, 0 as *mut _,\n-                         0 as *mut _)\n+            libc::select(max + 1, &mut read, ptr::null_mut(), ptr::null_mut(),\n+                         ptr::null_mut())\n         })?;\n \n         // Read as much as we can from each pipe, ignoring EWOULDBLOCK or"}, {"sha": "d68867fb3d2ce9d164466ef0a1164a1f8fb008c9", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -96,7 +96,7 @@ impl Command {\n         let mut saw_nul = false;\n         let program = os2c(program, &mut saw_nul);\n         Command {\n-            argv: vec![program.as_ptr(), 0 as *const _],\n+            argv: vec![program.as_ptr(), ptr::null()],\n             program: program,\n             args: Vec::new(),\n             env: None,\n@@ -117,7 +117,7 @@ impl Command {\n         // pointer.\n         let arg = os2c(arg, &mut self.saw_nul);\n         self.argv[self.args.len() + 1] = arg.as_ptr();\n-        self.argv.push(0 as *const _);\n+        self.argv.push(ptr::null());\n \n         // Also make sure we keep track of the owned value to schedule a\n         // destructor for this memory.\n@@ -134,7 +134,7 @@ impl Command {\n                 envp.push(s.as_ptr());\n                 map.insert(k, (envp.len() - 1, s));\n             }\n-            envp.push(0 as *const _);\n+            envp.push(ptr::null());\n             self.env = Some(map);\n             self.envp = Some(envp);\n         }\n@@ -158,7 +158,7 @@ impl Command {\n             Entry::Vacant(e) => {\n                 let len = envp.len();\n                 envp[len - 1] = new_key.as_ptr();\n-                envp.push(0 as *const _);\n+                envp.push(ptr::null());\n                 e.insert((len - 1, new_key));\n             }\n         }\n@@ -183,7 +183,7 @@ impl Command {\n \n     pub fn env_clear(&mut self) {\n         self.env = Some(HashMap::new());\n-        self.envp = Some(vec![0 as *const _]);\n+        self.envp = Some(vec![ptr::null()]);\n     }\n \n     pub fn cwd(&mut self, dir: &OsStr) {"}, {"sha": "a08cec38f732dae6ed8c8da0009080f91d08399d", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use cmp::Ordering;\n-use time::Duration;\n use libc;\n+use time::Duration;\n \n pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n \n@@ -164,12 +164,14 @@ mod inner {\n \n     impl SystemTime {\n         pub fn now() -> SystemTime {\n+            use ptr;\n+\n             let mut s = libc::timeval {\n                 tv_sec: 0,\n                 tv_usec: 0,\n             };\n             cvt(unsafe {\n-                libc::gettimeofday(&mut s, 0 as *mut _)\n+                libc::gettimeofday(&mut s, ptr::null_mut())\n             }).unwrap();\n             return SystemTime::from(s)\n         }"}, {"sha": "d10abae2865271dadfc6af7a3c1f3fa62cd41da9", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -46,10 +46,10 @@ impl Handle {\n \n     pub fn new_event(manual: bool, init: bool) -> io::Result<Handle> {\n         unsafe {\n-            let event = c::CreateEventW(0 as *mut _,\n+            let event = c::CreateEventW(ptr::null_mut(),\n                                         manual as c::BOOL,\n                                         init as c::BOOL,\n-                                        0 as *const _);\n+                                        ptr::null());\n             if event.is_null() {\n                 Err(io::Error::last_os_error())\n             } else {"}, {"sha": "6e9c67051a6eb3559c17a3d2d813df4b685816df", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -12,9 +12,10 @@ use prelude::v1::*;\n use os::windows::prelude::*;\n \n use ffi::OsStr;\n-use path::Path;\n use io;\n use mem;\n+use path::Path;\n+use ptr;\n use rand::{self, Rng};\n use slice;\n use sys::c;\n@@ -66,7 +67,7 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n                                              4096,\n                                              4096,\n                                              0,\n-                                             0 as *mut _);\n+                                             ptr::null_mut());\n \n             // We pass the FILE_FLAG_FIRST_PIPE_INSTANCE flag above, and we're\n             // also just doing a best effort at selecting a unique name. If"}, {"sha": "248f6f98650a526778ae67e84d66f4eb2d3bea6b", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cc3ad11e6fadcba443cc50ba6ed03ab04d34355/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=3cc3ad11e6fadcba443cc50ba6ed03ab04d34355", "patch": "@@ -959,6 +959,8 @@ fn get_concurrency() -> usize {\n               target_os = \"bitrig\",\n               target_os = \"netbsd\"))]\n     fn num_cpus() -> usize {\n+        use std::ptr;\n+\n         let mut cpus: libc::c_uint = 0;\n         let mut cpus_size = std::mem::size_of_val(&cpus);\n \n@@ -972,7 +974,7 @@ fn get_concurrency() -> usize {\n                              2,\n                              &mut cpus as *mut _ as *mut _,\n                              &mut cpus_size as *mut _ as *mut _,\n-                             0 as *mut _,\n+                             ptr::null_mut(),\n                              0);\n             }\n             if cpus < 1 {\n@@ -984,6 +986,8 @@ fn get_concurrency() -> usize {\n \n     #[cfg(target_os = \"openbsd\")]\n     fn num_cpus() -> usize {\n+        use std::ptr;\n+\n         let mut cpus: libc::c_uint = 0;\n         let mut cpus_size = std::mem::size_of_val(&cpus);\n         let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n@@ -993,7 +997,7 @@ fn get_concurrency() -> usize {\n                          2,\n                          &mut cpus as *mut _ as *mut _,\n                          &mut cpus_size as *mut _ as *mut _,\n-                         0 as *mut _,\n+                         ptr::null_mut(),\n                          0);\n         }\n         if cpus < 1 {"}]}