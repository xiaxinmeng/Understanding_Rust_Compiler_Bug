{"sha": "1e2f63de0a5e9a32d97d355f6351665e77455be2", "node_id": "C_kwDOAAsO6NoAKDFlMmY2M2RlMGE1ZTlhMzJkOTdkMzU1ZjYzNTE2NjVlNzc0NTViZTI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-18T22:23:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-18T22:23:09Z"}, "message": "Rollup merge of #93892 - compiler-errors:issue-92917, r=jackh726,nikomatsakis\n\nOnly mark projection as ambiguous if GAT substs are constrained\n\nA slightly more targeted version of #92917, where we only give up with ambiguity if we infer something about the GATs substs when probing for a projection candidate.\n\nfixes #93874\nalso note (but like the previous PR, does not fix) #91762\n\nr? `@jackh726`\ncc `@nikomatsakis` who reviewed #92917", "tree": {"sha": "e9da306098401bf54ecc4feff35942c30bd5eab1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9da306098401bf54ecc4feff35942c30bd5eab1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e2f63de0a5e9a32d97d355f6351665e77455be2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiEBxNCRBK7hj4Ov3rIwAAZb0IAEsHyb5Ys9x6k/akr+ulkiqc\nGAta3u6T68qYFQ9gH3cXB97spbUn2FVOYo+0etz6xc+M8L1aWIReJuFK6KsGwcxS\nTE42iSePv6bRBT0oppvYFnqRjVsD17+Kc00PlRwddQAT/CvNYG6+oBCcXjz0Fwgj\nWqfodIicahvUbdjXl/UF+tU7STPr+2mQFwyIGUBkiTU0UaAjqqZvrhxG+DeVxt4N\ndAHsc2V37XnjPP6I6EJ+Wf3yQY+OCkCS0ntPXIqbs1fe/qmV4V9yuXUhv6Idegdb\n2SAUOc0fLekLKQA9xlr+mScubBpF0qkoqbjsdnkojRN6gmlaMFZPXGVxRA9Rk8Q=\n=CRbx\n-----END PGP SIGNATURE-----\n", "payload": "tree e9da306098401bf54ecc4feff35942c30bd5eab1\nparent cb35370557ecea46d7b36237b9c60bfa105c8de5\nparent 879e4f8131b71050b00407befd6f1669389fe9ed\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1645222989 +0100\ncommitter GitHub <noreply@github.com> 1645222989 +0100\n\nRollup merge of #93892 - compiler-errors:issue-92917, r=jackh726,nikomatsakis\n\nOnly mark projection as ambiguous if GAT substs are constrained\n\nA slightly more targeted version of #92917, where we only give up with ambiguity if we infer something about the GATs substs when probing for a projection candidate.\n\nfixes #93874\nalso note (but like the previous PR, does not fix) #91762\n\nr? `@jackh726`\ncc `@nikomatsakis` who reviewed #92917\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e2f63de0a5e9a32d97d355f6351665e77455be2", "html_url": "https://github.com/rust-lang/rust/commit/1e2f63de0a5e9a32d97d355f6351665e77455be2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e2f63de0a5e9a32d97d355f6351665e77455be2/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb35370557ecea46d7b36237b9c60bfa105c8de5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb35370557ecea46d7b36237b9c60bfa105c8de5", "html_url": "https://github.com/rust-lang/rust/commit/cb35370557ecea46d7b36237b9c60bfa105c8de5"}, {"sha": "879e4f8131b71050b00407befd6f1669389fe9ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/879e4f8131b71050b00407befd6f1669389fe9ed", "html_url": "https://github.com/rust-lang/rust/commit/879e4f8131b71050b00407befd6f1669389fe9ed"}], "stats": {"total": 145, "additions": 101, "deletions": 44}, "files": [{"sha": "74c440890452a1bbe1d1db6c243f9f3dabf1d3fe", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2f63de0a5e9a32d97d355f6351665e77455be2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2f63de0a5e9a32d97d355f6351665e77455be2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=1e2f63de0a5e9a32d97d355f6351665e77455be2", "patch": "@@ -263,7 +263,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n         let index = self.values().push(TypeVariableData { origin });\n         assert_eq!(eq_key.vid.as_u32(), index as u32);\n \n-        debug!(\"new_var(index={:?}, universe={:?}, origin={:?}\", eq_key.vid, universe, origin,);\n+        debug!(\"new_var(index={:?}, universe={:?}, origin={:?})\", eq_key.vid, universe, origin);\n \n         eq_key.vid\n     }"}, {"sha": "dba24fb2f31b525f2fb779caa402145d461bf4cc", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1e2f63de0a5e9a32d97d355f6351665e77455be2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2f63de0a5e9a32d97d355f6351665e77455be2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=1e2f63de0a5e9a32d97d355f6351665e77455be2", "patch": "@@ -19,6 +19,7 @@ use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::select::ProjectionMatchesProjection;\n use rustc_data_structures::sso::SsoHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n@@ -1075,16 +1076,6 @@ fn project<'cx, 'tcx>(\n         return Ok(Projected::Progress(Progress::error(selcx.tcx())));\n     }\n \n-    // If the obligation contains any inference types or consts in associated\n-    // type substs, then we don't assemble any candidates.\n-    // This isn't really correct, but otherwise we can end up in a case where\n-    // we constrain inference variables by selecting a single predicate, when\n-    // we need to stay general. See issue #91762.\n-    let (_, predicate_own_substs) = obligation.predicate.trait_ref_and_own_substs(selcx.tcx());\n-    if predicate_own_substs.iter().any(|g| g.has_infer_types_or_consts()) {\n-        return Err(ProjectionError::TooManyCandidates);\n-    }\n-\n     let mut candidates = ProjectionCandidateSet::None;\n \n     // Make sure that the following procedures are kept in order. ParamEnv\n@@ -1182,7 +1173,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n         ProjectionCandidate::TraitDef,\n         bounds.iter(),\n         true,\n-    )\n+    );\n }\n \n /// In the case of a trait object like\n@@ -1247,28 +1238,35 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n         let bound_predicate = predicate.kind();\n         if let ty::PredicateKind::Projection(data) = predicate.kind().skip_binder() {\n             let data = bound_predicate.rebind(data);\n-            let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n-\n-            let is_match = same_def_id\n-                && infcx.probe(|_| {\n-                    selcx.match_projection_projections(\n-                        obligation,\n-                        data,\n-                        potentially_unnormalized_candidates,\n-                    )\n-                });\n+            if data.projection_def_id() != obligation.predicate.item_def_id {\n+                continue;\n+            }\n \n-            if is_match {\n-                candidate_set.push_candidate(ctor(data));\n+            let is_match = infcx.probe(|_| {\n+                selcx.match_projection_projections(\n+                    obligation,\n+                    data,\n+                    potentially_unnormalized_candidates,\n+                )\n+            });\n \n-                if potentially_unnormalized_candidates\n-                    && !obligation.predicate.has_infer_types_or_consts()\n-                {\n-                    // HACK: Pick the first trait def candidate for a fully\n-                    // inferred predicate. This is to allow duplicates that\n-                    // differ only in normalization.\n-                    return;\n+            match is_match {\n+                ProjectionMatchesProjection::Yes => {\n+                    candidate_set.push_candidate(ctor(data));\n+\n+                    if potentially_unnormalized_candidates\n+                        && !obligation.predicate.has_infer_types_or_consts()\n+                    {\n+                        // HACK: Pick the first trait def candidate for a fully\n+                        // inferred predicate. This is to allow duplicates that\n+                        // differ only in normalization.\n+                        return;\n+                    }\n+                }\n+                ProjectionMatchesProjection::Ambiguous => {\n+                    candidate_set.mark_ambiguous();\n                 }\n+                ProjectionMatchesProjection::No => {}\n             }\n         }\n     }"}, {"sha": "3b69700530b8504052f5fc0b96968c3860a9d8f6", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1e2f63de0a5e9a32d97d355f6351665e77455be2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2f63de0a5e9a32d97d355f6351665e77455be2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1e2f63de0a5e9a32d97d355f6351665e77455be2", "patch": "@@ -1494,12 +1494,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n+    /// Return `Yes` if the obligation's predicate type applies to the env_predicate, and\n+    /// `No` if it does not. Return `Ambiguous` in the case that the projection type is a GAT,\n+    /// and applying this env_predicate constrains any of the obligation's GAT substitutions.\n+    ///\n+    /// This behavior is a somewhat of a hack to prevent overconstraining inference variables\n+    /// in cases like #91762.\n     pub(super) fn match_projection_projections(\n         &mut self,\n         obligation: &ProjectionTyObligation<'tcx>,\n         env_predicate: PolyProjectionPredicate<'tcx>,\n         potentially_unnormalized_candidates: bool,\n-    ) -> bool {\n+    ) -> ProjectionMatchesProjection {\n         let mut nested_obligations = Vec::new();\n         let (infer_predicate, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n             obligation.cause.span,\n@@ -1521,7 +1527,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             infer_predicate.projection_ty\n         };\n \n-        self.infcx\n+        let is_match = self\n+            .infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(obligation.predicate, infer_projection)\n             .map_or(false, |InferOk { obligations, value: () }| {\n@@ -1530,7 +1537,26 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     nested_obligations.into_iter().chain(obligations),\n                 )\n                 .map_or(false, |res| res.may_apply())\n-            })\n+            });\n+\n+        if is_match {\n+            let generics = self.tcx().generics_of(obligation.predicate.item_def_id);\n+            // FIXME(generic-associated-types): Addresses aggressive inference in #92917.\n+            // If this type is a GAT, and of the GAT substs resolve to something new,\n+            // that means that we must have newly inferred something about the GAT.\n+            // We should give up in that case.\n+            if !generics.params.is_empty()\n+                && obligation.predicate.substs[generics.parent_count..]\n+                    .iter()\n+                    .any(|&p| p.has_infer_types_or_consts() && self.infcx.shallow_resolve(p) != p)\n+            {\n+                ProjectionMatchesProjection::Ambiguous\n+            } else {\n+                ProjectionMatchesProjection::Yes\n+            }\n+        } else {\n+            ProjectionMatchesProjection::No\n+        }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -2709,3 +2735,9 @@ impl<'o, 'tcx> fmt::Debug for TraitObligationStack<'o, 'tcx> {\n         write!(f, \"TraitObligationStack({:?})\", self.obligation)\n     }\n }\n+\n+pub enum ProjectionMatchesProjection {\n+    Yes,\n+    Ambiguous,\n+    No,\n+}"}, {"sha": "1bbf7aac5cdabc6ff70bb90f645e3f85ccda02f8", "filename": "src/test/ui/generic-associated-types/issue-74824.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e2f63de0a5e9a32d97d355f6351665e77455be2/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2f63de0a5e9a32d97d355f6351665e77455be2/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.rs?ref=1e2f63de0a5e9a32d97d355f6351665e77455be2", "patch": "@@ -17,7 +17,6 @@ impl<T> UnsafeCopy for T {}\n fn main() {\n     let b = Box::new(42usize);\n     let copy = <()>::copy(&b);\n-    //~^ type annotations needed\n \n     let raw_b = Box::deref(&b) as *const _;\n     let raw_copy = Box::deref(&copy) as *const _;"}, {"sha": "8517eb9fa21026c915453e4dcb1463593b7cee28", "filename": "src/test/ui/generic-associated-types/issue-74824.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e2f63de0a5e9a32d97d355f6351665e77455be2/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e2f63de0a5e9a32d97d355f6351665e77455be2/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr?ref=1e2f63de0a5e9a32d97d355f6351665e77455be2", "patch": "@@ -27,13 +27,6 @@ help: consider restricting type parameter `T`\n LL |     type Copy<T: std::clone::Clone>: Copy = Box<T>;\n    |                +++++++++++++++++++\n \n-error[E0282]: type annotations needed\n-  --> $DIR/issue-74824.rs:19:16\n-   |\n-LL |     let copy = <()>::copy(&b);\n-   |                ^^^^^^^^^^ cannot infer type for type parameter `T` declared on the associated function `copy`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0277, E0282.\n-For more information about an error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f403d75167d8a9f73a29ae2994ac7b2471c2f48d", "filename": "src/test/ui/generic-associated-types/issue-93874.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1e2f63de0a5e9a32d97d355f6351665e77455be2/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-93874.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2f63de0a5e9a32d97d355f6351665e77455be2/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-93874.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-93874.rs?ref=1e2f63de0a5e9a32d97d355f6351665e77455be2", "patch": "@@ -0,0 +1,35 @@\n+// check-pass\n+\n+#![feature(generic_associated_types)]\n+\n+pub trait Build {\n+    type Output<O>;\n+    fn build<O>(self, input: O) -> Self::Output<O>;\n+}\n+\n+pub struct IdentityBuild;\n+impl Build for IdentityBuild {\n+    type Output<O> = O;\n+    fn build<O>(self, input: O) -> Self::Output<O> {\n+        input\n+    }\n+}\n+\n+fn a() {\n+    let _x: u8 = IdentityBuild.build(10);\n+}\n+\n+fn b() {\n+    let _x: Vec<u8> = IdentityBuild.build(Vec::new());\n+}\n+\n+fn c() {\n+    let mut f = IdentityBuild.build(|| ());\n+    (f)();\n+}\n+\n+pub fn main() {\n+    a();\n+    b();\n+    c();\n+}"}]}