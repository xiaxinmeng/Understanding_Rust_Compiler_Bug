{"sha": "727d101561f9b1e81c6282943292d990288ca479", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyN2QxMDE1NjFmOWIxZTgxYzYyODI5NDMyOTJkOTkwMjg4Y2E0Nzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-27T20:19:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-27T20:19:57Z"}, "message": "Auto merge of #84494 - tdelabro:84304-bis, r=jyn514\n\n84304 - rustdoc: shrink Item::Attributes\n\nHelps with https://github.com/rust-lang/rust/issues/84304", "tree": {"sha": "5c611f422ac6adbf45825abaf914f5f08dfbeb59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c611f422ac6adbf45825abaf914f5f08dfbeb59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/727d101561f9b1e81c6282943292d990288ca479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/727d101561f9b1e81c6282943292d990288ca479", "html_url": "https://github.com/rust-lang/rust/commit/727d101561f9b1e81c6282943292d990288ca479", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/727d101561f9b1e81c6282943292d990288ca479/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83ebb00645cfa3288546b947aa557e90cc355bfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/83ebb00645cfa3288546b947aa557e90cc355bfa", "html_url": "https://github.com/rust-lang/rust/commit/83ebb00645cfa3288546b947aa557e90cc355bfa"}, {"sha": "727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc", "html_url": "https://github.com/rust-lang/rust/commit/727f9040aac16dfa5a27687f6f49b7cd5b98a2cc"}], "stats": {"total": 286, "additions": 158, "deletions": 128}, "files": [{"sha": "92eb6214f79fed7133458e74b080eb98fe115fd6", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -126,6 +126,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 synthetic: true,\n                 blanket_impl: None,\n             }),\n+            cfg: None,\n         })\n     }\n "}, {"sha": "3a14a1d23f2d4186602b741c340e0806846db583", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -128,6 +128,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         synthetic: false,\n                         blanket_impl: Some(trait_ref.self_ty().clean(self.cx)),\n                     }),\n+                    cfg: None,\n                 });\n             }\n         }"}, {"sha": "3e89c1ac4c514dc8f543791104ffad2c42dcc5ab", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -1,6 +1,7 @@\n //! Support for inlining external documentation into the current AST.\n \n use std::iter::once;\n+use std::sync::Arc;\n \n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n@@ -14,7 +15,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use crate::clean::{self, Attributes, GetDefId, ToSource};\n+use crate::clean::{self, Attributes, AttributesExt, GetDefId, ToSource};\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n \n@@ -119,12 +120,16 @@ crate fn try_inline(\n         _ => return None,\n     };\n \n-    let target_attrs = load_attrs(cx, did);\n-    let attrs = box merge_attrs(cx, Some(parent_module), target_attrs, attrs_clone);\n-\n+    let (attrs, cfg) = merge_attrs(cx, Some(parent_module), load_attrs(cx, did), attrs_clone);\n     cx.inlined.insert(did);\n-    let what_rustc_thinks = clean::Item::from_def_id_and_parts(did, Some(name), kind, cx);\n-    ret.push(clean::Item { attrs, ..what_rustc_thinks });\n+    ret.push(clean::Item::from_def_id_and_attrs_and_parts(\n+        did,\n+        Some(name),\n+        kind,\n+        box attrs,\n+        cx,\n+        cfg,\n+    ));\n     Some(ret)\n }\n \n@@ -288,22 +293,24 @@ fn merge_attrs(\n     parent_module: Option<DefId>,\n     old_attrs: Attrs<'_>,\n     new_attrs: Option<Attrs<'_>>,\n-) -> clean::Attributes {\n+) -> (clean::Attributes, Option<Arc<clean::cfg::Cfg>>) {\n     // NOTE: If we have additional attributes (from a re-export),\n     // always insert them first. This ensure that re-export\n     // doc comments show up before the original doc comments\n     // when we render them.\n     if let Some(inner) = new_attrs {\n-        if let Some(new_id) = parent_module {\n-            let diag = cx.sess().diagnostic();\n-            Attributes::from_ast(diag, old_attrs, Some((inner, new_id)))\n-        } else {\n-            let mut both = inner.to_vec();\n-            both.extend_from_slice(old_attrs);\n-            both.clean(cx)\n-        }\n+        let mut both = inner.to_vec();\n+        both.extend_from_slice(old_attrs);\n+        (\n+            if let Some(new_id) = parent_module {\n+                Attributes::from_ast(old_attrs, Some((inner, new_id)))\n+            } else {\n+                Attributes::from_ast(&both, None)\n+            },\n+            both.cfg(cx.sess().diagnostic()),\n+        )\n     } else {\n-        old_attrs.clean(cx)\n+        (old_attrs.clean(cx), old_attrs.cfg(cx.sess().diagnostic()))\n     }\n }\n \n@@ -414,8 +421,8 @@ crate fn build_impl(\n \n     debug!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n \n-    let attrs = box merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n-    debug!(\"merged_attrs={:?}\", attrs);\n+    let (merged_attrs, cfg) = merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n+    debug!(\"merged_attrs={:?}\", merged_attrs);\n \n     ret.push(clean::Item::from_def_id_and_attrs_and_parts(\n         did,\n@@ -432,8 +439,9 @@ crate fn build_impl(\n             synthetic: false,\n             blanket_impl: None,\n         }),\n-        attrs,\n+        box merged_attrs,\n         cx,\n+        cfg,\n     ));\n }\n \n@@ -479,6 +487,7 @@ fn build_module(\n                         },\n                         true,\n                     )),\n+                    cfg: None,\n                 });\n             } else if let Some(i) = try_inline(cx, did, item.res, item.ident.name, None, visited) {\n                 items.extend(i)"}, {"sha": "6563f398edb6fcea03e40511797b2ae54bfb80aa", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -84,9 +84,8 @@ impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n }\n \n impl Clean<ExternalCrate> for CrateNum {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> ExternalCrate {\n-        let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n-        ExternalCrate { crate_num: *self, attrs: cx.tcx.get_attrs(root).clean(cx) }\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> ExternalCrate {\n+        ExternalCrate { crate_num: *self }\n     }\n }\n \n@@ -123,8 +122,8 @@ impl Clean<Item> for doctree::Module<'_> {\n }\n \n impl Clean<Attributes> for [ast::Attribute] {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Attributes {\n-        Attributes::from_ast(cx.sess().diagnostic(), self, None)\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> Attributes {\n+        Attributes::from_ast(self, None)\n     }\n }\n \n@@ -850,7 +849,6 @@ where\n             inputs: (self.0.inputs, self.1).clean(cx),\n             output: self.0.output.clean(cx),\n             c_variadic: self.0.c_variadic,\n-            attrs: Attributes::default(),\n         }\n     }\n }\n@@ -862,7 +860,6 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n \n         FnDecl {\n             output: Return(sig.skip_binder().output().clean(cx)),\n-            attrs: Attributes::default(),\n             c_variadic: sig.skip_binder().c_variadic,\n             inputs: Arguments {\n                 values: sig\n@@ -2001,13 +1998,15 @@ fn clean_extern_crate(\n             return items;\n         }\n     }\n+\n     // FIXME: using `from_def_id_and_kind` breaks `rustdoc/masked` for some reason\n     vec![Item {\n         name: Some(name),\n         attrs: box attrs.clean(cx),\n         def_id: crate_def_id,\n         visibility: krate.vis.clean(cx),\n         kind: box ExternCrateItem { src: orig_name },\n+        cfg: attrs.cfg(cx.sess().diagnostic()),\n     }]\n }\n "}, {"sha": "5e47144588b3f3b0b2f5dc7c9bb5516c4b21051a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 80, "deletions": 60, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -73,7 +73,6 @@ crate struct TraitWithExtraInfo {\n #[derive(Clone, Debug)]\n crate struct ExternalCrate {\n     crate crate_num: CrateNum,\n-    crate attrs: Attributes,\n }\n \n impl ExternalCrate {\n@@ -220,11 +219,13 @@ crate struct Item {\n     /// E.g., struct vs enum vs function.\n     crate kind: Box<ItemKind>,\n     crate def_id: DefId,\n+\n+    crate cfg: Option<Arc<Cfg>>,\n }\n \n // `Item` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Item, 40);\n+rustc_data_structures::static_assert_size!(Item, 48);\n \n impl fmt::Debug for Item {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -236,6 +237,7 @@ impl fmt::Debug for Item {\n             .field(\"kind\", &self.kind)\n             .field(\"visibility\", &self.visibility)\n             .field(\"def_id\", def_id)\n+            .field(\"cfg\", &self.cfg)\n             .finish()\n     }\n }\n@@ -263,6 +265,10 @@ impl Item {\n         if self.is_fake() { None } else { tcx.lookup_deprecation(self.def_id) }\n     }\n \n+    crate fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n+        if self.is_fake() { false } else { tcx.get_attrs(self.def_id).inner_docs() }\n+    }\n+\n     crate fn span(&self, tcx: TyCtxt<'_>) -> Span {\n         let kind = match &*self.kind {\n             ItemKind::StrippedItem(k) => k,\n@@ -306,12 +312,15 @@ impl Item {\n         kind: ItemKind,\n         cx: &mut DocContext<'_>,\n     ) -> Item {\n+        let ast_attrs = cx.tcx.get_attrs(def_id);\n+\n         Self::from_def_id_and_attrs_and_parts(\n             def_id,\n             name,\n             kind,\n-            box cx.tcx.get_attrs(def_id).clean(cx),\n+            box ast_attrs.clean(cx),\n             cx,\n+            ast_attrs.cfg(cx.sess().diagnostic()),\n         )\n     }\n \n@@ -321,6 +330,7 @@ impl Item {\n         kind: ItemKind,\n         attrs: Box<Attributes>,\n         cx: &mut DocContext<'_>,\n+        cfg: Option<Arc<Cfg>>,\n     ) -> Item {\n         debug!(\"name={:?}, def_id={:?}\", name, def_id);\n \n@@ -330,6 +340,7 @@ impl Item {\n             name,\n             attrs,\n             visibility: cx.tcx.visibility(def_id).clean(cx),\n+            cfg,\n         }\n     }\n \n@@ -663,12 +674,72 @@ impl<'a> Iterator for ListAttributesIter<'a> {\n crate trait AttributesExt {\n     /// Finds an attribute as List and returns the list of attributes nested inside.\n     fn lists(&self, name: Symbol) -> ListAttributesIter<'_>;\n+\n+    fn span(&self) -> Option<rustc_span::Span>;\n+\n+    fn inner_docs(&self) -> bool;\n+\n+    fn other_attrs(&self) -> Vec<ast::Attribute>;\n+\n+    fn cfg(&self, diagnostic: &::rustc_errors::Handler) -> Option<Arc<Cfg>>;\n }\n \n impl AttributesExt for [ast::Attribute] {\n     fn lists(&self, name: Symbol) -> ListAttributesIter<'_> {\n         ListAttributesIter { attrs: self.iter(), current_list: Vec::new().into_iter(), name }\n     }\n+\n+    /// Return the span of the first doc-comment, if it exists.\n+    fn span(&self) -> Option<rustc_span::Span> {\n+        self.iter().find(|attr| attr.doc_str().is_some()).map(|attr| attr.span)\n+    }\n+\n+    /// Returns whether the first doc-comment is an inner attribute.\n+    ///\n+    //// If there are no doc-comments, return true.\n+    /// FIXME(#78591): Support both inner and outer attributes on the same item.\n+    fn inner_docs(&self) -> bool {\n+        self.iter().find(|a| a.doc_str().is_some()).map_or(true, |a| a.style == AttrStyle::Inner)\n+    }\n+\n+    fn other_attrs(&self) -> Vec<ast::Attribute> {\n+        self.iter().filter(|attr| attr.doc_str().is_none()).cloned().collect()\n+    }\n+\n+    fn cfg(&self, diagnostic: &::rustc_errors::Handler) -> Option<Arc<Cfg>> {\n+        let mut cfg = Cfg::True;\n+\n+        for attr in self.iter() {\n+            if attr.doc_str().is_none() && attr.has_name(sym::doc) {\n+                if let Some(mi) = attr.meta() {\n+                    if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n+                        // Extracted #[doc(cfg(...))]\n+                        match Cfg::parse(cfg_mi) {\n+                            Ok(new_cfg) => cfg &= new_cfg,\n+                            Err(e) => diagnostic.span_err(e.span, e.msg),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for attr in self.lists(sym::target_feature) {\n+            if attr.has_name(sym::enable) {\n+                if let Some(feat) = attr.value_str() {\n+                    let meta = attr::mk_name_value_item_str(\n+                        Ident::with_dummy_span(sym::target_feature),\n+                        feat,\n+                        DUMMY_SP,\n+                    );\n+                    if let Ok(feat_cfg) = Cfg::parse(&meta) {\n+                        cfg &= feat_cfg;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) }\n+    }\n }\n \n crate trait NestedAttributesExt {\n@@ -777,9 +848,6 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n crate struct Attributes {\n     crate doc_strings: Vec<DocFragment>,\n     crate other_attrs: Vec<ast::Attribute>,\n-    crate cfg: Option<Arc<Cfg>>,\n-    crate span: Option<rustc_span::Span>,\n-    crate inner_docs: bool,\n }\n \n #[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n@@ -811,6 +879,10 @@ pub struct RenderedLink {\n }\n \n impl Attributes {\n+    crate fn lists(&self, name: Symbol) -> ListAttributesIter<'_> {\n+        self.other_attrs.lists(name)\n+    }\n+\n     /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n     crate fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n         use rustc_ast::NestedMetaItem::MetaItem;\n@@ -890,13 +962,10 @@ impl Attributes {\n     }\n \n     crate fn from_ast(\n-        diagnostic: &::rustc_errors::Handler,\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n     ) -> Attributes {\n         let mut doc_strings: Vec<DocFragment> = vec![];\n-        let mut sp = None;\n-        let mut cfg = Cfg::True;\n         let mut doc_line = 0;\n \n         fn update_need_backline(doc_strings: &mut Vec<DocFragment>, frag: &DocFragment) {\n@@ -940,21 +1009,11 @@ impl Attributes {\n \n                 doc_strings.push(frag);\n \n-                if sp.is_none() {\n-                    sp = Some(attr.span);\n-                }\n                 None\n             } else {\n                 if attr.has_name(sym::doc) {\n                     if let Some(mi) = attr.meta() {\n-                        if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n-                            // Extracted #[doc(cfg(...))]\n-                            match Cfg::parse(cfg_mi) {\n-                                Ok(new_cfg) => cfg &= new_cfg,\n-                                Err(e) => diagnostic.span_err(e.span, e.msg),\n-                            }\n-                        } else if let Some((filename, contents)) = Attributes::extract_include(&mi)\n-                        {\n+                        if let Some((filename, contents)) = Attributes::extract_include(&mi) {\n                             let line = doc_line;\n                             doc_line += contents.as_str().lines().count();\n                             let frag = DocFragment {\n@@ -984,35 +1043,7 @@ impl Attributes {\n             .filter_map(clean_attr)\n             .collect();\n \n-        // treat #[target_feature(enable = \"feat\")] attributes as if they were\n-        // #[doc(cfg(target_feature = \"feat\"))] attributes as well\n-        for attr in attrs.lists(sym::target_feature) {\n-            if attr.has_name(sym::enable) {\n-                if let Some(feat) = attr.value_str() {\n-                    let meta = attr::mk_name_value_item_str(\n-                        Ident::with_dummy_span(sym::target_feature),\n-                        feat,\n-                        DUMMY_SP,\n-                    );\n-                    if let Ok(feat_cfg) = Cfg::parse(&meta) {\n-                        cfg &= feat_cfg;\n-                    }\n-                }\n-            }\n-        }\n-\n-        let inner_docs = attrs\n-            .iter()\n-            .find(|a| a.doc_str().is_some())\n-            .map_or(true, |a| a.style == AttrStyle::Inner);\n-\n-        Attributes {\n-            doc_strings,\n-            other_attrs,\n-            cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n-            span: sp,\n-            inner_docs,\n-        }\n+        Attributes { doc_strings, other_attrs }\n     }\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n@@ -1078,8 +1109,6 @@ impl Attributes {\n impl PartialEq for Attributes {\n     fn eq(&self, rhs: &Self) -> bool {\n         self.doc_strings == rhs.doc_strings\n-            && self.cfg == rhs.cfg\n-            && self.span == rhs.span\n             && self\n                 .other_attrs\n                 .iter()\n@@ -1093,20 +1122,12 @@ impl Eq for Attributes {}\n impl Hash for Attributes {\n     fn hash<H: Hasher>(&self, hasher: &mut H) {\n         self.doc_strings.hash(hasher);\n-        self.cfg.hash(hasher);\n-        self.span.hash(hasher);\n         for attr in &self.other_attrs {\n             attr.id.hash(hasher);\n         }\n     }\n }\n \n-impl AttributesExt for Attributes {\n-    fn lists(&self, name: Symbol) -> ListAttributesIter<'_> {\n-        self.other_attrs.lists(name)\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate enum GenericBound {\n     TraitBound(PolyTrait, hir::TraitBoundModifier),\n@@ -1269,7 +1290,6 @@ crate struct FnDecl {\n     crate inputs: Arguments,\n     crate output: FnRetTy,\n     crate c_variadic: bool,\n-    crate attrs: Attributes,\n }\n \n impl FnDecl {"}, {"sha": "212aac0e5b43c97733ee2a0dd38f66d79a640397", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -32,7 +32,7 @@ use std::rc::Rc;\n \n use crate::clean;\n use crate::clean::inline::build_external_trait;\n-use crate::clean::{AttributesExt, TraitWithExtraInfo, MAX_DEF_IDX};\n+use crate::clean::{TraitWithExtraInfo, MAX_DEF_IDX};\n use crate::config::{Options as RustdocOptions, OutputFormat, RenderOptions};\n use crate::formats::cache::Cache;\n use crate::passes::{self, Condition::*, ConditionalPass};"}, {"sha": "466d1b65406cd24ffd63aef83f2eba65264dd9a6", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -26,7 +26,7 @@ use std::str;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::{Arc, Mutex};\n \n-use crate::clean::Attributes;\n+use crate::clean::{types::AttributesExt, Attributes};\n use crate::config::Options;\n use crate::html::markdown::{self, ErrorCodes, Ignore, LangString};\n use crate::lint::init_lints;\n@@ -1092,9 +1092,10 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         sp: Span,\n         nested: F,\n     ) {\n-        let attrs = self.tcx.hir().attrs(hir_id);\n-        let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs, None);\n-        if let Some(ref cfg) = attrs.cfg {\n+        let ast_attrs = self.tcx.hir().attrs(hir_id);\n+        let mut attrs = Attributes::from_ast(ast_attrs, None);\n+\n+        if let Some(ref cfg) = ast_attrs.cfg(self.sess.diagnostic()) {\n             if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features_untracked())) {\n                 return;\n             }\n@@ -1110,8 +1111,8 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         // anything else, this will combine them for us.\n         if let Some(doc) = attrs.collapsed_doc_value() {\n             // Use the outermost invocation, so that doctest names come from where the docs were written.\n-            let span = attrs\n-                .span\n+            let span = ast_attrs\n+                .span()\n                 .map(|span| span.ctxt().outer_expn().expansion_cause().unwrap_or(span))\n                 .unwrap_or(DUMMY_SP);\n             self.collector.set_position(span);"}, {"sha": "8f8bca64e1497fcbbe097851f72452355f7a91c8", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -164,10 +164,12 @@ impl Cache {\n             };\n             let name = e.name(tcx);\n             let extern_url = extern_html_root_urls.get(&*name.as_str()).map(|u| &**u);\n-            self.extern_locations\n-                .insert(n, (name, src_root, extern_location(e, extern_url, &dst, tcx)));\n-\n             let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n+            self.extern_locations.insert(\n+                n,\n+                (name, src_root, extern_location(e, extern_url, tcx.get_attrs(did), &dst, tcx)),\n+            );\n+\n             self.external_paths.insert(did, (vec![name.to_string()], ItemType::Module));\n         }\n "}, {"sha": "f4296a04e59216c8683579f66bb6b79881377c10", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -1,15 +1,16 @@\n use std::collections::BTreeMap;\n use std::path::Path;\n \n+use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n+use crate::clean;\n use crate::clean::types::{\n-    FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n+    AttributesExt, FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n };\n-use crate::clean::{self, AttributesExt};\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::markdown::short_markdown_summary;\n@@ -30,6 +31,7 @@ crate enum ExternalLocation {\n crate fn extern_location(\n     e: &clean::ExternalCrate,\n     extern_url: Option<&str>,\n+    ast_attrs: &[ast::Attribute],\n     dst: &Path,\n     tcx: TyCtxt<'_>,\n ) -> ExternalLocation {\n@@ -50,7 +52,7 @@ crate fn extern_location(\n \n     // Failing that, see if there's an attribute specifying where to find this\n     // external crate\n-    e.attrs\n+    ast_attrs\n         .lists(sym::doc)\n         .filter(|a| a.has_name(sym::html_root_url))\n         .filter_map(|a| a.value_str())"}, {"sha": "4c8ba0e7b496e02fdd46d3ae6e9c5711150c343a", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -18,7 +18,7 @@ use super::print_item::{full_path, item_path, print_item};\n use super::write_shared::write_shared;\n use super::{print_sidebar, settings, AllTypes, NameDoc, StylePath, BASIC_KEYWORDS};\n \n-use crate::clean::{self, AttributesExt};\n+use crate::clean;\n use crate::config::RenderOptions;\n use crate::docfs::{DocFS, PathError};\n use crate::error::Error;"}, {"sha": "19b8dd15ad0f27896a751d3f63fd089d5ddde421", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -608,17 +608,12 @@ fn document_item_info(\n }\n \n fn portability(item: &clean::Item, parent: Option<&clean::Item>) -> Option<String> {\n-    let cfg = match (&item.attrs.cfg, parent.and_then(|p| p.attrs.cfg.as_ref())) {\n+    let cfg = match (&item.cfg, parent.and_then(|p| p.cfg.as_ref())) {\n         (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n         (cfg, _) => cfg.as_deref().cloned(),\n     };\n \n-    debug!(\n-        \"Portability {:?} - {:?} = {:?}\",\n-        item.attrs.cfg,\n-        parent.and_then(|p| p.attrs.cfg.as_ref()),\n-        cfg\n-    );\n+    debug!(\"Portability {:?} - {:?} = {:?}\", item.cfg, parent.and_then(|p| p.cfg.as_ref()), cfg);\n \n     Some(format!(\"<div class=\\\"stab portability\\\">{}</div>\", cfg?.render_long_html()))\n }"}, {"sha": "1bb1db00e8825d4a3d83d2757e3841a2df38601e", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -1,10 +1,11 @@\n+use clean::AttributesExt;\n+\n use std::cmp::Ordering;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::dep_graph::DepContext;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::hygiene::MacroKind;\n@@ -284,16 +285,14 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n \n             clean::ImportItem(ref import) => {\n                 let (stab, stab_tags) = if let Some(import_def_id) = import.source.did {\n-                    let import_attrs = Box::new(clean::Attributes::from_ast(\n-                        cx.tcx().sess().diagnostic(),\n-                        cx.tcx().get_attrs(import_def_id),\n-                        None,\n-                    ));\n+                    let ast_attrs = cx.tcx().get_attrs(import_def_id);\n+                    let import_attrs = Box::new(clean::Attributes::from_ast(ast_attrs, None));\n \n                     // Just need an item with the correct def_id and attrs\n                     let import_item = clean::Item {\n                         def_id: import_def_id,\n                         attrs: import_attrs,\n+                        cfg: ast_attrs.cfg(cx.tcx().sess.diagnostic()),\n                         ..myitem.clone()\n                     };\n \n@@ -400,12 +399,12 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n         tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n     }\n \n-    let cfg = match (&item.attrs.cfg, parent.attrs.cfg.as_ref()) {\n+    let cfg = match (&item.cfg, parent.cfg.as_ref()) {\n         (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n         (cfg, _) => cfg.as_deref().cloned(),\n     };\n \n-    debug!(\"Portability {:?} - {:?} = {:?}\", item.attrs.cfg, parent.attrs.cfg, cfg);\n+    debug!(\"Portability {:?} - {:?} = {:?}\", item.cfg, parent.cfg, cfg);\n     if let Some(ref cfg) = cfg {\n         tags += &tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html());\n     }"}, {"sha": "2d8c347c3c1678575188ef24b404290670862e21", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -41,7 +41,7 @@ impl JsonRenderer<'_> {\n             .map(rustc_ast_pretty::pprust::attribute_to_string)\n             .collect();\n         let span = item.span(self.tcx);\n-        let clean::Item { name, attrs: _, kind: _, visibility, def_id } = item;\n+        let clean::Item { name, attrs: _, kind: _, visibility, def_id, cfg: _ } = item;\n         let inner = match *item.kind {\n             clean::StrippedItem(_) => return None,\n             _ => from_clean_item(item, self.tcx),\n@@ -421,7 +421,7 @@ impl FromWithTcx<clean::BareFunctionDecl> for FunctionPointer {\n \n impl FromWithTcx<clean::FnDecl> for FnDecl {\n     fn from_tcx(decl: clean::FnDecl, tcx: TyCtxt<'_>) -> Self {\n-        let clean::FnDecl { inputs, output, c_variadic, attrs: _ } = decl;\n+        let clean::FnDecl { inputs, output, c_variadic } = decl;\n         FnDecl {\n             inputs: inputs\n                 .values"}, {"sha": "f1064756fdde7c928859b1c732aceeece6676950", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -853,7 +853,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n         });\n \n-        if item.is_mod() && item.attrs.inner_docs {\n+        let inner_docs = item.inner_docs(self.cx.tcx);\n+\n+        if item.is_mod() && inner_docs {\n             self.mod_ids.push(item.def_id);\n         }\n \n@@ -880,7 +882,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         }\n \n         Some(if item.is_mod() {\n-            if !item.attrs.inner_docs {\n+            if !inner_docs {\n                 self.mod_ids.push(item.def_id);\n             }\n \n@@ -1050,6 +1052,8 @@ impl LinkCollector<'_, '_> {\n             };\n         let mut path_str = &*path_str;\n \n+        let inner_docs = item.inner_docs(self.cx.tcx);\n+\n         // In order to correctly resolve intra-doc links we need to\n         // pick a base AST node to work from.  If the documentation for\n         // this module came from an inner comment (//!) then we anchor\n@@ -1061,11 +1065,8 @@ impl LinkCollector<'_, '_> {\n         // we've already pushed this node onto the resolution stack but\n         // for outer comments we explicitly try and resolve against the\n         // parent_node first.\n-        let base_node = if item.is_mod() && item.attrs.inner_docs {\n-            self.mod_ids.last().copied()\n-        } else {\n-            parent_node\n-        };\n+        let base_node =\n+            if item.is_mod() && inner_docs { self.mod_ids.last().copied() } else { parent_node };\n \n         let mut module_id = if let Some(id) = base_node {\n             id"}, {"sha": "f5a362bfbe8c6edf9e966b0863a87127821c38b5", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -24,7 +24,7 @@ impl DocFolder for CfgPropagator {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let old_parent_cfg = self.parent_cfg.clone();\n \n-        let new_cfg = match (self.parent_cfg.take(), item.attrs.cfg.take()) {\n+        let new_cfg = match (self.parent_cfg.take(), item.cfg.take()) {\n             (None, None) => None,\n             (Some(rc), None) | (None, Some(rc)) => Some(rc),\n             (Some(mut a), Some(b)) => {\n@@ -34,7 +34,7 @@ impl DocFolder for CfgPropagator {\n             }\n         };\n         self.parent_cfg = new_cfg.clone();\n-        item.attrs.cfg = new_cfg;\n+        item.cfg = new_cfg;\n \n         let result = self.fold_item_recur(item);\n         self.parent_cfg = old_parent_cfg;"}, {"sha": "54c4ed22f1c4be4e1588e58aacee5fbdfb288476", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/727d101561f9b1e81c6282943292d990288ca479/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=727d101561f9b1e81c6282943292d990288ca479", "patch": "@@ -2,8 +2,8 @@ use rustc_hir::def_id::DefIdSet;\n use rustc_span::symbol::sym;\n use std::mem;\n \n-use crate::clean::Item;\n-use crate::clean::{self, AttributesExt, NestedAttributesExt};\n+use crate::clean;\n+use crate::clean::{Item, NestedAttributesExt};\n use crate::core::DocContext;\n use crate::fold::{DocFolder, StripItem};\n use crate::passes::{ImplStripper, Pass};"}]}