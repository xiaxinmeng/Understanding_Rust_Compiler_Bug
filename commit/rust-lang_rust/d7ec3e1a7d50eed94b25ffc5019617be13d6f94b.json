{"sha": "d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZWMzZTFhN2Q1MGVlZDk0YjI1ZmZjNTAxOTYxN2JlMTNkNmY5NGI=", "commit": {"author": {"name": "Matthew Hammer", "email": "matthew.hammer@colorado.edu", "date": "2017-07-19T21:04:30Z"}, "committer": {"name": "Matthew Hammer", "email": "matthew.hammer@colorado.edu", "date": "2017-08-23T15:26:48Z"}, "message": "inc comp: -Z profile-queries support; see also https://github.com/rust-lang-nursery/rust-forge/blob/master/profile-queries.md", "tree": {"sha": "3d02c9cb3678f4d15ae54cf6c6ed8f10bdc8363f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d02c9cb3678f4d15ae54cf6c6ed8f10bdc8363f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "html_url": "https://github.com/rust-lang/rust/commit/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/comments", "author": null, "committer": null, "parents": [{"sha": "a3f0ee9a7b17d522bfc6385f841d040445730f28", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3f0ee9a7b17d522bfc6385f841d040445730f28", "html_url": "https://github.com/rust-lang/rust/commit/a3f0ee9a7b17d522bfc6385f841d040445730f28"}], "stats": {"total": 526, "additions": 526, "deletions": 0}, "files": [{"sha": "a89d5ae9cdcbc616d7557752722cc79854f954d4", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "patch": "@@ -995,6 +995,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"enable queries of the dependency graph for regression testing\"),\n+    profile_queries: bool = (false, parse_bool, [UNTRACKED],\n+          \"trace and profile the queries of the incremental compilation framework\"),\n     no_analysis: bool = (false, parse_bool, [UNTRACKED],\n           \"parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list, [TRACKED],"}, {"sha": "38a675922a8abf9939c7ed42681a9ad3db097a87", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "patch": "@@ -389,6 +389,7 @@ impl Session {\n     }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n     pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n+    pub fn profile_queries(&self) -> bool { self.opts.debugging_opts.profile_queries }\n     pub fn count_llvm_insns(&self) -> bool {\n         self.opts.debugging_opts.count_llvm_insns\n     }"}, {"sha": "678aa047b1400e425c31ab806c0d63177ee7fb17", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "patch": "@@ -28,6 +28,7 @@ use ty::steal::Steal;\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n use util::nodemap::{DefIdSet, NodeSet};\n+use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n@@ -510,6 +511,16 @@ impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"computing the lint levels for items in this crate\")\n+}\n+\n+// If enabled, send a message to the profile-queries thread\n+macro_rules! profq_msg {\n+    ($tcx:expr, $msg:expr) => {\n+        if cfg!(debug_assertions) {\n+            if $tcx.sess.opts.debugging_opts.profile_queries {\n+                profq_msg($msg)\n+            }\n+        }\n     }\n }\n \n@@ -539,6 +550,12 @@ macro_rules! define_maps {\n             $($(#[$attr])* $name($K)),*\n         }\n \n+        #[allow(bad_style)]\n+        #[derive(Clone, Debug, PartialEq, Eq)]\n+        pub enum QueryMsg {\n+            $($name(String)),*\n+        }\n+\n         impl<$tcx> Query<$tcx> {\n             pub fn describe(&self, tcx: TyCtxt) -> String {\n                 match *self {\n@@ -581,10 +598,17 @@ macro_rules! define_maps {\n                        key,\n                        span);\n \n+                profq_msg!(tcx,\n+                    ProfileQueriesMsg::QueryBegin(span.clone(),\n+                                                  QueryMsg::$name(format!(\"{:?}\", key))));\n+\n                 if let Some(&(ref result, dep_node_index)) = tcx.maps.$name.borrow().map.get(&key) {\n                     tcx.dep_graph.read_index(dep_node_index);\n+                    profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                     return Ok(f(result));\n                 }\n+                // else, we are going to run the provider:\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n \n                 // FIXME(eddyb) Get more valid Span's on queries.\n                 // def_span guard is necessary to prevent a recursive loop,\n@@ -612,6 +636,7 @@ macro_rules! define_maps {\n                         tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n                     }\n                 })?;\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n \n                 tcx.dep_graph.read_index(dep_node_index);\n "}, {"sha": "2e4aaeee2356e9a36b54fae8a0a6ca9f3d2193c8", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "patch": "@@ -19,6 +19,10 @@ use std::iter::repeat;\n use std::path::Path;\n use std::time::{Duration, Instant};\n \n+use std::sync::mpsc::{Sender};\n+use syntax_pos::{Span};\n+use ty::maps::{QueryMsg};\n+\n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -29,6 +33,59 @@ pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n+/// Initialized for -Z profile-queries\n+thread_local!(static PROFQ_CHAN: RefCell<Option<Sender<ProfileQueriesMsg>>> = RefCell::new(None));\n+\n+/// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n+#[derive(Clone,Debug)]\n+pub struct ProfQDumpParams {\n+    /// A base path for the files we will dump\n+    pub path:String,\n+    /// To ensure that the compiler waits for us to finish our dumps\n+    pub ack:Sender<()>,\n+    /// toggle dumping a log file with every `ProfileQueriesMsg`\n+    pub dump_profq_msg_log:bool,\n+}\n+\n+/// A sequence of these messages induce a trace of query-based incremental compilation.\n+/// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n+#[derive(Clone,Debug)]\n+pub enum ProfileQueriesMsg {\n+    /// begin a new query\n+    QueryBegin(Span,QueryMsg),\n+    /// query is satisfied by using an already-known value for the given key\n+    CacheHit,\n+    /// query requires running a provider; providers may nest, permitting queries to nest.\n+    ProviderBegin,\n+    /// query is satisfied by a provider terminating with a value\n+    ProviderEnd,\n+    /// dump a record of the queries to the given path\n+    Dump(ProfQDumpParams),\n+    /// halt the profiling/monitoring background thread\n+    Halt\n+}\n+\n+/// If enabled, send a message to the profile-queries thread\n+pub fn profq_msg(msg: ProfileQueriesMsg) {\n+    PROFQ_CHAN.with(|sender|{\n+        if let Some(s) = sender.borrow().as_ref() {\n+            s.send(msg).unwrap()\n+        } else {\n+            panic!(\"no channel on which to send profq_msg: {:?}\", msg)\n+        }\n+    })\n+}\n+\n+/// Set channel for profile queries channel\n+pub fn profq_set_chan(s: Sender<ProfileQueriesMsg>) -> bool {\n+    PROFQ_CHAN.with(|chan|{\n+        if chan.borrow().is_none() {\n+            *chan.borrow_mut() = Some(s);\n+            true\n+        } else { false }\n+    })\n+}\n+\n /// Read the current depth of `time()` calls. This is used to\n /// encourage indentation across threads.\n pub fn time_depth() -> usize {"}, {"sha": "1428513977cdbfa8bb830ce2fe065db96c532434", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "patch": "@@ -64,6 +64,8 @@ use arena::DroplessArena;\n \n use derive_registrar;\n \n+use profile;\n+\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      input: &Input,\n@@ -105,6 +107,10 @@ pub fn compile_input(sess: &Session,\n         sess.abort_if_errors();\n     }\n \n+    if sess.opts.debugging_opts.profile_queries {\n+        profile::begin();\n+    }\n+\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n@@ -537,6 +543,10 @@ pub fn phase_1_parse_input<'a>(control: &CompileController,\n                                -> PResult<'a, ast::Crate> {\n     sess.diagnostic().set_continue_after_error(control.continue_parse_after_error);\n \n+    if sess.opts.debugging_opts.profile_queries {\n+        profile::begin();\n+    }\n+\n     let krate = time(sess.time_passes(), \"parsing\", || {\n         match *input {\n             Input::File(ref file) => {\n@@ -1120,6 +1130,10 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n              \"translation\",\n              move || trans::trans_crate(tcx, analysis, incremental_hashes_map, output_filenames));\n \n+    if tcx.sess.opts.debugging_opts.profile_queries {\n+        profile::dump(\"profile_queries\".to_string())\n+    }\n+\n     translation\n }\n "}, {"sha": "d7b5d4a6fe3ba40ff73b3e56b82393ffde544040", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "patch": "@@ -104,6 +104,7 @@ use syntax_pos::{DUMMY_SP, MultiSpan};\n #[cfg(test)]\n mod test;\n \n+pub mod profile;\n pub mod driver;\n pub mod pretty;\n pub mod target_features;"}, {"sha": "32e938ebcd616aa9ed482c67de9fbcb8dc9adf04", "filename": "src/librustc_driver/profile/mod.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Fmod.rs?ref=d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "patch": "@@ -0,0 +1,188 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::common::{ProfQDumpParams, ProfileQueriesMsg, profq_msg, profq_set_chan};\n+use std::sync::mpsc::{Receiver};\n+use std::io::{Write};\n+\n+pub mod trace;\n+\n+/// begin a profile thread, if not already running\n+pub fn begin() {\n+    use std::thread;\n+    use std::sync::mpsc::{channel};\n+    let (tx, rx) = channel();\n+    if profq_set_chan(tx) {\n+        thread::spawn(move||profile_queries_thread(rx));\n+    }\n+}\n+\n+/// dump files with profiling information to the given base path, and\n+/// wait for this dump to complete.\n+///\n+/// wraps the RPC (send/recv channel logic) of requesting a dump.\n+pub fn dump(path:String) {\n+    use std::sync::mpsc::{channel};\n+    let (tx, rx) = channel();\n+    let params = ProfQDumpParams{\n+        path, ack:tx,\n+        // FIXME: Add another compiler flag to toggle whether this log\n+        // is written; false for now\n+        dump_profq_msg_log:false,\n+    };\n+    profq_msg(ProfileQueriesMsg::Dump(params));\n+    let _ = rx.recv().unwrap();\n+}\n+\n+// profiling thread; retains state (in local variables) and dump traces, upon request.\n+fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n+    use self::trace::*;\n+    use std::fs::File;\n+    use std::time::{Instant};\n+\n+    let mut profq_msgs : Vec<ProfileQueriesMsg> = vec![];\n+    let mut frame : StackFrame = StackFrame{ parse_st:ParseState::NoQuery, traces:vec![] };\n+    let mut stack : Vec<StackFrame> = vec![];\n+    loop {\n+        let msg = r.recv();\n+        if let Err(_recv_err) = msg {\n+            // FIXME: Perhaps do something smarter than simply quitting?\n+            break\n+        };\n+        let msg = msg.unwrap();\n+        debug!(\"profile_queries_thread: {:?}\", msg);\n+\n+        // Meta-level versus _actual_ queries messages\n+        match msg {\n+            ProfileQueriesMsg::Halt => return,\n+            ProfileQueriesMsg::Dump(params) => {\n+                assert!(stack.len() == 0);\n+                assert!(frame.parse_st == trace::ParseState::NoQuery);\n+                {\n+                    // write log of all messages\n+                    if params.dump_profq_msg_log {\n+                        let mut log_file =\n+                            File::create(format!(\"{}.log.txt\", params.path)).unwrap();\n+                        for m in profq_msgs.iter() {\n+                            writeln!(&mut log_file, \"{:?}\", m).unwrap()\n+                        };\n+                    }\n+\n+                    // write HTML file, and counts file\n+                    let html_path = format!(\"{}.html\", params.path);\n+                    let mut html_file = File::create(&html_path).unwrap();\n+\n+                    let counts_path = format!(\"{}.counts.txt\", params.path);\n+                    let mut counts_file = File::create(&counts_path).unwrap();\n+\n+                    write!(html_file, \"<html>\\n\").unwrap();\n+                    write!(html_file,\n+                           \"<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\",\n+                           \"profile_queries.css\").unwrap();\n+                    write!(html_file, \"<style>\\n\").unwrap();\n+                    trace::write_style(&mut html_file);\n+                    write!(html_file, \"</style>\\n\").unwrap();\n+                    write!(html_file, \"</head>\\n\").unwrap();\n+                    write!(html_file, \"<body>\\n\").unwrap();\n+                    trace::write_traces(&mut html_file, &mut counts_file, &frame.traces);\n+                    write!(html_file, \"</body>\\n</html>\\n\").unwrap();\n+\n+                    // Tell main thread that we are done, e.g., so it can exit\n+                    params.ack.send(()).unwrap();\n+                }\n+                continue\n+            }\n+            // Actual query message:\n+            msg => {\n+                // Record msg in our log\n+                profq_msgs.push(msg.clone());\n+                // Respond to the message, knowing that we've already handled Halt and Dump, above.\n+                match (frame.parse_st.clone(), msg) {\n+                    (_,ProfileQueriesMsg::Halt) => unreachable!(),\n+                    (_,ProfileQueriesMsg::Dump(_)) => unreachable!(),\n+\n+                    // Parse State: NoQuery\n+                    (ParseState::NoQuery,\n+                     ProfileQueriesMsg::QueryBegin(span,querymsg)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveQuery\n+                            (Query{span:span, msg:querymsg}, start)\n+                    },\n+                    (ParseState::NoQuery,\n+                     ProfileQueriesMsg::CacheHit) => {\n+                        panic!(\"parse error: unexpected CacheHit; expected QueryBegin\")\n+                    },\n+                    (ParseState::NoQuery,\n+                     ProfileQueriesMsg::ProviderBegin) => {\n+                        panic!(\"parse error: expected QueryBegin before beginning a provider\")\n+                    },\n+                    (ParseState::NoQuery,\n+                     ProfileQueriesMsg::ProviderEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::NoQuery =>\n+                                        panic!(\"parse error: expected a stack frame for a query\"),\n+                                    ParseState::HaveQuery(q,start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::NoQuery,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let trace = Rec {\n+                                            effect: Effect::QueryBegin(q, CacheCase::Miss),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            duration: duration,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Parse State: HaveQuery\n+                    (ParseState::HaveQuery(q,start),\n+                     ProfileQueriesMsg::CacheHit) => {\n+                        let duration = start.elapsed();\n+                        let trace : Rec = Rec{\n+                            effect: Effect::QueryBegin(q, CacheCase::Hit),\n+                            extent: Box::new(vec![]),\n+                            start: start,\n+                            duration: duration,\n+                        };\n+                        frame.traces.push( trace );\n+                        frame.parse_st = ParseState::NoQuery;\n+                    },\n+                    (ParseState::HaveQuery(_,_),\n+                     ProfileQueriesMsg::ProviderBegin) => {\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::NoQuery, traces:vec![]};\n+                    },\n+                    (ParseState::HaveQuery(q,_),\n+                     ProfileQueriesMsg::ProviderEnd) => {\n+                        panic!(\"parse error: unexpected ProviderEnd; \\\n+                                expected something else to follow BeginQuery for {:?}\", q)\n+                    },\n+                    (ParseState::HaveQuery(q1,_),\n+                     ProfileQueriesMsg::QueryBegin(span2,querymsg2)) => {\n+                        panic!(\"parse error: unexpected QueryBegin; \\\n+                                earlier query is unfinished: {:?} and now {:?}\",\n+                               q1, Query{span:span2, msg:querymsg2})\n+                    },\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "c0a8be603cc6943dc294892aba4e39d7d99684c1", "filename": "src/librustc_driver/profile/trace.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7ec3e1a7d50eed94b25ffc5019617be13d6f94b/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=d7ec3e1a7d50eed94b25ffc5019617be13d6f94b", "patch": "@@ -0,0 +1,238 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+use syntax_pos::Span;\n+use rustc::ty::maps::QueryMsg;\n+use std::fs::File;\n+use std::time::{Duration, Instant};\n+use std::collections::hash_map::HashMap;\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Query {\n+    pub span: Span,\n+    pub msg: QueryMsg,\n+}\n+pub enum Effect {\n+    QueryBegin(Query, CacheCase),\n+}\n+pub enum CacheCase {\n+    Hit, Miss\n+}\n+/// Recursive trace structure\n+pub struct Rec {\n+    pub effect: Effect,\n+    pub start: Instant,\n+    pub duration: Duration,\n+    pub extent: Box<Vec<Rec>>,\n+}\n+/// State for parsing recursive trace structure\n+#[derive(Clone, Eq, PartialEq)]\n+pub enum ParseState {\n+    NoQuery,\n+    HaveQuery(Query, Instant),\n+}\n+pub struct StackFrame {\n+    pub parse_st: ParseState,\n+    pub traces:   Vec<Rec>,\n+}\n+pub struct QueryMetric {\n+    pub count: usize,\n+    pub duration: Duration,\n+}\n+\n+pub fn cons_of_query_msg(q: &trace::Query) -> String {\n+    let s = format!(\"{:?}\", q.msg);\n+    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n+    assert!(cons.len() > 0 && cons[0] != \"\");\n+    cons[0].to_string()\n+}\n+\n+// First return value is text; second return value is a CSS class\n+pub fn html_of_effect(eff: &Effect) -> (String, String) {\n+    match *eff {\n+        Effect::QueryBegin(ref qmsg, ref cc) => {\n+            let cons = cons_of_query_msg(qmsg);\n+            (cons.clone(),\n+             format!(\"{} {}\",\n+                     cons,\n+                     match *cc {\n+                         CacheCase::Hit => \"hit\",\n+                         CacheCase::Miss => \"miss\",\n+                     }))\n+        }\n+    }\n+}\n+\n+// First return value is text; second return value is a CSS class\n+fn html_of_duration(_start: &Instant, dur: &Duration) -> (String, String) {\n+    use rustc::util::common::duration_to_secs_str;\n+    (duration_to_secs_str(dur.clone()),\n+     \"\".to_string()\n+    )\n+}\n+\n+fn html_of_fraction(frac: f64) -> (String, String) {\n+    let css = {\n+        if       frac > 0.50  { format!(\"frac-50\") }\n+        else if  frac > 0.40  { format!(\"frac-40\") }\n+        else if  frac > 0.30  { format!(\"frac-30\") }\n+        else if  frac > 0.20  { format!(\"frac-20\") }\n+        else if  frac > 0.10  { format!(\"frac-10\") }\n+        else if  frac > 0.05  { format!(\"frac-05\") }\n+        else if  frac > 0.02  { format!(\"frac-02\") }\n+        else if  frac > 0.01  { format!(\"frac-01\") }\n+        else if  frac > 0.001 { format!(\"frac-001\") }\n+        else                  { format!(\"frac-0\") }\n+    };\n+    let percent = frac * 100.0;\n+    if percent > 0.1 { (format!(\"{:.1}%\", percent), css) }\n+    else { (format!(\"< 0.1%\", ), css) }\n+}\n+\n+fn total_duration(traces: &Vec<Rec>) -> Duration {\n+    let mut sum : Duration = Duration::new(0,0);\n+    for t in traces.iter() {\n+        sum += t.duration;\n+    }\n+    return sum\n+}\n+\n+fn duration_div(nom: Duration, den: Duration) -> f64 {\n+    fn to_nanos(d: Duration) -> u64 {\n+        d.as_secs() * 1_000_000_000 + d.subsec_nanos() as u64\n+    }\n+\n+    to_nanos(nom) as f64 / to_nanos(den) as f64\n+}\n+\n+fn write_traces_rec(file: &mut File, traces: &Vec<Rec>, total: Duration, depth: usize) {\n+    for t in traces {\n+        let (eff_text, eff_css_classes) = html_of_effect(&t.effect);\n+        let (dur_text, dur_css_classes) = html_of_duration(&t.start, &t.duration);\n+        let fraction = duration_div(t.duration, total);\n+        let percent = fraction * 100.0;\n+        let (frc_text, frc_css_classes) = html_of_fraction(fraction);\n+        write!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\\n\",\n+               depth,\n+               t.extent.len(),\n+               /* Heuristic for 'important' CSS class: */\n+               if t.extent.len() > 5 || percent >= 1.0 {\n+                   \" important\" }\n+               else { \"\" },\n+               eff_css_classes,\n+               dur_css_classes,\n+               frc_css_classes,\n+        ).unwrap();\n+        write!(file, \"<div class=\\\"eff\\\">{}</div>\\n\", eff_text).unwrap();\n+        write!(file, \"<div class=\\\"dur\\\">{}</div>\\n\", dur_text).unwrap();\n+        write!(file, \"<div class=\\\"frc\\\">{}</div>\\n\", frc_text).unwrap();\n+        write_traces_rec(file, &t.extent, total, depth + 1);\n+        write!(file, \"</div>\\n\").unwrap();\n+    }\n+}\n+\n+fn compute_counts_rec(counts: &mut HashMap<String,QueryMetric>, traces: &Vec<Rec>) {\n+    for t in traces.iter() {\n+        match t.effect {\n+            Effect::QueryBegin(ref qmsg, ref _cc) => {\n+                let qcons = cons_of_query_msg(qmsg);\n+                let qm = match counts.get(&qcons) {\n+                    Some(qm) =>\n+                        QueryMetric{\n+                            count: qm.count + 1,\n+                            duration: qm.duration + t.duration\n+                        },\n+                    None => QueryMetric{\n+                        count: 1,\n+                        duration: t.duration\n+                    }\n+                };\n+                counts.insert(qcons, qm);\n+            }\n+        }\n+        compute_counts_rec(counts, &t.extent)\n+    }\n+}\n+\n+pub fn write_counts(count_file: &mut File, counts: &mut HashMap<String,QueryMetric>) {\n+    use rustc::util::common::duration_to_secs_str;\n+    use std::cmp::Ordering;\n+\n+    let mut data = vec![];\n+    for (ref cons, ref qm) in counts.iter() {\n+        data.push((cons.clone(), qm.count.clone(), qm.duration.clone()));\n+    };\n+    data.sort_by(|&(_,_,d1),&(_,_,d2)|\n+                 if d1 > d2 { Ordering::Less } else { Ordering::Greater } );\n+    for (cons, count, duration) in data {\n+        write!(count_file, \"{},{},{}\\n\",\n+               cons, count, duration_to_secs_str(duration)\n+        ).unwrap();\n+    }\n+}\n+\n+pub fn write_traces(html_file: &mut File, counts_file: &mut File, traces: &Vec<Rec>) {\n+    let mut counts : HashMap<String,QueryMetric> = HashMap::new();\n+    compute_counts_rec(&mut counts, traces);\n+    write_counts(counts_file, &mut counts);\n+\n+    let total : Duration = total_duration(traces);\n+    write_traces_rec(html_file, traces, total, 0)\n+}\n+\n+pub fn write_style(html_file: &mut File) {\n+    write!(html_file,\"{}\", \"\n+body {\n+    font-family: sans-serif;\n+    background: black;\n+}\n+.trace {\n+    color: black;\n+    display: inline-block;\n+    border-style: solid;\n+    border-color: red;\n+    border-width: 1px;\n+    border-radius: 5px;\n+    padding: 0px;\n+    margin: 1px;\n+    font-size: 0px;\n+}\n+.miss {\n+    border-color: red;\n+    border-width: 1px;\n+}\n+.extent-0 {\n+    padding: 2px;\n+}\n+.important {\n+    border-width: 3px;\n+    font-size: 12px;\n+    color: white;\n+    border-color: #f77;\n+}\n+.hit {\n+    padding: 0px;\n+    border-color: blue;\n+    border-width: 3px;\n+}\n+.eff {\n+  color: #fff;\n+  display: inline-block;\n+}\n+.frc {\n+  color: #7f7;\n+  display: inline-block;\n+}\n+.dur {\n+  display: none\n+}\n+\").unwrap();\n+}"}]}