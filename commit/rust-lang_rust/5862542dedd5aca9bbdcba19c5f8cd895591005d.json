{"sha": "5862542dedd5aca9bbdcba19c5f8cd895591005d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NjI1NDJkZWRkNWFjYTliYmRjYmExOWM1ZjhjZDg5NTU5MTAwNWQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-12T23:19:20Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-19T15:02:06Z"}, "message": "Add AST/HIR for type args in path segments", "tree": {"sha": "58fb630e97583db371eed1111d2c067bde2982b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58fb630e97583db371eed1111d2c067bde2982b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5862542dedd5aca9bbdcba19c5f8cd895591005d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5862542dedd5aca9bbdcba19c5f8cd895591005d", "html_url": "https://github.com/rust-lang/rust/commit/5862542dedd5aca9bbdcba19c5f8cd895591005d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5862542dedd5aca9bbdcba19c5f8cd895591005d/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "688a45e00b53412a7a16360c6d678a5d91a95789", "url": "https://api.github.com/repos/rust-lang/rust/commits/688a45e00b53412a7a16360c6d678a5d91a95789", "html_url": "https://github.com/rust-lang/rust/commit/688a45e00b53412a7a16360c6d678a5d91a95789"}], "stats": {"total": 240, "additions": 217, "deletions": 23}, "files": [{"sha": "2014f1090765e81259ed1ca8e5696973346c36ea", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5862542dedd5aca9bbdcba19c5f8cd895591005d/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5862542dedd5aca9bbdcba19c5f8cd895591005d/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=5862542dedd5aca9bbdcba19c5f8cd895591005d", "patch": "@@ -147,7 +147,7 @@ impl Module {\n             .def_id,\n         );\n \n-        for name in path.segments.iter() {\n+        for segment in path.segments.iter() {\n             let curr = match curr_per_ns.as_ref().take_types() {\n                 Some(r) => r,\n                 None => {\n@@ -163,15 +163,17 @@ impl Module {\n             curr_per_ns = match curr.resolve(db) {\n                 Def::Module(m) => {\n                     let scope = m.scope(db);\n-                    match scope.get(&name) {\n+                    match scope.get(&segment.name) {\n                         Some(r) => r.def_id,\n                         None => PerNs::none(),\n                     }\n                 }\n                 Def::Enum(e) => {\n                     // enum variant\n-                    let matching_variant =\n-                        e.variants(db).into_iter().find(|(n, _variant)| n == name);\n+                    let matching_variant = e\n+                        .variants(db)\n+                        .into_iter()\n+                        .find(|(n, _variant)| n == &segment.name);\n \n                     match matching_variant {\n                         Some((_n, variant)) => PerNs::both(variant.def_id(), e.def_id()),"}, {"sha": "4874e82f31ac7a899656bba73c5fb88d0b00c61a", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5862542dedd5aca9bbdcba19c5f8cd895591005d/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5862542dedd5aca9bbdcba19c5f8cd895591005d/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=5862542dedd5aca9bbdcba19c5f8cd895591005d", "patch": "@@ -221,10 +221,10 @@ where\n             };\n         }\n         for (import_id, import_data) in input.imports.iter() {\n-            if let Some(name) = import_data.path.segments.iter().last() {\n+            if let Some(segment) = import_data.path.segments.iter().last() {\n                 if !import_data.is_glob {\n                     module_items.items.insert(\n-                        name.clone(),\n+                        segment.name.clone(),\n                         Resolution {\n                             def_id: PerNs::none(),\n                             import: Some(import_id),\n@@ -319,13 +319,13 @@ where\n             PathKind::Crate => module_id.crate_root(&self.module_tree),\n         };\n \n-        for (i, name) in import.path.segments.iter().enumerate() {\n+        for (i, segment) in import.path.segments.iter().enumerate() {\n             let is_last = i == import.path.segments.len() - 1;\n \n-            let def_id = match self.result.per_module[&curr].items.get(name) {\n+            let def_id = match self.result.per_module[&curr].items.get(&segment.name) {\n                 Some(res) if !res.def_id.is_none() => res.def_id,\n                 _ => {\n-                    log::debug!(\"path segment {:?} not found\", name);\n+                    log::debug!(\"path segment {:?} not found\", segment.name);\n                     return false;\n                 }\n             };\n@@ -336,7 +336,7 @@ where\n                 } else {\n                     log::debug!(\n                         \"path segment {:?} resolved to value only, but is not last\",\n-                        name\n+                        segment.name\n                     );\n                     return false;\n                 };\n@@ -358,17 +358,17 @@ where\n                             log::debug!(\"resolving {:?} in other source root\", path);\n                             let def_id = module.resolve_path(self.db, &path);\n                             if !def_id.is_none() {\n-                                let name = path.segments.last().unwrap();\n+                                let last_segment = path.segments.last().unwrap();\n                                 self.update(module_id, |items| {\n                                     let res = Resolution {\n                                         def_id,\n                                         import: Some(import_id),\n                                     };\n-                                    items.items.insert(name.clone(), res);\n+                                    items.items.insert(last_segment.name.clone(), res);\n                                 });\n                                 log::debug!(\n                                     \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n-                                    name,\n+                                    last_segment.name,\n                                     import,\n                                     def_id.map(|did| did.loc(self.db))\n                                 );\n@@ -382,7 +382,7 @@ where\n                     _ => {\n                         log::debug!(\n                             \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                            name,\n+                            segment.name,\n                             type_def_id.loc(self.db)\n                         );\n                         return true; // this resolved to a non-module, so the path won't ever resolve\n@@ -391,7 +391,7 @@ where\n             } else {\n                 log::debug!(\n                     \"resolved import {:?} ({:?}) within source root to {:?}\",\n-                    name,\n+                    segment.name,\n                     import,\n                     def_id.map(|did| did.loc(self.db))\n                 );\n@@ -400,7 +400,7 @@ where\n                         def_id,\n                         import: Some(import_id),\n                     };\n-                    items.items.insert(name.clone(), res);\n+                    items.items.insert(segment.name.clone(), res);\n                 })\n             }\n         }"}, {"sha": "c3d14c689d96e148dddc7bbf387521d1de240aeb", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5862542dedd5aca9bbdcba19c5f8cd895591005d/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5862542dedd5aca9bbdcba19c5f8cd895591005d/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=5862542dedd5aca9bbdcba19c5f8cd895591005d", "patch": "@@ -1,11 +1,35 @@\n+use std::sync::Arc;\n+\n use ra_syntax::{ast, AstNode};\n \n-use crate::{Name, AsName};\n+use crate::{Name, AsName, type_ref::TypeRef};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub kind: PathKind,\n-    pub segments: Vec<Name>,\n+    pub segments: Vec<PathSegment>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct PathSegment {\n+    pub name: Name,\n+    pub args_and_bindings: Option<Arc<GenericArgs>>,\n+}\n+\n+/// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n+/// can (in the future) also include bindings of associated types, like in\n+/// `Iterator<Item = Foo>`.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct GenericArgs {\n+    pub args: Vec<GenericArg>,\n+    // someday also bindings\n+}\n+\n+/// A single generic argument.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum GenericArg {\n+    Type(TypeRef),\n+    // or lifetime...\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -34,7 +58,17 @@ impl Path {\n         loop {\n             let segment = path.segment()?;\n             match segment.kind()? {\n-                ast::PathSegmentKind::Name(name) => segments.push(name.as_name()),\n+                ast::PathSegmentKind::Name(name) => {\n+                    let args = segment\n+                        .type_arg_list()\n+                        .and_then(GenericArgs::from_ast)\n+                        .map(Arc::new);\n+                    let segment = PathSegment {\n+                        name: name.as_name(),\n+                        args_and_bindings: args,\n+                    };\n+                    segments.push(segment);\n+                }\n                 ast::PathSegmentKind::CrateKw => {\n                     kind = PathKind::Crate;\n                     break;\n@@ -88,15 +122,34 @@ impl Path {\n         if self.kind != PathKind::Plain || self.segments.len() > 1 {\n             return None;\n         }\n-        self.segments.first()\n+        self.segments.first().map(|s| &s.name)\n+    }\n+}\n+\n+impl GenericArgs {\n+    fn from_ast(node: &ast::TypeArgList) -> Option<GenericArgs> {\n+        let mut args = Vec::new();\n+        for type_arg in node.type_args() {\n+            let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n+            args.push(GenericArg::Type(type_ref));\n+        }\n+        // lifetimes and assoc type args ignored for now\n+        if args.len() > 0 {\n+            Some(GenericArgs { args })\n+        } else {\n+            None\n+        }\n     }\n }\n \n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n         Path {\n             kind: PathKind::Plain,\n-            segments: vec![name],\n+            segments: vec![PathSegment {\n+                name,\n+                args_and_bindings: None,\n+            }],\n         }\n     }\n }\n@@ -160,7 +213,10 @@ fn convert_path(prefix: Option<Path>, path: &ast::Path) -> Option<Path> {\n                 kind: PathKind::Plain,\n                 segments: Vec::with_capacity(1),\n             });\n-            res.segments.push(name.as_name());\n+            res.segments.push(PathSegment {\n+                name: name.as_name(),\n+                args_and_bindings: None, // no type args in use\n+            });\n             res\n         }\n         ast::PathSegmentKind::CrateKw => {"}, {"sha": "9fe94617271fcfb88f4e630210d302910f95927b", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/5862542dedd5aca9bbdcba19c5f8cd895591005d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5862542dedd5aca9bbdcba19c5f8cd895591005d/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=5862542dedd5aca9bbdcba19c5f8cd895591005d", "patch": "@@ -105,6 +105,38 @@ impl ArrayType {\n     }\n }\n \n+// AssocTypeArg\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct AssocTypeArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for AssocTypeArg {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for AssocTypeArg {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            ASSOC_TYPE_ARG => Some(AssocTypeArg::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<AssocTypeArg> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl AssocTypeArg {\n+    pub fn name_ref(&self) -> Option<&NameRef> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn type_ref(&self) -> Option<&TypeRef> {\n+        super::child_opt(self)\n+    }\n+}\n+\n // Attr\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -1397,6 +1429,34 @@ impl AstNode for Lifetime {\n impl ast::AstToken for Lifetime {}\n impl Lifetime {}\n \n+// LifetimeArg\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct LifetimeArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for LifetimeArg {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for LifetimeArg {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            LIFETIME_ARG => Some(LifetimeArg::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<LifetimeArg> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl LifetimeArg {\n+    pub fn lifetime(&self) -> Option<&Lifetime> {\n+        super::child_opt(self)\n+    }\n+}\n+\n // LifetimeParam\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -2355,6 +2415,10 @@ impl PathSegment {\n     pub fn name_ref(&self) -> Option<&NameRef> {\n         super::child_opt(self)\n     }\n+\n+    pub fn type_arg_list(&self) -> Option<&TypeArgList> {\n+        super::child_opt(self)\n+    }\n }\n \n // PathType\n@@ -3335,6 +3399,70 @@ impl TupleType {\n     }\n }\n \n+// TypeArg\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct TypeArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for TypeArg {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for TypeArg {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            TYPE_ARG => Some(TypeArg::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<TypeArg> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl TypeArg {\n+    pub fn type_ref(&self) -> Option<&TypeRef> {\n+        super::child_opt(self)\n+    }\n+}\n+\n+// TypeArgList\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct TypeArgList {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for TypeArgList {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for TypeArgList {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            TYPE_ARG_LIST => Some(TypeArgList::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<TypeArgList> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl TypeArgList {\n+    pub fn type_args(&self) -> impl Iterator<Item = &TypeArg> {\n+        super::children(self)\n+    }\n+\n+    pub fn lifetime_args(&self) -> impl Iterator<Item = &LifetimeArg> {\n+        super::children(self)\n+    }\n+\n+    pub fn assoc_type_args(&self) -> impl Iterator<Item = &AssocTypeArg> {\n+        super::children(self)\n+    }\n+}\n+\n // TypeDef\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]"}, {"sha": "0385183fdc6d08b40a5d75abc0a278171c22c66a", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5862542dedd5aca9bbdcba19c5f8cd895591005d/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/5862542dedd5aca9bbdcba19c5f8cd895591005d/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=5862542dedd5aca9bbdcba19c5f8cd895591005d", "patch": "@@ -597,8 +597,16 @@ Grammar(\n             ]\n         ),\n         \"PathSegment\": (\n-            options: [ \"NameRef\" ]\n+            options: [ \"NameRef\", \"TypeArgList\" ]\n         ),\n+        \"TypeArgList\": (collections: [\n+            [\"type_args\", \"TypeArg\"],\n+            [\"lifetime_args\", \"LifetimeArg\"],\n+            [\"assoc_type_args\", \"AssocTypeArg\"],\n+        ]),\n+        \"TypeArg\": (options: [\"TypeRef\"]),\n+        \"AssocTypeArg\": (options: [\"NameRef\", \"TypeRef\"]),\n+        \"LifetimeArg\": (options: [\"Lifetime\"]),\n         \"Comment\": ( traits: [\"AstToken\"] ),\n         \"Whitespace\": ( traits: [\"AstToken\"] ),\n     },"}]}