{"sha": "96fd606dddba6bd4773c41be66c44fc076a96ff8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZmQ2MDZkZGRiYTZiZDQ3NzNjNDFiZTY2YzQ0ZmMwNzZhOTZmZjg=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-07-31T20:47:32Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-08-09T21:11:50Z"}, "message": "std/rustc/rustpkg/syntax: Support the `extern mod = ...` form\n\nThis commit allows you to write:\n\n extern mod x = \"a/b/c\";\n\nwhich means rustc will search in the RUST_PATH for a package with\nID a/b/c, and bind it to the name `x` if it's found.\n\nIncidentally, move get_relative_to from back::rpath into std::path", "tree": {"sha": "51a9be1731ec2607021333e3c8ad0ebfa5848998", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51a9be1731ec2607021333e3c8ad0ebfa5848998"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96fd606dddba6bd4773c41be66c44fc076a96ff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96fd606dddba6bd4773c41be66c44fc076a96ff8", "html_url": "https://github.com/rust-lang/rust/commit/96fd606dddba6bd4773c41be66c44fc076a96ff8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96fd606dddba6bd4773c41be66c44fc076a96ff8/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e751c90513b3b7948ffab7b449f0758e4225125e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e751c90513b3b7948ffab7b449f0758e4225125e", "html_url": "https://github.com/rust-lang/rust/commit/e751c90513b3b7948ffab7b449f0758e4225125e"}], "stats": {"total": 1425, "additions": 821, "deletions": 604}, "files": [{"sha": "d285253ffe200158075a3e305131aec574079966", "filename": "doc/rust.md", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -744,7 +744,7 @@ There are several kinds of view item:\n ##### Extern mod declarations\n \n ~~~~~~~~ {.ebnf .gram}\n-extern_mod_decl : \"extern\" \"mod\" ident [ '(' link_attrs ')' ] ? ;\n+extern_mod_decl : \"extern\" \"mod\" ident [ '(' link_attrs ')' ] ? [ '=' string_lit ] ? ;\n link_attrs : link_attr [ ',' link_attrs ] + ;\n link_attr : ident '=' literal ;\n ~~~~~~~~\n@@ -755,20 +755,34 @@ as the `ident` provided in the `extern_mod_decl`.\n \n The external crate is resolved to a specific `soname` at compile time,\n and a runtime linkage requirement to that `soname` is passed to the linker for\n-loading at runtime. The `soname` is resolved at compile time by scanning the\n-compiler's library path and matching the `link_attrs` provided in the\n-`use_decl` against any `#link` attributes that were declared on the external\n-crate when it was compiled. If no `link_attrs` are provided, a default `name`\n-attribute is assumed, equal to the `ident` given in the `use_decl`.\n-\n-Three examples of `extern mod` declarations:\n+loading at runtime.\n+The `soname` is resolved at compile time by scanning the compiler's library path\n+and matching the `link_attrs` provided in the `use_decl` against any `#link` attributes that\n+were declared on the external crate when it was compiled.\n+If no `link_attrs` are provided,\n+a default `name` attribute is assumed,\n+equal to the `ident` given in the `use_decl`.\n+\n+Optionally, an identifier in an `extern mod` declaration may be followed by an equals sign,\n+then a string literal denoting a relative path on the filesystem.\n+This path should exist in one of the directories in the Rust path,\n+which by default contains the `.rust` subdirectory of the current directory and each of its parents,\n+as well as any directories in the colon-separated (or semicolon-separated on Windows)\n+list of paths that is the `RUST_PATH` environment variable.\n+The meaning of `extern mod a = \"b/c/d\";`, supposing that `/a` is in the RUST_PATH,\n+is that the name `a` should be taken as a reference to the crate whose absolute location is\n+`/a/b/c/d`.\n+\n+Four examples of `extern mod` declarations:\n \n ~~~~~~~~{.xfail-test}\n extern mod pcre (uuid = \"54aba0f8-a7b1-4beb-92f1-4cf625264841\");\n \n extern mod extra; // equivalent to: extern mod extra ( name = \"extra\" );\n \n extern mod rustextra (name = \"extra\"); // linking to 'extra' under another name\n+\n+extern mod complicated_mod = \"some-file/in/the-rust/path\";\n ~~~~~~~~\n \n ##### Use declarations"}, {"sha": "536a153b22281826f2cd399e5a2652182cf3e21f", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -348,7 +348,7 @@ $(3)/stage$(1)/test/rustpkgtest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t\t$$(RUSTPKG_LIB) $$(RUSTPKG_INPUTS)\t\t\\\n \t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2)) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2))\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2)) \\\n \t\t$$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$$(X_$(2))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test"}, {"sha": "bd95f1b735b0021a9d86046edb24271781b69202", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -16,7 +16,7 @@ use lib::llvm::llvm;\n use lib::llvm::ModuleRef;\n use lib;\n use metadata::common::LinkMeta;\n-use metadata::{encoder, csearch, cstore};\n+use metadata::{encoder, csearch, cstore, filesearch};\n use middle::trans::context::CrateContext;\n use middle::trans::common::gensym_name;\n use middle::ty;\n@@ -497,35 +497,40 @@ pub fn build_link_meta(sess: Session,\n     struct ProvidedMetas {\n         name: Option<@str>,\n         vers: Option<@str>,\n+        pkg_id: Option<@str>,\n         cmh_items: ~[@ast::MetaItem]\n     }\n \n     fn provided_link_metas(sess: Session, c: &ast::Crate) ->\n        ProvidedMetas {\n         let mut name = None;\n         let mut vers = None;\n+        let mut pkg_id = None;\n         let mut cmh_items = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for meta in linkage_metas.iter() {\n             match meta.name_str_pair() {\n                 Some((n, value)) if \"name\" == n => name = Some(value),\n                 Some((n, value)) if \"vers\" == n => vers = Some(value),\n+                Some((n, value)) if \"package_id\" == n => pkg_id = Some(value),\n                 _ => cmh_items.push(*meta)\n             }\n         }\n \n         ProvidedMetas {\n             name: name,\n             vers: vers,\n+            pkg_id: pkg_id,\n             cmh_items: cmh_items\n         }\n     }\n \n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(symbol_hasher: &mut hash::State,\n                               cmh_items: ~[@ast::MetaItem],\n-                              dep_hashes: ~[@str]) -> @str {\n+                              dep_hashes: ~[@str],\n+                              pkg_id: Option<@str>) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n             fmt!(\"%u_%s\", s.len(), s)\n         }\n@@ -563,7 +568,10 @@ pub fn build_link_meta(sess: Session,\n             write_string(symbol_hasher, len_and_str(*dh));\n         }\n \n-    // tjc: allocation is unfortunate; need to change std::hash\n+        for p in pkg_id.iter() {\n+            write_string(symbol_hasher, len_and_str(*p));\n+        }\n+\n         return truncated_hash_result(symbol_hasher).to_managed();\n     }\n \n@@ -605,18 +613,20 @@ pub fn build_link_meta(sess: Session,\n     let ProvidedMetas {\n         name: opt_name,\n         vers: opt_vers,\n+        pkg_id: opt_pkg_id,\n         cmh_items: cmh_items\n     } = provided_link_metas(sess, c);\n     let name = crate_meta_name(sess, output, opt_name);\n     let vers = crate_meta_vers(sess, opt_vers);\n     let dep_hashes = cstore::get_dep_hashes(sess.cstore);\n     let extras_hash =\n         crate_meta_extras_hash(symbol_hasher, cmh_items,\n-                               dep_hashes);\n+                               dep_hashes, opt_pkg_id);\n \n     LinkMeta {\n         name: name,\n         vers: vers,\n+        package_id: opt_pkg_id,\n         extras_hash: extras_hash\n     }\n }\n@@ -939,6 +949,11 @@ pub fn link_args(sess: Session,\n         args.push(~\"-L\" + path.to_str());\n     }\n \n+    let rustpath = filesearch::rust_path();\n+    for path in rustpath.iter() {\n+        args.push(~\"-L\" + path.to_str());\n+    }\n+\n     // The names of the extern libraries\n     let used_libs = cstore::get_used_libraries(cstore);\n     for l in used_libs.iter() { args.push(~\"-l\" + *l); }"}, {"sha": "231295475621eead6424dc109cc4d2891f2f637e", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 4, "deletions": 113, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -14,10 +14,7 @@ use metadata::cstore;\n use metadata::filesearch;\n \n use std::hashmap::HashSet;\n-use std::num;\n-use std::os;\n-use std::util;\n-use std::vec;\n+use std::{num, os, path, uint, util, vec};\n \n fn not_win32(os: session::os) -> bool {\n   os != session::os_win32\n@@ -122,42 +119,7 @@ pub fn get_rpath_relative_to_output(os: session::os,\n         session::os_win32 => util::unreachable()\n     };\n \n-    Path(prefix).push_rel(&get_relative_to(&os::make_absolute(output),\n-                                           &os::make_absolute(lib)))\n-}\n-\n-// Find the relative path from one file to another\n-pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n-    assert!(abs1.is_absolute);\n-    assert!(abs2.is_absolute);\n-    let abs1 = abs1.normalize();\n-    let abs2 = abs2.normalize();\n-    debug!(\"finding relative path from %s to %s\",\n-           abs1.to_str(), abs2.to_str());\n-    let split1: &[~str] = abs1.components;\n-    let split2: &[~str] = abs2.components;\n-    let len1 = split1.len();\n-    let len2 = split2.len();\n-    assert!(len1 > 0);\n-    assert!(len2 > 0);\n-\n-    let max_common_path = num::min(len1, len2) - 1;\n-    let mut start_idx = 0;\n-    while start_idx < max_common_path\n-        && split1[start_idx] == split2[start_idx] {\n-        start_idx += 1;\n-    }\n-\n-    let mut path = ~[];\n-    for _ in range(start_idx, len1 - 1) { path.push(~\"..\"); };\n-\n-    path.push_all(split2.slice(start_idx, len2 - 1));\n-\n-    return if !path.is_empty() {\n-        Path(\"\").push_many(path)\n-    } else {\n-        Path(\".\")\n-    }\n+    Path(prefix).push_rel(&os::make_absolute(output).get_relative_to(&os::make_absolute(lib)))\n }\n \n fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n@@ -199,8 +161,7 @@ mod test {\n     #[cfg(test)]\n     #[cfg(test)]\n     use back::rpath::{get_absolute_rpath, get_install_prefix_rpath};\n-    use back::rpath::{get_relative_to, get_rpath_relative_to_output};\n-    use back::rpath::{minimize_rpaths, rpaths_to_flags};\n+    use back::rpath::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n     use driver::session;\n \n     #[test]\n@@ -244,78 +205,9 @@ mod test {\n         assert_eq!(res, ~[Path(\"1a\"), Path(\"2\"), Path(\"4a\"), Path(\"3\")]);\n     }\n \n-    #[test]\n-    fn test_relative_to1() {\n-        let p1 = Path(\"/usr/bin/rustc\");\n-        let p2 = Path(\"/usr/lib/mylib\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"../lib\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to2() {\n-        let p1 = Path(\"/usr/bin/rustc\");\n-        let p2 = Path(\"/usr/bin/../lib/mylib\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"../lib\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to3() {\n-        let p1 = Path(\"/usr/bin/whatever/rustc\");\n-        let p2 = Path(\"/usr/lib/whatever/mylib\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"../../lib/whatever\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to4() {\n-        let p1 = Path(\"/usr/bin/whatever/../rustc\");\n-        let p2 = Path(\"/usr/lib/whatever/mylib\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"../lib/whatever\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to5() {\n-        let p1 = Path(\"/usr/bin/whatever/../rustc\");\n-        let p2 = Path(\"/usr/lib/whatever/../mylib\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"../lib\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to6() {\n-        let p1 = Path(\"/1\");\n-        let p2 = Path(\"/2/3\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"2\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to7() {\n-        let p1 = Path(\"/1/2\");\n-        let p2 = Path(\"/3\");\n-        let res = get_relative_to(&p1, &p2);\n-        assert_eq!(res, Path(\"..\"));\n-    }\n-\n-    #[test]\n-    fn test_relative_to8() {\n-        let p1 = Path(\"/home/brian/Dev/rust/build/\").push_rel(\n-            &Path(\"stage2/lib/rustc/i686-unknown-linux-gnu/lib/librustc.so\"));\n-        let p2 = Path(\"/home/brian/Dev/rust/build/stage2/bin/..\").push_rel(\n-            &Path(\"lib/rustc/i686-unknown-linux-gnu/lib/libstd.so\"));\n-        let res = get_relative_to(&p1, &p2);\n-        debug!(\"test_relative_tu8: %s vs. %s\",\n-               res.to_str(),\n-               Path(\".\").to_str());\n-        assert_eq!(res, Path(\".\"));\n-    }\n-\n     #[test]\n     #[cfg(target_os = \"linux\")]\n-    #[cfg(target_os = \"andorid\")]\n+    #[cfg(target_os = \"android\")]\n     fn test_rpath_relative() {\n       let o = session::os_linux;\n       let res = get_rpath_relative_to_output(o,\n@@ -335,7 +227,6 @@ mod test {\n     #[test]\n     #[cfg(target_os = \"macos\")]\n     fn test_rpath_relative() {\n-        // this is why refinements would be nice\n         let o = session::os_macos;\n         let res = get_rpath_relative_to_output(o,\n                                                &Path(\"bin/rustc\"),"}, {"sha": "2a61ea28e0c6b3452c6118b4faf403e4db10cbc6", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -47,7 +47,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n             let n1 = sess.next_node_id();\n             let vi1 = ast::view_item {\n                 node: ast::view_item_extern_mod(\n-                        sess.ident_of(\"std\"), ~[], n1),\n+                        sess.ident_of(\"std\"), None, ~[], n1),\n                 attrs: ~[\n                     attr::mk_attr(\n                         attr::mk_name_value_item_str(@\"vers\", STD_VERSION.to_managed()))"}, {"sha": "c6b1bdbe51ba1299fc7a6dfcc1d01403cd3ab925", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -282,7 +282,7 @@ fn mk_std(cx: &TestCtxt) -> ast::view_item {\n                                             cx.sess.next_node_id()))])\n     } else {\n         let mi = attr::mk_name_value_item_str(@\"vers\", @\"0.8-pre\");\n-        ast::view_item_extern_mod(id_extra, ~[mi], cx.sess.next_node_id())\n+        ast::view_item_extern_mod(id_extra, None, ~[mi], cx.sess.next_node_id())\n     };\n     ast::view_item {\n         node: vi,"}, {"sha": "f2d8b68faa6f3b7a655e5e6637830c5a0bb6e58a", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -185,5 +185,7 @@ pub static tag_item_impl_vtables: uint = 0x82;\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,\n+    // Optional package ID\n+    package_id: Option<@str>, // non-None if this was a URL-like package ID\n     extras_hash: @str\n }"}, {"sha": "0a9e8490f22dcce28a5d3320d9403093b6d8a58e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -18,6 +18,7 @@ use metadata::loader;\n \n use std::hashmap::HashMap;\n use syntax::ast;\n+use std::vec;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{span, dummy_sp};\n@@ -137,18 +138,33 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n \n fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n     match i.node {\n-      ast::view_item_extern_mod(ident, ref meta_items, id) => {\n-        debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n-               ident, *meta_items);\n-        let cnum = resolve_crate(e,\n-                                 ident,\n-                                 (*meta_items).clone(),\n-                                 @\"\",\n-                                 i.span);\n-        cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n+      ast::view_item_extern_mod(ident, path_opt, ref meta_items, id) => {\n+          let ident = token::ident_to_str(&ident);\n+          let meta_items = match path_opt {\n+              None => meta_items.clone(),\n+              Some(p) => {\n+                  let p_path = Path(p);\n+                  match p_path.filestem() {\n+                      Some(s) =>\n+                          vec::append(\n+                              ~[attr::mk_name_value_item_str(@\"package_id\", p),\n+                               attr::mk_name_value_item_str(@\"name\", s.to_managed())],\n+                              *meta_items),\n+                      None => e.diag.span_bug(i.span, \"Bad package path in `extern mod` item\")\n+                  }\n+            }\n+          };\n+          debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n+                 ident, meta_items);\n+          let cnum = resolve_crate(e,\n+                                   ident,\n+                                   meta_items,\n+                                   @\"\",\n+                                   i.span);\n+          cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ => ()\n-    }\n+  }\n }\n \n fn visit_item(e: &Env, i: @ast::item) {\n@@ -233,12 +249,12 @@ fn existing_match(e: &Env, metas: &[@ast::MetaItem], hash: &str)\n }\n \n fn resolve_crate(e: @mut Env,\n-                 ident: ast::ident,\n+                 ident: @str,\n                  metas: ~[@ast::MetaItem],\n                  hash: @str,\n                  span: span)\n               -> ast::CrateNum {\n-    let metas = metas_with_ident(token::ident_to_str(&ident), metas);\n+    let metas = metas_with_ident(ident, metas);\n \n     match existing_match(e, metas, hash) {\n       None => {\n@@ -279,7 +295,7 @@ fn resolve_crate(e: @mut Env,\n             match attr::last_meta_item_value_str_by_name(load_ctxt.metas,\n                                                          \"name\") {\n                 Some(v) => v,\n-                None => token::ident_to_str(&ident),\n+                None => ident\n             };\n         let cmeta = @cstore::crate_metadata {\n             name: cname,\n@@ -308,7 +324,6 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     let r = decoder::get_crate_deps(cdata);\n     for dep in r.iter() {\n         let extrn_cnum = dep.cnum;\n-        let cname = dep.name;\n         let cname_str = token::ident_to_str(&dep.name);\n         let cmetas = metas_with(dep.vers, @\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n@@ -327,7 +342,7 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n             let fake_span = dummy_sp();\n-            let local_cnum = resolve_crate(e, cname, cmetas, dep.hash,\n+            let local_cnum = resolve_crate(e, cname_str, cmetas, dep.hash,\n                                            fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }"}, {"sha": "2311ef0696199bcda518141c1e92c3deec4fd138", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 79, "deletions": 64, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -11,12 +11,15 @@\n \n use std::option;\n use std::os;\n-use std::result;\n+use std::{result, str};\n+use std::hashmap::HashSet;\n \n // A module for searching for libraries\n // FIXME (#2658): I'm not happy how this module turned out. Should\n // probably just be folded into cstore.\n \n+/// Functions with type `pick` take a parent directory as well as\n+/// a file found in that directory.\n pub type pick<'self, T> = &'self fn(path: &Path) -> Option<T>;\n \n pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n@@ -46,28 +49,33 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     impl FileSearch for FileSearchImpl {\n         fn sysroot(&self) -> @Path { self.sysroot }\n         fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool {\n+            let mut visited_dirs = HashSet::new();\n+\n             debug!(\"filesearch: searching additional lib search paths [%?]\",\n                    self.addl_lib_search_paths.len());\n-            // a little weird\n-            self.addl_lib_search_paths.iter().advance(|path| f(path));\n+            for path in self.addl_lib_search_paths.iter() {\n+                f(path);\n+                visited_dirs.insert(path.to_str());\n+            }\n \n             debug!(\"filesearch: searching target lib path\");\n-            if !f(&make_target_lib_path(self.sysroot,\n-                                        self.target_triple)) {\n-                return false;\n-            }\n-            debug!(\"filesearch: searching rustpkg lib path nearest\");\n-            if match get_rustpkg_lib_path_nearest() {\n-                    result::Ok(ref p) => f(p),\n-                    result::Err(_) => true\n-                } {\n-                    return true;\n+            let tlib_path = make_target_lib_path(self.sysroot,\n+                                        self.target_triple);\n+            if !visited_dirs.contains(&tlib_path.to_str()) {\n+                if !f(&tlib_path) {\n+                    return false;\n                 }\n-           debug!(\"filesearch: searching rustpkg lib path\");\n-           match get_rustpkg_lib_path() {\n-              result::Ok(ref p) => f(p),\n-              result::Err(_) => true\n-           }\n+            }\n+            visited_dirs.insert(tlib_path.to_str());\n+            // Try RUST_PATH\n+            let rustpath = rust_path();\n+            for path in rustpath.iter() {\n+                    if !visited_dirs.contains(&path.push(\"lib\").to_str()) {\n+                        f(&path.push(\"lib\"));\n+                        visited_dirs.insert(path.push(\"lib\").to_str());\n+                    }\n+            }\n+            true\n         }\n         fn get_target_lib_path(&self) -> Path {\n             make_target_lib_path(self.sysroot, self.target_triple)\n@@ -94,12 +102,15 @@ pub fn search<T>(filesearch: @FileSearch, pick: pick<T>) -> Option<T> {\n         for path in r.iter() {\n             debug!(\"testing %s\", path.to_str());\n             let maybe_picked = pick(path);\n-            if maybe_picked.is_some() {\n-                debug!(\"picked %s\", path.to_str());\n-                rslt = maybe_picked;\n-                break;\n-            } else {\n-                debug!(\"rejected %s\", path.to_str());\n+            match maybe_picked {\n+                Some(_) => {\n+                    debug!(\"picked %s\", path.to_str());\n+                    rslt = maybe_picked;\n+                    break;\n+                }\n+                None => {\n+                    debug!(\"rejected %s\", path.to_str());\n+                }\n             }\n         }\n         rslt.is_none()\n@@ -132,55 +143,59 @@ fn get_sysroot(maybe_sysroot: &Option<@Path>) -> @Path {\n     }\n }\n \n-pub fn get_rustpkg_sysroot() -> Result<Path, ~str> {\n-    result::Ok(get_or_default_sysroot().push_many([libdir(), ~\"rustpkg\"]))\n+#[cfg(windows)]\n+static PATH_ENTRY_SEPARATOR: &'static str = \";\";\n+#[cfg(not(windows))]\n+static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n+\n+/// Returns RUST_PATH as a string, without default paths added\n+pub fn get_rust_path() -> Option<~str> {\n+    os::getenv(\"RUST_PATH\")\n }\n \n-pub fn get_rustpkg_root() -> Result<Path, ~str> {\n-    match os::getenv(\"RUSTPKG_ROOT\") {\n-        Some(ref _p) => result::Ok(Path((*_p))),\n-        None => match os::homedir() {\n-          Some(ref _q) => result::Ok((*_q).push(\".rustpkg\")),\n-          None => result::Err(~\"no RUSTPKG_ROOT or home directory\")\n+/// Returns the value of RUST_PATH, as a list\n+/// of Paths. Includes default entries for, if they exist:\n+/// $HOME/.rust\n+/// DIR/.rust for any DIR that's the current working directory\n+/// or an ancestor of it\n+pub fn rust_path() -> ~[Path] {\n+    let mut env_rust_path: ~[Path] = match get_rust_path() {\n+        Some(env_path) => {\n+            let env_path_components: ~[&str] =\n+                env_path.split_str_iter(PATH_ENTRY_SEPARATOR).collect();\n+            env_path_components.map(|&s| Path(s))\n         }\n+        None => ~[]\n+    };\n+    let cwd = os::getcwd();\n+    // now add in default entries\n+    let cwd_dot_rust = cwd.push(\".rust\");\n+    if !env_rust_path.contains(&cwd_dot_rust) {\n+        env_rust_path.push(cwd_dot_rust);\n     }\n-}\n-\n-pub fn get_rustpkg_root_nearest() -> Result<Path, ~str> {\n-    do get_rustpkg_root().chain |p| {\n-        let cwd = os::getcwd();\n-        let cwd_rustpkg = cwd.push(\".rustpkg\");\n-        let rustpkg_is_non_root_file =\n-            !os::path_is_dir(&cwd_rustpkg) && cwd_rustpkg != p;\n-        let mut par_rustpkg = cwd.pop().push(\".rustpkg\");\n-        let mut rslt = result::Ok(cwd_rustpkg);\n-\n-        if rustpkg_is_non_root_file {\n-            while par_rustpkg != p {\n-                if os::path_is_dir(&par_rustpkg) {\n-                    rslt = result::Ok(par_rustpkg);\n-                    break;\n-                }\n-                if par_rustpkg.components.len() == 1 {\n-                    // We just checked /.rustpkg, stop now.\n-                    break;\n-                }\n-                par_rustpkg = par_rustpkg.pop().pop().push(\".rustpkg\");\n-            }\n+    if !env_rust_path.contains(&cwd) {\n+        env_rust_path.push(cwd.clone());\n+    }\n+    do cwd.each_parent() |p| {\n+        if !env_rust_path.contains(&p.push(\".rust\")) {\n+            push_if_exists(&mut env_rust_path, p);\n         }\n-        rslt\n     }\n-}\n-\n-fn get_rustpkg_lib_path() -> Result<Path, ~str> {\n-    do get_rustpkg_root().chain |p| {\n-        result::Ok(p.push(libdir()))\n+    let h = os::homedir();\n+    for h in h.iter() {\n+        if !env_rust_path.contains(&h.push(\".rust\")) {\n+            push_if_exists(&mut env_rust_path, h);\n+        }\n     }\n+    env_rust_path\n }\n \n-fn get_rustpkg_lib_path_nearest() -> Result<Path, ~str> {\n-    do get_rustpkg_root_nearest().chain |p| {\n-        result::Ok(p.push(libdir()))\n+\n+/// Adds p/.rust into vec, only if it exists\n+fn push_if_exists(vec: &mut ~[Path], p: &Path) {\n+    let maybe_dir = p.push(\".rust\");\n+    if os::path_exists(&maybe_dir) {\n+        vec.push(maybe_dir);\n     }\n }\n "}, {"sha": "5f145d87ca8d54ad5da0565a8913bcd689d527b7", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -18,7 +18,6 @@ use metadata::filesearch::FileSearch;\n use metadata::filesearch;\n use syntax::codemap::span;\n use syntax::diagnostic::span_handler;\n-use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::{ast, attr};\n@@ -46,7 +45,7 @@ pub struct Context {\n     diag: @span_handler,\n     filesearch: @FileSearch,\n     span: span,\n-    ident: ast::ident,\n+    ident: @str,\n     metas: ~[@ast::MetaItem],\n     hash: @str,\n     os: os,\n@@ -60,7 +59,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n       None => {\n         cx.diag.span_fatal(cx.span,\n                            fmt!(\"can't find crate for `%s`\",\n-                                token::ident_to_str(&cx.ident)));\n+                                cx.ident));\n       }\n     }\n }\n@@ -89,37 +88,38 @@ fn find_library_crate_aux(\n     filesearch: @filesearch::FileSearch\n ) -> Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(cx.metas);\n-    let prefix = prefix + crate_name + \"-\";\n-\n+    // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n+    let prefix = fmt!(\"%s%s-\", prefix, crate_name);\n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| -> Option<()> {\n-        debug!(\"inspecting file %s\", path.to_str());\n-        match path.filename() {\n-            Some(ref f) if f.starts_with(prefix) && f.ends_with(suffix) => {\n-                debug!(\"%s is a candidate\", path.to_str());\n-                match get_metadata_section(cx.os, path) {\n-                    Some(cvec) =>\n-                        if !crate_matches(cvec, cx.metas, cx.hash) {\n-                            debug!(\"skipping %s, metadata doesn't match\",\n-                                   path.to_str());\n-                            None\n-                        } else {\n-                            debug!(\"found %s with matching metadata\", path.to_str());\n-                            matches.push((path.to_str(), cvec));\n-                            None\n-                        },\n-                    _ => {\n-                        debug!(\"could not load metadata for %s\", path.to_str());\n-                        None\n-                    }\n-                }\n-            }\n-            _ => {\n-                debug!(\"skipping %s, doesn't look like %s*%s\", path.to_str(),\n-                       prefix, suffix);\n-                None\n-            }\n-        }});\n+      let path_str = path.filename();\n+      match path_str {\n+          None => None,\n+          Some(path_str) =>\n+              if path_str.starts_with(prefix) && path_str.ends_with(suffix) {\n+                  debug!(\"%s is a candidate\", path.to_str());\n+                  match get_metadata_section(cx.os, path) {\n+                      Some(cvec) =>\n+                          if !crate_matches(cvec, cx.metas, cx.hash) {\n+                              debug!(\"skipping %s, metadata doesn't match\",\n+                                  path.to_str());\n+                              None\n+                          } else {\n+                              debug!(\"found %s with matching metadata\", path.to_str());\n+                              matches.push((path.to_str(), cvec));\n+                              None\n+                          },\n+                      _ => {\n+                          debug!(\"could not load metadata for %s\", path.to_str());\n+                          None\n+                      }\n+                  }\n+               }\n+               else {\n+                   None\n+               }\n+      }\n+    });\n \n     match matches.len() {\n         0 => None,\n@@ -137,8 +137,8 @@ fn find_library_crate_aux(\n                 }\n                 cx.diag.handler().abort_if_errors();\n                 None\n-            }\n         }\n+    }\n }\n \n pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n@@ -151,6 +151,16 @@ pub fn crate_name_from_metas(metas: &[@ast::MetaItem]) -> @str {\n     fail!(\"expected to find the crate name\")\n }\n \n+pub fn package_id_from_metas(metas: &[@ast::MetaItem]) -> Option<@str> {\n+    for m in metas.iter() {\n+        match m.name_str_pair() {\n+            Some((name, s)) if \"package_id\" == name => { return Some(s); }\n+            _ => {}\n+        }\n+    }\n+    None\n+}\n+\n pub fn note_linkage_attrs(intr: @ident_interner,\n                           diag: @span_handler,\n                           attrs: ~[ast::Attribute]) {\n@@ -175,6 +185,8 @@ fn crate_matches(crate_data: @~[u8],\n pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n                         local_metas: &[@ast::MetaItem]) -> bool {\n \n+// extern_metas: metas we read from the crate\n+// local_metas: metas we're looking for\n     debug!(\"matching %u metadata requirements against %u items\",\n            local_metas.len(), extern_metas.len());\n "}, {"sha": "6ffe7c17ff612785f3420d7bb4bc4a7160663238", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -1487,9 +1487,10 @@ impl Resolver {\n                 }\n             }\n \n-            view_item_extern_mod(name, _, node_id) => {\n+            view_item_extern_mod(name, _, _, node_id) => {\n+                // n.b. we don't need to look at the path option here, because cstore already did\n                 match find_extern_mod_stmt_cnum(self.session.cstore,\n-                                                node_id) {\n+                                                        node_id) {\n                     Some(crate_id) => {\n                         let def_id = def_id { crate: crate_id, node: 0 };\n                         let parent_link = ModuleParentLink"}, {"sha": "2da66baa412b57914b7d27e535ffac99d36505dd", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -23,33 +23,30 @@ fn default_ctxt(p: @Path) -> Ctx {\n     Ctx { sysroot_opt: Some(p), json: false, dep_cache: @mut HashMap::new() }\n }\n \n-pub fn build_lib(sysroot: @Path, root: Path, dest: Path, name: ~str, version: Version,\n+pub fn build_lib(sysroot: @Path, root: Path, name: ~str, version: Version,\n                  lib: Path) {\n \n     let pkg_src = PkgSrc {\n         root: root,\n-        dst_dir: dest.clone(),\n-        id: PkgId{ version: version, ..PkgId::new(name, &dest.pop())},\n+        id: PkgId{ version: version, ..PkgId::new(name)},\n         libs: ~[mk_crate(lib)],\n         mains: ~[],\n         tests: ~[],\n         benchs: ~[]\n     };\n-    pkg_src.build(&default_ctxt(sysroot), pkg_src.dst_dir, ~[]);\n+    pkg_src.build(&default_ctxt(sysroot), ~[]);\n }\n \n-pub fn build_exe(sysroot: @Path, root: Path, dest: Path, name: ~str, version: Version,\n-                 main: Path) {\n+pub fn build_exe(sysroot: @Path, root: Path, name: ~str, version: Version, main: Path) {\n     let pkg_src = PkgSrc {\n         root: root,\n-        dst_dir: dest.clone(),\n-        id: PkgId{ version: version, ..PkgId::new(name, &dest.pop())},\n+        id: PkgId{ version: version, ..PkgId::new(name)},\n         libs: ~[],\n         mains: ~[mk_crate(main)],\n         tests: ~[],\n         benchs: ~[]\n     };\n-    pkg_src.build(&default_ctxt(sysroot), pkg_src.dst_dir, ~[]);\n+    pkg_src.build(&default_ctxt(sysroot), ~[]);\n \n }\n \n@@ -62,26 +59,23 @@ pub fn install_lib(sysroot: @Path,\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     debug!(\"workspace = %s\", workspace.to_str());\n     // make a PkgSrc\n-    let pkg_id = PkgId{ version: version, ..PkgId::new(name, &workspace)};\n-    let build_dir = workspace.push(\"build\");\n-    let dst_dir = build_dir.push_rel(&*pkg_id.local_path);\n+    let pkg_id = PkgId{ version: version, ..PkgId::new(name)};\n     let pkg_src = PkgSrc {\n         root: workspace.clone(),\n-        dst_dir: dst_dir.clone(),\n         id: pkg_id.clone(),\n         libs: ~[mk_crate(lib_path)],\n         mains: ~[],\n         tests: ~[],\n         benchs: ~[]\n     };\n     let cx = default_ctxt(sysroot);\n-    pkg_src.build(&cx, dst_dir, ~[]);\n+    pkg_src.build(&cx, ~[]);\n     cx.install_no_build(&workspace, &pkg_id);\n }\n \n pub fn install_exe(sysroot: @Path, workspace: Path, name: ~str, version: Version) {\n     default_ctxt(sysroot).install(&workspace, &PkgId{ version: version,\n-                                            ..PkgId::new(name, &workspace)});\n+                                            ..PkgId::new(name)});\n \n }\n "}, {"sha": "f051be25f266da111c12f204e41b992200fc0c2e", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -12,6 +12,7 @@\n \n \n use std::hashmap::HashMap;\n+use std::os;\n \n pub struct Ctx {\n     // Sysroot -- if this is None, uses rustc filesearch's\n@@ -23,3 +24,26 @@ pub struct Ctx {\n     // though I'm not sure why the value is a bool\n     dep_cache: @mut HashMap<~str, bool>,\n }\n+\n+impl Ctx {\n+    /// Debugging\n+    pub fn sysroot_opt_str(&self) -> ~str {\n+        match self.sysroot_opt {\n+            None => ~\"[none]\",\n+            Some(p) => p.to_str()\n+        }\n+    }\n+}\n+\n+/// We assume that if ../../rustc exists, then we're running\n+/// rustpkg from a Rust target directory. This is part of a\n+/// kludgy hack used to adjust the sysroot.\n+pub fn in_target(sysroot_opt: Option<@Path>) -> bool {\n+    match sysroot_opt {\n+        None => false,\n+        Some(p) => {\n+            debug!(\"Checking whether %s is in target\", p.to_str());\n+            os::path_is_dir(&p.pop().pop().push(\"rustc\"))\n+        }\n+    }\n+}"}, {"sha": "7c3cde655173b49454d8cdfaf4cd5138b73744f8", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -10,6 +10,7 @@\n \n // Listing installed packages\n \n+use rustc::metadata::filesearch::rust_path;\n use path_util::*;\n use std::os;\n \n@@ -20,21 +21,46 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n         for exec in binfiles.iter() {\n             let exec_path = Path(*exec).filestem();\n             do exec_path.iter().advance |s| {\n-                f(&PkgId::new(*s, p))\n+                f(&PkgId::new(*s))\n             };\n         }\n         let libfiles = os::list_dir(&p.push(\"lib\"));\n         for lib in libfiles.iter() {\n-            debug!(\"Full name: %s\", *lib);\n-            let lib_path = Path(*lib).filestem();\n-            do lib_path.iter().advance |s| {\n-                f(&PkgId::new(*s, p))\n-            };\n-        }\n+            let lib = Path(*lib);\n+            debug!(\"Full name: %s\", lib.to_str());\n+            match has_library(&lib) {\n+                Some(basename) => {\n+                    debug!(\"parent = %s, child = %s\",\n+                           p.push(\"lib\").to_str(), lib.to_str());\n+                    let rel_p = p.push(\"lib/\").get_relative_to(&lib);\n+                    debug!(\"Rel: %s\", rel_p.to_str());\n+                    let rel_path = rel_p.push(basename).to_str();\n+                    debug!(\"Rel name: %s\", rel_path);\n+                    f(&PkgId::new(rel_path));\n+                }\n+                None => ()\n+            }\n+        };\n     }\n     true\n }\n \n+pub fn has_library(p: &Path) -> Option<~str> {\n+    let files = os::list_dir(p);\n+    for q in files.iter() {\n+        let as_path = Path(*q);\n+        if as_path.filetype() == Some(os::consts::DLL_SUFFIX.to_owned()) {\n+            let stuff : ~str = as_path.filestem().expect(\"has_library: weird path\");\n+            let mut stuff2 = stuff.split_str_iter(&\"-\");\n+            let stuff3: ~[&str] = stuff2.collect();\n+            // argh\n+            let chars_to_drop = os::consts::DLL_PREFIX.len();\n+            return Some(stuff3[0].slice(chars_to_drop, stuff3[0].len()).to_owned());\n+        }\n+    }\n+    None\n+}\n+\n pub fn package_is_installed(p: &PkgId) -> bool {\n     let mut is_installed = false;\n     do list_installed_packages() |installed| {\n@@ -44,4 +70,4 @@ pub fn package_is_installed(p: &PkgId) -> bool {\n         false\n     };\n     is_installed\n-}\n\\ No newline at end of file\n+}"}, {"sha": "233e975cbb7e49bba3121747a1abd0cd5b23c514", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -45,7 +45,7 @@ impl PkgId {\n     // The PkgId constructor takes a Path argument so as\n     // to be able to infer the version if the path refers\n     // to a local git repository\n-    pub fn new(s: &str, work_dir: &Path) -> PkgId {\n+    pub fn new(s: &str) -> PkgId {\n         use conditions::bad_pkg_id::cond;\n \n         let mut given_version = None;\n@@ -76,7 +76,7 @@ impl PkgId {\n \n         let version = match given_version {\n             Some(v) => v,\n-            None => match try_getting_local_version(&work_dir.push_rel(&*local_path)) {\n+            None => match try_getting_local_version(&*local_path) {\n                 Some(v) => v,\n                 None => match try_getting_version(&remote_path) {\n                     Some(v) => v,\n@@ -103,6 +103,11 @@ impl PkgId {\n     pub fn short_name_with_version(&self) -> ~str {\n         fmt!(\"%s%s\", self.short_name, self.version.to_str())\n     }\n+\n+    /// True if the ID has multiple components\n+    pub fn is_complex(&self) -> bool {\n+        self.short_name != self.local_path.to_str()\n+     }\n }\n \n impl ToStr for PkgId {"}, {"sha": "b14f95cfae583c0ab428920ec13d1f40ff5b2e2e", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -23,7 +23,6 @@ use util::compile_crate;\n // This contains a list of files found in the source workspace.\n pub struct PkgSrc {\n     root: Path, // root of where the package source code lives\n-    dst_dir: Path, // directory where we will put the compiled output\n     id: PkgId,\n     libs: ~[Crate],\n     mains: ~[Crate],\n@@ -37,11 +36,9 @@ condition! {\n \n impl PkgSrc {\n \n-    pub fn new(src_dir: &Path, dst_dir: &Path,\n-                  id: &PkgId) -> PkgSrc {\n+    pub fn new(src_dir: &Path, id: &PkgId) -> PkgSrc {\n         PkgSrc {\n             root: (*src_dir).clone(),\n-            dst_dir: (*dst_dir).clone(),\n             id: (*id).clone(),\n             libs: ~[],\n             mains: ~[],\n@@ -202,20 +199,20 @@ impl PkgSrc {\n \n     fn build_crates(&self,\n                     ctx: &Ctx,\n-                    dst_dir: &Path,\n                     src_dir: &Path,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n                     what: OutputType) {\n         for crate in crates.iter() {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n-            note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n+            note(fmt!(\"build_crates: using as workspace %s\", self.root.to_str()));\n \n             let result = compile_crate(ctx,\n                                        &self.id,\n                                        path,\n-                                       dst_dir,\n+                                       // compile_crate wants the workspace\n+                                       &self.root,\n                                        crate.flags,\n                                        crate.cfgs + cfgs,\n                                        false,\n@@ -229,15 +226,15 @@ impl PkgSrc {\n         }\n     }\n \n-    pub fn build(&self, ctx: &Ctx, dst_dir: Path, cfgs: ~[~str]) {\n+    pub fn build(&self, ctx: &Ctx, cfgs: ~[~str]) {\n         let dir = self.check_dir();\n         debug!(\"Building libs in %s\", dir.to_str());\n-        self.build_crates(ctx, &dst_dir, &dir, self.libs, cfgs, Lib);\n+        self.build_crates(ctx, &dir, self.libs, cfgs, Lib);\n         debug!(\"Building mains\");\n-        self.build_crates(ctx, &dst_dir, &dir, self.mains, cfgs, Main);\n+        self.build_crates(ctx, &dir, self.mains, cfgs, Main);\n         debug!(\"Building tests\");\n-        self.build_crates(ctx, &dst_dir, &dir, self.tests, cfgs, Test);\n+        self.build_crates(ctx, &dir, self.tests, cfgs, Test);\n         debug!(\"Building benches\");\n-        self.build_crates(ctx, &dst_dir, &dir, self.benchs, cfgs, Bench);\n+        self.build_crates(ctx, &dir, self.benchs, cfgs, Bench);\n     }\n }"}, {"sha": "3eff260e79a9df68ffa74bc261e0b0e4bfa064d6", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 28, "deletions": 75, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -14,61 +14,14 @@ pub use package_path::{RemotePath, LocalPath, normalize};\n pub use package_id::PkgId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n pub use version::{Version, NoVersion, split_version_general};\n+pub use rustc::metadata::filesearch::rust_path;\n+\n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os::mkdir_recursive;\n use std::os;\n-use std::iterator::IteratorUtil;\n use messages::*;\n use package_id::*;\n \n-fn push_if_exists(vec: &mut ~[Path], p: &Path) {\n-    let maybe_dir = p.push(\".rust\");\n-    if os::path_exists(&maybe_dir) {\n-        vec.push(maybe_dir);\n-    }\n-}\n-\n-#[cfg(windows)]\n-static PATH_ENTRY_SEPARATOR: &'static str = \";\";\n-#[cfg(not(windows))]\n-static PATH_ENTRY_SEPARATOR: &'static str = \":\";\n-\n-/// Returns RUST_PATH as a string, without default paths added\n-pub fn get_rust_path() -> Option<~str> {\n-    os::getenv(\"RUST_PATH\")\n-}\n-\n-/// Returns the value of RUST_PATH, as a list\n-/// of Paths. Includes default entries for, if they exist:\n-/// $HOME/.rust\n-/// DIR/.rust for any DIR that's the current working directory\n-/// or an ancestor of it\n-pub fn rust_path() -> ~[Path] {\n-    let mut env_rust_path: ~[Path] = match get_rust_path() {\n-        Some(env_path) => {\n-            let env_path_components: ~[&str] =\n-                env_path.split_str_iter(PATH_ENTRY_SEPARATOR).collect();\n-            env_path_components.map(|&s| Path(s))\n-        }\n-        None => ~[]\n-    };\n-    debug!(\"RUST_PATH entries from environment: %?\", env_rust_path);\n-    let cwd = os::getcwd();\n-    // now add in default entries\n-    env_rust_path.push(cwd.clone());\n-    do cwd.each_parent() |p| { push_if_exists(&mut env_rust_path, p) };\n-    let h = os::homedir();\n-    // Avoid adding duplicates\n-    // could still add dups if someone puts one of these in the RUST_PATH\n-    // manually, though...\n-    for hdir in h.iter() {\n-        if !(cwd.is_ancestor_of(hdir) || hdir.is_ancestor_of(&cwd)) {\n-            push_if_exists(&mut env_rust_path, hdir);\n-        }\n-    }\n-    env_rust_path\n-}\n-\n pub fn default_workspace() -> Path {\n     let p = rust_path();\n     if p.is_empty() {\n@@ -99,39 +52,39 @@ pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, U_RWX) }\n /// pkgid's short name\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     let src_dir = workspace.push(\"src\");\n-    let dirs = os::list_dir(&src_dir);\n-    for p in dirs.iter() {\n-        let p = Path((*p).clone());\n+    let mut found = false;\n+    do os::walk_dir(&src_dir) |p| {\n         debug!(\"=> p = %s\", p.to_str());\n-        if !os::path_is_dir(&src_dir.push_rel(&p)) {\n-            loop;\n-        }\n-        debug!(\"p = %s, remote_path = %s\", p.to_str(), pkgid.remote_path.to_str());\n+        if os::path_is_dir(p) {\n+            debug!(\"p = %s, path = %s [%s]\", p.to_str(), pkgid.path.to_str(),\n+            src_dir.push_rel(&pkgid.path).to_str());\n \n-        if p == *pkgid.remote_path {\n-            return true;\n-        }\n-        else {\n-            let pf = p.filename();\n-            for pf in pf.iter() {\n-                let f_ = (*pf).clone();\n-                let g = f_.to_str();\n-                match split_version_general(g, '-') {\n-                    Some((ref might_match, ref vers)) => {\n-                        debug!(\"might_match = %s, vers = %s\", *might_match,\n+            if *p == src_dir.push_rel(&pkgid.path) {\n+                found = true;\n+            }\n+            else {\n+                let pf = p.filename();\n+                for pf in pf.iter() {\n+                    let f_ = (*pf).clone();\n+                    let g = f_.to_str();\n+                    match split_version_general(g, '-') {\n+                        Some((ref might_match, ref vers)) => {\n+                            debug!(\"might_match = %s, vers = %s\", *might_match,\n                                vers.to_str());\n-                        if *might_match == pkgid.short_name\n-                            && (*vers == pkgid.version || pkgid.version == NoVersion)\n-                        {\n-                            return true;\n+                            if *might_match == pkgid.short_name\n+                                 && (*vers == pkgid.version || pkgid.version == NoVersion)\n+                            {\n+                                  found = true;\n+                            }\n                         }\n-                    }\n-                    None => ()\n+                        None => ()\n+                     }\n                 }\n             }\n         }\n-    }\n-    false\n+        true\n+    };\n+    found\n }\n \n /// Returns a list of possible directories"}, {"sha": "bac31478bdee8d6f3119cf4fadb212bcb36485e9", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -33,12 +33,13 @@ use std::hashmap::HashMap;\n \n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n+use rustc::metadata::filesearch::rust_path;\n use extra::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n use messages::*;\n use path_util::{build_pkg_id_in_workspace, first_pkgid_src_in_workspace};\n-use path_util::{U_RWX, rust_path, in_rust_path};\n+use path_util::{U_RWX, in_rust_path};\n use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use source_control::is_git_dir;\n@@ -138,35 +139,28 @@ impl<'self> PkgScript<'self> {\n         let crate = util::ready_crate(sess, self.crate);\n         debug!(\"Building output filenames with script name %s\",\n                driver::source_name(&self.input));\n-        match filesearch::get_rustpkg_sysroot() {\n-            Ok(r) => {\n-                let root = r.pop().pop().pop().pop(); // :-\\\n-                debug!(\"Root is %s, calling compile_rest\", root.to_str());\n-                let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n-                util::compile_crate_from_input(&self.input,\n-                                               &self.build_dir,\n-                                               sess,\n-                                               crate);\n-                debug!(\"Running program: %s %s %s %s\", exe.to_str(),\n-                       sysroot.to_str(), root.to_str(), \"install\");\n-                // FIXME #7401 should support commands besides `install`\n-                let status = run::process_status(exe.to_str(), [sysroot.to_str(), ~\"install\"]);\n-                if status != 0 {\n-                    return (~[], status);\n-                }\n-                else {\n-                    debug!(\"Running program (configs): %s %s %s\",\n-                           exe.to_str(), root.to_str(), \"configs\");\n-                    let output = run::process_output(exe.to_str(), [root.to_str(), ~\"configs\"]);\n-                    // Run the configs() function to get the configs\n-                    let cfgs = str::from_bytes_slice(output.output).word_iter()\n-                        .transform(|w| w.to_owned()).collect();\n-                    (cfgs, output.status)\n-                }\n-            }\n-            Err(e) => {\n-                fail!(\"Running package script, couldn't find rustpkg sysroot (%s)\", e)\n-            }\n+        let root = filesearch::get_or_default_sysroot().pop().pop(); // :-\\\n+        debug!(\"Root is %s, calling compile_rest\", root.to_str());\n+        let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n+        util::compile_crate_from_input(&self.input,\n+                                       &self.build_dir,\n+                                       sess,\n+                                       crate);\n+        debug!(\"Running program: %s %s %s %s\", exe.to_str(),\n+               sysroot.to_str(), root.to_str(), \"install\");\n+        // FIXME #7401 should support commands besides `install`\n+        let status = run::process_status(exe.to_str(), [sysroot.to_str(), ~\"install\"]);\n+        if status != 0 {\n+            return (~[], status);\n+        }\n+        else {\n+            debug!(\"Running program (configs): %s %s %s\",\n+                   exe.to_str(), root.to_str(), \"configs\");\n+            let output = run::process_output(exe.to_str(), [root.to_str(), ~\"configs\"]);\n+            // Run the configs() function to get the configs\n+            let cfgs = str::from_bytes_slice(output.output).word_iter()\n+                .transform(|w| w.to_owned()).collect();\n+            (cfgs, output.status)\n         }\n     }\n \n@@ -205,7 +199,7 @@ impl CtxMethods for Ctx {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n+                    let pkgid = PkgId::new(args[0].clone());\n                     do each_pkg_parent_workspace(&pkgid) |workspace| {\n                         debug!(\"found pkg %s in workspace %s, trying to build\",\n                                pkgid.to_str(), workspace.to_str());\n@@ -228,7 +222,7 @@ impl CtxMethods for Ctx {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let pkgid = PkgId::new(args[0].clone(), &os::getcwd());\n+                    let pkgid = PkgId::new(args[0].clone());\n                     let cwd = os::getcwd();\n                     self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n                 }\n@@ -254,13 +248,12 @@ impl CtxMethods for Ctx {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let pkgid = PkgId::new(args[0], &os::getcwd());\n+                    let pkgid = PkgId::new(args[0]);\n                     let workspaces = pkg_parent_workspaces(&pkgid);\n                     if workspaces.is_empty() {\n                         let rp = rust_path();\n                         assert!(!rp.is_empty());\n-                        let src = PkgSrc::new(&rp[0], &build_pkg_id_in_workspace(&pkgid, &rp[0]),\n-                                              &pkgid);\n+                        let src = PkgSrc::new(&rp[0], &pkgid);\n                         src.fetch_git();\n                         self.install(&rp[0], &pkgid);\n                     }\n@@ -294,7 +287,7 @@ impl CtxMethods for Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let pkgid = PkgId::new(args[0], &os::getcwd()); // ??\n+                let pkgid = PkgId::new(args[0]);\n                 if !installed_packages::package_is_installed(&pkgid) {\n                     warn(fmt!(\"Package %s doesn't seem to be installed! Doing nothing.\", args[0]));\n                     return;\n@@ -332,8 +325,6 @@ impl CtxMethods for Ctx {\n                in_rust_path(workspace), is_git_dir(&workspace.push_rel(&*pkgid.local_path)),\n                pkgid.to_str());\n         let src_dir   = first_pkgid_src_in_workspace(pkgid, workspace);\n-        let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n-        debug!(\"Destination dir = %s\", build_dir.to_str());\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n@@ -351,7 +342,7 @@ impl CtxMethods for Ctx {\n         }\n \n         // Create the package source\n-        let mut src = PkgSrc::new(workspace, &build_dir, pkgid);\n+        let mut src = PkgSrc::new(workspace, pkgid);\n         debug!(\"Package src = %?\", src);\n \n         // Is there custom build logic? If so, use it\n@@ -385,7 +376,7 @@ impl CtxMethods for Ctx {\n             // Find crates inside the workspace\n             src.find_crates();\n             // Build it!\n-            src.build(self, build_dir, cfgs);\n+            src.build(self, cfgs);\n         }\n     }\n \n@@ -444,6 +435,7 @@ impl CtxMethods for Ctx {\n         for lib in maybe_library.iter() {\n             let target_lib = target_lib.clone().expect(fmt!(\"I built %s but apparently \\\n                                                 didn't install it!\", lib.to_str()));\n+            let target_lib = target_lib.pop().push(lib.filename().expect(\"weird target lib\"));\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n             if !(os::mkdir_recursive(&target_lib.dir_path(), U_RWX) &&\n                  os::copy_file(lib, &target_lib)) {\n@@ -518,9 +510,7 @@ pub fn main() {\n         };\n     }\n \n-    let sroot = match filesearch::get_rustpkg_sysroot() {\n-        Ok(r) => Some(@r.pop().pop()), Err(_) => None\n-    };\n+    let sroot = Some(@filesearch::get_or_default_sysroot());\n     debug!(\"Using sysroot: %?\", sroot);\n     Ctx {\n         sysroot_opt: sroot, // Currently, only tests override this"}, {"sha": "caa004a53b22879363807268745510a0926659bf", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -10,7 +10,7 @@\n \n // Utils for working with version control repositories. Just git right now.\n \n-use std::{os, run, str};\n+use std::{io, os, run, str};\n use std::run::{ProcessOutput, ProcessOptions, Process};\n use version::*;\n \n@@ -19,14 +19,37 @@ pub fn git_clone(source: &Path, target: &Path, v: &Version) {\n     assert!(os::path_is_dir(source));\n     assert!(is_git_dir(source));\n     if !os::path_exists(target) {\n-        debug!(\"Running: git clone %s %s\", source.to_str(),\n-               target.to_str());\n-        assert!(git_clone_general(source.to_str(), target, v));\n+        debug!(\"Running: git clone %s %s\", source.to_str(), target.to_str());\n+        let outp = run::process_output(\"git\", [~\"clone\", source.to_str(), target.to_str()]);\n+        if outp.status != 0 {\n+            io::println(str::from_bytes_owned(outp.output.clone()));\n+            io::println(str::from_bytes_owned(outp.error));\n+            fail!(\"Couldn't `git clone` %s\", source.to_str());\n+        }\n+        else {\n+            match v {\n+                &ExactRevision(ref s) => {\n+                    debug!(\"`Running: git --work-tree=%s --git-dir=%s checkout %s\",\n+                           *s, target.to_str(), target.push(\".git\").to_str());\n+                    let outp = run::process_output(\"git\",\n+                                   [fmt!(\"--work-tree=%s\", target.to_str()),\n+                                    fmt!(\"--git-dir=%s\", target.push(\".git\").to_str()),\n+                                    ~\"checkout\", fmt!(\"%s\", *s)]);\n+                    if outp.status != 0 {\n+                        io::println(str::from_bytes_owned(outp.output.clone()));\n+                        io::println(str::from_bytes_owned(outp.error));\n+                        fail!(\"Couldn't `git checkout %s` in %s\",\n+                              *s, target.to_str());\n+                    }\n+                }\n+                _ => ()\n+            }\n+        }\n     }\n     else {\n-        // Pull changes\n-        // Note that this ignores tags, which is probably wrong. There are no tests for\n-        // it, though.\n+        // Check that no version was specified. There's no reason to not handle the\n+        // case where a version was requested, but I haven't implemented it.\n+        assert!(*v == NoVersion);\n         debug!(\"Running: git --work-tree=%s --git-dir=%s pull --no-edit %s\",\n                target.to_str(), target.push(\".git\").to_str(), source.to_str());\n         let outp = run::process_output(\"git\", [fmt!(\"--work-tree=%s\", target.to_str()),"}, {"sha": "98fd843925dc0897df556357f9b74ead4bad66c7", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 162, "deletions": 121, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -24,7 +24,9 @@ use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                make_dir_rwx, U_RWX, library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n                built_library_in_workspace, built_executable_in_workspace,\n-                installed_library_in_workspace, rust_path};\n+                installed_library_in_workspace};\n+use rustc::metadata::filesearch::rust_path;\n+use rustc::driver::driver::host_triple;\n use target::*;\n \n /// Returns the last-modified date as an Option\n@@ -116,6 +118,22 @@ fn mk_temp_workspace(short_name: &LocalPath, version: &Version) -> Path {\n     package_dir\n }\n \n+fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &str) {\n+    let cwd = (*cwd).clone();\n+    let mut prog = run::Process::new(\"git\", args, run::ProcessOptions {\n+        env: env.map(|v| v.slice(0, v.len())),\n+        dir: Some(&cwd),\n+        in_fd: None,\n+        out_fd: None,\n+        err_fd: None\n+    });\n+    let rslt = prog.finish_with_output();\n+    if rslt.status != 0 {\n+        fail!(\"%s [git returned %?, output = %s, error = %s]\", err_msg,\n+           rslt.status, str::from_bytes(rslt.output), str::from_bytes(rslt.error));\n+    }\n+}\n+\n /// Should create an empty git repo in p, relative to the tmp dir, and return the new\n /// absolute path\n fn init_git_repo(p: &Path) -> Path {\n@@ -125,37 +143,14 @@ fn init_git_repo(p: &Path) -> Path {\n     let work_dir_for_opts = work_dir.clone();\n     assert!(os::mkdir_recursive(&work_dir, U_RWX));\n     debug!(\"Running: git init in %s\", work_dir.to_str());\n-    let opts = run::ProcessOptions {\n-        env: None,\n-        dir: Some(&work_dir_for_opts),\n-        in_fd: None,\n-        out_fd: None,\n-        err_fd: None\n-    };\n-    let mut prog = run::Process::new(\"git\", [~\"init\"], opts);\n-    let mut output = prog.finish_with_output();\n-    if output.status == 0 {\n-        // Add stuff to the dir so that git tag succeeds\n-        writeFile(&work_dir.push(\"README\"), \"\");\n-        prog = run::Process::new(\"git\", [~\"add\", ~\"README\"], opts);\n-        output = prog.finish_with_output();\n-        if output.status == 0 {\n-            prog = run::Process::new(\"git\", [~\"commit\", ~\"-m\", ~\"whatever\"], opts);\n-            output = prog.finish_with_output();\n-            if output.status == 0 {\n-                tmp\n-            }\n-            else {\n-                fail!(\"Couldn't commit in %s\", work_dir.to_str());\n-            }\n-        }\n-        else {\n-            fail!(\"Couldn't add in %s\", work_dir.to_str());\n-        }\n-    }\n-    else {\n-        fail!(\"Couldn't initialize git repository in %s\", work_dir.to_str())\n-    }\n+    let ws = work_dir.to_str();\n+    run_git([~\"init\"], None, &work_dir_for_opts,\n+        fmt!(\"Couldn't initialize git repository in %s\", ws));\n+    // Add stuff to the dir so that git tag succeeds\n+    writeFile(&work_dir.push(\"README\"), \"\");\n+    run_git([~\"add\", ~\"README\"], None, &work_dir_for_opts, fmt!(\"Couldn't add in %s\", ws));\n+    git_commit(&work_dir_for_opts, ~\"whatever\");\n+    tmp\n }\n \n fn add_all_and_commit(repo: &Path) {\n@@ -164,51 +159,20 @@ fn add_all_and_commit(repo: &Path) {\n }\n \n fn git_commit(repo: &Path, msg: ~str) {\n-    let mut prog = run::Process::new(\"git\", [~\"commit\", ~\"-m\", msg],\n-                                     run::ProcessOptions { env: None,\n-                                                          dir: Some(repo),\n-                                                          in_fd: None,\n-                                                          out_fd: None,\n-                                                          err_fd: None\n-                                                         });\n-    let output = prog.finish_with_output();\n-    if output.status != 0 {\n-        fail!(\"Couldn't commit in %s: output was %s\", repo.to_str(),\n-              str::from_bytes(output.output + output.error))\n-    }\n-\n+    run_git([~\"commit\", ~\"--author=tester <test@mozilla.com>\", ~\"-m\", msg],\n+            None, repo, fmt!(\"Couldn't commit in %s\", repo.to_str()));\n }\n \n fn git_add_all(repo: &Path) {\n-    let mut prog = run::Process::new(\"git\", [~\"add\", ~\"-A\"],\n-                                     run::ProcessOptions { env: None,\n-                                                          dir: Some(repo),\n-                                                          in_fd: None,\n-                                                          out_fd: None,\n-                                                          err_fd: None\n-                                                         });\n-    let output = prog.finish_with_output();\n-    if output.status != 0 {\n-        fail!(\"Couldn't add all files in %s: output was %s\",\n-              repo.to_str(), str::from_bytes(output.output + output.error))\n-    }\n+    run_git([~\"add\", ~\"-A\"], None, repo, fmt!(\"Couldn't add all files in %s\", repo.to_str()));\n }\n \n fn add_git_tag(repo: &Path, tag: ~str) {\n     assert!(repo.is_absolute());\n     git_add_all(repo);\n     git_commit(repo, ~\"whatever\");\n-    let mut prog = run::Process::new(\"git\", [~\"tag\", tag.clone()],\n-                                     run::ProcessOptions { env: None,\n-                                                          dir: Some(repo),\n-                                                          in_fd: None,\n-                                                          out_fd: None,\n-                                                          err_fd: None\n-                                                         });\n-    let output = prog.finish_with_output();\n-    if output.status != 0 {\n-        fail!(\"Couldn't add git tag %s in %s\", tag, repo.to_str())\n-    }\n+    run_git([~\"tag\", tag.clone()], None, repo,\n+            fmt!(\"Couldn't add git tag %s in %s\", tag, repo.to_str()));\n }\n \n fn is_rwx(p: &Path) -> bool {\n@@ -231,6 +195,25 @@ fn test_sysroot() -> Path {\n     self_path.pop()\n }\n \n+// Returns the path to rustpkg\n+fn rustpkg_exec() -> Path {\n+    // Ugh\n+    let first_try = test_sysroot().push(\"lib\").push(\"rustc\")\n+        .push(host_triple()).push(\"bin\").push(\"rustpkg\");\n+    if is_executable(&first_try) {\n+        first_try\n+    }\n+    else {\n+        let second_try = test_sysroot().push(\"bin\").push(\"rustpkg\");\n+        if is_executable(&second_try) {\n+            second_try\n+        }\n+        else {\n+            fail!(\"in rustpkg test, can't find an installed rustpkg\");\n+        }\n+    }\n+}\n+\n fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n     command_line_test_with_env(args, cwd, None)\n }\n@@ -240,8 +223,9 @@ fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n /// Returns the process's output.\n fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~str)]>)\n     -> ProcessOutput {\n-    let cmd = test_sysroot().push(\"bin\").push(\"rustpkg\").to_str();\n-    debug!(\"About to run command: %? %? in %s\", cmd, args, cwd.to_str());\n+    let cmd = rustpkg_exec().to_str();\n+    debug!(\"cd %s; %s %s\",\n+           cwd.to_str(), cmd, args.connect(\" \"));\n     assert!(os::path_is_dir(&*cwd));\n     let cwd = (*cwd).clone();\n     let mut prog = run::Process::new(cmd, args, run::ProcessOptions {\n@@ -263,8 +247,9 @@ So tests that use this need to check the existence of a file\n to make sure the command succeeded\n */\n     if output.status != 0 {\n-        fail!(\"Command %s %? failed with exit code %?\",\n-              cmd, args, output.status);\n+        fail!(\"Command %s %? failed with exit code %?; its output was {{{ %s }}}\",\n+              cmd, args, output.status,\n+              str::from_bytes(output.output) + str::from_bytes(output.error));\n     }\n     output\n }\n@@ -329,24 +314,24 @@ fn create_local_package_with_custom_build_hook(pkgid: &PkgId,\n \n fn assert_lib_exists(repo: &Path, short_name: &str, v: Version) {\n     debug!(\"assert_lib_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n-    let lib = target_library_in_workspace(&(PkgId {\n-        version: v, ..PkgId::new(short_name, repo)}\n-                                           ), repo);\n-    debug!(\"assert_lib_exists: checking whether %s exists\", lib.to_str());\n-    assert!(os::path_exists(&lib));\n-    assert!(is_rwx(&lib));\n+    let lib = installed_library_in_workspace(short_name, repo);\n+    debug!(\"assert_lib_exists: checking whether %? exists\", lib);\n+    assert!(lib.is_some());\n+    let libname = lib.get_ref();\n+    assert!(os::path_exists(libname));\n+    assert!(is_rwx(libname));\n }\n \n fn assert_executable_exists(repo: &Path, short_name: &str) {\n     debug!(\"assert_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n-    let exec = target_executable_in_workspace(&PkgId::new(short_name, repo), repo);\n+    let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n }\n \n fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n     debug!(\"assert_built_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n-    let exec = built_executable_in_workspace(&PkgId::new(short_name, repo),\n+    let exec = built_executable_in_workspace(&PkgId::new(short_name),\n                                              repo).expect(\"assert_built_executable_exists failed\");\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n@@ -563,18 +548,18 @@ fn test_package_ids_must_be_relative_path_like() {\n \n     */\n \n-    let whatever = PkgId::new(\"foo\", &os::getcwd());\n+    let whatever = PkgId::new(\"foo\");\n \n     assert_eq!(~\"foo-0.1\", whatever.to_str());\n     assert!(\"github.com/catamorphism/test_pkg-0.1\" ==\n-            PkgId::new(\"github.com/catamorphism/test-pkg\", &os::getcwd()).to_str());\n+            PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n     do cond.trap(|(p, e)| {\n         assert!(\"\" == p.to_str());\n         assert!(\"0-length pkgid\" == e);\n         whatever.clone()\n     }).inside {\n-        let x = PkgId::new(\"\", &os::getcwd());\n+        let x = PkgId::new(\"\");\n         assert_eq!(~\"foo-0.1\", x.to_str());\n     }\n \n@@ -583,8 +568,7 @@ fn test_package_ids_must_be_relative_path_like() {\n         assert!(\"absolute pkgid\" == e);\n         whatever.clone()\n     }).inside {\n-        let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str(),\n-                           &os::getcwd());\n+        let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n         assert_eq!(~\"foo-0.1\", z.to_str());\n     }\n \n@@ -607,7 +591,7 @@ fn test_package_version() {\n               \"#[bench] pub fn f() { (); }\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n-    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version\", &repo);\n+    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version\");\n     match temp_pkg_id.version {\n         ExactRevision(~\"0.4\") => (),\n         _ => fail!(fmt!(\"test_package_version: package version was %?, expected Some(0.4)\",\n@@ -656,7 +640,7 @@ fn test_package_request_version() {\n         }\n         None    => false\n     });\n-    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\", &repo);\n+    let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\");\n     assert!(target_executable_in_workspace(&temp_pkg_id, &repo.push(\".rust\"))\n             == repo.push(\".rust\").push(\"bin\").push(\"test_pkg_version\"));\n \n@@ -696,12 +680,12 @@ fn rustpkg_library_target() {\n \n     add_git_tag(&package_dir, ~\"1.0\");\n     command_line_test([~\"install\", ~\"foo\"], &foo_repo);\n-    assert_lib_exists(&foo_repo, \"foo\", ExactRevision(~\"1.0\"));\n+    assert_lib_exists(&foo_repo.push(\".rust\"), \"foo\", ExactRevision(~\"1.0\"));\n }\n \n #[test]\n fn rustpkg_local_pkg() {\n-    let dir = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n+    let dir = create_local_package(&PkgId::new(\"foo\"));\n     command_line_test([~\"install\", ~\"foo\"], &dir);\n     assert_executable_exists(&dir, \"foo\");\n }\n@@ -711,7 +695,7 @@ fn rustpkg_local_pkg() {\n #[test]\n #[ignore]\n fn package_script_with_default_build() {\n-    let dir = create_local_package(&PkgId::new(\"fancy-lib\", &os::getcwd()));\n+    let dir = create_local_package(&PkgId::new(\"fancy-lib\"));\n     debug!(\"dir = %s\", dir.to_str());\n     let source = test_sysroot().pop().pop().pop().push(\"src\").push(\"librustpkg\").\n         push(\"testsuite\").push(\"pass\").push(\"src\").push(\"fancy-lib\").push(\"pkg.rs\");\n@@ -763,7 +747,7 @@ fn rustpkg_clean_no_arg() {\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n-    assert!(!built_executable_in_workspace(&PkgId::new(\"foo\", &package_dir),\n+    assert!(!built_executable_in_workspace(&PkgId::new(\"foo\"),\n                 &tmp).map_default(false, |m| { os::path_exists(m) }));\n }\n \n@@ -777,8 +761,7 @@ fn rust_path_test() {\n \n     let cwd = os::getcwd();\n     debug!(\"cwd = %s\", cwd.to_str());\n-    debug!(\"Running command: cd %s; RUST_LOG=rustpkg RUST_PATH=%s rustpkg install foo\",\n-           cwd.to_str(), dir_for_path.to_str());\n+                                     // use command_line_test_with_env\n     let mut prog = run::Process::new(\"rustpkg\",\n                                      [~\"install\", ~\"foo\"],\n                                      run::ProcessOptions { env: Some(&[(~\"RUST_LOG\",\n@@ -830,39 +813,38 @@ fn rust_path_parse() {\n #[test]\n fn test_list() {\n     let dir = mkdtemp(&os::tmpdir(), \"test_list\").expect(\"test_list failed\");\n-    let foo = PkgId::new(\"foo\", &dir);\n+    let foo = PkgId::new(\"foo\");\n     create_local_package_in(&foo, &dir);\n-    let bar = PkgId::new(\"bar\", &dir);\n+    let bar = PkgId::new(\"bar\");\n     create_local_package_in(&bar, &dir);\n-    let quux = PkgId::new(\"quux\", &dir);\n+    let quux = PkgId::new(\"quux\");\n     create_local_package_in(&quux, &dir);\n \n-// NOTE Not really great output, though...\n-// NOTE do any tests need to be unignored?\n+// list doesn't output very much right now...\n     command_line_test([~\"install\", ~\"foo\"], &dir);\n     let env_arg = ~[(~\"RUST_PATH\", dir.to_str())];\n     debug!(\"RUST_PATH = %s\", dir.to_str());\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libfoo_\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n \n     command_line_test([~\"install\", ~\"bar\"], &dir);\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg.clone());\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libfoo_\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libbar_\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n \n     command_line_test([~\"install\", ~\"quux\"], &dir);\n     let list_output = command_line_test_output_with_env([~\"list\"], env_arg);\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libfoo_\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libbar_\")));\n-    assert!(list_output.iter().any(|x| x.starts_with(\"libquux_\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"foo\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"bar\")));\n+    assert!(list_output.iter().any(|x| x.starts_with(\"quux\")));\n }\n \n #[test]\n fn install_remove() {\n     let dir = mkdtemp(&os::tmpdir(), \"install_remove\").expect(\"install_remove\");\n-    let foo = PkgId::new(\"foo\", &dir);\n-    let bar = PkgId::new(\"bar\", &dir);\n-    let quux = PkgId::new(\"quux\", &dir);\n+    let foo = PkgId::new(\"foo\");\n+    let bar = PkgId::new(\"bar\");\n+    let quux = PkgId::new(\"quux\");\n     create_local_package_in(&foo, &dir);\n     create_local_package_in(&bar, &dir);\n     create_local_package_in(&quux, &dir);\n@@ -887,7 +869,7 @@ fn install_check_duplicates() {\n     // (\"Is already installed -- doing nothing\")\n     // check invariant that there are no dups in the pkg database\n     let dir = mkdtemp(&os::tmpdir(), \"install_remove\").expect(\"install_remove\");\n-    let foo = PkgId::new(\"foo\", &dir);\n+    let foo = PkgId::new(\"foo\");\n     create_local_package_in(&foo, &dir);\n \n     command_line_test([~\"install\", ~\"foo\"], &dir);\n@@ -908,7 +890,7 @@ fn install_check_duplicates() {\n #[test]\n #[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn no_rebuilding() {\n-    let p_id = PkgId::new(\"foo\", &os::getcwd());\n+    let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let date = datestamp(&built_library_in_workspace(&p_id,\n@@ -922,8 +904,8 @@ fn no_rebuilding() {\n #[test]\n #[ignore(reason = \"Workcache not yet implemented -- see #7075\")]\n fn no_rebuilding_dep() {\n-    let p_id = PkgId::new(\"foo\", &os::getcwd());\n-    let dep_id = PkgId::new(\"bar\", &os::getcwd());\n+    let p_id = PkgId::new(\"foo\");\n+    let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date = datestamp(&lib_output_file_name(&workspace,\n@@ -935,8 +917,8 @@ fn no_rebuilding_dep() {\n \n #[test]\n fn do_rebuild_dep_dates_change() {\n-    let p_id = PkgId::new(\"foo\", &os::getcwd());\n-    let dep_id = PkgId::new(\"bar\", &os::getcwd());\n+    let p_id = PkgId::new(\"foo\");\n+    let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n@@ -948,8 +930,8 @@ fn do_rebuild_dep_dates_change() {\n \n #[test]\n fn do_rebuild_dep_only_contents_change() {\n-    let p_id = PkgId::new(\"foo\", &os::getcwd());\n-    let dep_id = PkgId::new(\"bar\", &os::getcwd());\n+    let p_id = PkgId::new(\"foo\");\n+    let dep_id = PkgId::new(\"bar\");\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     let bar_date = datestamp(&lib_output_file_name(&workspace, \"build\", \"bar\"));\n@@ -962,8 +944,8 @@ fn do_rebuild_dep_only_contents_change() {\n \n #[test]\n fn test_versions() {\n-    let workspace = create_local_package(&PkgId::new(\"foo#0.1\", &os::getcwd()));\n-    create_local_package(&PkgId::new(\"foo#0.2\", &os::getcwd()));\n+    let workspace = create_local_package(&PkgId::new(\"foo#0.1\"));\n+    create_local_package(&PkgId::new(\"foo#0.2\"));\n     command_line_test([~\"install\", ~\"foo#0.1\"], &workspace);\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n@@ -973,7 +955,7 @@ fn test_versions() {\n #[test]\n #[ignore(reason = \"do not yet implemented\")]\n fn test_build_hooks() {\n-    let workspace = create_local_package_with_custom_build_hook(&PkgId::new(\"foo\", &os::getcwd()),\n+    let workspace = create_local_package_with_custom_build_hook(&PkgId::new(\"foo\"),\n                                                                 \"frob\");\n     command_line_test([~\"do\", ~\"foo\", ~\"frob\"], &workspace);\n }\n@@ -983,7 +965,7 @@ fn test_build_hooks() {\n #[ignore(reason = \"info not yet implemented\")]\n fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n-    let workspace = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n+    let workspace = create_local_package(&PkgId::new(\"foo\"));\n     let output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n     assert_eq!(str::from_bytes(output.output), expected_info);\n }\n@@ -992,15 +974,15 @@ fn test_info() {\n #[ignore(reason = \"test not yet implemented\")]\n fn test_rustpkg_test() {\n     let expected_results = ~\"1 out of 1 tests passed\"; // fill in\n-    let workspace = create_local_package_with_test(&PkgId::new(\"foo\", &os::getcwd()));\n+    let workspace = create_local_package_with_test(&PkgId::new(\"foo\"));\n     let output = command_line_test([~\"test\", ~\"foo\"], &workspace);\n     assert_eq!(str::from_bytes(output.output), expected_results);\n }\n \n #[test]\n #[ignore(reason = \"test not yet implemented\")]\n fn test_uninstall() {\n-    let workspace = create_local_package(&PkgId::new(\"foo\", &os::getcwd()));\n+    let workspace = create_local_package(&PkgId::new(\"foo\"));\n     let _output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n     command_line_test([~\"uninstall\", ~\"foo\"], &workspace);\n     let output = command_line_test([~\"list\"], &workspace);\n@@ -1031,3 +1013,62 @@ fn test_non_numeric_tag() {\n     assert!(os::path_exists(&file1));\n     assert!(!os::path_exists(&file2));\n }\n+\n+#[test]\n+fn test_extern_mod() {\n+    let dir = mkdtemp(&os::tmpdir(), \"test_extern_mod\").expect(\"test_extern_mod\");\n+    let main_file = dir.push(\"main.rs\");\n+    let lib_depend_dir = mkdtemp(&os::tmpdir(), \"foo\").expect(\"test_extern_mod\");\n+    let aux_dir = lib_depend_dir.push_many([\"src\", \"mockgithub.com\", \"catamorphism\", \"test_pkg\"]);\n+    assert!(os::mkdir_recursive(&aux_dir, U_RWX));\n+    let aux_pkg_file = aux_dir.push(\"lib.rs\");\n+\n+    writeFile(&aux_pkg_file, \"pub mod bar { pub fn assert_true() {  assert!(true); } }\\n\");\n+    assert!(os::path_exists(&aux_pkg_file));\n+\n+    writeFile(&main_file,\n+              \"extern mod test = \\\"mockgithub.com/catamorphism/test_pkg\\\";\\nuse test::bar;\\\n+               fn main() { bar::assert_true(); }\\n\");\n+\n+    command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg\"], &lib_depend_dir);\n+\n+    let exec_file = dir.push(\"out\");\n+    // Be sure to extend the existing environment\n+    let env = Some([(~\"RUST_PATH\", lib_depend_dir.to_str())] + os::env());\n+    let rustpkg_exec = rustpkg_exec();\n+    let rustc = rustpkg_exec.with_filename(\"rustc\");\n+    debug!(\"RUST_PATH=%s %s %s \\n --sysroot %s -o %s\",\n+                     lib_depend_dir.to_str(),\n+                     rustc.to_str(),\n+                     main_file.to_str(),\n+                     test_sysroot().to_str(),\n+                     exec_file.to_str());\n+\n+    let mut prog = run::Process::new(rustc.to_str(), [main_file.to_str(),\n+                                                      ~\"--sysroot\", test_sysroot().to_str(),\n+                                               ~\"-o\", exec_file.to_str()],\n+                                     run::ProcessOptions {\n+        env: env.map(|v| v.slice(0, v.len())),\n+        dir: Some(&dir),\n+        in_fd: None,\n+        out_fd: None,\n+        err_fd: None\n+    });\n+    let outp = prog.finish_with_output();\n+    if outp.status != 0 {\n+        fail!(\"output was %s, error was %s\",\n+              str::from_bytes(outp.output),\n+              str::from_bytes(outp.error));\n+    }\n+    assert!(os::path_exists(&exec_file) && is_executable(&exec_file));\n+}\n+\n+/// Returns true if p exists and is executable\n+fn is_executable(p: &Path) -> bool {\n+    use std::libc::consts::os::posix88::{S_IXUSR};\n+\n+    match p.get_mode() {\n+        None => false,\n+        Some(mode) => mode & S_IXUSR as uint == S_IXUSR as uint\n+    }\n+}"}, {"sha": "a1b318fcc95719d085bfdaa7c9731dbb64fb95fb", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 64, "deletions": 42, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{os, result};\n+use std::os;\n use rustc::driver::{driver, session};\n-use rustc::metadata::filesearch;\n use extra::getopts::groups::getopts;\n use syntax::ast_util::*;\n use syntax::codemap::{dummy_sp, spanned};\n@@ -19,10 +18,10 @@ use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::attr::AttrMetaMethods;\n use rustc::back::link::output_type_exe;\n use rustc::driver::session::{lib_crate, bin_crate};\n-use context::Ctx;\n+use context::{Ctx, in_target};\n use package_id::PkgId;\n use search::find_library_in_search_path;\n-use path_util::target_library_in_workspace;\n+use path_util::{target_library_in_workspace, U_RWX};\n pub use target::{OutputType, Main, Lib, Bench, Test};\n \n // It would be nice to have the list of commands in just one place -- for example,\n@@ -47,13 +46,6 @@ impl ToStr for Pkg {\n     }\n }\n \n-pub fn root() -> Path {\n-    match filesearch::get_rustpkg_root() {\n-        result::Ok(path) => path,\n-        result::Err(err) => fail!(err)\n-    }\n-}\n-\n pub fn is_cmd(cmd: &str) -> bool {\n     COMMANDS.iter().any(|&c| c == cmd)\n }\n@@ -162,25 +154,25 @@ pub fn ready_crate(sess: session::Session,\n pub fn compile_input(ctxt: &Ctx,\n                      pkg_id: &PkgId,\n                      in_file: &Path,\n-                     out_dir: &Path,\n+                     workspace: &Path,\n                      flags: &[~str],\n                      cfgs: &[~str],\n                      opt: bool,\n                      what: OutputType) -> bool {\n \n-    let workspace = out_dir.pop().pop();\n-\n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input((*in_file).clone());\n     debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n+    let out_dir = workspace.push(\"build\").push_rel(&*pkg_id.local_path);\n+\n     let binary = os::args()[0].to_managed();\n \n     debug!(\"flags: %s\", flags.connect(\" \"));\n     debug!(\"cfgs: %s\", cfgs.connect(\" \"));\n-    debug!(\"compile_input's sysroot = %?\", ctxt.sysroot_opt);\n+    debug!(\"out_dir = %s\", out_dir.to_str());\n \n     let crate_type = match what {\n         Lib => lib_crate,\n@@ -196,12 +188,22 @@ pub fn compile_input(ctxt: &Ctx,\n                           + flags\n                           + cfgs.flat_map(|c| { ~[~\"--cfg\", (*c).clone()] }),\n                           driver::optgroups()).unwrap();\n+    // Hack so that rustpkg can run either out of a rustc target dir,\n+    // or the host dir\n+    let sysroot_to_use = if !in_target(ctxt.sysroot_opt) {\n+        ctxt.sysroot_opt\n+    }\n+    else {\n+        ctxt.sysroot_opt.map(|p| { @p.pop().pop().pop() })\n+    };\n+    debug!(\"compile_input's sysroot = %?\", ctxt.sysroot_opt_str());\n+    debug!(\"sysroot_to_use = %?\", sysroot_to_use);\n     let options = @session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: what == Test || what == Bench,\n-        maybe_sysroot: ctxt.sysroot_opt,\n-        addl_lib_search_paths: @mut (~[(*out_dir).clone()]),\n+        maybe_sysroot: sysroot_to_use,\n+        addl_lib_search_paths: @mut (~[out_dir.clone()]),\n         // output_type should be conditional\n         output_type: output_type_exe, // Use this to get a library? That's weird\n         .. (*driver::build_session_options(binary, &matches, diagnostic::emit)).clone()\n@@ -211,7 +213,12 @@ pub fn compile_input(ctxt: &Ctx,\n     // Make sure all the library directories actually exist, since the linker will complain\n     // otherwise\n     for p in addl_lib_search_paths.iter() {\n-        assert!(os::path_is_dir(p));\n+        if os::path_exists(p) {\n+            assert!(os::path_is_dir(p));\n+        }\n+        else {\n+            assert!(os::mkdir_recursive(p, U_RWX));\n+        }\n     }\n \n     let sess = driver::build_session(options, diagnostic::emit);\n@@ -224,35 +231,44 @@ pub fn compile_input(ctxt: &Ctx,\n \n     // Not really right. Should search other workspaces too, and the installed\n     // database (which doesn't exist yet)\n-    find_and_install_dependencies(ctxt, sess, &workspace, crate,\n+    find_and_install_dependencies(ctxt, sess, workspace, crate,\n                                   |p| {\n                                       debug!(\"a dependency: %s\", p.to_str());\n                                       // Pass the directory containing a dependency\n                                       // as an additional lib search path\n-                                      addl_lib_search_paths.push(p);\n+                                      if !addl_lib_search_paths.contains(&p) {\n+                                          // Might be inefficient, but this set probably\n+                                          // won't get too large -- tjc\n+                                          addl_lib_search_paths.push(p);\n+                                      }\n                                   });\n \n     // Inject the link attributes so we get the right package name and version\n     if attr::find_linkage_metas(crate.attrs).is_empty() {\n-        let short_name_to_use = match what {\n-            Test  => fmt!(\"%stest\", pkg_id.short_name),\n-            Bench => fmt!(\"%sbench\", pkg_id.short_name),\n-            _     => pkg_id.short_name.clone()\n+        let name_to_use = match what {\n+            Test  => fmt!(\"%stest\", pkg_id.local_path.to_str()).to_managed(),\n+            Bench => fmt!(\"%sbench\", pkg_id.local_path.to_str()).to_managed(),\n+            _     => pkg_id.short_name.to_managed()\n         };\n-        debug!(\"Injecting link name: %s\", short_name_to_use);\n+        debug!(\"Injecting link name: %s\", name_to_use);\n         let link_options =\n-            ~[attr::mk_name_value_item_str(@\"name\", short_name_to_use.to_managed()),\n-              attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())];\n-\n+            ~[attr::mk_name_value_item_str(@\"name\", name_to_use),\n+              attr::mk_name_value_item_str(@\"vers\", pkg_id.version.to_str().to_managed())] +\n+                        if pkg_id.is_complex() {\n+                        ~[attr::mk_name_value_item_str(@\"package_id\",\n+                                                       pkg_id.local_path.to_str().to_managed())]\n+                } else { ~[] };\n+\n+        debug!(\"link options: %?\", link_options);\n         crate = @ast::Crate {\n             attrs: ~[attr::mk_attr(attr::mk_list_item(@\"link\", link_options))],\n             .. (*crate).clone()\n-        };\n+        }\n     }\n \n-    debug!(\"calling compile_crate_from_input, out_dir = %s,\n+    debug!(\"calling compile_crate_from_input, workspace = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    compile_crate_from_input(&input, out_dir, sess, crate);\n+    compile_crate_from_input(&input, &out_dir, sess, crate);\n     true\n }\n \n@@ -262,17 +278,22 @@ pub fn compile_input(ctxt: &Ctx,\n // call compile_upto and return the crate\n // also, too many arguments\n pub fn compile_crate_from_input(input: &driver::input,\n-                                build_dir: &Path,\n+ // should be of the form <workspace>/build/<pkg id's path>\n+                                out_dir: &Path,\n                                 sess: session::Session,\n                                 crate: @ast::Crate) {\n     debug!(\"Calling build_output_filenames with %s, building library? %?\",\n-           build_dir.to_str(), sess.building_library);\n+           out_dir.to_str(), sess.building_library);\n \n     // bad copy\n-    let outputs = driver::build_output_filenames(input, &Some((*build_dir).clone()), &None,\n+    debug!(\"out_dir = %s\", out_dir.to_str());\n+    let outputs = driver::build_output_filenames(input, &Some(out_dir.clone()), &None,\n                                                  crate.attrs, sess);\n \n-    debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n+    debug!(\"Outputs are out_filename: %s and obj_filename: %s and output type = %?\",\n+           outputs.out_filename.to_str(),\n+           outputs.obj_filename.to_str(),\n+           sess.opts.output_type);\n     debug!(\"additional libraries:\");\n     for lib in sess.opts.addl_lib_search_paths.iter() {\n         debug!(\"an additional library: %s\", lib.to_str());\n@@ -298,15 +319,15 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n // Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_crate(ctxt: &Ctx, pkg_id: &PkgId,\n-                     crate: &Path, dir: &Path,\n+                     crate: &Path, workspace: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n                      what: OutputType) -> bool {\n-    debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n+    debug!(\"compile_crate: crate=%s, workspace=%s\", crate.to_str(), workspace.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n     for fl in flags.iter() {\n         debug!(\"+++ %s\", *fl);\n     }\n-    compile_input(ctxt, pkg_id, crate, dir, flags, cfgs, opt, what)\n+    compile_input(ctxt, pkg_id, crate, workspace, flags, cfgs, opt, what)\n }\n \n \n@@ -327,19 +348,20 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n         debug!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess\n-            ast::view_item_extern_mod(lib_ident, _, _) => {\n+            ast::view_item_extern_mod(lib_ident, path_opt, _, _) => {\n                 match my_ctxt.sysroot_opt {\n-                    Some(ref x) => debug!(\"sysroot: %s\", x.to_str()),\n+                    Some(ref x) => debug!(\"*** sysroot: %s\", x.to_str()),\n                     None => debug!(\"No sysroot given\")\n                 };\n-                let lib_name = sess.str_of(lib_ident);\n+                let lib_name = match path_opt { // ???\n+                    Some(p) => p, None => sess.str_of(lib_ident) };\n                 match find_library_in_search_path(my_ctxt.sysroot_opt, lib_name) {\n                     Some(installed_path) => {\n                         debug!(\"It exists: %s\", installed_path.to_str());\n                     }\n                     None => {\n                         // Try to install it\n-                        let pkg_id = PkgId::new(lib_name, &os::getcwd());\n+                        let pkg_id = PkgId::new(lib_name);\n                         my_ctxt.install(&my_workspace, &pkg_id);\n                         // Also, add an additional search path\n                         debug!(\"let installed_path...\")"}, {"sha": "b5203ef0756eac39cad71ad6250d96def6560b78", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -17,6 +17,7 @@ use extra::semver;\n use std::{char, os, result, run, str};\n use package_path::RemotePath;\n use extra::tempfile::mkdtemp;\n+use path_util::rust_path;\n \n #[deriving(Clone)]\n pub enum Version {\n@@ -92,28 +93,36 @@ pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n     }\n }\n \n-/// If `local_path` is a git repo, and the most recent tag in that repo denotes a version,\n-/// return it; otherwise, `None`\n+/// If `local_path` is a git repo in the RUST_PATH, and the most recent tag\n+/// in that repo denotes a version, return it; otherwise, `None`\n pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n-    debug!(\"in try_getting_local_version\");\n-    let outp = run::process_output(\"git\",\n+    let rustpath = rust_path();\n+    for rp in rustpath.iter() {\n+        let local_path = rp.push_rel(local_path);\n+        debug!(\"in try_getting_local_version\");\n+        let outp = run::process_output(\"git\",\n                                    [fmt!(\"--git-dir=%s\", local_path.push(\".git\").to_str()),\n                                     ~\"tag\", ~\"-l\"]);\n \n-    debug!(\"git --git-dir=%s tag -l ~~~> %?\", local_path.push(\".git\").to_str(), outp.status);\n+        debug!(\"git --git-dir=%s tag -l ~~~> %?\", local_path.push(\".git\").to_str(), outp.status);\n \n-    if outp.status != 0 {\n-        return None;\n-    }\n+        if outp.status != 0 {\n+            loop;\n+        }\n \n     let mut output = None;\n     let output_text = str::from_bytes(outp.output);\n     for l in output_text.line_iter() {\n         if !l.is_whitespace() {\n             output = Some(l);\n         }\n+        match output.chain(try_parsing_version) {\n+            Some(v) => return Some(v),\n+            None    => ()\n+        }\n     }\n-    output.chain(try_parsing_version)\n+  }\n+  None\n }\n \n /// If `remote_path` refers to a git repo that can be downloaded,"}, {"sha": "2efe274a4a2fad3f3ba23917d78852df3c2b1eba", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -12,9 +12,11 @@\n \n use std::os;\n use std::path::Path;\n-use path_util::{rust_path, workspace_contains_package_id};\n+use path_util::workspace_contains_package_id;\n use package_id::PkgId;\n \n+use rustc::metadata::filesearch::rust_path;\n+\n pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n@@ -58,5 +60,5 @@ pub fn cwd_to_workspace() -> (Path, PkgId) {\n     let ws = cwd.pop().pop();\n     let cwd_ = cwd.clone();\n     let pkgid = cwd_.components.last().to_str();\n-    (ws, PkgId::new(pkgid, &cwd))\n+    (ws, PkgId::new(pkgid))\n }"}, {"sha": "3e1cb50ce4e610701f5a441b1bd72d584e85be60", "filename": "src/libstd/path.rs", "status": "modified", "additions": 163, "deletions": 2, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -19,13 +19,14 @@ Cross-platform file path handling\n use clone::Clone;\n use container::Container;\n use cmp::Eq;\n-use iterator::{Iterator, IteratorUtil};\n+use iterator::{Iterator, IteratorUtil, range};\n use libc;\n+use num;\n use option::{None, Option, Some};\n use str::{OwnedStr, Str, StrSlice, StrVector};\n use to_str::ToStr;\n use ascii::{AsciiCast, AsciiStr};\n-use vec::{OwnedVector, ImmutableVector};\n+use vec::{OwnedVector, ImmutableVector, OwnedCopyableVector};\n \n #[cfg(windows)]\n pub use Path = self::WindowsPath;\n@@ -124,6 +125,43 @@ pub trait GenericPath {\n \n     /// True if `self` is an ancestor of `other`. See `test_is_ancestor_of` for examples\n     fn is_ancestor_of(&self, (&Self)) -> bool;\n+\n+    /// Find the relative path from one file to another\n+    fn get_relative_to(&self, abs2: (&Self)) -> Self {\n+        assert!(self.is_absolute());\n+        assert!(abs2.is_absolute());\n+        let abs1 = self.normalize();\n+        let abs2 = abs2.normalize();\n+\n+        let split1: &[~str] = abs1.components();\n+        let split2: &[~str] = abs2.components();\n+        let len1 = split1.len();\n+        let len2 = split2.len();\n+        assert!(len1 > 0);\n+        assert!(len2 > 0);\n+\n+        let max_common_path = num::min(len1, len2) - 1;\n+        let mut start_idx = 0;\n+        while start_idx < max_common_path\n+            && split1[start_idx] == split2[start_idx] {\n+            start_idx += 1;\n+        }\n+\n+        let mut path: ~[~str] = ~[];\n+        for _ in range(start_idx, len1 - 1) { path.push(~\"..\"); };\n+\n+        path.push_all(split2.slice(start_idx, len2 - 1));\n+\n+        let mut result: Self = GenericPath::from_str(\".\");\n+        if !path.is_empty() {\n+            // Without this type hint, the typechecker doesn't seem to like it\n+            let p: Self = GenericPath::from_str(\"\");\n+            result = p.push_many(path);\n+        };\n+        result\n+    }\n+\n+    fn components(self) -> ~[~str];\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -703,6 +741,7 @@ impl GenericPath for PosixPath {\n              self.is_ancestor_of(&other.pop()))\n     }\n \n+   fn components(self) -> ~[~str] { self.components }\n }\n \n \n@@ -985,6 +1024,8 @@ impl GenericPath for WindowsPath {\n             (!other.components.is_empty() && !(self.components.is_empty() && !self.is_absolute) &&\n              self.is_ancestor_of(&other.pop()))\n     }\n+\n+   fn components(self) -> ~[~str] { self.components }\n }\n \n pub fn normalize(components: &[~str]) -> ~[~str] {\n@@ -1341,4 +1382,124 @@ mod tests {\n \n     }\n \n+    #[test]\n+    fn test_relative_to1() {\n+        let p1 = PosixPath(\"/usr/bin/rustc\");\n+        let p2 = PosixPath(\"/usr/lib/mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"../lib\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\rustc\");\n+        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\\\\lib\"));\n+\n+    }\n+\n+    #[test]\n+    fn test_relative_to2() {\n+        let p1 = PosixPath(\"/usr/bin/rustc\");\n+        let p2 = PosixPath(\"/usr/bin/../lib/mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"../lib\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\rustc\");\n+        let p2 = WindowsPath(\"C:\\\\usr\\\\bin\\\\..\\\\lib\\\\mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\\\\lib\"));\n+    }\n+\n+    #[test]\n+    fn test_relative_to3() {\n+        let p1 = PosixPath(\"/usr/bin/whatever/rustc\");\n+        let p2 = PosixPath(\"/usr/lib/whatever/mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"../../lib/whatever\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\whatever\\\\rustc\");\n+        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\whatever\\\\mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\\\\..\\\\lib\\\\whatever\"));\n+\n+    }\n+\n+    #[test]\n+    fn test_relative_to4() {\n+        let p1 = PosixPath(\"/usr/bin/whatever/../rustc\");\n+        let p2 = PosixPath(\"/usr/lib/whatever/mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"../lib/whatever\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\usr\\\\bin\\\\whatever\\\\..\\\\rustc\");\n+        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\whatever\\\\mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\\\\lib\\\\whatever\"));\n+\n+    }\n+\n+    #[test]\n+    fn test_relative_to5() {\n+        let p1 = PosixPath(\"/usr/bin/whatever/../rustc\");\n+        let p2 = PosixPath(\"/usr/lib/whatever/../mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"../lib\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\usr\\\\bin/whatever\\\\..\\\\rustc\");\n+        let p2 = WindowsPath(\"C:\\\\usr\\\\lib\\\\whatever\\\\..\\\\mylib\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\\\\lib\"));\n+    }\n+\n+    #[test]\n+    fn test_relative_to6() {\n+        let p1 = PosixPath(\"/1\");\n+        let p2 = PosixPath(\"/2/3\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"2\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\1\");\n+        let p2 = WindowsPath(\"C:\\\\2\\\\3\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"2\"));\n+\n+    }\n+\n+    #[test]\n+    fn test_relative_to7() {\n+        let p1 = PosixPath(\"/1/2\");\n+        let p2 = PosixPath(\"/3\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, PosixPath(\"..\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\1\\\\2\");\n+        let p2 = WindowsPath(\"C:\\\\3\");\n+        let res = p1.get_relative_to(&p2);\n+        assert_eq!(res, WindowsPath(\"..\"));\n+\n+    }\n+\n+    #[test]\n+    fn test_relative_to8() {\n+        let p1 = PosixPath(\"/home/brian/Dev/rust/build/\").push_rel(\n+            &PosixPath(\"stage2/lib/rustc/i686-unknown-linux-gnu/lib/librustc.so\"));\n+        let p2 = PosixPath(\"/home/brian/Dev/rust/build/stage2/bin/..\").push_rel(\n+            &PosixPath(\"lib/rustc/i686-unknown-linux-gnu/lib/libstd.so\"));\n+        let res = p1.get_relative_to(&p2);\n+        debug!(\"test_relative_to8: %s vs. %s\",\n+               res.to_str(),\n+               PosixPath(\".\").to_str());\n+        assert_eq!(res, PosixPath(\".\"));\n+\n+        let p1 = WindowsPath(\"C:\\\\home\\\\brian\\\\Dev\\\\rust\\\\build\\\\\").push_rel(\n+            &WindowsPath(\"stage2\\\\lib\\\\rustc\\\\i686-unknown-linux-gnu\\\\lib\\\\librustc.so\"));\n+        let p2 = WindowsPath(\"\\\\home\\\\brian\\\\Dev\\\\rust\\\\build\\\\stage2\\\\bin\\\\..\").push_rel(\n+            &WindowsPath(\"lib\\\\rustc\\\\i686-unknown-linux-gnu\\\\lib\\\\libstd.so\"));\n+        let res = p1.get_relative_to(&p2);\n+        debug!(\"test_relative_to8: %s vs. %s\",\n+               res.to_str(),\n+               WindowsPath(\".\").to_str());\n+        assert_eq!(res, WindowsPath(\".\"));\n+\n+    }\n+\n }"}, {"sha": "17247222c3ff954783b8d5f67d39f2b29d12f5e0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -951,7 +951,11 @@ pub struct view_item {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum view_item_ {\n-    view_item_extern_mod(ident, ~[@MetaItem], NodeId),\n+    // ident: name used to refer to this crate in the code\n+    // optional @str: if present, this is a location (containing\n+    // arbitrary characters) from which to fetch the crate sources\n+    // For example, extern mod whatever = \"github.com/mozilla/rust\"\n+    view_item_extern_mod(ident, Option<@str>, ~[@MetaItem], NodeId),\n     view_item_use(~[@view_path]),\n }\n "}, {"sha": "9a8a3bc25d8a3a2051d9742087f9ad293799e18b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -419,7 +419,7 @@ impl Visitor<()> for IdVisitor {\n \n     fn visit_view_item(@mut self, view_item: &view_item, env: ()) {\n         match view_item.node {\n-            view_item_extern_mod(_, _, node_id) => {\n+            view_item_extern_mod(_, _, _, node_id) => {\n                 (self.visit_callback)(node_id)\n             }\n             view_item_use(ref view_paths) => {"}, {"sha": "5240edf00f14f07ab5e1bc08a89c040cc4f10b71", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -4169,8 +4169,16 @@ impl Parser {\n                                  self.this_token_to_str()));\n         }\n \n-        let (sort, ident) = match *self.token {\n-            token::IDENT(*) => (ast::named, self.parse_ident()),\n+        let (sort, maybe_path, ident) = match *self.token {\n+            token::IDENT(*) => {\n+                let the_ident = self.parse_ident();\n+                let path = if *self.token == token::EQ {\n+                    self.bump();\n+                    Some(self.parse_str())\n+                }\n+                else { None };\n+                (ast::named, path, the_ident)\n+            }\n             _ => {\n                 if must_be_named_mod {\n                     self.span_fatal(*self.span,\n@@ -4179,7 +4187,7 @@ impl Parser {\n                                          self.this_token_to_str()));\n                 }\n \n-                (ast::anonymous,\n+                (ast::anonymous, None,\n                  special_idents::clownshoes_foreign_mod)\n             }\n         };\n@@ -4218,7 +4226,7 @@ impl Parser {\n         let metadata = self.parse_optional_meta();\n         self.expect(&token::SEMI);\n         iovi_view_item(ast::view_item {\n-            node: view_item_extern_mod(ident, metadata, self.get_id()),\n+            node: view_item_extern_mod(ident, maybe_path, metadata, self.get_id()),\n             attrs: attrs,\n             vis: visibility,\n             span: mk_sp(lo, self.last_span.hi)\n@@ -4800,8 +4808,13 @@ impl Parser {\n         } else if self.eat_keyword(keywords::Extern) {\n             self.expect_keyword(keywords::Mod);\n             let ident = self.parse_ident();\n+            let path = if *self.token == token::EQ {\n+                self.bump();\n+                Some(self.parse_str())\n+            }\n+            else { None };\n             let metadata = self.parse_optional_meta();\n-            view_item_extern_mod(ident, metadata, self.get_id())\n+            view_item_extern_mod(ident, path, metadata, self.get_id())\n         } else {\n             self.bug(\"expected view item\");\n         };"}, {"sha": "ffe9575a8644eaada860dbfd552cdd76e5487a70", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96fd606dddba6bd4773c41be66c44fc076a96ff8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=96fd606dddba6bd4773c41be66c44fc076a96ff8", "patch": "@@ -1856,9 +1856,13 @@ pub fn print_view_item(s: @ps, item: &ast::view_item) {\n     print_outer_attributes(s, item.attrs);\n     print_visibility(s, item.vis);\n     match item.node {\n-        ast::view_item_extern_mod(id, ref mta, _) => {\n+        ast::view_item_extern_mod(id, ref optional_path, ref mta, _) => {\n             head(s, \"extern mod\");\n             print_ident(s, id);\n+            for p in optional_path.iter() {\n+                word(s.s, \"=\");\n+                print_string(s, *p);\n+            }\n             if !mta.is_empty() {\n                 popen(s);\n                 commasep(s, consistent, *mta, |p, &i| print_meta_item(p, i));"}, {"sha": "363c54f68129a2c0f8f28a62bc1ea9f79f7272b2", "filename": "src/test/run-pass/extern-mod-url.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e751c90513b3b7948ffab7b449f0758e4225125e/src%2Ftest%2Frun-pass%2Fextern-mod-url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e751c90513b3b7948ffab7b449f0758e4225125e/src%2Ftest%2Frun-pass%2Fextern-mod-url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-mod-url.rs?ref=e751c90513b3b7948ffab7b449f0758e4225125e", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Just a test that new-style extern mods parse\n-\n-// xfail-test FIXME #6407\n-extern mod test = \"github.com/catamorphism/test-pkg\";\n-\n-fn main() {}"}]}