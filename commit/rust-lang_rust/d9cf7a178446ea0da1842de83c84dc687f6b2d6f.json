{"sha": "d9cf7a178446ea0da1842de83c84dc687f6b2d6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5Y2Y3YTE3ODQ0NmVhMGRhMTg0MmRlODNjODRkYzY4N2Y2YjJkNmY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-11T11:16:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-11T11:16:08Z"}, "message": "Rollup merge of #73183 - Manishearth:intra-doc-macro, r=GuillaumeGomez\n\nSupport proc macros in intra doc link resolution\n\nThe feature was written pre-proc macro resolution, so it only supported the wacky MBE resolution rules. This adds support for proc macros as well.\n\ncc @GuillaumeGomez\n\nFixes #73173", "tree": {"sha": "bd1b4bb314199a8d310982540701cfaab006108b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd1b4bb314199a8d310982540701cfaab006108b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9cf7a178446ea0da1842de83c84dc687f6b2d6f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe4hJ4CRBK7hj4Ov3rIwAAdHIIAHaFfCalA+37BEgr8S1i9VqZ\n4qCcfBpL9NWdRg9JGx5NksC1XzbT7p5cHXZ3C3p/QLL2tQ2ZVPAdfZzEDg2OAfGf\nmNVIQGA6LVca34OVk/MLmtu4HPbgDhCV830UDhOoWNaz1+1fj+9Mj7Eg4wZVk/RL\n9ENhrDMD5dnbiqLc7+t1WHAAxakV5dMMVMWDLnDmBwAqzk10sWMXn0VfEi5iIhWo\nxpF2eH45J6x0MxHKUD9wJ4T68obaHadcf3Txuk8RoHOiF+qXKdPDsF81lL/ijrPE\negtk1qH8LKiQBRdVVmW0T7PwDqWJb88psF5xVWUiwofVLcD64HS/oeWHmapwmAA=\n=qNz8\n-----END PGP SIGNATURE-----\n", "payload": "tree bd1b4bb314199a8d310982540701cfaab006108b\nparent 6cc757e698ec7994411ef327f463726b070a3410\nparent 34c6b38e68f2e88bcc6c943494a7c05d35a71f17\nauthor Dylan DPC <dylan.dpc@gmail.com> 1591874168 +0200\ncommitter GitHub <noreply@github.com> 1591874168 +0200\n\nRollup merge of #73183 - Manishearth:intra-doc-macro, r=GuillaumeGomez\n\nSupport proc macros in intra doc link resolution\n\nThe feature was written pre-proc macro resolution, so it only supported the wacky MBE resolution rules. This adds support for proc macros as well.\n\ncc @GuillaumeGomez\n\nFixes #73173\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9cf7a178446ea0da1842de83c84dc687f6b2d6f", "html_url": "https://github.com/rust-lang/rust/commit/d9cf7a178446ea0da1842de83c84dc687f6b2d6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9cf7a178446ea0da1842de83c84dc687f6b2d6f/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cc757e698ec7994411ef327f463726b070a3410", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc757e698ec7994411ef327f463726b070a3410", "html_url": "https://github.com/rust-lang/rust/commit/6cc757e698ec7994411ef327f463726b070a3410"}, {"sha": "34c6b38e68f2e88bcc6c943494a7c05d35a71f17", "url": "https://api.github.com/repos/rust-lang/rust/commits/34c6b38e68f2e88bcc6c943494a7c05d35a71f17", "html_url": "https://github.com/rust-lang/rust/commit/34c6b38e68f2e88bcc6c943494a7c05d35a71f17"}], "stats": {"total": 162, "additions": 134, "deletions": 28}, "files": [{"sha": "f5b2f1bb5b17844a6f89e1fd700b129deddd26af", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 72, "deletions": 28, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d9cf7a178446ea0da1842de83c84dc687f6b2d6f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9cf7a178446ea0da1842de83c84dc687f6b2d6f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d9cf7a178446ea0da1842de83c84dc687f6b2d6f", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty;\n use rustc_resolve::ParentScope;\n use rustc_session::lint;\n+use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n@@ -122,6 +123,42 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         }\n     }\n \n+    /// Resolves a string as a macro.\n+    fn macro_resolve(&self, path_str: &str, parent_id: Option<hir::HirId>) -> Option<Res> {\n+        let cx = self.cx;\n+        let path = ast::Path::from_ident(Ident::from_str(path_str));\n+        cx.enter_resolver(|resolver| {\n+            if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n+                &path,\n+                None,\n+                &ParentScope::module(resolver.graph_root()),\n+                false,\n+                false,\n+            ) {\n+                if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n+                    return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+                }\n+            }\n+            if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n+                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n+            }\n+            if let Some(module_id) = parent_id.or(self.mod_ids.last().cloned()) {\n+                let module_id = cx.tcx.hir().local_def_id(module_id);\n+                if let Ok((_, res)) =\n+                    resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n+                {\n+                    // don't resolve builtins like `#[derive]`\n+                    if let Res::Def(..) = res {\n+                        let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                        return Some(res);\n+                    }\n+                }\n+            } else {\n+                debug!(\"attempting to resolve item without parent module: {}\", path_str);\n+            }\n+            None\n+        })\n+    }\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n     /// URL fragment in the case of variants and methods.\n     fn resolve(\n@@ -371,6 +408,22 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n }\n \n+/// Check for resolve collisions between a trait and its derive\n+///\n+/// These are common and we should just resolve to the trait in that case\n+fn is_derive_trait_collision<T>(ns: &PerNS<Option<(Res, T)>>) -> bool {\n+    if let PerNS {\n+        type_ns: Some((Res::Def(DefKind::Trait, _), _)),\n+        macro_ns: Some((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n+        ..\n+    } = *ns\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let item_hir_id = if item.is_mod() {\n@@ -532,6 +585,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 } else if link.starts_with(\"macro@\") {\n                     kind = Some(MacroNS);\n                     link.trim_start_matches(\"macro@\")\n+                } else if link.starts_with(\"derive@\") {\n+                    kind = Some(MacroNS);\n+                    link.trim_start_matches(\"derive@\")\n                 } else if link.ends_with('!') {\n                     kind = Some(MacroNS);\n                     link.trim_end_matches('!')\n@@ -614,8 +670,9 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                     None => {\n                         // Try everything!\n-                        let candidates = PerNS {\n-                            macro_ns: macro_resolve(cx, path_str)\n+                        let mut candidates = PerNS {\n+                            macro_ns: self\n+                                .macro_resolve(path_str, base_node)\n                                 .map(|res| (res, extra_fragment.clone())),\n                             type_ns: match self.resolve(\n                                 path_str,\n@@ -668,10 +725,16 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             continue;\n                         }\n \n-                        let is_unambiguous = candidates.clone().present_items().count() == 1;\n-                        if is_unambiguous {\n+                        let len = candidates.clone().present_items().count();\n+\n+                        if len == 1 {\n                             candidates.present_items().next().unwrap()\n+                        } else if len == 2 && is_derive_trait_collision(&candidates) {\n+                            candidates.type_ns.unwrap()\n                         } else {\n+                            if is_derive_trait_collision(&candidates) {\n+                                candidates.macro_ns = None;\n+                            }\n                             ambiguity_error(\n                                 cx,\n                                 &item,\n@@ -684,7 +747,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                     Some(MacroNS) => {\n-                        if let Some(res) = macro_resolve(cx, path_str) {\n+                        if let Some(res) = self.macro_resolve(path_str, base_node) {\n                             (res, extra_fragment)\n                         } else {\n                             resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -727,28 +790,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n-/// Resolves a string as a macro.\n-fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n-    let path = ast::Path::from_ident(Ident::from_str(path_str));\n-    cx.enter_resolver(|resolver| {\n-        if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n-            &path,\n-            None,\n-            &ParentScope::module(resolver.graph_root()),\n-            false,\n-            false,\n-        ) {\n-            if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                return Some(res.map_id(|_| panic!(\"unexpected id\")));\n-            }\n-        }\n-        if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-            return Some(res.map_id(|_| panic!(\"unexpected id\")));\n-        }\n-        None\n-    })\n-}\n-\n fn build_diagnostic(\n     cx: &DocContext<'_>,\n     item: &Item,\n@@ -916,7 +957,7 @@ fn ambiguity_error(\n                             Res::Def(DefKind::AssocFn | DefKind::Fn, _) => {\n                                 (\"add parentheses\", format!(\"{}()\", path_str))\n                             }\n-                            Res::Def(DefKind::Macro(..), _) => {\n+                            Res::Def(DefKind::Macro(MacroKind::Bang), _) => {\n                                 (\"add an exclamation mark\", format!(\"{}!\", path_str))\n                             }\n                             _ => {\n@@ -930,6 +971,9 @@ fn ambiguity_error(\n                                     (Res::Def(DefKind::Mod, _), _) => \"module\",\n                                     (_, TypeNS) => \"type\",\n                                     (_, ValueNS) => \"value\",\n+                                    (Res::Def(DefKind::Macro(MacroKind::Derive), _), MacroNS) => {\n+                                        \"derive\"\n+                                    }\n                                     (_, MacroNS) => \"macro\",\n                                 };\n "}, {"sha": "04a431d99026e8f7c4478af244d3042042450c0e", "filename": "src/test/rustdoc/auxiliary/intra-link-proc-macro-macro.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d9cf7a178446ea0da1842de83c84dc687f6b2d6f/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-proc-macro-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9cf7a178446ea0da1842de83c84dc687f6b2d6f/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-proc-macro-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fintra-link-proc-macro-macro.rs?ref=d9cf7a178446ea0da1842de83c84dc687f6b2d6f", "patch": "@@ -0,0 +1,35 @@\n+// force-host\n+// no-prefer-dynamic\n+// compile-flags: --crate-type proc-macro\n+\n+#![crate_type=\"proc-macro\"]\n+#![crate_name=\"intra_link_proc_macro_macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(DeriveA)]\n+pub fn a_derive(input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(DeriveB)]\n+pub fn b_derive(input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(DeriveTrait)]\n+pub fn trait_derive(input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn attr_a(input: TokenStream, _args: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn attr_b(input: TokenStream, _args: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "7b6ea5d60f8530d0045f3904be1b296205c9624b", "filename": "src/test/rustdoc/intra-link-proc-macro.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d9cf7a178446ea0da1842de83c84dc687f6b2d6f/src%2Ftest%2Frustdoc%2Fintra-link-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9cf7a178446ea0da1842de83c84dc687f6b2d6f/src%2Ftest%2Frustdoc%2Fintra-link-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-proc-macro.rs?ref=d9cf7a178446ea0da1842de83c84dc687f6b2d6f", "patch": "@@ -0,0 +1,27 @@\n+// aux-build:intra-link-proc-macro-macro.rs\n+// build-aux-docs\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+extern crate intra_link_proc_macro_macro;\n+\n+\n+pub use intra_link_proc_macro_macro::{DeriveA, attr_a};\n+use intra_link_proc_macro_macro::{DeriveB, attr_b};\n+\n+// @has intra_link_proc_macro/struct.Foo.html\n+// @has - '//a/@href' '../intra_link_proc_macro/derive.DeriveA.html'\n+// @has - '//a/@href' '../intra_link_proc_macro/attr.attr_a.html'\n+// @has - '//a/@href' '../intra_link_proc_macro/trait.DeriveTrait.html'\n+// @has - '//a/@href' '../intra_link_proc_macro_macro/derive.DeriveB.html'\n+// @has - '//a/@href' '../intra_link_proc_macro_macro/attr.attr_b.html'\n+/// Link to [DeriveA], [attr_a], [DeriveB], [attr_b], [DeriveTrait]\n+pub struct Foo;\n+\n+// @has intra_link_proc_macro/struct.Bar.html\n+// @has - '//a/@href' '../intra_link_proc_macro/derive.DeriveA.html'\n+// @has - '//a/@href' '../intra_link_proc_macro/attr.attr_a.html'\n+/// Link to [deriveA](derive@DeriveA) [attr](macro@attr_a)\n+pub struct Bar;\n+\n+// this should not cause ambiguity errors\n+pub trait DeriveTrait {}"}]}