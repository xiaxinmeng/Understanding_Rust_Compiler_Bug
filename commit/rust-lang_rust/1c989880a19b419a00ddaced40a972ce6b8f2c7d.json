{"sha": "1c989880a19b419a00ddaced40a972ce6b8f2c7d", "node_id": "C_kwDOAAsO6NoAKDFjOTg5ODgwYTE5YjQxOWEwMGRkYWNlZDQwYTk3MmNlNmI4ZjJjN2Q", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-09-21T08:05:11Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-09-21T08:06:01Z"}, "message": "Update tests", "tree": {"sha": "448f77c71efb9dcb7998061d5d63f9c27148b49e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/448f77c71efb9dcb7998061d5d63f9c27148b49e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c989880a19b419a00ddaced40a972ce6b8f2c7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c989880a19b419a00ddaced40a972ce6b8f2c7d", "html_url": "https://github.com/rust-lang/rust/commit/1c989880a19b419a00ddaced40a972ce6b8f2c7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c989880a19b419a00ddaced40a972ce6b8f2c7d/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "099a34cd95bf54e859f7dd03a21fe8202a5e3f70", "url": "https://api.github.com/repos/rust-lang/rust/commits/099a34cd95bf54e859f7dd03a21fe8202a5e3f70", "html_url": "https://github.com/rust-lang/rust/commit/099a34cd95bf54e859f7dd03a21fe8202a5e3f70"}], "stats": {"total": 788, "additions": 229, "deletions": 559}, "files": [{"sha": "b0fc5120f08f219783461c3e3e44316ed4323b28", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.fixed", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.fixed?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -4,6 +4,14 @@\n \n use std::thread;\n \n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n /* Test Send Trait Migration */\n struct SendPointer(*mut i32);\n unsafe impl Send for SendPointer {}\n@@ -42,19 +50,19 @@ fn test_sync_trait() {\n }\n \n /* Test Clone Trait Migration */\n-struct S(String);\n+struct S(Foo);\n struct T(i32);\n \n struct U(S, T);\n \n impl Clone for U {\n     fn clone(&self) -> Self {\n-        U(S(String::from(\"Hello World\")), T(0))\n+        U(S(Foo(0)), T(0))\n     }\n }\n \n fn test_clone_trait() {\n-    let f = U(S(String::from(\"Hello World\")), T(0));\n+    let f = U(S(Foo(0)), T(0));\n     let c = || {\n         let _ = &f;\n         //~^ ERROR: `Clone` trait implementation for closure and drop order"}, {"sha": "2bcf9a795edbd8f9fa093efe8b216d76725d777f", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.rs?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -4,6 +4,14 @@\n \n use std::thread;\n \n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n /* Test Send Trait Migration */\n struct SendPointer(*mut i32);\n unsafe impl Send for SendPointer {}\n@@ -42,19 +50,19 @@ fn test_sync_trait() {\n }\n \n /* Test Clone Trait Migration */\n-struct S(String);\n+struct S(Foo);\n struct T(i32);\n \n struct U(S, T);\n \n impl Clone for U {\n     fn clone(&self) -> Self {\n-        U(S(String::from(\"Hello World\")), T(0))\n+        U(S(Foo(0)), T(0))\n     }\n }\n \n fn test_clone_trait() {\n-    let f = U(S(String::from(\"Hello World\")), T(0));\n+    let f = U(S(Foo(0)), T(0));\n     let c = || {\n         //~^ ERROR: `Clone` trait implementation for closure and drop order\n         //~| NOTE: in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f.1` does not implement `Clone`"}, {"sha": "8d2d3553d4040f2fdbb6027cbe71d5fb5c3fd700", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/auto_traits.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fauto_traits.stderr?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -1,5 +1,5 @@\n error: changes to closure capture in Rust 2021 will affect `Send` trait implementation for closure\n-  --> $DIR/auto_traits.rs:14:19\n+  --> $DIR/auto_traits.rs:22:19\n    |\n LL |     thread::spawn(move || unsafe {\n    |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` as `fptr.0` does not implement `Send`\n@@ -24,7 +24,7 @@ LL |         *fptr.0 = 20;\n  ...\n \n error: changes to closure capture in Rust 2021 will affect `Sync`, `Send` trait implementation for closure\n-  --> $DIR/auto_traits.rs:34:19\n+  --> $DIR/auto_traits.rs:42:19\n    |\n LL |     thread::spawn(move || unsafe {\n    |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Sync`, `Send` as `fptr` implements `Sync`, `Send`, but in Rust 2021, this closure will no longer implement `Sync`, `Send` as `fptr.0.0` does not implement `Sync`, `Send`\n@@ -44,7 +44,7 @@ LL |         *fptr.0.0 = 20;\n  ...\n \n error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/auto_traits.rs:58:13\n+  --> $DIR/auto_traits.rs:66:13\n    |\n LL |     let c = || {\n    |             ^^ in Rust 2018, this closure implements `Clone` as `f` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f.1` does not implement `Clone`"}, {"sha": "9a6db588c8bf50f8b9138af373678202242ea632", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/closure-body-macro-fragment.fixed", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.fixed?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -3,6 +3,14 @@\n // check-pass\n #![warn(rust_2021_compatibility)]\n \n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n macro_rules! m {\n     (@ $body:expr) => {{\n         let f = || $body;\n@@ -15,11 +23,11 @@ macro_rules! m {\n }\n \n fn main() {\n-    let a = (1.to_string(), 2.to_string());\n+    let a = (Foo(0), Foo(1));\n     m!({\n         let _ = &a;\n         //~^ HELP: add a dummy\n         let x = a.0;\n-        println!(\"{}\", x);\n+        println!(\"{:?}\", x);\n     });\n }"}, {"sha": "08cc24b4b3fe8f173c066d9a2d481e0c7fe463ff", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/closure-body-macro-fragment.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.rs?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -3,6 +3,14 @@\n // check-pass\n #![warn(rust_2021_compatibility)]\n \n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n macro_rules! m {\n     (@ $body:expr) => {{\n         let f = || $body;\n@@ -15,10 +23,10 @@ macro_rules! m {\n }\n \n fn main() {\n-    let a = (1.to_string(), 2.to_string());\n+    let a = (Foo(0), Foo(1));\n     m!({\n         //~^ HELP: add a dummy\n         let x = a.0;\n-        println!(\"{}\", x);\n+        println!(\"{:?}\", x);\n     });\n }"}, {"sha": "a2a9da5f87ced2f9ed3f24fe9ee3cfc45670c485", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/closure-body-macro-fragment.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.stderr?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -1,5 +1,5 @@\n warning: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/closure-body-macro-fragment.rs:8:17\n+  --> $DIR/closure-body-macro-fragment.rs:16:17\n    |\n LL |           let f = || $body;\n    |  _________________^\n@@ -15,7 +15,7 @@ LL | /     m!({\n LL | |\n LL | |         let x = a.0;\n    | |                 --- in Rust 2018, this closure captures all of `a`, but in Rust 2021, it will only capture `a.0`\n-LL | |         println!(\"{}\", x);\n+LL | |         println!(\"{:?}\", x);\n LL | |     });\n    | |_______- in this macro invocation\n    |"}, {"sha": "abcd92eb6b862a08646683eb8d03c022da1b9930", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.fixed", "status": "modified", "additions": 31, "deletions": 158, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.fixed?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -1,169 +1,42 @@\n+// run-pass\n // run-rustfix\n \n #![deny(rust_2021_incompatible_closure_captures)]\n-//~^ NOTE: the lint level is defined here\n+#![allow(unused)]\n \n-// Test cases for types that implement an insignificant drop (stlib defined)\n-\n-// `t` needs Drop because one of its elements needs drop,\n-// therefore precise capture might affect drop ordering\n-fn test1_all_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let t2 = (String::new(), String::new());\n-\n-    let c = || {\n-        let _ = (&t, &t1, &t2);\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n-\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-        let _t2 = t2.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t2`, but in Rust 2021, it will only capture `t2.0`\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t2` is dropped here, but in Rust 2021, only `t2.0` will be dropped here as part of the closure\n-\n-// String implements drop and therefore should be migrated.\n-// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n-fn test2_only_precise_paths_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let t2 = (String::new(), String::new());\n-\n-    let c = || {\n-        let _ = (&t, &t1);\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-        let _t2 = t2;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-\n-// If a variable would've not been captured by value then it would've not been\n-// dropped with the closure and therefore doesn't need migration.\n-fn test3_only_by_value_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let c = || {\n-        let _ = &t;\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        println!(\"{}\", t1.1);\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-// Copy types get copied into the closure instead of move. Therefore we don't need to\n-// migrate then as their drop order isn't tied to the closure.\n-fn test4_only_non_copy_types_need_migration() {\n-    let t = (String::new(), String::new());\n+#![feature(once_cell)]\n \n-    // `t1` is Copy because all of its elements are Copy\n-    let t1 = (0i32, 0i32);\n-\n-    let c = || {\n-        let _ = &t;\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-fn test5_only_drop_types_need_migration() {\n-    struct S(i32, i32);\n-\n-    let t = (String::new(), String::new());\n-\n-    // `s` doesn't implement Drop or any elements within it, and doesn't need migration\n-    let s = S(0i32, 0i32);\n-\n-    let c = || {\n-        let _ = &t;\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _s = s.0;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-// Since we are using a move closure here, both `t` and `t1` get moved\n-// even though they are being used by ref inside the closure.\n-fn test6_move_closures_non_copy_types_might_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let c = move || {\n-        let _ = (&t1, &t);\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n-        println!(\"{} {}\", t1.1, t.1);\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.1`\n-        //~| NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.1`\n-    };\n+// Test cases for types that implement an insignificant drop (stlib defined)\n \n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.1` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.1` will be dropped here as part of the closure\n+macro_rules! test_insig_dtor_for_type {\n+    ($t: ty, $disambiguator: ident) => {\n+        mod $disambiguator {\n+            use std::collections::*;\n+            use std::lazy::SyncOnceCell;\n+            use std::rc::Rc;\n+            use std::sync::Mutex;\n \n-// Test migration analysis in case of Drop + Non Drop aggregates.\n-// Note we need migration here only because the non-copy (because Drop type) is captured,\n-// otherwise we won't need to, since we can get away with just by ref capture in that case.\n-fn test7_drop_non_drop_aggregate_need_migration() {\n-    let t = (String::new(), String::new(), 0i32);\n+            fn _test_for_type(t: $t) {\n+                let tup = (Mutex::new(0), t);\n \n-    let c = || {\n-        let _ = &t;\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n+                let _c = || tup.0;\n+            }\n+        }\n     };\n-\n-    c();\n }\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n \n-fn main() {\n-    test1_all_need_migration();\n-    test2_only_precise_paths_need_migration();\n-    test3_only_by_value_need_migration();\n-    test4_only_non_copy_types_need_migration();\n-    test5_only_drop_types_need_migration();\n-    test6_move_closures_non_copy_types_might_need_migration();\n-    test7_drop_non_drop_aggregate_need_migration();\n-}\n+test_insig_dtor_for_type!(i32, prim_i32);\n+test_insig_dtor_for_type!(Vec<i32>, vec_i32);\n+test_insig_dtor_for_type!(String, string);\n+test_insig_dtor_for_type!(Vec<String>, vec_string);\n+//test_insig_dtor_for_type!(HashMap<String, String>, hash_map);\n+test_insig_dtor_for_type!(BTreeMap<String, i32>, btree_map);\n+test_insig_dtor_for_type!(LinkedList<String>, linked_list);\n+test_insig_dtor_for_type!(Rc<i32>, rc_i32);\n+test_insig_dtor_for_type!(Rc<String>, rc_string);\n+test_insig_dtor_for_type!(SyncOnceCell<String>, onecell);\n+test_insig_dtor_for_type!(std::vec::IntoIter<String>, vec_into_iter);\n+test_insig_dtor_for_type!(btree_map::IntoIter<String, String>, btree_map_into_iter);\n+test_insig_dtor_for_type!(std::array::IntoIter<String, 5>, array_into_iter);\n+\n+fn main() {}"}, {"sha": "abcd92eb6b862a08646683eb8d03c022da1b9930", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.rs", "status": "modified", "additions": 31, "deletions": 151, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.rs?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -1,162 +1,42 @@\n+// run-pass\n // run-rustfix\n \n #![deny(rust_2021_incompatible_closure_captures)]\n-//~^ NOTE: the lint level is defined here\n+#![allow(unused)]\n \n-// Test cases for types that implement an insignificant drop (stlib defined)\n-\n-// `t` needs Drop because one of its elements needs drop,\n-// therefore precise capture might affect drop ordering\n-fn test1_all_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let t2 = (String::new(), String::new());\n-\n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n-\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-        let _t2 = t2.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t2`, but in Rust 2021, it will only capture `t2.0`\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t2` is dropped here, but in Rust 2021, only `t2.0` will be dropped here as part of the closure\n-\n-// String implements drop and therefore should be migrated.\n-// But in this test cases, `t2` is completely captured and when it is dropped won't be affected\n-fn test2_only_precise_paths_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let t2 = (String::new(), String::new());\n-\n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t`, `t1` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-        let _t2 = t2;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-\n-// If a variable would've not been captured by value then it would've not been\n-// dropped with the closure and therefore doesn't need migration.\n-fn test3_only_by_value_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        println!(\"{}\", t1.1);\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-// Copy types get copied into the closure instead of move. Therefore we don't need to\n-// migrate then as their drop order isn't tied to the closure.\n-fn test4_only_non_copy_types_need_migration() {\n-    let t = (String::new(), String::new());\n+#![feature(once_cell)]\n \n-    // `t1` is Copy because all of its elements are Copy\n-    let t1 = (0i32, 0i32);\n-\n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _t1 = t1.0;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-fn test5_only_drop_types_need_migration() {\n-    struct S(i32, i32);\n-\n-    let t = (String::new(), String::new());\n-\n-    // `s` doesn't implement Drop or any elements within it, and doesn't need migration\n-    let s = S(0i32, 0i32);\n-\n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-        let _s = s.0;\n-    };\n-\n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-\n-// Since we are using a move closure here, both `t` and `t1` get moved\n-// even though they are being used by ref inside the closure.\n-fn test6_move_closures_non_copy_types_might_need_migration() {\n-    let t = (String::new(), String::new());\n-    let t1 = (String::new(), String::new());\n-    let c = move || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t1`, `t` to be fully captured\n-        println!(\"{} {}\", t1.1, t.1);\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.1`\n-        //~| NOTE: in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.1`\n-    };\n+// Test cases for types that implement an insignificant drop (stlib defined)\n \n-    c();\n-}\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.1` will be dropped here as part of the closure\n-//~| in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.1` will be dropped here as part of the closure\n+macro_rules! test_insig_dtor_for_type {\n+    ($t: ty, $disambiguator: ident) => {\n+        mod $disambiguator {\n+            use std::collections::*;\n+            use std::lazy::SyncOnceCell;\n+            use std::rc::Rc;\n+            use std::sync::Mutex;\n \n-// Test migration analysis in case of Drop + Non Drop aggregates.\n-// Note we need migration here only because the non-copy (because Drop type) is captured,\n-// otherwise we won't need to, since we can get away with just by ref capture in that case.\n-fn test7_drop_non_drop_aggregate_need_migration() {\n-    let t = (String::new(), String::new(), 0i32);\n+            fn _test_for_type(t: $t) {\n+                let tup = (Mutex::new(0), t);\n \n-    let c = || {\n-        //~^ ERROR: drop order\n-        //~| NOTE: for more information, see\n-        //~| HELP: add a dummy let to cause `t` to be fully captured\n-        let _t = t.0;\n-        //~^ NOTE: in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n+                let _c = || tup.0;\n+            }\n+        }\n     };\n-\n-    c();\n }\n-//~^ in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n \n-fn main() {\n-    test1_all_need_migration();\n-    test2_only_precise_paths_need_migration();\n-    test3_only_by_value_need_migration();\n-    test4_only_non_copy_types_need_migration();\n-    test5_only_drop_types_need_migration();\n-    test6_move_closures_non_copy_types_might_need_migration();\n-    test7_drop_non_drop_aggregate_need_migration();\n-}\n+test_insig_dtor_for_type!(i32, prim_i32);\n+test_insig_dtor_for_type!(Vec<i32>, vec_i32);\n+test_insig_dtor_for_type!(String, string);\n+test_insig_dtor_for_type!(Vec<String>, vec_string);\n+//test_insig_dtor_for_type!(HashMap<String, String>, hash_map);\n+test_insig_dtor_for_type!(BTreeMap<String, i32>, btree_map);\n+test_insig_dtor_for_type!(LinkedList<String>, linked_list);\n+test_insig_dtor_for_type!(Rc<i32>, rc_i32);\n+test_insig_dtor_for_type!(Rc<String>, rc_string);\n+test_insig_dtor_for_type!(SyncOnceCell<String>, onecell);\n+test_insig_dtor_for_type!(std::vec::IntoIter<String>, vec_into_iter);\n+test_insig_dtor_for_type!(btree_map::IntoIter<String, String>, btree_map_into_iter);\n+test_insig_dtor_for_type!(std::array::IntoIter<String, 5>, array_into_iter);\n+\n+fn main() {}"}, {"sha": "7989a8fa5ccae1957c7972867e45ac6c54183a6b", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop.stderr", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/099a34cd95bf54e859f7dd03a21fe8202a5e3f70/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/099a34cd95bf54e859f7dd03a21fe8202a5e3f70/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop.stderr?ref=099a34cd95bf54e859f7dd03a21fe8202a5e3f70", "patch": "@@ -1,161 +0,0 @@\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:15:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-LL |\n-LL |         let _t1 = t1.0;\n-   |                   ---- in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-LL |\n-LL |         let _t2 = t2.0;\n-   |                   ---- in Rust 2018, this closure captures all of `t2`, but in Rust 2021, it will only capture `t2.0`\n-...\n-LL | }\n-   | -\n-   | |\n-   | in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   | in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-   | in Rust 2018, `t2` is dropped here, but in Rust 2021, only `t2.0` will be dropped here as part of the closure\n-   |\n-note: the lint level is defined here\n-  --> $DIR/insignificant_drop.rs:3:9\n-   |\n-LL | #![deny(rust_2021_incompatible_closure_captures)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t`, `t1`, `t2` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = (&t, &t1, &t2);\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:41:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-LL |\n-LL |         let _t1 = t1.0;\n-   |                   ---- in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.0`\n-...\n-LL | }\n-   | -\n-   | |\n-   | in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   | in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.0` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t`, `t1` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = (&t, &t1);\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:62:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-...\n-LL | }\n-   | - in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = &t;\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:83:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-...\n-LL | }\n-   | - in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = &t;\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:104:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-...\n-LL | }\n-   | - in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = &t;\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:122:13\n-   |\n-LL |     let c = move || {\n-   |             ^^^^^^^\n-...\n-LL |         println!(\"{} {}\", t1.1, t.1);\n-   |                           ----  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.1`\n-   |                           |\n-   |                           in Rust 2018, this closure captures all of `t1`, but in Rust 2021, it will only capture `t1.1`\n-...\n-LL | }\n-   | -\n-   | |\n-   | in Rust 2018, `t1` is dropped here, but in Rust 2021, only `t1.1` will be dropped here as part of the closure\n-   | in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.1` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t1`, `t` to be fully captured\n-   |\n-LL ~     let c = move || {\n-LL +         let _ = (&t1, &t);\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop.rs:142:13\n-   |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-...\n-LL | }\n-   | - in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = &t;\n-   |\n-\n-error: aborting due to 7 previous errors\n-"}, {"sha": "0787ac7c77b538ab60089efecb3cae2e87488307", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop_attr_migrations.fixed", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.fixed?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -5,17 +5,19 @@\n #![feature(rustc_attrs)]\n #![allow(unused)]\n \n+    use std::sync::Mutex;\n+\n struct InsignificantDropPoint {\n     x: i32,\n-    y: i32,\n+    y: Mutex<T>,\n }\n \n impl Drop for InsignificantDropPoint {\n     #[rustc_insignificant_dtor]\n     fn drop(&mut self) {}\n }\n \n-struct SigDrop;\n+struct SigDrop { x: () }\n \n impl Drop for SigDrop {\n     fn drop(&mut self) {}\n@@ -30,12 +32,22 @@ impl<T> Drop for GenericStruct<T> {\n     fn drop(&mut self) {}\n }\n \n+// Test no migration because InsignificantDropPoint is marked as insignificant\n+fn insign_dtor() {\n+    let t = (\n+        InsignificantDropPoint { x: 0, y: Mutex::new(0) },\n+        InsignificantDropPoint { x: 0, y: Mutex::new(0) }\n+    );\n+\n+    let c = || t.0;\n+\n+}\n+\n // `SigDrop` implements drop and therefore needs to be migrated.\n fn significant_drop_needs_migration() {\n-    let t = (SigDrop {}, SigDrop {});\n+    let t = (SigDrop { x: () }, SigDrop { x: () });\n \n     let c = || {\n-        let _ = &t;\n         //~^ ERROR: drop order\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured\n@@ -52,11 +64,10 @@ fn significant_drop_needs_migration() {\n // consdered to have an significant drop. Since the elements\n // of `GenericStruct` implement drop, migration is required.\n fn generic_struct_with_significant_drop_needs_migration() {\n-    let t = Wrapper(GenericStruct(SigDrop {}, SigDrop {}), 5);\n+    let t = Wrapper(GenericStruct(SigDrop { x: () }, SigDrop { x: () }), 5);\n \n     // move is used to force i32 to be copied instead of being a ref\n     let c = move || {\n-        let _ = &t;\n         //~^ ERROR: drop order\n         //~| NOTE: for more information, see\n         //~| HELP: add a dummy let to cause `t` to be fully captured"}, {"sha": "ff7af685ea5bbe893ea689b8e1430c212cb3afc5", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop_attr_migrations.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.rs?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -5,9 +5,11 @@\n #![feature(rustc_attrs)]\n #![allow(unused)]\n \n+    use std::sync::Mutex;\n+\n struct InsignificantDropPoint {\n     x: i32,\n-    y: i32,\n+    y: Mutex<i32>,\n }\n \n impl Drop for InsignificantDropPoint {\n@@ -30,6 +32,17 @@ impl<T> Drop for GenericStruct<T> {\n     fn drop(&mut self) {}\n }\n \n+// Test no migration because InsignificantDropPoint is marked as insignificant\n+fn insign_dtor() {\n+    let t = (\n+        InsignificantDropPoint { x: 0, y: Mutex::new(0) },\n+        InsignificantDropPoint { x: 0, y: Mutex::new(0) }\n+    );\n+\n+    let c = || t.0;\n+\n+}\n+\n // `SigDrop` implements drop and therefore needs to be migrated.\n fn significant_drop_needs_migration() {\n     let t = (SigDrop {}, SigDrop {});"}, {"sha": "80289d6289dde9492dcd836bfb49eda7117a3cc1", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/insignificant_drop_attr_migrations.stderr", "status": "modified", "additions": 13, "deletions": 39, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Finsignificant_drop_attr_migrations.stderr?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -1,45 +1,19 @@\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop_attr_migrations.rs:37:13\n+error[E0107]: missing generics for struct `Mutex`\n+  --> $DIR/insignificant_drop_attr_migrations.rs:12:8\n    |\n-LL |     let c = || {\n-   |             ^^\n-...\n-LL |         let _t = t.0;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.0`\n-...\n-LL | }\n-   | - in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.0` will be dropped here as part of the closure\n+LL |     y: Mutex,\n+   |        ^^^^^ expected 1 generic argument\n    |\n-note: the lint level is defined here\n-  --> $DIR/insignificant_drop_attr_migrations.rs:3:9\n+note: struct defined here, with 1 generic parameter: `T`\n+  --> $SRC_DIR/std/src/sync/mutex.rs:LL:COL\n    |\n-LL | #![deny(rust_2021_incompatible_closure_captures)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t` to be fully captured\n-   |\n-LL ~     let c = || {\n-LL +         let _ = &t;\n-   |\n-\n-error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/insignificant_drop_attr_migrations.rs:57:13\n-   |\n-LL |     let c = move || {\n-   |             ^^^^^^^\n-...\n-LL |         let _t = t.1;\n-   |                  --- in Rust 2018, this closure captures all of `t`, but in Rust 2021, it will only capture `t.1`\n-...\n-LL | }\n-   | - in Rust 2018, `t` is dropped here, but in Rust 2021, only `t.1` will be dropped here as part of the closure\n-   |\n-   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n-help: add a dummy let to cause `t` to be fully captured\n-   |\n-LL ~     let c = move || {\n-LL +         let _ = &t;\n+LL | pub struct Mutex<T: ?Sized> {\n+   |            ^^^^^ -\n+help: add missing generic argument\n    |\n+LL |     y: Mutex<T>,\n+   |        ~~~~~~~~\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "31fe494dc795a900620a2ac511adf7963e342b36", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/macro.fixed", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.fixed?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -5,8 +5,17 @@\n #![deny(rust_2021_incompatible_closure_captures)]\n //~^ NOTE: the lint level is defined here\n \n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n fn main() {\n-    let a = (\"hey\".to_string(), \"123\".to_string());\n+    let a = (Foo(0), Foo(1));\n     let _ = || { let _ = &a; dbg!(a.0) };\n     //~^ ERROR: drop order\n     //~| NOTE: will only capture `a.0`"}, {"sha": "0f0c497492290b60fd769e64328d98d686c77970", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/macro.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.rs?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -5,8 +5,17 @@\n #![deny(rust_2021_incompatible_closure_captures)]\n //~^ NOTE: the lint level is defined here\n \n+\n+#[derive(Debug)]\n+struct Foo(i32);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n fn main() {\n-    let a = (\"hey\".to_string(), \"123\".to_string());\n+    let a = (Foo(0), Foo(1));\n     let _ = || dbg!(a.0);\n     //~^ ERROR: drop order\n     //~| NOTE: will only capture `a.0`"}, {"sha": "5046a4bcbb4b37fa009b59c965cc11eb93ecbc36", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmacro.stderr?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -1,5 +1,5 @@\n error: changes to closure capture in Rust 2021 will affect drop order\n-  --> $DIR/macro.rs:10:13\n+  --> $DIR/macro.rs:19:13\n    |\n LL |     let _ = || dbg!(a.0);\n    |             ^^^^^^^^---^"}, {"sha": "11218eff1337f7f63e779df6b9ec5a7a40fdc429", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.fixed", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.fixed?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -4,7 +4,22 @@\n \n use std::thread;\n \n-struct S(String);\n+#[derive(Debug)]\n+struct Foo(String);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+impl Foo {\n+    fn from(s: &str) -> Self {\n+        Self(String::from(s))\n+    }\n+}\n+\n+\n+struct S(Foo);\n \n #[derive(Clone)]\n struct T(i32);\n@@ -13,13 +28,13 @@ struct U(S, T);\n \n impl Clone for U {\n     fn clone(&self) -> Self {\n-        U(S(String::from(\"Hello World\")), T(0))\n+        U(S(Foo::from(\"Hello World\")), T(0))\n     }\n }\n \n fn test_multi_issues() {\n-    let f1 = U(S(String::from(\"foo\")), T(0));\n-    let f2 = U(S(String::from(\"bar\")), T(0));\n+    let f1 = U(S(Foo::from(\"foo\")), T(0));\n+    let f2 = U(S(Foo::from(\"bar\")), T(0));\n     let c = || {\n         let _ = (&f1, &f2);\n         //~^ ERROR: `Clone` trait implementation for closure and drop order\n@@ -39,7 +54,7 @@ fn test_multi_issues() {\n //~^ NOTE: in Rust 2018, `f2` is dropped here, but in Rust 2021, only `f2.1` will be dropped here as part of the closure\n \n fn test_capturing_all_disjoint_fields_individually() {\n-    let f1 = U(S(String::from(\"foo\")), T(0));\n+    let f1 = U(S(Foo::from(\"foo\")), T(0));\n     let c = || {\n         let _ = &f1;\n         //~^ ERROR: `Clone` trait implementation for closure\n@@ -60,12 +75,12 @@ struct U1(S, T, S);\n \n impl Clone for U1 {\n     fn clone(&self) -> Self {\n-        U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")))\n+        U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")))\n     }\n }\n \n fn test_capturing_several_disjoint_fields_individually_1() {\n-    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         let _ = &f1;\n         //~^ ERROR: `Clone` trait implementation for closure\n@@ -85,7 +100,7 @@ fn test_capturing_several_disjoint_fields_individually_1() {\n }\n \n fn test_capturing_several_disjoint_fields_individually_2() {\n-    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         let _ = &f1;\n         //~^ ERROR: `Clone` trait implementation for closure and drop order"}, {"sha": "02f2faa2e8741615266e5f91687be7713335d207", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.rs?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -4,7 +4,22 @@\n \n use std::thread;\n \n-struct S(String);\n+#[derive(Debug)]\n+struct Foo(String);\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"{:?} dropped\", self.0);\n+    }\n+}\n+\n+impl Foo {\n+    fn from(s: &str) -> Self {\n+        Self(String::from(s))\n+    }\n+}\n+\n+\n+struct S(Foo);\n \n #[derive(Clone)]\n struct T(i32);\n@@ -13,13 +28,13 @@ struct U(S, T);\n \n impl Clone for U {\n     fn clone(&self) -> Self {\n-        U(S(String::from(\"Hello World\")), T(0))\n+        U(S(Foo::from(\"Hello World\")), T(0))\n     }\n }\n \n fn test_multi_issues() {\n-    let f1 = U(S(String::from(\"foo\")), T(0));\n-    let f2 = U(S(String::from(\"bar\")), T(0));\n+    let f1 = U(S(Foo::from(\"foo\")), T(0));\n+    let f2 = U(S(Foo::from(\"bar\")), T(0));\n     let c = || {\n         //~^ ERROR: `Clone` trait implementation for closure and drop order\n         //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -38,7 +53,7 @@ fn test_multi_issues() {\n //~^ NOTE: in Rust 2018, `f2` is dropped here, but in Rust 2021, only `f2.1` will be dropped here as part of the closure\n \n fn test_capturing_all_disjoint_fields_individually() {\n-    let f1 = U(S(String::from(\"foo\")), T(0));\n+    let f1 = U(S(Foo::from(\"foo\")), T(0));\n     let c = || {\n         //~^ ERROR: `Clone` trait implementation for closure\n         //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -58,12 +73,12 @@ struct U1(S, T, S);\n \n impl Clone for U1 {\n     fn clone(&self) -> Self {\n-        U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")))\n+        U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")))\n     }\n }\n \n fn test_capturing_several_disjoint_fields_individually_1() {\n-    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         //~^ ERROR: `Clone` trait implementation for closure\n         //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -82,7 +97,7 @@ fn test_capturing_several_disjoint_fields_individually_1() {\n }\n \n fn test_capturing_several_disjoint_fields_individually_2() {\n-    let f1 = U1(S(String::from(\"foo\")), T(0), S(String::from(\"bar\")));\n+    let f1 = U1(S(Foo::from(\"foo\")), T(0), S(Foo::from(\"bar\")));\n     let c = || {\n         //~^ ERROR: `Clone` trait implementation for closure and drop order\n         //~| NOTE: in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`"}, {"sha": "d425db5aa998c69394a674441809eef0581660b3", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/multi_diagnostics.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fmulti_diagnostics.stderr?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -1,5 +1,5 @@\n error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/multi_diagnostics.rs:23:13\n+  --> $DIR/multi_diagnostics.rs:38:13\n    |\n LL |     let c = || {\n    |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -26,7 +26,7 @@ LL +         let _ = (&f1, &f2);\n    |\n \n error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:42:13\n+  --> $DIR/multi_diagnostics.rs:57:13\n    |\n LL |     let c = || {\n    |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -42,7 +42,7 @@ LL +         let _ = &f1;\n    |\n \n error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:67:13\n+  --> $DIR/multi_diagnostics.rs:82:13\n    |\n LL |     let c = || {\n    |             ^^\n@@ -64,7 +64,7 @@ LL +         let _ = &f1;\n    |\n \n error: changes to closure capture in Rust 2021 will affect `Clone` trait implementation for closure and drop order\n-  --> $DIR/multi_diagnostics.rs:86:13\n+  --> $DIR/multi_diagnostics.rs:101:13\n    |\n LL |     let c = || {\n    |             ^^ in Rust 2018, this closure implements `Clone` as `f1` implements `Clone`, but in Rust 2021, this closure will no longer implement `Clone` as `f1.0` does not implement `Clone`\n@@ -89,7 +89,7 @@ LL +         let _ = &f1;\n    |\n \n error: changes to closure capture in Rust 2021 will affect `Sync`, `Send` trait implementation for closure\n-  --> $DIR/multi_diagnostics.rs:119:19\n+  --> $DIR/multi_diagnostics.rs:134:19\n    |\n LL |     thread::spawn(move || unsafe {\n    |                   ^^^^^^^^^^^^^^"}, {"sha": "d3ede331313c2966a1166e3dfbfe27ff66d75dd5", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.fixed?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -165,7 +165,7 @@ fn test7_move_closures_non_copy_types_might_need_migration() {\n fn test8_drop_order_and_blocks() {\n     {\n         let tuple =\n-          (String::from(\"foo\"), String::from(\"bar\"));\n+          (Foo(0), Foo(1));\n         {\n             let c = || {\n                 let _ = &tuple;\n@@ -184,7 +184,7 @@ fn test8_drop_order_and_blocks() {\n \n fn test9_drop_order_and_nested_closures() {\n     let tuple =\n-        (String::from(\"foo\"), String::from(\"bar\"));\n+        (Foo(0), Foo(1));\n     let b = || {\n         let c = || {\n             let _ = &tuple;"}, {"sha": "d0046895987f02034978b790acc2b69df621ec81", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/significant_drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c989880a19b419a00ddaced40a972ce6b8f2c7d/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fsignificant_drop.rs?ref=1c989880a19b419a00ddaced40a972ce6b8f2c7d", "patch": "@@ -158,7 +158,7 @@ fn test7_move_closures_non_copy_types_might_need_migration() {\n fn test8_drop_order_and_blocks() {\n     {\n         let tuple =\n-          (String::from(\"foo\"), String::from(\"bar\"));\n+          (Foo(0), Foo(1));\n         {\n             let c = || {\n                 //~^ ERROR: drop order\n@@ -176,7 +176,7 @@ fn test8_drop_order_and_blocks() {\n \n fn test9_drop_order_and_nested_closures() {\n     let tuple =\n-        (String::from(\"foo\"), String::from(\"bar\"));\n+        (Foo(0), Foo(1));\n     let b = || {\n         let c = || {\n             //~^ ERROR: drop order"}]}