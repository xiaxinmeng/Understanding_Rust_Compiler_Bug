{"sha": "0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiM2EwNmFiMmNhOTg5YWIwZjBiOWZhNWZhOGFhODNhMmVjMTM5OTg=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-02-25T01:43:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-29T01:56:15Z"}, "message": "correcting for libuv behavior that differs between linux & windows\n\nnet complexity increase :/", "tree": {"sha": "0d5b1b38c8ab616f231884b253859a019de81c39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d5b1b38c8ab616f231884b253859a019de81c39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998", "html_url": "https://github.com/rust-lang/rust/commit/0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d461637cc5c896252003eda3e83084bcebb3717e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d461637cc5c896252003eda3e83084bcebb3717e", "html_url": "https://github.com/rust-lang/rust/commit/d461637cc5c896252003eda3e83084bcebb3717e"}], "stats": {"total": 56, "additions": 36, "deletions": 20}, "files": [{"sha": "0cc89a441ef704cfd93dd1b571b30ea4200b7b50", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998", "patch": "@@ -8,7 +8,8 @@ enum uv_operation {\n     op_close(uv_handle, *ctypes::void),\n     op_timer_init([u8]),\n     op_timer_start([u8], *ctypes::void, u32, u32),\n-    op_timer_stop([u8], *ctypes::void, fn~(uv_handle))\n+    op_timer_stop([u8], *ctypes::void, fn~(uv_handle)),\n+    op_teardown(*ctypes::void)\n }\n \n enum uv_handle {\n@@ -34,7 +35,8 @@ enum uv_msg {\n     uv_timer_init([u8], *ctypes::void),\n     uv_timer_call([u8]),\n     uv_timer_stop([u8], fn~(uv_handle)),\n-    uv_end()\n+    uv_end(),\n+    uv_teardown_check()\n }\n \n type uv_loop_data = {\n@@ -148,18 +150,22 @@ fn loop_new() -> uv_loop unsafe {\n                 // loop process any pending operations\n                 // once its up and running\n                 task::spawn_sched(task::manual_threads(1u)) {||\n+                    // make sure we didn't start the loop\n+                    // without the user registering handles\n+                    comm::send(rust_loop_chan, uv_teardown_check);\n                     // this call blocks\n                     rustrt::rust_uv_run(loop_handle);\n                     // when we're done, msg the\n                     // end chan\n-                    rustrt::rust_uv_stop_op_cb(op_handle);\n                     comm::send(end_chan, true);\n                     comm::send(rust_loop_chan, uv_end);\n                 };\n               }\n \n               msg_run_in_bg {\n                 task::spawn_sched(task::manual_threads(1u)) {||\n+                    // see note above\n+                    comm::send(rust_loop_chan, uv_teardown_check);\n                     // this call blocks\n                     rustrt::rust_uv_run(loop_handle);\n                 };\n@@ -194,6 +200,9 @@ fn loop_new() -> uv_loop unsafe {\n                 task::spawn {||\n                     cb();\n                 };\n+                // ask the rust loop to check and see if there\n+                // are no more user-registered handles\n+                comm::send(rust_loop_chan, uv_teardown_check);\n               }\n \n               msg_async_init(callback, after_cb) {\n@@ -202,6 +211,7 @@ fn loop_new() -> uv_loop unsafe {\n                 // data and save the callback for\n                 // invocation on msg_async_send\n                 let id = gen_handle_id();\n+                handles.insert(id, ptr::null());\n                 async_cbs.insert(id, callback);\n                 after_cbs.insert(id, after_cb);\n                 let op = op_async_init(id);\n@@ -235,6 +245,7 @@ fn loop_new() -> uv_loop unsafe {\n \n               msg_timer_init(after_cb) {\n                 let id = gen_handle_id();\n+                handles.insert(id, ptr::null());\n                 after_cbs.insert(id, after_cb);\n                 let op = op_timer_init(id);\n                 pass_to_libuv(op_handle, operation_chan, op);\n@@ -276,6 +287,18 @@ fn loop_new() -> uv_loop unsafe {\n                 after_cb(the_timer);\n               }\n \n+              uv_teardown_check() {\n+                // here we're checking if there are no user-registered\n+                // handles (and the loop is running), if this is the\n+                // case, then we need to unregister the op_handle via\n+                // a uv_close() call, thus allowing libuv to return\n+                // on its own.\n+                if (handles.size() == 0u) {\n+                    let op = op_teardown(op_handle);\n+                    pass_to_libuv(op_handle, operation_chan, op);\n+                }\n+              }\n+\n               uv_end() {\n                 keep_going = false;\n               }\n@@ -442,6 +465,12 @@ crust fn process_operation(\n             rustrt::rust_uv_timer_stop(handle);\n             comm::send(loop_chan, uv_timer_stop(id, after_cb));\n           }\n+          op_teardown(op_handle) {\n+            // this is the last msg that'll be processed by\n+            // this fn, in the current lifetime of the handle's\n+            // uv_loop_t\n+            rustrt::rust_uv_stop_op_cb(op_handle);\n+          }\n           _ { fail \"unknown form of uv_operation received\"; }\n         }\n         op_pending = comm::peek(op_port);\n@@ -536,7 +565,8 @@ fn test_uv_simple_async() {\n         async_send(new_async);\n     });\n     run(test_loop);\n-    assert comm::recv(exit_port);\n+    let result = comm::recv(exit_port);\n+    assert result;\n }\n \n #[test]"}, {"sha": "4126896895e0cde4f9ba028ba895c75c7c92f36d", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=0b3a06ab2ca989ab0f0b9fa5fa8aa83a2ec13998", "patch": "@@ -68,10 +68,8 @@ native_close_cb(uv_handle_t* handle) {\n \n static void\n native_close_op_cb(uv_handle_t* op_handle) {\n-  uv_loop_t* loop = op_handle->loop;\n   current_kernel_free(op_handle);\n-  loop->data = 0; // a ptr to some stack-allocated rust mem\n-  uv_loop_delete(loop);\n+  // uv_run() should return after this..\n }\n \n // native fns bound in rust\n@@ -94,25 +92,13 @@ rust_uv_bind_op_cb(uv_loop_t* loop, crust_async_op_cb cb) {\n \tasync->data = (void*)cb;\n \t// decrement the ref count, so that our async bind\n \t// doesn't count towards keeping the loop alive\n-\tuv_unref(loop);\n+\t//uv_unref(loop);\n \treturn async;\n }\n \n extern \"C\" void\n rust_uv_stop_op_cb(uv_handle_t* op_handle) {\n-  /*  // this is a hack to get libuv to cleanup a\n-  // handle that was made to not prevent the loop\n-  // from exiting via uv_unref().\n-  uv_ref(op_handle->loop);\n   uv_close(op_handle, native_close_op_cb);\n-  uv_run(op_handle->loop); // this should process the handle's\n-                           // close event and then return\n-\t\t\t\t\t\t   */\n-  // the above code is supposed to work to cleanly close\n-  // a handler that was uv_unref()'d. but it causes much spew\n-  // instead. this is the ugly/quick way to deal w/ it for now.\n-  uv_close(op_handle, native_close_op_cb);\n-  native_close_op_cb(op_handle);\n }\n \n extern \"C\" void"}]}