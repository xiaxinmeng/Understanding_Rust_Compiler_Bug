{"sha": "2f1652870f5900bc41610d808b8bc2d51c901192", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMTY1Mjg3MGY1OTAwYmM0MTYxMGQ4MDhiOGJjMmQ1MWM5MDExOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-31T23:23:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-31T23:23:49Z"}, "message": "Auto merge of #40972 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 6 pull requests\n\n- Successful merges: #40703, #40728, #40763, #40871, #40935, #40947\n- Failed merges:", "tree": {"sha": "3bd9adab1026631921ab10fca0efe84dc67b53aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bd9adab1026631921ab10fca0efe84dc67b53aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f1652870f5900bc41610d808b8bc2d51c901192", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1652870f5900bc41610d808b8bc2d51c901192", "html_url": "https://github.com/rust-lang/rust/commit/2f1652870f5900bc41610d808b8bc2d51c901192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f1652870f5900bc41610d808b8bc2d51c901192/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40feadb966f825de7aa54a3138416c906b60f54a", "url": "https://api.github.com/repos/rust-lang/rust/commits/40feadb966f825de7aa54a3138416c906b60f54a", "html_url": "https://github.com/rust-lang/rust/commit/40feadb966f825de7aa54a3138416c906b60f54a"}, {"sha": "54b3f6aa21818318c0cf9c6d7fc2e17d50bfe4d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/54b3f6aa21818318c0cf9c6d7fc2e17d50bfe4d4", "html_url": "https://github.com/rust-lang/rust/commit/54b3f6aa21818318c0cf9c6d7fc2e17d50bfe4d4"}], "stats": {"total": 178, "additions": 137, "deletions": 41}, "files": [{"sha": "c37a4fa6b5572757681971170e2984577d7d3385", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -133,9 +133,15 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n     }\n }\n \n-/// External iterator for a string's UTF-16 code units.\n+/// An iterator of [`u16`] over the string encoded as UTF-16.\n ///\n-/// For use with the `std::iter` module.\n+/// [`u16`]: ../../std/primitive.u16.html\n+///\n+/// This struct is created by the [`encode_utf16`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`encode_utf16`]: ../../std/primitive.str.html#method.encode_utf16\n+/// [`str`]: ../../std/primitive.str.html\n #[derive(Clone)]\n #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n pub struct EncodeUtf16<'a> {"}, {"sha": "c3e5304fb2b3544b855e7441d7ab32d88e0b7b09", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -383,9 +383,11 @@ fn test_reverse() {\n \n #[test]\n fn test_sort() {\n+    let mut rng = thread_rng();\n+\n     for len in (2..25).chain(500..510) {\n         for _ in 0..100 {\n-            let mut v: Vec<_> = thread_rng().gen_iter::<i32>().take(len).collect();\n+            let mut v: Vec<_> = rng.gen_iter::<i32>().take(len).collect();\n             let mut v1 = v.clone();\n \n             v.sort();\n@@ -399,6 +401,18 @@ fn test_sort() {\n         }\n     }\n \n+    // Sort using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    let mut v = [0; 500];\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+    v.sort_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n+    v.sort();\n+    for i in 0..v.len() {\n+        assert_eq!(v[i], i as i32);\n+    }\n+\n     // Should not panic.\n     [0i32; 0].sort();\n     [(); 10].sort();"}, {"sha": "f75a1f7ab6e0f07fa720b8abf8a81f8bfb0f9515", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -369,11 +369,15 @@ impl fmt::Display for Utf8Error {\n Section: Iterators\n */\n \n-/// Iterator for the char (representing *Unicode Scalar Values*) of a string.\n+/// An iterator over the [`char`]s of a string slice.\n ///\n-/// Created with the method [`chars`].\n+/// [`char`]: ../../std/primitive.char.html\n+///\n+/// This struct is created by the [`chars`] method on [`str`].\n+/// See its documentation for more.\n ///\n /// [`chars`]: ../../std/primitive.str.html#method.chars\n+/// [`str`]: ../../std/primitive.str.html\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chars<'a> {\n@@ -553,7 +557,15 @@ impl<'a> Chars<'a> {\n     }\n }\n \n-/// Iterator for a string's characters and their byte offsets.\n+/// An iterator over the [`char`]s of a string slice, and their positions.\n+///\n+/// [`char`]: ../../std/primitive.char.html\n+///\n+/// This struct is created by the [`char_indices`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`char_indices`]: ../../std/primitive.str.html#method.char_indices\n+/// [`str`]: ../../std/primitive.str.html\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n@@ -625,12 +637,13 @@ impl<'a> CharIndices<'a> {\n     }\n }\n \n-/// External iterator for a string's bytes.\n-/// Use with the `std::iter` module.\n+/// An iterator over the bytes of a string slice.\n ///\n-/// Created with the method [`bytes`].\n+/// This struct is created by the [`bytes`] method on [`str`].\n+/// See its documentation for more.\n ///\n /// [`bytes`]: ../../std/primitive.str.html#method.bytes\n+/// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone, Debug)]\n pub struct Bytes<'a>(Cloned<slice::Iter<'a, u8>>);\n@@ -1161,9 +1174,13 @@ generate_pattern_iterators! {\n     delegate double ended;\n }\n \n-/// Created with the method [`lines`].\n+/// An iterator over the lines of a string, as string slices.\n+///\n+/// This struct is created with the [`lines`] method on [`str`].\n+/// See its documentation for more.\n ///\n /// [`lines`]: ../../std/primitive.str.html#method.lines\n+/// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone, Debug)]\n pub struct Lines<'a>(Map<SplitTerminator<'a, char>, LinesAnyMap>);"}, {"sha": "ae47e6fdfa928ee6b037d9d7e1c1e80cd74bfdfc", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -15,27 +15,37 @@\n //! types.\n //!\n //! This module defines atomic versions of a select number of primitive\n-//! types, including `AtomicBool`, `AtomicIsize`, and `AtomicUsize`.\n+//! types, including [`AtomicBool`], [`AtomicIsize`], and [`AtomicUsize`].\n //! Atomic types present operations that, when used correctly, synchronize\n //! updates between threads.\n //!\n-//! Each method takes an `Ordering` which represents the strength of\n+//! [`AtomicBool`]: struct.AtomicBool.html\n+//! [`AtomicIsize`]: struct.AtomicIsize.html\n+//! [`AtomicUsize`]: struct.AtomicUsize.html\n+//!\n+//! Each method takes an [`Ordering`] which represents the strength of\n //! the memory barrier for that operation. These orderings are the\n //! same as [LLVM atomic orderings][1]. For more information see the [nomicon][2].\n //!\n+//! [`Ordering`]: enum.Ordering.html\n+//!\n //! [1]: http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n //! [2]: ../../../nomicon/atomics.html\n //!\n-//! Atomic variables are safe to share between threads (they implement `Sync`)\n+//! Atomic variables are safe to share between threads (they implement [`Sync`])\n //! but they do not themselves provide the mechanism for sharing and follow the\n //! [threading model](../../../std/thread/index.html#the-threading-model) of rust.\n-//! The most common way to share an atomic variable is to put it into an `Arc` (an\n+//! The most common way to share an atomic variable is to put it into an [`Arc`][arc] (an\n //! atomically-reference-counted shared pointer).\n //!\n+//! [`Sync`]: ../../marker/trait.Sync.html\n+//! [arc]: ../../../std/sync/struct.Arc.html\n+//!\n //! Most atomic types may be stored in static variables, initialized using\n-//! the provided static initializers like `ATOMIC_BOOL_INIT`. Atomic statics\n+//! the provided static initializers like [`ATOMIC_BOOL_INIT`]. Atomic statics\n //! are often used for lazy global initialization.\n //!\n+//! [`ATOMIC_BOOL_INIT`]: constant.ATOMIC_BOOL_INIT.html\n //!\n //! # Examples\n //!\n@@ -148,22 +158,32 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Debug)]\n pub enum Ordering {\n-    /// No ordering constraints, only atomic operations. Corresponds to LLVM's\n-    /// `Monotonic` ordering.\n+    /// No ordering constraints, only atomic operations.\n+    ///\n+    /// Corresponds to LLVM's [`Monotonic`] ordering.\n+    ///\n+    /// [`Monotonic`]: http://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n-    /// to the other threads that perform a load with `Acquire` ordering\n+    /// to the other threads that perform a load with [`Acquire`] ordering\n     /// on the same value.\n+    ///\n+    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n-    /// written before a store with `Release` ordering on the same value\n+    /// written before a store with [`Release`] ordering on the same value\n     /// in other threads.\n+    ///\n+    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n-    /// When coupled with a load, uses `Acquire` ordering, and with a store\n-    /// `Release` ordering.\n+    /// When coupled with a load, uses [`Acquire`] ordering, and with a store\n+    /// [`Release`] ordering.\n+    ///\n+    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n+    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n@@ -176,7 +196,9 @@ pub enum Ordering {\n     __Nonexhaustive,\n }\n \n-/// An `AtomicBool` initialized to `false`.\n+/// An [`AtomicBool`] initialized to `false`.\n+///\n+/// [`AtomicBool`]: struct.AtomicBool.html\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n@@ -250,7 +272,7 @@ impl AtomicBool {\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -287,7 +309,10 @@ impl AtomicBool {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `order` is `Acquire` or `AcqRel`.\n+    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n+    ///\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n@@ -404,7 +429,7 @@ impl AtomicBool {\n \n     /// Stores a value into the `bool` if the current value is the same as the `current` value.\n     ///\n-    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n@@ -415,6 +440,7 @@ impl AtomicBool {\n     /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n     /// weaker than the success ordering.\n     ///\n+    /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n     /// [`AcqRel`]: enum.Ordering.html#variant.Release\n@@ -694,7 +720,10 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `order` is `Acquire` or `AcqRel`.\n+    /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n+    ///\n+    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n@@ -1008,7 +1037,10 @@ macro_rules! atomic_int {\n             ///\n             /// # Panics\n             ///\n-            /// Panics if `order` is `Acquire` or `AcqRel`.\n+            /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n+            ///\n+            /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n             #[inline]\n             #[$stable]\n             pub fn store(&self, val: $int_type, order: Ordering) {"}, {"sha": "ec38345030fa5897423ff55d2f4f882dcff4c1ee", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::cmp::Ordering::{Equal, Greater, Less};\n use core::slice::heapsort;\n use core::result::Result::{Ok, Err};\n use rand::{Rng, XorShiftRng};\n@@ -268,6 +269,17 @@ fn sort_unstable() {\n         }\n     }\n \n+    // Sort using a completely random comparison function.\n+    // This will reorder the elements *somehow*, but won't panic.\n+    for i in 0..v.len() {\n+        v[i] = i as i32;\n+    }\n+    v.sort_unstable_by(|_, _| *rng.choose(&[Less, Equal, Greater]).unwrap());\n+    v.sort_unstable();\n+    for i in 0..v.len() {\n+        assert_eq!(v[i], i as i32);\n+    }\n+\n     // Should not panic.\n     [0i32; 0].sort_unstable();\n     [(); 10].sort_unstable();"}, {"sha": "8d759d89135ac90ca505853dce307c241b666c29", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -196,10 +196,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(SUPER_OR_SELF_IN_GLOBAL_PATH),\n             reference: \"issue #36888 <https://github.com/rust-lang/rust/issues/36888>\",\n         },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(OVERLAPPING_INHERENT_IMPLS),\n-            reference: \"issue #36889 <https://github.com/rust-lang/rust/issues/36889>\",\n-        },\n         FutureIncompatibleInfo {\n             id: LintId::of(ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN),\n             reference: \"issue #36890 <https://github.com/rust-lang/rust/issues/36890>\",\n@@ -263,4 +259,5 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     store.register_removed(\"drop_with_repr_extern\", \"drop flags have been removed\");\n     store.register_removed(\"transmute_from_fn_item_types\",\n         \"always cast functions before transmuting them\");\n+    store.register_removed(\"overlapping_inherent_impls\", \"converted into hard error, see #36889\");\n }"}, {"sha": "dc4bd7733fc211e90a18851cab92c7a1c8b50698", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -322,4 +322,3 @@ impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n         }\n     }\n }\n-"}, {"sha": "fb951fd20e564cbd3490f105994b03b10564a92d", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -4212,4 +4212,5 @@ register_diagnostics! {\n            // but `{}` was found in the type `{}`\n     E0567, // auto traits can not have type parameters\n     E0568, // auto-traits can not have predicates,\n+    E0592, // duplicate definitions with name `{}`\n }"}, {"sha": "8ebc5c0a8fe2d9443f14613f19b9648502e3afc8", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -145,6 +145,18 @@\n //! # }\n //! ```\n //!\n+//! Note that you cannot use the `?` operator in functions that do not return\n+//! a `Result<T, E>` (e.g. `main`). Instead, you can call `.unwrap()` or `match`\n+//! on the return value to catch any possible errors:\n+//!\n+//! ```\n+//! use std::io;\n+//!\n+//! let mut input = String::new();\n+//!\n+//! io::stdin().read_line(&mut input).unwrap();\n+//! ```\n+//!\n //! And a very common source of output is standard output:\n //!\n //! ```"}, {"sha": "5b2053e929a10317d645126fcbd16e163dd0cc10", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -183,9 +183,9 @@ mod prim_unit { }\n /// Working with raw pointers in Rust is uncommon,\n /// typically limited to a few patterns.\n ///\n-/// Use the `null` function to create null pointers, and the `is_null` method\n+/// Use the [`null`] function to create null pointers, and the [`is_null`] method\n /// of the `*const T` type  to check for null. The `*const T` type also defines\n-/// the `offset` method, for pointer math.\n+/// the [`offset`] method, for pointer math.\n ///\n /// # Common ways to create raw pointers\n ///\n@@ -213,7 +213,7 @@ mod prim_unit { }\n ///\n /// ## 2. Consume a box (`Box<T>`).\n ///\n-/// The `into_raw` function consumes a box and returns\n+/// The [`into_raw`] function consumes a box and returns\n /// the raw pointer. It doesn't destroy `T` or deallocate any memory.\n ///\n /// ```\n@@ -227,7 +227,7 @@ mod prim_unit { }\n /// }\n /// ```\n ///\n-/// Note that here the call to `drop` is for clarity - it indicates\n+/// Note that here the call to [`drop`] is for clarity - it indicates\n /// that we are done with the given value and it should be destroyed.\n ///\n /// ## 3. Get it from C.\n@@ -255,6 +255,11 @@ mod prim_unit { }\n ///\n /// *[See also the `std::ptr` module](ptr/index.html).*\n ///\n+/// [`null`]: ../std/ptr/fn.null.html\n+/// [`is_null`]: ../std/primitive.pointer.html#method.is_null\n+/// [`offset`]: ../std/primitive.pointer.html#method.offset\n+/// [`into_raw`]: ../std/boxed/struct.Box.html#method.into_raw\n+/// [`drop`]: ../std/mem/fn.drop.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_pointer { }\n "}, {"sha": "770b67acd49efef51e16942aaaf36ce13e505b10", "filename": "src/libstd_unicode/u_str.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibstd_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Flibstd_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fu_str.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -19,6 +19,12 @@ use core::str::Split;\n \n /// An iterator over the non-whitespace substrings of a string,\n /// separated by any amount of whitespace.\n+///\n+/// This struct is created by the [`split_whitespace`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_whitespace`]: ../../std/primitive.str.html#method.split_whitespace\n+/// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n pub struct SplitWhitespace<'a> {\n     inner: Filter<Split<'a, fn(char) -> bool>, fn(&&str) -> bool>,"}, {"sha": "158d3606104a956de3b9ec0461e9f66a6c8f92ec", "filename": "src/test/compile-fail/coherence-overlapping-inherent-impl-trait.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Ftest%2Fcompile-fail%2Fcoherence-overlapping-inherent-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Ftest%2Fcompile-fail%2Fcoherence-overlapping-inherent-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlapping-inherent-impl-trait.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -9,10 +9,8 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n-#![deny(overlapping_inherent_impls)]\n \n trait C {}\n impl C { fn f() {} } //~ ERROR duplicate definitions with name `f`\n-//~^ WARN: this was previously accepted\n impl C { fn f() {} }\n fn main() { }"}, {"sha": "18e77ddfd2c5b450e48af1c11bf98657c0214da4", "filename": "src/test/compile-fail/inherent-overlap.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Ftest%2Fcompile-fail%2Finherent-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1652870f5900bc41610d808b8bc2d51c901192/src%2Ftest%2Fcompile-fail%2Finherent-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finherent-overlap.rs?ref=2f1652870f5900bc41610d808b8bc2d51c901192", "patch": "@@ -17,7 +17,6 @@ struct Foo;\n \n impl Foo {\n     fn id() {} //~ ERROR duplicate definitions\n-    //~^ WARN previously accepted\n }\n \n impl Foo {\n@@ -28,7 +27,6 @@ struct Bar<T>(T);\n \n impl<T> Bar<T> {\n     fn bar(&self) {} //~ ERROR duplicate definitions\n-    //~^ WARN previously accepted\n }\n \n impl Bar<u32> {\n@@ -39,7 +37,6 @@ struct Baz<T>(T);\n \n impl<T: Copy> Baz<T> {\n     fn baz(&self) {} //~ ERROR duplicate definitions\n-    //~^ WARN previously accepted\n }\n \n impl<T> Baz<Vec<T>> {"}]}