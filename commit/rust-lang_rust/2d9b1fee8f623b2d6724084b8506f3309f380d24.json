{"sha": "2d9b1fee8f623b2d6724084b8506f3309f380d24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkOWIxZmVlOGY2MjNiMmQ2NzI0MDg0Yjg1MDZmMzMwOWYzODBkMjQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-08T18:50:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-08T19:28:56Z"}, "message": "Merge remote-tracking branch 'gifnksm/bigint' into kind-names", "tree": {"sha": "7b37c601563d80a976df048541c34788f31ed057", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b37c601563d80a976df048541c34788f31ed057"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d9b1fee8f623b2d6724084b8506f3309f380d24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d9b1fee8f623b2d6724084b8506f3309f380d24", "html_url": "https://github.com/rust-lang/rust/commit/2d9b1fee8f623b2d6724084b8506f3309f380d24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d9b1fee8f623b2d6724084b8506f3309f380d24/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "722d670c85e68a71b5731546c0590241c35f8fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/722d670c85e68a71b5731546c0590241c35f8fc4", "html_url": "https://github.com/rust-lang/rust/commit/722d670c85e68a71b5731546c0590241c35f8fc4"}, {"sha": "68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49", "url": "https://api.github.com/repos/rust-lang/rust/commits/68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49", "html_url": "https://github.com/rust-lang/rust/commit/68c689f1ca9527dc536f7c4a3e7c70bb5a28fb49"}], "stats": {"total": 1499, "additions": 1499, "deletions": 0}, "files": [{"sha": "37d5890070ace1897c6eef14c5e0895df4e7d315", "filename": "src/libstd/bigint.rs", "status": "added", "additions": 1498, "deletions": 0, "changes": 1498, "blob_url": "https://github.com/rust-lang/rust/blob/2d9b1fee8f623b2d6724084b8506f3309f380d24/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9b1fee8f623b2d6724084b8506f3309f380d24/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=2d9b1fee8f623b2d6724084b8506f3309f380d24", "patch": "@@ -0,0 +1,1498 @@\n+/*!\n+\n+A Big integer (signed version: BigInt, unsigned version: BigUint).\n+\n+A BigUint is represented as an array of BigDigits.\n+A BigInt is a combination of BigUint and Sign.\n+*/\n+\n+use core::cmp::{Eq, Ord};\n+use core::num::{Num, Zero, One};\n+use core::*;\n+\n+/**\n+A BigDigit is a BigUint's composing element.\n+\n+A BigDigit is half the size of machine word size.\n+*/\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"arm\")]\n+pub type BigDigit = u16;\n+\n+/**\n+A BigDigit is a BigUint's composing element.\n+\n+A BigDigit is half the size of machine word size.\n+*/\n+#[cfg(target_arch = \"x86_64\")]\n+pub type BigDigit = u32;\n+\n+pub mod BigDigit {\n+    #[cfg(target_arch = \"x86\")]\n+    #[cfg(target_arch = \"arm\")]\n+    pub const bits: uint = 16;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    pub const bits: uint = 32;\n+\n+    pub const base: uint = 1 << bits;\n+    priv const hi_mask: uint = (-1 as uint) << bits;\n+    priv const lo_mask: uint = (-1 as uint) >> bits;\n+\n+    priv pure fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n+    priv pure fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n+\n+    /// Split one machine sized unsigned integer into two BigDigits.\n+    pub pure fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n+        (get_hi(n), get_lo(n))\n+    }\n+\n+    /// Join two BigDigits into one machine sized unsigned integer\n+    pub pure fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n+        (lo as uint) | ((hi as uint) << bits)\n+    }\n+}\n+\n+/**\n+A big unsigned integer type.\n+\n+A BigUint-typed value BigUint { data: @[a, b, c] } represents a number\n+(a + b * BigDigit::base + c * BigDigit::base^2).\n+*/\n+pub struct BigUint {\n+    priv data: ~[BigDigit]\n+}\n+\n+impl BigUint : Eq {\n+    pure fn eq(&self, other: &BigUint) -> bool { self.cmp(other) == 0 }\n+    pure fn ne(&self, other: &BigUint) -> bool { self.cmp(other) != 0 }\n+}\n+\n+impl BigUint : Ord {\n+    pure fn lt(&self, other: &BigUint) -> bool { self.cmp(other) <  0 }\n+    pure fn le(&self, other: &BigUint) -> bool { self.cmp(other) <= 0 }\n+    pure fn ge(&self, other: &BigUint) -> bool { self.cmp(other) >= 0 }\n+    pure fn gt(&self, other: &BigUint) -> bool { self.cmp(other) >  0 }\n+}\n+\n+impl BigUint : ToStr {\n+    pure fn to_str() -> ~str { self.to_str_radix(10) }\n+}\n+\n+impl BigUint : from_str::FromStr {\n+    static pure fn from_str(s: &str) -> Option<BigUint> {\n+        BigUint::from_str_radix(s, 10)\n+    }\n+}\n+\n+impl BigUint : Shl<uint, BigUint> {\n+    pure fn shl(&self, rhs: &uint) -> BigUint {\n+        let n_unit = *rhs / BigDigit::bits;\n+        let n_bits = *rhs % BigDigit::bits;\n+        return self.shl_unit(n_unit).shl_bits(n_bits);\n+    }\n+}\n+\n+impl BigUint : Shr<uint, BigUint> {\n+    pure fn shr(&self, rhs: &uint) -> BigUint {\n+        let n_unit = *rhs / BigDigit::bits;\n+        let n_bits = *rhs % BigDigit::bits;\n+        return self.shr_unit(n_unit).shr_bits(n_bits);\n+    }\n+}\n+\n+impl BigUint : Zero {\n+    static pure fn zero() -> BigUint { BigUint::new(~[]) }\n+}\n+\n+impl BigUint : One {\n+    static pub pure fn one() -> BigUint { BigUint::new(~[1]) }\n+}\n+\n+impl BigUint : Num {\n+    pure fn add(&self, other: &BigUint) -> BigUint {\n+        let new_len = uint::max(self.data.len(), other.data.len());\n+\n+        let mut carry = 0;\n+        let sum = do vec::from_fn(new_len) |i| {\n+            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n+            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n+            let (hi, lo) = BigDigit::from_uint(\n+                (ai as uint) + (bi as uint) + (carry as uint)\n+            );\n+            carry = hi;\n+            lo\n+        };\n+        if carry == 0 { return BigUint::new(sum) };\n+        return BigUint::new(sum + [carry]);\n+    }\n+\n+    pure fn sub(&self, other: &BigUint) -> BigUint {\n+        let new_len = uint::max(self.data.len(), other.data.len());\n+\n+        let mut borrow = 0;\n+        let diff = do vec::from_fn(new_len) |i| {\n+            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n+            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n+            let (hi, lo) = BigDigit::from_uint(\n+                (BigDigit::base) +\n+                (ai as uint) - (bi as uint) - (borrow as uint)\n+            );\n+            /*\n+            hi * (base) + lo == 1*(base) + ai - bi - borrow\n+            => ai - bi - borrow < 0 <=> hi == 0\n+            */\n+            borrow = if hi == 0 { 1 } else { 0 };\n+            lo\n+        };\n+\n+        assert borrow == 0;     // <=> assert (self >= other);\n+        return BigUint::new(diff);\n+    }\n+\n+    pure fn mul(&self, other: &BigUint) -> BigUint {\n+        if self.is_zero() || other.is_zero() { return Zero::zero(); }\n+\n+        let s_len = self.data.len(), o_len = other.data.len();\n+        if s_len == 1 { return mul_digit(other, self.data[0]);  }\n+        if o_len == 1 { return mul_digit(self,  other.data[0]); }\n+\n+        // Using Karatsuba multiplication\n+        // (a1 * base + a0) * (b1 * base + b0)\n+        // = a1*b1 * base^2 +\n+        //   (a1*b1 + a0*b0 - (a1-b0)*(b1-a0)) * base +\n+        //   a0*b0\n+        let half_len = uint::max(s_len, o_len) / 2;\n+        let (sHi, sLo) = cut_at(self,  half_len);\n+        let (oHi, oLo) = cut_at(other, half_len);\n+\n+        let ll = sLo * oLo;\n+        let hh = sHi * oHi;\n+        let mm = {\n+            let (s1, n1) = sub_sign(sHi, sLo);\n+            let (s2, n2) = sub_sign(oHi, oLo);\n+            if s1 * s2 < 0 {\n+                hh + ll + (n1 * n2)\n+            } else if s1 * s2 > 0 {\n+                hh + ll - (n1 * n2)\n+            } else {\n+                hh + ll\n+            }\n+        };\n+\n+        return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n+\n+        pure fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n+            if n == 0 { return Zero::zero(); }\n+            if n == 1 { return copy *a; }\n+\n+            let mut carry = 0;\n+            let prod = do vec::map(a.data) |ai| {\n+                let (hi, lo) = BigDigit::from_uint(\n+                    (*ai as uint) * (n as uint) + (carry as uint)\n+                );\n+                carry = hi;\n+                lo\n+            };\n+            if carry == 0 { return BigUint::new(prod) };\n+            return BigUint::new(prod + [carry]);\n+        }\n+\n+        pure fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n+            let mid = uint::min(a.data.len(), n);\n+            return (BigUint::from_slice(vec::view(a.data, mid, a.data.len())),\n+                    BigUint::from_slice(vec::view(a.data, 0, mid)));\n+        }\n+\n+        pure fn sub_sign(a: BigUint, b: BigUint) -> (int, BigUint) {\n+            match a.cmp(&b) {\n+                s if s < 0 => (s, b - a),\n+                s if s > 0 => (s, a - b),\n+                _          => (0, Zero::zero())\n+            }\n+        }\n+    }\n+\n+    pure fn div(&self, other: &BigUint) -> BigUint {\n+        let (d, _) = self.divmod(other);\n+        return d;\n+    }\n+    pure fn modulo(&self, other: &BigUint) -> BigUint {\n+        let (_, m) = self.divmod(other);\n+        return m;\n+    }\n+\n+    pure fn neg(&self) -> BigUint { fail }\n+\n+    pure fn to_int(&self) -> int {\n+        uint::min(self.to_uint(), int::max_value as uint) as int\n+    }\n+\n+    static pure fn from_int(n: int) -> BigUint {\n+        if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n+    }\n+}\n+\n+pub impl BigUint {\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn new(v: ~[BigDigit]) -> BigUint {\n+        // omit trailing zeros\n+        let new_len = v.rposition(|n| *n != 0).map_default(0, |p| *p + 1);\n+\n+        if new_len == v.len() { return BigUint { data: v }; }\n+        let mut v = v;\n+        unsafe { v.truncate(new_len); }\n+        return BigUint { data: v };\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_uint(n: uint) -> BigUint {\n+        match BigDigit::from_uint(n) {\n+            (0,  0)  => Zero::zero(),\n+            (0,  n0) => BigUint::new(~[n0]),\n+            (n1, n0) => BigUint::new(~[n0, n1])\n+        }\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_slice(slice: &[BigDigit]) -> BigUint {\n+        return BigUint::new(vec::from_slice(slice));\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn from_str_radix(s: &str, radix: uint)\n+        -> Option<BigUint> {\n+        BigUint::parse_bytes(str::to_bytes(s), radix)\n+    }\n+\n+    /// Creates and initializes an BigUint.\n+    static pub pure fn parse_bytes(buf: &[u8], radix: uint)\n+        -> Option<BigUint> {\n+        let (base, unit_len) = get_radix_base(radix);\n+        let base_num: BigUint = BigUint::from_uint(base);\n+\n+        let mut end             = buf.len();\n+        let mut n: BigUint      = Zero::zero();\n+        let mut power: BigUint  = One::one();\n+        loop {\n+            let start = uint::max(end, unit_len) - unit_len;\n+            match uint::parse_bytes(vec::view(buf, start, end), radix) {\n+                Some(d) => n += BigUint::from_uint(d) * power,\n+                None    => return None\n+            }\n+            if end <= unit_len {\n+                return Some(n);\n+            }\n+            end -= unit_len;\n+            power *= base_num;\n+        }\n+    }\n+\n+    pure fn abs(&self) -> BigUint { copy *self }\n+\n+    /// Compare two BigUint value.\n+    pure fn cmp(&self, other: &BigUint) -> int {\n+        let s_len = self.data.len(), o_len = other.data.len();\n+        if s_len < o_len { return -1; }\n+        if s_len > o_len { return  1;  }\n+\n+        for vec::rev_eachi(self.data) |i, elm| {\n+            match (*elm, other.data[i]) {\n+                (l, r) if l < r => return -1,\n+                (l, r) if l > r => return  1,\n+                _               => loop\n+            };\n+        }\n+        return 0;\n+    }\n+\n+    pure fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n+        if other.is_zero() { fail }\n+        if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n+        if *other == One::one() { return (copy *self, Zero::zero()); }\n+\n+        match self.cmp(other) {\n+            s if s < 0 => return (Zero::zero(), copy *self),\n+            0          => return (One::one(), Zero::zero()),\n+            _          => {} // Do nothing\n+        }\n+\n+        let mut shift = 0;\n+        let mut n = other.data.last();\n+        while n < (1 << BigDigit::bits - 2) {\n+            n <<= 1;\n+            shift += 1;\n+        }\n+        assert shift < BigDigit::bits;\n+        let (d, m) = divmod_inner(self << shift, other << shift);\n+        return (d, m >> shift);\n+\n+        pure fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n+            let mut r = a;\n+            let mut d = Zero::zero::<BigUint>();\n+            let mut n = 1;\n+            while r >= b {\n+                let mut (d0, d_unit, b_unit) = div_estimate(&r, &b, n);\n+                let mut prod = b * d0;\n+                while prod > r {\n+                    d0   -= d_unit;\n+                    prod -= b_unit;\n+                }\n+                if d0.is_zero() {\n+                    n = 2;\n+                    loop;\n+                }\n+                n = 1;\n+                d += d0;\n+                r -= prod;\n+            }\n+            return (d, r);\n+        }\n+\n+        pure fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n+            -> (BigUint, BigUint, BigUint) {\n+            if a.data.len() < n {\n+                return (Zero::zero(), Zero::zero(), copy *a);\n+            }\n+\n+            let an = vec::view(a.data, a.data.len() - n, a.data.len());\n+            let bn = b.data.last();\n+            let mut d = ~[];\n+            let mut carry = 0;\n+            for vec::rev_each(an) |elt| {\n+                let ai = BigDigit::to_uint(carry, *elt);\n+                let di = ai / (bn as uint);\n+                assert di < BigDigit::base;\n+                carry = (ai % (bn as uint)) as BigDigit;\n+                d = ~[di as BigDigit] + d;\n+            }\n+\n+            let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n+            if shift == 0 {\n+                return (BigUint::new(d), One::one(), copy *b);\n+            }\n+            return (BigUint::from_slice(d).shl_unit(shift),\n+                    One::one::<BigUint>().shl_unit(shift),\n+                    b.shl_unit(shift));\n+        }\n+    }\n+\n+    pure fn quot(&self, other: &BigUint) -> BigUint {\n+        let (q, _) = self.quotrem(other);\n+        return q;\n+    }\n+    pure fn rem(&self, other: &BigUint) -> BigUint {\n+        let (_, r) = self.quotrem(other);\n+        return r;\n+    }\n+    pure fn quotrem(&self, other: &BigUint) -> (BigUint, BigUint) {\n+        self.divmod(other)\n+    }\n+\n+    pure fn is_zero(&self) -> bool { self.data.is_empty() }\n+    pure fn is_not_zero(&self) -> bool { self.data.is_not_empty() }\n+    pure fn is_positive(&self) -> bool { self.is_not_zero() }\n+    pure fn is_negative(&self) -> bool { false }\n+    pure fn is_nonpositive(&self) -> bool { self.is_zero() }\n+    pure fn is_nonnegative(&self) -> bool { true }\n+\n+    pure fn to_uint(&self) -> uint {\n+        match self.data.len() {\n+            0 => 0,\n+            1 => self.data[0] as uint,\n+            2 => BigDigit::to_uint(self.data[1], self.data[0]),\n+            _ => uint::max_value\n+        }\n+    }\n+\n+    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+        assert 1 < radix && radix <= 16;\n+        let (base, max_len) = get_radix_base(radix);\n+        if base == BigDigit::base {\n+            return fill_concat(self.data, radix, max_len)\n+        }\n+        return fill_concat(convert_base(copy *self, base), radix, max_len);\n+\n+        pure fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n+            let divider    = BigUint::from_uint(base);\n+            let mut result = ~[];\n+            let mut r      = n;\n+            while r > divider {\n+                let (d, r0) = r.divmod(&divider);\n+                result += [r0.to_uint() as BigDigit];\n+                r = d;\n+            }\n+            if r.is_not_zero() {\n+                result += [r.to_uint() as BigDigit];\n+            }\n+            return result;\n+        }\n+\n+        pure fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n+            if v.is_empty() { return ~\"0\" }\n+            str::trim_left_chars(str::concat(vec::reversed(v).map(|n| {\n+                let s = uint::to_str(*n as uint, radix);\n+                str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n+            })), ['0'])\n+        }\n+    }\n+\n+    priv pure fn shl_unit(self, n_unit: uint) -> BigUint {\n+        if n_unit == 0 || self.is_zero() { return self; }\n+\n+        return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n+    }\n+\n+    priv pure fn shl_bits(self, n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.is_zero() { return self; }\n+\n+        let mut carry = 0;\n+        let shifted = do vec::map(self.data) |elem| {\n+            let (hi, lo) = BigDigit::from_uint(\n+                (*elem as uint) << n_bits | (carry as uint)\n+            );\n+            carry = hi;\n+            lo\n+        };\n+        if carry == 0 { return BigUint::new(shifted); }\n+        return BigUint::new(shifted + [carry]);\n+    }\n+\n+    priv pure fn shr_unit(self, n_unit: uint) -> BigUint {\n+        if n_unit == 0 { return self; }\n+        if self.data.len() < n_unit { return Zero::zero(); }\n+        return BigUint::from_slice(\n+            vec::view(self.data, n_unit, self.data.len())\n+        );\n+    }\n+\n+    priv pure fn shr_bits(self, n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.data.is_empty() { return self; }\n+\n+        let mut borrow = 0;\n+        let mut shifted = ~[];\n+        for vec::rev_each(self.data) |elem| {\n+            shifted = ~[(*elem >> n_bits) | borrow] + shifted;\n+            borrow = *elem << (uint::bits - n_bits);\n+        }\n+        return BigUint::new(shifted);\n+    }\n+}\n+\n+priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n+    assert 1 < radix && radix <= 16;\n+    match radix {\n+        2  => (4294967296, 32),\n+        3  => (3486784401, 20),\n+        4  => (4294967296, 16),\n+        5  => (1220703125, 13),\n+        6  => (2176782336, 12),\n+        7  => (1977326743, 11),\n+        8  => (1073741824, 10),\n+        9  => (3486784401, 10),\n+        10 => (1000000000, 9),\n+        11 => (2357947691, 9),\n+        12 => (429981696,  8),\n+        13 => (815730721,  8),\n+        14 => (1475789056, 8),\n+        15 => (2562890625, 8),\n+        16 => (4294967296, 8),\n+        _  => fail\n+    }\n+}\n+\n+/// A Sign is a BigInt's composing element.\n+pub enum Sign { Minus, Zero, Plus }\n+\n+impl Sign : Eq {\n+    pure fn eq(&self, other: &Sign) -> bool { self.cmp(other) == 0 }\n+    pure fn ne(&self, other: &Sign) -> bool { self.cmp(other) != 0 }\n+}\n+\n+impl Sign : Ord {\n+    pure fn lt(&self, other: &Sign) -> bool { self.cmp(other) <  0 }\n+    pure fn le(&self, other: &Sign) -> bool { self.cmp(other) <= 0 }\n+    pure fn ge(&self, other: &Sign) -> bool { self.cmp(other) >= 0 }\n+    pure fn gt(&self, other: &Sign) -> bool { self.cmp(other) >  0 }\n+}\n+\n+pub impl Sign {\n+    /// Compare two Sign.\n+    pure fn cmp(&self, other: &Sign) -> int {\n+        match (*self, *other) {\n+          (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) =>  0,\n+          (Minus, Zero)  | (Minus, Plus) | (Zero, Plus) => -1,\n+          _                                             =>  1\n+        }\n+    }\n+\n+    /// Negate Sign value.\n+    pure fn neg(&self) -> Sign {\n+        match *self {\n+          Minus => Plus,\n+          Zero  => Zero,\n+          Plus  => Minus\n+        }\n+    }\n+}\n+\n+/// A big signed integer type.\n+pub struct BigInt {\n+    priv sign: Sign,\n+    priv data: BigUint\n+}\n+\n+impl BigInt : Eq {\n+    pure fn eq(&self, other: &BigInt) -> bool { self.cmp(other) == 0 }\n+    pure fn ne(&self, other: &BigInt) -> bool { self.cmp(other) != 0 }\n+}\n+\n+impl BigInt : Ord {\n+    pure fn lt(&self, other: &BigInt) -> bool { self.cmp(other) <  0 }\n+    pure fn le(&self, other: &BigInt) -> bool { self.cmp(other) <= 0 }\n+    pure fn ge(&self, other: &BigInt) -> bool { self.cmp(other) >= 0 }\n+    pure fn gt(&self, other: &BigInt) -> bool { self.cmp(other) >  0 }\n+}\n+\n+impl BigInt : ToStr {\n+    pure fn to_str() -> ~str { self.to_str_radix(10) }\n+}\n+\n+impl BigInt : from_str::FromStr {\n+    static pure fn from_str(s: &str) -> Option<BigInt> {\n+        BigInt::from_str_radix(s, 10)\n+    }\n+}\n+\n+impl BigInt : Shl<uint, BigInt> {\n+    pure fn shl(&self, rhs: &uint) -> BigInt {\n+        BigInt::from_biguint(self.sign, self.data << *rhs)\n+    }\n+}\n+\n+impl BigInt : Shr<uint, BigInt> {\n+    pure fn shr(&self, rhs: &uint) -> BigInt {\n+        BigInt::from_biguint(self.sign, self.data >> *rhs)\n+    }\n+}\n+\n+impl BigInt : Zero {\n+    static pub pure fn zero() -> BigInt {\n+        BigInt::from_biguint(Zero, Zero::zero())\n+    }\n+}\n+\n+impl BigInt : One {\n+    static pub pure fn one() -> BigInt {\n+        BigInt::from_biguint(Plus, One::one())\n+    }\n+}\n+\n+impl BigInt : Num {\n+    pure fn add(&self, other: &BigInt) -> BigInt {\n+        match (self.sign, other.sign) {\n+            (Zero, _)      => copy *other,\n+            (_,    Zero)   => copy *self,\n+            (Plus, Plus)   => BigInt::from_biguint(Plus,\n+                                                   self.data + other.data),\n+            (Plus, Minus)  => self - (-*other),\n+            (Minus, Plus)  => other - (-*self),\n+            (Minus, Minus) => -((-self) + (-*other))\n+        }\n+    }\n+    pure fn sub(&self, other: &BigInt) -> BigInt {\n+        match (self.sign, other.sign) {\n+            (Zero, _)    => -other,\n+            (_,    Zero) => copy *self,\n+            (Plus, Plus) => match self.data.cmp(&other.data) {\n+                s if s < 0 =>\n+                    BigInt::from_biguint(Minus, other.data - self.data),\n+                s if s > 0 =>\n+                    BigInt::from_biguint(Plus, self.data - other.data),\n+                _ =>\n+                    Zero::zero()\n+            },\n+            (Plus, Minus) => self + (-*other),\n+            (Minus, Plus) => -((-self) + *other),\n+            (Minus, Minus) => (-other) - (-*self)\n+        }\n+    }\n+    pure fn mul(&self, other: &BigInt) -> BigInt {\n+        match (self.sign, other.sign) {\n+            (Zero, _)     | (_,     Zero)  => Zero::zero(),\n+            (Plus, Plus)  | (Minus, Minus) => {\n+                BigInt::from_biguint(Plus, self.data * other.data)\n+            },\n+            (Plus, Minus) | (Minus, Plus) => {\n+                BigInt::from_biguint(Minus, self.data * other.data)\n+            }\n+        }\n+    }\n+    pure fn div(&self, other: &BigInt) -> BigInt {\n+        let (d, _) = self.divmod(other);\n+        return d;\n+    }\n+    pure fn modulo(&self, other: &BigInt) -> BigInt {\n+        let (_, m) = self.divmod(other);\n+        return m;\n+    }\n+    pure fn neg(&self) -> BigInt {\n+        BigInt::from_biguint(self.sign.neg(), copy self.data)\n+    }\n+\n+    pure fn to_int(&self) -> int {\n+        match self.sign {\n+            Plus  => uint::min(self.to_uint(), int::max_value as uint) as int,\n+            Zero  => 0,\n+            Minus => uint::min((-self).to_uint(),\n+                               (int::max_value as uint) + 1) as int\n+        }\n+    }\n+\n+    static pure fn from_int(n: int) -> BigInt {\n+        if n > 0 {\n+           return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n+        }\n+        if n < 0 {\n+            return BigInt::from_biguint(\n+                Minus, BigUint::from_uint(uint::max_value - (n as uint) + 1)\n+            );\n+        }\n+        return Zero::zero();\n+    }\n+}\n+\n+pub impl BigInt {\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n+        BigInt::from_biguint(sign, BigUint::new(v))\n+    }\n+\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n+        if sign == Zero || data.is_zero() {\n+            return BigInt { sign: Zero, data: Zero::zero() };\n+        }\n+        return BigInt { sign: sign, data: data };\n+    }\n+\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn from_uint(n: uint) -> BigInt {\n+        if n == 0 { return Zero::zero(); }\n+        return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n+    }\n+\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n+        BigInt::from_biguint(sign, BigUint::from_slice(slice))\n+    }\n+\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn from_str_radix(s: &str, radix: uint)\n+        -> Option<BigInt> {\n+        BigInt::parse_bytes(str::to_bytes(s), radix)\n+    }\n+\n+    /// Creates and initializes an BigInt.\n+    static pub pure fn parse_bytes(buf: &[u8], radix: uint)\n+        -> Option<BigInt> {\n+        if buf.is_empty() { return None; }\n+        let mut sign  = Plus;\n+        let mut start = 0;\n+        if buf[0] == ('-' as u8) {\n+            sign  = Minus;\n+            start = 1;\n+        }\n+        return BigUint::parse_bytes(vec::view(buf, start, buf.len()), radix)\n+            .map(|bu| BigInt::from_biguint(sign, *bu));\n+    }\n+\n+    pure fn abs(&self) -> BigInt {\n+        BigInt::from_biguint(Plus, copy self.data)\n+    }\n+\n+    pure fn cmp(&self, other: &BigInt) -> int {\n+        let ss = self.sign, os = other.sign;\n+        if ss < os { return -1; }\n+        if ss > os { return  1; }\n+\n+        assert ss == os;\n+        match ss {\n+            Zero  => 0,\n+            Plus  => self.data.cmp(&other.data),\n+            Minus => self.data.cmp(&other.data).neg(),\n+        }\n+    }\n+\n+    pure fn divmod(&self, other: &BigInt) -> (BigInt, BigInt) {\n+        // m.sign == other.sign\n+        let (d_ui, m_ui) = self.data.divmod(&other.data);\n+        let d = BigInt::from_biguint(Plus, d_ui),\n+            m = BigInt::from_biguint(Plus, m_ui);\n+        match (self.sign, other.sign) {\n+            (_,    Zero)   => fail,\n+            (Plus, Plus)  | (Zero, Plus)  => (d, m),\n+            (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n+                (-d, Zero::zero())\n+            } else {\n+                (-d - One::one(), m + *other)\n+            },\n+            (Minus, Plus) => if m.is_zero() {\n+                (-d, Zero::zero())\n+            } else {\n+                (-d - One::one(), other - m)\n+            },\n+            (Minus, Minus) => (d, -m)\n+        }\n+    }\n+\n+    pure fn quot(&self, other: &BigInt) -> BigInt {\n+        let (q, _) = self.quotrem(other);\n+        return q;\n+    }\n+    pure fn rem(&self, other: &BigInt) -> BigInt {\n+        let (_, r) = self.quotrem(other);\n+        return r;\n+    }\n+\n+    pure fn quotrem(&self, other: &BigInt) -> (BigInt, BigInt) {\n+        // r.sign == self.sign\n+        let (q_ui, r_ui) = self.data.quotrem(&other.data);\n+        let q = BigInt::from_biguint(Plus, q_ui);\n+        let r = BigInt::from_biguint(Plus, r_ui);\n+        match (self.sign, other.sign) {\n+            (_,    Zero)   => fail,\n+            (Plus, Plus)  | (Zero, Plus)  => ( q,  r),\n+            (Plus, Minus) | (Zero, Minus) => (-q,  r),\n+            (Minus, Plus)                 => (-q, -r),\n+            (Minus, Minus)                => ( q, -r)\n+        }\n+    }\n+\n+    pure fn is_zero(&self) -> bool { self.sign == Zero }\n+    pure fn is_not_zero(&self) -> bool { self.sign != Zero }\n+    pure fn is_positive(&self) -> bool { self.sign == Plus }\n+    pure fn is_negative(&self) -> bool { self.sign == Minus }\n+    pure fn is_nonpositive(&self) -> bool { self.sign != Plus }\n+    pure fn is_nonnegative(&self) -> bool { self.sign != Minus }\n+\n+    pure fn to_uint(&self) -> uint {\n+        match self.sign {\n+            Plus  => self.data.to_uint(),\n+            Zero  => 0,\n+            Minus => 0\n+        }\n+    }\n+\n+    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+        match self.sign {\n+            Plus  => self.data.to_str_radix(radix),\n+            Zero  => ~\"0\",\n+            Minus => ~\"-\" + self.data.to_str_radix(radix)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod biguint_tests {\n+\n+    use core::*;\n+    use core::num::{Num, Zero, One};\n+    use super::{BigInt, BigUint, BigDigit};\n+\n+    #[test]\n+    fn test_from_slice() {\n+        fn check(slice: &[BigDigit], data: &[BigDigit]) {\n+            assert data == BigUint::from_slice(slice).data;\n+        }\n+        check(~[1], ~[1]);\n+        check(~[0, 0, 0], ~[]);\n+        check(~[1, 2, 0, 0], ~[1, 2]);\n+        check(~[0, 0, 1, 2], ~[0, 0, 1, 2]);\n+        check(~[0, 0, 1, 2, 0, 0], ~[0, 0, 1, 2]);\n+        check(~[-1], ~[-1]);\n+    }\n+\n+    #[test]\n+    fn test_cmp() {\n+        let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n+            .map(|v| BigUint::from_slice(*v));\n+        for data.eachi |i, ni| {\n+            for vec::view(data, i, data.len()).eachi |j0, nj| {\n+                let j = j0 + i;\n+                if i == j {\n+                    assert ni.cmp(nj) == 0;\n+                    assert nj.cmp(ni) == 0;\n+                    assert ni == nj;\n+                    assert !(ni != nj);\n+                    assert ni <= nj;\n+                    assert ni >= nj;\n+                    assert !(ni < nj);\n+                    assert !(ni > nj);\n+                } else {\n+                    assert ni.cmp(nj) < 0;\n+                    assert nj.cmp(ni) > 0;\n+\n+                    assert !(ni == nj);\n+                    assert ni != nj;\n+\n+                    assert ni <= nj;\n+                    assert !(ni >= nj);\n+                    assert ni < nj;\n+                    assert !(ni > nj);\n+\n+                    assert !(nj <= ni);\n+                    assert nj >= ni;\n+                    assert !(nj < ni);\n+                    assert nj > ni;\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_shl() {\n+        fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n+            assert BigUint::new(v) << shift == BigUint::new(ans);\n+        }\n+\n+        check(~[], 3, ~[]);\n+        check(~[1, 1, 1], 3, ~[1 << 3, 1 << 3, 1 << 3]);\n+        check(~[1 << (BigDigit::bits - 2)], 2, ~[0, 1]);\n+        check(~[1 << (BigDigit::bits - 2)], 3, ~[0, 2]);\n+        check(~[1 << (BigDigit::bits - 2)], 3 + BigDigit::bits, ~[0, 0, 2]);\n+        check(~[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98], 4,\n+              ~[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf]);\n+        check(~[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777], 16,\n+              ~[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888]);\n+    }\n+\n+    #[test]\n+    fn test_shr() {\n+        fn check(v: ~[BigDigit], shift: uint, ans: ~[BigDigit]) {\n+            assert BigUint::new(v) >> shift == BigUint::new(ans);\n+        }\n+\n+        check(~[], 3, ~[]);\n+        check(~[1, 1, 1], 3,\n+              ~[1 << (BigDigit::bits - 3), 1 << (BigDigit::bits - 3)]);\n+        check(~[1 << 2], 2, ~[1]);\n+        check(~[1, 2], 3, ~[1 << (BigDigit::bits - 2)]);\n+        check(~[1, 1, 2], 3 + BigDigit::bits, ~[1 << (BigDigit::bits - 2)]);\n+        check(~[0x6543_2100, 0xedcb_a987, 0x6543_210f, 0xedcb_a987, 0xf], 4,\n+              ~[0x7654_3210, 0xfedc_ba98, 0x7654_3210, 0xfedc_ba98]);\n+        check(~[0x1111_0000, 0x3333_2222, 0x5555_4444, 0x7777_6666, 0x8888],\n+              16,\n+              ~[0x2222_1111, 0x4444_3333, 0x6666_5555, 0x8888_7777]);\n+    }\n+\n+    #[test]\n+    fn test_convert_int() {\n+        fn check(v: ~[BigDigit], i: int) {\n+            let b = BigUint::new(v);\n+            assert b == Num::from_int(i);\n+            assert b.to_int() == i;\n+        }\n+\n+        check(~[], 0);\n+        check(~[1], 1);\n+        check(~[-1], (uint::max_value >> BigDigit::bits) as int);\n+        check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n+        check(~[-1, -1 >> 1], int::max_value);\n+\n+        assert BigUint::new(~[0, -1]).to_int() == int::max_value;\n+        assert BigUint::new(~[0, 0, 1]).to_int() == int::max_value;\n+        assert BigUint::new(~[0, 0, -1]).to_int() == int::max_value;\n+    }\n+\n+    #[test]\n+    fn test_convert_uint() {\n+        fn check(v: ~[BigDigit], u: uint) {\n+            let b = BigUint::new(v);\n+            assert b == BigUint::from_uint(u);\n+            assert b.to_uint() == u;\n+        }\n+\n+        check(~[], 0);\n+        check(~[ 1], 1);\n+        check(~[-1], uint::max_value >> BigDigit::bits);\n+        check(~[ 0,  1], (uint::max_value >> BigDigit::bits) + 1);\n+        check(~[ 0, -1], uint::max_value << BigDigit::bits);\n+        check(~[-1, -1], uint::max_value);\n+\n+        assert BigUint::new(~[0, 0, 1]).to_uint()  == uint::max_value;\n+        assert BigUint::new(~[0, 0, -1]).to_uint() == uint::max_value;\n+    }\n+\n+    const sum_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+        (&[],          &[],       &[]),\n+        (&[],          &[ 1],     &[ 1]),\n+        (&[ 1],        &[ 1],     &[ 2]),\n+        (&[ 1],        &[ 1,  1], &[ 2,  1]),\n+        (&[ 1],        &[-1],     &[ 0,  1]),\n+        (&[ 1],        &[-1, -1], &[ 0,  0, 1]),\n+        (&[-1, -1],    &[-1, -1], &[-2, -1, 1]),\n+        (&[ 1,  1, 1], &[-1, -1], &[ 0,  1, 2]),\n+        (&[ 2,  2, 1], &[-1, -2], &[ 1,  1, 2])\n+    ];\n+\n+    #[test]\n+    fn test_add() {\n+        for sum_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert a + b == c;\n+            assert b + a == c;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sub() {\n+        for sum_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert c - a == b;\n+            assert c - b == a;\n+        }\n+    }\n+\n+    const mul_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+        (&[],               &[],               &[]),\n+        (&[],               &[ 1],             &[]),\n+        (&[ 2],             &[],               &[]),\n+        (&[ 1],             &[ 1],             &[1]),\n+        (&[ 2],             &[ 3],             &[ 6]),\n+        (&[ 1],             &[ 1,  1,  1],     &[1, 1,  1]),\n+        (&[ 1,  2,  3],     &[ 3],             &[ 3,  6,  9]),\n+        (&[ 1,  1,  1],     &[-1],             &[-1, -1, -1]),\n+        (&[ 1,  2,  3],     &[-1],             &[-1, -2, -2, 2]),\n+        (&[ 1,  2,  3,  4], &[-1],             &[-1, -2, -2, -2, 3]),\n+        (&[-1],             &[-1],             &[ 1, -2]),\n+        (&[-1, -1],         &[-1],             &[ 1, -1, -2]),\n+        (&[-1, -1, -1],     &[-1],             &[ 1, -1, -1, -2]),\n+        (&[-1, -1, -1, -1], &[-1],             &[ 1, -1, -1, -1, -2]),\n+        (&[-1/2 + 1],       &[ 2],             &[ 0,  1]),\n+        (&[0, -1/2 + 1],    &[ 2],             &[ 0,  0,  1]),\n+        (&[ 1,  2],         &[ 1,  2,  3],     &[1, 4,  7,  6]),\n+        (&[-1, -1],         &[-1, -1, -1],     &[1, 0, -1, -2, -1]),\n+        (&[-1, -1, -1],     &[-1, -1, -1, -1], &[1, 0,  0, -1, -2, -1, -1]),\n+        (&[ 0,  0,  1],     &[ 1,  2,  3],     &[0, 0,  1,  2,  3]),\n+        (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n+    ];\n+\n+    const divmod_quadruples: &[(&[BigDigit], &[BigDigit],\n+                                &[BigDigit], &[BigDigit])]\n+        = &[\n+            (&[ 1],        &[ 2], &[],               &[1]),\n+            (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n+            (&[ 1,  1, 1], &[ 2], &[-1/2+1, -1/2+1], &[1]),\n+            (&[ 0,  1],    &[-1], &[1],              &[1]),\n+            (&[-1, -1],    &[-2], &[2, 1],           &[3])\n+        ];\n+\n+    #[test]\n+    fn test_mul() {\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            assert a * b == c;\n+            assert b * a == c;\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+            let d = BigUint::from_slice(dVec);\n+\n+            assert a == b * c + d;\n+            assert a == c * b + d;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_divmod() {\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+\n+            if a.is_not_zero() {\n+                assert c.divmod(&a) == (b, Zero::zero());\n+            }\n+            if b.is_not_zero() {\n+                assert c.divmod(&b) == (a, Zero::zero());\n+            }\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigUint::from_slice(aVec);\n+            let b = BigUint::from_slice(bVec);\n+            let c = BigUint::from_slice(cVec);\n+            let d = BigUint::from_slice(dVec);\n+\n+            if b.is_not_zero() { assert a.divmod(&b) == (c, d); }\n+        }\n+    }\n+\n+    fn to_str_pairs() -> ~[ (BigUint, ~[(uint, ~str)]) ] {\n+        ~[( Zero::zero(), ~[\n+            (2, ~\"0\"), (3, ~\"0\")\n+        ]), ( BigUint::from_slice([ 0xff ]), ~[\n+            (2,  ~\"11111111\"),\n+            (3,  ~\"100110\"),\n+            (4,  ~\"3333\"),\n+            (5,  ~\"2010\"),\n+            (6,  ~\"1103\"),\n+            (7,  ~\"513\"),\n+            (8,  ~\"377\"),\n+            (9,  ~\"313\"),\n+            (10, ~\"255\"),\n+            (11, ~\"212\"),\n+            (12, ~\"193\"),\n+            (13, ~\"168\"),\n+            (14, ~\"143\"),\n+            (15, ~\"120\"),\n+            (16, ~\"ff\")\n+        ]), ( BigUint::from_slice([ 0xfff ]), ~[\n+            (2,  ~\"111111111111\"),\n+            (4,  ~\"333333\"),\n+            (16, ~\"fff\")\n+        ]), ( BigUint::from_slice([ 1, 2 ]), ~[\n+            (2,  ~\"10\" + str::from_chars(vec::from_elem(31, '0')) + \"1\"),\n+            (4,  ~\"2\"  + str::from_chars(vec::from_elem(15, '0')) + \"1\"),\n+            (10, ~\"8589934593\"),\n+            (16, ~\"2\"  + str::from_chars(vec::from_elem(7, '0')) + \"1\")\n+        ]), (BigUint::from_slice([ 1, 2, 3 ]), ~[\n+            (2,  ~\"11\" + str::from_chars(vec::from_elem(30, '0')) + \"10\" +\n+             str::from_chars(vec::from_elem(31, '0')) + \"1\"),\n+            (4,  ~\"3\"  + str::from_chars(vec::from_elem(15, '0')) + \"2\"  +\n+             str::from_chars(vec::from_elem(15, '0')) + \"1\"),\n+            (10, ~\"55340232229718589441\"),\n+            (16, ~\"3\"  + str::from_chars(vec::from_elem(7, '0')) + \"2\"  +\n+             str::from_chars(vec::from_elem(7, '0')) + \"1\")\n+        ])]\n+    }\n+\n+    #[test]\n+    fn test_to_str_radix() {\n+        for to_str_pairs().each |num_pair| {\n+            let &(n, rs) = num_pair;\n+            for rs.each |str_pair| {\n+                let &(radix, str) = str_pair;\n+                assert n.to_str_radix(radix) == str;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_from_str_radix() {\n+        for to_str_pairs().each |num_pair| {\n+            let &(n, rs) = num_pair;\n+            for rs.each |str_pair| {\n+                let &(radix, str) = str_pair;\n+                assert Some(n) == BigUint::from_str_radix(str, radix);\n+            }\n+        }\n+\n+        assert BigUint::from_str_radix(~\"Z\", 10) == None;\n+        assert BigUint::from_str_radix(~\"_\", 2) == None;\n+        assert BigUint::from_str_radix(~\"-1\", 10) == None;\n+    }\n+\n+    #[test]\n+    fn test_factor() {\n+        fn factor(n: uint) -> BigUint {\n+            let mut f= One::one::<BigUint>();\n+            for uint::range(2, n + 1) |i| {\n+                f *= BigUint::from_uint(i);\n+            }\n+            return f;\n+        }\n+\n+        fn check(n: uint, s: &str) {\n+            let n = factor(n);\n+            let ans = match BigUint::from_str_radix(s, 10) {\n+                Some(x) => x, None => fail\n+            };\n+            assert n == ans;\n+        }\n+\n+        check(3, \"6\");\n+        check(10, \"3628800\");\n+        check(20, \"2432902008176640000\");\n+        check(30, \"265252859812191058636308480000000\");\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bigint_tests {\n+\n+    use core::*;\n+    use core::num::{Num, Zero, One};\n+    use super::{BigInt, BigUint, BigDigit};\n+\n+    #[test]\n+    fn test_from_biguint() {\n+        fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) {\n+            let inp = BigInt::from_biguint(inp_s, BigUint::from_uint(inp_n));\n+            let ans = BigInt { sign: ans_s, data: BigUint::from_uint(ans_n)};\n+            assert inp == ans;\n+        }\n+        check(Plus, 1, Plus, 1);\n+        check(Plus, 0, Zero, 0);\n+        check(Minus, 1, Minus, 1);\n+        check(Zero, 1, Zero, 0);\n+    }\n+\n+    #[test]\n+    fn test_cmp() {\n+        let vs = [ &[2], &[1, 1], &[2, 1], &[1, 1, 1] ];\n+        let mut nums = vec::reversed(vs)\n+            .map(|s| BigInt::from_slice(Minus, *s));\n+        nums.push(Zero::zero());\n+        nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n+\n+        for nums.eachi |i, ni| {\n+            for vec::view(nums, i, nums.len()).eachi |j0, nj| {\n+                let j = i + j0;\n+                if i == j {\n+                    assert ni.cmp(nj) == 0;\n+                    assert nj.cmp(ni) == 0;\n+                    assert ni == nj;\n+                    assert !(ni != nj);\n+                    assert ni <= nj;\n+                    assert ni >= nj;\n+                    assert !(ni < nj);\n+                    assert !(ni > nj);\n+                } else {\n+                    assert ni.cmp(nj) < 0;\n+                    assert nj.cmp(ni) > 0;\n+\n+                    assert !(ni == nj);\n+                    assert ni != nj;\n+\n+                    assert ni <= nj;\n+                    assert !(ni >= nj);\n+                    assert ni < nj;\n+                    assert !(ni > nj);\n+\n+                    assert !(nj <= ni);\n+                    assert nj >= ni;\n+                    assert !(nj < ni);\n+                    assert nj > ni;\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_convert_int() {\n+        fn check(b: BigInt, i: int) {\n+            assert b == Num::from_int(i);\n+            assert b.to_int() == i;\n+        }\n+\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(BigInt::from_biguint(\n+            Plus, BigUint::from_uint(int::max_value as uint)\n+        ), int::max_value);\n+\n+        assert BigInt::from_biguint(\n+            Plus, BigUint::from_uint(int::max_value as uint + 1)\n+        ).to_int() == int::max_value;\n+        assert BigInt::from_biguint(\n+            Plus, BigUint::new(~[1, 2, 3])\n+        ).to_int() == int::max_value;\n+\n+        check(BigInt::from_biguint(\n+            Minus, BigUint::from_uint(-int::min_value as uint)\n+        ), int::min_value);\n+        assert BigInt::from_biguint(\n+            Minus, BigUint::from_uint(-int::min_value as uint + 1)\n+        ).to_int() == int::min_value;\n+        assert BigInt::from_biguint(\n+            Minus, BigUint::new(~[1, 2, 3])\n+        ).to_int() == int::min_value;\n+    }\n+\n+    #[test]\n+    fn test_convert_uint() {\n+        fn check(b: BigInt, u: uint) {\n+            assert b == BigInt::from_uint(u);\n+            assert b.to_uint() == u;\n+        }\n+\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+\n+        check(\n+            BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n+            uint::max_value);\n+        assert BigInt::from_biguint(\n+            Plus, BigUint::new(~[1, 2, 3])\n+        ).to_uint() == uint::max_value;\n+\n+        assert BigInt::from_biguint(\n+            Minus, BigUint::from_uint(uint::max_value)\n+        ).to_uint() == 0;\n+        assert BigInt::from_biguint(\n+            Minus, BigUint::new(~[1, 2, 3])\n+        ).to_uint() == 0;\n+    }\n+\n+    const sum_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+        (&[],          &[],       &[]),\n+        (&[],          &[ 1],     &[ 1]),\n+        (&[ 1],        &[ 1],     &[ 2]),\n+        (&[ 1],        &[ 1,  1], &[ 2,  1]),\n+        (&[ 1],        &[-1],     &[ 0,  1]),\n+        (&[ 1],        &[-1, -1], &[ 0,  0, 1]),\n+        (&[-1, -1],    &[-1, -1], &[-2, -1, 1]),\n+        (&[ 1,  1, 1], &[-1, -1], &[ 0,  1, 2]),\n+        (&[ 2,  2, 1], &[-1, -2], &[ 1,  1, 2])\n+    ];\n+\n+    #[test]\n+    fn test_add() {\n+        for sum_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            assert a + b == c;\n+            assert b + a == c;\n+            assert c + (-a) == b;\n+            assert c + (-b) == a;\n+            assert a + (-c) == (-b);\n+            assert b + (-c) == (-a);\n+            assert (-a) + (-b) == (-c);\n+            assert a + (-a) == Zero::zero();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sub() {\n+        for sum_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            assert c - a == b;\n+            assert c - b == a;\n+            assert (-b) - a == (-c);\n+            assert (-a) - b == (-c);\n+            assert b - (-a) == c;\n+            assert a - (-b) == c;\n+            assert (-c) - (-a) == (-b);\n+            assert a - a == Zero::zero();\n+        }\n+    }\n+\n+    const mul_triples: &[(&[BigDigit], &[BigDigit], &[BigDigit])] = &[\n+        (&[],               &[],               &[]),\n+        (&[],               &[ 1],             &[]),\n+        (&[ 2],             &[],               &[]),\n+        (&[ 1],             &[ 1],             &[1]),\n+        (&[ 2],             &[ 3],             &[ 6]),\n+        (&[ 1],             &[ 1,  1,  1],     &[1, 1,  1]),\n+        (&[ 1,  2,  3],     &[ 3],             &[ 3,  6,  9]),\n+        (&[ 1,  1,  1],     &[-1],             &[-1, -1, -1]),\n+        (&[ 1,  2,  3],     &[-1],             &[-1, -2, -2, 2]),\n+        (&[ 1,  2,  3,  4], &[-1],             &[-1, -2, -2, -2, 3]),\n+        (&[-1],             &[-1],             &[ 1, -2]),\n+        (&[-1, -1],         &[-1],             &[ 1, -1, -2]),\n+        (&[-1, -1, -1],     &[-1],             &[ 1, -1, -1, -2]),\n+        (&[-1, -1, -1, -1], &[-1],             &[ 1, -1, -1, -1, -2]),\n+        (&[-1/2 + 1],       &[ 2],             &[ 0,  1]),\n+        (&[0, -1/2 + 1],    &[ 2],             &[ 0,  0,  1]),\n+        (&[ 1,  2],         &[ 1,  2,  3],     &[1, 4,  7,  6]),\n+        (&[-1, -1],         &[-1, -1, -1],     &[1, 0, -1, -2, -1]),\n+        (&[-1, -1, -1],     &[-1, -1, -1, -1], &[1, 0,  0, -1, -2, -1, -1]),\n+        (&[ 0,  0,  1],     &[ 1,  2,  3],     &[0, 0,  1,  2,  3]),\n+        (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n+    ];\n+\n+    const divmod_quadruples: &[(&[BigDigit], &[BigDigit],\n+                                &[BigDigit], &[BigDigit])]\n+        = &[\n+            (&[ 1],        &[ 2], &[],               &[1]),\n+            (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n+            (&[ 1,  1, 1], &[ 2], &[-1/2+1, -1/2+1], &[1]),\n+            (&[ 0,  1],    &[-1], &[1],              &[1]),\n+            (&[-1, -1],    &[-2], &[2, 1],           &[3])\n+        ];\n+\n+    #[test]\n+    fn test_mul() {\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            assert a * b == c;\n+            assert b * a == c;\n+\n+            assert (-a) * b == -c;\n+            assert (-b) * a == -c;\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+            let d = BigInt::from_slice(Plus, dVec);\n+\n+            assert a == b * c + d;\n+            assert a == c * b + d;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_divmod() {\n+        fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n+            let (d, m) = a.divmod(b);\n+            if m.is_not_zero() {\n+                assert m.sign == b.sign;\n+            }\n+            assert m.abs() <= b.abs();\n+            assert *a == b * d + m;\n+            assert d == *ans_d;\n+            assert m == *ans_m;\n+        }\n+\n+        fn check(a: &BigInt, b: &BigInt, d: &BigInt, m: &BigInt) {\n+            if m.is_zero() {\n+                check_sub(a, b, d, m);\n+                check_sub(a, &b.neg(), &d.neg(), m);\n+                check_sub(&a.neg(), b, &d.neg(), m);\n+                check_sub(&a.neg(), &b.neg(), d, m);\n+            } else {\n+                check_sub(a, b, d, m);\n+                check_sub(a, &b.neg(), &(d.neg() - One::one()), &(m - *b));\n+                check_sub(&a.neg(), b, &(d.neg() - One::one()), &(b - *m));\n+                check_sub(&a.neg(), &b.neg(), d, &m.neg());\n+            }\n+        }\n+\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            if a.is_not_zero() { check(&c, &a, &b, &Zero::zero()); }\n+            if b.is_not_zero() { check(&c, &b, &a, &Zero::zero()); }\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+            let d = BigInt::from_slice(Plus, dVec);\n+\n+            if b.is_not_zero() {\n+                check(&a, &b, &c, &d);\n+            }\n+        }\n+    }\n+\n+\n+    #[test]\n+    fn test_quotrem() {\n+        fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n+            let (q, r) = a.quotrem(b);\n+            if r.is_not_zero() {\n+                assert r.sign == a.sign;\n+            }\n+            assert r.abs() <= b.abs();\n+            assert *a == b * q + r;\n+            assert q == *ans_q;\n+            assert r == *ans_r;\n+        }\n+\n+        fn check(a: &BigInt, b: &BigInt, q: &BigInt, r: &BigInt) {\n+            check_sub(a, b, q, r);\n+            check_sub(a, &b.neg(), &q.neg(), r);\n+            check_sub(&a.neg(), b, &q.neg(), &r.neg());\n+            check_sub(&a.neg(), &b.neg(), q, &r.neg());\n+        }\n+        for mul_triples.each |elm| {\n+            let (aVec, bVec, cVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+\n+            if a.is_not_zero() { check(&c, &a, &b, &Zero::zero()); }\n+            if b.is_not_zero() { check(&c, &b, &a, &Zero::zero()); }\n+        }\n+\n+        for divmod_quadruples.each |elm| {\n+            let (aVec, bVec, cVec, dVec) = *elm;\n+            let a = BigInt::from_slice(Plus, aVec);\n+            let b = BigInt::from_slice(Plus, bVec);\n+            let c = BigInt::from_slice(Plus, cVec);\n+            let d = BigInt::from_slice(Plus, dVec);\n+\n+            if b.is_not_zero() {\n+                check(&a, &b, &c, &d);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_to_str_radix() {\n+        fn check(n: int, ans: &str) {\n+            assert ans == Num::from_int::<BigInt>(n).to_str_radix(10);\n+        }\n+        check(10, \"10\");\n+        check(1, \"1\");\n+        check(0, \"0\");\n+        check(-1, \"-1\");\n+        check(-10, \"-10\");\n+    }\n+\n+\n+    #[test]\n+    fn test_from_str_radix() {\n+        fn check(s: &str, ans: Option<int>) {\n+            let ans = ans.map(|&n| Num::from_int(n));\n+            assert BigInt::from_str_radix(s, 10) == ans;\n+        }\n+        check(\"10\", Some(10));\n+        check(\"1\", Some(1));\n+        check(\"0\", Some(0));\n+        check(\"-1\", Some(-1));\n+        check(\"-10\", Some(-10));\n+        check(\"Z\", None);\n+        check(\"_\", None);\n+    }\n+\n+    #[test]\n+    fn test_neg() {\n+        assert -BigInt::new(Plus,  ~[1, 1, 1]) ==\n+            BigInt::new(Minus, ~[1, 1, 1]);\n+        assert -BigInt::new(Minus, ~[1, 1, 1]) ==\n+            BigInt::new(Plus,  ~[1, 1, 1]);\n+        assert -Zero::zero::<BigInt>() == Zero::zero::<BigInt>();\n+    }\n+}\n+"}, {"sha": "22cb91535717e6d64bc3ff681b9ec4787ed394fe", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d9b1fee8f623b2d6724084b8506f3309f380d24/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2d9b1fee8f623b2d6724084b8506f3309f380d24/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=2d9b1fee8f623b2d6724084b8506f3309f380d24", "patch": "@@ -98,6 +98,7 @@ pub mod cmp;\n pub mod base64;\n pub mod rl;\n pub mod workcache;\n+pub mod bigint;\n \n #[cfg(unicode)]\n mod unicode;"}]}