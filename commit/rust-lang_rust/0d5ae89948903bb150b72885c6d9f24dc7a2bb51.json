{"sha": "0d5ae89948903bb150b72885c6d9f24dc7a2bb51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNWFlODk5NDg5MDNiYjE1MGI3Mjg4NWM2ZDlmMjRkYzdhMmJiNTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-19T13:45:49Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-02-19T13:45:49Z"}, "message": "Derive visibility as well", "tree": {"sha": "b29624b73e3c242eda24495eb205eb5f828c7690", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b29624b73e3c242eda24495eb205eb5f828c7690"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d5ae89948903bb150b72885c6d9f24dc7a2bb51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d5ae89948903bb150b72885c6d9f24dc7a2bb51", "html_url": "https://github.com/rust-lang/rust/commit/0d5ae89948903bb150b72885c6d9f24dc7a2bb51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d5ae89948903bb150b72885c6d9f24dc7a2bb51/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86b66067f6321382cd72ec29c49d166da46fc3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/86b66067f6321382cd72ec29c49d166da46fc3f8", "html_url": "https://github.com/rust-lang/rust/commit/86b66067f6321382cd72ec29c49d166da46fc3f8"}], "stats": {"total": 108, "additions": 55, "deletions": 53}, "files": [{"sha": "ca5750521c2f3b8f17afea79cfcd63921250296a", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d5ae89948903bb150b72885c6d9f24dc7a2bb51/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5ae89948903bb150b72885c6d9f24dc7a2bb51/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=0d5ae89948903bb150b72885c6d9f24dc7a2bb51", "patch": "@@ -22,65 +22,62 @@ pub(crate) fn classify_name_ref(\n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_methods);\n         if let Some(func) = analyzer.resolve_method_call(&method_call) {\n-            return Some(from_module_def(sb.db, func.into()));\n+            return Some(from_module_def(func.into()));\n         }\n     }\n \n     if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_fields);\n         if let Some(field) = analyzer.resolve_field(&field_expr) {\n-            return Some(from_struct_field(sb.db, field));\n+            return Some(from_struct_field(field));\n         }\n     }\n \n     if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n         tested_by!(goto_def_for_record_fields);\n         tested_by!(goto_def_for_field_init_shorthand);\n         if let Some(field_def) = analyzer.resolve_record_field(&record_field) {\n-            return Some(from_struct_field(sb.db, field_def));\n+            return Some(from_struct_field(field_def));\n         }\n     }\n \n-    // FIXME: find correct container and visibility for each case\n-    let visibility = None;\n-\n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n         tested_by!(goto_def_for_macros);\n         if let Some(macro_def) =\n             analyzer.resolve_macro_call(sb.db, name_ref.with_value(&macro_call))\n         {\n             let kind = NameKind::Macro(macro_def);\n-            return Some(NameDefinition { kind, visibility });\n+            return Some(NameDefinition { kind });\n         }\n     }\n \n     let path = name_ref.value.syntax().ancestors().find_map(ast::Path::cast)?;\n     let resolved = analyzer.resolve_path(sb.db, &path)?;\n     let res = match resolved {\n-        PathResolution::Def(def) => from_module_def(sb.db, def),\n+        PathResolution::Def(def) => from_module_def(def),\n         PathResolution::AssocItem(item) => {\n             let def = match item {\n                 hir::AssocItem::Function(it) => it.into(),\n                 hir::AssocItem::Const(it) => it.into(),\n                 hir::AssocItem::TypeAlias(it) => it.into(),\n             };\n-            from_module_def(sb.db, def)\n+            from_module_def(def)\n         }\n         PathResolution::Local(local) => {\n             let kind = NameKind::Local(local);\n-            NameDefinition { kind, visibility: None }\n+            NameDefinition { kind }\n         }\n         PathResolution::TypeParam(par) => {\n             let kind = NameKind::TypeParam(par);\n-            NameDefinition { kind, visibility }\n+            NameDefinition { kind }\n         }\n         PathResolution::Macro(def) => {\n             let kind = NameKind::Macro(def);\n-            NameDefinition { kind, visibility }\n+            NameDefinition { kind }\n         }\n         PathResolution::SelfType(impl_block) => {\n             let kind = NameKind::SelfType(impl_block);\n-            NameDefinition { kind, visibility }\n+            NameDefinition { kind }\n         }\n     };\n     Some(res)"}, {"sha": "e5ac12044affc78f9ef4927680c2a824ea2e6f1b", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d5ae89948903bb150b72885c6d9f24dc7a2bb51/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5ae89948903bb150b72885c6d9f24dc7a2bb51/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=0d5ae89948903bb150b72885c6d9f24dc7a2bb51", "patch": "@@ -43,7 +43,7 @@ impl SearchScope {\n             return SearchScope::new(res);\n         }\n \n-        let vis = def.visibility.as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n+        let vis = def.visibility(db).as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n \n         if vis.as_str() == \"pub(super)\" {\n             if let Some(parent_module) = module.parent(db) {"}, {"sha": "aec748abf54813f84afe2daf853d0f402f16f257", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0d5ae89948903bb150b72885c6d9f24dc7a2bb51/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d5ae89948903bb150b72885c6d9f24dc7a2bb51/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=0d5ae89948903bb150b72885c6d9f24dc7a2bb51", "patch": "@@ -6,8 +6,8 @@\n // FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n \n use hir::{\n-    Adt, HasSource, ImplBlock, InFile, Local, MacroDef, Module, ModuleDef, SourceBinder,\n-    StructField, TypeParam, VariantDef,\n+    Adt, FieldSource, HasSource, ImplBlock, InFile, Local, MacroDef, Module, ModuleDef,\n+    SourceBinder, StructField, TypeParam,\n };\n use ra_prof::profile;\n use ra_syntax::{\n@@ -29,7 +29,6 @@ pub enum NameKind {\n \n #[derive(PartialEq, Eq)]\n pub struct NameDefinition {\n-    pub visibility: Option<ast::Visibility>,\n     /// FIXME: this doesn't really make sense. For example, builtin types don't\n     /// really have a module.\n     pub kind: NameKind,\n@@ -46,6 +45,34 @@ impl NameDefinition {\n             NameKind::TypeParam(it) => Some(it.module(db)),\n         }\n     }\n+\n+    pub fn visibility(&self, db: &RootDatabase) -> Option<ast::Visibility> {\n+        match self.kind {\n+            NameKind::Macro(_) => None,\n+            NameKind::StructField(sf) => match sf.source(db).value {\n+                FieldSource::Named(it) => it.visibility(),\n+                FieldSource::Pos(it) => it.visibility(),\n+            },\n+            NameKind::ModuleDef(def) => match def {\n+                ModuleDef::Module(it) => it.declaration_source(db)?.value.visibility(),\n+                ModuleDef::Function(it) => it.source(db).value.visibility(),\n+                ModuleDef::Adt(adt) => match adt {\n+                    Adt::Struct(it) => it.source(db).value.visibility(),\n+                    Adt::Union(it) => it.source(db).value.visibility(),\n+                    Adt::Enum(it) => it.source(db).value.visibility(),\n+                },\n+                ModuleDef::Const(it) => it.source(db).value.visibility(),\n+                ModuleDef::Static(it) => it.source(db).value.visibility(),\n+                ModuleDef::Trait(it) => it.source(db).value.visibility(),\n+                ModuleDef::TypeAlias(it) => it.source(db).value.visibility(),\n+                ModuleDef::EnumVariant(_) => None,\n+                ModuleDef::BuiltinType(_) => None,\n+            },\n+            NameKind::SelfType(_) => None,\n+            NameKind::Local(_) => None,\n+            NameKind::TypeParam(_) => None,\n+        }\n+    }\n }\n \n pub fn classify_name(\n@@ -61,73 +88,70 @@ pub fn classify_name(\n                 let src = name.with_value(it);\n                 let local = sb.to_def(src)?;\n                 Some(NameDefinition {\n-                    visibility: None,\n                     kind: NameKind::Local(local),\n                 })\n             },\n             ast::RecordFieldDef(it) => {\n                 let src = name.with_value(it);\n                 let field: hir::StructField = sb.to_def(src)?;\n-                Some(from_struct_field(sb.db, field))\n+                Some(from_struct_field(field))\n             },\n             ast::Module(it) => {\n                 let def = sb.to_def(name.with_value(it))?;\n-                Some(from_module_def(sb.db, def.into()))\n+                Some(from_module_def(def.into()))\n             },\n             ast::StructDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Struct = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into()))\n+                Some(from_module_def(def.into()))\n             },\n             ast::EnumDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Enum = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into()))\n+                Some(from_module_def(def.into()))\n             },\n             ast::TraitDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Trait = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into()))\n+                Some(from_module_def(def.into()))\n             },\n             ast::StaticDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Static = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into()))\n+                Some(from_module_def(def.into()))\n             },\n             ast::EnumVariant(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::EnumVariant = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into()))\n+                Some(from_module_def(def.into()))\n             },\n             ast::FnDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Function = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into()))\n+                Some(from_module_def(def.into()))\n             },\n             ast::ConstDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Const = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into()))\n+                Some(from_module_def(def.into()))\n             },\n             ast::TypeAliasDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::TypeAlias = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into()))\n+                Some(from_module_def(def.into()))\n             },\n             ast::MacroCall(it) => {\n                 let src = name.with_value(it);\n                 let def = sb.to_def(src.clone())?;\n \n                 Some(NameDefinition {\n-                    visibility: None,\n                     kind: NameKind::Macro(def),\n                 })\n             },\n             ast::TypeParam(it) => {\n                 let src = name.with_value(it);\n                 let def = sb.to_def(src)?;\n                 Some(NameDefinition {\n-                    visibility: None,\n                     kind: NameKind::TypeParam(def),\n                 })\n             },\n@@ -136,31 +160,12 @@ pub fn classify_name(\n     }\n }\n \n-pub fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDefinition {\n+pub fn from_struct_field(field: StructField) -> NameDefinition {\n     let kind = NameKind::StructField(field);\n-    let parent = field.parent_def(db);\n-    let visibility = match parent {\n-        VariantDef::Struct(s) => s.source(db).value.visibility(),\n-        VariantDef::Union(e) => e.source(db).value.visibility(),\n-        VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n-    };\n-    NameDefinition { kind, visibility }\n+    NameDefinition { kind }\n }\n \n-pub fn from_module_def(db: &RootDatabase, def: ModuleDef) -> NameDefinition {\n+pub fn from_module_def(def: ModuleDef) -> NameDefinition {\n     let kind = NameKind::ModuleDef(def);\n-    let visibility = match def {\n-        ModuleDef::Module(it) => it.declaration_source(db).and_then(|s| s.value.visibility()),\n-        ModuleDef::EnumVariant(it) => it.source(db).value.parent_enum().visibility(),\n-        ModuleDef::Function(it) => it.source(db).value.visibility(),\n-        ModuleDef::Const(it) => it.source(db).value.visibility(),\n-        ModuleDef::Static(it) => it.source(db).value.visibility(),\n-        ModuleDef::Trait(it) => it.source(db).value.visibility(),\n-        ModuleDef::TypeAlias(it) => it.source(db).value.visibility(),\n-        ModuleDef::Adt(Adt::Struct(it)) => it.source(db).value.visibility(),\n-        ModuleDef::Adt(Adt::Union(it)) => it.source(db).value.visibility(),\n-        ModuleDef::Adt(Adt::Enum(it)) => it.source(db).value.visibility(),\n-        ModuleDef::BuiltinType(..) => None,\n-    };\n-    NameDefinition { kind, visibility }\n+    NameDefinition { kind }\n }"}]}