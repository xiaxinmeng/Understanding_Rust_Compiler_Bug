{"sha": "f313ac45af0b9c81cf411a8a4a6873e742bb8562", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMTNhYzQ1YWYwYjljODFjZjQxMWE4YTRhNjg3M2U3NDJiYjg1NjI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-21T19:13:52Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-21T19:13:52Z"}, "message": "use structured editing API for fill struct assist", "tree": {"sha": "61f3e898b7e86c64b113e690ee55a94882c25911", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61f3e898b7e86c64b113e690ee55a94882c25911"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f313ac45af0b9c81cf411a8a4a6873e742bb8562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f313ac45af0b9c81cf411a8a4a6873e742bb8562", "html_url": "https://github.com/rust-lang/rust/commit/f313ac45af0b9c81cf411a8a4a6873e742bb8562", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f313ac45af0b9c81cf411a8a4a6873e742bb8562/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cc845e88d870173e1baa39ce4d3885a5b1f7043", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cc845e88d870173e1baa39ce4d3885a5b1f7043", "html_url": "https://github.com/rust-lang/rust/commit/7cc845e88d870173e1baa39ce4d3885a5b1f7043"}], "stats": {"total": 257, "additions": 138, "deletions": 119}, "files": [{"sha": "f46de61eb6a3c2308ad24f8752feb08b87900721", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f313ac45af0b9c81cf411a8a4a6873e742bb8562/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f313ac45af0b9c81cf411a8a4a6873e742bb8562/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=f313ac45af0b9c81cf411a8a4a6873e742bb8562", "patch": "@@ -161,6 +161,10 @@ impl AssistBuilder {\n         self.target = Some(target)\n     }\n \n+    pub(crate) fn text_edit_builder(&mut self) -> &mut TextEditBuilder {\n+        &mut self.edit\n+    }\n+\n     fn build(self) -> AssistAction {\n         AssistAction {\n             edit: self.edit.finish(),"}, {"sha": "5bf1fc0ed53b61300fa2f2d35a86dd21cb8680c9", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 98, "deletions": 42, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/f313ac45af0b9c81cf411a8a4a6873e742bb8562/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f313ac45af0b9c81cf411a8a4a6873e742bb8562/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=f313ac45af0b9c81cf411a8a4a6873e742bb8562", "patch": "@@ -1,6 +1,9 @@\n+use std::iter;\n+\n use arrayvec::ArrayVec;\n-use ra_text_edit::{TextEdit, TextEditBuilder};\n+use ra_text_edit::TextEditBuilder;\n use ra_syntax::{AstNode, TreeArc, ast, SyntaxKind::*, SyntaxElement, SourceFile, InsertPosition, Direction};\n+use ra_fmt::leading_indent;\n \n pub struct AstEditor<N: AstNode> {\n     original_ast: TreeArc<N>,\n@@ -12,82 +15,114 @@ impl<N: AstNode> AstEditor<N> {\n         AstEditor { original_ast: node.to_owned(), ast: node.to_owned() }\n     }\n \n-    pub fn into_text_edit(self) -> TextEdit {\n+    pub fn into_text_edit(self, builder: &mut TextEditBuilder) {\n         // FIXME: compute a more fine-grained diff here.\n         // If *you* know a nice algorithm to compute diff between two syntax\n         // tree, tell me about it!\n-        let mut builder = TextEditBuilder::default();\n         builder.replace(self.original_ast.syntax().range(), self.ast().syntax().text().to_string());\n-        builder.finish()\n     }\n \n     pub fn ast(&self) -> &N {\n         &*self.ast\n     }\n+\n+    fn insert_children<'a>(\n+        &self,\n+        position: InsertPosition<SyntaxElement<'_>>,\n+        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n+    ) -> TreeArc<N> {\n+        let new_syntax = self.ast().syntax().insert_children(position, to_insert);\n+        N::cast(&new_syntax).unwrap().to_owned()\n+    }\n }\n \n impl AstEditor<ast::NamedFieldList> {\n     pub fn append_field(&mut self, field: &ast::NamedField) {\n         self.insert_field(InsertPosition::Last, field)\n     }\n \n+    pub fn make_multiline(&mut self) {\n+        let l_curly = match self.l_curly() {\n+            Some(it) => it,\n+            None => return,\n+        };\n+        let sibling = match l_curly.next_sibling_or_token() {\n+            Some(it) => it,\n+            None => return,\n+        };\n+        if sibling.as_token().map(|it| it.text().contains('\\n')) == Some(true) {\n+            return;\n+        }\n+\n+        let ws = tokens::WsBuilder::new(&format!(\n+            \"\\n{}\",\n+            leading_indent(self.ast().syntax()).unwrap_or(\"\")\n+        ));\n+        self.ast = self.insert_children(InsertPosition::After(l_curly), iter::once(ws.ws().into()));\n+    }\n+\n     pub fn insert_field(\n         &mut self,\n         position: InsertPosition<&'_ ast::NamedField>,\n         field: &ast::NamedField,\n     ) {\n-        let mut to_insert: ArrayVec<[SyntaxElement; 2]> =\n-            [field.syntax().into(), tokens::comma().into()].into();\n-        let position = match position {\n-            InsertPosition::First => {\n-                let anchor = match self\n-                    .ast()\n-                    .syntax()\n-                    .children_with_tokens()\n-                    .find(|it| it.kind() == L_CURLY)\n-                {\n+        let is_multiline = self.ast().syntax().text().contains('\\n');\n+        let ws;\n+        let space = if is_multiline {\n+            ws = tokens::WsBuilder::new(&format!(\n+                \"\\n{}    \",\n+                leading_indent(self.ast().syntax()).unwrap_or(\"\")\n+            ));\n+            ws.ws()\n+        } else {\n+            tokens::single_space()\n+        };\n+\n+        let mut to_insert: ArrayVec<[SyntaxElement; 4]> = ArrayVec::new();\n+        to_insert.push(space.into());\n+        to_insert.push(field.syntax().into());\n+        to_insert.push(tokens::comma().into());\n+\n+        macro_rules! after_l_curly {\n+            () => {{\n+                let anchor = match self.l_curly() {\n                     Some(it) => it,\n                     None => return,\n                 };\n                 InsertPosition::After(anchor)\n-            }\n-            InsertPosition::Last => {\n-                let anchor = match self\n-                    .ast()\n-                    .syntax()\n-                    .children_with_tokens()\n-                    .find(|it| it.kind() == R_CURLY)\n-                {\n-                    Some(it) => it,\n-                    None => return,\n-                };\n-                InsertPosition::Before(anchor)\n-            }\n-            InsertPosition::Before(anchor) => InsertPosition::Before(anchor.syntax().into()),\n-            InsertPosition::After(anchor) => {\n-                if let Some(comma) = anchor\n+            }};\n+        }\n+\n+        macro_rules! after_field {\n+            ($anchor:expr) => {\n+                if let Some(comma) = $anchor\n                     .syntax()\n                     .siblings_with_tokens(Direction::Next)\n                     .find(|it| it.kind() == COMMA)\n                 {\n                     InsertPosition::After(comma)\n                 } else {\n                     to_insert.insert(0, tokens::comma().into());\n-                    InsertPosition::After(anchor.syntax().into())\n+                    InsertPosition::After($anchor.syntax().into())\n                 }\n-            }\n+            };\n+        };\n+\n+        let position = match position {\n+            InsertPosition::First => after_l_curly!(),\n+            InsertPosition::Last => match self.ast().fields().last() {\n+                Some(it) => after_field!(it),\n+                None => after_l_curly!(),\n+            },\n+            InsertPosition::Before(anchor) => InsertPosition::Before(anchor.syntax().into()),\n+            InsertPosition::After(anchor) => after_field!(anchor),\n         };\n-        self.ast = insert_children_into_ast(self.ast(), position, to_insert.iter().cloned());\n+        self.ast = self.insert_children(position, to_insert.iter().cloned());\n     }\n-}\n \n-fn insert_children_into_ast<'a, N: AstNode>(\n-    node: &N,\n-    position: InsertPosition<SyntaxElement<'_>>,\n-    to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n-) -> TreeArc<N> {\n-    let new_syntax = node.syntax().insert_children(position, to_insert);\n-    N::cast(&new_syntax).unwrap().to_owned()\n+    fn l_curly(&self) -> Option<SyntaxElement> {\n+        self.ast().syntax().children_with_tokens().find(|it| it.kind() == L_CURLY)\n+    }\n }\n \n pub struct AstBuilder<N: AstNode> {\n@@ -111,7 +146,7 @@ mod tokens {\n     use ra_syntax::{AstNode, SourceFile, TreeArc, SyntaxToken, SyntaxKind::*};\n \n     lazy_static! {\n-        static ref SOURCE_FILE: TreeArc<SourceFile> = SourceFile::parse(\",\");\n+        static ref SOURCE_FILE: TreeArc<SourceFile> = SourceFile::parse(\",\\n; ;\");\n     }\n \n     pub(crate) fn comma() -> SyntaxToken<'static> {\n@@ -122,6 +157,27 @@ mod tokens {\n             .find(|it| it.kind() == COMMA)\n             .unwrap()\n     }\n+\n+    pub(crate) fn single_space() -> SyntaxToken<'static> {\n+        SOURCE_FILE\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.as_token())\n+            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \" \")\n+            .unwrap()\n+    }\n+\n+    pub(crate) struct WsBuilder(TreeArc<SourceFile>);\n+\n+    impl WsBuilder {\n+        pub(crate) fn new(text: &str) -> WsBuilder {\n+            WsBuilder(SourceFile::parse(text))\n+        }\n+        pub(crate) fn ws(&self) -> SyntaxToken<'_> {\n+            self.0.syntax().first_child_or_token().unwrap().as_token().unwrap()\n+        }\n+    }\n+\n }\n \n #[cfg(test)]"}, {"sha": "ca128168a45afa71a1e9172a5fccaad8329750ab", "filename": "crates/ra_assists/src/fill_struct_fields.rs", "status": "modified", "additions": 36, "deletions": 77, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f313ac45af0b9c81cf411a8a4a6873e742bb8562/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f313ac45af0b9c81cf411a8a4a6873e742bb8562/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs?ref=f313ac45af0b9c81cf411a8a4a6873e742bb8562", "patch": "@@ -1,94 +1,53 @@\n-use std::fmt::Write;\n-\n use hir::{AdtDef, db::HirDatabase};\n \n use ra_syntax::ast::{self, AstNode};\n \n-use crate::{AssistCtx, Assist, AssistId};\n+use crate::{AssistCtx, Assist, AssistId, ast_editor::{AstEditor, AstBuilder}};\n \n pub(crate) fn fill_struct_fields(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let struct_lit = ctx.node_at_offset::<ast::StructLit>()?;\n-    let mut fsf = FillStructFields {\n-        ctx: &mut ctx,\n-        named_field_list: struct_lit.named_field_list()?,\n-        struct_fields: vec![],\n-        struct_lit,\n-    };\n-    fsf.evaluate_struct_def_fields()?;\n-    if fsf.struct_lit_and_def_have_the_same_number_of_fields() {\n-        return None;\n-    }\n-    fsf.remove_already_included_fields()?;\n-    fsf.add_action()?;\n-    ctx.build()\n-}\n-\n-struct FillStructFields<'a, 'b: 'a, DB> {\n-    ctx: &'a mut AssistCtx<'b, DB>,\n-    named_field_list: &'a ast::NamedFieldList,\n-    struct_fields: Vec<(String, String)>,\n-    struct_lit: &'a ast::StructLit,\n-}\n+    let named_field_list = struct_lit.named_field_list()?;\n \n-impl<DB> FillStructFields<'_, '_, DB>\n-where\n-    DB: HirDatabase,\n-{\n-    fn add_action(&mut self) -> Option<()> {\n-        let named_field_list = self.named_field_list;\n-        let struct_fields_string = self.struct_fields_string()?;\n-        let struct_lit = self.struct_lit;\n-        self.ctx.add_action(AssistId(\"fill_struct_fields\"), \"fill struct fields\", |edit| {\n-            edit.target(struct_lit.syntax().range());\n-            edit.set_cursor(struct_lit.syntax().range().start());\n-            edit.replace_node_and_indent(named_field_list.syntax(), struct_fields_string);\n-        });\n-        Some(())\n-    }\n-\n-    fn struct_lit_and_def_have_the_same_number_of_fields(&self) -> bool {\n-        self.named_field_list.fields().count() == self.struct_fields.len()\n-    }\n-\n-    fn evaluate_struct_def_fields(&mut self) -> Option<()> {\n-        let analyzer = hir::SourceAnalyzer::new(\n-            self.ctx.db,\n-            self.ctx.frange.file_id,\n-            self.struct_lit.syntax(),\n-            None,\n-        );\n-        let struct_lit_ty = analyzer.type_of(self.ctx.db, self.struct_lit.into())?;\n+    // Collect all fields from struct definition\n+    let mut fields = {\n+        let analyzer =\n+            hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, struct_lit.syntax(), None);\n+        let struct_lit_ty = analyzer.type_of(ctx.db, struct_lit.into())?;\n         let struct_def = match struct_lit_ty.as_adt() {\n             Some((AdtDef::Struct(s), _)) => s,\n             _ => return None,\n         };\n-        self.struct_fields = struct_def\n-            .fields(self.ctx.db)\n-            .into_iter()\n-            .map(|f| (f.name(self.ctx.db).to_string(), \"()\".into()))\n-            .collect();\n-        Some(())\n-    }\n+        struct_def.fields(ctx.db)\n+    };\n \n-    fn remove_already_included_fields(&mut self) -> Option<()> {\n-        for ast_field in self.named_field_list.fields() {\n-            let expr = ast_field.expr()?.syntax().text().to_string();\n-            let name_from_ast = ast_field.name_ref()?.text().to_string();\n-            if let Some(idx) = self.struct_fields.iter().position(|(n, _)| n == &name_from_ast) {\n-                self.struct_fields[idx] = (name_from_ast, expr);\n-            }\n-        }\n-        Some(())\n+    // Filter out existing fields\n+    for ast_field in named_field_list.fields() {\n+        let name_from_ast = ast_field.name_ref()?.text().to_string();\n+        fields.retain(|field| field.name(ctx.db).to_string() != name_from_ast);\n+    }\n+    if fields.is_empty() {\n+        return None;\n     }\n \n-    fn struct_fields_string(&mut self) -> Option<String> {\n-        let mut buf = String::from(\"{\\n\");\n-        for (name, expr) in &self.struct_fields {\n-            write!(&mut buf, \"    {}: {},\\n\", name, expr).unwrap();\n+    let db = ctx.db;\n+    ctx.add_action(AssistId(\"fill_struct_fields\"), \"fill struct fields\", |edit| {\n+        let mut ast_editor = AstEditor::new(named_field_list);\n+        if named_field_list.fields().count() == 0 && fields.len() > 2 {\n+            ast_editor.make_multiline();\n+        };\n+\n+        for field in fields {\n+            let field =\n+                AstBuilder::<ast::NamedField>::from_text(&format!(\"{}: ()\", field.name(db)));\n+            ast_editor.append_field(&field);\n         }\n-        buf.push_str(\"}\");\n-        Some(buf)\n-    }\n+\n+        edit.target(struct_lit.syntax().range());\n+        edit.set_cursor(struct_lit.syntax().range().start());\n+\n+        ast_editor.into_text_edit(edit.text_edit_builder());\n+    });\n+    ctx.build()\n }\n \n #[cfg(test)]\n@@ -225,11 +184,11 @@ mod tests {\n \n             fn main() {\n                 let s = <|>S {\n+                    c: (1, 2),\n+                    e: \"foo\",\n                     a: (),\n                     b: (),\n-                    c: (1, 2),\n                     d: (),\n-                    e: \"foo\",\n                 }\n             }\n             \"#,"}]}