{"sha": "808eeffee63f4276c3d246316f3fcf3ae4901e49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwOGVlZmZlZTYzZjQyNzZjM2QyNDYzMTZmM2ZjZjNhZTQ5MDFlNDk=", "commit": {"author": {"name": "Jonathan S", "email": "gereeter@gmail.com", "date": "2014-12-12T18:07:20Z"}, "committer": {"name": "Jonathan S", "email": "gereeter@gmail.com", "date": "2014-12-13T05:26:57Z"}, "message": "Make BTree's Handle system more generic and more powerful, removing some runtine checks in favor of newly gained static safety", "tree": {"sha": "8105dd05ad955bdb500b441d3b875216bc6b71a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8105dd05ad955bdb500b441d3b875216bc6b71a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/808eeffee63f4276c3d246316f3fcf3ae4901e49", "comment_count": 11, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/808eeffee63f4276c3d246316f3fcf3ae4901e49", "html_url": "https://github.com/rust-lang/rust/commit/808eeffee63f4276c3d246316f3fcf3ae4901e49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/808eeffee63f4276c3d246316f3fcf3ae4901e49/comments", "author": null, "committer": null, "parents": [{"sha": "a5921241a3146cccaffc336a0d1ade1a90e3517f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5921241a3146cccaffc336a0d1ade1a90e3517f", "html_url": "https://github.com/rust-lang/rust/commit/a5921241a3146cccaffc336a0d1ade1a90e3517f"}], "stats": {"total": 557, "additions": 259, "deletions": 298}, "files": [{"sha": "1ab0a61208b68d3b5b3c83b0f8a053b2b297576a", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 118, "deletions": 124, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/808eeffee63f4276c3d246316f3fcf3ae4901e49/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/808eeffee63f4276c3d246316f3fcf3ae4901e49/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=808eeffee63f4276c3d246316f3fcf3ae4901e49", "patch": "@@ -20,7 +20,10 @@ pub use self::Entry::*;\n use core::prelude::*;\n \n use self::StackOp::*;\n-use super::node::*;\n+use super::node::{mod, Node, Found, GoDown};\n+use super::node::{Traversal, MutTraversal, MoveTraversal};\n+use super::node::TraversalItem::{mod, Elem, Edge};\n+use super::node::ForceResult::{Leaf, Internal};\n use core::borrow::BorrowFrom;\n use std::hash::{Writer, Hash};\n use core::default::Default;\n@@ -123,12 +126,12 @@ pub enum Entry<'a, K:'a, V:'a> {\n /// A vacant Entry.\n pub struct VacantEntry<'a, K:'a, V:'a> {\n     key: K,\n-    stack: stack::VacantSearchStack<'a, K, V>,\n+    stack: stack::SearchStack<'a, K, V, node::Edge, node::Leaf>,\n }\n \n /// An occupied Entry.\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n-    stack: stack::OccupiedSearchStack<'a, K, V>,\n+    stack: stack::SearchStack<'a, K, V, node::KV, node::LeafOrInternal>,\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n@@ -206,10 +209,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         loop {\n             match Node::search(cur_node, key) {\n                 Found(handle) => return Some(handle.into_kv().1),\n-                GoDown(handle) => match handle.into_edge() {\n-                    None => return None,\n-                    Some(next_node) => {\n-                        cur_node = next_node;\n+                GoDown(handle) => match handle.force() {\n+                    Leaf(_) => return None,\n+                    Internal(internal_handle) => {\n+                        cur_node = internal_handle.into_edge();\n                         continue;\n                     }\n                 }\n@@ -270,10 +273,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             let cur_node = temp_node;\n             match Node::search(cur_node, key) {\n                 Found(handle) => return Some(handle.into_kv_mut().1),\n-                GoDown(handle) => match handle.into_edge_mut() {\n-                    None => return None,\n-                    Some(next_node) => {\n-                        temp_node = next_node;\n+                GoDown(handle) => match handle.force() {\n+                    Leaf(_) => return None,\n+                    Internal(internal_handle) => {\n+                        temp_node = internal_handle.into_edge_mut();\n                         continue;\n                     }\n                 }\n@@ -352,27 +355,27 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             let result = stack.with(move |pusher, node| {\n                 // Same basic logic as found in `find`, but with PartialSearchStack mediating the\n                 // actual nodes for us\n-                match Node::search(node, &key) {\n+                return match Node::search(node, &key) {\n                     Found(mut handle) => {\n                         // Perfect match, swap the values and return the old one\n                         mem::swap(handle.val_mut(), &mut value);\n-                        return Finished(Some(value));\n+                        Finished(Some(value))\n                     },\n                     GoDown(handle) => {\n                         // We need to keep searching, try to get the search stack\n                         // to go down further\n-                        match pusher.push(handle) {\n-                            stack::Done(new_stack) => {\n+                        match handle.force() {\n+                            Leaf(leaf_handle) => {\n                                 // We've reached a leaf, perform the insertion here\n-                                new_stack.insert(key, value);\n-                                return Finished(None);\n+                                pusher.seal(leaf_handle).insert(key, value);\n+                                Finished(None)\n                             }\n-                            stack::Grew(new_stack) => {\n+                            Internal(internal_handle) => {\n                                 // We've found the subtree to insert this key/value pair in,\n                                 // keep searching\n-                                return Continue((new_stack, key, value));\n+                                Continue((pusher.push(internal_handle), key, value))\n                             }\n-                        };\n+                        }\n                     }\n                 }\n             });\n@@ -450,18 +453,18 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n             let result = stack.with(move |pusher, node| {\n-                match Node::search(node, key) {\n+                return match Node::search(node, key) {\n                     Found(handle) => {\n                         // Perfect match. Terminate the stack here, and remove the entry\n-                        return Finished(Some(pusher.seal(handle).remove()));\n+                        Finished(Some(pusher.seal(handle).remove()))\n                     },\n                     GoDown(handle) => {\n                         // We need to keep searching, try to go down the next edge\n-                        match pusher.push(handle) {\n+                        match handle.force() {\n                             // We're at a leaf; the key isn't in here\n-                            stack::Done(_) => return Finished(None),\n-                            stack::Grew(new_stack) => return Continue(new_stack)\n-                        };\n+                            Leaf(_) => Finished(None),\n+                            Internal(internal_handle) => Continue(pusher.push(internal_handle))\n+                        }\n                     }\n                 }\n             });\n@@ -484,12 +487,11 @@ enum Continuation<A, B> {\n /// to nodes. By using this module much better safety guarantees can be made, and more search\n /// boilerplate gets cut out.\n mod stack {\n-    pub use self::PushResult::*;\n     use core::prelude::*;\n     use core::kinds::marker;\n     use core::mem;\n     use super::BTreeMap;\n-    use super::super::node::*;\n+    use super::super::node::{mod, Node, Fit, Split, KV, Edge, Internal, Leaf, LeafOrInternal};\n     use vec::Vec;\n \n     /// A generic mutable reference, identical to `&mut` except for the fact that its lifetime\n@@ -513,30 +515,23 @@ mod stack {\n         }\n     }\n \n-    type StackItem<K, V> = EdgeNodeHandle<*mut Node<K, V>>;\n+    type StackItem<K, V> = node::Handle<*mut Node<K, V>, Edge, Internal>;\n     type Stack<K, V> = Vec<StackItem<K, V>>;\n \n-    /// A PartialSearchStack handles the construction of a search stack.\n+    /// A `PartialSearchStack` handles the construction of a search stack.\n     pub struct PartialSearchStack<'a, K:'a, V:'a> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n         next: *mut Node<K, V>,\n     }\n \n-    /// An OccupiedSearchStack represents a full path to an element of interest. It provides methods\n-    /// for manipulating the element at the top of its stack.\n-    pub struct OccupiedSearchStack<'a, K:'a, V:'a> {\n+    /// A `SearchStack` represents a full path to an element or an edge of interest. It provides\n+    /// methods depending on the type of what the path points to for removing an element, inserting\n+    /// a new element, and manipulating to element at the top of the stack.\n+    pub struct SearchStack<'a, K:'a, V:'a, Type, NodeType> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n-        top: KVNodeHandle<*mut Node<K, V>>,\n-    }\n-\n-    /// A VacantSearchStack represents a full path to a spot for a new element of interest. It\n-    /// provides a method inserting an element at the top of its stack.\n-    pub struct VacantSearchStack<'a, K:'a, V:'a> {\n-        map: &'a mut BTreeMap<K, V>,\n-        stack: Stack<K, V>,\n-        top: EdgeNodeHandle<*mut Node<K, V>>,\n+        top: node::Handle<*mut Node<K, V>, Type, NodeType>,\n     }\n \n     /// A `PartialSearchStack` that doesn't hold a a reference to the next node, and is just\n@@ -548,14 +543,6 @@ mod stack {\n         marker: marker::InvariantLifetime<'id>\n     }\n \n-    /// The result of asking a PartialSearchStack to push another node onto itself. Either it\n-    /// Grew, in which case it's still Partial, or it found its last node was actually a leaf, in\n-    /// which case it seals itself and yields a complete SearchStack.\n-    pub enum PushResult<'a, K:'a, V:'a> {\n-        Grew(PartialSearchStack<'a, K, V>),\n-        Done(VacantSearchStack<'a, K, V>),\n-    }\n-\n     impl<'a, K, V> PartialSearchStack<'a, K, V> {\n         /// Creates a new PartialSearchStack from a BTreeMap by initializing the stack with the\n         /// root of the tree.\n@@ -603,40 +590,29 @@ mod stack {\n         /// Pushes the requested child of the stack's current top on top of the stack. If the child\n         /// exists, then a new PartialSearchStack is yielded. Otherwise, a VacantSearchStack is\n         /// yielded.\n-        pub fn push(mut self, mut edge: EdgeNodeHandle<IdRef<'id, Node<K, V>>>)\n-                    -> PushResult<'a, K, V> {\n-            let to_insert = edge.as_raw();\n-            match edge.edge_mut() {\n-                None => {\n-                    Done(VacantSearchStack {\n-                        map: self.map,\n-                        stack: self.stack,\n-                        top: to_insert,\n-                    })\n-                },\n-                Some(node) => {\n-                    self.stack.push(to_insert);\n-                    Grew(PartialSearchStack {\n-                        map: self.map,\n-                        stack: self.stack,\n-                        next: node as *mut _,\n-                    })\n-                },\n+        pub fn push(mut self, mut edge: node::Handle<IdRef<'id, Node<K, V>>, Edge, Internal>)\n+                    -> PartialSearchStack<'a, K, V> {\n+            self.stack.push(edge.as_raw());\n+            PartialSearchStack {\n+                map: self.map,\n+                stack: self.stack,\n+                next: edge.edge_mut() as *mut _,\n             }\n         }\n \n-        /// Converts the PartialSearchStack into an OccupiedSearchStack.\n-        pub fn seal(self, mut node: KVNodeHandle<IdRef<'id, Node<K, V>>>)\n-                    -> OccupiedSearchStack<'a, K, V> {\n-            OccupiedSearchStack {\n+        /// Converts the PartialSearchStack into a SearchStack.\n+        pub fn seal<Type, NodeType>\n+                   (self, mut handle: node::Handle<IdRef<'id, Node<K, V>>, Type, NodeType>)\n+                    -> SearchStack<'a, K, V, Type, NodeType> {\n+            SearchStack {\n                 map: self.map,\n                 stack: self.stack,\n-                top: node.as_raw(),\n+                top: handle.as_raw(),\n             }\n         }\n     }\n \n-    impl<'a, K, V> OccupiedSearchStack<'a, K, V> {\n+    impl<'a, K, V, NodeType> SearchStack<'a, K, V, KV, NodeType> {\n         /// Gets a reference to the value the stack points to.\n         pub fn peek(&self) -> &V {\n             unsafe { self.top.from_raw().into_kv().1 }\n@@ -657,20 +633,13 @@ mod stack {\n                 )\n             }\n         }\n+    }\n \n+    impl<'a, K, V> SearchStack<'a, K, V, KV, Leaf> {\n         /// Removes the key and value in the top element of the stack, then handles underflows as\n         /// described in BTree's pop function.\n-        pub fn remove(mut self) -> V {\n-            // Ensure that the search stack goes to a leaf. This is necessary to perform deletion\n-            // in a BTree. Note that this may put the tree in an inconsistent state (further\n-            // described in leafify's comments), but this is immediately fixed by the\n-            // removing the value we want to remove\n-            self.leafify();\n-\n-            let map = self.map;\n-            map.length -= 1;\n-\n-            let mut stack = self.stack;\n+        fn remove_leaf(mut self) -> V {\n+            self.map.length -= 1;\n \n             // Remove the key-value pair from the leaf that this search stack points to.\n             // Then, note if the leaf is underfull, and promptly forget the leaf and its ptr\n@@ -682,16 +651,16 @@ mod stack {\n             };\n \n             loop {\n-                match stack.pop() {\n+                match self.stack.pop() {\n                     None => {\n                         // We've reached the root, so no matter what, we're done. We manually\n                         // access the root via the tree itself to avoid creating any dangling\n                         // pointers.\n-                        if map.root.len() == 0 && !map.root.is_leaf() {\n+                        if self.map.root.len() == 0 && !self.map.root.is_leaf() {\n                             // We've emptied out the root, so make its only child the new root.\n                             // If it's a leaf, we just let it become empty.\n-                            map.depth -= 1;\n-                            map.root.into_edge();\n+                            self.map.depth -= 1;\n+                            self.map.root.hoist_lone_child();\n                         }\n                         return value;\n                     }\n@@ -710,14 +679,26 @@ mod stack {\n                 }\n             }\n         }\n+    }\n+\n+    impl<'a, K, V> SearchStack<'a, K, V, KV, LeafOrInternal> {\n+        /// Removes the key and value in the top element of the stack, then handles underflows as\n+        /// described in BTree's pop function.\n+        pub fn remove(self) -> V {\n+            // Ensure that the search stack goes to a leaf. This is necessary to perform deletion\n+            // in a BTree. Note that this may put the tree in an inconsistent state (further\n+            // described in into_leaf's comments), but this is immediately fixed by the\n+            // removing the value we want to remove\n+            self.into_leaf().remove_leaf()\n+        }\n \n         /// Subroutine for removal. Takes a search stack for a key that might terminate at an\n         /// internal node, and mutates the tree and search stack to *make* it a search stack\n         /// for that same key that *does* terminates at a leaf. If the mutation occurs, then this\n         /// leaves the tree in an inconsistent state that must be repaired by the caller by\n         /// removing the entry in question. Specifically the key-value pair and its successor will\n         /// become swapped.\n-        fn leafify(&mut self) {\n+        fn into_leaf(mut self) -> SearchStack<'a, K, V, KV, Leaf> {\n             unsafe {\n                 let mut top_raw = self.top;\n                 let mut top = top_raw.from_raw_mut();\n@@ -726,31 +707,43 @@ mod stack {\n                 let val_ptr = top.val_mut() as *mut _;\n \n                 // Try to go into the right subtree of the found key to find its successor\n-                let mut right_edge = top.right_edge();\n-                let right_edge_raw = right_edge.as_raw();\n-                match right_edge.edge_mut() {\n-                    None => {\n+                match top.force() {\n+                    Leaf(mut leaf_handle) => {\n                         // We're a proper leaf stack, nothing to do\n+                        return SearchStack {\n+                            map: self.map,\n+                            stack: self.stack,\n+                            top: leaf_handle.as_raw()\n+                        }\n                     }\n-                    Some(mut temp_node) => {\n+                    Internal(mut internal_handle) => {\n+                        let mut right_handle = internal_handle.right_edge();\n+\n                         //We're not a proper leaf stack, let's get to work.\n-                        self.stack.push(right_edge_raw);\n+                        self.stack.push(right_handle.as_raw());\n+\n+                        let mut temp_node = right_handle.edge_mut();\n                         loop {\n                             // Walk into the smallest subtree of this node\n                             let node = temp_node;\n \n-                            if node.is_leaf() {\n-                                // This node is a leaf, do the swap and return\n-                                let mut handle = node.kv_handle(0);\n-                                self.top = handle.as_raw();\n-                                mem::swap(handle.key_mut(), &mut *key_ptr);\n-                                mem::swap(handle.val_mut(), &mut *val_ptr);\n-                                break;\n-                            } else {\n-                                // This node is internal, go deeper\n-                                let mut handle = node.edge_handle(0);\n-                                self.stack.push(handle.as_raw());\n-                                temp_node = handle.into_edge_mut().unwrap();\n+                            match node.kv_handle(0).force() {\n+                                Leaf(mut handle) => {\n+                                    // This node is a leaf, do the swap and return\n+                                    mem::swap(handle.key_mut(), &mut *key_ptr);\n+                                    mem::swap(handle.val_mut(), &mut *val_ptr);\n+                                    return SearchStack {\n+                                        map: self.map,\n+                                        stack: self.stack,\n+                                        top: handle.as_raw()\n+                                    }\n+                                },\n+                                Internal(kv_handle) => {\n+                                    // This node is internal, go deeper\n+                                    let mut handle = kv_handle.into_left_edge();\n+                                    self.stack.push(handle.as_raw());\n+                                    temp_node = handle.into_edge_mut();\n+                                }\n                             }\n                         }\n                     }\n@@ -759,7 +752,7 @@ mod stack {\n         }\n     }\n \n-    impl<'a, K, V> VacantSearchStack<'a, K, V> {\n+    impl<'a, K, V> SearchStack<'a, K, V, Edge, Leaf> {\n         /// Inserts the key and value into the top element in the stack, and if that node has to\n         /// split recursively inserts the split contents into the next element stack until\n         /// splits stop.\n@@ -1234,27 +1227,28 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n             let result = stack.with(move |pusher, node| {\n-                match Node::search(node, &key) {\n+                return match Node::search(node, &key) {\n                     Found(handle) => {\n                         // Perfect match\n-                        return Finished(Occupied(OccupiedEntry {\n+                        Finished(Occupied(OccupiedEntry {\n                             stack: pusher.seal(handle)\n-                        }));\n+                        }))\n                     },\n                     GoDown(handle) => {\n-                        match pusher.push(handle) {\n-                            stack::Done(new_stack) => {\n-                                // Not in the tree, but we've found where it goes\n-                                return Finished(Vacant(VacantEntry {\n-                                    stack: new_stack,\n+                        match handle.force() {\n+                            Leaf(leaf_handle) => {\n+                                Finished(Vacant(VacantEntry {\n+                                    stack: pusher.seal(leaf_handle),\n                                     key: key,\n-                                }));\n+                                }))\n+                            },\n+                            Internal(internal_handle) => {\n+                                Continue((\n+                                    pusher.push(internal_handle),\n+                                    key\n+                                ))\n                             }\n-                            stack::Grew(new_stack) => {\n-                                // We've found the subtree this key must go in\n-                                return Continue((new_stack, key));\n-                            }\n-                        };\n+                        }\n                     }\n                 }\n             });"}, {"sha": "3718dd516b21a977c54e78cd29d112d1ee0b2260", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 141, "deletions": 174, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/808eeffee63f4276c3d246316f3fcf3ae4901e49/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/808eeffee63f4276c3d246316f3fcf3ae4901e49/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=808eeffee63f4276c3d246316f3fcf3ae4901e49", "patch": "@@ -13,6 +13,7 @@\n \n pub use self::InsertionResult::*;\n pub use self::SearchResult::*;\n+pub use self::ForceResult::*;\n pub use self::TraversalItem::*;\n \n use core::prelude::*;\n@@ -34,9 +35,9 @@ pub enum InsertionResult<K, V> {\n /// Represents the result of a search for a key in a single node\n pub enum SearchResult<NodeRef> {\n     /// The element was found at the given index\n-    Found(KVNodeHandle<NodeRef>),\n+    Found(Handle<NodeRef, KV, LeafOrInternal>),\n     /// The element wasn't found, but if it's anywhere, it must be beyond this edge\n-    GoDown(EdgeNodeHandle<NodeRef>),\n+    GoDown(Handle<NodeRef, Edge, LeafOrInternal>),\n }\n \n /// A B-Tree Node. We keep keys/edges/values separate to optimize searching for keys.\n@@ -428,8 +429,10 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n     }\n }\n \n-/// A reference to a key/value pair in the middle of a `Node`. Methods are provided for removing\n-/// the pair and accessing the pair and the adjacent edges.\n+/// A reference to something in the middle of a `Node`. There are two `Type`s of `Handle`s,\n+/// namely `KV` handles, which point to key/value pairs, and `Edge` handles, which point to edges\n+/// before or after key/value pairs. Methods are provided for removing pairs, inserting into edges,\n+/// accessing the stored values, and moving around the `Node`.\n ///\n /// This handle is generic, and can take any sort of reference to a `Node`. The reason for this is\n /// two-fold. First of all, it reduces the amount of repetitive code, implementing functions that\n@@ -490,20 +493,17 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n /// }\n /// ```\n #[deriving(Copy)]\n-pub struct KVNodeHandle<NodeRef> {\n+pub struct Handle<NodeRef, Type, NodeType> {\n     node: NodeRef,\n     index: uint\n }\n \n-/// A reference to an edge in the middle of a `Node`. Methods are provided for inserting stuff into\n-/// the space, handling underflow, and accessing the pointed-to edge.\n-///\n-/// Please see the notes on `KVNodeHandle` about the generic parameter and safety concerns.\n-#[deriving(Copy)]\n-pub struct EdgeNodeHandle<NodeRef> {\n-    node: NodeRef,\n-    index: uint\n-}\n+pub enum KV {}\n+pub enum Edge {}\n+\n+pub enum LeafOrInternal {}\n+pub enum Leaf {}\n+pub enum Internal {}\n \n impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n@@ -516,12 +516,12 @@ impl<K: Ord, V> Node<K, V> {\n         // worse for uints.\n         let (found, index) = node.search_linear(key);\n         if found {\n-            Found(KVNodeHandle {\n+            Found(Handle {\n                 node: node,\n                 index: index\n             })\n         } else {\n-            GoDown(EdgeNodeHandle {\n+            GoDown(Handle {\n                 node: node,\n                 index: index\n             })\n@@ -586,81 +586,111 @@ impl <K, V> Node<K, V> {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> EdgeNodeHandle<&'a Node<K, V>> {\n+impl<K, V, NodeRef: Deref<Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n+    /// Returns a reference to the node that contains the pointed-to edge or key/value pair. This\n+    /// is very different from `edge` and `edge_mut` because those return children of the node\n+    /// returned by `node`.\n+    pub fn node(&self) -> &Node<K, V> {\n+        &*self.node\n+    }\n+}\n+\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n+    /// Converts a handle into one that stores the same information using a raw pointer. This can\n+    /// be useful in conjunction with `from_raw` when the type system is insufficient for\n+    /// determining the lifetimes of the nodes.\n+    pub fn as_raw(&mut self) -> Handle<*mut Node<K, V>, Type, NodeType> {\n+        Handle {\n+            node: &mut *self.node as *mut _,\n+            index: self.index\n+        }\n+    }\n+}\n+\n+impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> {\n+    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n+    /// stored with a reference. This is an unsafe inverse of `as_raw`, and together they allow\n+    /// unsafely extending the lifetime of the reference to the `Node`.\n+    pub unsafe fn from_raw<'a>(&'a self) -> Handle<&'a Node<K, V>, Type, NodeType> {\n+        Handle {\n+            node: &*self.node,\n+            index: self.index\n+        }\n+    }\n+\n+    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n+    /// stored with a mutable reference. This is an unsafe inverse of `as_raw`, and together they\n+    /// allow unsafely extending the lifetime of the reference to the `Node`.\n+    pub unsafe fn from_raw_mut<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Type, NodeType> {\n+        Handle {\n+            node: &mut *self.node,\n+            index: self.index\n+        }\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, Edge, Internal> {\n     /// Turns the handle into a reference to the edge it points at. This is necessary because the\n     /// returned pointer has a larger lifetime than what would be returned by `edge` or `edge_mut`,\n     /// making it more suitable for moving down a chain of nodes.\n-    ///\n-    /// Returns `None` if called on an edge in a leaf node.\n-    pub fn into_edge(self) -> Option<&'a Node<K, V>> {\n-        if self.node.is_leaf() {\n-            None\n-        } else {\n-            unsafe {\n-                Some(self.node.edges().unsafe_get(self.index))\n-            }\n+    pub fn into_edge(self) -> &'a Node<K, V> {\n+        unsafe {\n+            self.node.edges().unsafe_get(self.index)\n         }\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> EdgeNodeHandle<&'a mut Node<K, V>> {\n+impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, Edge, Internal> {\n     /// Turns the handle into a mutable reference to the edge it points at. This is necessary\n     /// because the returned pointer has a larger lifetime than what would be returned by\n     /// `edge_mut`, making it more suitable for moving down a chain of nodes.\n-    ///\n-    /// Returns `None` if called on an edge in a leaf node.\n-    pub fn into_edge_mut(self) -> Option<&'a mut Node<K, V>> {\n-        if self.node.is_leaf() {\n-            None\n-        } else {\n-            unsafe {\n-                Some(self.node.edges_mut().unsafe_mut(self.index))\n-            }\n+    pub fn into_edge_mut(self) -> &'a mut Node<K, V> {\n+        unsafe {\n+            self.node.edges_mut().unsafe_mut(self.index)\n         }\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Node<K, V>>> EdgeNodeHandle<NodeRef> {\n-    /// Returns a reference to the node that contains the pointed-to edge. This is very different\n-    /// from `edge` and `edge_mut` because those return children of the node returned by `node`.\n-    pub fn node(&self) -> &Node<K, V> {\n-        &*self.node\n-    }\n-\n+impl<K, V, NodeRef: Deref<Node<K, V>>> Handle<NodeRef, Edge, Internal> {\n     // This doesn't exist because there are no uses for it,\n     // but is fine to add, analagous to edge_mut.\n     //\n     // /// Returns a reference to the edge pointed-to by this handle. This should not be\n     // /// confused with `node`, which references the parent node of what is returned here.\n-    // ///\n-    // /// Returns `None` when called on an edge in a leaf node.\n-    // pub fn edge(&self) -> Option<&Node<K, V>>\n+    // pub fn edge(&self) -> &Node<K, V>\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> EdgeNodeHandle<NodeRef> {\n-    /// Returns a mutable reference to the edge pointed-to by this handle. This should not be\n-    /// confused with `node`, which references the parent node of what is returned here.\n-    ///\n-    /// Returns `None` when called on an edge in a leaf node.\n-    pub fn edge_mut(&mut self) -> Option<&mut Node<K, V>> {\n+pub enum ForceResult<NodeRef, Type> {\n+    Leaf(Handle<NodeRef, Type, Leaf>),\n+    Internal(Handle<NodeRef, Type, Internal>)\n+}\n+\n+impl<K, V, NodeRef: Deref<Node<K, V>>, Type> Handle<NodeRef, Type, LeafOrInternal> {\n+    /// Figure out whether this handle is pointing to something in a leaf node or to something in\n+    /// an internal node, clarifying the type according to the result.\n+    pub fn force(self) -> ForceResult<NodeRef, Type> {\n         if self.node.is_leaf() {\n-            None\n+            Leaf(Handle {\n+                node: self.node,\n+                index: self.index\n+            })\n         } else {\n-            unsafe { Some(self.node.edges_mut().unsafe_mut(self.index)) }\n+            Internal(Handle {\n+                node: self.node,\n+                index: self.index\n+            })\n         }\n     }\n+}\n \n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, Edge, Leaf> {\n     /// Tries to insert this key-value pair at the given index in this leaf node\n     /// If the node is full, we have to split it.\n     ///\n     /// Returns a *mut V to the inserted value, because the caller may want this when\n     /// they're done mutating the tree, but we don't want to borrow anything for now.\n     pub fn insert_as_leaf(mut self, key: K, value: V) ->\n             (InsertionResult<K, V>, *mut V) {\n-        // Necessary for correctness, but in a private module\n-        debug_assert!(self.node.is_leaf(),\n-                      \"insert_as_leaf must only be called on leaf nodes\");\n-\n         if !self.node.is_full() {\n             // The element can fit, just insert it\n             (Fit, unsafe { self.node.insert_kv(self.index, key, value) as *mut _ })\n@@ -683,15 +713,21 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> EdgeNodeHandle<NodeRef> {\n             (Split(new_key, new_val, new_right), ptr)\n         }\n     }\n+}\n+\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, Edge, Internal> {\n+    /// Returns a mutable reference to the edge pointed-to by this handle. This should not be\n+    /// confused with `node`, which references the parent node of what is returned here.\n+    pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n+        unsafe {\n+            self.node.edges_mut().unsafe_mut(self.index)\n+        }\n+    }\n \n     /// Tries to insert this key-value pair at the given index in this internal node\n     /// If the node is full, we have to split it.\n     pub fn insert_as_internal(mut self, key: K, value: V, right: Node<K, V>)\n             -> InsertionResult<K, V> {\n-        // Necessary for correctness, but in a private module\n-        debug_assert!(!self.node.is_leaf(),\n-                      \"insert_as_internal must only be called on internal nodes\");\n-\n         if !self.node.is_full() {\n             // The element can fit, just insert it\n             unsafe {\n@@ -739,26 +775,6 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> EdgeNodeHandle<NodeRef> {\n         }\n     }\n \n-    /// Gets the handle pointing to the key/value pair just to the left of the pointed-to edge.\n-    /// This is unsafe because the handle might point to the first edge in the node, which has no\n-    /// pair to its left.\n-    unsafe fn left_kv<'a>(&'a mut self) -> KVNodeHandle<&'a mut Node<K, V>> {\n-        KVNodeHandle {\n-            node: &mut *self.node,\n-            index: self.index - 1\n-        }\n-    }\n-\n-    /// Gets the handle pointing to the key/value pair just to the right of the pointed-to edge.\n-    /// This is unsafe because the handle might point to the last edge in the node, which has no\n-    /// pair to its right.\n-    unsafe fn right_kv<'a>(&'a mut self) -> KVNodeHandle<&'a mut Node<K, V>> {\n-        KVNodeHandle {\n-            node: &mut *self.node,\n-            index: self.index\n-        }\n-    }\n-\n     /// Right is underflowed. Tries to steal from left,\n     /// but merges left and right if left is low too.\n     unsafe fn handle_underflow_to_left(&mut self) {\n@@ -780,41 +796,31 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> EdgeNodeHandle<NodeRef> {\n             self.right_kv().merge_children();\n         }\n     }\n-\n-    /// Converts a handle into one that stores the same information using a raw pointer. This can\n-    /// be useful in conjunction with `from_raw` in the cases in which the type system is\n-    /// insufficient for determining the lifetimes of the nodes.\n-    pub fn as_raw(&mut self) -> EdgeNodeHandle<*mut Node<K, V>> {\n-        EdgeNodeHandle {\n-            node: &mut *self.node as *mut _,\n-            index: self.index\n-        }\n-    }\n }\n \n-impl<K, V> EdgeNodeHandle<*mut Node<K, V>> {\n-    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n-    /// stored with a reference. This is an unsafe inverse of `as_raw`, and together they allow\n-    /// unsafely extending the lifetime of the reference to the `Node`.\n-    pub unsafe fn from_raw<'a>(&'a self) -> EdgeNodeHandle<&'a Node<K, V>> {\n-        EdgeNodeHandle {\n-            node: &*self.node,\n-            index: self.index\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, Edge, NodeType> {\n+    /// Gets the handle pointing to the key/value pair just to the left of the pointed-to edge.\n+    /// This is unsafe because the handle might point to the first edge in the node, which has no\n+    /// pair to its left.\n+    unsafe fn left_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, KV, NodeType> {\n+        Handle {\n+            node: &mut *self.node,\n+            index: self.index - 1\n         }\n     }\n \n-    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n-    /// stored with a mutable reference. This is an unsafe inverse of `as_raw`, and together they\n-    /// allow unsafely extending the lifetime of the reference to the `Node`.\n-    pub unsafe fn from_raw_mut<'a>(&'a mut self) -> EdgeNodeHandle<&'a mut Node<K, V>> {\n-        EdgeNodeHandle {\n+    /// Gets the handle pointing to the key/value pair just to the right of the pointed-to edge.\n+    /// This is unsafe because the handle might point to the last edge in the node, which has no\n+    /// pair to its right.\n+    unsafe fn right_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, KV, NodeType> {\n+        Handle {\n             node: &mut *self.node,\n             index: self.index\n         }\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> KVNodeHandle<&'a Node<K, V>> {\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, KV, NodeType> {\n     /// Turns the handle into references to the key and value it points at. This is necessary\n     /// because the returned pointers have larger lifetimes than what would be returned by `key`\n     /// or `val`.\n@@ -829,7 +835,7 @@ impl<'a, K: 'a, V: 'a> KVNodeHandle<&'a Node<K, V>> {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> KVNodeHandle<&'a mut Node<K, V>> {\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, KV, NodeType> {\n     /// Turns the handle into mutable references to the key and value it points at. This is\n     /// necessary because the returned pointers have larger lifetimes than what would be returned\n     /// by `key_mut` or `val_mut`.\n@@ -842,14 +848,19 @@ impl<'a, K: 'a, V: 'a> KVNodeHandle<&'a mut Node<K, V>> {\n             )\n         }\n     }\n-}\n \n-impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a> KVNodeHandle<NodeRef> {\n-    /// Returns a reference to the node that contains the pointed-to key/value pair.\n-    pub fn node(&'a self) -> &'a Node<K, V> {\n-        &*self.node\n+    /// Convert this handle into one pointing at the edge immediately to the left of the key/value\n+    /// pair pointed-to by this handle. This is useful because it returns a reference with larger\n+    /// lifetime than `left_edge`.\n+    pub fn into_left_edge(self) -> Handle<&'a mut Node<K, V>, Edge, NodeType> {\n+        Handle {\n+            node: &mut *self.node,\n+            index: self.index\n+        }\n     }\n+}\n \n+impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef, KV, NodeType> {\n     // These are fine to include, but are currently unneeded.\n     //\n     // /// Returns a reference to the key pointed-to by this handle. This doesn't return a\n@@ -867,7 +878,7 @@ impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a> KVNodeHandle<NodeRef> {\n     // }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a> KVNodeHandle<NodeRef> {\n+impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<NodeRef, KV, NodeType> {\n     /// Returns a mutable reference to the key pointed-to by this handle. This doesn't return a\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     /// handle.\n@@ -883,53 +894,45 @@ impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a> KVNodeHandle<NodeRef>\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> KVNodeHandle<NodeRef> {\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, KV, NodeType> {\n     /// Gets the handle pointing to the edge immediately to the left of the key/value pair pointed\n     /// to by this handle.\n-    pub fn left_edge<'a>(&'a mut self) -> EdgeNodeHandle<&'a mut Node<K, V>> {\n-        EdgeNodeHandle {\n+    pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Edge, NodeType> {\n+        Handle {\n             node: &mut *self.node,\n             index: self.index\n         }\n     }\n \n     /// Gets the handle pointing to the edge immediately to the right of the key/value pair pointed\n     /// to by this handle.\n-    pub fn right_edge<'a>(&'a mut self) -> EdgeNodeHandle<&'a mut Node<K, V>> {\n-        EdgeNodeHandle {\n+    pub fn right_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Edge, NodeType> {\n+        Handle {\n             node: &mut *self.node,\n             index: self.index + 1\n         }\n     }\n+}\n \n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, KV, Leaf> {\n     /// Removes the key/value pair at the handle's location.\n     ///\n     /// # Panics (in debug build)\n     ///\n     /// Panics if the node containing the pair is not a leaf node.\n     pub fn remove_as_leaf(mut self) -> (K, V) {\n-        // Necessary for correctness, but in a private module\n-        debug_assert!(self.node.is_leaf(), \"remove_as_leaf must only be called on leaf nodes\");\n         unsafe { self.node.remove_kv(self.index) }\n     }\n+}\n \n-    /// Converts a handle into one that stores the same information using a raw pointer. This can\n-    /// be useful in conjunction with `from_raw` in the cases in which the type system is\n-    /// insufficient for determining the lifetimes of the nodes.\n-    pub fn as_raw(&mut self) -> KVNodeHandle<*mut Node<K, V>> {\n-        KVNodeHandle {\n-            node: &mut *self.node as *mut _,\n-            index: self.index\n-        }\n-    }\n-\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, KV, Internal> {\n     /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" right.\n     unsafe fn steal_rightward(&mut self) {\n         // Take the biggest stuff off left\n         let (mut key, mut val, edge) = {\n             let mut left_handle = self.left_edge();\n-            let left = left_handle.edge_mut().unwrap();\n+            let left = left_handle.edge_mut();\n             let (key, val) = left.pop_kv();\n             let edge = if left.is_leaf() {\n                 None\n@@ -946,7 +949,7 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> KVNodeHandle<NodeRef> {\n \n         // Put them at the start of right\n         let mut right_handle = self.right_edge();\n-        let right = right_handle.edge_mut().unwrap();\n+        let right = right_handle.edge_mut();\n         right.insert_kv(0, key, val);\n         match edge {\n             Some(edge) => right.insert_edge(0, edge),\n@@ -960,7 +963,7 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> KVNodeHandle<NodeRef> {\n         // Take the smallest stuff off right\n         let (mut key, mut val, edge) = {\n             let mut right_handle = self.right_edge();\n-            let right = right_handle.edge_mut().unwrap();\n+            let right = right_handle.edge_mut();\n             let (key, val) = right.remove_kv(0);\n             let edge = if right.is_leaf() {\n                 None\n@@ -977,7 +980,7 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> KVNodeHandle<NodeRef> {\n \n         // Put them at the end of left\n         let mut left_handle = self.left_edge();\n-        let left = left_handle.edge_mut().unwrap();\n+        let left = left_handle.edge_mut();\n         left.push_kv(key, val);\n         match edge {\n             Some(edge) => left.push_edge(edge),\n@@ -994,57 +997,21 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> KVNodeHandle<NodeRef> {\n         let right = self.node.remove_edge(self.index + 1);\n \n         // Give left right's stuff.\n-        self.left_edge().edge_mut().unwrap()\n+        self.left_edge().edge_mut()\n             .absorb(key, val, right);\n     }\n }\n \n-impl<K, V> KVNodeHandle<*mut Node<K, V>> {\n-    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n-    /// stored with a reference. This is an unsafe inverse of `as_raw`, and together they allow\n-    /// unsafely extending the lifetime of the reference to the `Node`.\n-    pub unsafe fn from_raw<'a>(&'a self) -> KVNodeHandle<&'a Node<K, V>> {\n-        KVNodeHandle {\n-            node: &*self.node,\n-            index: self.index\n-        }\n-    }\n-\n-    /// Converts from a handle stored with a raw pointer, which isn't directly usable, to a handle\n-    /// stored with a mutable reference. This is an unsafe inverse of `as_raw`, and together they\n-    /// allow unsafely extending the lifetime of the reference to the `Node`.\n-    pub unsafe fn from_raw_mut<'a>(&'a mut self) -> KVNodeHandle<&'a mut Node<K, V>> {\n-        KVNodeHandle {\n-            node: &mut *self.node,\n-            index: self.index\n-        }\n-    }\n-}\n-\n impl<K, V> Node<K, V> {\n     /// Returns the mutable handle pointing to the key/value pair at a given index.\n     ///\n     /// # Panics (in debug build)\n     ///\n     /// Panics if the given index is out of bounds.\n-    pub fn kv_handle(&mut self, index: uint) -> KVNodeHandle<&mut Node<K, V>> {\n+    pub fn kv_handle(&mut self, index: uint) -> Handle<&mut Node<K, V>, KV, LeafOrInternal> {\n         // Necessary for correctness, but in a private module\n         debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n-        KVNodeHandle {\n-            node: self,\n-            index: index\n-        }\n-    }\n-\n-    /// Returns the mutable handle pointing to the edge at a given index.\n-    ///\n-    /// # Panics (in debug build)\n-    ///\n-    /// Panics if the given index is out of bounds.\n-    pub fn edge_handle(&mut self, index: uint) -> EdgeNodeHandle<&mut Node<K, V>> {\n-        // Necessary for correctness, but in a private module\n-        debug_assert!(index <= self.len(), \"edge_handle index out of bounds\");\n-        EdgeNodeHandle {\n+        Handle {\n             node: self,\n             index: index\n         }\n@@ -1100,7 +1067,7 @@ impl<K, V> Node<K, V> {\n     }\n \n     /// When a node has no keys or values and only a single edge, extract that edge.\n-    pub fn into_edge(&mut self) {\n+    pub fn hoist_lone_child(&mut self) {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.len() == 0);\n         debug_assert!(!self.is_leaf());"}]}