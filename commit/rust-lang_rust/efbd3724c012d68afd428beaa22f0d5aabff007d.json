{"sha": "efbd3724c012d68afd428beaa22f0d5aabff007d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYmQzNzI0YzAxMmQ2OGFmZDQyOGJlYWEyMmYwZDVhYWJmZjAwN2Q=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-19T22:51:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-19T22:51:31Z"}, "message": "std: Rebuild sync::deque on Arc\n\nThis also removes the `&mut self` requirement, using the correct `&self`\nrequirement for concurrent types.", "tree": {"sha": "8d1acb5a91fcee967390fb8494c76fc04f440589", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d1acb5a91fcee967390fb8494c76fc04f440589"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efbd3724c012d68afd428beaa22f0d5aabff007d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efbd3724c012d68afd428beaa22f0d5aabff007d", "html_url": "https://github.com/rust-lang/rust/commit/efbd3724c012d68afd428beaa22f0d5aabff007d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efbd3724c012d68afd428beaa22f0d5aabff007d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44fcf46b00389bea30f4902ce77f2e33557d9170", "url": "https://api.github.com/repos/rust-lang/rust/commits/44fcf46b00389bea30f4902ce77f2e33557d9170", "html_url": "https://github.com/rust-lang/rust/commit/44fcf46b00389bea30f4902ce77f2e33557d9170"}], "stats": {"total": 52, "additions": 27, "deletions": 25}, "files": [{"sha": "42a8bd886525bbadd253b45900ae3cda89cc5fcd", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/efbd3724c012d68afd428beaa22f0d5aabff007d/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efbd3724c012d68afd428beaa22f0d5aabff007d/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=efbd3724c012d68afd428beaa22f0d5aabff007d", "patch": "@@ -48,6 +48,8 @@\n // FIXME: all atomic operations in this module use a SeqCst ordering. That is\n //      probably overkill\n \n+use alloc::arc::Arc;\n+\n use clone::Clone;\n use iter::{range, Iterator};\n use kinds::Send;\n@@ -58,7 +60,6 @@ use owned::Box;\n use ptr::RawPtr;\n use ptr;\n use slice::ImmutableVector;\n-use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n use unstable::sync::Exclusive;\n use rt::heap::{allocate, deallocate};\n@@ -87,14 +88,14 @@ struct Deque<T> {\n ///\n /// There may only be one worker per deque.\n pub struct Worker<T> {\n-    deque: UnsafeArc<Deque<T>>,\n+    deque: Arc<Deque<T>>,\n }\n \n /// The stealing half of the work-stealing deque. Stealers have access to the\n /// opposite end of the deque from the worker, and they only have access to the\n /// `steal` method.\n pub struct Stealer<T> {\n-    deque: UnsafeArc<Deque<T>>,\n+    deque: Arc<Deque<T>>,\n }\n \n /// When stealing some data, this is an enumeration of the possible outcomes.\n@@ -149,12 +150,13 @@ impl<T: Send> BufferPool<T> {\n \n     /// Allocates a new work-stealing deque which will send/receiving memory to\n     /// and from this buffer pool.\n-    pub fn deque(&mut self) -> (Worker<T>, Stealer<T>) {\n-        let (a, b) = UnsafeArc::new2(Deque::new(self.clone()));\n+    pub fn deque(&self) -> (Worker<T>, Stealer<T>) {\n+        let a = Arc::new(Deque::new(self.clone()));\n+        let b = a.clone();\n         (Worker { deque: a }, Stealer { deque: b })\n     }\n \n-    fn alloc(&mut self, bits: int) -> Box<Buffer<T>> {\n+    fn alloc(&self, bits: int) -> Box<Buffer<T>> {\n         unsafe {\n             self.pool.with(|pool| {\n                 match pool.iter().position(|x| x.size() >= (1 << bits)) {\n@@ -165,7 +167,7 @@ impl<T: Send> BufferPool<T> {\n         }\n     }\n \n-    fn free(&mut self, buf: Box<Buffer<T>>) {\n+    fn free(&self, buf: Box<Buffer<T>>) {\n         unsafe {\n             let mut buf = Some(buf);\n             self.pool.with(|pool| {\n@@ -185,34 +187,34 @@ impl<T: Send> Clone for BufferPool<T> {\n \n impl<T: Send> Worker<T> {\n     /// Pushes data onto the front of this work queue.\n-    pub fn push(&mut self, t: T) {\n-        unsafe { (*self.deque.get()).push(t) }\n+    pub fn push(&self, t: T) {\n+        unsafe { self.deque.push(t) }\n     }\n     /// Pops data off the front of the work queue, returning `None` on an empty\n     /// queue.\n-    pub fn pop(&mut self) -> Option<T> {\n-        unsafe { (*self.deque.get()).pop() }\n+    pub fn pop(&self) -> Option<T> {\n+        unsafe { self.deque.pop() }\n     }\n \n     /// Gets access to the buffer pool that this worker is attached to. This can\n     /// be used to create more deques which share the same buffer pool as this\n     /// deque.\n-    pub fn pool<'a>(&'a mut self) -> &'a mut BufferPool<T> {\n-        unsafe { &mut (*self.deque.get()).pool }\n+    pub fn pool<'a>(&'a self) -> &'a BufferPool<T> {\n+        &self.deque.pool\n     }\n }\n \n impl<T: Send> Stealer<T> {\n     /// Steals work off the end of the queue (opposite of the worker's end)\n-    pub fn steal(&mut self) -> Stolen<T> {\n-        unsafe { (*self.deque.get()).steal() }\n+    pub fn steal(&self) -> Stolen<T> {\n+        unsafe { self.deque.steal() }\n     }\n \n     /// Gets access to the buffer pool that this stealer is attached to. This\n     /// can be used to create more deques which share the same buffer pool as\n     /// this deque.\n-    pub fn pool<'a>(&'a mut self) -> &'a mut BufferPool<T> {\n-        unsafe { &mut (*self.deque.get()).pool }\n+    pub fn pool<'a>(&'a self) -> &'a BufferPool<T> {\n+        &self.deque.pool\n     }\n }\n \n@@ -224,7 +226,7 @@ impl<T: Send> Clone for Stealer<T> {\n // personally going to heavily comment what's going on here.\n \n impl<T: Send> Deque<T> {\n-    fn new(mut pool: BufferPool<T>) -> Deque<T> {\n+    fn new(pool: BufferPool<T>) -> Deque<T> {\n         let buf = pool.alloc(MIN_BITS);\n         Deque {\n             bottom: AtomicInt::new(0),\n@@ -234,7 +236,7 @@ impl<T: Send> Deque<T> {\n         }\n     }\n \n-    unsafe fn push(&mut self, data: T) {\n+    unsafe fn push(&self, data: T) {\n         let mut b = self.bottom.load(SeqCst);\n         let t = self.top.load(SeqCst);\n         let mut a = self.array.load(SeqCst);\n@@ -250,7 +252,7 @@ impl<T: Send> Deque<T> {\n         self.bottom.store(b + 1, SeqCst);\n     }\n \n-    unsafe fn pop(&mut self) -> Option<T> {\n+    unsafe fn pop(&self) -> Option<T> {\n         let b = self.bottom.load(SeqCst);\n         let a = self.array.load(SeqCst);\n         let b = b - 1;\n@@ -276,7 +278,7 @@ impl<T: Send> Deque<T> {\n         }\n     }\n \n-    unsafe fn steal(&mut self) -> Stolen<T> {\n+    unsafe fn steal(&self) -> Stolen<T> {\n         let t = self.top.load(SeqCst);\n         let old = self.array.load(SeqCst);\n         let b = self.bottom.load(SeqCst);\n@@ -298,7 +300,7 @@ impl<T: Send> Deque<T> {\n         }\n     }\n \n-    unsafe fn maybe_shrink(&mut self, b: int, t: int) {\n+    unsafe fn maybe_shrink(&self, b: int, t: int) {\n         let a = self.array.load(SeqCst);\n         if b - t < (*a).size() / K && b - t > (1 << MIN_BITS) {\n             self.swap_buffer(b, a, (*a).resize(b, t, -1));\n@@ -312,7 +314,7 @@ impl<T: Send> Deque<T> {\n     // after this method has called 'free' on it. The continued usage is simply\n     // a read followed by a forget, but we must make sure that the memory can\n     // continue to be read after we flag this buffer for reclamation.\n-    unsafe fn swap_buffer(&mut self, b: int, old: *mut Buffer<T>,\n+    unsafe fn swap_buffer(&self, b: int, old: *mut Buffer<T>,\n                           buf: Buffer<T>) -> *mut Buffer<T> {\n         let newbuf: *mut Buffer<T> = transmute(box buf);\n         self.array.store(newbuf, SeqCst);\n@@ -373,7 +375,7 @@ impl<T: Send> Buffer<T> {\n \n     // Unsafe because this unsafely overwrites possibly uninitialized or\n     // initialized data.\n-    unsafe fn put(&mut self, i: int, t: T) {\n+    unsafe fn put(&self, i: int, t: T) {\n         let ptr = self.storage.offset(i & self.mask());\n         ptr::copy_nonoverlapping_memory(ptr as *mut T, &t as *T, 1);\n         forget(t);\n@@ -382,7 +384,7 @@ impl<T: Send> Buffer<T> {\n     // Again, unsafe because this has incredibly dubious ownership violations.\n     // It is assumed that this buffer is immediately dropped.\n     unsafe fn resize(&self, b: int, t: int, delta: int) -> Buffer<T> {\n-        let mut buf = Buffer::new(self.log_size + delta);\n+        let buf = Buffer::new(self.log_size + delta);\n         for i in range(t, b) {\n             buf.put(i, self.get(i));\n         }"}]}