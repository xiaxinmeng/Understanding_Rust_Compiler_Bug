{"sha": "4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "node_id": "C_kwDOAAsO6NoAKDRlNmI1NWU5YjhkNjRhZjVkMTRlZDU0NjVmZGNmNTRjNjJlZjNiOGI", "commit": {"author": {"name": "josh rotenberg", "email": "joshrotenberg@gmail.com", "date": "2021-06-16T05:05:44Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-06-06T14:15:52Z"}, "message": "Initial commit for the Clippy Book", "tree": {"sha": "0e7482ab7d2e8b94fc9a537bbf4e0eccfdd07bec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e7482ab7d2e8b94fc9a537bbf4e0eccfdd07bec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmKeDBgACgkQHKDfKvWd\naKUrwg/7BHFxsZ8NmIWWL05NDsvfkicpclsWZwyk1ExJCIahTLNlr2fJ7mqeTp+O\nPXkA681/r06sRIKf1Dc/l7ikdiZR0nvqnoPG0JwYadK0oXKlJSyJ499vi1+CVGVF\n6vh30KsJJ4J2pt1/HMafflMO02V45H68oheUp0GN+TxCdcwxW+XGm6GWcbB+qRsP\nDH+3d/ZEO8X9AVCwY7yp1xSLd6J5PDg+r4DuLBC0ufnzGxxaksBFCxoa+l6KOI8+\nEblKb3RDSFZyShbIfbYktBkatOTHgSfljOVJ0x3DblevN7yWmStR1VWmGX/SZDxa\neiJP2qa4ncbEKvAKd7Q4JSbHrc6QxaqszyiRYiTAGnLmxla69FjN/TwUr45FAgIH\n2mIoWcHXl0OqC6dmh/LUbnLJehjKtm37A2/LpUzouASAIODEbK5TgukbD4CfaNLP\nC5dbPiWBoj2eYdDoWBIVqvi6qMjtUddE8pRQoBb0dS0QIIegxB8OXqb+q1xSNSkM\n5MbzQRP8Uw38OVXPAJEaW4EOMinG5OMG/GOM9W4Y+4dNDBgihBsz517RJqNGEqRi\nCakuKdYKN8iZ/b9oJF4W6T91EDFlik+ZIKj/rhuKIfavPn12zSuQ/znIdEPh1Esr\n+4/Y8Fb8kBb5GCSRx3gCV9MB8yd6/by06R2kJGTgcLNDApCILZ4=\n=bowX\n-----END PGP SIGNATURE-----", "payload": "tree 0e7482ab7d2e8b94fc9a537bbf4e0eccfdd07bec\nparent 0f6e50fe1b8a9f40b77d248d05695bba9fd8773f\nauthor josh rotenberg <joshrotenberg@gmail.com> 1623819944 -0700\ncommitter Philipp Krones <hello@philkrones.com> 1654524952 +0200\n\nInitial commit for the Clippy Book\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "html_url": "https://github.com/rust-lang/rust/commit/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/comments", "author": {"login": "joshrotenberg", "id": 3231, "node_id": "MDQ6VXNlcjMyMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3231?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joshrotenberg", "html_url": "https://github.com/joshrotenberg", "followers_url": "https://api.github.com/users/joshrotenberg/followers", "following_url": "https://api.github.com/users/joshrotenberg/following{/other_user}", "gists_url": "https://api.github.com/users/joshrotenberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/joshrotenberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joshrotenberg/subscriptions", "organizations_url": "https://api.github.com/users/joshrotenberg/orgs", "repos_url": "https://api.github.com/users/joshrotenberg/repos", "events_url": "https://api.github.com/users/joshrotenberg/events{/privacy}", "received_events_url": "https://api.github.com/users/joshrotenberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f6e50fe1b8a9f40b77d248d05695bba9fd8773f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f6e50fe1b8a9f40b77d248d05695bba9fd8773f", "html_url": "https://github.com/rust-lang/rust/commit/0f6e50fe1b8a9f40b77d248d05695bba9fd8773f"}], "stats": {"total": 1908, "additions": 1908, "deletions": 0}, "files": [{"sha": "503ae3c50903921c42c63f628073c5d51ae7a949", "filename": ".gitignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -39,3 +39,6 @@ helper.txt\n *.iml\n .vscode\n .idea\n+\n+# mdbook generated output\n+/book/book"}, {"sha": "b652194d0d13b25ec38c99d56460923b5ab7b02f", "filename": "book/README.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2FREADME.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,4 @@\n+# Clippy Book\n+\n+This is the source for the Clippy Book. See the\n+[book](src/infrastructure/book.md) for more information."}, {"sha": "93b6641f7e1e743c3705298c6a1593ab2719cbec", "filename": "book/book.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fbook.toml?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,28 @@\n+[book]\n+authors = [\"The Rust Clippy Developers\"]\n+language = \"en\"\n+multilingual = false\n+src = \"src\"\n+title = \"Clippy Documentation\"\n+\n+[rust]\n+edition = \"2018\"\n+\n+[output.html]\n+edit-url-template = \"https://github.com/rust-lang/rust-clippy/edit/master/book/{path}\"\n+git-repository-url = \"https://github.com/rust-lang/rust-clippy/tree/master/book\"\n+mathjax-support = true\n+site-url = \"/rust-clippy/\"\n+\n+[output.html.playground]\n+editable = true\n+line-numbers = true\n+\n+[output.html.search]\n+boost-hierarchy = 2\n+boost-paragraph = 1\n+boost-title = 2\n+expand = true\n+heading-split-level = 2\n+limit-results = 20\n+use-boolean-and = true"}, {"sha": "de1f70d7e9640080e1bc4873e48f94ce8c409feb", "filename": "book/src/README.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2FREADME.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,34 @@\n+# Clippy\n+\n+[![Clippy Test](https://github.com/rust-lang/rust-clippy/workflows/Clippy%20Test/badge.svg?branch=auto&event=push)](https://github.com/rust-lang/rust-clippy/actions?query=workflow%3A%22Clippy+Test%22+event%3Apush+branch%3Aauto)\n+[![License: MIT OR Apache-2.0](https://img.shields.io/crates/l/clippy.svg)](#license)\n+\n+A collection of lints to catch common mistakes and improve your\n+[Rust](https://github.com/rust-lang/rust) code.\n+\n+[There are over 500 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+\n+Lints are divided into categories, each with a default [lint\n+level](https://doc.rust-lang.org/rustc/lints/levels.html). You can choose how\n+much Clippy is supposed to ~~annoy~~ help you by changing the lint level by\n+category.\n+\n+| Category              | Description                                                                         | Default level |\n+| --------------------- | ----------------------------------------------------------------------------------- | ------------- |\n+| `clippy::all`         | all lints that are on by default (correctness, suspicious, style, complexity, perf) | **warn/deny** |\n+| `clippy::correctness` | code that is outright wrong or useless                                              | **deny**      |\n+| `clippy::suspicious`  | code that is most likely wrong or useless                                           | **warn**      |\n+| `clippy::complexity`  | code that does something simple but in a complex way                                | **warn**      |\n+| `clippy::perf`        | code that can be written to run faster                                              | **warn**      |\n+| `clippy::style`       | code that should be written in a more idiomatic way                                 | **warn**      |\n+| `clippy::pedantic`    | lints which are rather strict or might have false positives                         | allow         |\n+| `clippy::nursery`     | new lints that are still under development                                          | allow         |\n+| `clippy::cargo`       | lints for the cargo manifest                                                        | allow         |                                   | allow         |\n+\n+More to come, please [file an\n+issue](https://github.com/rust-lang/rust-clippy/issues) if you have ideas!\n+\n+The [lint list](https://rust-lang.github.io/rust-clippy/master/index.html) also\n+contains \"restriction lints\", which are for things which are usually not\n+considered \"bad\", but may be useful to turn on in specific cases. These should\n+be used very selectively, if at all."}, {"sha": "470760b6d168800c8a036a3b86f68c271f2551d9", "filename": "book/src/SUMMARY.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2FSUMMARY.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,26 @@\n+# Summary\n+\n+[Introduction](README.md)\n+\n+- [Installation and Usage](installation_and_usage.md)\n+- [Configuration](configuration.md)\n+- [Clippy's Lints](lints/README.md)\n+    - [Correctness]()\n+    - [Suspicious]()\n+    - [Style]()\n+    - [Complexity]()\n+    - [Perf]()\n+    - [Pendantic]()\n+    - [Nursery]()\n+    - [Cargo]()\n+- [Development](development/README.md)\n+    - [Basics](development/basics.md)\n+    - [Adding Lints](development/adding_lints.md)\n+    - [Common Tools](development/common_tools_writing_lints.md)\n+- [Infrastructure](infrastructure/README.md)\n+    - [Backporting Changes](infrastructure/backport.md)\n+    - [Updating the Changelog](infrastructure/changelog_update.md)\n+    - [Release a New Version](infrastructure/release.md)\n+    - [The Clippy Book](infrastructure/book.md)\n+- [Roadmap](roadmap/README.md)\n+    - [2021](roadmap/2021.md)"}, {"sha": "6e295ac3181dd99e7c3e40324eafa69069076185", "filename": "book/src/configuration.md", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Fconfiguration.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Fconfiguration.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fconfiguration.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,92 @@\n+# Configuring Clippy\n+\n+> **Note:** The configuration file is unstable and may be deprecated in the future.\n+\n+Some lints can be configured in a TOML file named `clippy.toml` or `.clippy.toml`. It contains a\n+basic `variable = value` mapping eg.\n+\n+```toml\n+avoid-breaking-exported-api = false\n+blacklisted-names = [\"toto\", \"tata\", \"titi\"]\n+cognitive-complexity-threshold = 30\n+```\n+\n+See the [list of lints](https://rust-lang.github.io/rust-clippy/master/index.html) for more information about which\n+lints can be configured and the meaning of the variables.\n+\n+To deactivate the \"for further information visit *lint-link*\" message you can define the `CLIPPY_DISABLE_DOCS_LINKS`\n+environment variable.\n+\n+### Allowing/denying lints\n+\n+You can add options to your code to `allow`/`warn`/`deny` Clippy lints:\n+\n+* the whole set of `Warn` lints using the `clippy` lint group (`#![deny(clippy::all)]`)\n+\n+* all lints using both the `clippy` and `clippy::pedantic` lint groups (`#![deny(clippy::all)]`,\n+  `#![deny(clippy::pedantic)]`). Note that `clippy::pedantic` contains some very aggressive lints prone to false\n+  positives.\n+\n+* only some lints (`#![deny(clippy::single_match, clippy::box_vec)]`, etc.)\n+\n+* `allow`/`warn`/`deny` can be limited to a single function or module using `#[allow(...)]`, etc.\n+\n+Note: `allow` means to suppress the lint for your code. With `warn` the lint will only emit a warning, while with `deny`\n+the lint will emit an error, when triggering for your code. An error causes clippy to exit with an error code, so is\n+useful in scripts like CI/CD.\n+\n+If you do not want to include your lint levels in your code, you can globally enable/disable lints by passing extra\n+flags to Clippy during the run:\n+\n+To allow `lint_name`, run\n+\n+```terminal\n+cargo clippy -- -A clippy::lint_name\n+```\n+\n+And to warn on `lint_name`, run\n+\n+```terminal\n+cargo clippy -- -W clippy::lint_name\n+```\n+\n+This also works with lint groups. For example you can run Clippy with warnings for all lints enabled:\n+\n+```terminal\n+cargo clippy -- -W clippy::pedantic\n+```\n+\n+If you care only about a single lint, you can allow all others and then explicitly warn on the lint(s) you are\n+interested in:\n+\n+```terminal\n+cargo clippy -- -A clippy::all -W clippy::useless_format -W clippy::...\n+```\n+\n+### Specifying the minimum supported Rust version\n+\n+Projects that intend to support old versions of Rust can disable lints pertaining to newer features by specifying the\n+minimum supported Rust version (MSRV) in the clippy configuration file.\n+\n+```toml\n+msrv = \"1.30.0\"\n+```\n+\n+The MSRV can also be specified as an inner attribute, like below.\n+\n+```rust\n+#![feature(custom_inner_attributes)]\n+#![clippy::msrv = \"1.30.0\"]\n+\n+fn main() {\n+    ...\n+}\n+```\n+\n+You can also omit the patch version when specifying the MSRV, so `msrv = 1.30`\n+is equivalent to `msrv = 1.30.0`.\n+\n+Note: `custom_inner_attributes` is an unstable feature so it has to be enabled explicitly.\n+\n+Lints that recognize this configuration option can be\n+found [here](https://rust-lang.github.io/rust-clippy/master/index.html#msrv)"}, {"sha": "09d6aad2c538e8ab75bb1d8e3648f5ef71579038", "filename": "book/src/development/README.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Fdevelopment%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Fdevelopment%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2FREADME.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1 @@\n+# Clippy Development"}, {"sha": "5a06afedbf4c2e7b86afff20847a30456b7a6d41", "filename": "book/src/development/adding_lints.md", "status": "added", "additions": 670, "deletions": 0, "changes": 670, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Fdevelopment%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Fdevelopment%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fadding_lints.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,670 @@\n+# Adding a new lint\n+\n+You are probably here because you want to add a new lint to Clippy. If this is\n+the first time you're contributing to Clippy, this document guides you through\n+creating an example lint from scratch.\n+\n+To get started, we will create a lint that detects functions called `foo`,\n+because that's clearly a non-descriptive name.\n+\n+- [Adding a new lint](#adding-a-new-lint)\n+  - [Setup](#setup)\n+  - [Getting Started](#getting-started)\n+  - [Testing](#testing)\n+  - [Rustfix tests](#rustfix-tests)\n+  - [Edition 2018 tests](#edition-2018-tests)\n+  - [Testing manually](#testing-manually)\n+  - [Lint declaration](#lint-declaration)\n+  - [Lint passes](#lint-passes)\n+  - [Emitting a lint](#emitting-a-lint)\n+  - [Adding the lint logic](#adding-the-lint-logic)\n+  - [Specifying the lint's minimum supported Rust version (MSRV)](#specifying-the-lints-minimum-supported-rust-version-msrv)\n+  - [Author lint](#author-lint)\n+  - [Documentation](#documentation)\n+  - [Running rustfmt](#running-rustfmt)\n+  - [Debugging](#debugging)\n+  - [PR Checklist](#pr-checklist)\n+  - [Adding configuration to a lint](#adding-configuration-to-a-lint)\n+  - [Cheatsheet](#cheatsheet)\n+\n+## Setup\n+\n+See the [Basics](basics.md#get-the-code) documentation.\n+\n+## Getting Started\n+\n+There is a bit of boilerplate code that needs to be set up when creating a new\n+lint. Fortunately, you can use the clippy dev tools to handle this for you. We\n+are naming our new lint `foo_functions` (lints are generally written in snake\n+case), and we don't need type information so it will have an early pass type\n+(more on this later on). If you're not sure if the name you chose fits the lint,\n+take a look at our [lint naming guidelines][lint_naming]. To get started on this\n+lint you can run `cargo dev new_lint --name=foo_functions --pass=early\n+--category=pedantic` (category will default to nursery if not provided). This\n+command will create two files: `tests/ui/foo_functions.rs` and\n+`clippy_lints/src/foo_functions.rs`, as well as run `cargo dev update_lints` to\n+register the new lint. For cargo lints, two project hierarchies (fail/pass) will\n+be created by default under `tests/ui-cargo`.\n+\n+Next, we'll open up these files and add our lint!\n+\n+## Testing\n+\n+Let's write some tests first that we can execute while we iterate on our lint.\n+\n+Clippy uses UI tests for testing. UI tests check that the output of Clippy is\n+exactly as expected. Each test is just a plain Rust file that contains the code\n+we want to check. The output of Clippy is compared against a `.stderr` file.\n+Note that you don't have to create this file yourself, we'll get to\n+generating the `.stderr` files further down.\n+\n+We start by opening the test file created at `tests/ui/foo_functions.rs`.\n+\n+Update the file with some examples to get started:\n+\n+```rust\n+#![warn(clippy::foo_functions)]\n+\n+// Impl methods\n+struct A;\n+impl A {\n+    pub fn fo(&self) {}\n+    pub fn foo(&self) {}\n+    pub fn food(&self) {}\n+}\n+\n+// Default trait methods\n+trait B {\n+    fn fo(&self) {}\n+    fn foo(&self) {}\n+    fn food(&self) {}\n+}\n+\n+// Plain functions\n+fn fo() {}\n+fn foo() {}\n+fn food() {}\n+\n+fn main() {\n+    // We also don't want to lint method calls\n+    foo();\n+    let a = A;\n+    a.foo();\n+}\n+```\n+\n+Now we can run the test with `TESTNAME=foo_functions cargo uitest`,\n+currently this test is meaningless though.\n+\n+While we are working on implementing our lint, we can keep running the UI\n+test. That allows us to check if the output is turning into what we want.\n+\n+Once we are satisfied with the output, we need to run\n+`cargo dev bless` to update the `.stderr` file for our lint.\n+Please note that, we should run `TESTNAME=foo_functions cargo uitest`\n+every time before running `cargo dev bless`.\n+Running `TESTNAME=foo_functions cargo uitest` should pass then. When we commit\n+our lint, we need to commit the generated `.stderr` files, too. In general, you\n+should only commit files changed by `cargo dev bless` for the\n+specific lint you are creating/editing. Note that if the generated files are\n+empty, they should be removed.\n+\n+Note that you can run multiple test files by specifying a comma separated list:\n+`TESTNAME=foo_functions,test2,test3`.\n+\n+### Cargo lints\n+\n+For cargo lints, the process of testing differs in that we are interested in\n+the `Cargo.toml` manifest file. We also need a minimal crate associated\n+with that manifest.\n+\n+If our new lint is named e.g. `foo_categories`, after running `cargo dev new_lint`\n+we will find by default two new crates, each with its manifest file:\n+\n+* `tests/ui-cargo/foo_categories/fail/Cargo.toml`: this file should cause the new lint to raise an error.\n+* `tests/ui-cargo/foo_categories/pass/Cargo.toml`: this file should not trigger the lint.\n+\n+If you need more cases, you can copy one of those crates (under `foo_categories`) and rename it.\n+\n+The process of generating the `.stderr` file is the same, and prepending the `TESTNAME`\n+variable to `cargo uitest` works too.\n+\n+## Rustfix tests\n+\n+If the lint you are working on is making use of structured suggestions, the\n+test file should include a `// run-rustfix` comment at the top. This will\n+additionally run [rustfix] for that test. Rustfix will apply the suggestions\n+from the lint to the code of the test file and compare that to the contents of\n+a `.fixed` file.\n+\n+Use `cargo dev bless` to automatically generate the\n+`.fixed` file after running the tests.\n+\n+[rustfix]: https://github.com/rust-lang/rustfix\n+\n+## Edition 2018 tests\n+\n+Some features require the 2018 edition to work (e.g. `async_await`), but\n+compile-test tests run on the 2015 edition by default. To change this behavior\n+add `// edition:2018` at the top of the test file (note that it's space-sensitive).\n+\n+## Testing manually\n+\n+Manually testing against an example file can be useful if you have added some\n+`println!`s and the test suite output becomes unreadable. To try Clippy with\n+your local modifications, run\n+\n+```\n+env __CLIPPY_INTERNAL_TESTS=true cargo run --bin clippy-driver -- -L ./target/debug input.rs\n+```\n+\n+from the working copy root. With tests in place, let's have a look at\n+implementing our lint now.\n+\n+## Lint declaration\n+\n+Let's start by opening the new file created in the `clippy_lints` crate\n+at `clippy_lints/src/foo_functions.rs`. That's the crate where all the\n+lint code is. This file has already imported some initial things we will need:\n+\n+```rust\n+use rustc_lint::{EarlyLintPass, EarlyContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_ast::ast::*;\n+```\n+\n+The next step is to update the lint declaration. Lints are declared using the\n+[`declare_clippy_lint!`][declare_clippy_lint] macro, and we just need to update\n+the auto-generated lint declaration to have a real description, something like this:\n+\n+```rust\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    ///\n+    /// **Why is this bad?**\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // example code\n+    /// ```\n+    pub FOO_FUNCTIONS,\n+    pedantic,\n+    \"function named `foo`, which is not a descriptive name\"\n+}\n+```\n+\n+* The section of lines prefixed with `///` constitutes the lint documentation\n+  section. This is the default documentation style and will be displayed\n+  [like this][example_lint_page]. To render and open this documentation locally\n+  in a browser, run `cargo dev serve`.\n+* `FOO_FUNCTIONS` is the name of our lint. Be sure to follow the\n+  [lint naming guidelines][lint_naming] here when naming your lint.\n+  In short, the name should state the thing that is being checked for and\n+  read well when used with `allow`/`warn`/`deny`.\n+* `pedantic` sets the lint level to `Allow`.\n+  The exact mapping can be found [here][category_level_mapping]\n+* The last part should be a text that explains what exactly is wrong with the\n+  code\n+\n+The rest of this file contains an empty implementation for our lint pass,\n+which in this case is `EarlyLintPass` and should look like this:\n+\n+```rust\n+// clippy_lints/src/foo_functions.rs\n+\n+// .. imports and lint declaration ..\n+\n+declare_lint_pass!(FooFunctions => [FOO_FUNCTIONS]);\n+\n+impl EarlyLintPass for FooFunctions {}\n+```\n+\n+Normally after declaring the lint, we have to run `cargo dev update_lints`,\n+which updates some files, so Clippy knows about the new lint. Since we used\n+`cargo dev new_lint ...` to generate the lint declaration, this was done\n+automatically. While `update_lints` automates most of the things, it doesn't\n+automate everything. We will have to register our lint pass manually in the\n+`register_plugins` function in `clippy_lints/src/lib.rs`:\n+\n+```rust\n+store.register_early_pass(|| box foo_functions::FooFunctions);\n+```\n+\n+As one may expect, there is a corresponding `register_late_pass` method\n+available as well. Without a call to one of `register_early_pass` or\n+`register_late_pass`, the lint pass in question will not be run.\n+\n+One reason that `cargo dev` does not automate this step is that multiple lints\n+can use the same lint pass, so registering the lint pass may already be done\n+when adding a new lint. Another reason that this step is not automated is that\n+the order that the passes are registered determines the order the passes\n+actually run, which in turn affects the order that any emitted lints are output\n+in.\n+\n+[declare_clippy_lint]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L60\n+[example_lint_page]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n+[lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n+[category_level_mapping]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L110\n+\n+## Lint passes\n+\n+Writing a lint that only checks for the name of a function means that we only\n+have to deal with the AST and don't have to deal with the type system at all.\n+This is good, because it makes writing this particular lint less complicated.\n+\n+We have to make this decision with every new Clippy lint. It boils down to using\n+either [`EarlyLintPass`][early_lint_pass] or [`LateLintPass`][late_lint_pass].\n+\n+In short, the `LateLintPass` has access to type information while the\n+`EarlyLintPass` doesn't. If you don't need access to type information, use the\n+`EarlyLintPass`. The `EarlyLintPass` is also faster. However linting speed\n+hasn't really been a concern with Clippy so far.\n+\n+Since we don't need type information for checking the function name, we used\n+`--pass=early` when running the new lint automation and all the imports were\n+added accordingly.\n+\n+[early_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html\n+[late_lint_pass]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.LateLintPass.html\n+\n+## Emitting a lint\n+\n+With UI tests and the lint declaration in place, we can start working on the\n+implementation of the lint logic.\n+\n+Let's start by implementing the `EarlyLintPass` for our `FooFunctions`:\n+\n+```rust\n+impl EarlyLintPass for FooFunctions {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n+        // TODO: Emit lint here\n+    }\n+}\n+```\n+\n+We implement the [`check_fn`][check_fn] method from the\n+[`EarlyLintPass`][early_lint_pass] trait. This gives us access to various\n+information about the function that is currently being checked. More on that in\n+the next section. Let's worry about the details later and emit our lint for\n+*every* function definition first.\n+\n+Depending on how complex we want our lint message to be, we can choose from a\n+variety of lint emission functions. They can all be found in\n+[`clippy_utils/src/diagnostics.rs`][diagnostics].\n+\n+`span_lint_and_help` seems most appropriate in this case. It allows us to\n+provide an extra help message and we can't really suggest a better name\n+automatically. This is how it looks:\n+\n+```rust\n+impl EarlyLintPass for FooFunctions {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n+        span_lint_and_help(\n+            cx,\n+            FOO_FUNCTIONS,\n+            span,\n+            \"function named `foo`\",\n+            None,\n+            \"consider using a more meaningful name\"\n+        );\n+    }\n+}\n+```\n+\n+Running our UI test should now produce output that contains the lint message.\n+\n+According to [the rustc-dev-guide], the text should be matter of fact and avoid\n+capitalization and periods, unless multiple sentences are needed.\n+When code or an identifier must appear in a message or label, it should be\n+surrounded with single grave accents \\`.\n+\n+[check_fn]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/trait.EarlyLintPass.html#method.check_fn\n+[diagnostics]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/diagnostics.rs\n+[the rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/diagnostics.html\n+\n+## Adding the lint logic\n+\n+Writing the logic for your lint will most likely be different from our example,\n+so this section is kept rather short.\n+\n+Using the [`check_fn`][check_fn] method gives us access to [`FnKind`][fn_kind]\n+that has the [`FnKind::Fn`] variant. It provides access to the name of the\n+function/method via an [`Ident`][ident].\n+\n+With that we can expand our `check_fn` method to:\n+\n+```rust\n+impl EarlyLintPass for FooFunctions {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, span: Span, _: NodeId) {\n+        if is_foo_fn(fn_kind) {\n+            span_lint_and_help(\n+                cx,\n+                FOO_FUNCTIONS,\n+                span,\n+                \"function named `foo`\",\n+                None,\n+                \"consider using a more meaningful name\"\n+            );\n+        }\n+    }\n+}\n+```\n+\n+We separate the lint conditional from the lint emissions because it makes the\n+code a bit easier to read. In some cases this separation would also allow to\n+write some unit tests (as opposed to only UI tests) for the separate function.\n+\n+In our example, `is_foo_fn` looks like:\n+\n+```rust\n+// use statements, impl EarlyLintPass, check_fn, ..\n+\n+fn is_foo_fn(fn_kind: FnKind<'_>) -> bool {\n+    match fn_kind {\n+        FnKind::Fn(_, ident, ..) => {\n+            // check if `fn` name is `foo`\n+            ident.name.as_str() == \"foo\"\n+        }\n+        // ignore closures\n+        FnKind::Closure(..) => false\n+    }\n+}\n+```\n+\n+Now we should also run the full test suite with `cargo test`. At this point\n+running `cargo test` should produce the expected output. Remember to run\n+`cargo dev bless` to update the `.stderr` file.\n+\n+`cargo test` (as opposed to `cargo uitest`) will also ensure that our lint\n+implementation is not violating any Clippy lints itself.\n+\n+That should be it for the lint implementation. Running `cargo test` should now\n+pass.\n+\n+[fn_kind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html\n+[`FnKind::Fn`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html#variant.Fn\n+[ident]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html\n+\n+## Specifying the lint's minimum supported Rust version (MSRV)\n+\n+Sometimes a lint makes suggestions that require a certain version of Rust. For example, the `manual_strip` lint suggests\n+using `str::strip_prefix` and `str::strip_suffix` which is only available after Rust 1.45. In such cases, you need to\n+ensure that the MSRV configured for the project is >= the MSRV of the required Rust feature. If multiple features are\n+required, just use the one with a lower MSRV.\n+\n+First, add an MSRV alias for the required feature in [`clippy_utils::msrvs`](/clippy_utils/src/msrvs.rs). This can be\n+accessed later as `msrvs::STR_STRIP_PREFIX`, for example.\n+\n+```rust\n+msrv_aliases! {\n+    ..\n+    1,45,0 { STR_STRIP_PREFIX }\n+}\n+```\n+\n+In order to access the project-configured MSRV, you need to have an `msrv` field in the LintPass struct, and a\n+constructor to initialize the field. The `msrv` value is passed to the constructor in `clippy_lints/lib.rs`.\n+\n+```rust\n+pub struct ManualStrip {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl ManualStrip {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+```\n+\n+The project's MSRV can then be matched against the feature MSRV in the LintPass\n+using the `meets_msrv` utility function.\n+\n+``` rust\n+if !meets_msrv(self.msrv.as_ref(), &msrvs::STR_STRIP_PREFIX) {\n+    return;\n+}\n+```\n+\n+The project's MSRV can also be specified as an inner attribute, which overrides\n+the value from `clippy.toml`. This can be accounted for using the\n+`extract_msrv_attr!(LintContext)` macro and passing\n+`LateContext`/`EarlyContext`.\n+\n+```rust\n+impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        ...\n+    }\n+    extract_msrv_attr!(LateContext);\n+}\n+```\n+\n+Once the `msrv` is added to the lint, a relevant test case should be added to\n+`tests/ui/min_rust_version_attr.rs` which verifies that the lint isn't emitted\n+if the project's MSRV is lower.\n+\n+As a last step, the lint should be added to the lint documentation. This is done\n+in `clippy_lints/src/utils/conf.rs`:\n+\n+```rust\n+define_Conf! {\n+    /// Lint: LIST, OF, LINTS, <THE_NEWLY_ADDED_LINT>. The minimum rust version that the project supports\n+    (msrv: Option<String> = None),\n+    ...\n+}\n+```\n+\n+## Author lint\n+\n+If you have trouble implementing your lint, there is also the internal `author`\n+lint to generate Clippy code that detects the offending pattern. It does not\n+work for all of the Rust syntax, but can give a good starting point.\n+\n+The quickest way to use it, is the\n+[Rust playground: play.rust-lang.org][author_example].\n+Put the code you want to lint into the editor and add the `#[clippy::author]`\n+attribute above the item. Then run Clippy via `Tools -> Clippy` and you should\n+see the generated code in the output below.\n+\n+[Here][author_example] is an example on the playground.\n+\n+If the command was executed successfully, you can copy the code over to where\n+you are implementing your lint.\n+\n+[author_example]: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=9a12cb60e5c6ad4e3003ac6d5e63cf55\n+\n+## Documentation\n+\n+The final thing before submitting our PR is to add some documentation to our\n+lint declaration.\n+\n+Please document your lint with a doc comment akin to the following:\n+\n+```rust\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for ... (describe what the lint matches).\n+    ///\n+    /// **Why is this bad?** Supply the reason for linting the code.\n+    ///\n+    /// **Known problems:** None. (Or describe where it could go wrong.)\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// Insert a short example of code that triggers the lint\n+    ///\n+    /// // Good\n+    /// Insert a short example of improved code that doesn't trigger the lint\n+    /// ```\n+    pub FOO_FUNCTIONS,\n+    pedantic,\n+    \"function named `foo`, which is not a descriptive name\"\n+}\n+```\n+\n+Once your lint is merged, this documentation will show up in the [lint\n+list][lint_list].\n+\n+[lint_list]: https://rust-lang.github.io/rust-clippy/master/index.html\n+\n+## Running rustfmt\n+\n+[Rustfmt] is a tool for formatting Rust code according to style guidelines.\n+Your code has to be formatted by `rustfmt` before a PR can be merged.\n+Clippy uses nightly `rustfmt` in the CI.\n+\n+It can be installed via `rustup`:\n+\n+```bash\n+rustup component add rustfmt --toolchain=nightly\n+```\n+\n+Use `cargo dev fmt` to format the whole codebase. Make sure that `rustfmt` is\n+installed for the nightly toolchain.\n+\n+[Rustfmt]: https://github.com/rust-lang/rustfmt\n+\n+## Debugging\n+\n+If you want to debug parts of your lint implementation, you can use the [`dbg!`]\n+macro anywhere in your code. Running the tests should then include the debug\n+output in the `stdout` part.\n+\n+[`dbg!`]: https://doc.rust-lang.org/std/macro.dbg.html\n+\n+## PR Checklist\n+\n+Before submitting your PR make sure you followed all of the basic requirements:\n+\n+<!-- Sync this with `.github/PULL_REQUEST_TEMPLATE` -->\n+\n+- \\[ ] Followed [lint naming conventions][lint_naming]\n+- \\[ ] Added passing UI tests (including committed `.stderr` file)\n+- \\[ ] `cargo test` passes locally\n+- \\[ ] Executed `cargo dev update_lints`\n+- \\[ ] Added lint documentation\n+- \\[ ] Run `cargo dev fmt`\n+\n+## Adding configuration to a lint\n+\n+Clippy supports the configuration of lints values using a `clippy.toml` file in the workspace\n+directory. Adding a configuration to a lint can be useful for thresholds or to constrain some\n+behavior that can be seen as a false positive for some users. Adding a configuration is done\n+in the following steps:\n+\n+1. Adding a new configuration entry to [clippy_utils::conf](/clippy_utils/src/conf.rs)\n+    like this:\n+    ```rust\n+    /// Lint: LINT_NAME. <The configuration field doc comment>\n+    (configuration_ident: Type = DefaultValue),\n+    ```\n+    The configuration value and identifier should usually be the same. The doc comment will be\n+    automatically added to the lint documentation.\n+2. Adding the configuration value to the lint impl struct:\n+    1. This first requires the definition of a lint impl struct. Lint impl structs are usually\n+        generated with the `declare_lint_pass!` macro. This struct needs to be defined manually\n+        to add some kind of metadata to it:\n+        ```rust\n+        // Generated struct definition\n+        declare_lint_pass!(StructName => [\n+            LINT_NAME\n+        ]);\n+\n+        // New manual definition struct\n+        #[derive(Copy, Clone)]\n+        pub struct StructName {}\n+\n+        impl_lint_pass!(StructName => [\n+            LINT_NAME\n+        ]);\n+        ```\n+\n+    2. Next add the configuration value and a corresponding creation method like this:\n+        ```rust\n+        #[derive(Copy, Clone)]\n+        pub struct StructName {\n+            configuration_ident: Type,\n+        }\n+\n+        // ...\n+\n+        impl StructName {\n+            pub fn new(configuration_ident: Type) -> Self {\n+                Self {\n+                    configuration_ident,\n+                }\n+            }\n+        }\n+        ```\n+3. Passing the configuration value to the lint impl struct:\n+\n+    First find the struct construction in the [clippy_lints lib file](/clippy_lints/src/lib.rs).\n+    The configuration value is now cloned or copied into a local value that is then passed to the\n+    impl struct like this:\n+    ```rust\n+    // Default generated registration:\n+    store.register_*_pass(|| box module::StructName);\n+\n+    // New registration with configuration value\n+    let configuration_ident = conf.configuration_ident.clone();\n+    store.register_*_pass(move || box module::StructName::new(configuration_ident));\n+    ```\n+\n+    Congratulations the work is almost done. The configuration value can now be accessed\n+    in the linting code via `self.configuration_ident`.\n+\n+4. Adding tests:\n+    1. The default configured value can be tested like any normal lint in [`tests/ui`](/tests/ui).\n+    2. The configuration itself will be tested separately in [`tests/ui-toml`](/tests/ui-toml).\n+        Simply add a new subfolder with a fitting name. This folder contains a `clippy.toml` file\n+        with the configuration value and a rust file that should be linted by Clippy. The test can\n+        otherwise be written as usual.\n+\n+## Cheatsheet\n+\n+Here are some pointers to things you are likely going to need for every lint:\n+\n+* [Clippy utils][utils] - Various helper functions. Maybe the function you need\n+  is already in here (`implements_trait`, `match_def_path`, `snippet`, etc)\n+* [Clippy diagnostics][diagnostics]\n+* [The `if_chain` macro][if_chain]\n+* [`from_expansion`][from_expansion] and [`in_external_macro`][in_external_macro]\n+* [`Span`][span]\n+* [`Applicability`][applicability]\n+* [Common tools for writing lints](common_tools_writing_lints.md) helps with common operations\n+* [The rustc-dev-guide][rustc-dev-guide] explains a lot of internal compiler concepts\n+* [The nightly rustc docs][nightly_docs] which has been linked to throughout\n+  this guide\n+\n+For `EarlyLintPass` lints:\n+\n+* [`EarlyLintPass`][early_lint_pass]\n+* [`rustc_ast::ast`][ast]\n+\n+For `LateLintPass` lints:\n+\n+* [`LateLintPass`][late_lint_pass]\n+* [`Ty::TyKind`][ty]\n+\n+While most of Clippy's lint utils are documented, most of rustc's internals lack\n+documentation currently. This is unfortunate, but in most cases you can probably\n+get away with copying things from existing similar lints. If you are stuck,\n+don't hesitate to ask on [Zulip] or in the issue/PR.\n+\n+[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/lib.rs\n+[if_chain]: https://docs.rs/if_chain/*/if_chain/\n+[from_expansion]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion\n+[in_external_macro]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/lint/fn.in_external_macro.html\n+[span]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html\n+[applicability]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html\n+[rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n+[nightly_docs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/\n+[ast]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/index.html\n+[ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/index.html\n+[Zulip]: https://rust-lang.zulipchat.com/#narrow/stream/clippy"}, {"sha": "aaf31158f58a81062456b4d26aaa52da5938239a", "filename": "book/src/development/basics.md", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Fdevelopment%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Fdevelopment%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fbasics.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,172 @@\n+# Basics for hacking on Clippy\n+\n+This document explains the basics for hacking on Clippy. Besides others, this\n+includes how to build and test Clippy. For a more in depth description on\n+the codebase take a look at [Adding Lints] or [Common Tools].\n+\n+[Adding Lints]: https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md\n+[Common Tools]: https://github.com/rust-lang/rust-clippy/blob/master/doc/common_tools_writing_lints.md\n+\n+- [Basics for hacking on Clippy](#basics-for-hacking-on-clippy)\n+  - [Get the Code](#get-the-code)\n+  - [Building and Testing](#building-and-testing)\n+  - [`cargo dev`](#cargo-dev)\n+  - [lintcheck](#lintcheck)\n+  - [PR](#pr)\n+  - [Common Abbreviations](#common-abbreviations)\n+  - [Install from source](#install-from-source)\n+\n+## Get the Code\n+\n+First, make sure you have checked out the latest version of Clippy. If this is\n+your first time working on Clippy, create a fork of the repository and clone it\n+afterwards with the following command:\n+\n+```bash\n+git clone git@github.com:<your-username>/rust-clippy\n+```\n+\n+If you've already cloned Clippy in the past, update it to the latest version:\n+\n+```bash\n+# If the upstream remote has not been added yet\n+git remote add upstream https://github.com/rust-lang/rust-clippy\n+# upstream has to be the remote of the rust-lang/rust-clippy repo\n+git fetch upstream\n+# make sure that you are on the master branch\n+git checkout master\n+# rebase your master branch on the upstream master\n+git rebase upstream/master\n+# push to the master branch of your fork\n+git push\n+```\n+\n+## Building and Testing\n+\n+You can build and test Clippy like every other Rust project:\n+\n+```bash\n+cargo build  # builds Clippy\n+cargo test   # tests Clippy\n+```\n+\n+Since Clippy's test suite is pretty big, there are some commands that only run a\n+subset of Clippy's tests:\n+\n+```bash\n+# only run UI tests\n+cargo uitest\n+# only run UI tests starting with `test_`\n+TESTNAME=\"test_\" cargo uitest\n+# only run dogfood tests\n+cargo test --test dogfood\n+```\n+\n+If the output of a [UI test] differs from the expected output, you can update the\n+reference file with:\n+\n+```bash\n+cargo dev bless\n+```\n+\n+For example, this is necessary, if you fix a typo in an error message of a lint\n+or if you modify a test file to add a test case.\n+\n+_Note:_ This command may update more files than you intended. In that case only\n+commit the files you wanted to update.\n+\n+[UI test]: https://rustc-dev-guide.rust-lang.org/tests/adding.html#guide-to-the-ui-tests\n+\n+## `cargo dev`\n+\n+Clippy has some dev tools to make working on Clippy more convenient. These tools\n+can be accessed through the `cargo dev` command. Available tools are listed\n+below. To get more information about these commands, just call them with\n+`--help`.\n+\n+```bash\n+# formats the whole Clippy codebase and all tests\n+cargo dev fmt\n+# register or update lint names/groups/...\n+cargo dev update_lints\n+# create a new lint and register it\n+cargo dev new_lint\n+# (experimental) Setup Clippy to work with IntelliJ-Rust\n+cargo dev ide_setup\n+```\n+\n+## lintcheck\n+`cargo lintcheck` will build and run clippy on a fixed set of crates and generate a log of the results.  \n+You can `git diff` the updated log against its previous version and \n+see what impact your lint made on a small set of crates.  \n+If you add a new lint, please audit the resulting warnings and make sure \n+there are no false positives and that the suggestions are valid.\n+\n+Refer to the tools [README] for more details.\n+\n+[README]: https://github.com/rust-lang/rust-clippy/blob/master/lintcheck/README.md\n+## PR\n+\n+We follow a rustc no merge-commit policy.\n+See <https://rustc-dev-guide.rust-lang.org/contributing.html#opening-a-pr>.\n+\n+## Common Abbreviations\n+\n+| Abbreviation | Meaning                                |\n+| ------------ | -------------------------------------- |\n+| UB           | Undefined Behavior                     |\n+| FP           | False Positive                         |\n+| FN           | False Negative                         |\n+| ICE          | Internal Compiler Error                |\n+| AST          | Abstract Syntax Tree                   |\n+| MIR          | Mid-Level Intermediate Representation  |\n+| HIR          | High-Level Intermediate Representation |\n+| TCX          | Type context                           |\n+\n+This is a concise list of abbreviations that can come up during Clippy development. An extensive\n+general list can be found in the [rustc-dev-guide glossary][glossary]. Always feel free to ask if\n+an abbreviation or meaning is unclear to you.\n+\n+## Install from source\n+\n+If you are hacking on Clippy and want to install it from source, do the following:\n+\n+First, take note of the toolchain [override](https://rust-lang.github.io/rustup/overrides.html) in `/rust-toolchain`.\n+We will use this override to install Clippy into the right toolchain.\n+\n+> Tip: You can view the active toolchain for the current directory with `rustup show active-toolchain`.\n+\n+From the Clippy project root, run the following command to build the Clippy binaries and copy them into the\n+toolchain directory. This will override the currently installed Clippy component.\n+\n+```terminal\n+cargo build --release --bin cargo-clippy --bin clippy-driver -Zunstable-options --out-dir \"$(rustc --print=sysroot)/bin\"\n+```\n+\n+Now you may run `cargo clippy` in any project, using the toolchain where you just installed Clippy.\n+\n+```terminal\n+cd my-project\n+cargo +nightly-2021-07-01 clippy\n+```\n+\n+...or `clippy-driver`\n+\n+```terminal\n+clippy-driver +nightly-2021-07-01 <filename>\n+```\n+\n+If you need to restore the default Clippy installation, run the following (from the Clippy project root).\n+\n+```terminal\n+rustup component remove clippy\n+rustup component add clippy\n+```\n+\n+> **DO NOT** install using `cargo install --path . --force` since this will overwrite rustup\n+> [proxies](https://rust-lang.github.io/rustup/concepts/proxies.html). That is, `~/.cargo/bin/cargo-clippy` and\n+> `~/.cargo/bin/clippy-driver` should be hard or soft links to `~/.cargo/bin/rustup`. You can repair these by running\n+> `rustup update`.\n+ \n+ \n+[glossary]: https://rustc-dev-guide.rust-lang.org/appendix/glossary.html"}, {"sha": "0a85f65001101c4fa5a172ac462b73d781e5e125", "filename": "book/src/development/common_tools_writing_lints.md", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fcommon_tools_writing_lints.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,203 @@\n+# Common tools for writing lints\n+\n+You may need following tooltips to catch up with common operations.\n+\n+- [Common tools for writing lints](#common-tools-for-writing-lints)\n+  - [Retrieving the type of an expression](#retrieving-the-type-of-an-expression)\n+  - [Checking if an expression is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n+  - [Checking if a type implements a specific trait](#checking-if-a-type-implements-a-specific-trait)\n+  - [Checking if a type defines a specific method](#checking-if-a-type-defines-a-specific-method)\n+  - [Dealing with macros](#dealing-with-macros)\n+\n+Useful Rustc dev guide links:\n+- [Stages of compilation](https://rustc-dev-guide.rust-lang.org/compiler-src.html#the-main-stages-of-compilation)\n+- [Type checking](https://rustc-dev-guide.rust-lang.org/type-checking.html)\n+- [Ty module](https://rustc-dev-guide.rust-lang.org/ty.html)\n+\n+# Retrieving the type of an expression\n+\n+Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for example to answer following questions:\n+\n+- which type does this expression correspond to (using its [`TyKind`][TyKind])?\n+- is it a sized type?\n+- is it a primitive type?\n+- does it implement a trait?\n+\n+This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckResults`][TypeckResults] struct,\n+that gives you access to the underlying structure [`TyS`][TyS].\n+\n+Example of use:\n+```rust\n+impl LateLintPass<'_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        // Get type of `expr`\n+        let ty = cx.typeck_results().expr_ty(expr);\n+        // Match its kind to enter its type\n+        match ty.kind {\n+            ty::Adt(adt_def, _) if adt_def.is_struct() => println!(\"Our `expr` is a struct!\"),\n+            _ => ()\n+        }\n+    }\n+}\n+```\n+\n+Similarly in [`TypeckResults`][TypeckResults] methods, you have the [`pat_ty()`][pat_ty] method\n+to retrieve a type from a pattern.\n+\n+Two noticeable items here:\n+- `cx` is the lint context [`LateContext`][LateContext]. The two most useful\n+  data structures in this context are `tcx` and the `TypeckResults` returned by\n+  `LateContext::typeck_results`, allowing us to jump to type definitions and\n+  other compilation stages such as HIR.\n+- `typeck_results`'s return value is [`TypeckResults`][TypeckResults] and is\n+  created by type checking step, it includes useful information such as types\n+  of expressions, ways to resolve methods and so on.\n+\n+# Checking if an expr is calling a specific method\n+\n+Starting with an `expr`, you can check whether it is calling a specific method `some_method`:\n+\n+```rust\n+impl LateLintPass<'_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            // Check our expr is calling a method\n+            if let hir::ExprKind::MethodCall(path, _, _args, _) = &expr.kind;\n+            // Check the name of this method is `some_method`\n+            if path.ident.name == sym!(some_method);\n+            then {\n+                // ...\n+            }\n+        }\n+    }\n+}\n+```\n+\n+# Checking if a type implements a specific trait\n+\n+There are two ways to do this, depending if the target trait is part of lang items.\n+\n+```rust\n+use clippy_utils::{implements_trait, match_trait_method, paths};\n+\n+impl LateLintPass<'_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        // 1. Using expression and Clippy's convenient method\n+        // we use `match_trait_method` function from Clippy's toolbox\n+        if match_trait_method(cx, expr, &paths::INTO) {\n+            // `expr` implements `Into` trait\n+        }\n+\n+        // 2. Using type context `TyCtxt`\n+        let ty = cx.typeck_results().expr_ty(expr);\n+        if cx.tcx.lang_items()\n+            // we are looking for the `DefId` of `Drop` trait in lang items\n+            .drop_trait()\n+            // then we use it with our type `ty` by calling `implements_trait` from Clippy's utils\n+            .map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n+                // `expr` implements `Drop` trait\n+            }\n+    }\n+}\n+```\n+\n+> Prefer using lang items, if the target trait is available there.\n+\n+A list of defined paths for Clippy can be found in [paths.rs][paths]\n+\n+We access lang items through the type context `tcx`. `tcx` is of type [`TyCtxt`][TyCtxt] and is defined in the `rustc_middle` crate.\n+\n+# Checking if a type defines a specific method\n+\n+To check if our type defines a method called `some_method`:\n+\n+```rust\n+use clippy_utils::{is_type_diagnostic_item, return_ty};\n+\n+impl<'tcx> LateLintPass<'tcx> for MyTypeImpl {\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n+        if_chain! {\n+            // Check if item is a method/function\n+            if let ImplItemKind::Fn(ref signature, _) = impl_item.kind;\n+            // Check the method is named `some_method`\n+            if impl_item.ident.name == sym!(some_method);\n+            // We can also check it has a parameter `self`\n+            if signature.decl.implicit_self.has_implicit_self();\n+            // We can go further and even check if its return type is `String`\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(string_type));\n+            then {\n+                // ...\n+            }\n+        }\n+    }\n+}\n+```\n+\n+# Dealing with macros\n+\n+There are several helpers in [`clippy_utils`][utils] to deal with macros:\n+\n+- `in_macro()`: detect if the given span is expanded by a macro\n+\n+You may want to use this for example to not start linting in any macro.\n+\n+```rust\n+macro_rules! foo {\n+    ($param:expr) => {\n+        match $param {\n+            \"bar\" => println!(\"whatever\"),\n+            _ => ()\n+        }\n+    };\n+}\n+\n+foo!(\"bar\");\n+\n+// if we lint the `match` of `foo` call and test its span\n+assert_eq!(in_macro(match_span), true);\n+```\n+\n+- `in_external_macro()`: detect if the given span is from an external macro, defined in a foreign crate\n+\n+You may want to use it for example to not start linting in macros from other crates\n+\n+```rust\n+#[macro_use]\n+extern crate a_crate_with_macros;\n+\n+// `foo` is defined in `a_crate_with_macros`\n+foo!(\"bar\");\n+\n+// if we lint the `match` of `foo` call and test its span\n+assert_eq!(in_external_macro(cx.sess(), match_span), true);\n+```\n+\n+- `differing_macro_contexts()`: returns true if the two given spans are not from the same context\n+\n+```rust\n+macro_rules! m {\n+    ($a:expr, $b:expr) => {\n+        if $a.is_some() {\n+            $b;\n+        }\n+    }\n+}\n+\n+let x: Option<u32> = Some(42);\n+m!(x, x.unwrap());\n+\n+// These spans are not from the same context\n+// x.is_some() is from inside the macro\n+// x.unwrap() is from outside the macro\n+assert_eq!(differing_macro_contexts(x_is_some_span, x_unwrap_span), true);\n+```\n+\n+[TyS]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html\n+[TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n+[TypeckResults]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html\n+[expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty\n+[LateContext]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/struct.LateContext.html\n+[TyCtxt]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html\n+[pat_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TypeckResults.html#method.pat_ty\n+[paths]: ../clippy_utils/src/paths.rs\n+[utils]: https://github.com/rust-lang/rust-clippy/blob/master/clippy_utils/src/lib.rs"}, {"sha": "2b4e5f6a6efe00d3dcffcdacc9e3b8466e7cdd31", "filename": "book/src/infrastructure/README.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finfrastructure%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finfrastructure%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Finfrastructure%2FREADME.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1 @@\n+# Infrastructure"}, {"sha": "15f3d1f080604d7286cf870a66569b9f123e287d", "filename": "book/src/infrastructure/backport.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finfrastructure%2Fbackport.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finfrastructure%2Fbackport.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Finfrastructure%2Fbackport.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,71 @@\n+# Backport Changes\n+\n+Sometimes it is necessary to backport changes to the beta release of Clippy.\n+Backports in Clippy are rare and should be approved by the Clippy team. For\n+example, a backport is done, if a crucial ICE was fixed or a lint is broken to a\n+point, that it has to be disabled, before landing on stable.\n+\n+Backports are done to the `beta` branch of Clippy. Backports to stable Clippy\n+releases basically don't exist, since this would require a Rust point release,\n+which is almost never justifiable for a Clippy fix.\n+\n+\n+## Backport the changes\n+\n+Backports are done on the beta branch of the Clippy repository.\n+\n+```bash\n+# Assuming the current directory corresponds to the Clippy repository\n+$ git checkout beta\n+$ git checkout -b backport\n+$ git cherry-pick <SHA>  # `<SHA>` is the commit hash of the commit(s), that should be backported\n+$ git push origin backport\n+```\n+\n+Now you should test that the backport passes all the tests in the Rust\n+repository. You can do this with:\n+\n+```bash\n+# Assuming the current directory corresponds to the Rust repository\n+$ git checkout beta\n+$ git subtree pull -p src/tools/clippy https://github.com/<your-github-name>/rust-clippy backport\n+$ ./x.py test src/tools/clippy\n+```\n+\n+Should the test fail, you can fix Clippy directly in the Rust repository. This\n+has to be first applied to the Clippy beta branch and then again synced to the\n+Rust repository, though. The easiest way to do this is:\n+\n+```bash\n+# In the Rust repository\n+$ git diff --patch --relative=src/tools/clippy > clippy.patch\n+# In the Clippy repository\n+$ git apply /path/to/clippy.patch\n+$ git add -u\n+$ git commit -m \"Fix rustup fallout\"\n+$ git push origin backport\n+```\n+\n+After this, you can open a PR to the `beta` branch of the Clippy repository.\n+\n+\n+## Update Clippy in the Rust Repository\n+\n+This step must be done, **after** the PR of the previous step was merged.\n+\n+After the backport landed in the Clippy repository, the branch has to be synced\n+back to the beta branch of the Rust repository.\n+\n+```bash\n+# Assuming the current directory corresponds to the Rust repository\n+$ git checkout beta\n+$ git checkout -b clippy_backport\n+$ git subtree pull -p src/tools/clippy https://github.com/rust-lang/rust-clippy beta\n+$ git push origin clippy_backport\n+```\n+\n+Make sure to test the backport in the Rust repository before opening a PR. This\n+is done with `./x.py test src/tools/clippy`. If that passes all tests, open a PR\n+to the `beta` branch of the Rust repository. In this PR you should tag the\n+Clippy team member, that agreed to the backport or the `@rust-lang/clippy` team.\n+Make sure to add `[beta]` to the title of the PR."}, {"sha": "056d54b679243e93c5b0d9082bf1d5ca31d0ad70", "filename": "book/src/infrastructure/book.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finfrastructure%2Fbook.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finfrastructure%2Fbook.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Finfrastructure%2Fbook.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,38 @@\n+# The Clippy Book\n+\n+This document explains how to make additions and changes to the Clippy book, the guide to Clippy that you're reading\n+right now. The Clippy book is formatted with [Markdown](https://www.markdownguide.org) and generated\n+by [mdbook](https://github.com/rust-lang/mdBook).\n+\n+- [Get mdbook](#get-mdbook)\n+- [Make changes](#make-changes)\n+\n+## Get mdbook\n+\n+While not strictly necessary since the book source is simply Markdown text files, having mdbook locally will allow you\n+to build, test and serve the book locally to view changes before you commit them to the repository. You likely already\n+have\n+`cargo` installed, so the easiest option is to simply:\n+\n+```shell\n+cargo install mdbook\n+```\n+\n+See the mdbook [installation](https://github.com/rust-lang/mdBook#installation) instructions for other options.\n+\n+## Make changes\n+\n+The book's [src](https://github.com/joshrotenberg/rust-clippy/tree/clippy_guide/book/src) directory contains all of the\n+markdown files used to generate the book. If you want to see your changes in real time, you can use the mdbook `serve`\n+command to run a web server locally that will automatically update changes as they are made. From the top level of\n+your `rust-clippy`\n+directory:\n+\n+```shell\n+mdbook serve book --open\n+```\n+\n+Then navigate to `http://localhost:3000` to see the generated book. While the server is running, changes you make will\n+automatically be updated.\n+\n+For more information, see the mdbook [guide](https://rust-lang.github.io/mdBook/)."}, {"sha": "115848c48044ce19000414b2923ba5f1fc5f3e4e", "filename": "book/src/infrastructure/changelog_update.md", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finfrastructure%2Fchangelog_update.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finfrastructure%2Fchangelog_update.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Finfrastructure%2Fchangelog_update.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,97 @@\n+# Changelog Update\n+\n+If you want to help with updating the [changelog][changelog], you're in the right place.\n+\n+## When to update\n+\n+Typos and other small fixes/additions are _always_ welcome.\n+\n+Special care needs to be taken when it comes to updating the changelog for a new\n+Rust release. For that purpose, the changelog is ideally updated during the week\n+before an upcoming stable release. You can find the release dates on the [Rust\n+Forge][forge].\n+\n+Most of the time we only need to update the changelog for minor Rust releases. It's\n+been very rare that Clippy changes were included in a patch release.\n+\n+## Changelog update walkthrough\n+\n+### 1. Finding the relevant Clippy commits\n+\n+Each Rust release ships with its own version of Clippy. The Clippy subtree can\n+be found in the `tools` directory of the Rust repository.\n+\n+Depending on the current time and what exactly you want to update, the following\n+bullet points might be helpful:\n+\n+* When writing the release notes for the **upcoming stable release** you need to check\n+  out the Clippy commit of the current Rust `beta` branch. [Link][rust_beta_tools]\n+* When writing the release notes for the **upcoming beta release**, you need to check\n+  out the Clippy commit of the current Rust `master`. [Link][rust_master_tools]\n+* When writing the (forgotten) release notes for a **past stable release**, you\n+  need to check out the Rust release tag of the stable release.\n+  [Link][rust_stable_tools]\n+\n+Usually you want to wirte the changelog of the **upcoming stable release**. Make\n+sure though, that `beta` was already branched in the Rust repository.\n+\n+To find the commit hash, issue the following command when in a `rust-lang/rust` checkout:\n+```\n+git log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\"\n+```\n+\n+### 2. Fetching the PRs between those commits\n+\n+Once you've got the correct commit range, run\n+\n+    util/fetch_prs_between.sh commit1 commit2 > changes.txt\n+\n+and open that file in your editor of choice.\n+\n+When updating the changelog it's also a good idea to make sure that `commit1` is\n+already correct in the current changelog.\n+\n+### 3. Authoring the final changelog\n+\n+The above script should have dumped all the relevant PRs to the file you\n+specified. It should have filtered out most of the irrelevant PRs\n+already, but it's a good idea to do a manual cleanup pass where you look for\n+more irrelevant PRs. If you're not sure about some PRs, just leave them in for\n+the review and ask for feedback.\n+\n+With the PRs filtered, you can start to take each PR and move the\n+`changelog: ` content to `CHANGELOG.md`. Adapt the wording as you see fit but\n+try to keep it somewhat coherent.\n+\n+The order should roughly be:\n+\n+1. New lints\n+2. Moves or deprecations of lints\n+3. Changes that expand what code existing lints cover\n+4. False positive fixes\n+5. Suggestion fixes/improvements\n+6. ICE fixes\n+7. Documentation improvements\n+8. Others\n+\n+As section headers, we use:\n+\n+```\n+### New Lints\n+### Moves and Deprecations\n+### Enhancements\n+### False Positive Fixes\n+### Suggestion Fixes/Improvements\n+### ICE Fixes\n+### Documentation Improvements\n+### Others\n+```\n+\n+Please also be sure to update the Beta/Unreleased sections at the top with the\n+relevant commit ranges.\n+\n+[changelog]: https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md\n+[forge]: https://forge.rust-lang.org/\n+[rust_master_tools]: https://github.com/rust-lang/rust/tree/master/src/tools/clippy\n+[rust_beta_tools]: https://github.com/rust-lang/rust/tree/beta/src/tools/clippy\n+[rust_stable_tools]: https://github.com/rust-lang/rust/releases"}, {"sha": "afe3033c288cffd8d95b06ea2e833989455cb81a", "filename": "book/src/infrastructure/release.md", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finfrastructure%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finfrastructure%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Finfrastructure%2Frelease.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,124 @@\n+# Release a new Clippy Version\n+\n+_NOTE: This document is probably only relevant to you, if you're a member of the\n+Clippy team._\n+\n+Clippy is released together with stable Rust releases. The dates for these\n+releases can be found at the [Rust Forge]. This document explains the necessary\n+steps to create a Clippy release.\n+\n+1. [Remerge the `beta` branch](#remerge-the-beta-branch)\n+2. [Update the `beta` branch](#update-the-beta-branch)\n+3. [Find the Clippy commit](#find-the-clippy-commit)\n+4. [Tag the stable commit](#tag-the-stable-commit)\n+5. [Update `CHANGELOG.md`](#update-changelogmd)\n+\n+_NOTE: This document is for stable Rust releases, not for point releases. For\n+point releases, step 1. and 2. should be enough._\n+\n+[Rust Forge]: https://forge.rust-lang.org/\n+\n+\n+## Remerge the `beta` branch\n+\n+This step is only necessary, if since the last release something was backported\n+to the beta Rust release. The remerge is then necessary, to make sure that the\n+Clippy commit, that was used by the now stable Rust release, persists in the\n+tree of the Clippy repository.\n+\n+To find out if this step is necessary run\n+\n+```bash\n+# Assumes that the local master branch is up-to-date\n+$ git fetch upstream\n+$ git branch master --contains upstream/beta\n+```\n+\n+If this command outputs `master`, this step is **not** necessary.\n+\n+```bash\n+# Assuming `HEAD` is the current `master` branch of rust-lang/rust-clippy\n+$ git checkout -b backport_remerge\n+$ git merge upstream/beta\n+$ git diff  # This diff has to be empty, otherwise something with the remerge failed\n+$ git push origin backport_remerge  # This can be pushed to your fork\n+```\n+\n+After this, open a PR to the master branch. In this PR, the commit hash of the\n+`HEAD` of the `beta` branch must exists. In addition to that, no files should\n+be changed by this PR.\n+\n+\n+## Update the `beta` branch\n+\n+This step must be done **after** the PR of the previous step was merged.\n+\n+First, the Clippy commit of the `beta` branch of the Rust repository has to be\n+determined.\n+\n+```bash\n+# Assuming the current directory corresponds to the Rust repository\n+$ git checkout beta\n+$ BETA_SHA=$(git log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\")\n+```\n+\n+After finding the Clippy commit, the `beta` branch in the Clippy repository can\n+be updated.\n+\n+```bash\n+# Assuming the current directory corresponds to the Clippy repository\n+$ git checkout beta\n+$ git reset --hard $BETA_SHA\n+$ git push upstream beta\n+```\n+\n+\n+## Find the Clippy commit\n+\n+The first step is to tag the Clippy commit, that is included in the stable Rust\n+release. This commit can be found in the Rust repository.\n+\n+```bash\n+# Assuming the current directory corresponds to the Rust repository\n+$ git fetch upstream    # `upstream` is the `rust-lang/rust` remote\n+$ git checkout 1.XX.0   # XX should be exchanged with the corresponding version\n+$ SHA=$(git log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\")\n+```\n+\n+\n+## Tag the stable commit\n+\n+After finding the Clippy commit, it can be tagged with the release number.\n+\n+```bash\n+# Assuming the current directory corresponds to the Clippy repository\n+$ git checkout $SHA\n+$ git tag rust-1.XX.0               # XX should be exchanged with the corresponding version\n+$ git push upstream rust-1.XX.0     # `upstream` is the `rust-lang/rust-clippy` remote\n+```\n+\n+After this, the release should be available on the Clippy [release page].\n+\n+[release page]: https://github.com/rust-lang/rust-clippy/releases\n+\n+## Update the `stable` branch\n+\n+At this step you should have already checked out the commit of the `rust-1.XX.0`\n+tag. Updating the stable branch from here is as easy as:\n+\n+```bash\n+# Assuming the current directory corresponds to the Clippy repository and the\n+# commit of the just created rust-1.XX.0 tag is checked out.\n+$ git push upstream rust-1.XX.0:stable  # `upstream` is the `rust-lang/rust-clippy` remote\n+```\n+\n+_NOTE: Usually there are no stable backports for Clippy, so this update should\n+be possible without force pushing or anything like this. If there should have\n+happened a stable backport, make sure to re-merge those changes just as with the\n+`beta` branch._\n+\n+## Update `CHANGELOG.md`\n+\n+For this see the document on [how to update the changelog].\n+\n+[how to update the changelog]: https://github.com/rust-lang/rust-clippy/blob/master/doc/changelog_update.md"}, {"sha": "190c8ed5342ab962534bd62daa2e96a78ca89597", "filename": "book/src/installation_and_usage.md", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finstallation_and_usage.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Finstallation_and_usage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Finstallation_and_usage.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,108 @@\n+# Installation and Usage\n+\n+Below are instructions on how to use Clippy as a subcommand, compiled from source\n+or in Travis CI. Note that Clippy is installed as a \n+[component](https://rust-lang.github.io/rustup/concepts/components.html?highlight=clippy#components) as part of the \n+[rustup](https://rust-lang.github.io/rustup/installation/index.html) installation.\n+\n+### As a cargo subcommand (`cargo clippy`)\n+\n+One way to use Clippy is by installing Clippy through rustup as a cargo\n+subcommand.\n+\n+#### Step 1: Install rustup\n+\n+You can install [rustup](https://rustup.rs/) on supported platforms. This will help\n+us install Clippy and its dependencies.\n+\n+If you already have rustup installed, update to ensure you have the latest\n+rustup and compiler:\n+\n+```terminal\n+rustup update\n+```\n+\n+#### Step 2: Install Clippy\n+\n+Once you have rustup and the latest stable release (at least Rust 1.29) installed, run the following command:\n+\n+```terminal\n+rustup component add clippy\n+```\n+If it says that it can't find the `clippy` component, please run `rustup self update`.\n+\n+#### Step 3: Run Clippy\n+\n+Now you can run Clippy by invoking the following command:\n+\n+```terminal\n+cargo clippy\n+```\n+\n+#### Automatically applying Clippy suggestions\n+\n+Clippy can automatically apply some lint suggestions.\n+Note that this is still experimental and only supported on the nightly channel:\n+\n+```terminal\n+cargo clippy --fix\n+```\n+\n+#### Workspaces\n+\n+All the usual workspace options should work with Clippy. For example the following command\n+will run Clippy on the `example` crate:\n+\n+```terminal\n+cargo clippy -p example\n+```\n+\n+As with `cargo check`, this includes dependencies that are members of the workspace, like path dependencies.\n+If you want to run Clippy **only** on the given crate, use the `--no-deps` option like this:\n+\n+```terminal\n+cargo clippy -p example --no-deps \n+```\n+\n+### As a rustc replacement (`clippy-driver`)\n+\n+Clippy can also be used in projects that do not use cargo. To do so, you will need to replace\n+your `rustc` compilation commands with `clippy-driver`. For example, if your project runs:\n+\n+```terminal\n+rustc --edition 2018 -Cpanic=abort foo.rs\n+```\n+\n+Then, to enable Clippy, you will need to call:\n+\n+```terminal\n+clippy-driver --edition 2018 -Cpanic=abort foo.rs\n+```\n+\n+Note that `rustc` will still run, i.e. it will still emit the output files it normally does.\n+\n+### Travis CI\n+\n+You can add Clippy to Travis CI in the same way you use it locally:\n+\n+```yml\n+language: rust\n+rust:\n+  - stable\n+  - beta\n+before_script:\n+  - rustup component add clippy\n+script:\n+  - cargo clippy\n+  # if you want the build job to fail when encountering warnings, use\n+  - cargo clippy -- -D warnings\n+  # in order to also check tests and non-default crate features, use\n+  - cargo clippy --all-targets --all-features -- -D warnings\n+  - cargo test\n+  # etc.\n+```\n+\n+Note that adding `-D warnings` will cause your build to fail if **any** warnings are found in your code.\n+That includes warnings found by rustc (e.g. `dead_code`, etc.). If you want to avoid this and only cause\n+an error for Clippy warnings, use `#![deny(clippy::all)]` in your code or `-D clippy::all` on the command\n+line. (You can swap `clippy::all` with the specific lint category you are targeting.)"}, {"sha": "a2777e8f4d5830347c4b92356e2cf1d2cbed8bd0", "filename": "book/src/lints/README.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints%2FREADME.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1 @@\n+# Clippy's Lints"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "book/src/lints/cargo.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fcargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fcargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints%2Fcargo.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "book/src/lints/complexity.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fcomplexity.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fcomplexity.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints%2Fcomplexity.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "book/src/lints/correctness.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fcorrectness.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fcorrectness.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints%2Fcorrectness.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "book/src/lints/deprecated.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fdeprecated.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fdeprecated.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints%2Fdeprecated.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "book/src/lints/nursery.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fnursery.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fnursery.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints%2Fnursery.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "book/src/lints/pedantic.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fpedantic.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fpedantic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints%2Fpedantic.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "book/src/lints/perf.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fperf.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fperf.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints%2Fperf.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "book/src/lints/restriction.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Frestriction.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Frestriction.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints%2Frestriction.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "book/src/lints/style.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Flints%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Flints%2Fstyle.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b"}, {"sha": "fe8b080f56f2bc0c518c7b3e2049def4eed5b9f1", "filename": "book/src/roadmap/2021.md", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Froadmap%2F2021.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Froadmap%2F2021.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Froadmap%2F2021.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b", "patch": "@@ -0,0 +1,235 @@\n+# Roadmap 2021\n+\n+# Summary\n+\n+This Roadmap lays out the plans for Clippy in 2021:\n+\n+- Improving usability and reliability\n+- Improving experience of contributors and maintainers\n+- Develop and specify processes\n+\n+Members of the Clippy team will be assigned tasks from one or more of these\n+topics. The team member is then responsible to complete the assigned tasks. This\n+can either be done by implementing them or by providing mentorship to interested\n+contributors.\n+\n+# Motivation\n+\n+With the ongoing growth of the Rust language and with that of the whole\n+ecosystem, also Clippy gets more and more users and contributors. This is good\n+for the project, but also brings challenges along. Some of these challenges are:\n+\n+- More issues about reliability or usability are popping up\n+- Traffic is hard to handle for a small team\n+- Bigger projects don't get completed due to the lack of processes and/or time\n+  of the team members\n+\n+Additionally, according to the [Rust Roadmap 2021], clear processes should be\n+defined by every team and unified across teams. This Roadmap is the first step\n+towards this.\n+\n+[Rust Roadmap 2021]: https://github.com/rust-lang/rfcs/pull/3037\n+\n+# Explanation\n+\n+This section will explain the things that should be done in 2021. It is\n+important to note, that this document focuses on the \"What?\", not the \"How?\".\n+The later will be addressed in follow-up tracking issue, with an assigned team\n+member.\n+\n+The following is split up in two major sections. The first section covers the\n+user facing plans, the second section the internal plans.\n+\n+## User Facing\n+\n+Clippy should be as pleasant to use and configure as possible. This section\n+covers plans that should be implemented to improve the situation of Clippy in\n+this regard.\n+\n+### Usability\n+\n+In the following, plans to improve the usability are covered.\n+\n+#### No Output After `cargo check`\n+\n+Currently when `cargo clippy` is run after `cargo check`, it does not produce\n+any output. This is especially problematic since `rust-analyzer` is on the rise\n+and it uses `cargo check` for checking code. A fix is already implemented, but\n+it still has to be pushed over the finish line. This also includes the\n+stabilization of the `cargo clippy --fix` command or the support of multi-span\n+suggestions in `rustfix`.\n+\n+- [#4612](https://github.com/rust-lang/rust-clippy/issues/4612)\n+\n+#### `lints.toml` Configuration\n+\n+This is something that comes up every now and then: a reusable configuration\n+file, where lint levels can be defined. Discussions about this often lead to\n+nothing specific or to \"we need an RFC for this\". And this is exactly what needs\n+to be done. Get together with the cargo team and write an RFC and implement such\n+a configuration file somehow and somewhere.\n+\n+- [#3164](https://github.com/rust-lang/rust-clippy/issues/3164)\n+- [cargo#5034](https://github.com/rust-lang/cargo/issues/5034)\n+- [IRLO](https://internals.rust-lang.org/t/proposal-cargo-lint-configuration/9135/8)\n+\n+#### Lint Groups\n+\n+There are more and more issues about managing lints in Clippy popping up. Lints\n+are hard to implement with a guarantee of no/few false positives (FPs). One way\n+to address this might be to introduce more lint groups to give users the ability\n+to better manage lints, or improve the process of classifying lints, so that\n+disabling lints due to FPs becomes rare. It is important to note, that Clippy\n+lints are less conservative than `rustc` lints, which won't change in the\n+future.\n+\n+- [#5537](https://github.com/rust-lang/rust-clippy/issues/5537)\n+- [#6366](https://github.com/rust-lang/rust-clippy/issues/6366)\n+\n+### Reliability\n+\n+In the following, plans to improve the reliability are covered.\n+\n+#### False Positive Rate\n+\n+In the worst case, new lints are only available in nightly for 2 weeks, before\n+hitting beta and ultimately stable. This and the fact that fewer people use\n+nightly Rust nowadays makes it more probable that a lint with many FPs hits\n+stable. This leads to annoyed users, that will disable these new lints in the\n+best case and to more annoyed users, that will stop using Clippy in the worst.\n+A process should be developed and implemented to prevent this from happening.\n+\n+- [#6429](https://github.com/rust-lang/rust-clippy/issues/6429)\n+\n+## Internal\n+\n+(The end of) 2020 has shown, that Clippy has to think about the available\n+resources, especially regarding management and maintenance of the project. This\n+section address issues affecting team members and contributors.\n+\n+### Management\n+\n+In 2020 Clippy achieved over 1000 open issues with regularly between 25-35 open\n+PRs. This is simultaneously a win and a loss. More issues and PRs means more\n+people are interested in Clippy and in contributing to it. On the other hand, it\n+means for team members more work and for contributors longer wait times for\n+reviews. The following will describe plans how to improve the situation for both\n+team members and contributors.\n+\n+#### Clear Expectations for Team Members\n+\n+According to the [Rust Roadmap 2021], a document specifying what it means to be\n+a member of the team should be produced. This should not put more pressure on\n+the team members, but rather help them and interested folks to know what the\n+expectations are. With this it should also be easier to recruit new team members\n+and may encourage people to get in touch, if they're interested to join.\n+\n+#### Scaling up the Team\n+\n+More people means less work for each individual. Together with the document\n+about expectations for team members, a document defining the process of how to\n+join the team should be produced. This can also increase the stability of the\n+team, in case of current members dropping out (temporarily). There can also be\n+different roles in the team, like people triaging vs. people reviewing.\n+\n+#### Regular Meetings\n+\n+Other teams have regular meetings. Clippy is big enough that it might be worth\n+to also do them. Especially if more people join the team, this can be important\n+for sync-ups. Besides the asynchronous communication, that works well for\n+working on separate lints, a meeting adds a synchronous alternative at a known\n+time. This is especially helpful if there are bigger things that need to be\n+discussed (like the projects in this roadmap). For starters bi-weekly meetings\n+before Rust syncs might make sense.\n+\n+#### Triaging\n+\n+To get a handle on the influx of open issues, a process for triaging issues and\n+PRs should be developed. Officially, Clippy follows the Rust triage process, but\n+currently no one enforces it. This can be improved by sharing triage teams\n+across projects or by implementing dashboards / tools which simplify triaging.\n+\n+### Development\n+\n+Improving the developer and contributor experience is something the Clippy team\n+works on regularly. Though, some things might need special attention and\n+planing. These topics are listed in the following.\n+\n+#### Process for New and Existing Lints\n+\n+As already mentioned above, classifying new lints gets quite hard, because the\n+probability of a buggy lint getting into stable is quite high. A process should\n+be implemented on how to classify lints. In addition, a test system should be\n+developed to find out which lints are currently problematic in real world code\n+to fix or disable them.\n+\n+- [#6429 (comment)](https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741056379)\n+- [#6429 (comment)](https://github.com/rust-lang/rust-clippy/issues/6429#issuecomment-741153345)\n+\n+#### Processes\n+\n+Related to the point before, a process for suggesting and discussing major\n+changes should be implemented. It's also not clearly defined when a lint should\n+be enabled or disabled by default. This can also be improved by the test system\n+mentioned above.\n+\n+#### Dev-Tools\n+\n+There's already `cargo dev` which makes Clippy development easier and more\n+pleasant. This can still be expanded, so that it covers more areas of the\n+development process.\n+\n+- [#5394](https://github.com/rust-lang/rust-clippy/issues/5394)\n+\n+#### Contributor Guide\n+\n+Similar to a Clippy Book, which describes how to use Clippy, a book about how to\n+contribute to Clippy might be helpful for new and existing contributors. There's\n+already the `doc` directory in the Clippy repo, this can be turned into a\n+`mdbook`.\n+\n+#### `rustc` integration\n+\n+Recently Clippy was integrated with `git subtree` into the `rust-lang/rust`\n+repository. This made syncing between the two repositories easier. A\n+`#[non_exhaustive]` list of things that still can be improved is:\n+\n+1. Use the same `rustfmt` version and configuration as `rustc`.\n+2. Make `cargo dev` work in the Rust repo, just as it works in the Clippy repo.\n+   E.g. `cargo dev bless` or `cargo dev update_lints`. And even add more things\n+   to it that might be useful for the Rust repo, e.g. `cargo dev deprecate`.\n+3. Easier sync process. The `subtree` situation is not ideal.\n+\n+## Prioritization\n+\n+The most pressing issues for users of Clippy are of course the user facing\n+issues. So there should be a priority on those issues, but without losing track\n+of the internal issues listed in this document.\n+\n+Getting the FP rate of warn/deny-by-default lints under control should have the\n+highest priority. Other user facing issues should also get a high priority, but\n+shouldn't be in the way of addressing internal issues.\n+\n+To better manage the upcoming projects, the basic internal processes, like\n+meetings, tracking issues and documentation, should be established as soon as\n+possible. They might even be necessary to properly manage the projects,\n+regarding the user facing issues.\n+\n+# Prior Art\n+\n+## Rust Roadmap\n+\n+Rust's roadmap process was established by [RFC 1728] in 2016. Since then every\n+year a roadmap was published, that defined the bigger plans for the coming\n+years. This years roadmap can be found [here][Rust Roadmap 2021].\n+\n+[RFC 1728]: https://rust-lang.github.io/rfcs/1728-north-star.html\n+\n+# Drawbacks\n+\n+## Big Roadmap\n+\n+This roadmap is pretty big and not all items listed in this document might be\n+addressed during 2021. Because this is the first roadmap for Clippy, having open\n+tasks at the end of 2021 is fine, but they should be revisited in the 2022\n+roadmap."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "book/src/roadmap/README.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Froadmap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b/book%2Fsrc%2Froadmap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Froadmap%2FREADME.md?ref=4e6b55e9b8d64af5d14ed5465fdcf54c62ef3b8b"}]}