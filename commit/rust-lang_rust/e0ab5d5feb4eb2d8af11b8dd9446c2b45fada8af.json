{"sha": "e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwYWI1ZDVmZWI0ZWIyZDhhZjExYjhkZDk0NDZjMmI0NWZhZGE4YWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-12-16T16:20:54Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-12-18T19:44:00Z"}, "message": "rustc: Work around `DICompileUnit` bugs in LLVM\n\nThis commit implements a workaround for #46346 which basically just\navoids triggering the situation that LLVM's bug\nhttps://bugs.llvm.org/show_bug.cgi?id=35562 arises. More details can be\nfound in the code itself but this commit is also intended to ...\n\nCloses #46346", "tree": {"sha": "a502ff2d52a8329aa843e13780e95db3ad24625a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a502ff2d52a8329aa843e13780e95db3ad24625a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af", "html_url": "https://github.com/rust-lang/rust/commit/e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3a7203e2c9ed30a501da86f3fa1f9efe707ac94", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3a7203e2c9ed30a501da86f3fa1f9efe707ac94", "html_url": "https://github.com/rust-lang/rust/commit/a3a7203e2c9ed30a501da86f3fa1f9efe707ac94"}], "stats": {"total": 130, "additions": 130, "deletions": 0}, "files": [{"sha": "cb385923067c4a316d39281183ef8b54fb6d0a87", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af", "patch": "@@ -1728,4 +1728,8 @@ extern \"C\" {\n         Identifier: *const c_char,\n     ) -> ModuleRef;\n     pub fn LLVMGetModuleIdentifier(M: ModuleRef, size: *mut usize) -> *const c_char;\n+    pub fn LLVMRustThinLTOGetDICompileUnit(M: ModuleRef,\n+                                           CU1: *mut *mut c_void,\n+                                           CU2: *mut *mut c_void);\n+    pub fn LLVMRustThinLTOPatchDICompileUnit(M: ModuleRef, CU: *mut c_void);\n }"}, {"sha": "ba8c26bc819be435860edeaaa78b7fe66f16994c", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af", "patch": "@@ -26,6 +26,7 @@ use {ModuleTranslation, ModuleLlvm, ModuleKind, ModuleSource};\n use libc;\n \n use std::ffi::CString;\n+use std::ptr;\n use std::slice;\n use std::sync::Arc;\n \n@@ -629,6 +630,18 @@ impl ThinModule {\n         };\n         cgcx.save_temp_bitcode(&mtrans, \"thin-lto-input\");\n \n+        // Before we do much else find the \"main\" `DICompileUnit` that we'll be\n+        // using below. If we find more than one though then rustc has changed\n+        // in a way we're not ready for, so generate an ICE by returning\n+        // an error.\n+        let mut cu1 = ptr::null_mut();\n+        let mut cu2 = ptr::null_mut();\n+        llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n+        if !cu2.is_null() {\n+            let msg = format!(\"multiple source DICompileUnits found\");\n+            return Err(write::llvm_err(&diag_handler, msg))\n+        }\n+\n         // Like with \"fat\" LTO, get some better optimizations if landing pads\n         // are disabled by removing all landing pads.\n         if cgcx.no_landing_pads {\n@@ -670,6 +683,39 @@ impl ThinModule {\n         cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-import\");\n         timeline.record(\"import\");\n \n+        // Ok now this is a bit unfortunate. This is also something you won't\n+        // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n+        // work around bugs in LLVM.\n+        //\n+        // First discovered in #45511 it was found that as part of ThinLTO\n+        // importing passes LLVM will import `DICompileUnit` metadata\n+        // information across modules. This means that we'll be working with one\n+        // LLVM module that has multiple `DICompileUnit` instances in it (a\n+        // bunch of `llvm.dbg.cu` members). Unfortunately there's a number of\n+        // bugs in LLVM's backend which generates invalid DWARF in a situation\n+        // like this:\n+        //\n+        //  https://bugs.llvm.org/show_bug.cgi?id=35212\n+        //  https://bugs.llvm.org/show_bug.cgi?id=35562\n+        //\n+        // While the first bug there is fixed the second ended up causing #46346\n+        // which was basically a resurgence of #45511 after LLVM's bug 35212 was\n+        // fixed.\n+        //\n+        // This function below is a huge hack around tihs problem. The function\n+        // below is defined in `PassWrapper.cpp` and will basically \"merge\"\n+        // all `DICompileUnit` instances in a module. Basically it'll take all\n+        // the objects, rewrite all pointers of `DISubprogram` to point to the\n+        // first `DICompileUnit`, and then delete all the other units.\n+        //\n+        // This is probably mangling to the debug info slightly (but hopefully\n+        // not too much) but for now at least gets LLVM to emit valid DWARF (or\n+        // so it appears). Hopefully we can remove this once upstream bugs are\n+        // fixed in LLVM.\n+        llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n+        cgcx.save_temp_bitcode(&mtrans, \"thin-lto-after-patch\");\n+        timeline.record(\"patch\");\n+\n         // Alright now that we've done everything related to the ThinLTO\n         // analysis it's time to run some optimizations! Here we use the same\n         // `run_pass_manager` as the \"fat\" LTO above except that we tell it to"}, {"sha": "776e4a3e65ad55fb2b9baa28ccdeaf49305da9e9", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af", "patch": "@@ -1114,6 +1114,74 @@ LLVMRustParseBitcodeForThinLTO(LLVMContextRef Context,\n   return wrap(std::move(*SrcOrError).release());\n }\n \n+// Rewrite all `DICompileUnit` pointers to the `DICompileUnit` specified. See\n+// the comment in `back/lto.rs` for why this exists.\n+extern \"C\" void\n+LLVMRustThinLTOGetDICompileUnit(LLVMModuleRef Mod,\n+                                DICompileUnit **A,\n+                                DICompileUnit **B) {\n+  Module *M = unwrap(Mod);\n+  DICompileUnit **Cur = A;\n+  DICompileUnit **Next = B;\n+  for (DICompileUnit *CU : M->debug_compile_units()) {\n+    *Cur = CU;\n+    Cur = Next;\n+    Next = nullptr;\n+    if (Cur == nullptr)\n+      break;\n+  }\n+}\n+\n+// Rewrite all `DICompileUnit` pointers to the `DICompileUnit` specified. See\n+// the comment in `back/lto.rs` for why this exists.\n+extern \"C\" void\n+LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod, DICompileUnit *Unit) {\n+  Module *M = unwrap(Mod);\n+\n+  // If the original source module didn't have a `DICompileUnit` then try to\n+  // merge all the existing compile units. If there aren't actually any though\n+  // then there's not much for us to do so return.\n+  if (Unit == nullptr) {\n+    for (DICompileUnit *CU : M->debug_compile_units()) {\n+      Unit = CU;\n+      break;\n+    }\n+    if (Unit == nullptr)\n+      return;\n+  }\n+\n+  // Use LLVM's built-in `DebugInfoFinder` to find a bunch of debuginfo and\n+  // process it recursively. Note that we specifically iterate over instructions\n+  // to ensure we feed everything into it.\n+  DebugInfoFinder Finder;\n+  Finder.processModule(*M);\n+  for (Function &F : M->functions()) {\n+    for (auto &FI : F) {\n+      for (Instruction &BI : FI) {\n+        if (auto Loc = BI.getDebugLoc())\n+          Finder.processLocation(*M, Loc);\n+        if (auto DVI = dyn_cast<DbgValueInst>(&BI))\n+          Finder.processValue(*M, DVI);\n+        if (auto DDI = dyn_cast<DbgDeclareInst>(&BI))\n+          Finder.processDeclare(*M, DDI);\n+      }\n+    }\n+  }\n+\n+  // After we've found all our debuginfo, rewrite all subprograms to point to\n+  // the same `DICompileUnit`.\n+  for (auto &F : Finder.subprograms()) {\n+    F->replaceUnit(Unit);\n+  }\n+\n+  // Erase any other references to other `DICompileUnit` instances, the verifier\n+  // will later ensure that we don't actually have any other stale references to\n+  // worry about.\n+  auto *MD = M->getNamedMetadata(\"llvm.dbg.cu\");\n+  MD->clearOperands();\n+  MD->addOperand(Unit);\n+}\n+\n #else\n \n extern \"C\" bool\n@@ -1192,4 +1260,16 @@ LLVMRustParseBitcodeForThinLTO(LLVMContextRef Context,\n                                const char *identifier) {\n   report_fatal_error(\"ThinLTO not available\");\n }\n+\n+extern \"C\" void\n+LLVMRustThinLTOGetDICompileUnit(LLVMModuleRef Mod,\n+                                DICompileUnit **A,\n+                                DICompileUnit **B) {\n+  report_fatal_error(\"ThinLTO not available\");\n+}\n+\n+extern \"C\" void\n+LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod) {\n+  report_fatal_error(\"ThinLTO not available\");\n+}\n #endif // LLVM_VERSION_GE(4, 0)"}]}