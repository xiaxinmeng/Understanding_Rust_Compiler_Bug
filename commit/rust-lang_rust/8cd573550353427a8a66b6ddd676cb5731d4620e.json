{"sha": "8cd573550353427a8a66b6ddd676cb5731d4620e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZDU3MzU1MDM1MzQyN2E4YTY2YjZkZGQ2NzZjYjU3MzFkNDYyMGU=", "commit": {"author": {"name": "Marc-Antoine Perennou", "email": "Marc-Antoine@Perennou.com", "date": "2017-11-15T10:17:39Z"}, "committer": {"name": "Marc-Antoine Perennou", "email": "Marc-Antoine@Perennou.com", "date": "2017-11-16T09:51:23Z"}, "message": "rustbuild: use a macro to define \"extended\" tools\n\nSigned-off-by: Marc-Antoine Perennou <Marc-Antoine@Perennou.com>", "tree": {"sha": "081e870ac60fd9fabdefaac492fd72661a275f45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/081e870ac60fd9fabdefaac492fd72661a275f45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cd573550353427a8a66b6ddd676cb5731d4620e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cd573550353427a8a66b6ddd676cb5731d4620e", "html_url": "https://github.com/rust-lang/rust/commit/8cd573550353427a8a66b6ddd676cb5731d4620e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cd573550353427a8a66b6ddd676cb5731d4620e/comments", "author": {"login": "Keruspe", "id": 222942, "node_id": "MDQ6VXNlcjIyMjk0Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/222942?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Keruspe", "html_url": "https://github.com/Keruspe", "followers_url": "https://api.github.com/users/Keruspe/followers", "following_url": "https://api.github.com/users/Keruspe/following{/other_user}", "gists_url": "https://api.github.com/users/Keruspe/gists{/gist_id}", "starred_url": "https://api.github.com/users/Keruspe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Keruspe/subscriptions", "organizations_url": "https://api.github.com/users/Keruspe/orgs", "repos_url": "https://api.github.com/users/Keruspe/repos", "events_url": "https://api.github.com/users/Keruspe/events{/privacy}", "received_events_url": "https://api.github.com/users/Keruspe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Keruspe", "id": 222942, "node_id": "MDQ6VXNlcjIyMjk0Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/222942?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Keruspe", "html_url": "https://github.com/Keruspe", "followers_url": "https://api.github.com/users/Keruspe/followers", "following_url": "https://api.github.com/users/Keruspe/following{/other_user}", "gists_url": "https://api.github.com/users/Keruspe/gists{/gist_id}", "starred_url": "https://api.github.com/users/Keruspe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Keruspe/subscriptions", "organizations_url": "https://api.github.com/users/Keruspe/orgs", "repos_url": "https://api.github.com/users/Keruspe/repos", "events_url": "https://api.github.com/users/Keruspe/events{/privacy}", "received_events_url": "https://api.github.com/users/Keruspe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1410d5604042b739f02f9ec0f2a6c5125c797d52", "url": "https://api.github.com/repos/rust-lang/rust/commits/1410d5604042b739f02f9ec0f2a6c5125c797d52", "html_url": "https://github.com/rust-lang/rust/commit/1410d5604042b739f02f9ec0f2a6c5125c797d52"}], "stats": {"total": 185, "additions": 50, "deletions": 135}, "files": [{"sha": "eb403f88cb05f9a06fa7cdb0df956a5b119c6ca2", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 50, "deletions": 135, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/8cd573550353427a8a66b6ddd676cb5731d4620e/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cd573550353427a8a66b6ddd676cb5731d4620e/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=8cd573550353427a8a66b6ddd676cb5731d4620e", "patch": "@@ -403,71 +403,64 @@ impl Step for Cargo {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Clippy {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n+macro_rules! tool_extended {\n+    (($sel:ident, $builder:ident),\n+       $($name:ident,\n+       $toolstate:ident,\n+       $path:expr,\n+       $tool_name:expr,\n+       $extra_deps:block;)+) => {\n+        $(\n+            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+        pub struct $name {\n+            pub compiler: Compiler,\n+            pub target: Interned<String>,\n+        }\n \n-impl Step for Clippy {\n-    type Output = Option<PathBuf>;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n+        impl Step for $name {\n+            type Output = Option<PathBuf>;\n+            const DEFAULT: bool = true;\n+            const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/clippy\").default_condition(builder.build.config.extended)\n-    }\n+            fn should_run(run: ShouldRun) -> ShouldRun {\n+                let builder = run.builder;\n+                run.path($path).default_condition(builder.build.config.extended)\n+            }\n \n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Clippy {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n+            fn make_run(run: RunConfig) {\n+                run.builder.ensure($name {\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+                    target: run.target,\n+                });\n+            }\n+\n+            fn run($sel, $builder: &Builder) -> Option<PathBuf> {\n+                $extra_deps\n+                $builder.ensure(ToolBuild {\n+                    compiler: $sel.compiler,\n+                    target: $sel.target,\n+                    tool: $tool_name,\n+                    mode: Mode::Librustc,\n+                    path: $path,\n+                    expectation: $builder.build.config.toolstate.$toolstate.passes(ToolState::Compiling),\n+                })\n+            }\n+        }\n+        )+\n     }\n+}\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+tool_extended!((self, builder),\n+    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n         // Clippy depends on procedural macros (serde), which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n             compiler: self.compiler,\n             target: builder.build.build,\n         });\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"clippy-driver\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/clippy\",\n-            expectation: builder.build.config.toolstate.clippy.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rls {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Rls {\n-    type Output = Option<PathBuf>;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/rls\").default_condition(builder.build.config.extended)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rls {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    };\n+    Miri, miri, \"src/tools/miri\", \"miri\", {};\n+    Rls, rls, \"src/tools/rls\", \"rls\", {\n         builder.ensure(native::Openssl {\n             target: self.target,\n         });\n@@ -477,87 +470,9 @@ impl Step for Rls {\n             compiler: self.compiler,\n             target: builder.build.build,\n         });\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"rls\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/rls\",\n-            expectation: builder.build.config.toolstate.rls.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rustfmt {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Rustfmt {\n-    type Output = Option<PathBuf>;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/rustfmt\").default_condition(builder.build.config.extended)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rustfmt {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"rustfmt\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/rustfmt\",\n-            expectation: builder.build.config.toolstate.rustfmt.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n-\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Miri {\n-    pub compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Miri {\n-    type Output = Option<PathBuf>;\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let build_miri = run.builder.build.config.test_miri;\n-        run.path(\"src/tools/miri\").default_condition(build_miri)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Miri {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        builder.ensure(ToolBuild {\n-            compiler: self.compiler,\n-            target: self.target,\n-            tool: \"miri\",\n-            mode: Mode::Librustc,\n-            path: \"src/tools/miri\",\n-            expectation: builder.build.config.toolstate.miri.passes(ToolState::Compiling),\n-        })\n-    }\n-}\n+    };\n+    Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n+);\n \n impl<'a> Builder<'a> {\n     /// Get a `Command` which is ready to run `tool` in `stage` built for"}]}