{"sha": "aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMmFiMjY1OWY2YzdhY2E3OWRkYWFhYzUzNzBkYThhZWE2YTE4ZDY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-15T02:09:38Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-15T02:09:38Z"}, "message": "Add core::reflect, start migrating core::repr to use it. Tidy up various Repr types.", "tree": {"sha": "084c63998f0d1552b9db812bfeded7a0e451dac3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/084c63998f0d1552b9db812bfeded7a0e451dac3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "html_url": "https://github.com/rust-lang/rust/commit/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c5db46f8e44441ba1aa11f0f607b7c015fd1fa5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c5db46f8e44441ba1aa11f0f607b7c015fd1fa5", "html_url": "https://github.com/rust-lang/rust/commit/1c5db46f8e44441ba1aa11f0f607b7c015fd1fa5"}], "stats": {"total": 973, "additions": 925, "deletions": 48}, "files": [{"sha": "845437ac95942c78be605c1f724a59231eab7b8a", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "patch": "@@ -30,7 +30,7 @@ pure fn capacity<T>(&&v: @[const T]) -> uint {\n     unsafe {\n         let repr: **unsafe::VecRepr =\n             ::unsafe::reinterpret_cast(&addr_of(v));\n-        (**repr).alloc / sys::size_of::<T>()\n+        (**repr).unboxed.alloc / sys::size_of::<T>()\n     }\n }\n \n@@ -155,14 +155,14 @@ mod unsafe {\n     #[inline(always)]\n     unsafe fn set_len<T>(&&v: @[const T], new_len: uint) {\n         let repr: **VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n-        (**repr).fill = new_len * sys::size_of::<T>();\n+        (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n     #[inline(always)]\n     unsafe fn push<T>(&v: @[const T], +initval: T) {\n         let repr: **VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n-        let fill = (**repr).fill;\n-        if (**repr).alloc > fill {\n+        let fill = (**repr).unboxed.fill;\n+        if (**repr).unboxed.alloc > fill {\n             push_fast(v, move initval);\n         }\n         else {\n@@ -173,9 +173,9 @@ mod unsafe {\n     #[inline(always)] // really pretty please\n     unsafe fn push_fast<T>(&v: @[const T], +initval: T) {\n         let repr: **VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n-        let fill = (**repr).fill;\n-        (**repr).fill += sys::size_of::<T>();\n-        let p = ptr::addr_of((**repr).data);\n+        let fill = (**repr).unboxed.fill;\n+        (**repr).unboxed.fill += sys::size_of::<T>();\n+        let p = ptr::addr_of((**repr).unboxed.data);\n         let p = ptr::offset(p, fill) as *mut T;\n         rusti::move_val_init(*p, move initval);\n     }"}, {"sha": "bb64080834e348068f2884515ffe5ce36d00c644", "filename": "src/libcore/box.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "patch": "@@ -5,8 +5,25 @@\n #[forbid(deprecated_pattern)];\n \n use cmp::{Eq, Ord};\n+use intrinsic::TyDesc;\n \n-export ptr_eq;\n+export ptr_eq, raw;\n+\n+mod raw {\n+\n+    struct BoxHeaderRepr {\n+        ref_count: uint,\n+        type_desc: *TyDesc,\n+        prev: *BoxRepr,\n+        next: *BoxRepr,\n+    }\n+\n+    struct BoxRepr {\n+        header: BoxHeaderRepr,\n+        data: u8\n+    }\n+\n+}\n \n pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     //! Determine if two shared boxes point to the same object"}, {"sha": "6558643507e4651e18432446c7beceb58358b89a", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "patch": "@@ -80,28 +80,28 @@ pub unsafe fn annihilate() {\n     let mut box: *mut BoxRepr = transmute(copy box);\n     while box != mut_null() {\n         debug!(\"making box immortal: %x\", box as uint);\n-        (*box).ref_count = 0x77777777;\n-        box = transmute(copy (*box).next);\n+        (*box).header.ref_count = 0x77777777;\n+        box = transmute(copy (*box).header.next);\n     }\n \n     // Pass 2: Drop all boxes.\n     let box = (*task).boxed_region.live_allocs;\n     let mut box: *mut BoxRepr = transmute(copy box);\n     while box != mut_null() {\n         debug!(\"calling drop glue for box: %x\", box as uint);\n-        let tydesc: *TypeDesc = transmute(copy (*box).type_desc);\n+        let tydesc: *TypeDesc = transmute(copy (*box).header.type_desc);\n         let drop_glue: DropGlue = transmute(((*tydesc).drop_glue, 0));\n         drop_glue(to_unsafe_ptr(&tydesc), transmute(&(*box).data));\n \n-        box = transmute(copy (*box).next);\n+        box = transmute(copy (*box).header.next);\n     }\n \n     // Pass 3: Free all boxes.\n     loop {\n         let box = (*task).boxed_region.live_allocs;\n         if box == null() { break; }\n         let mut box: *mut BoxRepr = transmute(copy box);\n-        assert (*box).prev == null();\n+        assert (*box).header.prev == null();\n \n         debug!(\"freeing box: %x\", box as uint);\n         rt_free(transmute(box));"}, {"sha": "48c61e82cb0e539963cf17e6596253dc2bc66025", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "patch": "@@ -63,6 +63,7 @@ export unit;\n export uniq;\n export repr;\n export cleanup;\n+export reflect;\n \n // NDM seems to be necessary for resolve to work\n export option_iter;\n@@ -230,6 +231,7 @@ mod mutable;\n mod flate;\n mod repr;\n mod cleanup;\n+mod reflect;\n \n // Modules supporting compiler-generated code\n // Exported but not part of the public interface"}, {"sha": "c95d1e6ca57fbcc4835ed5943f7618ba1047ce18", "filename": "src/libcore/reflect.rs", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "patch": "@@ -0,0 +1,472 @@\n+/*!\n+ * Helper types for interfacing with the `intrinsic::visit_ty`\n+ * reflection system.\n+ */\n+\n+use intrinsic::{TyDesc, get_tydesc, visit_tydesc, TyVisitor};\n+use libc::c_void;\n+\n+/**\n+ * Trait for visitor that wishes to reflect on data. To use this, create a\n+ * struct that encapsulates the set of pointers you wish to walk through a\n+ * data structure, and implement both `MovePtr` for it as well as `TyVisitor`;\n+ * then build a MovePtrAdaptor wrapped around your struct.\n+ */\n+trait MovePtr {\n+    fn move_ptr(adjustment: fn(*c_void) -> *c_void);\n+}\n+\n+/// Helper function for alignment calculation.\n+#[inline(always)]\n+fn align(size: uint, align: uint) -> uint {\n+    ((size + align) - 1u) & !(align - 1u)\n+}\n+\n+/// Adaptor to wrap around visitors implementing MovePtr.\n+struct MovePtrAdaptor<V: TyVisitor MovePtr> {\n+    inner: V\n+}\n+pub fn MovePtrAdaptor<V: TyVisitor MovePtr>(+v: V) -> MovePtrAdaptor<V> {\n+    MovePtrAdaptor { inner: move v }\n+}\n+\n+/// Abstract type-directed pointer-movement using the MovePtr trait\n+impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n+\n+    #[inline(always)]\n+    fn bump(sz: uint) {\n+      do self.inner.move_ptr() |p| {\n+            ((p as uint) + sz) as *c_void\n+      };\n+    }\n+\n+    #[inline(always)]\n+    fn align(a: uint) {\n+      do self.inner.move_ptr() |p| {\n+            align(p as uint, a) as *c_void\n+      };\n+    }\n+\n+    #[inline(always)]\n+    fn align_to<T>() {\n+        self.align(sys::min_align_of::<T>());\n+    }\n+\n+    #[inline(always)]\n+    fn bump_past<T>() {\n+        self.bump(sys::size_of::<T>());\n+    }\n+\n+    fn visit_bot() -> bool {\n+        self.align_to::<()>();\n+        if ! self.inner.visit_bot() { return false; }\n+        self.bump_past::<()>();\n+        true\n+    }\n+\n+    fn visit_nil() -> bool {\n+        self.align_to::<()>();\n+        if ! self.inner.visit_nil() { return false; }\n+        self.bump_past::<()>();\n+        true\n+    }\n+\n+    fn visit_bool() -> bool {\n+        self.align_to::<bool>();\n+        if ! self.inner.visit_bool() { return false; }\n+        self.bump_past::<bool>();\n+        true\n+    }\n+\n+    fn visit_int() -> bool {\n+        self.align_to::<int>();\n+        if ! self.inner.visit_int() { return false; }\n+        self.bump_past::<int>();\n+        true\n+    }\n+\n+    fn visit_i8() -> bool {\n+        self.align_to::<i8>();\n+        if ! self.inner.visit_i8() { return false; }\n+        self.bump_past::<i8>();\n+        true\n+    }\n+\n+    fn visit_i16() -> bool {\n+        self.align_to::<i16>();\n+        if ! self.inner.visit_i16() { return false; }\n+        self.bump_past::<i16>();\n+        true\n+    }\n+\n+    fn visit_i32() -> bool {\n+        self.align_to::<i32>();\n+        if ! self.inner.visit_i32() { return false; }\n+        self.bump_past::<i32>();\n+        true\n+    }\n+\n+    fn visit_i64() -> bool {\n+        self.align_to::<i64>();\n+        if ! self.inner.visit_i64() { return false; }\n+        self.bump_past::<i64>();\n+        true\n+    }\n+\n+    fn visit_uint() -> bool {\n+        self.align_to::<uint>();\n+        if ! self.inner.visit_uint() { return false; }\n+        self.bump_past::<uint>();\n+        true\n+    }\n+\n+    fn visit_u8() -> bool {\n+        self.align_to::<u8>();\n+        if ! self.inner.visit_u8() { return false; }\n+        self.bump_past::<u8>();\n+        true\n+    }\n+\n+    fn visit_u16() -> bool {\n+        self.align_to::<u16>();\n+        if ! self.inner.visit_u16() { return false; }\n+        self.bump_past::<u16>();\n+        true\n+    }\n+\n+    fn visit_u32() -> bool {\n+        self.align_to::<u32>();\n+        if ! self.inner.visit_u32() { return false; }\n+        self.bump_past::<u32>();\n+        true\n+    }\n+\n+    fn visit_u64() -> bool {\n+        self.align_to::<u64>();\n+        if ! self.inner.visit_u64() { return false; }\n+        self.bump_past::<u64>();\n+        true\n+    }\n+\n+    fn visit_float() -> bool {\n+        self.align_to::<float>();\n+        if ! self.inner.visit_float() { return false; }\n+        self.bump_past::<float>();\n+        true\n+    }\n+\n+    fn visit_f32() -> bool {\n+        self.align_to::<f32>();\n+        if ! self.inner.visit_f32() { return false; }\n+        self.bump_past::<f32>();\n+        true\n+    }\n+\n+    fn visit_f64() -> bool {\n+        self.align_to::<f64>();\n+        if ! self.inner.visit_f64() { return false; }\n+        self.bump_past::<f64>();\n+        true\n+    }\n+\n+    fn visit_char() -> bool {\n+        self.align_to::<char>();\n+        if ! self.inner.visit_char() { return false; }\n+        self.bump_past::<char>();\n+        true\n+    }\n+\n+    fn visit_str() -> bool {\n+        self.align_to::<~str>();\n+        if ! self.inner.visit_str() { return false; }\n+        self.bump_past::<~str>();\n+        true\n+    }\n+\n+    fn visit_estr_box() -> bool {\n+        self.align_to::<@str>();\n+        if ! self.inner.visit_estr_box() { return false; }\n+        self.bump_past::<@str>();\n+        true\n+    }\n+\n+    fn visit_estr_uniq() -> bool {\n+        self.align_to::<~str>();\n+        if ! self.inner.visit_estr_uniq() { return false; }\n+        self.bump_past::<~str>();\n+        true\n+    }\n+\n+    fn visit_estr_slice() -> bool {\n+        self.align_to::<&static/str>();\n+        if ! self.inner.visit_estr_slice() { return false; }\n+        self.bump_past::<&static/str>();\n+        true\n+    }\n+\n+    fn visit_estr_fixed(n: uint,\n+                        sz: uint,\n+                        align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_estr_fixed(n, sz, align) { return false; }\n+        self.bump(sz);\n+        true\n+    }\n+\n+    fn visit_box(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<@u8>();\n+        if ! self.inner.visit_box(mtbl, inner) { return false; }\n+        self.bump_past::<@u8>();\n+        true\n+    }\n+\n+    fn visit_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~u8>();\n+        if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n+        self.bump_past::<~u8>();\n+        true\n+    }\n+\n+    fn visit_ptr(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<*u8>();\n+        if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n+        self.bump_past::<*u8>();\n+        true\n+    }\n+\n+    fn visit_rptr(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<&static/u8>();\n+        if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n+        self.bump_past::<&static/u8>();\n+        true\n+    }\n+\n+    fn visit_unboxed_vec(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<vec::raw::UnboxedVecRepr>();\n+        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_vec(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~[u8]>();\n+        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n+        self.bump_past::<~[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_box(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<@[u8]>();\n+        if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n+        self.bump_past::<@[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<~[u8]>();\n+        if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n+        self.bump_past::<~[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_slice(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align_to::<&static/[u8]>();\n+        if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n+        self.bump_past::<&static/[u8]>();\n+        true\n+    }\n+\n+    fn visit_evec_fixed(n: uint, sz: uint, align: uint,\n+                        mtbl: uint, inner: *TyDesc) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n+            return false;\n+        }\n+        self.bump(sz);\n+        true\n+    }\n+\n+    fn visit_enter_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_rec_field(i: uint, name: &str,\n+                       mtbl: uint, inner: *TyDesc) -> bool {\n+        unsafe { self.align((*inner).align); }\n+        if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n+            return false;\n+        }\n+        unsafe { self.bump((*inner).size); }\n+        true\n+    }\n+\n+    fn visit_leave_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_enter_class(n_fields: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_class(n_fields, sz, align) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_class_field(i: uint, name: &str,\n+                         mtbl: uint, inner: *TyDesc) -> bool {\n+        unsafe { self.align((*inner).align); }\n+        if ! self.inner.visit_class_field(i, name, mtbl, inner) {\n+            return false;\n+        }\n+        unsafe { self.bump((*inner).size); }\n+        true\n+    }\n+\n+    fn visit_leave_class(n_fields: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_class(n_fields, sz, align) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enter_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_tup_field(i: uint, inner: *TyDesc) -> bool {\n+        unsafe { self.align((*inner).align); }\n+        if ! self.inner.visit_tup_field(i, inner) { return false; }\n+        unsafe { self.bump((*inner).size); }\n+        true\n+    }\n+\n+    fn visit_leave_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n+        true\n+    }\n+\n+    fn visit_enter_fn(purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool {\n+        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n+            return false\n+        }\n+        true\n+    }\n+\n+    fn visit_fn_input(i: uint, mode: uint, inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_fn_output(retstyle: uint, inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_leave_fn(purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool {\n+        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enter_enum(n_variants: uint, sz: uint, align: uint) -> bool {\n+        self.align(align);\n+        if ! self.inner.visit_enter_enum(n_variants, sz, align) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enter_enum_variant(variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool {\n+        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n+                                                 n_fields, name) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_enum_variant_field(i: uint, inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_enum_variant_field(i, inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_leave_enum_variant(variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool {\n+        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n+                                                 n_fields, name) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_leave_enum(n_variants: uint, sz: uint, align: uint) -> bool {\n+        if ! self.inner.visit_leave_enum(n_variants, sz, align) {\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn visit_trait() -> bool {\n+        self.align_to::<TyVisitor>();\n+        if ! self.inner.visit_trait() { return false; }\n+        self.bump_past::<TyVisitor>();\n+        true\n+    }\n+\n+    fn visit_var() -> bool {\n+        if ! self.inner.visit_var() { return false; }\n+        true\n+    }\n+\n+    fn visit_var_integral() -> bool {\n+        if ! self.inner.visit_var_integral() { return false; }\n+        true\n+    }\n+\n+    fn visit_param(i: uint) -> bool {\n+        if ! self.inner.visit_param(i) { return false; }\n+        true\n+    }\n+\n+    fn visit_self() -> bool {\n+        self.align_to::<&static/u8>();\n+        if ! self.inner.visit_self() { return false; }\n+        self.align_to::<&static/u8>();\n+        true\n+    }\n+\n+    fn visit_type() -> bool {\n+        if ! self.inner.visit_type() { return false; }\n+        true\n+    }\n+\n+    fn visit_opaque_box() -> bool {\n+        self.align_to::<@u8>();\n+        if ! self.inner.visit_opaque_box() { return false; }\n+        self.bump_past::<@u8>();\n+        true\n+    }\n+\n+    fn visit_constr(inner: *TyDesc) -> bool {\n+        if ! self.inner.visit_constr(inner) { return false; }\n+        true\n+    }\n+\n+    fn visit_closure_ptr(ck: uint) -> bool {\n+        self.align_to::<fn@()>();\n+        if ! self.inner.visit_closure_ptr(ck) { return false; }\n+        self.bump_past::<fn@()>();\n+        true\n+    }\n+}"}, {"sha": "a0d6b013407d1ff2cd2d33acd8cd51f2196eec5d", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 401, "deletions": 21, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "patch": "@@ -4,7 +4,10 @@ use libc::c_void;\n use sys::TypeDesc;\n use to_str::ToStr;\n use unsafe::transmute;\n-use intrinsic::{TyDesc, TyVisitor};\n+use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n+use reflect::{MovePtr, MovePtrAdaptor};\n+use vec::raw::{VecRepr, UnboxedVecRepr, SliceRepr};\n+use box::raw::{BoxRepr, BoxHeaderRepr};\n \n /// Helpers\n \n@@ -14,21 +17,6 @@ fn align(size: uint, align: uint) -> uint {\n     ((size + align) - 1) & !(align - 1)\n }\n \n-struct VecRepr {\n-    box_header: (uint, uint, uint, uint),\n-    mut fill: uint,\n-    mut alloc: uint,\n-    data: u8\n-}\n-\n-struct BoxRepr {\n-    ref_count: uint,\n-    type_desc: *TyDesc,\n-    prev: *BoxRepr,\n-    next: *BoxRepr,\n-    data: u8\n-}\n-\n trait EscapedCharWriter {\n     fn write_escaped_char(ch: char);\n }\n@@ -118,6 +106,397 @@ impl char : Repr {\n     fn write_repr(writer: @Writer) { writer.write_char(self); }\n }\n \n+\n+// New implementation using reflect::MovePtr\n+\n+struct ReprVisitor {\n+    mut ptr: *c_void,\n+    writer: @Writer\n+}\n+fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n+    ReprVisitor { ptr: ptr, writer: writer }\n+}\n+\n+impl ReprVisitor : MovePtr {\n+    #[inline(always)]\n+    fn move_ptr(adjustment: fn(*c_void) -> *c_void) {\n+        self.ptr = adjustment(self.ptr);\n+    }\n+}\n+\n+impl ReprVisitor {\n+\n+    // Various helpers for the TyVisitor impl\n+\n+    #[inline(always)]\n+    fn get<T>(f: fn((&T))) -> bool {\n+        unsafe {\n+            f(transmute::<*c_void,&T>(copy self.ptr));\n+        }\n+        true\n+    }\n+\n+    #[inline(always)]\n+    fn visit_inner(inner: *TyDesc) -> bool {\n+        self.visit_ptr_inner(self.ptr, inner)\n+    }\n+\n+    #[inline(always)]\n+    fn visit_ptr_inner(ptr: *c_void, inner: *TyDesc) -> bool {\n+        let mut u = ReprVisitor(ptr, self.writer);\n+        let v = reflect::MovePtrAdaptor(move u);\n+        visit_tydesc(inner, v as @TyVisitor);\n+        true\n+    }\n+\n+    #[inline(always)]\n+    fn write<T:Repr>() -> bool {\n+        do self.get |v:&T| {\n+            v.write_repr(self.writer);\n+        }\n+    }\n+\n+    fn write_escaped_slice(slice: &str) {\n+        self.writer.write_char('\"');\n+        do str::chars_iter(slice) |ch| {\n+            self.writer.write_escaped_char(ch);\n+        }\n+        self.writer.write_char('\"');\n+    }\n+\n+    fn write_mut_qualifier(mtbl: uint) {\n+        if mtbl == 0 {\n+            self.writer.write_str(\"mut \");\n+        } else if mtbl == 1 {\n+            // skip, this is ast::m_imm\n+        } else {\n+            assert mtbl == 2;\n+            self.writer.write_str(\"const \");\n+        }\n+    }\n+\n+    fn write_vec_range(mtbl: uint, ptr: *u8, len: uint,\n+                       inner: *TyDesc) -> bool {\n+        let mut p = ptr;\n+        let end = ptr::offset(p, len);\n+        let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n+        self.writer.write_char('[');\n+        let mut first = true;\n+        while p as uint < end as uint {\n+            if first {\n+                first = false;\n+            } else {\n+                self.writer.write_str(\", \");\n+            }\n+            self.write_mut_qualifier(mtbl);\n+            self.visit_ptr_inner(p as *c_void, inner);\n+            p = align(ptr::offset(p, sz) as uint, al) as *u8;\n+        }\n+        self.writer.write_char(']');\n+        true\n+    }\n+\n+    fn write_unboxed_vec_repr(mtbl: uint, v: &UnboxedVecRepr,\n+                              inner: *TyDesc) -> bool {\n+        self.write_vec_range(mtbl, ptr::to_unsafe_ptr(&v.data),\n+                             v.fill, inner)\n+    }\n+\n+\n+}\n+\n+impl ReprVisitor : TyVisitor {\n+    fn visit_bot() -> bool {\n+        self.writer.write_str(\"!\");\n+        true\n+    }\n+    fn visit_nil() -> bool { self.write::<()>() }\n+    fn visit_bool() -> bool { self.write::<bool>() }\n+    fn visit_int() -> bool { self.write::<int>() }\n+    fn visit_i8() -> bool { self.write::<i8>() }\n+    fn visit_i16() -> bool { self.write::<i16>() }\n+    fn visit_i32() -> bool { self.write::<i32>()  }\n+    fn visit_i64() -> bool { self.write::<i64>() }\n+\n+    fn visit_uint() -> bool { self.write::<uint>() }\n+    fn visit_u8() -> bool { self.write::<u8>() }\n+    fn visit_u16() -> bool { self.write::<u16>() }\n+    fn visit_u32() -> bool { self.write::<u32>() }\n+    fn visit_u64() -> bool { self.write::<u64>() }\n+\n+    fn visit_float() -> bool { self.write::<float>() }\n+    fn visit_f32() -> bool { self.write::<f32>() }\n+    fn visit_f64() -> bool { self.write::<f64>() }\n+\n+    fn visit_char() -> bool { self.write::<uint>() }\n+\n+    // Type no longer exists, vestigial function.\n+    fn visit_str() -> bool { fail; }\n+\n+    fn visit_estr_box() -> bool {\n+        do self.get::<@str> |s| {\n+            self.writer.write_char('@');\n+            self.write_escaped_slice(*s);\n+        }\n+    }\n+    fn visit_estr_uniq() -> bool {\n+        do self.get::<~str> |s| {\n+            self.writer.write_char('~');\n+            self.write_escaped_slice(*s);\n+        }\n+    }\n+    fn visit_estr_slice() -> bool {\n+        do self.get::<&str> |s| {\n+            self.write_escaped_slice(*s);\n+        }\n+    }\n+\n+    // Type no longer exists, vestigial function.\n+    fn visit_estr_fixed(_n: uint, _sz: uint,\n+                        _align: uint) -> bool { fail; }\n+\n+    fn visit_box(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('@');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<&box::raw::BoxRepr> |b| {\n+            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            self.visit_ptr_inner(p, inner);\n+        }\n+    }\n+\n+    fn visit_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('~');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<&box::raw::BoxRepr> |b| {\n+            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            self.visit_ptr_inner(p, inner);\n+        }\n+    }\n+\n+    fn visit_ptr(_mtbl: uint, _inner: *TyDesc) -> bool {\n+        do self.get::<*c_void> |p| {\n+            self.writer.write_str(fmt!(\"(0x%x as *())\",\n+                                       *p as uint));\n+        }\n+    }\n+\n+    fn visit_rptr(mtbl: uint, inner: *TyDesc) -> bool {\n+        self.writer.write_char('&');\n+        self.write_mut_qualifier(mtbl);\n+        do self.get::<*c_void> |p| {\n+            self.visit_ptr_inner(*p, inner);\n+        }\n+    }\n+\n+    // Type no longer exists, vestigial function.\n+    fn visit_vec(_mtbl: uint, _inner: *TyDesc) -> bool { fail; }\n+\n+\n+    fn visit_unboxed_vec(mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<vec::raw::UnboxedVecRepr> |b| {\n+            self.write_unboxed_vec_repr(mtbl, b, inner);\n+        }\n+    }\n+\n+    fn visit_evec_box(mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&VecRepr> |b| {\n+            self.writer.write_char('@');\n+            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n+        }\n+    }\n+\n+    fn visit_evec_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<&VecRepr> |b| {\n+            self.writer.write_char('~');\n+            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n+        }\n+    }\n+\n+    fn visit_evec_slice(mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<SliceRepr> |s| {\n+            self.writer.write_char('&');\n+            self.write_vec_range(mtbl, s.data, s.len, inner);\n+        }\n+    }\n+\n+    fn visit_evec_fixed(_n: uint, sz: uint, _align: uint,\n+                        mtbl: uint, inner: *TyDesc) -> bool {\n+        do self.get::<u8> |b| {\n+            self.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), sz, inner);\n+        }\n+    }\n+\n+    fn visit_enter_rec(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('{');\n+        true\n+    }\n+\n+    fn visit_rec_field(i: uint, name: &str,\n+                       mtbl: uint, inner: *TyDesc) -> bool {\n+        if i != 0 {\n+            self.writer.write_str(\", \");\n+        }\n+        self.write_mut_qualifier(mtbl);\n+        self.writer.write_str(name);\n+        self.writer.write_str(\": \");\n+        self.visit_inner(inner);\n+        true\n+    }\n+\n+    fn visit_leave_rec(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('}');\n+        true\n+    }\n+\n+    fn visit_enter_class(_n_fields: uint,\n+                         _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('{');\n+        true\n+    }\n+    fn visit_class_field(i: uint, name: &str,\n+                         mtbl: uint, inner: *TyDesc) -> bool {\n+        if i != 0 {\n+            self.writer.write_str(\", \");\n+        }\n+        self.write_mut_qualifier(mtbl);\n+        self.writer.write_str(name);\n+        self.writer.write_str(\": \");\n+        self.visit_inner(inner);\n+        true\n+    }\n+    fn visit_leave_class(_n_fields: uint,\n+                         _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('}');\n+        true\n+    }\n+\n+    fn visit_enter_tup(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char('(');\n+        true\n+    }\n+    fn visit_tup_field(i: uint, inner: *TyDesc) -> bool {\n+        if i != 0 {\n+            self.writer.write_str(\", \");\n+        }\n+        self.visit_inner(inner);\n+        true\n+    }\n+    fn visit_leave_tup(_n_fields: uint,\n+                       _sz: uint, _align: uint) -> bool {\n+        self.writer.write_char(')');\n+        true\n+    }\n+\n+    fn visit_enter_enum(_n_variants: uint,\n+                        _sz: uint, _align: uint) -> bool {\n+        true\n+    }\n+    fn visit_enter_enum_variant(_variant: uint,\n+                                _disr_val: int,\n+                                _n_fields: uint,\n+                                _name: &str) -> bool { true }\n+    fn visit_enum_variant_field(_i: uint, inner: *TyDesc) -> bool {\n+        self.visit_inner(inner)\n+    }\n+    fn visit_leave_enum_variant(_variant: uint,\n+                                _disr_val: int,\n+                                _n_fields: uint,\n+                                _name: &str) -> bool { true }\n+    fn visit_leave_enum(_n_variants: uint,\n+                        _sz: uint, _align: uint) -> bool { true }\n+\n+    fn visit_enter_fn(_purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+    fn visit_fn_input(_i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_fn_output(_retstyle: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_leave_fn(_purity: uint, _proto: uint,\n+                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n+\n+\n+    fn visit_trait() -> bool { true }\n+    fn visit_var() -> bool { true }\n+    fn visit_var_integral() -> bool { true }\n+    fn visit_param(_i: uint) -> bool { true }\n+    fn visit_self() -> bool { true }\n+    fn visit_type() -> bool { true }\n+\n+    fn visit_opaque_box() -> bool {\n+        self.writer.write_char('@');\n+        do self.get::<&box::raw::BoxRepr> |b| {\n+            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            self.visit_ptr_inner(p, b.header.type_desc);\n+        }\n+    }\n+\n+    // Type no longer exists, vestigial function.\n+    fn visit_constr(_inner: *TyDesc) -> bool { fail; }\n+\n+    fn visit_closure_ptr(_ck: uint) -> bool { true }\n+}\n+\n+pub fn write_repr2<T>(writer: @Writer, object: &T) {\n+    let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n+    let tydesc = intrinsic::get_tydesc::<T>();\n+    let mut u = ReprVisitor(ptr, writer);\n+    let v = reflect::MovePtrAdaptor(move u);\n+    visit_tydesc(tydesc, v as @TyVisitor)\n+}\n+\n+#[test]\n+fn test_repr2() {\n+    repr::write_repr2(io::stdout(), &10);\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &true);\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &false);\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &1.234);\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(&\"hello\"));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(@\"hello\"));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(~\"he\\u10f3llo\"));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(@10));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(@mut 10));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(~10));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(~mut 10));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(&10));\n+    io::println(\"\");\n+    let mut x = 10;\n+    repr::write_repr2(io::stdout(), &(&mut x));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(ptr::to_unsafe_ptr(&10) as *int));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(@[1,2,3,4,5,6,7,8]));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(@[1u8,2u8,3u8,4u8]));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(@[\"hi\", \"there\"]));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(~[\"hi\", \"there\"]));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(&[\"hi\", \"there\"]));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &({a:10, b:1.234}));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(@{a:10, b:1.234}));\n+    io::println(\"\");\n+    repr::write_repr2(io::stdout(), &(~{a:10, b:1.234}));\n+    io::println(\"\");\n+}\n+\n+\n+// Old non-factored implementation, transitional...\n+\n enum EnumVisitState {\n     PreVariant,     // We're before the variant we're interested in.\n     InVariant,      // We're inside the variant we're interested in.\n@@ -181,8 +560,8 @@ impl ReprPrinterWrapper {\n             self.printer.writer.write_char('\"');\n             let vec_repr_ptr: **VecRepr = transmute(copy self.printer.ptr);\n             let vec_repr = *vec_repr_ptr;\n-            let data_ptr = ptr::to_unsafe_ptr(&(*vec_repr).data);\n-            let slice: &str = transmute((data_ptr, (*vec_repr).fill));\n+            let data_ptr = ptr::to_unsafe_ptr(&(*vec_repr).unboxed.data);\n+            let slice: &str = transmute((data_ptr, (*vec_repr).unboxed.fill));\n             do str::chars_iter(slice) |ch| {\n                 self.printer.writer.write_escaped_char(ch);\n             }\n@@ -199,7 +578,8 @@ impl ReprPrinterWrapper {\n             let box_ptr: **BoxRepr = transmute(copy self.printer.ptr);\n             let box = *box_ptr;\n             self.printer.ptr = transmute(&(*box).data);\n-            intrinsic::visit_tydesc((*box).type_desc, self as @TyVisitor);\n+            intrinsic::visit_tydesc((*box).header.type_desc,\n+                                    self as @TyVisitor);\n             let box_size = sys::size_of::<*BoxRepr>();\n             self.printer.ptr = transmute(box_ptr as uint + box_size);\n             true\n@@ -229,9 +609,9 @@ impl ReprPrinterWrapper {\n             let vec_repr_ptr: **VecRepr = transmute(copy self.printer.ptr);\n             let old_ptr = self.printer.ptr as uint;\n             let vec_repr: *VecRepr = *vec_repr_ptr;\n-            self.printer.ptr = transmute(&(*vec_repr).data);\n+            self.printer.ptr = transmute(&(*vec_repr).unboxed.data);\n             let end_ptr: *c_void = transmute(self.printer.ptr as uint +\n-                                             (*vec_repr).fill);\n+                                             (*vec_repr).unboxed.fill);\n             let sys_tydesc: *TypeDesc = transmute(copy inner);\n             let alignment = (*sys_tydesc).align;\n             let mut first = true;"}, {"sha": "3d4478080c9e4266871be7cb2852e12ce6e67c7c", "filename": "src/libcore/str.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "patch": "@@ -2119,8 +2119,9 @@ mod raw {\n     /// Sets the length of the string and adds the null terminator\n     unsafe fn set_len(&v: ~str, new_len: uint) {\n         let repr: *vec::raw::VecRepr = ::unsafe::reinterpret_cast(&v);\n-        (*repr).fill = new_len + 1u;\n-        let null = ptr::mut_offset(ptr::mut_addr_of((*repr).data), new_len);\n+        (*repr).unboxed.fill = new_len + 1u;\n+        let null = ptr::mut_offset(ptr::mut_addr_of((*repr).unboxed.data),\n+                                   new_len);\n         *null = 0u8;\n     }\n "}, {"sha": "2f84a30a49bd4053e4710afabbbc4597daef2d6d", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "patch": "@@ -169,7 +169,7 @@ fn reserve_at_least<T>(&v: ~[const T], n: uint) {\n pure fn capacity<T>(&&v: ~[const T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n-        (**repr).alloc / sys::size_of::<T>()\n+        (**repr).unboxed.alloc / sys::size_of::<T>()\n     }\n }\n \n@@ -565,8 +565,8 @@ fn swap_remove<T>(&v: ~[const T], index: uint) -> T {\n fn push<T>(&v: ~[const T], +initval: T) {\n     unsafe {\n         let repr: **raw::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n-        let fill = (**repr).fill;\n-        if (**repr).alloc > fill {\n+        let fill = (**repr).unboxed.fill;\n+        if (**repr).unboxed.alloc > fill {\n             push_fast(v, move initval);\n         }\n         else {\n@@ -579,9 +579,9 @@ fn push<T>(&v: ~[const T], +initval: T) {\n #[inline(always)] // really pretty please\n unsafe fn push_fast<T>(&v: ~[const T], +initval: T) {\n     let repr: **raw::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n-    let fill = (**repr).fill;\n-    (**repr).fill += sys::size_of::<T>();\n-    let p = ptr::addr_of((**repr).data);\n+    let fill = (**repr).unboxed.fill;\n+    (**repr).unboxed.fill += sys::size_of::<T>();\n+    let p = ptr::addr_of((**repr).unboxed.data);\n     let p = ptr::offset(p, fill) as *mut T;\n     rusti::move_val_init(*p, move initval);\n }\n@@ -1787,13 +1787,19 @@ impl<T: Copy> &[T]: ImmutableCopyableVector<T> {\n /// Unsafe operations\n mod raw {\n     // FIXME: This should have crate visibility (#1893 blocks that)\n-    /// The internal representation of a vector\n-    type VecRepr = {\n-        box_header: (uint, uint, uint, uint),\n+\n+    /// The internal representation of a (boxed) vector\n+    struct VecRepr {\n+        box_header: box::raw::BoxHeaderRepr,\n+        unboxed: UnboxedVecRepr\n+    }\n+\n+    /// The internal 'unboxed' representation of a vector\n+    struct UnboxedVecRepr {\n         mut fill: uint,\n         mut alloc: uint,\n         data: u8\n-    };\n+    }\n \n     type SliceRepr = {\n         mut data: *u8,\n@@ -1827,7 +1833,7 @@ mod raw {\n     #[inline(always)]\n     unsafe fn set_len<T>(&&v: ~[const T], new_len: uint) {\n         let repr: **VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n-        (**repr).fill = new_len * sys::size_of::<T>();\n+        (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n     /**"}, {"sha": "33de068fad0ae19fe790d68db97b39c90ac3011b", "filename": "src/rustc/front/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Frustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6/src%2Frustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic.rs?ref=aa2ab2659f6c7aca79ddaaac5370da8aea6a18d6", "patch": "@@ -12,7 +12,6 @@ mod intrinsic {\n     }\n \n     pub enum TyDesc = {\n-        first_param: **u8,\n         size: uint,\n         align: uint\n         // Remaining fields not listed"}]}