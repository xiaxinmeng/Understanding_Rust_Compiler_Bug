{"sha": "cdb7701434be0ee463fa1dcce7e92647c5b5828c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYjc3MDE0MzRiZTBlZTQ2M2ZhMWRjY2U3ZTkyNjQ3YzViNTgyOGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-03T17:24:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-03T17:24:40Z"}, "message": "rustdoc: Document what's going on throughout\n\nThis addresses some of @huonw's in #9691 about the startling lack of\ndocumentation guiding one throughout the innards of rustdoc::html", "tree": {"sha": "a9706cf459c3dc7e678f837dda7240a6bba6ce76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9706cf459c3dc7e678f837dda7240a6bba6ce76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdb7701434be0ee463fa1dcce7e92647c5b5828c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb7701434be0ee463fa1dcce7e92647c5b5828c", "html_url": "https://github.com/rust-lang/rust/commit/cdb7701434be0ee463fa1dcce7e92647c5b5828c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdb7701434be0ee463fa1dcce7e92647c5b5828c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff30566954514b2c3bae3b8d428670abbca05f5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff30566954514b2c3bae3b8d428670abbca05f5e", "html_url": "https://github.com/rust-lang/rust/commit/ff30566954514b2c3bae3b8d428670abbca05f5e"}], "stats": {"total": 201, "additions": 187, "deletions": 14}, "files": [{"sha": "dedc19bbe7eba522dc253466b977b78aa62913a2", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7701434be0ee463fa1dcce7e92647c5b5828c/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7701434be0ee463fa1dcce7e92647c5b5828c/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=cdb7701434be0ee463fa1dcce7e92647c5b5828c", "patch": "@@ -8,8 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! HTML Escaping\n+//!\n+//! This module contains one unit-struct which can be used to HTML-escape a\n+//! string of text (for use in a format string).\n+\n use std::fmt;\n \n+/// Wrapper struct which will emit the HTML-escaped version of the contained\n+/// string when passed to a format string.\n pub struct Escape<'self>(&'self str);\n \n impl<'self> fmt::Default for Escape<'self> {"}, {"sha": "8c1db5aef656f915f5da585e02044afc9ccfbe6a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7701434be0ee463fa1dcce7e92647c5b5828c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7701434be0ee463fa1dcce7e92647c5b5828c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=cdb7701434be0ee463fa1dcce7e92647c5b5828c", "patch": "@@ -8,6 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! HTML formatting module\n+//!\n+//! This module contains a large number of `fmt::Default` implementations for\n+//! various types in `rustdoc::clean`. These implementations all currently\n+//! assume that HTML output is desired, although it may be possible to redesign\n+//! them in the future to instead emit any format desired.\n+\n use std::fmt;\n use std::local_data;\n use std::rt::io;\n@@ -19,8 +26,13 @@ use clean;\n use html::render;\n use html::render::{cache_key, current_location_key};\n \n+/// Helper to render an optional visibility with a space after it (if the\n+/// visibility is preset)\n pub struct VisSpace(Option<ast::visibility>);\n+/// Similarly to VisSpace, this structure is used to render a purity with a\n+/// space after it.\n pub struct PuritySpace(ast::purity);\n+/// Wrapper struct for properly emitting a method declaration.\n pub struct Method<'self>(&'self clean::SelfTy, &'self clean::FnDecl);\n \n impl fmt::Default for clean::Generics {\n@@ -98,6 +110,8 @@ impl fmt::Default for clean::Path {\n     }\n }\n \n+/// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n+/// rendering function with the necessary arguments for linking to a local path.\n fn resolved_path(w: &mut io::Writer, id: ast::NodeId, p: &clean::Path,\n                  print_all: bool) {\n     path(w, p, print_all,\n@@ -115,6 +129,8 @@ fn resolved_path(w: &mut io::Writer, id: ast::NodeId, p: &clean::Path,\n         });\n }\n \n+/// Used when rendering an `ExternalPath` structure. Like `resolved_path` this\n+/// will invoke `path` with proper linking-style arguments.\n fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n                  fqn: &[~str], kind: clean::TypeKind, crate: ast::CrateNum) {\n     path(w, p, print_all,\n@@ -230,6 +246,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n     }\n }\n \n+/// Helper to render type parameters\n fn typarams(w: &mut io::Writer, typarams: &Option<~[clean::TyParamBound]>) {\n     match *typarams {\n         Some(ref params) => {"}, {"sha": "f4a61e87993ea23dd5fdb21da7659d2f39cd2d77", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7701434be0ee463fa1dcce7e92647c5b5828c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7701434be0ee463fa1dcce7e92647c5b5828c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=cdb7701434be0ee463fa1dcce7e92647c5b5828c", "patch": "@@ -10,11 +10,28 @@\n \n #[allow(cstack)]; // each rendering task runs on a fixed stack segment.\n \n+//! Markdown formatting for rustdoc\n+//!\n+//! This module implements markdown formatting through the sundown C-library\n+//! (bundled into the rust runtime). This module self-contains the C bindings\n+//! and necessary legwork to render markdown, and exposes all of the\n+//! functionality through a unit-struct, `Markdown`, which has an implementation\n+//! of `fmt::Default`. Example usage:\n+//!\n+//! ```rust\n+//! let s = \"My *markdown* _text_\";\n+//! let html = format!(\"{}\", Markdown(s));\n+//! // ... something using html\n+//! ```\n+\n use std::fmt;\n use std::libc;\n use std::rt::io;\n use std::vec;\n \n+/// A unit struct which has the `fmt::Default` trait implemented. When\n+/// formatted, this struct will emit the HTML corresponding to the rendered\n+/// version of the contained markdown string.\n pub struct Markdown<'self>(&'self str);\n \n static OUTPUT_UNIT: libc::size_t = 64;\n@@ -110,7 +127,6 @@ impl<'self> fmt::Default for Markdown<'self> {\n     fn fmt(md: &Markdown<'self>, fmt: &mut fmt::Formatter) {\n         // This is actually common enough to special-case\n         if md.len() == 0 { return; }\n-\n         render(fmt.buf, md.as_slice());\n     }\n }"}, {"sha": "f04527ee893b09162cb6d305425b6398be59c77f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 146, "deletions": 13, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/cdb7701434be0ee463fa1dcce7e92647c5b5828c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb7701434be0ee463fa1dcce7e92647c5b5828c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cdb7701434be0ee463fa1dcce7e92647c5b5828c", "patch": "@@ -8,6 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Rustdoc's HTML Rendering module\n+//!\n+//! This modules contains the bulk of the logic necessary for rendering a\n+//! rustdoc `clean::Crate` instance to a set of static HTML pages. This\n+//! rendering process is largely driven by the `format!` syntax extension to\n+//! perform all I/O into files and streams.\n+//!\n+//! The rendering process is largely driven by the `Context` and `Cache`\n+//! structures. The cache is pre-populated by crawling the crate in question,\n+//! and then it is shared among the various rendering tasks. The cache is meant\n+//! to be a fairly large structure not implementing `Clone` (because it's shared\n+//! among tasks). The context, however, should be a lightweight structure. This\n+//! is cloned per-task and contains information about what is currently being\n+//! rendered.\n+//!\n+//! In order to speed up rendering (mostly because of markdown rendering), the\n+//! rendering process has been parallelized. This parallelization is only\n+//! exposed through the `crate` method on the context, and then also from the\n+//! fact that the shared cache is stored in TLS (and must be accessed as such).\n+//!\n+//! In addition to rendering the crate itself, this module is also responsible\n+//! for creating the corresponding search index and source file renderings.\n+//! These tasks are not parallelized (they haven't been a bottleneck yet), and\n+//! both occur before the crate is rendered.\n+\n use std::cell::Cell;\n use std::comm::{SharedPort, SharedChan};\n use std::comm;\n@@ -40,55 +65,132 @@ use html::format::{VisSpace, Method, PuritySpace};\n use html::layout;\n use html::markdown::Markdown;\n \n+/// Major driving force in all rustdoc rendering. This contains information\n+/// about where in the tree-like hierarchy rendering is occurring and controls\n+/// how the current page is being rendered.\n+///\n+/// It is intended that this context is a lightweight object which can be fairly\n+/// easily cloned because it is cloned per work-job (about once per item in the\n+/// rustdoc tree).\n #[deriving(Clone)]\n pub struct Context {\n+    /// Current hierarchy of components leading down to what's currently being\n+    /// rendered\n     current: ~[~str],\n+    /// String representation of how to get back to the root path of the 'doc/'\n+    /// folder in terms of a relative URL.\n     root_path: ~str,\n+    /// The current destination folder of where HTML artifacts should be placed.\n+    /// This changes as the context descends into the module hierarchy.\n     dst: Path,\n+    /// This describes the layout of each page, and is not modified after\n+    /// creation of the context (contains info like the favicon)\n     layout: layout::Layout,\n+    /// This map is a list of what should be displayed on the sidebar of the\n+    /// current page. The key is the section header (traits, modules,\n+    /// functions), and the value is the list of containers belonging to this\n+    /// header. This map will change depending on the surrounding context of the\n+    /// page.\n     sidebar: HashMap<~str, ~[~str]>,\n+    /// This flag indicates whether [src] links should be generated or not. If\n+    /// the source files are present in the html rendering, then this will be\n+    /// `true`.\n     include_sources: bool,\n }\n \n+/// Indicates where an external crate can be found.\n pub enum ExternalLocation {\n-    Remote(~str),   // remote url root of the documentation\n-    Local,          // inside local folder\n-    Unknown,        // unknown where the documentation is\n+    /// Remote URL root of the external crate\n+    Remote(~str),\n+    /// This external crate can be found in the local doc/ folder\n+    Local,\n+    /// The external crate could not be found.\n+    Unknown,\n }\n \n+/// Different ways an implementor of a trait can be rendered.\n enum Implementor {\n+    /// Paths are displayed specially by omitting the `impl XX for` cruft\n     PathType(clean::Type),\n+    /// This is the generic representation of an trait implementor, used for\n+    /// primitive types and otherwise non-path types.\n     OtherType(clean::Generics, /* trait */ clean::Type, /* for */ clean::Type),\n }\n \n+/// This cache is used to store information about the `clean::Crate` being\n+/// rendered in order to provide more useful documentation. This contains\n+/// information like all implementors of a trait, all traits a type implements,\n+/// documentation for all known traits, etc.\n+///\n+/// This structure purposefully does not implement `Clone` because it's intended\n+/// to be a fairly large and expensive structure to clone. Instead this adheres\n+/// to both `Send` and `Freeze` so it may be stored in a `RWArc` instance and\n+/// shared among the various rendering tasks.\n struct Cache {\n-    // typaram id => name of that typaram\n+    /// Mapping of typaram ids to the name of the type parameter. This is used\n+    /// when pretty-printing a type (so pretty printing doesn't have to\n+    /// painfully maintain a context like this)\n     typarams: HashMap<ast::NodeId, ~str>,\n-    // type id => all implementations for that type\n+\n+    /// Maps a type id to all known implementations for that type. This is only\n+    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n+    /// out extra documentation on the page of an enum/struct.\n+    ///\n+    /// The values of the map are a list of implementations and documentation\n+    /// found on that implementation.\n     impls: HashMap<ast::NodeId, ~[(clean::Impl, Option<~str>)]>,\n-    // path id => (full qualified path, shortty) -- used to generate urls\n+\n+    /// Maintains a mapping of local crate node ids to the fully qualified name\n+    /// and \"short type description\" of that node. This is used when generating\n+    /// URLs when a type is being linked to. External paths are not located in\n+    /// this map because the `External` type itself has all the information\n+    /// necessary.\n     paths: HashMap<ast::NodeId, (~[~str], &'static str)>,\n-    // trait id => method name => dox\n+\n+    /// This map contains information about all known traits of this crate.\n+    /// Implementations of a crate should inherit the documentation of the\n+    /// parent trait if no extra documentation is specified, and this map is\n+    /// keyed on trait id with a value of a 'method name => documentation'\n+    /// mapping.\n     traits: HashMap<ast::NodeId, HashMap<~str, ~str>>,\n-    // trait id => implementors of the trait\n+\n+    /// When rendering traits, it's often useful to be able to list all\n+    /// implementors of the trait, and this mapping is exactly, that: a mapping\n+    /// of trait ids to the list of known implementors of the trait\n     implementors: HashMap<ast::NodeId, ~[Implementor]>,\n-    // crate number => where is the crate's dox located at\n+\n+    /// Cache of where external crate documentation can be found.\n     extern_locations: HashMap<ast::CrateNum, ExternalLocation>,\n \n+    // Private fields only used when initially crawling a crate to build a cache\n+\n     priv stack: ~[~str],\n     priv parent_stack: ~[ast::NodeId],\n     priv search_index: ~[IndexItem],\n }\n \n+/// Helper struct to render all source code to HTML pages\n struct SourceCollector<'self> {\n+    cx: &'self mut Context,\n+\n+    /// Processed source-file paths\n     seen: HashSet<~str>,\n+    /// Root destination to place all HTML output into\n     dst: Path,\n-    cx: &'self mut Context,\n }\n \n+/// Wrapper struct to render the source code of a file. This will do things like\n+/// adding line numbers to the left-hand side.\n+struct Source<'self>(&'self str);\n+\n+// Helper structs for rendering items/sidebars and carrying along contextual\n+// information\n+\n struct Item<'self> { cx: &'self Context, item: &'self clean::Item, }\n struct Sidebar<'self> { cx: &'self Context, item: &'self clean::Item, }\n \n+/// Struct representing one entry in the JS search index. These are all emitted\n+/// by hand to a large JS file at the end of cache-creation.\n struct IndexItem {\n     ty: &'static str,\n     name: ~str,\n@@ -97,7 +199,7 @@ struct IndexItem {\n     parent: Option<ast::NodeId>,\n }\n \n-struct Source<'self>(&'self str);\n+// TLS keys used to carry information around during rendering.\n \n local_data_key!(pub cache_key: RWArc<Cache>)\n local_data_key!(pub current_location_key: ~[~str])\n@@ -211,11 +313,15 @@ pub fn run(mut crate: clean::Crate, dst: Path) {\n     cx.crate(crate, cache);\n }\n \n+/// Writes the entire contents of a string to a destination, not attempting to\n+/// catch any errors.\n fn write(dst: Path, contents: &str) {\n     let mut w = dst.open_writer(io::CreateOrTruncate);\n     w.write(contents.as_bytes());\n }\n \n+/// Makes a directory on the filesystem, failing the task if an error occurs and\n+/// skipping if the directory already exists.\n fn mkdir(path: &Path) {\n     do io::io_error::cond.trap(|err| {\n         error2!(\"Couldn't create directory `{}`: {}\",\n@@ -228,6 +334,9 @@ fn mkdir(path: &Path) {\n     }\n }\n \n+/// Takes a path to a source file and cleans the path to it. This canonicalizes\n+/// things like \".\" and \"..\" to components which preserve the \"top down\"\n+/// hierarchy of a static HTML tree.\n fn clean_srcpath(src: &str, f: &fn(&str)) {\n     let p = Path(src);\n     for c in p.components.iter() {\n@@ -242,6 +351,8 @@ fn clean_srcpath(src: &str, f: &fn(&str)) {\n     }\n }\n \n+/// Attempts to find where an external crate is located, given that we're\n+/// rendering in to the specified source destination.\n fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n     // See if there's documentation generated into the local directory\n     let local_location = dst.push(e.name);\n@@ -276,7 +387,10 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n \n impl<'self> DocFolder for SourceCollector<'self> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        // If we're including source files, and we haven't seen this file yet,\n+        // then we need to render it out to the filesystem\n         if self.cx.include_sources && !self.seen.contains(&item.source.filename) {\n+\n             // If it turns out that we couldn't read this file, then we probably\n             // can't read any of the files (generating html output from json or\n             // something like that), so just don't include sources for the\n@@ -292,11 +406,13 @@ impl<'self> DocFolder for SourceCollector<'self> {\n                 println!(\"         skipping rendering of source code\");\n             }\n         }\n+\n         self.fold_item_recur(item)\n     }\n }\n \n impl<'self> SourceCollector<'self> {\n+    /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> bool {\n         let p = Path(filename);\n \n@@ -539,9 +655,9 @@ impl<'self> Cache {\n }\n \n impl Context {\n+    /// Recurse in the directory structure and change the \"root path\" to make\n+    /// sure it always points to the top (relatively)\n     fn recurse<T>(&mut self, s: ~str, f: &fn(&mut Context) -> T) -> T {\n-        // Recurse in the directory structure and change the \"root path\" to make\n-        // sure it always points to the top (relatively)\n         if s.len() == 0 {\n             fail2!(\"what {:?}\", self);\n         }\n@@ -562,6 +678,9 @@ impl Context {\n         return ret;\n     }\n \n+    /// Main method for rendering a crate. This parallelizes the task of\n+    /// rendering a crate, and requires ownership of the crate in order to break\n+    /// it up into its separate components.\n     fn crate(self, mut crate: clean::Crate, cache: Cache) {\n         enum Work {\n             Die,\n@@ -583,6 +702,11 @@ impl Context {\n         let prog_chan = SharedChan::new(prog_chan);\n         let cache = RWArc::new(cache);\n \n+        // Each worker thread receives work from a shared port and publishes\n+        // new work onto the corresponding shared port. All of the workers are\n+        // using the same channel/port. Through this, the crate is recursed on\n+        // in a hierarchical fashion, and parallelization is only achieved if\n+        // one node in the hierarchy has more than one child (very common).\n         for i in range(0, WORKERS) {\n             let port = port.clone();\n             let chan = chan.clone();\n@@ -623,8 +747,12 @@ impl Context {\n             }\n         }\n \n+        // Send off the initial job\n         chan.send(Process(self, item));\n         let mut jobs = 1;\n+\n+        // Keep track of the number of jobs active in the system and kill\n+        // everything once there are no more jobs remaining.\n         loop {\n             match prog_port.recv() {\n                 JobNew => jobs += 1,\n@@ -639,6 +767,11 @@ impl Context {\n         }\n     }\n \n+    /// Non-parellelized version of rendering an item. This will take the input\n+    /// item, render its contents, and then invoke the specified closure with\n+    /// all sub-items which need to be rendered.\n+    ///\n+    /// The rendering driver uses this closure to queue up more work.\n     fn item(&mut self, item: clean::Item, f: &fn(&mut Context, clean::Item)) {\n         fn render(w: io::file::FileWriter, cx: &mut Context, it: &clean::Item,\n                   pushname: bool) {"}]}