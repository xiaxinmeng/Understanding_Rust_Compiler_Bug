{"sha": "3b7d496f72a3a9745756c88179b4a23cc550f89e", "node_id": "C_kwDOAAsO6NoAKDNiN2Q0OTZmNzJhM2E5NzQ1NzU2Yzg4MTc5YjRhMjNjYzU1MGY4OWU", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-11-18T22:29:07Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-07T21:31:36Z"}, "message": "Add query to avoid name comparison in `leaf_def`", "tree": {"sha": "5e63dfd1004a46b4904c78c666187742b3bb73a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e63dfd1004a46b4904c78c666187742b3bb73a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b7d496f72a3a9745756c88179b4a23cc550f89e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b7d496f72a3a9745756c88179b4a23cc550f89e", "html_url": "https://github.com/rust-lang/rust/commit/3b7d496f72a3a9745756c88179b4a23cc550f89e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b7d496f72a3a9745756c88179b4a23cc550f89e/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1", "html_url": "https://github.com/rust-lang/rust/commit/1b057a33bdf0eb6a49e49f036c84f6f1e84ce3a1"}], "stats": {"total": 203, "additions": 114, "deletions": 89}, "files": [{"sha": "f1c2be660bc76eef060939c766e8f3a70cde49f8", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=3b7d496f72a3a9745756c88179b4a23cc550f89e", "patch": "@@ -630,6 +630,32 @@ rustc_queries! {\n         desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n     }\n \n+    /// Maps from associated items on a trait to the corresponding associated\n+    /// item on the impl specified by `impl_id`.\n+    ///\n+    /// For example, with the following code\n+    ///\n+    /// ```\n+    /// struct Type {}\n+    ///                         // DefId\n+    /// trait Trait {           // trait_id\n+    ///     fn f();             // trait_f\n+    ///     fn g() {}           // trait_g\n+    /// }\n+    ///\n+    /// impl Trait for Type {   // impl_id\n+    ///     fn f() {}           // impl_f\n+    ///     fn g() {}           // impl_g\n+    /// }\n+    /// ```\n+    ///\n+    /// The map returned for `tcx.impl_item_implementor_ids(impl_id)` would be\n+    ///`{ trait_f: impl_f, trait_g: impl_g }`\n+    query impl_item_implementor_ids(impl_id: DefId) -> FxHashMap<DefId, DefId> {\n+        desc { |tcx| \"comparing impl items against trait for {}\", tcx.def_path_str(impl_id) }\n+        storage(ArenaCacheSelector<'tcx>)\n+    }\n+\n     /// Given an `impl_id`, return the trait it implements.\n     /// Return `None` if this is an inherent impl.\n     query impl_trait_ref(impl_id: DefId) -> Option<ty::TraitRef<'tcx>> {"}, {"sha": "087be313b26def87e4806eac693175ff3780ef97", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=3b7d496f72a3a9745756c88179b4a23cc550f89e", "patch": "@@ -4,7 +4,6 @@ use crate::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::{DefId, DefIdMap};\n-use rustc_span::symbol::Ident;\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n /// graph forms a tree rooted with the trait itself, with all other nodes\n@@ -75,34 +74,28 @@ pub enum Node {\n     Trait(DefId),\n }\n \n-impl<'tcx> Node {\n+impl Node {\n     pub fn is_from_trait(&self) -> bool {\n         matches!(self, Node::Trait(..))\n     }\n \n-    /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'tcx>) -> impl 'tcx + Iterator<Item = &'tcx ty::AssocItem> {\n-        tcx.associated_items(self.def_id()).in_definition_order()\n-    }\n-\n-    /// Finds an associated item defined in this node.\n+    /// Trys to find the associated item that implements `trait_item_def_id`\n+    /// defined in this node.\n     ///\n     /// If this returns `None`, the item can potentially still be found in\n     /// parents of this node.\n-    pub fn item(\n+    pub fn item<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        trait_item_name: Ident,\n-        trait_item_kind: ty::AssocKind,\n-        trait_def_id: DefId,\n-    ) -> Option<ty::AssocItem> {\n-        tcx.associated_items(self.def_id())\n-            .filter_by_name_unhygienic(trait_item_name.name)\n-            .find(move |impl_item| {\n-                trait_item_kind == impl_item.kind\n-                    && tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id)\n-            })\n-            .copied()\n+        trait_item_def_id: DefId,\n+    ) -> Option<&'tcx ty::AssocItem> {\n+        match *self {\n+            Node::Trait(_) => Some(tcx.associated_item(trait_item_def_id)),\n+            Node::Impl(impl_def_id) => {\n+                let id = tcx.impl_item_implementor_ids(impl_def_id).get(&trait_item_def_id)?;\n+                Some(tcx.associated_item(*id))\n+            }\n+        }\n     }\n \n     pub fn def_id(&self) -> DefId {\n@@ -181,17 +174,11 @@ impl LeafDef {\n impl<'tcx> Ancestors<'tcx> {\n     /// Finds the bottom-most (ie. most specialized) definition of an associated\n     /// item.\n-    pub fn leaf_def(\n-        mut self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_item_name: Ident,\n-        trait_item_kind: ty::AssocKind,\n-    ) -> Option<LeafDef> {\n-        let trait_def_id = self.trait_def_id;\n+    pub fn leaf_def(mut self, tcx: TyCtxt<'tcx>, trait_item_def_id: DefId) -> Option<LeafDef> {\n         let mut finalizing_node = None;\n \n         self.find_map(|node| {\n-            if let Some(item) = node.item(tcx, trait_item_name, trait_item_kind, trait_def_id) {\n+            if let Some(item) = node.item(tcx, trait_item_def_id) {\n                 if finalizing_node.is_none() {\n                     let is_specializable = item.defaultness.is_default()\n                         || tcx.impl_defaultness(node.def_id()).is_default();\n@@ -201,7 +188,7 @@ impl<'tcx> Ancestors<'tcx> {\n                     }\n                 }\n \n-                Some(LeafDef { item, defining_node: node, finalizing_node })\n+                Some(LeafDef { item: *item, defining_node: node, finalizing_node })\n             } else {\n                 // Item not mentioned. This \"finalizes\" any defaulted item provided by an ancestor.\n                 finalizing_node = Some(node);"}, {"sha": "3e06e7f36d419583a02dc03b48488dd8f7a92562", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=3b7d496f72a3a9745756c88179b4a23cc550f89e", "patch": "@@ -1310,10 +1310,9 @@ fn create_mono_items_for_default_impls<'tcx>(\n             if let Some(trait_ref) = tcx.impl_trait_ref(item.def_id) {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n-                let overridden_methods: FxHashSet<_> =\n-                    impl_.items.iter().map(|iiref| iiref.ident.normalize_to_macros_2_0()).collect();\n+                let overridden_methods = tcx.impl_item_implementor_ids(item.def_id);\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n-                    if overridden_methods.contains(&method.ident.normalize_to_macros_2_0()) {\n+                    if overridden_methods.contains_key(&method.def_id) {\n                         continue;\n                     }\n "}, {"sha": "b755f686f6aac15e5222a016f1a99ed1081ce7d5", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=3b7d496f72a3a9745756c88179b4a23cc550f89e", "patch": "@@ -93,26 +93,29 @@ impl<'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for CheckConstTraitVisitor<\n                     for trait_item in self.tcx.associated_items(trait_def_id).in_definition_order()\n                     {\n                         if let ty::AssocItem {\n-                            kind: ty::AssocKind::Fn, ident, defaultness, ..\n-                        } = trait_item\n+                            kind: ty::AssocKind::Fn,\n+                            defaultness,\n+                            def_id: trait_item_id,\n+                            ..\n+                        } = *trait_item\n                         {\n                             // we can ignore functions that do not have default bodies:\n                             // if those are unimplemented it will be catched by typeck.\n                             if !defaultness.has_value()\n                                 || self\n                                     .tcx\n-                                    .has_attr(trait_item.def_id, sym::default_method_body_is_const)\n+                                    .has_attr(trait_item_id, sym::default_method_body_is_const)\n                             {\n                                 continue;\n                             }\n \n                             let is_implemented = ancestors\n-                                .leaf_def(self.tcx, trait_item.ident, trait_item.kind)\n+                                .leaf_def(self.tcx, trait_item_id)\n                                 .map(|node_item| !node_item.defining_node.is_from_trait())\n                                 .unwrap_or(false);\n \n                             if !is_implemented {\n-                                to_implement.push(ident.to_string());\n+                                to_implement.push(self.tcx.item_name(trait_item_id).to_string());\n                             }\n                         }\n                     }"}, {"sha": "51bd505366c778e5b37fcfdbe29d3b802887fe55", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=3b7d496f72a3a9745756c88179b4a23cc550f89e", "patch": "@@ -1883,7 +1883,6 @@ fn assoc_ty_def(\n     assoc_ty_def_id: DefId,\n ) -> Result<specialization_graph::LeafDef, ErrorReported> {\n     let tcx = selcx.tcx();\n-    let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n     let trait_def = tcx.trait_def(trait_def_id);\n \n@@ -1893,21 +1892,18 @@ fn assoc_ty_def(\n     // for the associated item at the given impl.\n     // If there is no such item in that impl, this function will fail with a\n     // cycle error if the specialization graph is currently being built.\n-    let impl_node = specialization_graph::Node::Impl(impl_def_id);\n-    for item in impl_node.items(tcx) {\n-        if matches!(item.kind, ty::AssocKind::Type)\n-            && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n-        {\n-            return Ok(specialization_graph::LeafDef {\n-                item: *item,\n-                defining_node: impl_node,\n-                finalizing_node: if item.defaultness.is_default() { None } else { Some(impl_node) },\n-            });\n-        }\n+    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_ty_def_id) {\n+        let item = tcx.associated_item(impl_item_id);\n+        let impl_node = specialization_graph::Node::Impl(impl_def_id);\n+        return Ok(specialization_graph::LeafDef {\n+            item: *item,\n+            defining_node: impl_node,\n+            finalizing_node: if item.defaultness.is_default() { None } else { Some(impl_node) },\n+        });\n     }\n \n     let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n-    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_ty_name, ty::AssocKind::Type) {\n+    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_ty_def_id) {\n         Ok(assoc_item)\n     } else {\n         // This is saying that neither the trait nor\n@@ -1916,7 +1912,11 @@ fn assoc_ty_def(\n         // could only arise through a compiler bug --\n         // if the user wrote a bad item name, it\n         // should have failed in astconv.\n-        bug!(\"No associated type `{}` for {}\", assoc_ty_name, tcx.def_path_str(impl_def_id))\n+        bug!(\n+            \"No associated type `{}` for {}\",\n+            tcx.item_name(assoc_ty_def_id),\n+            tcx.def_path_str(impl_def_id)\n+        )\n     }\n }\n "}, {"sha": "72ffe9085cbe779069d17b908d36bf2435aa4c60", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=3b7d496f72a3a9745756c88179b4a23cc550f89e", "patch": "@@ -197,14 +197,13 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     item: Option<&hir::Item<'tcx>>,\n     cause: &mut traits::ObligationCause<'tcx>,\n     pred: &ty::Predicate<'tcx>,\n-    mut trait_assoc_items: impl Iterator<Item = &'tcx ty::AssocItem>,\n ) {\n     debug!(\n         \"extended_cause_with_original_assoc_item_obligation {:?} {:?} {:?} {:?}\",\n         trait_ref, item, cause, pred\n     );\n-    let items = match item {\n-        Some(hir::Item { kind: hir::ItemKind::Impl(impl_), .. }) => impl_.items,\n+    let (items, impl_def_id) = match item {\n+        Some(hir::Item { kind: hir::ItemKind::Impl(impl_), def_id, .. }) => (impl_.items, *def_id),\n         _ => return,\n     };\n     let fix_span =\n@@ -222,11 +221,16 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n             if let ty::Projection(projection_ty) = proj.ty.kind() {\n-                let trait_assoc_item = tcx.associated_item(projection_ty.item_def_id);\n-                if let Some(impl_item_span) =\n-                    items.iter().find(|item| item.ident == trait_assoc_item.ident).map(fix_span)\n+                if let Some(&impl_item_id) =\n+                    tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.item_def_id)\n                 {\n-                    cause.span = impl_item_span;\n+                    if let Some(impl_item_span) = items\n+                        .iter()\n+                        .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                        .map(fix_span)\n+                    {\n+                        cause.span = impl_item_span;\n+                    }\n                 }\n             }\n         }\n@@ -235,13 +239,16 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n             if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = *pred.self_ty().kind() {\n-                if let Some(impl_item_span) = trait_assoc_items\n-                    .find(|i| i.def_id == item_def_id)\n-                    .and_then(|trait_assoc_item| {\n-                        items.iter().find(|i| i.ident == trait_assoc_item.ident).map(fix_span)\n-                    })\n+                if let Some(&impl_item_id) =\n+                    tcx.impl_item_implementor_ids(impl_def_id).get(&item_def_id)\n                 {\n-                    cause.span = impl_item_span;\n+                    if let Some(impl_item_span) = items\n+                        .iter()\n+                        .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                        .map(fix_span)\n+                    {\n+                        cause.span = impl_item_span;\n+                    }\n                 }\n             }\n         }\n@@ -312,7 +319,6 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 item,\n                 &mut cause,\n                 &obligation.predicate,\n-                tcx.associated_items(trait_ref.def_id).in_definition_order(),\n             );\n             traits::Obligation::with_depth(cause, depth, param_env, obligation.predicate)\n         };"}, {"sha": "b1d47f6c29a21b81f8c9d4a2083b018e64f10e7f", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=3b7d496f72a3a9745756c88179b4a23cc550f89e", "patch": "@@ -1,3 +1,4 @@\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -8,6 +9,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         associated_item,\n         associated_item_def_ids,\n         associated_items,\n+        impl_item_implementor_ids,\n         trait_of_item,\n         ..*providers\n     };\n@@ -32,6 +34,13 @@ fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems<'_> {\n     ty::AssocItems::new(items)\n }\n \n+fn impl_item_implementor_ids(tcx: TyCtxt<'_>, impl_id: DefId) -> FxHashMap<DefId, DefId> {\n+    tcx.associated_items(impl_id)\n+        .in_definition_order()\n+        .filter_map(|item| item.trait_item_def_id.map(|trait_item| (trait_item, item.def_id)))\n+        .collect()\n+}\n+\n /// If the given `DefId` describes an item belonging to a trait,\n /// returns the `DefId` of the trait that the trait item belongs to;\n /// otherwise, returns `None`."}, {"sha": "e0aea786b837a26fb9edb33811d1bbef8cdc92f9", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7d496f72a3a9745756c88179b4a23cc550f89e/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=3b7d496f72a3a9745756c88179b4a23cc550f89e", "patch": "@@ -152,8 +152,7 @@ fn inner_resolve_instance<'tcx>(\n \n     let result = if let Some(trait_def_id) = tcx.trait_of_item(def.did) {\n         debug!(\" => associated item, attempting to find impl in param_env {:#?}\", param_env);\n-        let item = tcx.associated_item(def.did);\n-        resolve_associated_item(tcx, &item, param_env, trait_def_id, substs)\n+        resolve_associated_item(tcx, def.did, param_env, trait_def_id, substs)\n     } else {\n         let ty = tcx.type_of(def.def_id_for_type_of());\n         let item_type = tcx.subst_and_normalize_erasing_regions(substs, param_env, ty);\n@@ -204,19 +203,12 @@ fn inner_resolve_instance<'tcx>(\n \n fn resolve_associated_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    trait_item: &ty::AssocItem,\n+    trait_item_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_id: DefId,\n     rcvr_substs: SubstsRef<'tcx>,\n ) -> Result<Option<Instance<'tcx>>, ErrorReported> {\n-    let def_id = trait_item.def_id;\n-    debug!(\n-        \"resolve_associated_item(trait_item={:?}, \\\n-            param_env={:?}, \\\n-            trait_id={:?}, \\\n-            rcvr_substs={:?})\",\n-        def_id, param_env, trait_id, rcvr_substs\n-    );\n+    debug!(?trait_item_id, ?param_env, ?trait_id, ?rcvr_substs, \"resolve_associated_item\");\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n \n@@ -232,7 +224,7 @@ fn resolve_associated_item<'tcx>(\n         traits::ImplSource::UserDefined(impl_data) => {\n             debug!(\n                 \"resolving ImplSource::UserDefined: {:?}, {:?}, {:?}, {:?}\",\n-                param_env, trait_item, rcvr_substs, impl_data\n+                param_env, trait_item_id, rcvr_substs, impl_data\n             );\n             assert!(!rcvr_substs.needs_infer());\n             assert!(!trait_ref.needs_infer());\n@@ -241,9 +233,9 @@ fn resolve_associated_item<'tcx>(\n             let trait_def = tcx.trait_def(trait_def_id);\n             let leaf_def = trait_def\n                 .ancestors(tcx, impl_data.impl_def_id)?\n-                .leaf_def(tcx, trait_item.ident, trait_item.kind)\n+                .leaf_def(tcx, trait_item_id)\n                 .unwrap_or_else(|| {\n-                    bug!(\"{:?} not found in {:?}\", trait_item, impl_data.impl_def_id);\n+                    bug!(\"{:?} not found in {:?}\", trait_item_id, impl_data.impl_def_id);\n                 });\n \n             let substs = tcx.infer_ctxt().enter(|infcx| {\n@@ -297,22 +289,22 @@ fn resolve_associated_item<'tcx>(\n             // performs (i.e. that the definition's type in the `impl` matches\n             // the declaration in the `trait`), so that we can cheaply check\n             // here if it failed, instead of approximating it.\n-            if trait_item.kind == ty::AssocKind::Const\n-                && trait_item.def_id != leaf_def.item.def_id\n+            if leaf_def.item.kind == ty::AssocKind::Const\n+                && trait_item_id != leaf_def.item.def_id\n                 && leaf_def.item.def_id.is_local()\n             {\n                 let normalized_type_of = |def_id, substs| {\n                     tcx.subst_and_normalize_erasing_regions(substs, param_env, tcx.type_of(def_id))\n                 };\n \n-                let original_ty = normalized_type_of(trait_item.def_id, rcvr_substs);\n+                let original_ty = normalized_type_of(trait_item_id, rcvr_substs);\n                 let resolved_ty = normalized_type_of(leaf_def.item.def_id, substs);\n \n                 if original_ty != resolved_ty {\n                     let msg = format!(\n                         \"Instance::resolve: inconsistent associated `const` type: \\\n                          was `{}: {}` but resolved to `{}: {}`\",\n-                        tcx.def_path_str_with_substs(trait_item.def_id, rcvr_substs),\n+                        tcx.def_path_str_with_substs(trait_item_id, rcvr_substs),\n                         original_ty,\n                         tcx.def_path_str_with_substs(leaf_def.item.def_id, substs),\n                         resolved_ty,\n@@ -343,19 +335,22 @@ fn resolve_associated_item<'tcx>(\n         }\n         traits::ImplSource::FnPointer(ref data) => match data.fn_ty.kind() {\n             ty::FnDef(..) | ty::FnPtr(..) => Some(Instance {\n-                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+                def: ty::InstanceDef::FnPtrShim(trait_item_id, data.fn_ty),\n                 substs: rcvr_substs,\n             }),\n             _ => None,\n         },\n         traits::ImplSource::Object(ref data) => {\n-            let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n-            Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n+            let index = traits::get_vtable_index_of_object_method(tcx, data, trait_item_id);\n+            Some(Instance {\n+                def: ty::InstanceDef::Virtual(trait_item_id, index),\n+                substs: rcvr_substs,\n+            })\n         }\n         traits::ImplSource::Builtin(..) => {\n             if Some(trait_ref.def_id) == tcx.lang_items().clone_trait() {\n                 // FIXME(eddyb) use lang items for methods instead of names.\n-                let name = tcx.item_name(def_id);\n+                let name = tcx.item_name(trait_item_id);\n                 if name == sym::clone {\n                     let self_ty = trait_ref.self_ty();\n \n@@ -367,15 +362,15 @@ fn resolve_associated_item<'tcx>(\n                     };\n \n                     Some(Instance {\n-                        def: ty::InstanceDef::CloneShim(def_id, self_ty),\n+                        def: ty::InstanceDef::CloneShim(trait_item_id, self_ty),\n                         substs: rcvr_substs,\n                     })\n                 } else {\n                     assert_eq!(name, sym::clone_from);\n \n                     // Use the default `fn clone_from` from `trait Clone`.\n                     let substs = tcx.erase_regions(rcvr_substs);\n-                    Some(ty::Instance::new(def_id, substs))\n+                    Some(ty::Instance::new(trait_item_id, substs))\n                 }\n             } else {\n                 None"}]}