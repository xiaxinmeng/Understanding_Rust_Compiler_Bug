{"sha": "b107a4e4f669454b74dcc438c29b691c0bae086e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMDdhNGU0ZjY2OTQ1NGI3NGRjYzQzOGMyOWI2OTFjMGJhZTA4NmU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-28T02:34:01Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-01T19:06:45Z"}, "message": "Refactor `module.try_define_child(..)` -> `resolver.try_define(module, ..)`.", "tree": {"sha": "ed16e0ee2018f1713ec8dd06c5f2a4724e8f0321", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed16e0ee2018f1713ec8dd06c5f2a4724e8f0321"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b107a4e4f669454b74dcc438c29b691c0bae086e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b107a4e4f669454b74dcc438c29b691c0bae086e", "html_url": "https://github.com/rust-lang/rust/commit/b107a4e4f669454b74dcc438c29b691c0bae086e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b107a4e4f669454b74dcc438c29b691c0bae086e/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "096c3ed6c6ed98147d5d22ba5c5b0c109912b837", "url": "https://api.github.com/repos/rust-lang/rust/commits/096c3ed6c6ed98147d5d22ba5c5b0c109912b837", "html_url": "https://github.com/rust-lang/rust/commit/096c3ed6c6ed98147d5d22ba5c5b0c109912b837"}], "stats": {"total": 144, "additions": 75, "deletions": 69}, "files": [{"sha": "116c1b7a6d06f811eb29829e316cfedfe093d1e6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b107a4e4f669454b74dcc438c29b691c0bae086e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b107a4e4f669454b74dcc438c29b691c0bae086e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b107a4e4f669454b74dcc438c29b691c0bae086e", "patch": "@@ -16,7 +16,7 @@\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n-use {NameBinding, NameBindingKind};\n+use {NameBinding, NameBindingKind, ToNameBinding};\n use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n@@ -39,10 +39,6 @@ use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n-trait ToNameBinding<'a> {\n-    fn to_name_binding(self) -> NameBinding<'a>;\n-}\n-\n impl<'a> ToNameBinding<'a> for (Module<'a>, Span, ty::Visibility) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n         NameBinding { kind: NameBindingKind::Module(self.0), span: self.1, vis: self.2 }\n@@ -68,18 +64,13 @@ impl<'b> Resolver<'b> {\n         visit::walk_crate(&mut visitor, krate);\n     }\n \n-    /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined.\n-    fn try_define<T>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n-        where T: ToNameBinding<'b>\n-    {\n-        let _ = parent.try_define_child(name, ns, def.to_name_binding());\n-    }\n-\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    fn define<T: ToNameBinding<'b>>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T) {\n+    fn define<T>(&mut self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n+        where T: ToNameBinding<'b>,\n+    {\n         let binding = def.to_name_binding();\n-        if let Err(old_binding) = parent.try_define_child(name, ns, binding.clone()) {\n+        if let Err(old_binding) = self.try_define(parent, name, ns, binding.clone()) {\n             self.report_conflict(parent, name, ns, old_binding, &binding);\n         }\n     }\n@@ -399,14 +390,14 @@ impl<'b> Resolver<'b> {\n                        name, vis);\n                 let parent_link = ModuleParentLink(parent, name);\n                 let module = self.new_module(parent_link, Some(def), true);\n-                self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::Variant(_, variant_id) => {\n                 debug!(\"(building reduced graph for external crate) building variant {}\", name);\n                 // Variants are always treated as importable to allow them to be glob used.\n                 // All variants are defined in both type and value namespaces as future-proofing.\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n                 if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n                     // Not adding fields for variants as they are not accessed with a self receiver\n                     self.structs.insert(variant_id, Vec::new());\n@@ -419,7 +410,7 @@ impl<'b> Resolver<'b> {\n             Def::Method(..) => {\n                 debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n                        name);\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n             Def::Trait(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n@@ -441,20 +432,20 @@ impl<'b> Resolver<'b> {\n \n                 let parent_link = ModuleParentLink(parent, name);\n                 let module = self.new_module(parent_link, Some(def), true);\n-                self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n             }\n             Def::Struct(def_id)\n                 if self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_none() => {\n                 debug!(\"(building reduced graph for external crate) building type and value for {}\",\n                        name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n                 if let Some(ctor_def_id) = self.session.cstore.struct_ctor_def_id(def_id) {\n                     let def = Def::Struct(ctor_def_id);\n-                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                    let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n                 }\n \n                 // Record the def ID and fields of this struct."}, {"sha": "56b92d169b093091e8212137dae133c7fa52cb12", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b107a4e4f669454b74dcc438c29b691c0bae086e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b107a4e4f669454b74dcc438c29b691c0bae086e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b107a4e4f669454b74dcc438c29b691c0bae086e", "patch": "@@ -818,6 +818,16 @@ pub struct NameBinding<'a> {\n     vis: ty::Visibility,\n }\n \n+pub trait ToNameBinding<'a> {\n+    fn to_name_binding(self) -> NameBinding<'a>;\n+}\n+\n+impl<'a> ToNameBinding<'a> for NameBinding<'a> {\n+    fn to_name_binding(self) -> NameBinding<'a> {\n+        self\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n enum NameBindingKind<'a> {\n     Def(Def),"}, {"sha": "feec81b9fc9badfba0f0b7277deea4b3929a467f", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 52, "deletions": 47, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b107a4e4f669454b74dcc438c29b691c0bae086e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b107a4e4f669454b74dcc438c29b691c0bae086e/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b107a4e4f669454b74dcc438c29b691c0bae086e", "patch": "@@ -12,7 +12,7 @@ use self::ImportDirectiveSubclass::*;\n \n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n-use {NameBinding, NameBindingKind, PrivacyError};\n+use {NameBinding, NameBindingKind, PrivacyError, ToNameBinding};\n use ResolveResult;\n use ResolveResult::*;\n use Resolver;\n@@ -226,28 +226,6 @@ impl<'a> ::ModuleS<'a> {\n         Failed(None)\n     }\n \n-    // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n-                            -> Result<(), &'a NameBinding<'a>> {\n-        let binding = self.arenas.alloc_name_binding(binding);\n-        self.update_resolution(name, ns, |resolution| {\n-            if let Some(old_binding) = resolution.binding {\n-                if binding.is_glob_import() {\n-                    resolution.duplicate_globs.push(binding);\n-                } else if old_binding.is_glob_import() {\n-                    resolution.duplicate_globs.push(old_binding);\n-                    resolution.binding = Some(binding);\n-                } else {\n-                    return Err(old_binding);\n-                }\n-            } else {\n-                resolution.binding = Some(binding);\n-            }\n-\n-            Ok(())\n-        })\n-    }\n-\n     pub fn add_import_directive(&self,\n                                 module_path: Vec<Name>,\n                                 subclass: ImportDirectiveSubclass,\n@@ -277,19 +255,45 @@ impl<'a> ::ModuleS<'a> {\n             GlobImport { .. } => self.globs.borrow_mut().push(directive),\n         }\n     }\n+}\n \n-    // Use `update` to mutate the resolution for the name.\n+impl<'a> Resolver<'a> {\n+    // Define the name or return the existing binding if there is a collision.\n+    pub fn try_define<T>(&mut self, module: Module<'a>, name: Name, ns: Namespace, binding: T)\n+                         -> Result<(), &'a NameBinding<'a>>\n+        where T: ToNameBinding<'a>\n+    {\n+        let binding = self.arenas.alloc_name_binding(binding.to_name_binding());\n+        self.update_resolution(module, name, ns, |_, resolution| {\n+            if let Some(old_binding) = resolution.binding {\n+                if binding.is_glob_import() {\n+                    resolution.duplicate_globs.push(binding);\n+                } else if old_binding.is_glob_import() {\n+                    resolution.duplicate_globs.push(old_binding);\n+                    resolution.binding = Some(binding);\n+                } else {\n+                    return Err(old_binding);\n+                }\n+            } else {\n+                resolution.binding = Some(binding);\n+            }\n+\n+            Ok(())\n+        })\n+    }\n+\n+    // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n-    fn update_resolution<T, F>(&self, name: Name, ns: Namespace, update: F) -> T\n-        where F: FnOnce(&mut NameResolution<'a>) -> T\n+    fn update_resolution<T, F>(&mut self, module: Module<'a>, name: Name, ns: Namespace, f: F) -> T\n+        where F: FnOnce(&mut Resolver<'a>, &mut NameResolution<'a>) -> T\n     {\n-        // Ensure that `resolution` isn't borrowed during `define_in_glob_importers`,\n-        // where it might end up getting re-defined via a glob cycle.\n+        // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n+        // during which the resolution might end up getting re-defined via a glob cycle.\n         let (new_binding, t) = {\n-            let mut resolution = &mut *self.resolution(name, ns).borrow_mut();\n+            let mut resolution = &mut *module.resolution(name, ns).borrow_mut();\n             let was_known = resolution.binding().is_some();\n \n-            let t = update(resolution);\n+            let t = f(self, resolution);\n \n             if was_known { return t; }\n             match resolution.binding() {\n@@ -298,15 +302,14 @@ impl<'a> ::ModuleS<'a> {\n             }\n         };\n \n-        self.define_in_glob_importers(name, ns, new_binding);\n-        t\n-    }\n-\n-    fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n-        if !binding.is_importable() || !binding.is_pseudo_public() { return }\n-        for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n-            let _ = importer.try_define_child(name, ns, directive.import(binding));\n+        // Define `new_binding` in `module`s glob importers.\n+        if new_binding.is_importable() && new_binding.is_pseudo_public() {\n+            for &(importer, directive) in module.glob_importers.borrow_mut().iter() {\n+                let _ = self.try_define(importer, name, ns, directive.import(new_binding));\n+            }\n         }\n+\n+        t\n     }\n }\n \n@@ -396,7 +399,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n     // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n     // failed resolution\n-    fn import_dummy_binding(&self, source_module: Module<'b>, directive: &'b ImportDirective<'b>) {\n+    fn import_dummy_binding(&mut self,\n+                            source_module: Module<'b>,\n+                            directive: &'b ImportDirective<'b>) {\n         if let SingleImport { target, .. } = directive.subclass {\n             let dummy_binding = self.arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Def(Def::Err),\n@@ -405,14 +410,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             });\n             let dummy_binding = directive.import(dummy_binding);\n \n-            let _ = source_module.try_define_child(target, ValueNS, dummy_binding.clone());\n-            let _ = source_module.try_define_child(target, TypeNS, dummy_binding);\n+            let _ = self.try_define(source_module, target, ValueNS, dummy_binding.clone());\n+            let _ = self.try_define(source_module, target, TypeNS, dummy_binding);\n         }\n     }\n \n     /// Resolves an `ImportResolvingError` into the correct enum discriminant\n     /// and passes that on to `resolve_error`.\n-    fn import_resolving_error(&self, e: ImportResolvingError<'b>) {\n+    fn import_resolving_error(&mut self, e: ImportResolvingError<'b>) {\n         // If the error is a single failed import then create a \"fake\" import\n         // resolution for it so that later resolve stages won't complain.\n         self.import_dummy_binding(e.source_module, e.import_directive);\n@@ -492,7 +497,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             match *result {\n                 Failed(..) if !determined.get() => {\n                     determined.set(true);\n-                    module_.update_resolution(target, ns, |resolution| {\n+                    self.update_resolution(module_, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n@@ -508,7 +513,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Success(binding) if !determined.get() => {\n                     determined.set(true);\n                     let imported_binding = directive.import(binding);\n-                    let conflict = module_.try_define_child(target, ns, imported_binding);\n+                    let conflict = self.try_define(module_, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n                         let binding = &directive.import(binding);\n                         self.report_conflict(module_, target, ns, binding, old_binding);\n@@ -551,7 +556,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n                 let binding = match *result { Success(binding) => binding, _ => continue };\n                 self.privacy_errors.push(PrivacyError(directive.span, source, binding));\n-                let _ = module_.try_define_child(target, ns, directive.import(binding));\n+                let _ = self.try_define(module_, target, ns, directive.import(binding));\n             }\n         }\n \n@@ -626,14 +631,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         // Add to target_module's glob_importers\n         target_module.glob_importers.borrow_mut().push((module_, directive));\n \n-        // Ensure that `resolutions` isn't borrowed during `try_define_child`,\n+        // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n         let bindings = target_module.resolutions.borrow().iter().filter_map(|(name, resolution)| {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n             if binding.is_importable() && binding.is_pseudo_public() {\n-                let _ = module_.try_define_child(name, ns, directive.import(binding));\n+                let _ = self.try_define(module_, name, ns, directive.import(binding));\n             }\n         }\n "}]}