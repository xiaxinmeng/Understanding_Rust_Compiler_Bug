{"sha": "a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZDA4MTJlZDE1YmJkOGQ4ZTAwNGViNWMwOWZkYWNkZDBhMjA1YTA=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-10T15:54:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-10T15:54:22Z"}, "message": "Merge pull request #20 from oli-obk/error_reporting\n\nvarious fixes and refactorings", "tree": {"sha": "f7d74838129d13f97a4b5355990b34499ab770fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7d74838129d13f97a4b5355990b34499ab770fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0", "html_url": "https://github.com/rust-lang/rust/commit/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1186a7d05dacc0696b56244d83ec19e85e3555a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1186a7d05dacc0696b56244d83ec19e85e3555a6", "html_url": "https://github.com/rust-lang/rust/commit/1186a7d05dacc0696b56244d83ec19e85e3555a6"}, {"sha": "cea2a8ae9eeadd02b3da38d819f95741449dd4e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/cea2a8ae9eeadd02b3da38d819f95741449dd4e0", "html_url": "https://github.com/rust-lang/rust/commit/cea2a8ae9eeadd02b3da38d819f95741449dd4e0"}], "stats": {"total": 520, "additions": 228, "deletions": 292}, "files": [{"sha": "82702ae43788087ef42199340f720c8369a9b56c", "filename": "src/bin/miri.rs", "status": "modified", "additions": 84, "deletions": 3, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0", "patch": "@@ -7,11 +7,21 @@ extern crate rustc;\n extern crate rustc_driver;\n extern crate env_logger;\n extern crate log_settings;\n-extern crate log;\n+extern crate syntax;\n+#[macro_use] extern crate log;\n \n-use miri::interpreter;\n+use miri::{\n+    EvalContext,\n+    CachedMir,\n+    step,\n+    EvalError,\n+    Frame,\n+};\n use rustc::session::Session;\n use rustc_driver::{driver, CompilerCalls};\n+use rustc::ty::{TyCtxt, subst};\n+use rustc::mir::mir_map::MirMap;\n+use rustc::hir::def_id::DefId;\n \n struct MiriCompilerCalls;\n \n@@ -25,13 +35,84 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n \n         control.after_analysis.callback = Box::new(|state| {\n             state.session.abort_if_errors();\n-            interpreter::interpret_start_points(state.tcx.unwrap(), state.mir_map.unwrap());\n+            interpret_start_points(state.tcx.unwrap(), state.mir_map.unwrap());\n         });\n \n         control\n     }\n }\n \n+\n+\n+fn interpret_start_points<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir_map: &MirMap<'tcx>,\n+) {\n+    let initial_indentation = ::log_settings::settings().indentation;\n+    for (&id, mir) in &mir_map.map {\n+        for attr in tcx.map.attrs(id) {\n+            use syntax::attr::AttrMetaMethods;\n+            if attr.check_name(\"miri_run\") {\n+                let item = tcx.map.expect_item(id);\n+\n+                ::log_settings::settings().indentation = initial_indentation;\n+\n+                debug!(\"Interpreting: {}\", item.name);\n+\n+                let mut ecx = EvalContext::new(tcx, mir_map);\n+                let substs = tcx.mk_substs(subst::Substs::empty());\n+                let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs);\n+\n+                ecx.push_stack_frame(tcx.map.local_def_id(id), mir.span, CachedMir::Ref(mir), substs, return_ptr);\n+\n+                loop {\n+                    match (step(&mut ecx), return_ptr) {\n+                        (Ok(true), _) => {},\n+                        (Ok(false), Some(ptr)) => if log_enabled!(::log::LogLevel::Debug) {\n+                            ecx.memory().dump(ptr.alloc_id);\n+                            break;\n+                        },\n+                        (Ok(false), None) => {\n+                            warn!(\"diverging function returned\");\n+                            break;\n+                        },\n+                        // FIXME: diverging functions can end up here in some future miri\n+                        (Err(e), _) => {\n+                            report(tcx, &ecx, e);\n+                            break;\n+                        },\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n+    let frame = ecx.stack().last().expect(\"stackframe was empty\");\n+    let block = frame.mir.basic_block_data(frame.next_block);\n+    let span = if frame.stmt < block.statements.len() {\n+        block.statements[frame.stmt].span\n+    } else {\n+        block.terminator().span\n+    };\n+    let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n+    for &Frame { def_id, substs, span, .. } in ecx.stack().iter().rev() {\n+        // FIXME(solson): Find a way to do this without this Display impl hack.\n+        use rustc::util::ppaux;\n+        use std::fmt;\n+        struct Instance<'tcx>(DefId, &'tcx subst::Substs<'tcx>);\n+        impl<'tcx> fmt::Display for Instance<'tcx> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n+                    |tcx| tcx.lookup_item_type(self.0).generics)\n+            }\n+        }\n+        err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n+    }\n+    err.emit();\n+}\n+\n #[miri_run]\n fn main() {\n     init_logger();"}, {"sha": "6831ab212fb356febf647150256bd00b06f9deb9", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 77, "deletions": 213, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0", "patch": "@@ -9,7 +9,7 @@ use rustc::ty::subst::{self, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::DefIdMap;\n use std::cell::RefCell;\n-use std::ops::{Deref, DerefMut};\n+use std::ops::Deref;\n use std::rc::Rc;\n use std::{iter, mem};\n use syntax::ast;\n@@ -24,7 +24,11 @@ use std::collections::HashMap;\n \n mod stepper;\n \n-struct GlobalEvalContext<'a, 'tcx: 'a> {\n+pub fn step<'ecx, 'a: 'ecx, 'tcx: 'a>(ecx: &'ecx mut EvalContext<'a, 'tcx>) -> EvalResult<bool> {\n+    stepper::Stepper::new(ecx).step()\n+}\n+\n+pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n@@ -39,61 +43,44 @@ struct GlobalEvalContext<'a, 'tcx: 'a> {\n \n     /// Precomputed statics, constants and promoteds\n     statics: HashMap<ConstantId<'tcx>, Pointer>,\n-}\n-\n-struct FnEvalContext<'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> {\n-    gecx: &'a mut GlobalEvalContext<'b, 'tcx>,\n \n     /// The virtual call stack.\n-    stack: Vec<Frame<'mir, 'tcx>>,\n-}\n-\n-impl<'a, 'b, 'mir, 'tcx> Deref for FnEvalContext<'a, 'b, 'mir, 'tcx> {\n-    type Target = GlobalEvalContext<'b, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        self.gecx\n-    }\n-}\n-\n-impl<'a, 'b, 'mir, 'tcx> DerefMut for FnEvalContext<'a, 'b, 'mir, 'tcx> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.gecx\n-    }\n+    stack: Vec<Frame<'a, 'tcx>>,\n }\n \n /// A stack frame.\n-struct Frame<'a, 'tcx: 'a> {\n+pub struct Frame<'a, 'tcx: 'a> {\n     /// The def_id of the current function\n-    def_id: DefId,\n+    pub def_id: DefId,\n \n     /// The span of the call site\n-    span: codemap::Span,\n+    pub span: codemap::Span,\n \n     /// type substitutions for the current function invocation\n-    substs: &'tcx Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n \n     /// The MIR for the function called on this frame.\n-    mir: CachedMir<'a, 'tcx>,\n+    pub mir: CachedMir<'a, 'tcx>,\n \n     /// The block that is currently executed (or will be executed after the above call stacks return)\n-    next_block: mir::BasicBlock,\n+    pub next_block: mir::BasicBlock,\n \n     /// A pointer for writing the return value of the current call if it's not a diverging call.\n-    return_ptr: Option<Pointer>,\n+    pub return_ptr: Option<Pointer>,\n \n     /// The list of locals for the current function, stored in order as\n     /// `[arguments..., variables..., temporaries...]`. The variables begin at `self.var_offset`\n     /// and the temporaries at `self.temp_offset`.\n-    locals: Vec<Pointer>,\n+    pub locals: Vec<Pointer>,\n \n     /// The offset of the first variable in `self.locals`.\n-    var_offset: usize,\n+    pub var_offset: usize,\n \n     /// The offset of the first temporary in `self.locals`.\n-    temp_offset: usize,\n+    pub temp_offset: usize,\n \n     /// The index of the currently evaluated statment\n-    stmt: usize,\n+    pub stmt: usize,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -111,23 +98,11 @@ enum LvalueExtra {\n }\n \n #[derive(Clone)]\n-enum CachedMir<'mir, 'tcx: 'mir> {\n+pub enum CachedMir<'mir, 'tcx: 'mir> {\n     Ref(&'mir mir::Mir<'tcx>),\n     Owned(Rc<mir::Mir<'tcx>>)\n }\n \n-/// Represents the action to be taken in the main loop as a result of executing a terminator.\n-enum TerminatorTarget {\n-    /// Make a local jump to the next block\n-    Block,\n-\n-    /// Start executing from the new current frame. (For function calls.)\n-    Call,\n-\n-    /// Stop executing the current frame and resume the previous frame.\n-    Return,\n-}\n-\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n /// Uniquely identifies a specific constant or static\n struct ConstantId<'tcx> {\n@@ -148,9 +123,9 @@ enum ConstantKind {\n     Global,\n }\n \n-impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n-        GlobalEvalContext {\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n+        EvalContext {\n             tcx: tcx,\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n@@ -160,24 +135,11 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n                                    .bit_width()\n                                    .expect(\"Session::target::uint_type was usize\")/8),\n             statics: HashMap::new(),\n+            stack: Vec::new(),\n         }\n     }\n \n-    fn call(&mut self, mir: &mir::Mir<'tcx>, def_id: DefId) -> EvalResult<Option<Pointer>> {\n-        let substs = self.tcx.mk_substs(subst::Substs::empty());\n-        let return_ptr = self.alloc_ret_ptr(mir.return_ty, substs);\n-\n-        let mut nested_fecx = FnEvalContext::new(self);\n-\n-        nested_fecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, None);\n-\n-        nested_fecx.frame_mut().return_ptr = return_ptr;\n-\n-        nested_fecx.run()?;\n-        Ok(return_ptr)\n-    }\n-\n-    fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<Pointer> {\n+    pub fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<Pointer> {\n         match output_ty {\n             ty::FnConverging(ty) => {\n                 let size = self.type_size(ty, substs);\n@@ -187,6 +149,14 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n         }\n     }\n \n+    pub fn memory(&self) -> &Memory {\n+        &self.memory\n+    }\n+\n+    pub fn stack(&self) -> &[Frame] {\n+        &self.stack\n+    }\n+\n     // TODO(solson): Try making const_to_primval instead.\n     fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<Pointer> {\n         use rustc::middle::const_val::ConstVal::*;\n@@ -349,57 +319,8 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n             ty.layout(&infcx).unwrap()\n         })\n     }\n-}\n-\n-impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n-    fn new(gecx: &'a mut GlobalEvalContext<'b, 'tcx>) -> Self {\n-        FnEvalContext {\n-            gecx: gecx,\n-            stack: Vec::new(),\n-        }\n-    }\n-\n-    #[inline(never)]\n-    #[cold]\n-    fn report(&self, e: &EvalError) {\n-        let stmt = self.frame().stmt;\n-        let block = self.basic_block();\n-        let span = if stmt < block.statements.len() {\n-            block.statements[stmt].span\n-        } else {\n-            block.terminator().span\n-        };\n-        let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n-        for &Frame{ def_id, substs, span, .. } in self.stack.iter().rev() {\n-            // FIXME(solson): Find a way to do this without this Display impl hack.\n-            use rustc::util::ppaux;\n-            use std::fmt;\n-            struct Instance<'tcx>(DefId, &'tcx Substs<'tcx>);\n-            impl<'tcx> fmt::Display for Instance<'tcx> {\n-                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n-                        |tcx| tcx.lookup_item_type(self.0).generics)\n-                }\n-            }\n-            err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n-        }\n-        err.emit();\n-    }\n \n-    fn maybe_report<T>(&self, r: EvalResult<T>) -> EvalResult<T> {\n-        if let Err(ref e) = r {\n-            self.report(e);\n-        }\n-        r\n-    }\n-\n-    fn run(&mut self) -> EvalResult<()> {\n-        let mut stepper = stepper::Stepper::new(self);\n-        while stepper.step()? {}\n-        Ok(())\n-    }\n-\n-    fn push_stack_frame(&mut self, def_id: DefId, span: codemap::Span, mir: CachedMir<'mir, 'tcx>, substs: &'tcx Substs<'tcx>,\n+    pub fn push_stack_frame(&mut self, def_id: DefId, span: codemap::Span, mir: CachedMir<'a, 'tcx>, substs: &'tcx Substs<'tcx>,\n         return_ptr: Option<Pointer>)\n     {\n         let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n@@ -411,25 +332,23 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n         ::log_settings::settings().indentation += 1;\n \n+        let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n+            let size = self.type_size(ty, substs);\n+            self.memory.allocate(size)\n+        }).collect();\n+\n         self.stack.push(Frame {\n             mir: mir.clone(),\n             next_block: mir::START_BLOCK,\n             return_ptr: return_ptr,\n-            locals: Vec::new(),\n+            locals: locals,\n             var_offset: num_args,\n             temp_offset: num_args + num_vars,\n             span: span,\n             def_id: def_id,\n             substs: substs,\n             stmt: 0,\n         });\n-\n-        let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n-            let size = self.type_size(ty);\n-            self.memory.allocate(size)\n-        }).collect();\n-\n-        self.frame_mut().locals = locals;\n     }\n \n     fn pop_stack_frame(&mut self) {\n@@ -439,27 +358,25 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     }\n \n     fn eval_terminator(&mut self, terminator: &mir::Terminator<'tcx>)\n-            -> EvalResult<TerminatorTarget> {\n+            -> EvalResult<()> {\n         use rustc::mir::repr::TerminatorKind::*;\n-        let target = match terminator.kind {\n-            Return => TerminatorTarget::Return,\n+        match terminator.kind {\n+            Return => self.pop_stack_frame(),\n \n             Goto { target } => {\n                 self.frame_mut().next_block = target;\n-                TerminatorTarget::Block\n             },\n \n             If { ref cond, targets: (then_target, else_target) } => {\n                 let cond_ptr = self.eval_operand(cond)?;\n                 let cond_val = self.memory.read_bool(cond_ptr)?;\n                 self.frame_mut().next_block = if cond_val { then_target } else { else_target };\n-                TerminatorTarget::Block\n             }\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n                 let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n                 let discr_size = self\n-                    .type_layout(self.lvalue_ty(discr))\n+                    .type_layout(self.lvalue_ty(discr), self.substs())\n                     .size(&self.tcx.data_layout)\n                     .bytes() as usize;\n                 let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n@@ -477,7 +394,6 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 }\n \n                 self.frame_mut().next_block = target_block;\n-                TerminatorTarget::Block\n             }\n \n             Switch { ref discr, ref targets, adt_def } => {\n@@ -490,7 +406,6 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 match matching {\n                     Some(i) => {\n                         self.frame_mut().next_block = targets[i];\n-                        TerminatorTarget::Block\n                     },\n                     None => return Err(EvalError::InvalidDiscriminant),\n                 }\n@@ -512,7 +427,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                 let name = self.tcx.item_name(def_id).as_str();\n                                 match fn_ty.sig.0.output {\n                                     ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty);\n+                                        let size = self.type_size(ty, self.substs());\n                                         let ret = return_ptr.unwrap();\n                                         self.call_intrinsic(&name, substs, args, ret, size)?\n                                     }\n@@ -523,7 +438,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                             Abi::C => {\n                                 match fn_ty.sig.0.output {\n                                     ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty);\n+                                        let size = self.type_size(ty, self.substs());\n                                         self.call_c_abi(def_id, args, return_ptr.unwrap(), size)?\n                                     }\n                                     ty::FnDiverging => unimplemented!(),\n@@ -553,7 +468,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                     let last_arg = args.last().unwrap();\n                                     let last = self.eval_operand(last_arg)?;\n                                     let last_ty = self.operand_ty(last_arg);\n-                                    let last_layout = self.type_layout(last_ty);\n+                                    let last_layout = self.type_layout(last_ty, self.substs());\n                                     match (&last_ty.sty, last_layout) {\n                                         (&ty::TyTuple(fields),\n                                          &Layout::Univariant { ref variant, .. }) => {\n@@ -576,8 +491,6 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                     let dest = self.frame().locals[i];\n                                     self.move_(src, dest, src_ty)?;\n                                 }\n-\n-                                TerminatorTarget::Call\n                             }\n \n                             abi => return Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n@@ -593,13 +506,12 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 let ty = self.lvalue_ty(value);\n                 self.drop(ptr, ty)?;\n                 self.frame_mut().next_block = target;\n-                TerminatorTarget::Block\n             }\n \n             Resume => unimplemented!(),\n-        };\n+        }\n \n-        Ok(target)\n+        Ok(())\n     }\n \n     fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n@@ -638,15 +550,15 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n         // Filling drop.\n         // FIXME(solson): Trait objects (with no static size) probably get filled, too.\n-        let size = self.type_size(ty);\n+        let size = self.type_size(ty, self.substs());\n         self.memory.drop_fill(ptr, size)?;\n \n         Ok(())\n     }\n \n     fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<u64> {\n         use rustc::ty::layout::Layout::*;\n-        let adt_layout = self.type_layout(adt_ty);\n+        let adt_layout = self.type_layout(adt_ty, self.substs());\n \n         let discr_val = match *adt_layout {\n             General { discr, .. } | CEnum { discr, .. } => {\n@@ -689,7 +601,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n         dest_size: usize\n-    ) -> EvalResult<TerminatorTarget> {\n+    ) -> EvalResult<()> {\n         let args_res: EvalResult<Vec<Pointer>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n@@ -699,7 +611,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly.\n             \"add_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n+                let size = self.type_size(ty, self.substs());\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let (n, overflowed) = unsafe {\n@@ -713,7 +625,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             \"copy_nonoverlapping\" => {\n                 let elem_ty = *substs.types.get(subst::FnSpace, 0);\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty, self.substs());\n                 let src = self.memory.read_ptr(args[0])?;\n                 let dest = self.memory.read_ptr(args[1])?;\n                 let count = self.memory.read_isize(args[2])?;\n@@ -729,7 +641,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             \"forget\" => {\n                 let arg_ty = *substs.types.get(subst::FnSpace, 0);\n-                let arg_size = self.type_size(arg_ty);\n+                let arg_size = self.type_size(arg_ty, self.substs());\n                 self.memory.drop_fill(args[0], arg_size)?;\n             }\n \n@@ -748,7 +660,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly.\n             \"mul_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n+                let size = self.type_size(ty, self.substs());\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let (n, overflowed) = unsafe {\n@@ -760,7 +672,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             \"offset\" => {\n                 let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n-                let pointee_size = self.type_size(pointee_ty) as isize;\n+                let pointee_size = self.type_size(pointee_ty, self.substs()) as isize;\n                 let ptr_arg = args[0];\n                 let offset = self.memory.read_isize(args[1])?;\n \n@@ -781,7 +693,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly. Use primvals?\n             \"overflowing_sub\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n+                let size = self.type_size(ty, self.substs());\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let n = left.wrapping_sub(right);\n@@ -790,20 +702,20 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             \"size_of\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty) as u64;\n+                let size = self.type_size(ty, self.substs()) as u64;\n                 self.memory.write_uint(dest, size, dest_size)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 if self.type_is_sized(ty) {\n-                    let size = self.type_size(ty) as u64;\n+                    let size = self.type_size(ty, self.substs()) as u64;\n                     self.memory.write_uint(dest, size, dest_size)?;\n                 } else {\n                     match ty.sty {\n                         ty::TySlice(_) | ty::TyStr => {\n                             let elem_ty = ty.sequence_element_type(self.tcx);\n-                            let elem_size = self.type_size(elem_ty) as u64;\n+                            let elem_size = self.type_size(elem_ty, self.substs()) as u64;\n                             let ptr_size = self.memory.pointer_size as isize;\n                             let n = self.memory.read_usize(args[0].offset(ptr_size))?;\n                             self.memory.write_uint(dest, n * elem_size, dest_size)?;\n@@ -826,7 +738,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         // Since we pushed no stack frame, the main loop will act\n         // as if the call just completed and it's returning to the\n         // current frame.\n-        Ok(TerminatorTarget::Call)\n+        Ok(())\n     }\n \n     fn call_c_abi(\n@@ -835,7 +747,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n         dest_size: usize,\n-    ) -> EvalResult<TerminatorTarget> {\n+    ) -> EvalResult<()> {\n         let name = self.tcx.item_name(def_id);\n         let attrs = self.tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, \"link_name\") {\n@@ -888,7 +800,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         // Since we pushed no stack frame, the main loop will act\n         // as if the call just completed and it's returning to the\n         // current frame.\n-        Ok(TerminatorTarget::Call)\n+        Ok(())\n     }\n \n     fn assign_fields<I: IntoIterator<Item = u64>>(\n@@ -911,7 +823,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     {\n         let dest = self.eval_lvalue(lvalue)?.to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n-        let dest_layout = self.type_layout(dest_ty);\n+        let dest_layout = self.type_layout(dest_ty, self.substs());\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n@@ -951,7 +863,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n                     Array { .. } => {\n                         let elem_size = match dest_ty.sty {\n-                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty) as u64,\n+                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty, self.substs()) as u64,\n                             _ => panic!(\"tried to assign {:?} to non-array type {:?}\",\n                                         kind, dest_ty),\n                         };\n@@ -1029,7 +941,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             Repeat(ref operand, _) => {\n                 let (elem_size, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty), n),\n+                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty, self.substs()), n),\n                     _ => panic!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n \n@@ -1070,7 +982,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             }\n \n             Box(ty) => {\n-                let size = self.type_size(ty);\n+                let size = self.type_size(ty, self.substs());\n                 let ptr = self.memory.allocate(size);\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n@@ -1164,7 +1076,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     }\n \n     fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<Size> {\n-        let layout = self.type_layout(ty);\n+        let layout = self.type_layout(ty, self.substs());\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n@@ -1229,13 +1141,13 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     substs: substs,\n                     kind: ConstantKind::Global,\n                 };\n-                *self.gecx.statics.get(&cid).expect(\"static should have been cached (lvalue)\")\n+                *self.statics.get(&cid).expect(\"static should have been cached (lvalue)\")\n             },\n \n             Projection(ref proj) => {\n                 let base = self.eval_lvalue(&proj.base)?;\n                 let base_ty = self.lvalue_ty(&proj.base);\n-                let base_layout = self.type_layout(base_ty);\n+                let base_layout = self.type_layout(base_ty, self.substs());\n \n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n@@ -1296,7 +1208,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     Index(ref operand) => {\n                         let elem_size = match base_ty.sty {\n                             ty::TyArray(elem_ty, _) |\n-                            ty::TySlice(elem_ty) => self.type_size(elem_ty),\n+                            ty::TySlice(elem_ty) => self.type_size(elem_ty, self.substs()),\n                             _ => panic!(\"indexing expected an array or slice, got {:?}\", base_ty),\n                         };\n                         let n_ptr = self.eval_operand(operand)?;\n@@ -1313,34 +1225,22 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     }\n \n     fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(self.mir().lvalue_ty(self.tcx, lvalue).to_ty(self.tcx))\n+        self.monomorphize(self.mir().lvalue_ty(self.tcx, lvalue).to_ty(self.tcx), self.substs())\n     }\n \n     fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(self.mir().operand_ty(self.tcx, operand))\n-    }\n-\n-    fn monomorphize(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.gecx.monomorphize(ty, self.substs())\n+        self.monomorphize(self.mir().operand_ty(self.tcx, operand), self.substs())\n     }\n \n     fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n-        let size = self.type_size(ty);\n+        let size = self.type_size(ty, self.substs());\n         self.memory.copy(src, dest, size)?;\n         if self.type_needs_drop(ty) {\n             self.memory.drop_fill(src, size)?;\n         }\n         Ok(())\n     }\n \n-    fn type_size(&self, ty: Ty<'tcx>) -> usize {\n-        self.gecx.type_size(ty, self.substs())\n-    }\n-\n-    fn type_layout(&self, ty: Ty<'tcx>) -> &'tcx Layout {\n-        self.gecx.type_layout(ty, self.substs())\n-    }\n-\n     pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<PrimVal> {\n         use syntax::ast::{IntTy, UintTy};\n         let val = match (self.memory.pointer_size, &ty.sty) {\n@@ -1380,20 +1280,15 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(val)\n     }\n \n-    fn frame(&self) -> &Frame<'mir, 'tcx> {\n+    fn frame(&self) -> &Frame<'a, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n-    fn basic_block(&self) -> &mir::BasicBlockData<'tcx> {\n-        let frame = self.frame();\n-        frame.mir.basic_block_data(frame.next_block)\n-    }\n-\n-    fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n+    fn frame_mut(&mut self) -> &mut Frame<'a, 'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n-    fn mir(&self) -> CachedMir<'mir, 'tcx> {\n+    fn mir(&self) -> CachedMir<'a, 'tcx> {\n         self.frame().mir.clone()\n     }\n \n@@ -1472,37 +1367,6 @@ pub fn get_impl_method<'a, 'tcx>(\n     }\n }\n \n-pub fn interpret_start_points<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir_map: &MirMap<'tcx>,\n-) {\n-    let initial_indentation = ::log_settings::settings().indentation;\n-    for (&id, mir) in &mir_map.map {\n-        for attr in tcx.map.attrs(id) {\n-            use syntax::attr::AttrMetaMethods;\n-            if attr.check_name(\"miri_run\") {\n-                let item = tcx.map.expect_item(id);\n-\n-                ::log_settings::settings().indentation = initial_indentation;\n-\n-                debug!(\"Interpreting: {}\", item.name);\n-\n-                let mut gecx = GlobalEvalContext::new(tcx, mir_map);\n-                match gecx.call(mir, tcx.map.local_def_id(id)) {\n-                    Ok(Some(return_ptr)) => if log_enabled!(::log::LogLevel::Debug) {\n-                        gecx.memory.dump(return_ptr.alloc_id);\n-                    },\n-                    Ok(None) => warn!(\"diverging function returned\"),\n-                    Err(_e) => {\n-                        // TODO(solson): Detect whether the error was already reported or not.\n-                        // tcx.sess.err(&e.to_string());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n // TODO(solson): Upstream these methods into rustc::ty::layout.\n \n trait IntegerExt {"}, {"sha": "3e4816834a82dca9598f5f602ecce55d9ab1dd3b", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 52, "deletions": 75, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0", "patch": "@@ -1,9 +1,7 @@\n use super::{\n-    FnEvalContext,\n     CachedMir,\n-    TerminatorTarget,\n     ConstantId,\n-    GlobalEvalContext,\n+    EvalContext,\n     ConstantKind,\n };\n use error::EvalResult;\n@@ -13,138 +11,117 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::visit::{Visitor, LvalueContext};\n use syntax::codemap::Span;\n use std::rc::Rc;\n-use memory::Pointer;\n \n-pub struct Stepper<'fncx, 'a: 'fncx, 'b: 'a + 'mir, 'mir: 'fncx, 'tcx: 'b>{\n-    fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>,\n-\n-    // a cache of the constants to be computed before the next statement/terminator\n-    // this is an optimization, so we don't have to allocate a new vector for every statement\n-    constants: Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'mir, 'tcx>)>,\n+pub(super) struct Stepper<'ecx, 'a: 'ecx, 'tcx: 'a>{\n+    ecx: &'ecx mut EvalContext<'a, 'tcx>,\n }\n \n-impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx> {\n-    pub(super) fn new(fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>) -> Self {\n+impl<'ecx, 'a, 'tcx> Stepper<'ecx, 'a, 'tcx> {\n+    pub(super) fn new(ecx: &'ecx mut EvalContext<'a, 'tcx>) -> Self {\n         Stepper {\n-            fncx: fncx,\n-            constants: Vec::new(),\n+            ecx: ecx,\n         }\n     }\n \n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<()> {\n         trace!(\"{:?}\", stmt);\n         let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n-        let result = self.fncx.eval_assignment(lvalue, rvalue);\n-        self.fncx.maybe_report(result)?;\n-        self.fncx.frame_mut().stmt += 1;\n+        self.ecx.eval_assignment(lvalue, rvalue)?;\n+        self.ecx.frame_mut().stmt += 1;\n         Ok(())\n     }\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<()> {\n         // after a terminator we go to a new block\n-        self.fncx.frame_mut().stmt = 0;\n-        let term = {\n-            trace!(\"{:?}\", terminator.kind);\n-            let result = self.fncx.eval_terminator(terminator);\n-            self.fncx.maybe_report(result)?\n-        };\n-        match term {\n-            TerminatorTarget::Return => {\n-                self.fncx.pop_stack_frame();\n-            },\n-            TerminatorTarget::Block |\n-            TerminatorTarget::Call => trace!(\"// {:?}\", self.fncx.frame().next_block),\n+        self.ecx.frame_mut().stmt = 0;\n+        trace!(\"{:?}\", terminator.kind);\n+        self.ecx.eval_terminator(terminator)?;\n+        if !self.ecx.stack.is_empty() {\n+            trace!(\"// {:?}\", self.ecx.frame().next_block);\n         }\n         Ok(())\n     }\n \n     // returns true as long as there are more things to do\n-    pub fn step(&mut self) -> EvalResult<bool> {\n-        if self.fncx.stack.is_empty() {\n+    pub(super) fn step(&mut self) -> EvalResult<bool> {\n+        if self.ecx.stack.is_empty() {\n             return Ok(false);\n         }\n \n-        let block = self.fncx.frame().next_block;\n-        let stmt = self.fncx.frame().stmt;\n-        let mir = self.fncx.mir();\n+        let block = self.ecx.frame().next_block;\n+        let stmt = self.ecx.frame().stmt;\n+        let mir = self.ecx.mir();\n         let basic_block = mir.basic_block_data(block);\n \n         if let Some(ref stmt) = basic_block.statements.get(stmt) {\n-            assert!(self.constants.is_empty());\n+            let current_stack = self.ecx.stack.len();\n             ConstantExtractor {\n                 span: stmt.span,\n-                substs: self.fncx.substs(),\n-                def_id: self.fncx.frame().def_id,\n-                gecx: self.fncx.gecx,\n-                constants: &mut self.constants,\n+                substs: self.ecx.substs(),\n+                def_id: self.ecx.frame().def_id,\n+                ecx: self.ecx,\n                 mir: &mir,\n             }.visit_statement(block, stmt);\n-            if self.constants.is_empty() {\n+            if current_stack == self.ecx.stack.len() {\n                 self.statement(stmt)?;\n             } else {\n-                self.extract_constants()?;\n+                // ConstantExtractor added some new frames for statics/constants/promoteds\n+                // self.step() can't be \"done\", so it can't return false\n+                assert!(self.step()?);\n             }\n             return Ok(true);\n         }\n \n         let terminator = basic_block.terminator();\n-        assert!(self.constants.is_empty());\n+        let current_stack = self.ecx.stack.len();\n         ConstantExtractor {\n             span: terminator.span,\n-            substs: self.fncx.substs(),\n-            def_id: self.fncx.frame().def_id,\n-            gecx: self.fncx.gecx,\n-            constants: &mut self.constants,\n+            substs: self.ecx.substs(),\n+            def_id: self.ecx.frame().def_id,\n+            ecx: self.ecx,\n             mir: &mir,\n         }.visit_terminator(block, terminator);\n-        if self.constants.is_empty() {\n+        if current_stack == self.ecx.stack.len() {\n             self.terminator(terminator)?;\n         } else {\n-            self.extract_constants()?;\n+            // ConstantExtractor added some new frames for statics/constants/promoteds\n+            // self.step() can't be \"done\", so it can't return false\n+            assert!(self.step()?);\n         }\n         Ok(true)\n     }\n-\n-    fn extract_constants(&mut self) -> EvalResult<()> {\n-        assert!(!self.constants.is_empty());\n-        for (cid, span, return_ptr, mir) in self.constants.drain(..) {\n-            trace!(\"queuing a constant\");\n-            self.fncx.push_stack_frame(cid.def_id, span, mir, cid.substs, Some(return_ptr));\n-        }\n-        // self.step() can't be \"done\", so it can't return false\n-        assert!(self.step()?);\n-        Ok(())\n-    }\n }\n \n-struct ConstantExtractor<'a, 'b: 'mir, 'mir: 'a, 'tcx: 'b> {\n+// WARNING: make sure that any methods implemented on this type don't ever access ecx.stack\n+// this includes any method that might access the stack\n+// basically don't call anything other than `load_mir`, `alloc_ret_ptr`, `push_stack_frame`\n+// The reason for this is, that `push_stack_frame` modifies the stack out of obvious reasons\n+struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n     span: Span,\n-    // FIXME: directly push the new stackframes instead of doing this intermediate caching\n-    constants: &'a mut Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'mir, 'tcx>)>,\n-    gecx: &'a mut GlobalEvalContext<'b, 'tcx>,\n+    ecx: &'a mut EvalContext<'b, 'tcx>,\n     mir: &'a mir::Mir<'tcx>,\n     def_id: DefId,\n     substs: &'tcx subst::Substs<'tcx>,\n }\n \n-impl<'a, 'b, 'mir, 'tcx> ConstantExtractor<'a, 'b, 'mir, 'tcx> {\n+impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n     fn global_item(&mut self, def_id: DefId, substs: &'tcx subst::Substs<'tcx>, span: Span) {\n         let cid = ConstantId {\n             def_id: def_id,\n             substs: substs,\n             kind: ConstantKind::Global,\n         };\n-        if self.gecx.statics.contains_key(&cid) {\n+        if self.ecx.statics.contains_key(&cid) {\n             return;\n         }\n-        let mir = self.gecx.load_mir(def_id);\n-        let ptr = self.gecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"there's no such thing as an unreachable static\");\n-        self.gecx.statics.insert(cid.clone(), ptr);\n-        self.constants.push((cid, span, ptr, mir));\n+        let mir = self.ecx.load_mir(def_id);\n+        let ptr = self.ecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"there's no such thing as an unreachable static\");\n+        self.ecx.statics.insert(cid.clone(), ptr);\n+        self.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr));\n     }\n }\n \n-impl<'a, 'b, 'mir, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'mir, 'tcx> {\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n     fn visit_constant(&mut self, constant: &mir::Constant<'tcx>) {\n         self.super_constant(constant);\n         match constant.literal {\n@@ -165,23 +142,23 @@ impl<'a, 'b, 'mir, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'mir, 'tcx>\n                     substs: self.substs,\n                     kind: ConstantKind::Promoted(index),\n                 };\n-                if self.gecx.statics.contains_key(&cid) {\n+                if self.ecx.statics.contains_key(&cid) {\n                     return;\n                 }\n                 let mir = self.mir.promoted[index].clone();\n                 let return_ty = mir.return_ty;\n-                let return_ptr = self.gecx.alloc_ret_ptr(return_ty, cid.substs).expect(\"there's no such thing as an unreachable static\");\n+                let return_ptr = self.ecx.alloc_ret_ptr(return_ty, cid.substs).expect(\"there's no such thing as an unreachable static\");\n                 let mir = CachedMir::Owned(Rc::new(mir));\n-                self.gecx.statics.insert(cid.clone(), return_ptr);\n-                self.constants.push((cid, constant.span, return_ptr, mir));\n+                self.ecx.statics.insert(cid.clone(), return_ptr);\n+                self.ecx.push_stack_frame(self.def_id, constant.span, mir, self.substs, Some(return_ptr));\n             }\n         }\n     }\n \n     fn visit_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>, context: LvalueContext) {\n         self.super_lvalue(lvalue, context);\n         if let mir::Lvalue::Static(def_id) = *lvalue {\n-            let substs = self.gecx.tcx.mk_substs(subst::Substs::empty());\n+            let substs = self.ecx.tcx.mk_substs(subst::Substs::empty());\n             let span = self.span;\n             self.global_item(def_id, substs, span);\n         }"}, {"sha": "c3369878f3554478e54d28413497a2ef77e9c259", "filename": "src/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a8d0812ed15bbd8d8e004eb5c09fdacdd0a205a0", "patch": "@@ -20,6 +20,20 @@ extern crate log_settings;\n extern crate byteorder;\n \n mod error;\n-pub mod interpreter;\n+mod interpreter;\n mod memory;\n mod primval;\n+\n+pub use error::{\n+    EvalError,\n+    EvalResult,\n+};\n+\n+pub use interpreter::{\n+    EvalContext,\n+    step,\n+    Frame,\n+    CachedMir,\n+};\n+\n+pub use memory::Memory;"}]}