{"sha": "e5b3684872d42e531ce3f51edc914b3917658905", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1YjM2ODQ4NzJkNDJlNTMxY2UzZjUxZWRjOTE0YjM5MTc2NTg5MDU=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-06-26T00:11:02Z"}, "committer": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-06-27T21:26:13Z"}, "message": "Remove ClosureTyper impl for FnCtxt", "tree": {"sha": "4b70c7bcbca43c65c7a803fd1c52783822950514", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b70c7bcbca43c65c7a803fd1c52783822950514"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5b3684872d42e531ce3f51edc914b3917658905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5b3684872d42e531ce3f51edc914b3917658905", "html_url": "https://github.com/rust-lang/rust/commit/e5b3684872d42e531ce3f51edc914b3917658905", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5b3684872d42e531ce3f51edc914b3917658905/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "480cd8fe678ddd34c7dc626791deaed2b49a0bda", "url": "https://api.github.com/repos/rust-lang/rust/commits/480cd8fe678ddd34c7dc626791deaed2b49a0bda", "html_url": "https://github.com/rust-lang/rust/commit/480cd8fe678ddd34c7dc626791deaed2b49a0bda"}], "stats": {"total": 154, "additions": 62, "deletions": 92}, "files": [{"sha": "c21ec9fbbb3bf038d59ec315922efec9f6deec31", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e5b3684872d42e531ce3f51edc914b3917658905", "patch": "@@ -25,7 +25,7 @@ pub use self::region_inference::GenericKind;\n use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n-use middle::region::{self, CodeExtent};\n+use middle::region::CodeExtent;\n use middle::subst;\n use middle::subst::Substs;\n use middle::subst::Subst;\n@@ -40,7 +40,7 @@ use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n-use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n+use util::nodemap::{FnvHashMap, NodeMap};\n \n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n@@ -524,15 +524,38 @@ impl<'a, 'tcx> ty::ClosureTyper<'tcx> for InferCtxt<'a, 'tcx> {\n                     substs: &subst::Substs<'tcx>)\n                     -> ty::ClosureTy<'tcx>\n     {\n-        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self.tcx, substs)\n+        // the substitutions in `substs` are already monomorphized,\n+        // but we still must normalize associated types\n+        let closure_ty = self.tables\n+                             .borrow()\n+                             .closure_tys\n+                             .get(&def_id)\n+                             .unwrap()\n+                             .subst(self.tcx, substs);\n+\n+        if self.normalize {\n+            // NOTE: this flag is *always* set to false currently\n+            panic!(\"issue XXXX: must finish fulfill refactor\") // normalize_associated_type(self.param_env.tcx, &closure_ty)\n+        } else {\n+            closure_ty\n+        }\n     }\n \n     fn closure_upvars(&self,\n                       def_id: ast::DefId,\n                       substs: &Substs<'tcx>)\n                       -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n     {\n-        ty::ctxt::closure_upvars(self, def_id, substs)\n+        // the substitutions in `substs` are already monomorphized,\n+        // but we still must normalize associated types\n+        let result = ty::ctxt::closure_upvars(self, def_id, substs)\n+\n+        if self.normalize {\n+            // NOTE: this flag is *always* set to false currently\n+            panic!(\"issue XXXX: must finish fulfill refactor\") // monomorphize::normalize_associated_type(self.param_env.tcx, &result)\n+        } else {\n+            result\n+        }\n     }\n }\n \n@@ -1073,6 +1096,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n+    /// Resolves all type variables in `t` and then, if any were left\n+    /// unresolved, substitutes an error type. This is used after the\n+    /// main checking when doing a second pass before writeback. The\n+    /// justification is that writeback will produce an error for\n+    /// these unconstrained type variables.\n     fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n         let ty = self.resolve_type_vars_if_possible(t);\n         if ty.has_infer_types() || ty.references_error() { Err(()) } else { Ok(ty) }"}, {"sha": "d29c0494572cb4d3e9b098bc6b029e7f59912c0c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=e5b3684872d42e531ce3f51edc914b3917658905", "patch": "@@ -137,9 +137,9 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // Check whether this is a call to a closure where we\n             // haven't yet decided on whether the closure is fn vs\n             // fnmut vs fnonce. If so, we have to defer further processing.\n-            if fcx.closure_kind(def_id).is_none() {\n+            if fcx.infcx().closure_kind(def_id).is_none() {\n                 let closure_ty =\n-                    fcx.closure_type(def_id, substs);\n+                    fcx.infcx().closure_type(def_id, substs);\n                 let fn_sig =\n                     fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n                                                                           infer::FnCall,\n@@ -344,7 +344,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n-        assert!(fcx.closure_kind(self.closure_def_id).is_some());\n+        assert!(fcx.infcx().closure_kind(self.closure_def_id).is_some());\n \n         // We may now know enough to figure out fn vs fnmut etc.\n         match try_overloaded_call_traits(fcx, self.call_expr, self.callee_expr,"}, {"sha": "b38b6884a98ad639688ca6e2ed0cc970bf113562", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e5b3684872d42e531ce3f51edc914b3917658905", "patch": "@@ -273,7 +273,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n         let source = source.adjust_for_autoref(self.tcx(), reborrow);\n \n-        let mut selcx = traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n+        let mut selcx = traits::SelectionContext::new(self.fcx.infcx(), self.fcx.infcx());\n \n         // Use a FIFO queue for this custom fulfillment procedure.\n         let mut queue = VecDeque::new();"}, {"sha": "f312db9c4dcf2b75ff48925020a294cb16c6699f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e5b3684872d42e531ce3f51edc914b3917658905", "patch": "@@ -195,7 +195,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                               poly_trait_ref.to_predicate());\n \n     // Now we want to know if this can be matched\n-    let mut selcx = traits::SelectionContext::new(fcx.infcx(), fcx);\n+    let mut selcx = traits::SelectionContext::new(fcx.infcx(), fcx.infcx());\n     if !selcx.evaluate_obligation(&obligation) {\n         debug!(\"--> Cannot match obligation\");\n         return None; // Cannot be matched, no such method resolution is possible."}, {"sha": "94a2050829dfa3213f332ab7a579f7f7cfa3d503", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e5b3684872d42e531ce3f51edc914b3917658905", "patch": "@@ -421,7 +421,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // We can't use normalize_associated_types_in as it will pollute the\n         // fcx's fulfillment context after this probe is over.\n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n-        let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n+        let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx.infcx());\n         let traits::Normalized { value: xform_self_ty, obligations } =\n             traits::normalize(selcx, cause, &xform_self_ty);\n         debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n@@ -681,7 +681,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             // as it will pollute the fcx's fulfillment context after this probe\n             // is over.\n             let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n-            let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx);\n+            let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx(), self.fcx.infcx());\n             let traits::Normalized { value: xform_self_ty, obligations } =\n                 traits::normalize(selcx, cause, &xform_self_ty);\n \n@@ -1076,7 +1076,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             match probe.kind {\n                 InherentImplCandidate(impl_def_id, ref substs, ref ref_obligations) |\n                 ExtensionImplCandidate(impl_def_id, _, ref substs, _, ref ref_obligations) => {\n-                    let selcx = &mut traits::SelectionContext::new(self.infcx(), self.fcx);\n+                    let selcx = &mut traits::SelectionContext::new(self.infcx(), self.fcx.infcx());\n                     let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n                     // Check whether the impl imposes obligations we have to worry about."}, {"sha": "b81b672e684a5aa76f740a2e25615e60f25920c7", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e5b3684872d42e531ce3f51edc914b3917658905", "patch": "@@ -102,7 +102,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             let obligation = Obligation::misc(span,\n                                                               fcx.body_id,\n                                                               poly_trait_ref.to_predicate());\n-                            let mut selcx = SelectionContext::new(infcx, fcx);\n+                            let mut selcx = SelectionContext::new(infcx, fcx.infcx());\n \n                             if selcx.evaluate_obligation(&obligation) {\n                                 span_stored_function();"}, {"sha": "2dc0b7d326181ef1b12cf60476418f1532507039", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 64, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e5b3684872d42e531ce3f51edc914b3917658905", "patch": "@@ -316,65 +316,6 @@ impl<'a, 'tcx> mc::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n                 .map(|ty| self.infcx().resolve_type_vars_if_possible(&ty))\n     }\n \n-    fn node_method_origin(&self, method_call: ty::MethodCall)\n-                          -> Option<ty::MethodOrigin<'tcx>>\n-    {\n-        self.inh.tables\n-                .borrow()\n-                .method_map\n-                .get(&method_call)\n-                .map(|method| method.origin.clone())\n-    }\n-\n-    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n-        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>) -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n-            &tables.adjustments\n-        }\n-\n-        Ref::map(self.inh.tables.borrow(), project_adjustments)\n-    }\n-\n-    fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.inh.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n-    }\n-\n-    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n-        self.param_env().temporary_scope(rvalue_id)\n-    }\n-\n-    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        self.inh.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n-    }\n-}\n-\n-impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n-    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n-        &self.inh.infcx.parameter_environment\n-    }\n-\n-    fn closure_kind(&self,\n-                    def_id: ast::DefId)\n-                    -> Option<ty::ClosureKind>\n-    {\n-        self.inh.tables.borrow().closure_kinds.get(&def_id).cloned()\n-    }\n-\n-    fn closure_type(&self,\n-                    def_id: ast::DefId,\n-                    substs: &subst::Substs<'tcx>)\n-                    -> ty::ClosureTy<'tcx>\n-    {\n-        self.inh.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self.tcx(), substs)\n-    }\n-\n-    fn closure_upvars(&self,\n-                      def_id: ast::DefId,\n-                      substs: &Substs<'tcx>)\n-                      -> Option<Vec<ty::ClosureUpvar<'tcx>>> {\n-        ty::ctxt::closure_upvars(self, def_id, substs)\n-    }\n-}\n-\n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n            tables: &'a RefCell<ty::Tables<'tcx>>,\n@@ -1473,7 +1414,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n         where T : TypeFoldable<'tcx> + HasTypeFlags\n     {\n-        self.inh.normalize_associated_types_in(self, span, self.body_id, value)\n+        self.inh.normalize_associated_types_in(self.infcx(), span, self.body_id, value)\n     }\n \n     fn normalize_associated_type(&self,\n@@ -1488,7 +1429,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.fulfillment_cx\n             .borrow_mut()\n             .normalize_projection_type(self.infcx(),\n-                                       self,\n+                                       self.infcx(),\n                                        ty::ProjectionTy {\n                                            trait_ref: trait_ref,\n                                            item_name: item_name,\n@@ -1843,7 +1784,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.select_all_obligations_and_apply_defaults();\n         let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n-        match fulfillment_cx.select_all_or_error(self.infcx(), self) {\n+        match fulfillment_cx.select_all_or_error(self.infcx(), self.infcx()) {\n             Ok(()) => { }\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n         }\n@@ -1854,7 +1795,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match\n             self.inh.fulfillment_cx\n             .borrow_mut()\n-            .select_where_possible(self.infcx(), self)\n+            .select_where_possible(self.infcx(), self.infcx())\n         {\n             Ok(()) => { }\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n@@ -1869,7 +1810,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match\n             self.inh.fulfillment_cx\n             .borrow_mut()\n-            .select_new_obligations(self.infcx(), self)\n+            .select_new_obligations(self.infcx(), self.infcx())\n         {\n             Ok(()) => { }\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }"}, {"sha": "796f6d646939f31548ff1dd90c54b6817790a584", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e5b3684872d42e531ce3f51edc914b3917658905", "patch": "@@ -86,6 +86,7 @@ use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n+use middle::infer::InferCtxt;\n use middle::implicator;\n use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n@@ -353,7 +354,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             debug!(\"relate_free_regions(t={:?})\", ty);\n             let body_scope = CodeExtent::from_node_id(body_id);\n             let body_scope = ty::ReScope(body_scope);\n-            let implications = implicator::implications(self.fcx.infcx(), self.fcx, body_id,\n+            let implications = implicator::implications(self.fcx.infcx(), self.fcx.infcx(), body_id,\n                                                         ty, body_scope, span);\n \n             // Record any relations between free regions that we observe into the free-region-map.\n@@ -549,7 +550,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         // If necessary, constrain destructors in the unadjusted form of this\n         // expression.\n         let cmt_result = {\n-            let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+            let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n             mc.cat_expr_unadjusted(expr)\n         };\n         match cmt_result {\n@@ -568,7 +569,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     // If necessary, constrain destructors in this expression. This will be\n     // the adjusted form if there is an adjustment.\n     let cmt_result = {\n-        let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+        let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n         mc.cat_expr(expr)\n     };\n     match cmt_result {\n@@ -912,7 +913,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                        r, m);\n \n                 {\n-                    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+                    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     debug!(\"constrain_autoderefs: self_cmt={:?}\",\n                            self_cmt);\n@@ -1037,7 +1038,7 @@ fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n     debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n     let cmt = {\n-        let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+        let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n         ignore_err!(mc.cat_expr(base))\n     };\n \n@@ -1055,7 +1056,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n         None => { return; }\n         Some(ref expr) => &**expr,\n     };\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n     link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n@@ -1065,7 +1066,7 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n /// linked to the lifetime of its guarantor (if any).\n fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     debug!(\"regionck::for_match()\");\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={:?}\", discr_cmt);\n     for arm in arms {\n@@ -1080,7 +1081,7 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n /// linked to the lifetime of its guarantor (if any).\n fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n     debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     for arg in args {\n         let arg_ty = rcx.fcx.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n@@ -1095,7 +1096,7 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[ast::Arg]) {\n /// Link lifetimes of any ref bindings in `root_pat` to the pointers found in the discriminant, if\n /// needed.\n fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                          mc: mc::MemCategorizationContext<FnCtxt<'a, 'tcx>>,\n+                          mc: mc::MemCategorizationContext<InferCtxt<'a, 'tcx>>,\n                           discr_cmt: mc::cmt<'tcx>,\n                           root_pat: &ast::Pat) {\n     debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n@@ -1134,7 +1135,7 @@ fn link_autoref(rcx: &Rcx,\n                 autoref: &ty::AutoRef)\n {\n     debug!(\"link_autoref(autoref={:?})\", autoref);\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={:?}\", expr_cmt);\n \n@@ -1158,7 +1159,7 @@ fn link_by_ref(rcx: &Rcx,\n                callee_scope: CodeExtent) {\n     debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n            expr, callee_scope);\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n     link_region(rcx, expr.span, &borrow_region, ty::ImmBorrow, expr_cmt);\n@@ -1402,7 +1403,7 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            ty,\n            region);\n \n-    let implications = implicator::implications(rcx.fcx.infcx(), rcx.fcx, rcx.body_id,\n+    let implications = implicator::implications(rcx.fcx.infcx(), rcx.fcx.infcx(), rcx.body_id,\n                                                 ty, region, origin.span());\n     for implication in implications {\n         debug!(\"implication: {:?}\", implication);\n@@ -1443,7 +1444,7 @@ fn closure_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     debug!(\"closure_must_outlive(region={:?}, def_id={:?}, substs={:?})\",\n            region, def_id, substs);\n \n-    let upvars = rcx.fcx.closure_upvars(def_id, substs).unwrap();\n+    let upvars = rcx.fcx.infcx().closure_upvars(def_id, substs).unwrap();\n     for upvar in upvars {\n         let var_id = upvar.def.def_id().local_id();\n         type_must_outlive("}, {"sha": "19a0345e8088f8aec6a408ab13d6742a2cbb108b", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=e5b3684872d42e531ce3f51edc914b3917658905", "patch": "@@ -186,7 +186,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n         debug!(\"analyzing closure `{}` with fn body id `{}`\", id, body.id);\n \n-        let mut euv = euv::ExprUseVisitor::new(self, self.fcx);\n+        let mut euv = euv::ExprUseVisitor::new(self, self.fcx.infcx());\n         euv.walk_fn(decl, body);\n \n         // If we had not yet settled on a closure kind for this closure,"}, {"sha": "18e05cd73fb7db85169ee056e5a392fac0b8aa07", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5b3684872d42e531ce3f51edc914b3917658905/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=e5b3684872d42e531ce3f51edc914b3917658905", "patch": "@@ -259,7 +259,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let predicates = fcx.tcx().lookup_super_predicates(poly_trait_ref.def_id());\n             let predicates = predicates.instantiate_supertrait(fcx.tcx(), &poly_trait_ref);\n             let predicates = {\n-                let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx);\n+                let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx.infcx());\n                 traits::normalize(selcx, cause.clone(), &predicates)\n             };\n             for predicate in predicates.value.predicates {"}]}