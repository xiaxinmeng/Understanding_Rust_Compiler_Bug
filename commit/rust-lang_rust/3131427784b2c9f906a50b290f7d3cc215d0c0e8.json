{"sha": "3131427784b2c9f906a50b290f7d3cc215d0c0e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMzE0Mjc3ODRiMmM5ZjkwNmE1MGIyOTBmN2QzY2MyMTVkMGMwZTg=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-15T19:33:23Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-25T21:41:22Z"}, "message": "Use `Local`s instead of `Place`s in MIR drop generation", "tree": {"sha": "cb67804118bb6d1966ac1ce2212b219218074588", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb67804118bb6d1966ac1ce2212b219218074588"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3131427784b2c9f906a50b290f7d3cc215d0c0e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3131427784b2c9f906a50b290f7d3cc215d0c0e8", "html_url": "https://github.com/rust-lang/rust/commit/3131427784b2c9f906a50b290f7d3cc215d0c0e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3131427784b2c9f906a50b290f7d3cc215d0c0e8/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b86e6755b982bafc36133d9016e7d5a4cd0de0e8", "html_url": "https://github.com/rust-lang/rust/commit/b86e6755b982bafc36133d9016e7d5a4cd0de0e8"}], "stats": {"total": 181, "additions": 81, "deletions": 100}, "files": [{"sha": "17e7b1acc68f06e30bcddfe12cfb3359cf9eda09", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3131427784b2c9f906a50b290f7d3cc215d0c0e8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3131427784b2c9f906a50b290f7d3cc215d0c0e8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3131427784b2c9f906a50b290f7d3cc215d0c0e8", "patch": "@@ -127,7 +127,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     this.schedule_drop_storage_and_value(\n                         expr_span,\n                         scope,\n-                        &Place::from(result),\n+                        result,\n                         value.ty,\n                     );\n                 }\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             this.schedule_drop_storage_and_value(\n                 upvar_span,\n                 temp_lifetime,\n-                &Place::from(temp),\n+                temp,\n                 upvar_ty,\n             );\n         }"}, {"sha": "1fe6be8bbc82eee739a1da45f3d6d7004e850b11", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3131427784b2c9f906a50b290f7d3cc215d0c0e8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3131427784b2c9f906a50b290f7d3cc215d0c0e8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=3131427784b2c9f906a50b290f7d3cc215d0c0e8", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 this.schedule_drop(\n                     expr_span,\n                     temp_lifetime,\n-                    temp_place,\n+                    temp,\n                     expr_ty,\n                     DropKind::Storage,\n                 );\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             this.schedule_drop(\n                 expr_span,\n                 temp_lifetime,\n-                temp_place,\n+                temp,\n                 expr_ty,\n                 DropKind::Value,\n             );"}, {"sha": "f831f5105a4686d368ff694b8c34d3b399a07ac0", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3131427784b2c9f906a50b290f7d3cc215d0c0e8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3131427784b2c9f906a50b290f7d3cc215d0c0e8/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=3131427784b2c9f906a50b290f7d3cc215d0c0e8", "patch": "@@ -531,11 +531,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 kind: StatementKind::StorageLive(local_id),\n             },\n         );\n-        let place = Place::from(local_id);\n         let var_ty = self.local_decls[local_id].ty;\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n-        self.schedule_drop(span, region_scope, &place, var_ty, DropKind::Storage);\n-        place\n+        self.schedule_drop(span, region_scope, local_id, var_ty, DropKind::Storage);\n+        Place::Base(PlaceBase::Local(local_id))\n     }\n \n     pub fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n@@ -545,7 +544,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.schedule_drop(\n             span,\n             region_scope,\n-            &Place::from(local_id),\n+            local_id,\n             var_ty,\n             DropKind::Value,\n         );"}, {"sha": "ad970de466cfdf16baba62ffdbe2645ec9d9ad91", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3131427784b2c9f906a50b290f7d3cc215d0c0e8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3131427784b2c9f906a50b290f7d3cc215d0c0e8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3131427784b2c9f906a50b290f7d3cc215d0c0e8", "patch": "@@ -809,7 +809,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop(\n                 pattern.as_ref().map_or(ast_body.span, |pat| pat.span),\n-                argument_scope, &place, ty, DropKind::Value,\n+                argument_scope, local, ty, DropKind::Value,\n             );\n \n             if let Some(pattern) = pattern {"}, {"sha": "1b5fa1c9770f168d37de3a4e2fb6885075b69e83", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 73, "deletions": 91, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/3131427784b2c9f906a50b290f7d3cc215d0c0e8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3131427784b2c9f906a50b290f7d3cc215d0c0e8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=3131427784b2c9f906a50b290f7d3cc215d0c0e8", "patch": "@@ -94,7 +94,7 @@ use std::collections::hash_map::Entry;\n use std::mem;\n \n #[derive(Debug)]\n-struct Scope<'tcx> {\n+struct Scope {\n     /// The source scope this scope was created in.\n     source_scope: SourceScope,\n \n@@ -121,7 +121,7 @@ struct Scope<'tcx> {\n     /// out empty but grows as variables are declared during the\n     /// building process. This is a stack, so we always drop from the\n     /// end of the vector (top of the stack) first.\n-    drops: Vec<DropData<'tcx>>,\n+    drops: Vec<DropData>,\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n     cached_exits: FxHashMap<(BasicBlock, region::Scope), BasicBlock>,\n@@ -135,18 +135,18 @@ struct Scope<'tcx> {\n \n #[derive(Debug, Default)]\n pub struct Scopes<'tcx> {\n-    scopes: Vec<Scope<'tcx>>,\n+    scopes: Vec<Scope>,\n     /// The current set of breakable scopes. See module comment for more details.\n     breakable_scopes: Vec<BreakableScope<'tcx>>,\n }\n \n #[derive(Debug)]\n-struct DropData<'tcx> {\n+struct DropData {\n     /// span where drop obligation was incurred (typically where place was declared)\n     span: Span,\n \n-    /// place to drop\n-    location: Place<'tcx>,\n+    /// local to drop\n+    local: Local,\n \n     /// Whether this is a value Drop or a StorageDead.\n     kind: DropKind,\n@@ -223,7 +223,7 @@ impl CachedBlock {\n     }\n }\n \n-impl<'tcx> Scope<'tcx> {\n+impl Scope {\n     /// Invalidates all the cached blocks in the scope.\n     ///\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n@@ -285,7 +285,7 @@ impl<'tcx> Scopes<'tcx> {\n     fn pop_scope(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n-    ) -> (Scope<'tcx>, Option<BasicBlock>) {\n+    ) -> (Scope, Option<BasicBlock>) {\n         let scope = self.scopes.pop().unwrap();\n         assert_eq!(scope.region_scope, region_scope.0);\n         let unwind_to = self.scopes.last()\n@@ -343,11 +343,11 @@ impl<'tcx> Scopes<'tcx> {\n         scope_count\n     }\n \n-    fn iter_mut(&mut self) -> impl DoubleEndedIterator<Item=&mut Scope<'tcx>> + '_ {\n+    fn iter_mut(&mut self) -> impl DoubleEndedIterator<Item=&mut Scope> + '_ {\n         self.scopes.iter_mut().rev()\n     }\n \n-    fn top_scopes(&mut self, count: usize) -> impl DoubleEndedIterator<Item=&mut Scope<'tcx>> + '_ {\n+    fn top_scopes(&mut self, count: usize) -> impl DoubleEndedIterator<Item=&mut Scope> + '_ {\n         let len = self.len();\n         self.scopes[len - count..].iter_mut()\n     }\n@@ -717,11 +717,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n-        place: &Place<'tcx>,\n+        local: Local,\n         place_ty: Ty<'tcx>,\n     ) {\n-        self.schedule_drop(span, region_scope, place, place_ty, DropKind::Storage);\n-        self.schedule_drop(span, region_scope, place, place_ty, DropKind::Value);\n+        self.schedule_drop(span, region_scope, local, place_ty, DropKind::Storage);\n+        self.schedule_drop(span, region_scope, local, place_ty, DropKind::Value);\n     }\n \n     /// Indicates that `place` should be dropped on exit from\n@@ -733,25 +733,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n-        place: &Place<'tcx>,\n+        local: Local,\n         place_ty: Ty<'tcx>,\n         drop_kind: DropKind,\n     ) {\n         let needs_drop = self.hir.needs_drop(place_ty);\n         match drop_kind {\n             DropKind::Value => if !needs_drop { return },\n             DropKind::Storage => {\n-                match *place {\n-                    Place::Base(PlaceBase::Local(index)) => if index.index() <= self.arg_count {\n-                        span_bug!(\n-                            span, \"`schedule_drop` called with index {} and arg_count {}\",\n-                            index.index(),\n-                            self.arg_count,\n-                        )\n-                    },\n-                    _ => span_bug!(\n-                        span, \"`schedule_drop` called with non-`Local` place {:?}\", place\n-                    ),\n+                if local.index() <= self.arg_count {\n+                    span_bug!(\n+                        span, \"`schedule_drop` called with local {:?} and arg_count {}\",\n+                        local,\n+                        self.arg_count,\n+                    )\n                 }\n             }\n         }\n@@ -817,14 +812,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 scope.drops.push(DropData {\n                     span: scope_end,\n-                    location: place.clone(),\n+                    local,\n                     kind: drop_kind,\n                     cached_block: CachedBlock::default(),\n                 });\n                 return;\n             }\n         }\n-        span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, place);\n+        span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, local);\n     }\n \n     // Other\n@@ -867,29 +862,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         bug!(\"Drop scheduled on top of condition variable\")\n                     }\n                     DropKind::Storage => {\n-                        // Drop the storage for both value and storage drops.\n-                        // Only temps and vars need their storage dead.\n-                        match top_drop_data.location {\n-                            Place::Base(PlaceBase::Local(index)) => {\n-                                let source_info = top_scope.source_info(top_drop_data.span);\n-                                assert_eq!(index, cond_temp, \"Drop scheduled on top of condition\");\n-                                self.cfg.push(\n-                                    true_block,\n-                                    Statement {\n-                                        source_info,\n-                                        kind: StatementKind::StorageDead(index)\n-                                    },\n-                                );\n-                                self.cfg.push(\n-                                    false_block,\n-                                    Statement {\n-                                        source_info,\n-                                        kind: StatementKind::StorageDead(index)\n-                                    },\n-                                );\n-                            }\n-                            _ => unreachable!(),\n-                        }\n+                        let source_info = top_scope.source_info(top_drop_data.span);\n+                        let local = top_drop_data.local;\n+                        assert_eq!(local, cond_temp, \"Drop scheduled on top of condition\");\n+                        self.cfg.push(\n+                            true_block,\n+                            Statement {\n+                                source_info,\n+                                kind: StatementKind::StorageDead(local)\n+                            },\n+                        );\n+                        self.cfg.push(\n+                            false_block,\n+                            Statement {\n+                                source_info,\n+                                kind: StatementKind::StorageDead(local)\n+                            },\n+                        );\n                     }\n                 }\n \n@@ -1020,7 +1009,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n fn build_scope_drops<'tcx>(\n     cfg: &mut CFG<'tcx>,\n     is_generator: bool,\n-    scope: &Scope<'tcx>,\n+    scope: &Scope,\n     mut block: BasicBlock,\n     last_unwind_to: BasicBlock,\n     arg_count: usize,\n@@ -1050,39 +1039,35 @@ fn build_scope_drops<'tcx>(\n     for drop_idx in (0..scope.drops.len()).rev() {\n         let drop_data = &scope.drops[drop_idx];\n         let source_info = scope.source_info(drop_data.span);\n+        let local = drop_data.local;\n         match drop_data.kind {\n             DropKind::Value => {\n                 let unwind_to = get_unwind_to(scope, is_generator, drop_idx, generator_drop)\n                     .unwrap_or(last_unwind_to);\n \n                 let next = cfg.start_new_block();\n                 cfg.terminate(block, source_info, TerminatorKind::Drop {\n-                    location: drop_data.location.clone(),\n+                    location: local.into(),\n                     target: next,\n                     unwind: Some(unwind_to)\n                 });\n                 block = next;\n             }\n             DropKind::Storage => {\n-                // Drop the storage for both value and storage drops.\n                 // Only temps and vars need their storage dead.\n-                match drop_data.location {\n-                    Place::Base(PlaceBase::Local(index)) if index.index() > arg_count => {\n-                        cfg.push(block, Statement {\n-                            source_info,\n-                            kind: StatementKind::StorageDead(index)\n-                        });\n-                    }\n-                    _ => unreachable!(),\n-                }\n+                assert!(local.index() > arg_count);\n+                cfg.push(block, Statement {\n+                    source_info,\n+                    kind: StatementKind::StorageDead(local)\n+                });\n             }\n         }\n     }\n     block.unit()\n }\n \n-fn get_unwind_to<'tcx>(\n-    scope: &Scope<'tcx>,\n+fn get_unwind_to(\n+    scope: &Scope,\n     is_generator: bool,\n     unwind_from: usize,\n     generator_drop: bool,\n@@ -1108,7 +1093,7 @@ fn get_unwind_to<'tcx>(\n \n fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n                              span: Span,\n-                             scope: &mut Scope<'tcx>,\n+                             scope: &mut Scope,\n                              mut target: BasicBlock,\n                              generator_drop: bool,\n                              is_generator: bool)\n@@ -1152,26 +1137,20 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n         // this is not what clang does.\n         match drop_data.kind {\n             DropKind::Storage if is_generator => {\n-                // Only temps and vars need their storage dead.\n-                match drop_data.location {\n-                    Place::Base(PlaceBase::Local(index)) => {\n-                        storage_deads.push(Statement {\n-                            source_info: source_info(drop_data.span),\n-                            kind: StatementKind::StorageDead(index)\n-                        });\n-                        if !target_built_by_us {\n-                            // We cannot add statements to an existing block, so we create a new\n-                            // block for our StorageDead statements.\n-                            let block = cfg.start_new_cleanup_block();\n-                            let source_info = SourceInfo { span: DUMMY_SP, scope: source_scope };\n-                            cfg.terminate(block, source_info,\n-                                          TerminatorKind::Goto { target: target });\n-                            target = block;\n-                            target_built_by_us = true;\n-                        }\n-                    }\n-                    _ => unreachable!(),\n-                };\n+                storage_deads.push(Statement {\n+                    source_info: source_info(drop_data.span),\n+                    kind: StatementKind::StorageDead(drop_data.local)\n+                });\n+                if !target_built_by_us {\n+                    // We cannot add statements to an existing block, so we create a new\n+                    // block for our StorageDead statements.\n+                    let block = cfg.start_new_cleanup_block();\n+                    let source_info = SourceInfo { span: DUMMY_SP, scope: source_scope };\n+                    cfg.terminate(block, source_info,\n+                                    TerminatorKind::Goto { target: target });\n+                    target = block;\n+                    target_built_by_us = true;\n+                }\n                 *drop_data.cached_block.ref_mut(generator_drop) = Some(target);\n             }\n             DropKind::Storage => {}\n@@ -1184,12 +1163,15 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n                 } else {\n                     push_storage_deads(cfg, target, &mut storage_deads);\n                     let block = cfg.start_new_cleanup_block();\n-                    cfg.terminate(block, source_info(drop_data.span),\n-                                  TerminatorKind::Drop {\n-                                      location: drop_data.location.clone(),\n-                                      target,\n-                                      unwind: None\n-                                  });\n+                    cfg.terminate(\n+                        block,\n+                        source_info(drop_data.span),\n+                        TerminatorKind::Drop {\n+                            location: drop_data.local.into(),\n+                            target,\n+                            unwind: None\n+                        },\n+                    );\n                     *cached_block = Some(block);\n                     target_built_by_us = true;\n                     block"}]}