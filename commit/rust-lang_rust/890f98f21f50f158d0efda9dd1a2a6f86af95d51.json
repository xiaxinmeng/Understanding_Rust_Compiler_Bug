{"sha": "890f98f21f50f158d0efda9dd1a2a6f86af95d51", "node_id": "C_kwDOAAsO6NoAKDg5MGY5OGYyMWY1MGYxNThkMGVmZGE5ZGQxYTJhNmY4NmFmOTVkNTE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-18T14:30:58Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-18T14:42:19Z"}, "message": "internal: Allow explicitly specifying end of fixture annotation", "tree": {"sha": "b083413b7b9e8a432294e14ea3cd3aba4331f65e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b083413b7b9e8a432294e14ea3cd3aba4331f65e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/890f98f21f50f158d0efda9dd1a2a6f86af95d51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/890f98f21f50f158d0efda9dd1a2a6f86af95d51", "html_url": "https://github.com/rust-lang/rust/commit/890f98f21f50f158d0efda9dd1a2a6f86af95d51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/890f98f21f50f158d0efda9dd1a2a6f86af95d51/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "828196be3bd92ba33e62270d24dae79bd2eb5125", "url": "https://api.github.com/repos/rust-lang/rust/commits/828196be3bd92ba33e62270d24dae79bd2eb5125", "html_url": "https://github.com/rust-lang/rust/commit/828196be3bd92ba33e62270d24dae79bd2eb5125"}], "stats": {"total": 35, "additions": 28, "deletions": 7}, "files": [{"sha": "0fa38bb97ce9ad08af0f35908986edaa07b7739e", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/890f98f21f50f158d0efda9dd1a2a6f86af95d51/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890f98f21f50f158d0efda9dd1a2a6f86af95d51/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=890f98f21f50f158d0efda9dd1a2a6f86af95d51", "patch": "@@ -212,6 +212,13 @@ pub fn add_cursor(text: &str, offset: TextSize) -> String {\n /// // ^^^ first line\n /// //   | second line\n ///\n+/// Trailing whitespace is sometimes desired but usually stripped by the editor\n+/// if at the end of a line, or incorrectly sized if followed by another\n+/// annotation. In those cases the annotation can be explicitly ended with the\n+/// `$` character.\n+///\n+/// // ^^^ trailing-ws-wanted  $\n+///\n /// Annotations point to the last line that actually was long enough for the\n /// range, not counting annotations themselves. So overlapping annotations are\n /// possible:\n@@ -229,9 +236,10 @@ pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n     let mut prev_line_annotations: Vec<(TextSize, usize)> = Vec::new();\n     for line in text.split_inclusive('\\n') {\n         let mut this_line_annotations = Vec::new();\n-        let line_length = if let Some(idx) = line.find(\"//\") {\n-            let annotation_offset = TextSize::of(&line[..idx + \"//\".len()]);\n-            for annotation in extract_line_annotations(&line[idx + \"//\".len()..]) {\n+        let line_length = if let Some((prefix, suffix)) = line.split_once(\"//\") {\n+            let ss_len = TextSize::of(\"//\");\n+            let annotation_offset = TextSize::of(prefix) + ss_len;\n+            for annotation in extract_line_annotations(suffix.trim_end_matches('\\n')) {\n                 match annotation {\n                     LineAnnotation::Annotation { mut range, content, file } => {\n                         range += annotation_offset;\n@@ -257,7 +265,7 @@ pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n                     }\n                 }\n             }\n-            idx.try_into().unwrap()\n+            annotation_offset\n         } else {\n             TextSize::of(line)\n         };\n@@ -294,16 +302,29 @@ fn extract_line_annotations(mut line: &str) -> Vec<LineAnnotation> {\n             len = 1;\n         }\n         let range = TextRange::at(offset, len.try_into().unwrap());\n-        let next = line[len..].find(marker).map_or(line.len(), |it| it + len);\n-        let mut content = &line[len..][..next - len];\n+        let line_no_caret = &line[len..];\n+        let end_marker = line_no_caret.find(|c| c == '$');\n+        let next = line_no_caret.find(marker).map_or(line.len(), |it| it + len);\n+\n+        let mut content = match end_marker {\n+            Some(end_marker)\n+                if end_marker < next\n+                    && line_no_caret[end_marker..]\n+                        .strip_prefix(|c: char| c.is_whitespace() || c == '^')\n+                        .is_some() =>\n+            {\n+                &line_no_caret[..end_marker]\n+            }\n+            _ => line_no_caret[..next - len].trim_end(),\n+        };\n \n         let mut file = false;\n         if !continuation && content.starts_with(\"file\") {\n             file = true;\n             content = &content[\"file\".len()..];\n         }\n \n-        let content = content.trim().to_string();\n+        let content = content.trim_start().to_string();\n \n         let annotation = if continuation {\n             LineAnnotation::Continuation { offset: range.end(), content }"}]}