{"sha": "157231183c586dd19d150a7324b07d65cf7a002f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NzIzMTE4M2M1ODZkZDE5ZDE1MGE3MzI0YjA3ZDY1Y2Y3YTAwMmY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-06T18:27:38Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-10T15:46:29Z"}, "message": "start extracting things into modules\n\nThe borrow_check module is too big for its own good", "tree": {"sha": "6fbc3faddc2398bca5b92f1fc11c94033feb8097", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fbc3faddc2398bca5b92f1fc11c94033feb8097"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/157231183c586dd19d150a7324b07d65cf7a002f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/157231183c586dd19d150a7324b07d65cf7a002f", "html_url": "https://github.com/rust-lang/rust/commit/157231183c586dd19d150a7324b07d65cf7a002f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/157231183c586dd19d150a7324b07d65cf7a002f/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02b4d3ddfb7cd9f1caf8ed90f18f8e798a1f4b05", "url": "https://api.github.com/repos/rust-lang/rust/commits/02b4d3ddfb7cd9f1caf8ed90f18f8e798a1f4b05", "html_url": "https://github.com/rust-lang/rust/commit/02b4d3ddfb7cd9f1caf8ed90f18f8e798a1f4b05"}], "stats": {"total": 2180, "additions": 1132, "deletions": 1048}, "files": [{"sha": "7ae980bc861b8b4bb8cb2b68bd2b193ae637739e", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "added", "additions": 550, "deletions": 0, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=157231183c586dd19d150a7324b07d65cf7a002f", "patch": "@@ -0,0 +1,550 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax_pos::Span;\n+use rustc::mir::{BorrowKind, Field, Local, Location, Operand};\n+use rustc::mir::{Place, ProjectionElem, Rvalue, StatementKind};\n+use rustc::ty;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use super::{MirBorrowckCtxt, Context};\n+use super::{InitializationRequiringAction, PrefixSet};\n+use super::flow::FlowInProgress;\n+use dataflow::{BorrowData, MovingOutStatements};\n+use dataflow::move_paths::MovePathIndex;\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n+\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    pub(super) fn report_use_of_moved_or_uninitialized(\n+        &mut self,\n+        _context: Context,\n+        desired_action: InitializationRequiringAction,\n+        (place, span): (&Place<'tcx>, Span),\n+        mpi: MovePathIndex,\n+        curr_move_out: &FlowInProgress<MovingOutStatements<'_, 'gcx, 'tcx>>,\n+    ) {\n+        let mois = self.move_data.path_map[mpi]\n+            .iter()\n+            .filter(|moi| curr_move_out.contains(moi))\n+            .collect::<Vec<_>>();\n+\n+        if mois.is_empty() {\n+            let item_msg = match self.describe_place(place) {\n+                Some(name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned(),\n+            };\n+            self.tcx\n+                .cannot_act_on_uninitialized_variable(\n+                    span,\n+                    desired_action.as_noun(),\n+                    &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+                    Origin::Mir,\n+                )\n+                .span_label(span, format!(\"use of possibly uninitialized {}\", item_msg))\n+                .emit();\n+        } else {\n+            let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n+\n+            let mut err = self.tcx.cannot_act_on_moved_value(\n+                span,\n+                desired_action.as_noun(),\n+                msg,\n+                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+                Origin::Mir,\n+            );\n+\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"value {} here after move\",\n+                    desired_action.as_verb_in_past_tense()\n+                ),\n+            );\n+            for moi in mois {\n+                let move_msg = \"\"; //FIXME: add \" (into closure)\"\n+                let move_span = self.mir.source_info(self.move_data.moves[*moi].source).span;\n+                if span == move_span {\n+                    err.span_label(\n+                        span,\n+                        format!(\"value moved{} here in previous iteration of loop\", move_msg),\n+                    );\n+                } else {\n+                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                };\n+            }\n+            //FIXME: add note for closure\n+            err.emit();\n+        }\n+    }\n+\n+    pub(super) fn report_move_out_while_borrowed(\n+        &mut self,\n+        _context: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        borrow: &BorrowData<'tcx>,\n+    ) {\n+        let value_msg = match self.describe_place(place) {\n+            Some(name) => format!(\"`{}`\", name),\n+            None => \"value\".to_owned(),\n+        };\n+        let borrow_msg = match self.describe_place(&borrow.place) {\n+            Some(name) => format!(\"`{}`\", name),\n+            None => \"value\".to_owned(),\n+        };\n+        self.tcx\n+            .cannot_move_when_borrowed(\n+                span,\n+                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+                Origin::Mir,\n+            )\n+            .span_label(\n+                self.retrieve_borrow_span(borrow),\n+                format!(\"borrow of {} occurs here\", borrow_msg),\n+            )\n+            .span_label(span, format!(\"move out of {} occurs here\", value_msg))\n+            .emit();\n+    }\n+\n+    pub(super) fn report_use_while_mutably_borrowed(\n+        &mut self,\n+        _context: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        borrow: &BorrowData<'tcx>,\n+    ) {\n+        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n+            span,\n+            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+            self.retrieve_borrow_span(borrow),\n+            &self.describe_place(&borrow.place).unwrap_or(\"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+\n+        err.emit();\n+    }\n+\n+    /// Finds the span of arguments of a closure (within `maybe_closure_span`) and its usage of\n+    /// the local assigned at `location`.\n+    /// This is done by searching in statements succeeding `location`\n+    /// and originating from `maybe_closure_span`.\n+    fn find_closure_span(\n+        &self,\n+        maybe_closure_span: Span,\n+        location: Location,\n+    ) -> Option<(Span, Span)> {\n+        use rustc::hir::ExprClosure;\n+        use rustc::mir::AggregateKind;\n+\n+        let local = if let StatementKind::Assign(Place::Local(local), _) =\n+            self.mir[location.block].statements[location.statement_index].kind\n+        {\n+            local\n+        } else {\n+            return None;\n+        };\n+\n+        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+            if maybe_closure_span != stmt.source_info.span {\n+                break;\n+            }\n+\n+            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n+                if let AggregateKind::Closure(def_id, _) = **kind {\n+                    debug!(\"find_closure_span: found closure {:?}\", places);\n+\n+                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                        let args_span = if let ExprClosure(_, _, _, span, _) =\n+                            self.tcx.hir.expect_expr(node_id).node\n+                        {\n+                            span\n+                        } else {\n+                            return None;\n+                        };\n+\n+                        self.tcx\n+                            .with_freevars(node_id, |freevars| {\n+                                for (v, place) in freevars.iter().zip(places) {\n+                                    match *place {\n+                                        Operand::Copy(Place::Local(l)) |\n+                                        Operand::Move(Place::Local(l)) if local == l =>\n+                                        {\n+                                            debug!(\n+                                                \"find_closure_span: found captured local {:?}\",\n+                                                l\n+                                            );\n+                                            return Some(v.span);\n+                                        }\n+                                        _ => {}\n+                                    }\n+                                }\n+                                None\n+                            })\n+                            .map(|var_span| (args_span, var_span))\n+                    } else {\n+                        None\n+                    };\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    pub(super) fn report_conflicting_borrow(\n+        &mut self,\n+        context: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        gen_borrow_kind: BorrowKind,\n+        issued_borrow: &BorrowData,\n+        end_issued_loan_span: Option<Span>,\n+    ) {\n+        let issued_span = self.retrieve_borrow_span(issued_borrow);\n+\n+        let new_closure_span = self.find_closure_span(span, context.loc);\n+        let span = new_closure_span.map(|(args, _)| args).unwrap_or(span);\n+        let old_closure_span = self.find_closure_span(issued_span, issued_borrow.location);\n+        let issued_span = old_closure_span\n+            .map(|(args, _)| args)\n+            .unwrap_or(issued_span);\n+\n+        let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n+\n+        // FIXME: supply non-\"\" `opt_via` when appropriate\n+        let mut err = match (\n+            gen_borrow_kind,\n+            \"immutable\",\n+            \"mutable\",\n+            issued_borrow.kind,\n+            \"immutable\",\n+            \"mutable\",\n+        ) {\n+            (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n+            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n+                .cannot_reborrow_already_borrowed(\n+                    span,\n+                    &desc_place,\n+                    \"\",\n+                    lft,\n+                    issued_span,\n+                    \"it\",\n+                    rgt,\n+                    \"\",\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) => self.tcx\n+                .cannot_mutably_borrow_multiply(\n+                    span,\n+                    &desc_place,\n+                    \"\",\n+                    issued_span,\n+                    \"\",\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => self.tcx\n+                .cannot_uniquely_borrow_by_two_closures(\n+                    span,\n+                    &desc_place,\n+                    issued_span,\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Unique, _, _, _, _, _) => self.tcx.cannot_uniquely_borrow_by_one_closure(\n+                span,\n+                &desc_place,\n+                \"\",\n+                issued_span,\n+                \"it\",\n+                \"\",\n+                end_issued_loan_span,\n+                Origin::Mir,\n+            ),\n+\n+            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => self.tcx\n+                .cannot_reborrow_already_uniquely_borrowed(\n+                    span,\n+                    &desc_place,\n+                    \"\",\n+                    lft,\n+                    issued_span,\n+                    \"\",\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Mut, _, lft, BorrowKind::Unique, _, _) => self.tcx\n+                .cannot_reborrow_already_uniquely_borrowed(\n+                    span,\n+                    &desc_place,\n+                    \"\",\n+                    lft,\n+                    issued_span,\n+                    \"\",\n+                    end_issued_loan_span,\n+                    Origin::Mir,\n+                ),\n+\n+            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) => unreachable!(),\n+        };\n+\n+        if let Some((_, var_span)) = old_closure_span {\n+            err.span_label(\n+                var_span,\n+                format!(\n+                    \"previous borrow occurs due to use of `{}` in closure\",\n+                    desc_place\n+                ),\n+            );\n+        }\n+\n+        if let Some((_, var_span)) = new_closure_span {\n+            err.span_label(\n+                var_span,\n+                format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n+            );\n+        }\n+\n+        err.emit();\n+    }\n+\n+    pub(super) fn report_borrowed_value_does_not_live_long_enough(\n+        &mut self,\n+        _: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        end_span: Option<Span>,\n+    ) {\n+        let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n+        let proper_span = match *root_place {\n+            Place::Local(local) => self.mir.local_decls[local].source_info.span,\n+            _ => span,\n+        };\n+        let mut err = self.tcx\n+            .path_does_not_live_long_enough(span, \"borrowed value\", Origin::Mir);\n+        err.span_label(proper_span, \"temporary value created here\");\n+        err.span_label(span, \"temporary value dropped here while still borrowed\");\n+        err.note(\"consider using a `let` binding to increase its lifetime\");\n+\n+        if let Some(end) = end_span {\n+            err.span_label(end, \"temporary value needs to live until here\");\n+        }\n+\n+        err.emit();\n+    }\n+\n+    pub(super) fn report_illegal_mutation_of_borrowed(\n+        &mut self,\n+        _: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        loan: &BorrowData,\n+    ) {\n+        let mut err = self.tcx.cannot_assign_to_borrowed(\n+            span,\n+            self.retrieve_borrow_span(loan),\n+            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+\n+        err.emit();\n+    }\n+\n+    pub(super) fn report_illegal_reassignment(\n+        &mut self,\n+        _context: Context,\n+        (place, span): (&Place<'tcx>, Span),\n+        assigned_span: Span,\n+    ) {\n+        let mut err = self.tcx.cannot_reassign_immutable(\n+            span,\n+            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n+            Origin::Mir,\n+        );\n+        err.span_label(span, \"cannot assign twice to immutable variable\");\n+        if span != assigned_span {\n+            let value_msg = match self.describe_place(place) {\n+                Some(name) => format!(\"`{}`\", name),\n+                None => \"value\".to_owned(),\n+            };\n+            err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n+        }\n+        err.emit();\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    // End-user visible description of `place` if one can be found. If the\n+    // place is a temporary for instance, None will be returned.\n+    pub(super) fn describe_place(&self, place: &Place<'tcx>) -> Option<String> {\n+        let mut buf = String::new();\n+        match self.append_place_to_string(place, &mut buf, false) {\n+            Ok(()) => Some(buf),\n+            Err(()) => None,\n+        }\n+    }\n+\n+    // Appends end-user visible description of `place` to `buf`.\n+    fn append_place_to_string(\n+        &self,\n+        place: &Place<'tcx>,\n+        buf: &mut String,\n+        mut autoderef: bool,\n+    ) -> Result<(), ()> {\n+        match *place {\n+            Place::Local(local) => {\n+                self.append_local_to_string(local, buf)?;\n+            }\n+            Place::Static(ref static_) => {\n+                buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n+            }\n+            Place::Projection(ref proj) => {\n+                match proj.elem {\n+                    ProjectionElem::Deref => {\n+                        if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n+                            let var_index = field.index();\n+                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n+                            if self.mir.upvar_decls[var_index].by_ref {\n+                                buf.push_str(&name);\n+                            } else {\n+                                buf.push_str(&format!(\"*{}\", &name));\n+                            }\n+                        } else {\n+                            if autoderef {\n+                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                            } else {\n+                                buf.push_str(&\"*\");\n+                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                            }\n+                        }\n+                    }\n+                    ProjectionElem::Downcast(..) => {\n+                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                    }\n+                    ProjectionElem::Field(field, _ty) => {\n+                        autoderef = true;\n+\n+                        if let Some(field) = self.is_upvar_field_projection(place) {\n+                            let var_index = field.index();\n+                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n+                            buf.push_str(&name);\n+                        } else {\n+                            let field_name = self.describe_field(&proj.base, field);\n+                            self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                            buf.push_str(&format!(\".{}\", field_name));\n+                        }\n+                    }\n+                    ProjectionElem::Index(index) => {\n+                        autoderef = true;\n+\n+                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                        buf.push_str(\"[\");\n+                        if let Err(_) = self.append_local_to_string(index, buf) {\n+                            buf.push_str(\"..\");\n+                        }\n+                        buf.push_str(\"]\");\n+                    }\n+                    ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n+                        autoderef = true;\n+                        // Since it isn't possible to borrow an element on a particular index and\n+                        // then use another while the borrow is held, don't output indices details\n+                        // to avoid confusing the end-user\n+                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n+                        buf.push_str(&\"[..]\");\n+                    }\n+                };\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    // Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n+    // a name, then `Err` is returned\n+    fn append_local_to_string(&self, local_index: Local, buf: &mut String) -> Result<(), ()> {\n+        let local = &self.mir.local_decls[local_index];\n+        match local.name {\n+            Some(name) => {\n+                buf.push_str(&format!(\"{}\", name));\n+                Ok(())\n+            }\n+            None => Err(()),\n+        }\n+    }\n+\n+    // End-user visible description of the `field`nth field of `base`\n+    fn describe_field(&self, base: &Place, field: Field) -> String {\n+        match *base {\n+            Place::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                self.describe_field_from_ty(&local.ty, field)\n+            }\n+            Place::Static(ref static_) => self.describe_field_from_ty(&static_.ty, field),\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Deref => self.describe_field(&proj.base, field),\n+                ProjectionElem::Downcast(def, variant_index) => {\n+                    format!(\"{}\", def.variants[variant_index].fields[field.index()].name)\n+                }\n+                ProjectionElem::Field(_, field_type) => {\n+                    self.describe_field_from_ty(&field_type, field)\n+                }\n+                ProjectionElem::Index(..) |\n+                ProjectionElem::ConstantIndex { .. } |\n+                ProjectionElem::Subslice { .. } => {\n+                    format!(\"{}\", self.describe_field(&proj.base, field))\n+                }\n+            },\n+        }\n+    }\n+\n+    // End-user visible description of the `field_index`nth field of `ty`\n+    fn describe_field_from_ty(&self, ty: &ty::Ty, field: Field) -> String {\n+        if ty.is_box() {\n+            // If the type is a box, the field is described from the boxed type\n+            self.describe_field_from_ty(&ty.boxed_ty(), field)\n+        } else {\n+            match ty.sty {\n+                ty::TyAdt(def, _) => if def.is_enum() {\n+                    format!(\"{}\", field.index())\n+                } else {\n+                    format!(\"{}\", def.struct_variant().fields[field.index()].name)\n+                },\n+                ty::TyTuple(_, _) => format!(\"{}\", field.index()),\n+                ty::TyRef(_, tnm) | ty::TyRawPtr(tnm) => {\n+                    self.describe_field_from_ty(&tnm.ty, field)\n+                }\n+                ty::TyArray(ty, _) | ty::TySlice(ty) => self.describe_field_from_ty(&ty, field),\n+                ty::TyClosure(closure_def_id, _) => {\n+                    // Convert the def-id into a node-id. node-ids are only valid for\n+                    // the local code in the current crate, so this returns an `Option` in case\n+                    // the closure comes from another crate. But in that case we wouldn't\n+                    // be borrowck'ing it, so we can just unwrap:\n+                    let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n+                    let freevar = self.tcx.with_freevars(node_id, |fv| fv[field.index()]);\n+\n+                    self.tcx.hir.name(freevar.var_id()).to_string()\n+                }\n+                _ => {\n+                    // Might need a revision when the fields in trait RFC is implemented\n+                    // (https://github.com/rust-lang/rfcs/pull/1546)\n+                    bug!(\n+                        \"End-user description not implemented for field access on `{:?}`\",\n+                        ty.sty\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    // Retrieve span of given borrow from the current MIR representation\n+    fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n+        self.mir.source_info(borrow.location).span\n+    }\n+}"}, {"sha": "5e9cee6c4b589ed9ef06e513e0d6037a8238677f", "filename": "src/librustc_mir/borrow_check/flow.rs", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Fflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Fflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflow.rs?ref=157231183c586dd19d150a7324b07d65cf7a002f", "patch": "@@ -0,0 +1,335 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Manages the dataflow bits required for borrowck.\n+//!\n+//! FIXME: this might be better as a \"generic\" fixed-point combinator,\n+//! but is not as ugly as it is right now.\n+\n+use rustc::mir::{BasicBlock, Location};\n+use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use dataflow::{BitDenotation, BlockSets, DataflowResults};\n+use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{EverInitializedLvals, MovingOutStatements};\n+use dataflow::Borrows;\n+use dataflow::move_paths::{HasMoveData, MovePathIndex};\n+use std::fmt;\n+\n+// (forced to be `pub` due to its use as an associated type below.)\n+pub struct InProgress<'b, 'gcx: 'tcx, 'tcx: 'b> {\n+    pub borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n+    pub inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+    pub uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+    pub move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n+    pub ever_inits: FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+}\n+\n+pub struct FlowInProgress<BD>\n+where\n+    BD: BitDenotation,\n+{\n+    base_results: DataflowResults<BD>,\n+    curr_state: IdxSetBuf<BD::Idx>,\n+    stmt_gen: IdxSetBuf<BD::Idx>,\n+    stmt_kill: IdxSetBuf<BD::Idx>,\n+}\n+\n+impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n+    pub fn new(\n+        borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n+        inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n+        uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+        move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n+        ever_inits: FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+    ) -> Self {\n+        InProgress {\n+            borrows,\n+            inits,\n+            uninits,\n+            move_outs,\n+            ever_inits,\n+        }\n+    }\n+\n+    fn each_flow<XB, XI, XU, XM, XE>(\n+        &mut self,\n+        mut xform_borrows: XB,\n+        mut xform_inits: XI,\n+        mut xform_uninits: XU,\n+        mut xform_move_outs: XM,\n+        mut xform_ever_inits: XE,\n+    ) where\n+        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'gcx, 'tcx>>),\n+        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>),\n+        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>),\n+        XM: FnMut(&mut FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>),\n+        XE: FnMut(&mut FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>),\n+    {\n+        xform_borrows(&mut self.borrows);\n+        xform_inits(&mut self.inits);\n+        xform_uninits(&mut self.uninits);\n+        xform_move_outs(&mut self.move_outs);\n+        xform_ever_inits(&mut self.ever_inits);\n+    }\n+\n+    pub fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n+        self.each_flow(\n+            |b| b.reset_to_entry_of(bb),\n+            |i| i.reset_to_entry_of(bb),\n+            |u| u.reset_to_entry_of(bb),\n+            |m| m.reset_to_entry_of(bb),\n+            |e| e.reset_to_entry_of(bb),\n+        );\n+    }\n+\n+    pub fn reconstruct_statement_effect(\n+        &mut self,\n+        location: Location,\n+    ) {\n+        self.each_flow(\n+            |b| b.reconstruct_statement_effect(location),\n+            |i| i.reconstruct_statement_effect(location),\n+            |u| u.reconstruct_statement_effect(location),\n+            |m| m.reconstruct_statement_effect(location),\n+            |e| e.reconstruct_statement_effect(location),\n+        );\n+    }\n+\n+    pub fn apply_local_effect(&mut self, _location: Location) {\n+        self.each_flow(\n+            |b| b.apply_local_effect(),\n+            |i| i.apply_local_effect(),\n+            |u| u.apply_local_effect(),\n+            |m| m.apply_local_effect(),\n+            |e| e.apply_local_effect(),\n+        );\n+    }\n+\n+    pub fn reconstruct_terminator_effect(&mut self, location: Location) {\n+        self.each_flow(\n+            |b| b.reconstruct_terminator_effect(location),\n+            |i| i.reconstruct_terminator_effect(location),\n+            |u| u.reconstruct_terminator_effect(location),\n+            |m| m.reconstruct_terminator_effect(location),\n+            |e| e.reconstruct_terminator_effect(location),\n+        );\n+    }\n+}\n+\n+impl<'b, 'gcx, 'tcx> fmt::Display for InProgress<'b, 'gcx, 'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut s = String::new();\n+\n+        s.push_str(\"borrows in effect: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_state_bit(|borrow| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"borrows generated: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_gen_bit(|borrow| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"inits: [\");\n+        let mut saw_one = false;\n+        self.inits.each_state_bit(|mpi_init| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let move_path = &self.inits.base_results.operator().move_data().move_paths[mpi_init];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"uninits: [\");\n+        let mut saw_one = false;\n+        self.uninits.each_state_bit(|mpi_uninit| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let move_path =\n+                &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"move_out: [\");\n+        let mut saw_one = false;\n+        self.move_outs.each_state_bit(|mpi_move_out| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let move_out = &self.move_outs.base_results.operator().move_data().moves[mpi_move_out];\n+            s.push_str(&format!(\"{:?}\", move_out));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"ever_init: [\");\n+        let mut saw_one = false;\n+        self.ever_inits.each_state_bit(|mpi_ever_init| {\n+            if saw_one {\n+                s.push_str(\", \");\n+            };\n+            saw_one = true;\n+            let ever_init =\n+                &self.ever_inits.base_results.operator().move_data().inits[mpi_ever_init];\n+            s.push_str(&format!(\"{:?}\", ever_init));\n+        });\n+        s.push_str(\"]\");\n+\n+        fmt::Display::fmt(&s, fmt)\n+    }\n+}\n+\n+impl<'tcx, T> FlowInProgress<T>\n+where\n+    T: HasMoveData<'tcx> + BitDenotation<Idx = MovePathIndex>,\n+{\n+    pub fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n+        let move_data = self.base_results.operator().move_data();\n+\n+        let mut todo = vec![mpi];\n+        let mut push_siblings = false; // don't look at siblings of original `mpi`.\n+        while let Some(mpi) = todo.pop() {\n+            if self.curr_state.contains(&mpi) {\n+                return Some(mpi);\n+            }\n+            let move_path = &move_data.move_paths[mpi];\n+            if let Some(child) = move_path.first_child {\n+                todo.push(child);\n+            }\n+            if push_siblings {\n+                if let Some(sibling) = move_path.next_sibling {\n+                    todo.push(sibling);\n+                }\n+            } else {\n+                // after we've processed the original `mpi`, we should\n+                // always traverse the siblings of any of its\n+                // children.\n+                push_siblings = true;\n+            }\n+        }\n+        return None;\n+    }\n+}\n+\n+impl<BD> FlowInProgress<BD>\n+where\n+    BD: BitDenotation,\n+{\n+    pub fn each_state_bit<F>(&self, f: F)\n+    where\n+        F: FnMut(BD::Idx),\n+    {\n+        self.curr_state\n+            .each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    fn each_gen_bit<F>(&self, f: F)\n+    where\n+        F: FnMut(BD::Idx),\n+    {\n+        self.stmt_gen\n+            .each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    pub fn new(results: DataflowResults<BD>) -> Self {\n+        let bits_per_block = results.sets().bits_per_block();\n+        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n+        FlowInProgress {\n+            base_results: results,\n+            curr_state: curr_state,\n+            stmt_gen: stmt_gen,\n+            stmt_kill: stmt_kill,\n+        }\n+    }\n+\n+    pub fn operator(&self) -> &BD {\n+        self.base_results.operator()\n+    }\n+\n+    pub fn contains(&self, x: &BD::Idx) -> bool {\n+        self.curr_state.contains(x)\n+    }\n+\n+    pub fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n+        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n+    }\n+\n+    pub fn reconstruct_statement_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored,\n+            gen_set: &mut self.stmt_gen,\n+            kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results\n+            .operator()\n+            .statement_effect(&mut sets, loc);\n+    }\n+\n+    pub fn reconstruct_terminator_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored,\n+            gen_set: &mut self.stmt_gen,\n+            kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results\n+            .operator()\n+            .terminator_effect(&mut sets, loc);\n+    }\n+\n+    pub fn apply_local_effect(&mut self) {\n+        self.curr_state.union(&self.stmt_gen);\n+        self.curr_state.subtract(&self.stmt_kill);\n+    }\n+\n+    pub fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.curr_state.elems(univ)\n+    }\n+\n+    pub fn with_elems_outgoing<F>(&self, f: F)\n+    where\n+        F: FnOnce(indexed_set::Elems<BD::Idx>),\n+    {\n+        let mut curr_state = self.curr_state.clone();\n+        curr_state.union(&self.stmt_gen);\n+        curr_state.subtract(&self.stmt_kill);\n+        let univ = self.base_results.sets().bits_per_block();\n+        f(curr_state.elems(univ));\n+    }\n+}"}, {"sha": "d3a8e2bce8238146268888b2afa64265997895c5", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 58, "deletions": 1047, "changes": 1105, "blob_url": "https://github.com/rust-lang/rust/blob/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=157231183c586dd19d150a7324b07d65cf7a002f", "patch": "@@ -22,27 +22,31 @@ use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n use rustc::mir::ClosureRegionRequirements;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_set::{IdxSetBuf};\n use rustc_data_structures::indexed_vec::Idx;\n \n use syntax::ast;\n use syntax_pos::Span;\n \n use dataflow::do_dataflow;\n use dataflow::MoveDataParamEnv;\n-use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n+use dataflow::DataflowResultsConsumer;\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n use dataflow::{BorrowData, BorrowIndex, Borrows};\n use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n-use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MoveOutIndex, MovePathIndex};\n+use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n-use std::fmt;\n use std::iter;\n \n+use self::flow::{InProgress, FlowInProgress};\n+use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n+mod error_reporting;\n+mod flow;\n+mod prefixes;\n pub(crate) mod nll;\n \n pub fn provide(providers: &mut Providers) {\n@@ -200,20 +204,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     };\n     let flow_inits = flow_inits; // remove mut\n \n-    let mut mbcx = MirBorrowckCtxt {\n-        tcx: tcx,\n-        mir: mir,\n-        node_id: id,\n-        move_data: &mdpe.move_data,\n-        param_env: param_env,\n-        locals_are_invalidated_at_exit: match tcx.hir.body_owner_kind(id) {\n-            hir::BodyOwnerKind::Const |\n-            hir::BodyOwnerKind::Static(_) => false,\n-            hir::BodyOwnerKind::Fn => true,\n-        },\n-        storage_dead_or_drop_error_reported: FxHashSet(),\n-    };\n-\n     let flow_borrows = FlowInProgress::new(do_dataflow(\n         tcx,\n         mir,\n@@ -232,6 +222,20 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         flow_ever_inits,\n     );\n \n+    let mut mbcx = MirBorrowckCtxt {\n+        tcx: tcx,\n+        mir: mir,\n+        node_id: id,\n+        move_data: &mdpe.move_data,\n+        param_env: param_env,\n+        locals_are_invalidated_at_exit: match tcx.hir.body_owner_kind(id) {\n+            hir::BodyOwnerKind::Const |\n+            hir::BodyOwnerKind::Static(_) => false,\n+            hir::BodyOwnerKind::Fn => true,\n+        },\n+        storage_dead_or_drop_error_reported: FxHashSet(),\n+    };\n+\n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n \n     opt_closure_req\n@@ -257,25 +261,6 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     storage_dead_or_drop_error_reported: FxHashSet<Local>,\n }\n \n-// (forced to be `pub` due to its use as an associated type below.)\n-pub struct InProgress<'b, 'gcx: 'tcx, 'tcx: 'b> {\n-    borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n-    inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n-    move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-    ever_inits: FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n-}\n-\n-struct FlowInProgress<BD>\n-where\n-    BD: BitDenotation,\n-{\n-    base_results: DataflowResults<BD>,\n-    curr_state: IdxSetBuf<BD::Idx>,\n-    stmt_gen: IdxSetBuf<BD::Idx>,\n-    stmt_kill: IdxSetBuf<BD::Idx>,\n-}\n-\n // Check that:\n // 1. assignments are always made to mutable locations (FIXME: does that still really go here?)\n // 2. loans made in overlapping scopes do not conflict\n@@ -289,51 +274,27 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n     }\n \n     fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n-        flow_state.each_flow(\n-            |b| b.reset_to_entry_of(bb),\n-            |i| i.reset_to_entry_of(bb),\n-            |u| u.reset_to_entry_of(bb),\n-            |m| m.reset_to_entry_of(bb),\n-            |e| e.reset_to_entry_of(bb),\n-        );\n+        flow_state.reset_to_entry_of(bb);\n     }\n \n     fn reconstruct_statement_effect(\n         &mut self,\n         location: Location,\n         flow_state: &mut Self::FlowState,\n     ) {\n-        flow_state.each_flow(\n-            |b| b.reconstruct_statement_effect(location),\n-            |i| i.reconstruct_statement_effect(location),\n-            |u| u.reconstruct_statement_effect(location),\n-            |m| m.reconstruct_statement_effect(location),\n-            |e| e.reconstruct_statement_effect(location),\n-        );\n+        flow_state.reconstruct_statement_effect(location);\n     }\n \n-    fn apply_local_effect(&mut self, _location: Location, flow_state: &mut Self::FlowState) {\n-        flow_state.each_flow(\n-            |b| b.apply_local_effect(),\n-            |i| i.apply_local_effect(),\n-            |u| u.apply_local_effect(),\n-            |m| m.apply_local_effect(),\n-            |e| e.apply_local_effect(),\n-        );\n+    fn apply_local_effect(&mut self, location: Location, flow_state: &mut Self::FlowState) {\n+        flow_state.apply_local_effect(location);\n     }\n \n     fn reconstruct_terminator_effect(\n         &mut self,\n         location: Location,\n         flow_state: &mut Self::FlowState,\n     ) {\n-        flow_state.each_flow(\n-            |b| b.reconstruct_terminator_effect(location),\n-            |i| i.reconstruct_terminator_effect(location),\n-            |u| u.reconstruct_terminator_effect(location),\n-            |m| m.reconstruct_terminator_effect(location),\n-            |e| e.reconstruct_terminator_effect(location),\n-        );\n+        flow_state.reconstruct_terminator_effect(location);\n     }\n \n     fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n@@ -560,7 +521,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // Often, the storage will already have been killed by an explicit\n                 // StorageDead, but we don't always emit those (notably on unwind paths),\n                 // so this \"extra check\" serves as a kind of backup.\n-                let domain = flow_state.borrows.base_results.operator();\n+                let domain = flow_state.borrows.operator();\n                 let data = domain.borrows();\n                 flow_state.borrows.with_elems_outgoing(|borrows| {\n                     for i in borrows {\n@@ -749,7 +710,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         ReadKind::Borrow(bk) => {\n                             let end_issued_loan_span = flow_state\n                                 .borrows\n-                                .base_results\n                                 .operator()\n                                 .opt_region_end_span(&borrow.region);\n                             error_reported = true;\n@@ -769,7 +729,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         WriteKind::MutableBorrow(bk) => {\n                             let end_issued_loan_span = flow_state\n                                 .borrows\n-                                .base_results\n                                 .operator()\n                                 .opt_region_end_span(&borrow.region);\n                             error_reported = true;\n@@ -784,7 +743,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         WriteKind::StorageDeadOrDrop => {\n                             let end_span = flow_state\n                                 .borrows\n-                                .base_results\n                                 .operator()\n                                 .opt_region_end_span(&borrow.region);\n                             error_reported = true;\n@@ -1060,7 +1018,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         match self.move_path_closest_to(place) {\n             Ok(mpi) => for ii in &move_data.init_path_map[mpi] {\n-                if flow_state.ever_inits.curr_state.contains(ii) {\n+                if flow_state.ever_inits.contains(ii) {\n                     let first_assign_span = self.move_data.inits[*ii].span;\n                     self.report_illegal_reassignment(context, (place, span), first_assign_span);\n                     break;\n@@ -1095,7 +1053,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let place = self.base_path(place_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n-        let curr_move_outs = &flow_state.move_outs.curr_state;\n+        let curr_move_outs = &flow_state.move_outs;\n \n         // Bad scenarios:\n         //\n@@ -1136,7 +1094,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         debug!(\"check_if_path_is_moved part1 place: {:?}\", place);\n         match self.move_path_closest_to(place) {\n             Ok(mpi) => {\n-                if maybe_uninits.curr_state.contains(&mpi) {\n+                if maybe_uninits.contains(&mpi) {\n                     self.report_use_of_moved_or_uninitialized(\n                         context,\n                         desired_action,\n@@ -1521,6 +1479,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+\n+    /// If this is a field projection, and the field is being projected from a closure type,\n+    /// then returns the index of the field being projected. Note that this closure will always\n+    /// be `self` in the current MIR, because that is the only time we directly access the fields\n+    /// of a closure type.\n+    fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n+        match *place {\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(field, _ty) => {\n+                    let is_projection_from_ty_closure = proj.base\n+                        .ty(self.mir, self.tcx)\n+                        .to_ty(self.tcx)\n+                        .is_closure();\n+\n+                    if is_projection_from_ty_closure {\n+                        Some(field)\n+                    } else {\n+                        None\n+                    }\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -1886,8 +1870,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // FIXME: analogous code in check_loans first maps `place` to\n         // its base_path.\n \n-        let domain = flow_state.borrows.base_results.operator();\n-        let data = domain.borrows();\n+        let data = flow_state.borrows.operator().borrows();\n \n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n@@ -1902,738 +1885,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-use self::prefixes::PrefixSet;\n-\n-/// From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n-/// place are formed by stripping away fields and derefs, except that\n-/// we stop when we reach the deref of a shared reference. [...] \"\n-///\n-/// \"Shallow prefixes are found by stripping away fields, but stop at\n-/// any dereference. So: writing a path like `a` is illegal if `a.b`\n-/// is borrowed. But: writing `a` is legal if `*a` is borrowed,\n-/// whether or not `a` is a shared or mutable reference. [...] \"\n-mod prefixes {\n-    use super::MirBorrowckCtxt;\n-\n-    use rustc::hir;\n-    use rustc::ty::{self, TyCtxt};\n-    use rustc::mir::{Mir, Place, ProjectionElem};\n-\n-    pub trait IsPrefixOf<'tcx> {\n-        fn is_prefix_of(&self, other: &Place<'tcx>) -> bool;\n-    }\n-\n-    impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n-        fn is_prefix_of(&self, other: &Place<'tcx>) -> bool {\n-            let mut cursor = other;\n-            loop {\n-                if self == cursor {\n-                    return true;\n-                }\n-\n-                match *cursor {\n-                    Place::Local(_) | Place::Static(_) => return false,\n-                    Place::Projection(ref proj) => {\n-                        cursor = &proj.base;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    pub(super) struct Prefixes<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-        mir: &'cx Mir<'tcx>,\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        kind: PrefixSet,\n-        next: Option<&'cx Place<'tcx>>,\n-    }\n-\n-    #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-    #[allow(dead_code)]\n-    pub(super) enum PrefixSet {\n-        /// Doesn't stop until it returns the base case (a Local or\n-        /// Static prefix).\n-        All,\n-        /// Stops at any dereference.\n-        Shallow,\n-        /// Stops at the deref of a shared reference.\n-        Supporting,\n-    }\n-\n-    impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-        /// Returns an iterator over the prefixes of `place`\n-        /// (inclusive) from longest to smallest, potentially\n-        /// terminating the iteration early based on `kind`.\n-        pub(super) fn prefixes(\n-            &self,\n-            place: &'cx Place<'tcx>,\n-            kind: PrefixSet,\n-        ) -> Prefixes<'cx, 'gcx, 'tcx> {\n-            Prefixes {\n-                next: Some(place),\n-                kind,\n-                mir: self.mir,\n-                tcx: self.tcx,\n-            }\n-        }\n-    }\n-\n-    impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n-        type Item = &'cx Place<'tcx>;\n-        fn next(&mut self) -> Option<Self::Item> {\n-            let mut cursor = self.next?;\n-\n-            // Post-processing `place`: Enqueue any remaining\n-            // work. Also, `place` may not be a prefix itself, but\n-            // may hold one further down (e.g. we never return\n-            // downcasts here, but may return a base of a downcast).\n-\n-            'cursor: loop {\n-                let proj = match *cursor {\n-                    Place::Local(_) | // search yielded this leaf\n-                    Place::Static(_) => {\n-                        self.next = None;\n-                        return Some(cursor);\n-                    }\n-\n-                    Place::Projection(ref proj) => proj,\n-                };\n-\n-                match proj.elem {\n-                    ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n-                        // FIXME: add union handling\n-                        self.next = Some(&proj.base);\n-                        return Some(cursor);\n-                    }\n-                    ProjectionElem::Downcast(..) |\n-                    ProjectionElem::Subslice { .. } |\n-                    ProjectionElem::ConstantIndex { .. } |\n-                    ProjectionElem::Index(_) => {\n-                        cursor = &proj.base;\n-                        continue 'cursor;\n-                    }\n-                    ProjectionElem::Deref => {\n-                        // (handled below)\n-                    }\n-                }\n-\n-                assert_eq!(proj.elem, ProjectionElem::Deref);\n-\n-                match self.kind {\n-                    PrefixSet::Shallow => {\n-                        // shallow prefixes are found by stripping away\n-                        // fields, but stop at *any* dereference.\n-                        // So we can just stop the traversal now.\n-                        self.next = None;\n-                        return Some(cursor);\n-                    }\n-                    PrefixSet::All => {\n-                        // all prefixes: just blindly enqueue the base\n-                        // of the projection\n-                        self.next = Some(&proj.base);\n-                        return Some(cursor);\n-                    }\n-                    PrefixSet::Supporting => {\n-                        // fall through!\n-                    }\n-                }\n-\n-                assert_eq!(self.kind, PrefixSet::Supporting);\n-                // supporting prefixes: strip away fields and\n-                // derefs, except we stop at the deref of a shared\n-                // reference.\n-\n-                let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                match ty.sty {\n-                    ty::TyRawPtr(_) |\n-                    ty::TyRef(\n-                        _, /*rgn*/\n-                        ty::TypeAndMut {\n-                            ty: _,\n-                            mutbl: hir::MutImmutable,\n-                        },\n-                    ) => {\n-                        // don't continue traversing over derefs of raw pointers or shared borrows.\n-                        self.next = None;\n-                        return Some(cursor);\n-                    }\n-\n-                    ty::TyRef(\n-                        _, /*rgn*/\n-                        ty::TypeAndMut {\n-                            ty: _,\n-                            mutbl: hir::MutMutable,\n-                        },\n-                    ) => {\n-                        self.next = Some(&proj.base);\n-                        return Some(cursor);\n-                    }\n-\n-                    ty::TyAdt(..) if ty.is_box() => {\n-                        self.next = Some(&proj.base);\n-                        return Some(cursor);\n-                    }\n-\n-                    _ => panic!(\"unknown type fed to Projection Deref.\"),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    fn report_use_of_moved_or_uninitialized(\n-        &mut self,\n-        _context: Context,\n-        desired_action: InitializationRequiringAction,\n-        (place, span): (&Place<'tcx>, Span),\n-        mpi: MovePathIndex,\n-        curr_move_out: &IdxSetBuf<MoveOutIndex>,\n-    ) {\n-        let mois = self.move_data.path_map[mpi]\n-            .iter()\n-            .filter(|moi| curr_move_out.contains(moi))\n-            .collect::<Vec<_>>();\n-\n-        if mois.is_empty() {\n-            let item_msg = match self.describe_place(place) {\n-                Some(name) => format!(\"`{}`\", name),\n-                None => \"value\".to_owned(),\n-            };\n-            self.tcx\n-                .cannot_act_on_uninitialized_variable(\n-                    span,\n-                    desired_action.as_noun(),\n-                    &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-                    Origin::Mir,\n-                )\n-                .span_label(span, format!(\"use of possibly uninitialized {}\", item_msg))\n-                .emit();\n-        } else {\n-            let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n-\n-            let mut err = self.tcx.cannot_act_on_moved_value(\n-                span,\n-                desired_action.as_noun(),\n-                msg,\n-                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-                Origin::Mir,\n-            );\n-\n-            err.span_label(\n-                span,\n-                format!(\n-                    \"value {} here after move\",\n-                    desired_action.as_verb_in_past_tense()\n-                ),\n-            );\n-            for moi in mois {\n-                let move_msg = \"\"; //FIXME: add \" (into closure)\"\n-                let move_span = self.mir.source_info(self.move_data.moves[*moi].source).span;\n-                if span == move_span {\n-                    err.span_label(\n-                        span,\n-                        format!(\"value moved{} here in previous iteration of loop\", move_msg),\n-                    );\n-                } else {\n-                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n-                };\n-            }\n-            //FIXME: add note for closure\n-            err.emit();\n-        }\n-    }\n-\n-    fn report_move_out_while_borrowed(\n-        &mut self,\n-        _context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        borrow: &BorrowData<'tcx>,\n-    ) {\n-        let value_msg = match self.describe_place(place) {\n-            Some(name) => format!(\"`{}`\", name),\n-            None => \"value\".to_owned(),\n-        };\n-        let borrow_msg = match self.describe_place(&borrow.place) {\n-            Some(name) => format!(\"`{}`\", name),\n-            None => \"value\".to_owned(),\n-        };\n-        self.tcx\n-            .cannot_move_when_borrowed(\n-                span,\n-                &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-                Origin::Mir,\n-            )\n-            .span_label(\n-                self.retrieve_borrow_span(borrow),\n-                format!(\"borrow of {} occurs here\", borrow_msg),\n-            )\n-            .span_label(span, format!(\"move out of {} occurs here\", value_msg))\n-            .emit();\n-    }\n-\n-    fn report_use_while_mutably_borrowed(\n-        &mut self,\n-        _context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        borrow: &BorrowData<'tcx>,\n-    ) {\n-        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n-            span,\n-            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-            self.retrieve_borrow_span(borrow),\n-            &self.describe_place(&borrow.place).unwrap_or(\"_\".to_owned()),\n-            Origin::Mir,\n-        );\n-\n-        err.emit();\n-    }\n-\n-    /// Finds the span of arguments of a closure (within `maybe_closure_span`) and its usage of\n-    /// the local assigned at `location`.\n-    /// This is done by searching in statements succeeding `location`\n-    /// and originating from `maybe_closure_span`.\n-    fn find_closure_span(\n-        &self,\n-        maybe_closure_span: Span,\n-        location: Location,\n-    ) -> Option<(Span, Span)> {\n-        use rustc::hir::ExprClosure;\n-        use rustc::mir::AggregateKind;\n-\n-        let local = if let StatementKind::Assign(Place::Local(local), _) =\n-            self.mir[location.block].statements[location.statement_index].kind\n-        {\n-            local\n-        } else {\n-            return None;\n-        };\n-\n-        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n-            if maybe_closure_span != stmt.source_info.span {\n-                break;\n-            }\n-\n-            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref places)) = stmt.kind {\n-                if let AggregateKind::Closure(def_id, _) = **kind {\n-                    debug!(\"find_closure_span: found closure {:?}\", places);\n-\n-                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        let args_span = if let ExprClosure(_, _, _, span, _) =\n-                            self.tcx.hir.expect_expr(node_id).node\n-                        {\n-                            span\n-                        } else {\n-                            return None;\n-                        };\n-\n-                        self.tcx\n-                            .with_freevars(node_id, |freevars| {\n-                                for (v, place) in freevars.iter().zip(places) {\n-                                    match *place {\n-                                        Operand::Copy(Place::Local(l)) |\n-                                        Operand::Move(Place::Local(l)) if local == l =>\n-                                        {\n-                                            debug!(\n-                                                \"find_closure_span: found captured local {:?}\",\n-                                                l\n-                                            );\n-                                            return Some(v.span);\n-                                        }\n-                                        _ => {}\n-                                    }\n-                                }\n-                                None\n-                            })\n-                            .map(|var_span| (args_span, var_span))\n-                    } else {\n-                        None\n-                    };\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn report_conflicting_borrow(\n-        &mut self,\n-        context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        gen_borrow_kind: BorrowKind,\n-        issued_borrow: &BorrowData,\n-        end_issued_loan_span: Option<Span>,\n-    ) {\n-        let issued_span = self.retrieve_borrow_span(issued_borrow);\n-\n-        let new_closure_span = self.find_closure_span(span, context.loc);\n-        let span = new_closure_span.map(|(args, _)| args).unwrap_or(span);\n-        let old_closure_span = self.find_closure_span(issued_span, issued_borrow.location);\n-        let issued_span = old_closure_span\n-            .map(|(args, _)| args)\n-            .unwrap_or(issued_span);\n-\n-        let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n-\n-        // FIXME: supply non-\"\" `opt_via` when appropriate\n-        let mut err = match (\n-            gen_borrow_kind,\n-            \"immutable\",\n-            \"mutable\",\n-            issued_borrow.kind,\n-            \"immutable\",\n-            \"mutable\",\n-        ) {\n-            (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n-            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n-                .cannot_reborrow_already_borrowed(\n-                    span,\n-                    &desc_place,\n-                    \"\",\n-                    lft,\n-                    issued_span,\n-                    \"it\",\n-                    rgt,\n-                    \"\",\n-                    end_issued_loan_span,\n-                    Origin::Mir,\n-                ),\n-\n-            (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) => self.tcx\n-                .cannot_mutably_borrow_multiply(\n-                    span,\n-                    &desc_place,\n-                    \"\",\n-                    issued_span,\n-                    \"\",\n-                    end_issued_loan_span,\n-                    Origin::Mir,\n-                ),\n-\n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => self.tcx\n-                .cannot_uniquely_borrow_by_two_closures(\n-                    span,\n-                    &desc_place,\n-                    issued_span,\n-                    end_issued_loan_span,\n-                    Origin::Mir,\n-                ),\n-\n-            (BorrowKind::Unique, _, _, _, _, _) => self.tcx.cannot_uniquely_borrow_by_one_closure(\n-                span,\n-                &desc_place,\n-                \"\",\n-                issued_span,\n-                \"it\",\n-                \"\",\n-                end_issued_loan_span,\n-                Origin::Mir,\n-            ),\n-\n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => self.tcx\n-                .cannot_reborrow_already_uniquely_borrowed(\n-                    span,\n-                    &desc_place,\n-                    \"\",\n-                    lft,\n-                    issued_span,\n-                    \"\",\n-                    end_issued_loan_span,\n-                    Origin::Mir,\n-                ),\n-\n-            (BorrowKind::Mut, _, lft, BorrowKind::Unique, _, _) => self.tcx\n-                .cannot_reborrow_already_uniquely_borrowed(\n-                    span,\n-                    &desc_place,\n-                    \"\",\n-                    lft,\n-                    issued_span,\n-                    \"\",\n-                    end_issued_loan_span,\n-                    Origin::Mir,\n-                ),\n-\n-            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) => unreachable!(),\n-        };\n-\n-        if let Some((_, var_span)) = old_closure_span {\n-            err.span_label(\n-                var_span,\n-                format!(\n-                    \"previous borrow occurs due to use of `{}` in closure\",\n-                    desc_place\n-                ),\n-            );\n-        }\n-\n-        if let Some((_, var_span)) = new_closure_span {\n-            err.span_label(\n-                var_span,\n-                format!(\"borrow occurs due to use of `{}` in closure\", desc_place),\n-            );\n-        }\n-\n-        err.emit();\n-    }\n-\n-    fn report_borrowed_value_does_not_live_long_enough(\n-        &mut self,\n-        _: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        end_span: Option<Span>,\n-    ) {\n-        let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n-        let proper_span = match *root_place {\n-            Place::Local(local) => self.mir.local_decls[local].source_info.span,\n-            _ => span,\n-        };\n-        let mut err = self.tcx\n-            .path_does_not_live_long_enough(span, \"borrowed value\", Origin::Mir);\n-        err.span_label(proper_span, \"temporary value created here\");\n-        err.span_label(span, \"temporary value dropped here while still borrowed\");\n-        err.note(\"consider using a `let` binding to increase its lifetime\");\n-\n-        if let Some(end) = end_span {\n-            err.span_label(end, \"temporary value needs to live until here\");\n-        }\n-\n-        err.emit();\n-    }\n-\n-    fn report_illegal_mutation_of_borrowed(\n-        &mut self,\n-        _: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        loan: &BorrowData,\n-    ) {\n-        let mut err = self.tcx.cannot_assign_to_borrowed(\n-            span,\n-            self.retrieve_borrow_span(loan),\n-            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-            Origin::Mir,\n-        );\n-\n-        err.emit();\n-    }\n-\n-    fn report_illegal_reassignment(\n-        &mut self,\n-        _context: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        assigned_span: Span,\n-    ) {\n-        let mut err = self.tcx.cannot_reassign_immutable(\n-            span,\n-            &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n-            Origin::Mir,\n-        );\n-        err.span_label(span, \"cannot assign twice to immutable variable\");\n-        if span != assigned_span {\n-            let value_msg = match self.describe_place(place) {\n-                Some(name) => format!(\"`{}`\", name),\n-                None => \"value\".to_owned(),\n-            };\n-            err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n-        }\n-        err.emit();\n-    }\n-}\n-\n-impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n-    // End-user visible description of `place` if one can be found. If the\n-    // place is a temporary for instance, None will be returned.\n-    fn describe_place(&self, place: &Place<'tcx>) -> Option<String> {\n-        let mut buf = String::new();\n-        match self.append_place_to_string(place, &mut buf, false) {\n-            Ok(()) => Some(buf),\n-            Err(()) => None,\n-        }\n-    }\n-\n-    /// If this is a field projection, and the field is being projected from a closure type,\n-    /// then returns the index of the field being projected. Note that this closure will always\n-    /// be `self` in the current MIR, because that is the only time we directly access the fields\n-    /// of a closure type.\n-    fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n-        match *place {\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _ty) => {\n-                    let is_projection_from_ty_closure = proj.base\n-                        .ty(self.mir, self.tcx)\n-                        .to_ty(self.tcx)\n-                        .is_closure();\n-\n-                    if is_projection_from_ty_closure {\n-                        Some(field)\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    // Appends end-user visible description of `place` to `buf`.\n-    fn append_place_to_string(\n-        &self,\n-        place: &Place<'tcx>,\n-        buf: &mut String,\n-        mut autoderef: bool,\n-    ) -> Result<(), ()> {\n-        match *place {\n-            Place::Local(local) => {\n-                self.append_local_to_string(local, buf)?;\n-            }\n-            Place::Static(ref static_) => {\n-                buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n-            }\n-            Place::Projection(ref proj) => {\n-                match proj.elem {\n-                    ProjectionElem::Deref => {\n-                        if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n-                            let var_index = field.index();\n-                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n-                            if self.mir.upvar_decls[var_index].by_ref {\n-                                buf.push_str(&name);\n-                            } else {\n-                                buf.push_str(&format!(\"*{}\", &name));\n-                            }\n-                        } else {\n-                            if autoderef {\n-                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                            } else {\n-                                buf.push_str(&\"*\");\n-                                self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                            }\n-                        }\n-                    }\n-                    ProjectionElem::Downcast(..) => {\n-                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                    }\n-                    ProjectionElem::Field(field, _ty) => {\n-                        autoderef = true;\n-\n-                        if let Some(field) = self.is_upvar_field_projection(place) {\n-                            let var_index = field.index();\n-                            let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n-                            buf.push_str(&name);\n-                        } else {\n-                            let field_name = self.describe_field(&proj.base, field);\n-                            self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                            buf.push_str(&format!(\".{}\", field_name));\n-                        }\n-                    }\n-                    ProjectionElem::Index(index) => {\n-                        autoderef = true;\n-\n-                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                        buf.push_str(\"[\");\n-                        if let Err(_) = self.append_local_to_string(index, buf) {\n-                            buf.push_str(\"..\");\n-                        }\n-                        buf.push_str(\"]\");\n-                    }\n-                    ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n-                        autoderef = true;\n-                        // Since it isn't possible to borrow an element on a particular index and\n-                        // then use another while the borrow is held, don't output indices details\n-                        // to avoid confusing the end-user\n-                        self.append_place_to_string(&proj.base, buf, autoderef)?;\n-                        buf.push_str(&\"[..]\");\n-                    }\n-                };\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    // Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n-    // a name, then `Err` is returned\n-    fn append_local_to_string(&self, local_index: Local, buf: &mut String) -> Result<(), ()> {\n-        let local = &self.mir.local_decls[local_index];\n-        match local.name {\n-            Some(name) => {\n-                buf.push_str(&format!(\"{}\", name));\n-                Ok(())\n-            }\n-            None => Err(()),\n-        }\n-    }\n-\n-    // End-user visible description of the `field`nth field of `base`\n-    fn describe_field(&self, base: &Place, field: Field) -> String {\n-        match *base {\n-            Place::Local(local) => {\n-                let local = &self.mir.local_decls[local];\n-                self.describe_field_from_ty(&local.ty, field)\n-            }\n-            Place::Static(ref static_) => self.describe_field_from_ty(&static_.ty, field),\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Deref => self.describe_field(&proj.base, field),\n-                ProjectionElem::Downcast(def, variant_index) => {\n-                    format!(\"{}\", def.variants[variant_index].fields[field.index()].name)\n-                }\n-                ProjectionElem::Field(_, field_type) => {\n-                    self.describe_field_from_ty(&field_type, field)\n-                }\n-                ProjectionElem::Index(..) |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Subslice { .. } => {\n-                    format!(\"{}\", self.describe_field(&proj.base, field))\n-                }\n-            },\n-        }\n-    }\n-\n-    // End-user visible description of the `field_index`nth field of `ty`\n-    fn describe_field_from_ty(&self, ty: &ty::Ty, field: Field) -> String {\n-        if ty.is_box() {\n-            // If the type is a box, the field is described from the boxed type\n-            self.describe_field_from_ty(&ty.boxed_ty(), field)\n-        } else {\n-            match ty.sty {\n-                ty::TyAdt(def, _) => if def.is_enum() {\n-                    format!(\"{}\", field.index())\n-                } else {\n-                    format!(\"{}\", def.struct_variant().fields[field.index()].name)\n-                },\n-                ty::TyTuple(_, _) => format!(\"{}\", field.index()),\n-                ty::TyRef(_, tnm) | ty::TyRawPtr(tnm) => {\n-                    self.describe_field_from_ty(&tnm.ty, field)\n-                }\n-                ty::TyArray(ty, _) | ty::TySlice(ty) => self.describe_field_from_ty(&ty, field),\n-                ty::TyClosure(closure_def_id, _) => {\n-                    // Convert the def-id into a node-id. node-ids are only valid for\n-                    // the local code in the current crate, so this returns an `Option` in case\n-                    // the closure comes from another crate. But in that case we wouldn't\n-                    // be borrowck'ing it, so we can just unwrap:\n-                    let node_id = self.tcx.hir.as_local_node_id(closure_def_id).unwrap();\n-                    let freevar = self.tcx.with_freevars(node_id, |fv| fv[field.index()]);\n-\n-                    self.tcx.hir.name(freevar.var_id()).to_string()\n-                }\n-                _ => {\n-                    // Might need a revision when the fields in trait RFC is implemented\n-                    // (https://github.com/rust-lang/rfcs/pull/1546)\n-                    bug!(\n-                        \"End-user description not implemented for field access on `{:?}`\",\n-                        ty.sty\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    // Retrieve span of given borrow from the current MIR representation\n-    fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n-        self.mir.source_info(borrow.location).span\n-    }\n-}\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     // FIXME (#16118): function intended to allow the borrow checker\n@@ -2694,243 +1945,3 @@ impl ContextKind {\n         }\n     }\n }\n-\n-impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n-    fn new(\n-        borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n-        inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-        uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n-        move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-        ever_inits: FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n-    ) -> Self {\n-        InProgress {\n-            borrows,\n-            inits,\n-            uninits,\n-            move_outs,\n-            ever_inits,\n-        }\n-    }\n-\n-    fn each_flow<XB, XI, XU, XM, XE>(\n-        &mut self,\n-        mut xform_borrows: XB,\n-        mut xform_inits: XI,\n-        mut xform_uninits: XU,\n-        mut xform_move_outs: XM,\n-        mut xform_ever_inits: XE,\n-    ) where\n-        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'gcx, 'tcx>>),\n-        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>),\n-        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>),\n-        XM: FnMut(&mut FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>),\n-        XE: FnMut(&mut FlowInProgress<EverInitializedLvals<'b, 'gcx, 'tcx>>),\n-    {\n-        xform_borrows(&mut self.borrows);\n-        xform_inits(&mut self.inits);\n-        xform_uninits(&mut self.uninits);\n-        xform_move_outs(&mut self.move_outs);\n-        xform_ever_inits(&mut self.ever_inits);\n-    }\n-}\n-\n-impl<'b, 'gcx, 'tcx> fmt::Display for InProgress<'b, 'gcx, 'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut s = String::new();\n-\n-        s.push_str(\"borrows in effect: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_state_bit(|borrow| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n-            s.push_str(&format!(\"{}\", borrow_data));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"borrows generated: [\");\n-        let mut saw_one = false;\n-        self.borrows.each_gen_bit(|borrow| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n-            s.push_str(&format!(\"{}\", borrow_data));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"inits: [\");\n-        let mut saw_one = false;\n-        self.inits.each_state_bit(|mpi_init| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_path = &self.inits.base_results.operator().move_data().move_paths[mpi_init];\n-            s.push_str(&format!(\"{}\", move_path));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"uninits: [\");\n-        let mut saw_one = false;\n-        self.uninits.each_state_bit(|mpi_uninit| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_path =\n-                &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n-            s.push_str(&format!(\"{}\", move_path));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"move_out: [\");\n-        let mut saw_one = false;\n-        self.move_outs.each_state_bit(|mpi_move_out| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let move_out = &self.move_outs.base_results.operator().move_data().moves[mpi_move_out];\n-            s.push_str(&format!(\"{:?}\", move_out));\n-        });\n-        s.push_str(\"] \");\n-\n-        s.push_str(\"ever_init: [\");\n-        let mut saw_one = false;\n-        self.ever_inits.each_state_bit(|mpi_ever_init| {\n-            if saw_one {\n-                s.push_str(\", \");\n-            };\n-            saw_one = true;\n-            let ever_init =\n-                &self.ever_inits.base_results.operator().move_data().inits[mpi_ever_init];\n-            s.push_str(&format!(\"{:?}\", ever_init));\n-        });\n-        s.push_str(\"]\");\n-\n-        fmt::Display::fmt(&s, fmt)\n-    }\n-}\n-\n-impl<'tcx, T> FlowInProgress<T>\n-where\n-    T: HasMoveData<'tcx> + BitDenotation<Idx = MovePathIndex>,\n-{\n-    fn has_any_child_of(&self, mpi: T::Idx) -> Option<T::Idx> {\n-        let move_data = self.base_results.operator().move_data();\n-\n-        let mut todo = vec![mpi];\n-        let mut push_siblings = false; // don't look at siblings of original `mpi`.\n-        while let Some(mpi) = todo.pop() {\n-            if self.curr_state.contains(&mpi) {\n-                return Some(mpi);\n-            }\n-            let move_path = &move_data.move_paths[mpi];\n-            if let Some(child) = move_path.first_child {\n-                todo.push(child);\n-            }\n-            if push_siblings {\n-                if let Some(sibling) = move_path.next_sibling {\n-                    todo.push(sibling);\n-                }\n-            } else {\n-                // after we've processed the original `mpi`, we should\n-                // always traverse the siblings of any of its\n-                // children.\n-                push_siblings = true;\n-            }\n-        }\n-        return None;\n-    }\n-}\n-\n-impl<BD> FlowInProgress<BD>\n-where\n-    BD: BitDenotation,\n-{\n-    fn each_state_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.curr_state\n-            .each_bit(self.base_results.operator().bits_per_block(), f)\n-    }\n-\n-    fn each_gen_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.stmt_gen\n-            .each_bit(self.base_results.operator().bits_per_block(), f)\n-    }\n-\n-    fn new(results: DataflowResults<BD>) -> Self {\n-        let bits_per_block = results.sets().bits_per_block();\n-        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n-        FlowInProgress {\n-            base_results: results,\n-            curr_state: curr_state,\n-            stmt_gen: stmt_gen,\n-            stmt_kill: stmt_kill,\n-        }\n-    }\n-\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n-    }\n-\n-    fn reconstruct_statement_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n-        let mut sets = BlockSets {\n-            on_entry: &mut ignored,\n-            gen_set: &mut self.stmt_gen,\n-            kill_set: &mut self.stmt_kill,\n-        };\n-        self.base_results\n-            .operator()\n-            .statement_effect(&mut sets, loc);\n-    }\n-\n-    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n-        self.stmt_gen.reset_to_empty();\n-        self.stmt_kill.reset_to_empty();\n-        let mut ignored = IdxSetBuf::new_empty(0);\n-        let mut sets = BlockSets {\n-            on_entry: &mut ignored,\n-            gen_set: &mut self.stmt_gen,\n-            kill_set: &mut self.stmt_kill,\n-        };\n-        self.base_results\n-            .operator()\n-            .terminator_effect(&mut sets, loc);\n-    }\n-\n-    fn apply_local_effect(&mut self) {\n-        self.curr_state.union(&self.stmt_gen);\n-        self.curr_state.subtract(&self.stmt_kill);\n-    }\n-\n-    fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n-        let univ = self.base_results.sets().bits_per_block();\n-        self.curr_state.elems(univ)\n-    }\n-\n-    fn with_elems_outgoing<F>(&self, f: F)\n-    where\n-        F: FnOnce(indexed_set::Elems<BD::Idx>),\n-    {\n-        let mut curr_state = self.curr_state.clone();\n-        curr_state.union(&self.stmt_gen);\n-        curr_state.subtract(&self.stmt_kill);\n-        let univ = self.base_results.sets().bits_per_block();\n-        f(curr_state.elems(univ));\n-    }\n-}"}, {"sha": "a954d9f15e6bfcf7a24281c8c6434099ecdc7026", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=157231183c586dd19d150a7324b07d65cf7a002f", "patch": "@@ -172,7 +172,6 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                         \"add_liveness_constraints: location={:?} initialized={:?}\",\n                         location,\n                         &self.flow_inits\n-                            .base_results\n                             .operator()\n                             .move_data()\n                             .move_paths[mpi_init]"}, {"sha": "645c935de09b1a04cc985d39a5c4e54cc68e52e8", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157231183c586dd19d150a7324b07d65cf7a002f/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=157231183c586dd19d150a7324b07d65cf7a002f", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n+//! place are formed by stripping away fields and derefs, except that\n+//! we stop when we reach the deref of a shared reference. [...] \"\n+//!\n+//! \"Shallow prefixes are found by stripping away fields, but stop at\n+//! any dereference. So: writing a path like `a` is illegal if `a.b`\n+//! is borrowed. But: writing `a` is legal if `*a` is borrowed,\n+//! whether or not `a` is a shared or mutable reference. [...] \"\n+\n+use super::MirBorrowckCtxt;\n+\n+use rustc::hir;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::mir::{Mir, Place, ProjectionElem};\n+\n+pub trait IsPrefixOf<'tcx> {\n+    fn is_prefix_of(&self, other: &Place<'tcx>) -> bool;\n+}\n+\n+impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n+    fn is_prefix_of(&self, other: &Place<'tcx>) -> bool {\n+        let mut cursor = other;\n+        loop {\n+            if self == cursor {\n+                return true;\n+            }\n+\n+            match *cursor {\n+                Place::Local(_) | Place::Static(_) => return false,\n+                Place::Projection(ref proj) => {\n+                    cursor = &proj.base;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+pub(super) struct Prefixes<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    mir: &'cx Mir<'tcx>,\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    kind: PrefixSet,\n+    next: Option<&'cx Place<'tcx>>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[allow(dead_code)]\n+pub(super) enum PrefixSet {\n+    /// Doesn't stop until it returns the base case (a Local or\n+    /// Static prefix).\n+    All,\n+    /// Stops at any dereference.\n+    Shallow,\n+    /// Stops at the deref of a shared reference.\n+    Supporting,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    /// Returns an iterator over the prefixes of `place`\n+    /// (inclusive) from longest to smallest, potentially\n+    /// terminating the iteration early based on `kind`.\n+    pub(super) fn prefixes(\n+        &self,\n+        place: &'cx Place<'tcx>,\n+        kind: PrefixSet,\n+    ) -> Prefixes<'cx, 'gcx, 'tcx> {\n+        Prefixes {\n+            next: Some(place),\n+            kind,\n+            mir: self.mir,\n+            tcx: self.tcx,\n+        }\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n+    type Item = &'cx Place<'tcx>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let mut cursor = match self.next {\n+            None => return None,\n+            Some(place) => place,\n+        };\n+\n+        // Post-processing `place`: Enqueue any remaining\n+        // work. Also, `place` may not be a prefix itself, but\n+        // may hold one further down (e.g. we never return\n+        // downcasts here, but may return a base of a downcast).\n+\n+        'cursor: loop {\n+            let proj = match *cursor {\n+                Place::Local(_) | // search yielded this leaf\n+                Place::Static(_) => {\n+                    self.next = None;\n+                    return Some(cursor);\n+                }\n+\n+                Place::Projection(ref proj) => proj,\n+            };\n+\n+            match proj.elem {\n+                ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n+                        // FIXME: add union handling\n+                    self.next = Some(&proj.base);\n+                    return Some(cursor);\n+                }\n+                ProjectionElem::Downcast(..) |\n+                ProjectionElem::Subslice { .. } |\n+                ProjectionElem::ConstantIndex { .. } |\n+                ProjectionElem::Index(_) => {\n+                    cursor = &proj.base;\n+                    continue 'cursor;\n+                }\n+                ProjectionElem::Deref => {\n+                    // (handled below)\n+                }\n+            }\n+\n+            assert_eq!(proj.elem, ProjectionElem::Deref);\n+\n+            match self.kind {\n+                PrefixSet::Shallow => {\n+                    // shallow prefixes are found by stripping away\n+                    // fields, but stop at *any* dereference.\n+                    // So we can just stop the traversal now.\n+                    self.next = None;\n+                    return Some(cursor);\n+                }\n+                PrefixSet::All => {\n+                    // all prefixes: just blindly enqueue the base\n+                    // of the projection\n+                    self.next = Some(&proj.base);\n+                    return Some(cursor);\n+                }\n+                PrefixSet::Supporting => {\n+                    // fall through!\n+                }\n+            }\n+\n+            assert_eq!(self.kind, PrefixSet::Supporting);\n+            // supporting prefixes: strip away fields and\n+            // derefs, except we stop at the deref of a shared\n+            // reference.\n+\n+            let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            match ty.sty {\n+                ty::TyRawPtr(_) |\n+                ty::TyRef(\n+                    _, /*rgn*/\n+                    ty::TypeAndMut {\n+                        ty: _,\n+                            mutbl: hir::MutImmutable,\n+                        },\n+                    ) => {\n+                    // don't continue traversing over derefs of raw pointers or shared borrows.\n+                    self.next = None;\n+                    return Some(cursor);\n+                }\n+\n+                ty::TyRef(\n+                    _, /*rgn*/\n+                    ty::TypeAndMut {\n+                        ty: _,\n+                        mutbl: hir::MutMutable,\n+                    },\n+                    ) => {\n+                    self.next = Some(&proj.base);\n+                    return Some(cursor);\n+                }\n+\n+                ty::TyAdt(..) if ty.is_box() => {\n+                    self.next = Some(&proj.base);\n+                    return Some(cursor);\n+                }\n+\n+                _ => panic!(\"unknown type fed to Projection Deref.\"),\n+            }\n+        }\n+    }\n+}"}]}