{"sha": "c77fdbf2ebfa6a2f17017c38eebf18b4a802336a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3N2ZkYmYyZWJmYTZhMmYxNzAxN2MzOGVlYmYxOGI0YTgwMjMzNmE=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-03T21:50:49Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-26T21:27:08Z"}, "message": "Implemented variants on type aliases in both ctor and pattern position.", "tree": {"sha": "38ec1d72f31fa698cd4f2e383425d1797d204ec0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38ec1d72f31fa698cd4f2e383425d1797d204ec0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a", "html_url": "https://github.com/rust-lang/rust/commit/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b150c4043654f93fcf7250b560581d44fc2b43d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b150c4043654f93fcf7250b560581d44fc2b43d", "html_url": "https://github.com/rust-lang/rust/commit/1b150c4043654f93fcf7250b560581d44fc2b43d"}], "stats": {"total": 201, "additions": 166, "deletions": 35}, "files": [{"sha": "2b790e3e1d34b2e3ed11ee8c2b6581f6c733dd50", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c77fdbf2ebfa6a2f17017c38eebf18b4a802336a", "patch": "@@ -481,10 +481,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             }\n                         }\n                         AdtKind::Enum => {\n-                            let def = match *qpath {\n-                                hir::QPath::Resolved(_, ref path) => path.def,\n-                                hir::QPath::TypeRelative(..) => Def::Err,\n-                            };\n+                            let def = cx.tables().qpath_def(qpath, expr.hir_id);\n                             match def {\n                                 Def::Variant(variant_id) => {\n                                     assert!(base.is_none());"}, {"sha": "18c19352a603b7d3f1565bc9a8b5def82889c096", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c77fdbf2ebfa6a2f17017c38eebf18b4a802336a", "patch": "@@ -31,6 +31,8 @@ use std::collections::BTreeSet;\n use std::iter;\n use std::slice;\n \n+use super::{allow_type_alias_enum_variants};\n+\n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n@@ -1275,6 +1277,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                      ref_id: ast::NodeId,\n                                      span: Span,\n                                      ty: Ty<'tcx>,\n+                                     ty_hir: &hir::Ty,\n                                      ty_path_def: Def,\n                                      item_segment: &hir::PathSegment)\n                                      -> (Ty<'tcx>, Def)\n@@ -1286,6 +1289,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         self.prohibit_generics(slice::from_ref(item_segment));\n \n+        // Check if we have an enum variant here.\n+        if let ty::Adt(adt_def, _) = ty.sty {\n+            if adt_def.is_enum() {\n+                if allow_type_alias_enum_variants(tcx, ty_hir, span) {\n+                    let variant_def = adt_def.variants.iter().find(|vd| {\n+                        tcx.hygienic_eq(assoc_name, vd.ident, adt_def.did)\n+                    });\n+                    if let Some(variant_def) = variant_def {\n+                        let def = Def::Variant(variant_def.did);\n+                        return (ty, def);\n+                    }\n+                }\n+            }\n+        }\n+\n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n         let bound = match (&ty.sty, ty_path_def) {\n@@ -1342,7 +1360,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 return (tcx.types.err, Def::Err);\n             }\n             _ => {\n-                // Don't print TyErr to the user.\n+                // Don't print `TyErr` to the user.\n                 if !ty.references_error() {\n                     self.report_ambiguous_associated_type(span,\n                                                           &ty.to_string(),\n@@ -1505,10 +1523,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n             Def::SelfTy(_, Some(def_id)) => {\n                 // `Self` in impl (we know the concrete type)\n-\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n-\n                 tcx.at(span).type_of(def_id)\n             }\n             Def::SelfTy(Some(_), None) => {\n@@ -1602,7 +1618,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 } else {\n                     Def::Err\n                 };\n-                self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n+                self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, qself, def, segment).0\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir().local_def_id(length.id);"}, {"sha": "f594690f77f023d16f2c3ffb781c0a551873bec2", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=c77fdbf2ebfa6a2f17017c38eebf18b4a802336a", "patch": "@@ -1,4 +1,4 @@\n-//! Method lookup: the secret sauce of Rust. See the [rustc guide] chapter.\n+//! Method lookup: the secret sauce of Rust. See the [rustc guide] for more information.\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/method-lookup.html\n \n@@ -25,6 +25,7 @@ use rustc::infer::{self, InferOk};\n use syntax::ast;\n use syntax_pos::Span;\n \n+use crate::{allow_type_alias_enum_variants};\n use self::probe::{IsSuggestion, ProbeScope};\n \n pub fn provide(providers: &mut ty::query::Providers) {\n@@ -360,21 +361,45 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         span: Span,\n                         method_name: ast::Ident,\n                         self_ty: Ty<'tcx>,\n+                        self_ty_hir: &hir::Ty,\n                         expr_id: ast::NodeId)\n                         -> Result<Def, MethodError<'tcx>> {\n+        debug!(\"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\",\n+            method_name,\n+            self_ty,\n+            expr_id\n+        );\n+\n+        let tcx = self.tcx;\n+\n+        // Check if we have an enum variant here.\n+        if let ty::Adt(adt_def, _) = self_ty.sty {\n+            if adt_def.is_enum() {\n+                if allow_type_alias_enum_variants(tcx, self_ty_hir, span) {\n+                    let variant_def = adt_def.variants.iter().find(|vd| {\n+                        tcx.hygienic_eq(method_name, vd.ident, adt_def.did)\n+                    });\n+                    if let Some(variant_def) = variant_def {\n+                        let def = Def::VariantCtor(variant_def.did, variant_def.ctor_kind);\n+                        return Ok(def);\n+                    }\n+                }\n+            }\n+        }\n+\n         let mode = probe::Mode::Path;\n         let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n                                        self_ty, expr_id, ProbeScope::TraitsInScope)?;\n \n         if let Some(import_id) = pick.import_id {\n-            let import_def_id = self.tcx.hir().local_def_id(import_id);\n-            debug!(\"used_trait_import: {:?}\", import_def_id);\n+            let import_def_id = tcx.hir().local_def_id(import_id);\n+            debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n             Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n-                                        .unwrap().insert(import_def_id);\n+                                         .unwrap().insert(import_def_id);\n         }\n \n         let def = pick.item.def();\n-        self.tcx.check_stability(def.def_id(), Some(expr_id), span);\n+        tcx.check_stability(def.def_id(), Some(expr_id), span);\n \n         Ok(def)\n     }"}, {"sha": "9914ae7ed89307de59b6d0272d5782e7e4e6db88", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 85, "deletions": 21, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c77fdbf2ebfa6a2f17017c38eebf18b4a802336a", "patch": "@@ -101,14 +101,14 @@ use rustc::infer::opaque_types::OpaqueTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n-use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n-                       UserSelfTy, UserSubsts};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, RegionKind, Visibility,\n                 ToPolyTraitRef, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n+use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n+                       UserSelfTy, UserSubsts};\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use rustc::ty::layout::VariantIdx;\n use syntax_pos::{self, BytePos, Span, MultiSpan};\n@@ -4539,7 +4539,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Def::Err\n                 };\n                 let (ty, def) = AstConv::associated_path_def_to_ty(self, node_id, path_span,\n-                                                                   ty, def, segment);\n+                                                                   ty, qself, def, segment);\n \n                 // Write back the new resolution.\n                 let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n@@ -4558,14 +4558,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        let (ty, item_segment) = match *qpath {\n+        let (ty, ty_hir, item_segment) = match *qpath {\n             hir::QPath::Resolved(ref opt_qself, ref path) => {\n                 return (path.def,\n                         opt_qself.as_ref().map(|qself| self.to_ty(qself)),\n                         &path.segments[..]);\n             }\n             hir::QPath::TypeRelative(ref qself, ref segment) => {\n-                (self.to_ty(qself), segment)\n+                (self.to_ty(qself), qself, segment)\n             }\n         };\n         let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n@@ -4575,7 +4575,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return (*cached_def, Some(ty), slice::from_ref(&**item_segment))\n         }\n         let item_name = item_segment.ident;\n-        let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n+        let def = match self.resolve_ufcs(span, item_name, ty, ty_hir, node_id) {\n             Ok(def) => def,\n             Err(error) => {\n                 let def = match error {\n@@ -5042,6 +5042,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn def_ids_for_path_segments(&self,\n                                  segments: &[hir::PathSegment],\n+                                 self_ty: Option<Ty<'tcx>>,\n                                  def: Def)\n                                  -> Vec<PathSeg> {\n         // We need to extract the type parameters supplied by the user in\n@@ -5053,15 +5054,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // There are basically four cases to consider:\n         //\n-        // 1. Reference to a constructor of enum variant or struct:\n+        // 1. Reference to a constructor of a struct:\n         //\n         //        struct Foo<T>(...)\n+        //\n+        //    In this case, the parameters are declared in the type space.\n+        //\n+        // 2. Reference to a constructor of an enum variant:\n+        //\n         //        enum E<T> { Foo(...) }\n         //\n-        //    In these cases, the parameters are declared in the type\n-        //    space.\n+        //    In this case, the parameters are defined in the type space,\n+        //    but may be specified either on the type or the variant.\n         //\n-        // 2. Reference to a fn item or a free constant:\n+        // 3. Reference to a fn item or a free constant:\n         //\n         //        fn foo<T>() { }\n         //\n@@ -5070,7 +5076,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //    type parameters. However, in this case, those parameters are\n         //    declared on a value, and hence are in the `FnSpace`.\n         //\n-        // 3. Reference to a method or an associated constant:\n+        // 4. Reference to a method or an associated constant:\n         //\n         //        impl<A> SomeStruct<A> {\n         //            fn foo<B>(...)\n@@ -5082,7 +5088,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n         //    final segment, `foo::<B>` contains parameters in fn space.\n         //\n-        // 4. Reference to a local variable\n+        // 5. Reference to a local variable\n         //\n         //    Local variables can't have any type parameters.\n         //\n@@ -5094,9 +5100,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut path_segs = vec![];\n \n         match def {\n-            // Case 1. Reference to a struct/variant constructor.\n+            // Case 1. Reference to a struct constructor.\n             Def::StructCtor(def_id, ..) |\n-            Def::VariantCtor(def_id, ..) |\n             Def::SelfCtor(.., def_id) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n@@ -5107,14 +5112,49 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 path_segs.push(PathSeg(generics_def_id, last));\n             }\n \n-            // Case 2. Reference to a top-level value.\n+            // Case 2. Reference to a variant constructor.\n+            Def::VariantCtor(def_id, ..) => {\n+                if tcx.features().type_alias_enum_variants {\n+                    let adt_def = self_ty.and_then(|t| t.ty_adt_def());\n+                    let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n+                        debug_assert!(adt_def.is_enum());\n+                        (adt_def.did, last)\n+                    } else if last >= 1 && segments[last - 1].args.is_some() {\n+                        // Everything but the penultimate segment should have no\n+                        // parameters at all.\n+                        let enum_def_id = self.tcx.parent_def_id(def_id).unwrap();\n+                        (enum_def_id, last - 1)\n+                    } else {\n+                        // FIXME: lint here suggesting `Enum::<...>::Variant` form\n+                        // instead of `Enum::Variant::<...>` form.\n+\n+                        // Everything but the final segment should have no\n+                        // parameters at all.\n+                        let generics = self.tcx.generics_of(def_id);\n+                        // Variant and struct constructors use the\n+                        // generics of their parent type definition.\n+                        (generics.parent.unwrap_or(def_id), last)\n+                    };\n+                    path_segs.push(PathSeg(generics_def_id, index));\n+                } else {\n+                    // Everything but the final segment should have no\n+                    // parameters at all.\n+                    let generics = self.tcx.generics_of(def_id);\n+                    // Variant and struct constructors use the\n+                    // generics of their parent type definition.\n+                    let generics_def_id = generics.parent.unwrap_or(def_id);\n+                    path_segs.push(PathSeg(generics_def_id, last));\n+                }\n+            }\n+\n+            // Case 3. Reference to a top-level value.\n             Def::Fn(def_id) |\n             Def::Const(def_id) |\n             Def::Static(def_id, _) => {\n                 path_segs.push(PathSeg(def_id, last));\n             }\n \n-            // Case 3. Reference to a method or associated const.\n+            // Case 4. Reference to a method or associated const.\n             Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n                 if segments.len() >= 2 {\n@@ -5124,7 +5164,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 path_segs.push(PathSeg(def_id, last));\n             }\n \n-            // Case 4. Local variable, no generics.\n+            // Case 5. Local variable, no generics.\n             Def::Local(..) | Def::Upvar(..) => {}\n \n             _ => bug!(\"unexpected definition: {:?}\", def),\n@@ -5152,7 +5192,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             node_id,\n         );\n \n-        let path_segs = self.def_ids_for_path_segments(segments, def);\n+        let path_segs = self.def_ids_for_path_segments(segments, self_ty, def);\n \n         let mut user_self_ty = None;\n         match def {\n@@ -5187,10 +5227,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // provided (if any) into their appropriate spaces. We'll also report\n         // errors if type parameters are provided in an inappropriate place.\n \n-        let generic_segs = path_segs.iter().map(|PathSeg(_, index)| index)\n-            .collect::<FxHashSet<_>>();\n+        let is_alias_variant_ctor = if tcx.features().type_alias_enum_variants {\n+            match def {\n+                Def::VariantCtor(_, _) if self_ty.is_some() => true,\n+                _ => false,\n+            };\n+        } else {\n+            false\n+        };\n+\n+        let generic_segs: FxHashSet<_> = path_segs.iter().map(|PathSeg(_, index)| index).collect();\n         AstConv::prohibit_generics(self, segments.iter().enumerate().filter_map(|(index, seg)| {\n-            if !generic_segs.contains(&index) {\n+            if !generic_segs.contains(&index) || is_alias_variant_ctor {\n                 Some(seg)\n             } else {\n                 None\n@@ -5274,6 +5322,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+            Def::VariantCtor(_, _) if self_ty.is_some() => {\n+                let def_id = def.def_id();\n+\n+                let ty = self.tcx.type_of(def_id);\n+                if tcx.features().type_alias_enum_variants {\n+                    if let Some(self_ty) = self_ty {\n+                        match ty.ty_adt_def() {\n+                            Some(adt_def) if adt_def.is_enum() => {\n+                                return (self_ty, def);\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+                (def_id, ty)\n+            }\n             _ => {\n                 let def_id = def.def_id();\n "}, {"sha": "d63e5a3fe93a4e5b18506f6b5b513772ebeed63c", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c77fdbf2ebfa6a2f17017c38eebf18b4a802336a", "patch": "@@ -105,12 +105,14 @@ mod outlives;\n mod variance;\n \n use hir::Node;\n+use hir::def::Def;\n use rustc_target::spec::abi::Abi;\n use rustc::hir;\n use rustc::infer::InferOk;\n use rustc::lint;\n use rustc::middle;\n use rustc::session;\n+use rustc::session::config::nightly_options;\n use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -129,6 +131,30 @@ pub struct TypeAndSubsts<'tcx> {\n     ty: Ty<'tcx>,\n }\n \n+fn allow_type_alias_enum_variants<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                  ty_hir: &hir::Ty,\n+                                                  span: Span) -> bool {\n+    let allow_feature = tcx.features().type_alias_enum_variants;\n+    if !allow_feature {\n+        // Only print error if we know the type is an alias.\n+        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ty_hir.node {\n+            if let Def::TyAlias(_) = path.def {\n+                let mut err = tcx.sess.struct_span_err(\n+                    span,\n+                    \"type alias enum variants are not yet allowed\"\n+                );\n+                if nightly_options::is_nightly_build() {\n+                    help!(&mut err,\n+                        \"add `#![feature(type_alias_enum_variants)]` to the \\\n+                        crate attributes to enable\");\n+                }\n+                err.emit();\n+            }\n+        }\n+    }\n+    allow_feature\n+}\n+\n fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              decl: &hir::FnDecl,\n                              abi: Abi,"}, {"sha": "6a3b2156f3ae7a5762491e5ef7a42480b018e211", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77fdbf2ebfa6a2f17017c38eebf18b4a802336a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c77fdbf2ebfa6a2f17017c38eebf18b4a802336a", "patch": "@@ -471,11 +471,14 @@ declare_features! (\n     // Allows `const _: TYPE = VALUE`.\n     (active, underscore_const_names, \"1.31.0\", Some(54912), None),\n \n-    // `reason = ` in lint attributes and `expect` lint attribute\n+    // Adds `reason` and `expect` lint attributes.\n     (active, lint_reasons, \"1.31.0\", Some(54503), None),\n \n     // `extern crate self as foo;` puts local crate root into extern prelude under name `foo`.\n     (active, extern_crate_self, \"1.31.0\", Some(56409), None),\n+\n+    // Allows paths to enum variants on type aliases.\n+    (active, type_alias_enum_variants, \"1.31.0\", Some(49683), None),\n );\n \n declare_features! ("}]}