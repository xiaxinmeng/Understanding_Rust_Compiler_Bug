{"sha": "0f996f70a632d1427801f20935a69a57fbb3679e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmOTk2ZjcwYTYzMmQxNDI3ODAxZjIwOTM1YTY5YTU3ZmJiMzY3OWU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-24T01:17:16Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-24T02:40:01Z"}, "message": "Remove purity from fn_decl and move it out to containing AST elements.", "tree": {"sha": "10bb420206b95838c5bd1b2ac6451cf93ef0b8f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10bb420206b95838c5bd1b2ac6451cf93ef0b8f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f996f70a632d1427801f20935a69a57fbb3679e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f996f70a632d1427801f20935a69a57fbb3679e", "html_url": "https://github.com/rust-lang/rust/commit/0f996f70a632d1427801f20935a69a57fbb3679e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f996f70a632d1427801f20935a69a57fbb3679e/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34886ed488f6cc18c3fdc20cdeccab6178e00c0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/34886ed488f6cc18c3fdc20cdeccab6178e00c0f", "html_url": "https://github.com/rust-lang/rust/commit/34886ed488f6cc18c3fdc20cdeccab6178e00c0f"}], "stats": {"total": 400, "additions": 208, "deletions": 192}, "files": [{"sha": "b921fbf5a28bbe56a52e2f910445b8ac1175e5cc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -531,7 +531,7 @@ type ty_field_ = {ident: ident, mt: mt};\n type ty_field = spanned<ty_field_>;\n \n #[auto_serialize]\n-type ty_method = {ident: ident, attrs: ~[attribute],\n+type ty_method = {ident: ident, attrs: ~[attribute], purity: purity,\n                   decl: fn_decl, tps: ~[ty_param], self_ty: self_ty,\n                   id: node_id, span: span};\n \n@@ -582,7 +582,7 @@ enum ty_ {\n     ty_ptr(mt),\n     ty_rptr(@region, mt),\n     ty_rec(~[ty_field]),\n-    ty_fn(proto, @~[ty_param_bound], fn_decl),\n+    ty_fn(proto, purity, @~[ty_param_bound], fn_decl),\n     ty_tup(~[@ty]),\n     ty_path(@path, node_id),\n     ty_fixed_length(@ty, option<uint>),\n@@ -600,7 +600,6 @@ type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n type fn_decl =\n     {inputs: ~[arg],\n      output: @ty,\n-     purity: purity,\n      cf: ret_style};\n \n #[auto_serialize]\n@@ -633,7 +632,8 @@ type self_ty = spanned<self_ty_>;\n \n #[auto_serialize]\n type method = {ident: ident, attrs: ~[attribute],\n-               tps: ~[ty_param], self_ty: self_ty, decl: fn_decl, body: blk,\n+               tps: ~[ty_param], self_ty: self_ty,\n+               purity: purity, decl: fn_decl, body: blk,\n                id: node_id, span: span, self_id: node_id,\n                vis: visibility};  // always public, unless it's a\n                                   // class method\n@@ -775,7 +775,7 @@ type item = {ident: ident, attrs: ~[attribute],\n #[auto_serialize]\n enum item_ {\n     item_const(@ty, @expr),\n-    item_fn(fn_decl, ~[ty_param], blk),\n+    item_fn(fn_decl, purity, ~[ty_param], blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n     item_ty(@ty, ~[ty_param]),\n@@ -821,7 +821,7 @@ type foreign_item =\n \n #[auto_serialize]\n enum foreign_item_ {\n-    foreign_item_fn(fn_decl, ~[ty_param]),\n+    foreign_item_fn(fn_decl, purity, ~[ty_param]),\n }\n \n // The data we save and restore about an inlined item or method.  This is not"}, {"sha": "9ea9cf000f9563fa33c60cf1cb777e2636297d09", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -311,7 +311,8 @@ fn trait_method_to_ty_method(method: trait_method) -> ty_method {\n       required(m) => m,\n       provided(m) => {\n         {ident: m.ident, attrs: m.attrs,\n-         decl: m.decl, tps: m.tps, self_ty: m.self_ty,\n+         purity: m.purity, decl: m.decl,\n+         tps: m.tps, self_ty: m.self_ty,\n          id: m.id, span: m.span}\n       }\n     }\n@@ -411,7 +412,7 @@ fn dtor_dec() -> fn_decl {\n     {inputs: ~[{mode: ast::expl(ast::by_ref),\n                 ty: nil_t, ident: parse::token::special_idents::underscore,\n                 id: 0}],\n-     output: nil_t, purity: impure_fn, cf: return_val}\n+     output: nil_t, cf: return_val}\n }\n \n // ______________________________________________________________________\n@@ -515,7 +516,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n                 vfn(self_id);\n                 vfn(parent_id.node);\n               }\n-              visit::fk_item_fn(_, tps) => {\n+              visit::fk_item_fn(_, tps, _) => {\n                 vec::iter(tps, |tp| vfn(tp.id));\n               }\n               visit::fk_method(_, tps, m) => {"}, {"sha": "beb255d2cb6909cd8ca0756310e0687171cb8e0b", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -191,10 +191,10 @@ impl ext_ctxt: ext_ctxt_helpers {\n \n         @{id: self.next_id(),\n           node: ast::ty_fn(ast::proto_block,\n+                           ast::impure_fn,\n                            @~[],\n                            {inputs: args,\n                             output: output,\n-                            purity: ast::impure_fn,\n                             cf: ast::return_val}),\n           span: span}\n     }\n@@ -604,8 +604,8 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: ser_inputs,\n                           output: ser_output,\n-                          purity: ast::impure_fn,\n                           cf: ast::return_val},\n+                         ast::impure_fn,\n                          ser_tps,\n                          ser_blk),\n       vis: ast::public,\n@@ -810,8 +810,8 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: deser_inputs,\n                           output: v_ty,\n-                          purity: ast::impure_fn,\n                           cf: ast::return_val},\n+                         ast::impure_fn,\n                          deser_tps,\n                          deser_blk),\n       vis: ast::public,"}, {"sha": "8b134239fc14c009551b7651d59769733511dab3", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -203,7 +203,6 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n                output: @ast::ty) -> ast::fn_decl {\n         {inputs: inputs,\n          output: output,\n-         purity: ast::impure_fn,\n          cf: ast::return_val}\n     }\n \n@@ -226,6 +225,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n         self.item(name,\n                   self.empty_span(),\n                   ast::item_fn(self.fn_decl(inputs, output),\n+                               ast::impure_fn,\n                                ty_params,\n                                body))\n     }"}, {"sha": "3c06edb443b7c591ff5cf311aababa664dade092", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -127,7 +127,6 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n     return {inputs: vec::map(decl.inputs, |x| fold_arg_(x, fld) ),\n          output: fld.fold_ty(decl.output),\n-         purity: decl.purity,\n          cf: decl.cf}\n }\n \n@@ -190,12 +189,12 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n           attrs: vec::map(ni.attrs, fold_attribute),\n           node:\n               match ni.node {\n-                foreign_item_fn(fdec, typms) => {\n+                foreign_item_fn(fdec, purity, typms) => {\n                   foreign_item_fn({inputs: vec::map(fdec.inputs, fold_arg),\n-                                  output: fld.fold_ty(fdec.output),\n-                                  purity: fdec.purity,\n-                                  cf: fdec.cf},\n-                                 fold_ty_params(typms, fld))\n+                                   output: fld.fold_ty(fdec.output),\n+                                   cf: fdec.cf},\n+                                  purity,\n+                                  fold_ty_params(typms, fld))\n                 }\n               },\n           id: fld.new_id(ni.id),\n@@ -224,8 +223,9 @@ fn noop_fold_struct_field(&&sf: @struct_field, fld: ast_fold)\n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n     return match i {\n           item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n-          item_fn(decl, typms, body) => {\n+          item_fn(decl, purity, typms, body) => {\n               item_fn(fold_fn_decl(decl, fld),\n+                      purity,\n                       fold_ty_params(typms, fld),\n                       fld.fold_block(body))\n           }\n@@ -314,6 +314,7 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n           attrs: /* FIXME (#2543) */ copy m.attrs,\n           tps: fold_ty_params(m.tps, fld),\n           self_ty: m.self_ty,\n+          purity: m.purity,\n           decl: fold_fn_decl(m.decl, fld),\n           body: fld.fold_block(m.body),\n           id: fld.new_id(m.id),\n@@ -531,10 +532,11 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_ptr(mt) => ty_ptr(fold_mt(mt, fld)),\n       ty_rptr(region, mt) => ty_rptr(region, fold_mt(mt, fld)),\n       ty_rec(fields) => ty_rec(vec::map(fields, |f| fold_field(f, fld))),\n-      ty_fn(proto, bounds, decl) =>\n-        ty_fn(proto, @vec::map(*bounds,\n-                               |x| fold_ty_param_bound(x, fld)),\n-                               fold_fn_decl(decl, fld)),\n+      ty_fn(proto, purity, bounds, decl) =>\n+        ty_fn(proto, purity,\n+              @vec::map(*bounds,\n+                        |x| fold_ty_param_bound(x, fld)),\n+              fold_fn_decl(decl, fld)),\n       ty_tup(tys) => ty_tup(vec::map(tys, |ty| fld.fold_ty(ty))),\n       ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n       ty_fixed_length(t, vs) => ty_fixed_length(fld.fold_ty(t), vs),"}, {"sha": "ff06c14c4fbf5b85e3e4d15870c5dea4a0a8dad8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -285,10 +285,10 @@ struct parser {\n             proto = self.parse_fn_ty_proto();\n             bounds = self.parse_optional_ty_param_bounds();\n         };\n-        ty_fn(proto, bounds, self.parse_ty_fn_decl(purity))\n+        ty_fn(proto, purity, bounds, self.parse_ty_fn_decl())\n     }\n \n-    fn parse_ty_fn_decl(purity: ast::purity) -> fn_decl {\n+    fn parse_ty_fn_decl() -> fn_decl {\n         let inputs = do self.parse_unspanned_seq(\n             token::LPAREN, token::RPAREN,\n             seq_sep_trailing_disallowed(token::COMMA)) |p| {\n@@ -297,7 +297,7 @@ struct parser {\n         };\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         return {inputs: inputs, output: ret_ty,\n-             purity: purity, cf: ret_style};\n+                cf: ret_style};\n     }\n \n     fn parse_trait_methods() -> ~[trait_method] {\n@@ -316,7 +316,7 @@ struct parser {\n \n             let tps = p.parse_ty_params();\n \n-            let (self_ty, d, _) = do self.parse_fn_decl_with_self(pur) |p| {\n+            let (self_ty, d, _) = do self.parse_fn_decl_with_self() |p| {\n                 // This is somewhat dubious; We don't want to allow argument\n                 // names to be left off if there is a definition...\n                 either::Left(p.parse_arg_general(false))\n@@ -335,7 +335,7 @@ struct parser {\n                 // NB: at the moment, visibility annotations on required\n                 // methods are ignored; this could change.\n                 required({ident: ident, attrs: attrs,\n-                          decl: {purity: pur with d}, tps: tps,\n+                          purity: pur, decl: d, tps: tps,\n                           self_ty: self_ty,\n                           id: p.get_id(), span: mk_sp(lo, hi)})\n               }\n@@ -348,6 +348,7 @@ struct parser {\n                            attrs: attrs,\n                            tps: tps,\n                            self_ty: self_ty,\n+                           purity: pur,\n                            decl: d,\n                            body: body,\n                            id: p.get_id(),\n@@ -518,7 +519,7 @@ struct parser {\n             self.parse_ty_fn(ast::impure_fn)\n         } else if self.eat_keyword(~\"extern\") {\n             self.expect_keyword(~\"fn\");\n-            ty_fn(proto_bare, @~[], self.parse_ty_fn_decl(ast::impure_fn))\n+            ty_fn(proto_bare, ast::impure_fn, @~[], self.parse_ty_fn_decl())\n         } else if self.token == token::MOD_SEP || is_ident(self.token) {\n             let path = self.parse_path_with_tps(colons_before_params);\n             ty_path(path, self.get_id())\n@@ -1492,8 +1493,7 @@ struct parser {\n         // if we want to allow fn expression argument types to be inferred in\n         // the future, just have to change parse_arg to parse_fn_block_arg.\n         let (decl, capture_clause) =\n-            self.parse_fn_decl(impure_fn,\n-                               |p| p.parse_arg_or_capture_item());\n+            self.parse_fn_decl(|p| p.parse_arg_or_capture_item());\n \n         let body = self.parse_block();\n         return self.mk_expr(lo, body.span.hi,\n@@ -1518,7 +1518,6 @@ struct parser {\n                                 node: ty_infer,\n                                 span: self.span\n                             },\n-                            purity: impure_fn,\n                             cf: return_val\n                         }\n                     },\n@@ -2281,8 +2280,7 @@ struct parser {\n         } else { ~[] }\n     }\n \n-    fn parse_fn_decl(purity: purity,\n-                     parse_arg_fn: fn(parser) -> arg_or_capture_item)\n+    fn parse_fn_decl(parse_arg_fn: fn(parser) -> arg_or_capture_item)\n         -> (fn_decl, capture_clause) {\n \n         let args_or_capture_items: ~[arg_or_capture_item] =\n@@ -2295,9 +2293,8 @@ struct parser {\n \n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         return ({inputs: inputs,\n-              output: ret_ty,\n-              purity: purity,\n-              cf: ret_style}, capture_clause);\n+                 output: ret_ty,\n+                 cf: ret_style}, capture_clause);\n     }\n \n     fn is_self_ident() -> bool {\n@@ -2316,8 +2313,7 @@ struct parser {\n         self.bump();\n     }\n \n-    fn parse_fn_decl_with_self(purity: purity,\n-                               parse_arg_fn:\n+    fn parse_fn_decl_with_self(parse_arg_fn:\n                                     fn(parser) -> arg_or_capture_item)\n                             -> (self_ty, fn_decl, capture_clause) {\n \n@@ -2401,7 +2397,6 @@ struct parser {\n         let fn_decl = {\n             inputs: inputs,\n             output: ret_ty,\n-            purity: purity,\n             cf: ret_style\n         };\n \n@@ -2425,10 +2420,9 @@ struct parser {\n             @{id: self.get_id(), node: ty_infer, span: self.span}\n         };\n         return ({inputs: either::lefts(inputs_captures),\n-              output: output,\n-              purity: impure_fn,\n-              cf: return_val},\n-             @either::rights(inputs_captures));\n+                 output: output,\n+                 cf: return_val},\n+                @either::rights(inputs_captures));\n     }\n \n     fn parse_fn_header() -> {ident: ident, tps: ~[ty_param]} {\n@@ -2450,9 +2444,9 @@ struct parser {\n \n     fn parse_item_fn(purity: purity) -> item_info {\n         let t = self.parse_fn_header();\n-        let (decl, _) = self.parse_fn_decl(purity, |p| p.parse_arg());\n+        let (decl, _) = self.parse_fn_decl(|p| p.parse_arg());\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n-        (t.ident, item_fn(decl, t.tps, body), some(inner_attrs))\n+        (t.ident, item_fn(decl, purity, t.tps, body), some(inner_attrs))\n     }\n \n     fn parse_method_name() -> ident {\n@@ -2469,7 +2463,7 @@ struct parser {\n         let pur = self.parse_fn_purity();\n         let ident = self.parse_method_name();\n         let tps = self.parse_ty_params();\n-        let (self_ty, decl, _) = do self.parse_fn_decl_with_self(pur) |p| {\n+        let (self_ty, decl, _) = do self.parse_fn_decl_with_self() |p| {\n             p.parse_arg()\n         };\n         // XXX: interaction between staticness, self_ty is broken now\n@@ -2478,7 +2472,7 @@ struct parser {\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n         let attrs = vec::append(attrs, inner_attrs);\n         @{ident: ident, attrs: attrs,\n-          tps: tps, self_ty: self_ty, decl: decl,\n+          tps: tps, self_ty: self_ty, purity: pur, decl: decl,\n           body: body, id: self.get_id(), span: mk_sp(lo, body.span.hi),\n           self_id: self.get_id(), vis: pr}\n     }\n@@ -2717,7 +2711,7 @@ struct parser {\n     fn parse_ctor(attrs: ~[attribute],\n                   result_ty: ast::ty_) -> class_contents {\n         let lo = self.last_span.lo;\n-        let (decl_, _) = self.parse_fn_decl(impure_fn, |p| p.parse_arg());\n+        let (decl_, _) = self.parse_fn_decl(|p| p.parse_arg());\n         let decl = {output: @{id: self.get_id(),\n                               node: result_ty, span: decl_.output.span}\n                     with decl_};\n@@ -2837,18 +2831,18 @@ struct parser {\n         (id, item_mod(m), some(inner_attrs.inner))\n     }\n \n-    fn parse_item_foreign_fn(+attrs: ~[attribute],\n-                             purity: purity) -> @foreign_item {\n-        let lo = self.last_span.lo;\n+    fn parse_item_foreign_fn(+attrs: ~[attribute]) -> @foreign_item {\n+        let lo = self.span.lo;\n+        let purity = self.parse_fn_purity();\n         let t = self.parse_fn_header();\n-        let (decl, _) = self.parse_fn_decl(purity, |p| p.parse_arg());\n+        let (decl, _) = self.parse_fn_decl(|p| p.parse_arg());\n         let mut hi = self.span.hi;\n         self.expect(token::SEMI);\n         return @{ident: t.ident,\n-              attrs: attrs,\n-              node: foreign_item_fn(decl, t.tps),\n-              id: self.get_id(),\n-              span: mk_sp(lo, hi)};\n+                 attrs: attrs,\n+                 node: foreign_item_fn(decl, purity, t.tps),\n+                 id: self.get_id(),\n+                 span: mk_sp(lo, hi)};\n     }\n \n     fn parse_fn_purity() -> purity {\n@@ -2865,7 +2859,7 @@ struct parser {\n \n     fn parse_foreign_item(+attrs: ~[attribute]) ->\n         @foreign_item {\n-        self.parse_item_foreign_fn(attrs, self.parse_fn_purity())\n+        self.parse_item_foreign_fn(attrs)\n     }\n \n     fn parse_foreign_mod_items(+first_item_attrs: ~[attribute]) ->"}, {"sha": "53458fd875673e094648ebe31b3cb62023a9f6c1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -129,7 +129,7 @@ fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n               params: ~[ast::ty_param], intr: ident_interner) -> ~str {\n     let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer), intr);\n-    print_fn(s, decl, name, params, none);\n+    print_fn(s, decl, none, name, params, none);\n     end(s); // Close the head box\n     end(s); // Close the outer box\n     eof(s.s);\n@@ -390,8 +390,8 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n         commasep(s, inconsistent, elts, print_type);\n         pclose(s);\n       }\n-      ast::ty_fn(proto, bounds, d) => {\n-        print_ty_fn(s, some(proto), bounds, d, none, none, none);\n+      ast::ty_fn(proto, purity, bounds, d) => {\n+        print_ty_fn(s, some(proto), purity, bounds, d, none, none, none);\n       }\n       ast::ty_path(path, _) => print_path(s, path, print_colons),\n       ast::ty_fixed_length(t, v) => {\n@@ -415,8 +415,8 @@ fn print_foreign_item(s: ps, item: @ast::foreign_item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     match item.node {\n-      ast::foreign_item_fn(decl, typarams) => {\n-        print_fn(s, decl, item.ident, typarams, none);\n+      ast::foreign_item_fn(decl, purity, typarams) => {\n+        print_fn(s, decl, some(purity), item.ident, typarams, none);\n         end(s); // end head-ibox\n         word(s.s, ~\";\");\n         end(s); // end the outer fn box\n@@ -445,8 +445,8 @@ fn print_item(s: ps, &&item: @ast::item) {\n         end(s); // end the outer cbox\n \n       }\n-      ast::item_fn(decl, typarams, body) => {\n-        print_fn(s, decl, item.ident, typarams, none);\n+      ast::item_fn(decl, purity, typarams, body) => {\n+        print_fn(s, decl, some(purity), item.ident, typarams, none);\n         word(s.s, ~\" \");\n         print_block_with_attrs(s, body, item.attrs);\n       }\n@@ -722,7 +722,8 @@ fn print_ty_method(s: ps, m: ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n-    print_ty_fn(s, none, @~[], m.decl, some(m.ident), some(m.tps),\n+    print_ty_fn(s, none, m.purity,\n+                @~[], m.decl, some(m.ident), some(m.tps),\n                 some(m.self_ty.node));\n     word(s.s, ~\";\");\n }\n@@ -738,7 +739,8 @@ fn print_method(s: ps, meth: @ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n-    print_fn(s, meth.decl, meth.ident, meth.tps, some(meth.self_ty.node));\n+    print_fn(s, meth.decl, some(meth.purity),\n+             meth.ident, meth.tps, some(meth.self_ty.node));\n     word(s.s, ~\" \");\n     print_block_with_attrs(s, meth.body, meth.attrs);\n }\n@@ -1188,7 +1190,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n-        word(s.s, fn_header_info_to_str(none, decl.purity, some(proto)));\n+        word(s.s, fn_header_info_to_str(none, none, some(proto)));\n         print_fn_args_and_ret(s, decl, *cap_clause, none);\n         space(s.s);\n         print_block(s, body);\n@@ -1542,10 +1544,11 @@ fn print_self_ty(s: ps, self_ty: ast::self_ty_) -> bool {\n     return true;\n }\n \n-fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n+fn print_fn(s: ps, decl: ast::fn_decl, purity: option<ast::purity>,\n+            name: ast::ident,\n             typarams: ~[ast::ty_param],\n             opt_self_ty: option<ast::self_ty_>) {\n-    head(s, fn_header_info_to_str(opt_self_ty, decl.purity, none));\n+    head(s, fn_header_info_to_str(opt_self_ty, purity, none));\n     print_ident(s, name);\n     print_type_params(s, typarams);\n     print_fn_args_and_ret(s, decl, ~[], opt_self_ty);\n@@ -1767,13 +1770,13 @@ fn print_arg(s: ps, input: ast::arg) {\n     end(s);\n }\n \n-fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n+fn print_ty_fn(s: ps, opt_proto: option<ast::proto>, purity: ast::purity,\n                bounds: @~[ast::ty_param_bound],\n                decl: ast::fn_decl, id: option<ast::ident>,\n                tps: option<~[ast::ty_param]>,\n                opt_self_ty: option<ast::self_ty_>) {\n     ibox(s, indent_unit);\n-    word(s.s, fn_header_info_to_str(opt_self_ty, decl.purity, opt_proto));\n+    word(s.s, fn_header_info_to_str(opt_self_ty, some(purity), opt_proto));\n     print_bounds(s, bounds);\n     match id { some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n     match tps { some(tps) => print_type_params(s, tps), _ => () }\n@@ -1990,19 +1993,20 @@ fn next_comment(s: ps) -> option<comments::cmnt> {\n }\n \n fn fn_header_info_to_str(opt_sty: option<ast::self_ty_>,\n-                         purity: ast::purity,\n+                         opt_purity: option<ast::purity>,\n                          opt_p: option<ast::proto>) -> ~str {\n     let mut s = match opt_sty {\n       some(ast::sty_static) => ~\"static \",\n       _ => ~ \"\"\n     };\n \n-    match purity {\n-      ast::impure_fn => { }\n-      _ => {\n+    match opt_purity {\n+      some(ast::impure_fn) => { }\n+      some(purity) => {\n         str::push_str(s, purity_to_str(purity));\n         str::push_char(s, ' ');\n       }\n+      none => {}\n     }\n \n     str::push_str(s, opt_proto_to_str(opt_p));"}, {"sha": "a5f86dee1cc085dabb10898fcaff7c044f99fae6", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -13,7 +13,7 @@ import codemap::span;\n enum vt<E> { mk_vt(visitor<E>), }\n \n enum fn_kind {\n-    fk_item_fn(ident, ~[ty_param]), //< an item declared with fn()\n+    fk_item_fn(ident, ~[ty_param], purity), //< an item declared with fn()\n     fk_method(ident, ~[ty_param], @method),\n     fk_anon(proto, capture_clause),  //< an anonymous function like fn@(...)\n     fk_fn_block(capture_clause),     //< a block {||...}\n@@ -26,7 +26,7 @@ enum fn_kind {\n \n fn name_of_fn(fk: fn_kind) -> ident {\n     match fk {\n-      fk_item_fn(name, _) | fk_method(name, _, _)\n+      fk_item_fn(name, _, _) | fk_method(name, _, _)\n           | fk_ctor(name, _, _, _, _) =>  /* FIXME (#2543) */ copy name,\n       fk_anon(*) | fk_fn_block(*) => parse::token::special_idents::anon,\n       fk_dtor(*)                  => parse::token::special_idents::dtor\n@@ -35,7 +35,7 @@ fn name_of_fn(fk: fn_kind) -> ident {\n \n fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n     match fk {\n-      fk_item_fn(_, tps) | fk_method(_, tps, _)\n+      fk_item_fn(_, tps, _) | fk_method(_, tps, _)\n           | fk_ctor(_, _, tps, _, _) | fk_dtor(tps, _, _, _) => {\n           /* FIXME (#2543) */ copy tps\n       }\n@@ -124,9 +124,10 @@ fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     match i.node {\n       item_const(t, ex) => { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n-      item_fn(decl, tp, body) => {\n+      item_fn(decl, purity, tp, body) => {\n         v.visit_fn(fk_item_fn(/* FIXME (#2543) */ copy i.ident,\n-                              /* FIXME (#2543) */ copy tp), decl, body,\n+                              /* FIXME (#2543) */ copy tp,\n+                              purity), decl, body,\n                    i.span, i.id, e, v);\n       }\n       item_mod(m) => v.visit_mod(m, i.span, i.id, e, v),\n@@ -199,7 +200,7 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n       ty_tup(ts) => for ts.each |tt| {\n         v.visit_ty(tt, e, v);\n       },\n-      ty_fn(_, bounds, decl) => {\n+      ty_fn(_, _, bounds, decl) => {\n         for decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n         visit_ty_param_bounds(bounds, e, v);\n         v.visit_ty(decl.output, e, v);\n@@ -249,7 +250,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n \n fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n     match ni.node {\n-      foreign_item_fn(fd, tps) => {\n+      foreign_item_fn(fd, purity, tps) => {\n         v.visit_ty_params(tps, e, v);\n         visit_fn_decl(fd, e, v);\n       }"}, {"sha": "d2abe360f674d0e9b3094a31fff480fdf8d53adc", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -71,7 +71,7 @@ fn fold_mod(cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     // indicate to the translation pass which function we want to be main.\n     fn nomain(cx: test_ctxt, item: @ast::item) -> option<@ast::item> {\n         match item.node {\n-          ast::item_fn(_, _, _) => {\n+          ast::item_fn(*) => {\n             if item.ident == cx.sess.ident_of(~\"main\") {\n                 option::none\n             } else { option::some(item) }\n@@ -105,7 +105,7 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n \n     if is_test_fn(i) {\n         match i.node {\n-          ast::item_fn(decl, _, _) if decl.purity == ast::unsafe_fn => {\n+          ast::item_fn(decl, purity, _, _) if purity == ast::unsafe_fn => {\n             cx.sess.span_fatal(\n                 i.span,\n                 ~\"unsafe functions cannot be used for tests\");\n@@ -132,7 +132,7 @@ fn is_test_fn(i: @ast::item) -> bool {\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         match i.node {\n-          ast::item_fn(decl, tps, _) => {\n+          ast::item_fn(decl, _, tps, _) => {\n             let input_cnt = vec::len(decl.inputs);\n             let no_output = decl.output.node == ast::ty_nil;\n             let tparm_cnt = vec::len(tps);\n@@ -223,7 +223,6 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let decl: ast::fn_decl =\n         {inputs: ~[],\n          output: ret_ty,\n-         purity: ast::impure_fn,\n          cf: ast::return_val};\n \n     // The vector of test_descs for this crate\n@@ -233,7 +232,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n         default_block(~[], option::some(test_descs), cx.sess.next_node_id());\n     let body = nospan(body_);\n \n-    let item_ = ast::item_fn(decl, ~[], body);\n+    let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n     let item: ast::item =\n         {ident: cx.sess.ident_of(~\"tests\"),\n          attrs: ~[],\n@@ -389,7 +388,6 @@ fn mk_test_wrapper(cx: test_ctxt,\n     let wrapper_decl: ast::fn_decl = {\n         inputs: ~[],\n         output: @{id: cx.sess.next_node_id(), node: ast::ty_nil, span: span},\n-        purity: ast::impure_fn,\n         cf: ast::return_val\n     };\n \n@@ -442,7 +440,6 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let decl: ast::fn_decl =\n         {inputs: ~[args_arg],\n          output: @ret_ty,\n-         purity: ast::impure_fn,\n          cf: ast::return_val};\n \n     let test_main_call_expr = mk_test_main_call(cx);\n@@ -452,7 +449,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n                       cx.sess.next_node_id());\n     let body = {node: body_, span: dummy_sp()};\n \n-    let item_ = ast::item_fn(decl, ~[], body);\n+    let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n     let item: ast::item =\n         {ident: cx.sess.ident_of(~\"main\"),\n          attrs: ~[],"}, {"sha": "05457a710eae1826910a67a8827be63c91c835db", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -695,13 +695,8 @@ fn get_trait_methods(intr: ident_interner, cdata: cmd, id: ast::node_id,\n         } };\n         let self_ty = get_self_ty(mth);\n         vec::push(result, {ident: name, tps: bounds, fty: fty,\n-                    self_ty: self_ty,\n-                    purity: match item_family(mth) {\n-                      UnsafeFn => ast::unsafe_fn,\n-                      Fn => ast::impure_fn,\n-                      PureFn => ast::pure_fn,\n-                      _ => fail ~\"bad purity\"\n-                    }, vis: ast::public});\n+                           self_ty: self_ty,\n+                           vis: ast::public});\n     }\n     #debug(\"get_trait_methods: }\");\n     @result"}, {"sha": "66d74c377ca4b783ff14052cc664e6257a8db2db", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -414,14 +414,14 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     *index\n }\n \n-fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n-                      id: node_id, ident: ident, path: ast_map::path,\n-                      item: option<inlined_item>, tps: ~[ty_param],\n-                      decl: fn_decl) {\n+// This is for encoding info for ctors and dtors\n+fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                        id: node_id, ident: ident, path: ast_map::path,\n+                        item: option<inlined_item>, tps: ~[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n         encode_name(ecx, ebml_w, ident);\n         encode_def_id(ebml_w, local_def(id));\n-        encode_family(ebml_w, purity_fn_family(decl.purity));\n+        encode_family(ebml_w, purity_fn_family(ast::impure_fn));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n         debug!(\"fn name = %s ty = %s its node id = %d\",\n@@ -448,7 +448,7 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n            ecx.tcx.sess.str_of(m.ident), all_tps.len());\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n-    encode_family(ebml_w, purity_fn_family(m.decl.purity));\n+    encode_family(ebml_w, purity_fn_family(m.purity));\n     encode_type_param_bounds(ebml_w, ecx, all_tps);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n     encode_name(ecx, ebml_w, m.ident);\n@@ -519,11 +519,11 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n-      item_fn(decl, tps, _) => {\n+      item_fn(decl, purity, tps, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, purity_fn_family(decl.purity));\n+        encode_family(ebml_w, purity_fn_family(purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n@@ -588,13 +588,14 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         /* Encode the dtor */\n         do option::iter(struct_def.dtor) |dtor| {\n             vec::push(*index, {val: dtor.node.id, pos: ebml_w.writer.tell()});\n-          encode_info_for_fn(ecx, ebml_w, dtor.node.id,\n-                             ecx.tcx.sess.ident_of(\n-                                 ecx.tcx.sess.str_of(item.ident) + ~\"_dtor\"),\n-                             path, if tps.len() > 0u {\n-                                 some(ii_dtor(dtor, item.ident, tps,\n-                                              local_def(item.id))) }\n-                             else { none }, tps, ast_util::dtor_dec());\n+          encode_info_for_ctor(ecx, ebml_w, dtor.node.id,\n+                               ecx.tcx.sess.ident_of(\n+                                   ecx.tcx.sess.str_of(item.ident) +\n+                                   ~\"_dtor\"),\n+                               path, if tps.len() > 0u {\n+                                   some(ii_dtor(dtor, item.ident, tps,\n+                                                local_def(item.id))) }\n+                               else { none }, tps);\n         }\n \n         /* Index the class*/\n@@ -647,7 +648,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                 /* Write the info that's needed when viewing this class\n                    as a trait */\n                 ebml_w.start_tag(tag_item_trait_method);\n-                encode_family(ebml_w, purity_fn_family(m.decl.purity));\n+                encode_family(ebml_w, purity_fn_family(m.purity));\n                 encode_name(ecx, ebml_w, m.ident);\n                 encode_type_param_bounds(ebml_w, ecx, m.tps);\n                 encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n@@ -675,11 +676,11 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                 val: ctor.node.id,\n                 pos: ebml_w.writer.tell()\n             });\n-            encode_info_for_fn(ecx, ebml_w, ctor.node.id, item.ident,\n-                               path, if tps.len() > 0u {\n-                                   some(ii_ctor(ctor, item.ident, tps,\n-                                                local_def(item.id))) }\n-                               else { none }, tps, ctor.node.dec);\n+            encode_info_for_ctor(ecx, ebml_w, ctor.node.id, item.ident,\n+                                 path, if tps.len() > 0u {\n+                                     some(ii_ctor(ctor, item.ident, tps,\n+                                                  local_def(item.id))) }\n+                                 else { none }, tps);\n         }\n       }\n       item_impl(tps, traits, _, methods) => {\n@@ -734,7 +735,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                 encode_name(ecx, ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx, ty_m.tps);\n                 encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n-                encode_family(ebml_w, purity_fn_family(mty.purity));\n+                encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 ebml_w.end_tag();\n               }\n@@ -766,7 +767,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_def_id(ebml_w, local_def(ty_m.id));\n             encode_name(ecx, ebml_w, ty_m.ident);\n             encode_family(ebml_w,\n-                          purity_static_method_family(ty_m.decl.purity));\n+                          purity_static_method_family(ty_m.purity));\n             let polyty = ecx.tcx.tcache.get(local_def(ty_m.id));\n             encode_ty_type_param_bounds(ebml_w, ecx, polyty.bounds);\n             encode_type(ecx, ebml_w, polyty.ty);\n@@ -789,9 +790,9 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n \n     ebml_w.start_tag(tag_items_data_item);\n     match nitem.node {\n-      foreign_item_fn(fn_decl, tps) => {\n+      foreign_item_fn(fn_decl, purity, tps) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n-        encode_family(ebml_w, purity_fn_family(fn_decl.purity));\n+        encode_family(ebml_w, purity_fn_family(purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         if abi == foreign_abi_rust_intrinsic {"}, {"sha": "7c18133ae02dda3746a765937668d9dbed845c9c", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -521,6 +521,8 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n         do save_and_restore(self.declared_purity) {\n             do save_and_restore(self.fn_args) {\n                 let is_stack_closure = self.is_stack_closure(id);\n+                let purity =\n+                    ty::ty_fn_purity(ty::node_id_to_type(self.tcx(), id));\n \n                 // In principle, we could consider fk_anon(*) or\n                 // fk_fn_block(*) to be in a ctor, I suppose, but the\n@@ -531,7 +533,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                 match fk {\n                   visit::fk_ctor(*) => {\n                     self.in_ctor = true;\n-                    self.declared_purity = decl.purity;\n+                    self.declared_purity = purity;\n                     self.fn_args = @decl.inputs.map(|i| i.id );\n                   }\n                   visit::fk_anon(*) |\n@@ -543,7 +545,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                   visit::fk_method(*) | visit::fk_item_fn(*) |\n                   visit::fk_dtor(*) => {\n                     self.in_ctor = false;\n-                    self.declared_purity = decl.purity;\n+                    self.declared_purity = purity;\n                     self.fn_args = @decl.inputs.map(|i| i.id );\n                   }\n                 }"}, {"sha": "7b7e163d38c42a34a32ed6cc5ef77209c66f5176", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -401,7 +401,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n       either::Right(ast::foreign_abi_rust_intrinsic) => {\n         for nmod.items.each |ni| {\n             match ni.node {\n-              ast::foreign_item_fn(decl, tps) => {\n+              ast::foreign_item_fn(decl, _, tps) => {\n                 check_foreign_fn(cx, it.id, decl);\n               }\n             }"}, {"sha": "5b6a64ccd73a79a2324957643c5b2336fde118a8", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -613,8 +613,8 @@ fn determine_rp_in_ty(ty: @ast::ty,\n         }\n       }\n \n-      ast::ty_fn(ast::proto_bare, _, _) |\n-      ast::ty_fn(ast::proto_block, _, _) if cx.anon_implies_rp => {\n+      ast::ty_fn(ast::proto_bare, _, _, _) |\n+      ast::ty_fn(ast::proto_block, _, _, _) if cx.anon_implies_rp => {\n         debug!(\"referenced bare fn type with regions %s\",\n                pprust::ty_to_str(ty, cx.sess.intr()));\n         cx.add_rp(cx.item_id, cx.add_variance(rv_contravariant));\n@@ -661,8 +661,8 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     match ty.node {\n       ast::ty_box(mt) | ast::ty_uniq(mt) => {\n         match mt.ty.node {\n-          ast::ty_fn(ast::proto_bare, _, _) |\n-          ast::ty_fn(ast::proto_block, _, _) => {\n+          ast::ty_fn(ast::proto_bare, _, _, _) |\n+          ast::ty_fn(ast::proto_block, _, _, _) => {\n             do cx.with(cx.item_id, false) {\n                 visit_mt(mt, cx, visitor);\n             }\n@@ -695,7 +695,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n         }\n       }\n \n-      ast::ty_fn(_, bounds, decl) => {\n+      ast::ty_fn(_, _, bounds, decl) => {\n         // fn() binds the & region, so do not consider &T types that\n         // appear *inside* a fn() type to affect the enclosing item:\n         do cx.with(cx.item_id, false) {"}, {"sha": "66b7818d88033e849c5ee5b37afe5299fe200618", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -891,11 +891,11 @@ struct Resolver {\n                      def_const(local_def(item.id)),\n                      sp);\n             }\n-            item_fn(decl, _, _) => {\n+            item_fn(decl, purity, _, _) => {\n               let (name_bindings, new_parent) = self.add_child(atom, parent,\n                                                         ~[ValueNS], sp);\n \n-                let def = def_fn(local_def(item.id), decl.purity);\n+                let def = def_fn(local_def(item.id), purity);\n                 (*name_bindings).define_value\n                     (self.visibility_to_privacy(item.vis), def, sp);\n                 visit_item(item, new_parent, visitor);\n@@ -954,7 +954,7 @@ struct Resolver {\n                         (*name_bindings).define_type\n                             (privacy, def_ty(local_def(item.id)), sp);\n \n-                        let purity = ctor.node.dec.purity;\n+                        let purity = impure_fn;\n                         let ctor_def = def_fn(local_def(ctor.node.id),\n                                               purity);\n                         (*name_bindings).define_value(privacy, ctor_def, sp);\n@@ -992,7 +992,7 @@ struct Resolver {\n                             self.add_child(atom, new_parent, ~[ValueNS],\n                                            ty_m.span);\n                         let def = def_static_method(local_def(ty_m.id),\n-                                                    ty_m.decl.purity);\n+                                                    ty_m.purity);\n                         (*method_name_bindings).define_value\n                             (Public, def, ty_m.span);\n                       }\n@@ -1215,11 +1215,11 @@ struct Resolver {\n         let name = foreign_item.ident;\n \n         match foreign_item.node {\n-            foreign_item_fn(fn_decl, type_parameters) => {\n+            foreign_item_fn(fn_decl, purity, type_parameters) => {\n               let (name_bindings, new_parent) = self.add_child(name, parent,\n                                               ~[ValueNS], foreign_item.span);\n \n-                let def = def_fn(local_def(foreign_item.id), fn_decl.purity);\n+                let def = def_fn(local_def(foreign_item.id), purity);\n                 (*name_bindings).define_value(Public, def, foreign_item.span);\n \n                 do self.with_type_parameter_rib\n@@ -2944,7 +2944,7 @@ struct Resolver {\n                 do self.with_scope(some(item.ident)) {\n                     for foreign_module.items.each |foreign_item| {\n                         match foreign_item.node {\n-                            foreign_item_fn(_, type_parameters) => {\n+                            foreign_item_fn(_, _, type_parameters) => {\n                                 do self.with_type_parameter_rib\n                                     (HasTypeParameters(&type_parameters,\n                                                        foreign_item.id,\n@@ -2961,7 +2961,7 @@ struct Resolver {\n                 }\n             }\n \n-            item_fn(fn_decl, ty_params, block) => {\n+            item_fn(fn_decl, _, ty_params, block) => {\n                 // If this is the main function, we must record it in the\n                 // session.\n                 //"}, {"sha": "13988ad8861d7189604ab50610903d15ce0ca1d5", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -2214,7 +2214,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n \n     let psubsts = some({tys: substs, vtables: vtables, bounds: tpt.bounds});\n     let lldecl = match map_node {\n-      ast_map::node_item(i@@{node: ast::item_fn(decl, _, body), _}, _) => {\n+      ast_map::node_item(i@@{node: ast::item_fn(decl, _, _, body), _}, _) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(i.attrs, d);\n         trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node);\n@@ -5010,8 +5010,8 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n       ast_map::node_item(_, p) => p\n     };\n     match item.node {\n-      ast::item_fn(decl, tps, body) => {\n-        if decl.purity == ast::extern_fn  {\n+      ast::item_fn(decl, purity, tps, body) => {\n+        if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_foreign_fn(ccx,\n                                      vec::append(\n@@ -5304,8 +5304,8 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 ccx.item_symbols.insert(i.id, s);\n                 g\n               }\n-              ast::item_fn(decl, _, _) => {\n-                let llfn = if decl.purity != ast::extern_fn {\n+              ast::item_fn(decl, purity, _, _) => {\n+                let llfn = if purity != ast::extern_fn {\n                     register_fn(ccx, i.span, my_path, i.id)\n                 } else {\n                     foreign::register_foreign_fn(ccx, i.span, my_path, i.id)\n@@ -5535,7 +5535,7 @@ fn push_rtcall(ccx: @crate_ctxt, name: ~str, did: ast::def_id) {\n fn gather_local_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n         visit_item: |item| match item.node {\n-          ast::item_fn(decl, _, _) => {\n+          ast::item_fn(decl, _, _, _) => {\n             let attr_metas = attr::attr_metas(\n                 attr::find_attrs_by_name(item.attrs, ~\"rt\"));\n             do vec::iter(attr_metas) |attr_meta| {"}, {"sha": "04e0f7be75fabd8cda4b2ae702b8a5b76acde298", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -721,7 +721,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let (ident, ret_ty, id) = match cx.tcx.items.get(fcx.id) {\n       ast_map::node_item(item, _) => {\n         match item.node {\n-          ast::item_fn(decl, _, _) => {\n+          ast::item_fn(decl, _, _, _) => {\n             (item.ident, decl.output, item.id)\n           }\n           _ => fcx.ccx.sess.span_bug(item.span, ~\"create_function: item \\"}, {"sha": "efcdc64410454fb0e3f8904dc95ba9cd7ee993e4", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -755,7 +755,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n \n     for vec::each(foreign_mod.items) |foreign_item| {\n       match foreign_item.node {\n-        ast::foreign_item_fn(fn_decl, typarams) => {\n+        ast::foreign_item_fn(fn_decl, purity, typarams) => {\n           let id = foreign_item.id;\n           if abi != ast::foreign_abi_rust_intrinsic {\n               let llwrapfn = get_item_val(ccx, id);"}, {"sha": "48ab856342a22c3cc295efd1d9c278b80d9ce6d0", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -96,7 +96,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n               for vec::each(nm.items) |item| { cx.rmap.insert(item.id, ()); }\n           }\n       }\n-      item_fn(_, tps, blk) => {\n+      item_fn(_, _, tps, blk) => {\n         if tps.len() > 0u ||\n            attr::find_inline_attr(item.attrs) != attr::ia_none {\n             traverse_inline_body(cx, blk);"}, {"sha": "2b527bb96828e2d68cea9ad0fdda6f1ad1b40e36", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -65,7 +65,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n                                      fn_id_loc))\n     };\n     match map_node {\n-      ast_map::node_item(@{node: item_fn(_, _, body), _}, _) |\n+      ast_map::node_item(@{node: item_fn(_, _, _, body), _}, _) |\n       ast_map::node_method(@{body, _}, _, _) => {\n         handle_body(cx, body);\n       }\n@@ -78,7 +78,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       ast_map::node_variant(_, _, _) => {\n         for uint::range(0u, n_tps) |n| { cx.uses[n] |= use_repr;}\n       }\n-      ast_map::node_foreign_item(i@@{node: foreign_item_fn(_, _), _},\n+      ast_map::node_foreign_item(i@@{node: foreign_item_fn(*), _},\n                                  abi, _) => {\n         if abi == foreign_abi_rust_intrinsic {\n             let flags = match cx.ccx.sess.str_of(i.ident) {"}, {"sha": "b5411dd597c814e6e6fb340a05a2f75ecfb4368e", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -79,7 +79,7 @@ export ty_opaque_closure_ptr, mk_opaque_closure_ptr;\n export ty_opaque_box, mk_opaque_box;\n export ty_float, mk_float, mk_mach_float, type_is_fp;\n export ty_fn, fn_ty, mk_fn;\n-export ty_fn_proto, ty_fn_ret, ty_fn_ret_style, tys_in_fn_ty;\n+export ty_fn_proto, ty_fn_purity, ty_fn_ret, ty_fn_ret_style, tys_in_fn_ty;\n export ty_int, mk_int, mk_mach_int, mk_char;\n export mk_i8, mk_u8, mk_i16, mk_u16, mk_i32, mk_u32, mk_i64, mk_u64;\n export ty_estr, mk_estr, type_is_str;\n@@ -202,7 +202,6 @@ type method = {ident: ast::ident,\n                tps: @~[param_bounds],\n                fty: fn_ty,\n                self_ty: ast::self_ty_,\n-               purity: ast::purity,\n                vis: ast::visibility};\n \n type mt = {ty: t, mutbl: ast::mutability};\n@@ -2358,6 +2357,13 @@ fn ty_fn_proto(fty: t) -> fn_proto {\n     }\n }\n \n+fn ty_fn_purity(fty: t) -> ast::purity {\n+    match get(fty).struct {\n+      ty_fn(ref f) => f.purity,\n+      _ => fail ~\"ty_fn_purity() called on non-fn type\"\n+    }\n+}\n+\n pure fn ty_fn_ret(fty: t) -> t {\n     match get(fty).struct {\n       ty_fn(ref f) => f.output,"}, {"sha": "d4ed45f99b3b724c25596713c7acc27671485f5e", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -259,7 +259,7 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n         match tcx.items.find(main_id) {\n          some(ast_map::node_item(it,_)) => {\n              match it.node {\n-               ast::item_fn(_,ps,_) if vec::is_not_empty(ps) => {\n+               ast::item_fn(_,_,ps,_) if vec::is_not_empty(ps) => {\n                   tcx.sess.span_err(main_span,\n                     ~\"main function is not allowed to have type parameters\");\n                   return;"}, {"sha": "374e14749f245638b6508bbde73df23be5855db4", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -201,7 +201,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n               _ => ()\n             }\n           }\n-          ast::ty_fn(ast::proto_block, ast_bounds, ast_fn_decl) => {\n+          ast::ty_fn(ast::proto_block, purity, ast_bounds, ast_fn_decl) => {\n             let new_proto;\n             match vst {\n                 ty::vstore_fixed(_) => {\n@@ -216,7 +216,8 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n \n             // Run through the normal function type conversion process.\n             let bounds = collect::compute_bounds(self.ccx(), ast_bounds);\n-            let fn_decl = ty_of_fn_decl(self, rscope, new_proto, bounds,\n+            let fn_decl = ty_of_fn_decl(self, rscope, new_proto, purity,\n+                                        bounds,\n                                         ast_fn_decl, none, span);\n             return ty::mk_fn(tcx, fn_decl);\n           }\n@@ -301,9 +302,10 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n         };\n         ty::mk_rec(tcx, flds)\n       }\n-      ast::ty_fn(proto, ast_bounds, decl) => {\n+      ast::ty_fn(proto, purity, ast_bounds, decl) => {\n         let bounds = collect::compute_bounds(self.ccx(), ast_bounds);\n-        let fn_decl = ty_of_fn_decl(self, rscope, proto, bounds, decl, none,\n+        let fn_decl = ty_of_fn_decl(self, rscope, proto, purity,\n+                                    bounds, decl, none,\n                                     ast_ty.span);\n         ty::mk_fn(tcx, fn_decl)\n       }\n@@ -465,6 +467,7 @@ type expected_tys = option<{inputs: ~[ty::arg],\n fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy owned>(\n     self: AC, rscope: RS,\n     ast_proto: ast::proto,\n+    purity: ast::purity,\n     bounds: @~[ty::param_bound],\n     decl: ast::fn_decl,\n     expected_tys: expected_tys,\n@@ -494,7 +497,7 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy owned>(\n \n         let proto = ast_proto_to_proto(self, rscope, span, ast_proto);\n \n-        {purity: decl.purity, proto: proto, bounds: bounds, inputs: input_tys,\n+        {purity: purity, proto: proto, bounds: bounds, inputs: input_tys,\n          output: output_ty, ret_style: decl.cf}\n     }\n }"}, {"sha": "aa51f2dd4a2cd2abc286119e93f3dd318fe9ac30", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -223,12 +223,12 @@ fn check_fn(ccx: @crate_ctxt,\n           none => {\n             {infcx: infer::new_infer_ctxt(tcx),\n              locals: int_hash(),\n-             purity: decl.purity,\n+             purity: fn_ty.purity,\n              node_types: map::int_hash(),\n              node_type_substs: map::int_hash()}\n           }\n           some(fcx) => {\n-            assert decl.purity == ast::impure_fn;\n+            assert fn_ty.purity == ast::impure_fn;\n             {infcx: fcx.infcx,\n              locals: fcx.locals,\n              purity: fcx.purity,\n@@ -476,7 +476,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_enum(enum_definition, _) => {\n         check_enum_variants(ccx, it.span, enum_definition.variants, it.id);\n       }\n-      ast::item_fn(decl, tps, body) => {\n+      ast::item_fn(decl, _, tps, body) => {\n         check_bare_fn(ccx, decl, body, it.id, none);\n       }\n       ast::item_impl(tps, _, ty, ms) => {\n@@ -1232,8 +1232,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             }\n         }\n \n+        let purity = ast::impure_fn;\n+\n         // construct the function type\n-        let mut fn_ty = astconv::ty_of_fn_decl(fcx, fcx, ast_proto, @~[],\n+        let mut fn_ty = astconv::ty_of_fn_decl(fcx, fcx, ast_proto, purity,\n+                                               @~[],\n                                                decl, expected_tys, expr.span);\n \n         // Patch up the function declaration, if necessary.\n@@ -1599,16 +1602,18 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = alt::check_alt(fcx, expr, discrim, arms);\n       }\n       ast::expr_fn(proto, decl, body, cap_clause) => {\n-        check_expr_fn(fcx, expr, foap_ast_proto(proto), decl, body, false,\n+        check_expr_fn(fcx, expr, foap_ast_proto(proto),\n+                      decl, body, false,\n                       expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n       ast::expr_fn_block(decl, body, cap_clause) => {\n-         // Take the prototype from the expected type, but default to block:\n-          let proto = unpack_expected(fcx, expected, |sty|\n-              match sty { ty::ty_fn({proto, _}) => some(proto), _ => none }\n-          ).get_default(ty::proto_vstore(ty::vstore_box));\n-        check_expr_fn(fcx, expr, foap_fn_proto(proto), decl, body, false,\n+        // Take the prototype from the expected type, but default to block:\n+        let proto = do unpack_expected(fcx, expected) |sty| {\n+            match sty { ty::ty_fn({proto, _}) => some(proto), _ => none }\n+        }.get_default(ty::proto_vstore(ty::vstore_box));\n+        check_expr_fn(fcx, expr, foap_fn_proto(proto),\n+                      decl, body, false,\n                       expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n@@ -1642,7 +1647,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         };\n         match check b.node {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n-            check_expr_fn(fcx, b, foap_fn_proto(proto), decl, body, true,\n+            check_expr_fn(fcx, b, foap_fn_proto(proto),\n+                          decl, body, true,\n                           some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n@@ -1671,7 +1677,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         };\n         match check b.node {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n-            check_expr_fn(fcx, b, foap_fn_proto(proto), decl, body, true,\n+            check_expr_fn(fcx, b, foap_fn_proto(proto),\n+                          decl, body, true,\n                           some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);"}, {"sha": "b87380720cefc09f2faa739ce8d9bdd9d2a330b8", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -247,7 +247,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n                        trait_m: ty::method, trait_substs: ty::substs,\n                        self_ty: ty::t) {\n \n-    if impl_m.purity != trait_m.purity {\n+    if impl_m.fty.purity != trait_m.fty.purity {\n         tcx.sess.span_err(\n             sp, fmt!(\"method `%s`'s purity does \\\n                           not match the trait method's \\\n@@ -506,7 +506,8 @@ fn convert_struct(ccx: @crate_ctxt,\n         // Write the dtor type\n         let t_dtor = ty::mk_fn(\n             tcx,\n-            ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare, @~[],\n+            ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n+                          ast::impure_fn, @~[],\n                           ast_util::dtor_dec(), none, dtor.span));\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n@@ -537,7 +538,7 @@ fn convert_foreign(ccx: @crate_ctxt, i: @ast::foreign_item) {\n     // table.\n     let tpt = ty_of_foreign_item(ccx, i);\n     match i.node {\n-      ast::foreign_item_fn(_, _) => {\n+      ast::foreign_item_fn(*) => {\n         write_ty_to_tcx(ccx.tcx, i.id, tpt.ty);\n         ccx.tcx.tcache.insert(local_def(i.id), tpt);\n       }\n@@ -549,10 +550,10 @@ fn ty_of_method(ccx: @crate_ctxt,\n                 rp: option<ty::region_variance>) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(ccx, m.tps),\n-     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare, @~[],\n+     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n+                        m.purity, @~[],\n                         m.decl, none, m.span),\n      self_ty: m.self_ty.node,\n-     purity: m.decl.purity,\n      vis: m.vis}\n }\n \n@@ -561,11 +562,11 @@ fn ty_of_ty_method(self: @crate_ctxt,\n                    rp: option<ty::region_variance>) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(self, m.tps),\n-     fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare, @~[], m.decl,\n-                        none, m.span),\n+     fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare, m.purity,\n+                        @~[], m.decl, none, m.span),\n      // assume public, because this is only invoked on trait methods\n      self_ty: m.self_ty.node,\n-     purity: m.decl.purity, vis: ast::public}\n+     vis: ast::public}\n }\n \n /*\n@@ -614,9 +615,10 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_fn(decl, tps, _) => {\n+      ast::item_fn(decl, purity, tps, _) => {\n         let bounds = ty_param_bounds(ccx, tps);\n-        let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare, @~[],\n+        let tofd = ty_of_fn_decl(ccx, empty_rscope,\n+                                 ast::proto_bare, purity, @~[],\n                                  decl, none, it.span);\n         let tpt = {bounds: bounds,\n                    region_param: none,\n@@ -689,9 +691,9 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n fn ty_of_foreign_item(ccx: @crate_ctxt, it: @ast::foreign_item)\n     -> ty::ty_param_bounds_and_ty {\n     match it.node {\n-      ast::foreign_item_fn(fn_decl, params) => {\n-        return ty_of_foreign_fn_decl(ccx, fn_decl, params,\n-                                  local_def(it.id));\n+      ast::foreign_item_fn(fn_decl, purity, params) => {\n+        return ty_of_foreign_fn_decl(ccx, fn_decl, purity, params,\n+                                     local_def(it.id));\n       }\n     }\n }\n@@ -739,16 +741,17 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n }\n \n fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n-                        decl: ast::fn_decl,\n-                        ty_params: ~[ast::ty_param],\n-                        def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+                         decl: ast::fn_decl,\n+                         purity: ast::purity,\n+                         ty_params: ~[ast::ty_param],\n+                         def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n \n     let bounds = ty_param_bounds(ccx, ty_params);\n     let rb = in_binding_rscope(empty_rscope);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, a, none) );\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n-    let t_fn = ty::mk_fn(ccx.tcx, {purity: decl.purity,\n+    let t_fn = ty::mk_fn(ccx.tcx, {purity: purity,\n                                    proto: ty::proto_bare,\n                                    bounds: @~[],\n                                    inputs: input_tys,"}, {"sha": "2bfc0da36f9242ca5d751c7fe3e3bf5f814a21e9", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -83,7 +83,7 @@ fn moddoc_from_mod(\n                     nmoddoc_from_mod(itemdoc, nm)\n                 ))\n               }\n-              ast::item_fn(_, _, _) => {\n+              ast::item_fn(*) => {\n                 some(doc::fntag(\n                     fndoc_from_fn(itemdoc)\n                 ))\n@@ -129,7 +129,7 @@ fn nmoddoc_from_mod(\n         fns: do vec::map(module_.items) |item| {\n             let itemdoc = mk_itemdoc(item.id, to_str(item.ident));\n             match item.node {\n-              ast::foreign_item_fn(_, _) => {\n+              ast::foreign_item_fn(*) => {\n                 fndoc_from_fn(itemdoc)\n               }\n             }"}, {"sha": "f41c2de4093f83540b806d48da20a61b3167a216", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f996f70a632d1427801f20935a69a57fbb3679e/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=0f996f70a632d1427801f20935a69a57fbb3679e", "patch": "@@ -50,11 +50,11 @@ fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<~str> {\n         match ctxt.ast_map.get(fn_id) {\n           ast_map::node_item(@{\n             ident: ident,\n-            node: ast::item_fn(decl, tys, _), _\n+            node: ast::item_fn(decl, _, tys, _), _\n           }, _) |\n           ast_map::node_foreign_item(@{\n             ident: ident,\n-            node: ast::foreign_item_fn(decl, tys), _\n+            node: ast::foreign_item_fn(decl, _, tys), _\n           }, _, _) => {\n             some(pprust::fun_to_str(decl, ident, tys, extract::interner()))\n           }"}]}