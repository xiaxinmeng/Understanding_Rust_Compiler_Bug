{"sha": "9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxOTliYjVmODFlYWUxZjhlYTQ3Yzk5NDVmYzNmNGM0ZGRlZDQ5ODk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-03T14:24:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-03T14:24:56Z"}, "message": "Rollup merge of #60373 - rasendubi:lang-features-sort-since, r=Centril\n\nTidy: ensure lang features are sorted by since\n\nThis is the tidy side of https://github.com/rust-lang/rust/issues/60361.\n\nWhat is left is actually splitting features into groups and sorting by since.\n\nThis PR also likely to produce a small (a couple of lines) merge conflict with https://github.com/rust-lang/rust/pull/60362.\n\nr? @Centril", "tree": {"sha": "6bd237d38a7b5ec41ae7c3412e7bec8216814969", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bd237d38a7b5ec41ae7c3412e7bec8216814969"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJczE84CRBK7hj4Ov3rIwAAdHIIAKzGqUJ0QvmfRnLf4pbXXRkY\nIcT/2D9q7+uqK21jam72V+dMiEwsXQXhFZlstP2YiBh2kutDKwOEv2BfV22IGHG7\n20d3ZsViwHDhWULvW5BQOuSjCbDnwdeOLaKhBC95ncnREYyfidQaCz2q/0AoyV37\nv1Ze045E0Kro55f2ubuzGqJ63gIJ5KlQtGavsN+afVyyaqT4cUEqyP00/pYJkGWj\ne/qhb6jLBX3U0BgLQjwQ2lqh69v1rV/uGhzTCpQOx6gU0QsYL3UKtibTp8iXgDIU\npCYqNG4y5sQ+pKlXjWm4JCMgLp5FjzdKZIrBWgod9QvH7p+9jsXcDP98N4xILi4=\n=AaQ1\n-----END PGP SIGNATURE-----\n", "payload": "tree 6bd237d38a7b5ec41ae7c3412e7bec8216814969\nparent 06e1d88de6de15c34cd9a9fa34d7608bc346c6ec\nparent 201f14b88b19d43615845bfc2a6de9bc31985b13\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556893496 +0200\ncommitter GitHub <noreply@github.com> 1556893496 +0200\n\nRollup merge of #60373 - rasendubi:lang-features-sort-since, r=Centril\n\nTidy: ensure lang features are sorted by since\n\nThis is the tidy side of https://github.com/rust-lang/rust/issues/60361.\n\nWhat is left is actually splitting features into groups and sorting by since.\n\nThis PR also likely to produce a small (a couple of lines) merge conflict with https://github.com/rust-lang/rust/pull/60362.\n\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "html_url": "https://github.com/rust-lang/rust/commit/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06e1d88de6de15c34cd9a9fa34d7608bc346c6ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/06e1d88de6de15c34cd9a9fa34d7608bc346c6ec", "html_url": "https://github.com/rust-lang/rust/commit/06e1d88de6de15c34cd9a9fa34d7608bc346c6ec"}, {"sha": "201f14b88b19d43615845bfc2a6de9bc31985b13", "url": "https://api.github.com/repos/rust-lang/rust/commits/201f14b88b19d43615845bfc2a6de9bc31985b13", "html_url": "https://github.com/rust-lang/rust/commit/201f14b88b19d43615845bfc2a6de9bc31985b13"}], "stats": {"total": 338, "additions": 256, "deletions": 82}, "files": [{"sha": "3d7f00e6410b5f3392db26779224d8e088b81aa9", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "patch": "@@ -3556,6 +3556,7 @@ dependencies = [\n name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n+ \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "b3ef5f3064c167f1d658a0ebfe994d9f13241720", "filename": "src/libstd/sys/redox/ext/net.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs?ref=9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "patch": "@@ -1,4 +1,4 @@\n-#![stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#![stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n \n //! Unix-specific networking functionality\n \n@@ -27,7 +27,7 @@ use crate::sys::{cvt, fd::FileDesc, syscall};\n /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n /// ```\n #[derive(Clone)]\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n pub struct SocketAddr(());\n \n impl SocketAddr {\n@@ -55,7 +55,7 @@ impl SocketAddr {\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// assert_eq!(addr.as_pathname(), None);\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn as_pathname(&self) -> Option<&Path> {\n         None\n     }\n@@ -83,12 +83,12 @@ impl SocketAddr {\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// assert_eq!(addr.is_unnamed(), true);\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn is_unnamed(&self) -> bool {\n         false\n     }\n }\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl fmt::Debug for SocketAddr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"SocketAddr\")\n@@ -109,10 +109,10 @@ impl fmt::Debug for SocketAddr {\n /// stream.read_to_string(&mut response).unwrap();\n /// println!(\"{}\", response);\n /// ```\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n pub struct UnixStream(FileDesc);\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl fmt::Debug for UnixStream {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixStream\");\n@@ -143,7 +143,7 @@ impl UnixStream {\n     ///     }\n     /// };\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n         if let Some(s) = path.as_ref().to_str() {\n             cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CLOEXEC))\n@@ -174,7 +174,7 @@ impl UnixStream {\n     ///     }\n     /// };\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n         let server = cvt(syscall::open(\"chan:\", syscall::O_CREAT | syscall::O_CLOEXEC))\n             .map(FileDesc::new)?;\n@@ -198,7 +198,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixStream> {\n         self.0.duplicate().map(UnixStream)\n     }\n@@ -213,7 +213,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::local_addr unimplemented on redox\"))\n     }\n@@ -228,7 +228,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::peer_addr unimplemented on redox\"))\n     }\n@@ -267,7 +267,7 @@ impl UnixStream {\n     /// let err = result.unwrap_err();\n     /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn set_read_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::set_read_timeout unimplemented on redox\"))\n     }\n@@ -306,7 +306,7 @@ impl UnixStream {\n     /// let err = result.unwrap_err();\n     /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn set_write_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::set_write_timeout unimplemented on redox\"))\n     }\n@@ -323,7 +323,7 @@ impl UnixStream {\n     /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n     /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::read_timeout unimplemented on redox\"))\n     }\n@@ -340,7 +340,7 @@ impl UnixStream {\n     /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n     /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::write_timeout unimplemented on redox\"))\n     }\n@@ -355,7 +355,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n@@ -375,7 +375,7 @@ impl UnixStream {\n     ///\n     /// # Platform specific\n     /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         Ok(None)\n     }\n@@ -397,13 +397,13 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn shutdown(&self, _how: Shutdown) -> io::Result<()> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::shutdown unimplemented on redox\"))\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl io::Read for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         io::Read::read(&mut &*self, buf)\n@@ -415,7 +415,7 @@ impl io::Read for UnixStream {\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl<'a> io::Read for &'a UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.read(buf)\n@@ -427,7 +427,7 @@ impl<'a> io::Read for &'a UnixStream {\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl io::Write for UnixStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         io::Write::write(&mut &*self, buf)\n@@ -438,7 +438,7 @@ impl io::Write for UnixStream {\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl<'a> io::Write for &'a UnixStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n@@ -449,21 +449,21 @@ impl<'a> io::Write for &'a UnixStream {\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl AsRawFd for UnixStream {\n     fn as_raw_fd(&self) -> RawFd {\n         self.0.raw()\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl FromRawFd for UnixStream {\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n         UnixStream(FileDesc::new(fd))\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl IntoRawFd for UnixStream {\n     fn into_raw_fd(self) -> RawFd {\n         self.0.into_raw()\n@@ -498,10 +498,10 @@ impl IntoRawFd for UnixStream {\n ///     }\n /// }\n /// ```\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n pub struct UnixListener(FileDesc);\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl fmt::Debug for UnixListener {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixListener\");\n@@ -529,7 +529,7 @@ impl UnixListener {\n     ///     }\n     /// };\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n         if let Some(s) = path.as_ref().to_str() {\n             cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CREAT | syscall::O_CLOEXEC))\n@@ -563,7 +563,7 @@ impl UnixListener {\n     ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n     /// }\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n         self.0.duplicate_path(b\"listen\").map(|fd| (UnixStream(fd), SocketAddr(())))\n     }\n@@ -583,7 +583,7 @@ impl UnixListener {\n     ///\n     /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixListener> {\n         self.0.duplicate().map(UnixListener)\n     }\n@@ -599,7 +599,7 @@ impl UnixListener {\n     ///\n     /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         Err(Error::new(ErrorKind::Other, \"UnixListener::local_addr unimplemented on redox\"))\n     }\n@@ -615,7 +615,7 @@ impl UnixListener {\n     ///\n     /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n@@ -636,7 +636,7 @@ impl UnixListener {\n     ///\n     /// # Platform specific\n     /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         Ok(None)\n     }\n@@ -672,34 +672,34 @@ impl UnixListener {\n     ///     }\n     /// }\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n         Incoming { listener: self }\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl AsRawFd for UnixListener {\n     fn as_raw_fd(&self) -> RawFd {\n         self.0.raw()\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl FromRawFd for UnixListener {\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n         UnixListener(FileDesc::new(fd))\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl IntoRawFd for UnixListener {\n     fn into_raw_fd(self) -> RawFd {\n         self.0.into_raw()\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl<'a> IntoIterator for &'a UnixListener {\n     type Item = io::Result<UnixStream>;\n     type IntoIter = Incoming<'a>;\n@@ -740,12 +740,12 @@ impl<'a> IntoIterator for &'a UnixListener {\n /// }\n /// ```\n #[derive(Debug)]\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n pub struct Incoming<'a> {\n     listener: &'a UnixListener,\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl<'a> Iterator for Incoming<'a> {\n     type Item = io::Result<UnixStream>;\n "}, {"sha": "2a1f3c48014069191ac6461a8277b230f2c978cd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "patch": "@@ -109,15 +109,14 @@ macro_rules! declare_features {\n // stable (active).\n //\n // Note that the features should be grouped into internal/user-facing\n-// and then sorted by version inside those groups.\n-// FIXME(60361): Enforce ^-- with tidy.\n+// and then sorted by version inside those groups. This is inforced with tidy.\n //\n // N.B., `tools/tidy/src/features.rs` parses this information directly out of the\n // source, so take care when modifying it.\n \n declare_features! (\n     // -------------------------------------------------------------------------\n-    // Internal feature gates.\n+    // feature-group-start: internal feature gates\n     // -------------------------------------------------------------------------\n \n     // no tracking issue START\n@@ -211,12 +210,12 @@ declare_features! (\n \n     // no tracking issue END\n \n-    // Allows using the `may_dangle` attribute (RFC 1327).\n-    (active, dropck_eyepatch, \"1.10.0\", Some(34761), None),\n-\n     // Allows using `#[structural_match]` which indicates that a type is structurally matchable.\n     (active, structural_match, \"1.8.0\", Some(31434), None),\n \n+    // Allows using the `may_dangle` attribute (RFC 1327).\n+    (active, dropck_eyepatch, \"1.10.0\", Some(34761), None),\n+\n     // Allows using the `#![panic_runtime]` attribute.\n     (active, panic_runtime, \"1.10.0\", Some(32837), None),\n \n@@ -252,7 +251,11 @@ declare_features! (\n     (active, test_2018_feature, \"1.31.0\", Some(0), Some(Edition::Edition2018)),\n \n     // -------------------------------------------------------------------------\n-    // Actual feature gates (target features).\n+    // feature-group-end: internal feature gates\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: actual feature gates (target features)\n     // -------------------------------------------------------------------------\n \n     // FIXME: Document these and merge with the list below.\n@@ -275,7 +278,11 @@ declare_features! (\n     (active, f16c_target_feature, \"1.36.0\", Some(44839), None),\n \n     // -------------------------------------------------------------------------\n-    // Actual feature gates.\n+    // feature-group-end: actual feature gates (target features)\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: actual feature gates\n     // -------------------------------------------------------------------------\n \n     // Allows using `asm!` macro with which inline assembly can be embedded.\n@@ -340,9 +347,6 @@ declare_features! (\n     // Permits specifying whether a function should permit unwinding or abort on unwind.\n     (active, unwind_attributes, \"1.4.0\", Some(58760), None),\n \n-    // Allows using `#[naked]` on functions.\n-    (active, naked_functions, \"1.9.0\", Some(32408), None),\n-\n     // Allows `#[no_debug]`.\n     (active, no_debug, \"1.5.0\", Some(29721), None),\n \n@@ -358,6 +362,9 @@ declare_features! (\n     // Allows specialization of implementations (RFC 1210).\n     (active, specialization, \"1.7.0\", Some(31844), None),\n \n+    // Allows using `#[naked]` on functions.\n+    (active, naked_functions, \"1.9.0\", Some(32408), None),\n+\n     // Allows `cfg(target_has_atomic = \"...\")`.\n     (active, cfg_target_has_atomic, \"1.9.0\", Some(32976), None),\n \n@@ -545,6 +552,10 @@ declare_features! (\n \n     // Allows using C-variadics.\n     (active, c_variadic, \"1.34.0\", Some(44930), None),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: actual feature gates\n+    // -------------------------------------------------------------------------\n );\n \n // Some features are known to be incomplete and using them is likely to have"}, {"sha": "f5db2487618d6e116ffc10138ee6205e8cfdf2c2", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "patch": "@@ -4,6 +4,7 @@ version = \"0.1.0\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n \n [dependencies]\n+regex = \"1\"\n serde = \"1.0.8\"\n serde_derive = \"1.0.8\"\n serde_json = \"1.0.2\""}, {"sha": "3144df6dd4cdf90d8773794a7ed60a0073831172", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 98, "deletions": 30, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "patch": "@@ -7,13 +7,22 @@\n //! * Library features have at most one stability level.\n //! * Library features have at most one `since` value.\n //! * All unstable lang features have tests to ensure they are actually unstable.\n+//! * Language features in a group are sorted by `since` value.\n \n use std::collections::HashMap;\n use std::fmt;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::path::Path;\n \n+use regex::{Regex, escape};\n+\n+mod version;\n+use self::version::Version;\n+\n+const FEATURE_GROUP_START_PREFIX: &str = \"// feature-group-start\";\n+const FEATURE_GROUP_END_PREFIX: &str = \"// feature-group-end\";\n+\n #[derive(Debug, PartialEq, Clone)]\n pub enum Status {\n     Stable,\n@@ -35,7 +44,7 @@ impl fmt::Display for Status {\n #[derive(Debug, Clone)]\n pub struct Feature {\n     pub level: Status,\n-    pub since: String,\n+    pub since: Option<Version>,\n     pub has_gate_test: bool,\n     pub tracking_issue: Option<u32>,\n }\n@@ -129,32 +138,40 @@ pub fn check(path: &Path, bad: &mut bool, quiet: bool) {\n     }\n \n     let mut lines = Vec::new();\n-    for (name, feature) in features.iter() {\n-        lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n-                           name,\n-                           \"lang\",\n-                           feature.level,\n-                           feature.since));\n-    }\n-    for (name, feature) in lib_features {\n-        lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n-                           name,\n-                           \"lib\",\n-                           feature.level,\n-                           feature.since));\n-    }\n+    lines.extend(format_features(&features, \"lang\"));\n+    lines.extend(format_features(&lib_features, \"lib\"));\n \n     lines.sort();\n     for line in lines {\n         println!(\"* {}\", line);\n     }\n }\n \n+fn format_features<'a>(features: &'a Features, family: &'a str) -> impl Iterator<Item = String> + 'a {\n+    features.iter().map(move |(name, feature)| {\n+        format!(\"{:<32} {:<8} {:<12} {:<8}\",\n+                name,\n+                family,\n+                feature.level,\n+                feature.since.map_or(\"None\".to_owned(),\n+                                     |since| since.to_string()))\n+    })\n+}\n+\n fn find_attr_val<'a>(line: &'a str, attr: &str) -> Option<&'a str> {\n-    line.find(attr)\n-        .and_then(|i| line[i..].find('\"').map(|j| i + j + 1))\n-        .and_then(|i| line[i..].find('\"').map(|j| (i, i + j)))\n-        .map(|(i, j)| &line[i..j])\n+    let r = Regex::new(&format!(r#\"{}\\s*=\\s*\"([^\"]*)\"\"#, escape(attr)))\n+        .expect(\"malformed regex for find_attr_val\");\n+    r.captures(line)\n+        .and_then(|c| c.get(1))\n+        .map(|m| m.as_str())\n+}\n+\n+#[test]\n+fn test_find_attr_val() {\n+    let s = r#\"#[unstable(feature = \"checked_duration_since\", issue = \"58402\")]\"#;\n+    assert_eq!(find_attr_val(s, \"feature\"), Some(\"checked_duration_since\"));\n+    assert_eq!(find_attr_val(s, \"issue\"), Some(\"58402\"));\n+    assert_eq!(find_attr_val(s, \"since\"), None);\n }\n \n fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n@@ -177,6 +194,9 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n     // without one inside `// no tracking issue START` and `// no tracking issue END`.\n     let mut next_feature_omits_tracking_issue = false;\n \n+    let mut in_feature_group = false;\n+    let mut prev_since = None;\n+\n     contents.lines().zip(1..)\n         .filter_map(|(line, line_number)| {\n             let line = line.trim();\n@@ -194,6 +214,25 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n                 _ => {}\n             }\n \n+            if line.starts_with(FEATURE_GROUP_START_PREFIX) {\n+                if in_feature_group {\n+                    tidy_error!(\n+                        bad,\n+                        // ignore-tidy-linelength\n+                        \"libsyntax/feature_gate.rs:{}: new feature group is started without ending the previous one\",\n+                        line_number,\n+                    );\n+                }\n+\n+                in_feature_group = true;\n+                prev_since = None;\n+                return None;\n+            } else if line.starts_with(FEATURE_GROUP_END_PREFIX) {\n+                in_feature_group = false;\n+                prev_since = None;\n+                return None;\n+            }\n+\n             let mut parts = line.split(',');\n             let level = match parts.next().map(|l| l.trim().trim_start_matches('(')) {\n                 Some(\"active\") => Status::Unstable,\n@@ -202,7 +241,33 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n                 _ => return None,\n             };\n             let name = parts.next().unwrap().trim();\n-            let since = parts.next().unwrap().trim().trim_matches('\"');\n+\n+            let since_str = parts.next().unwrap().trim().trim_matches('\"');\n+            let since = match since_str.parse() {\n+                Ok(since) => Some(since),\n+                Err(err) => {\n+                    tidy_error!(\n+                        bad,\n+                        \"libsyntax/feature_gate.rs:{}: failed to parse since: {} ({:?})\",\n+                        line_number,\n+                        since_str,\n+                        err,\n+                    );\n+                    None\n+                }\n+            };\n+            if in_feature_group {\n+                if prev_since > since {\n+                    tidy_error!(\n+                        bad,\n+                        \"libsyntax/feature_gate.rs:{}: feature {} is not sorted by since\",\n+                        line_number,\n+                        name,\n+                    );\n+                }\n+                prev_since = since;\n+            }\n+\n             let issue_str = parts.next().unwrap().trim();\n             let tracking_issue = if issue_str.starts_with(\"None\") {\n                 if level == Status::Unstable && !next_feature_omits_tracking_issue {\n@@ -222,7 +287,7 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n             Some((name.to_owned(),\n                 Feature {\n                     level,\n-                    since: since.to_owned(),\n+                    since,\n                     has_gate_test: false,\n                     tracking_issue,\n                 }))\n@@ -239,7 +304,7 @@ pub fn collect_lib_features(base_src_path: &Path) -> Features {\n     // add it to the set of known library features so we can still generate docs.\n     lib_features.insert(\"compiler_builtins_lib\".to_owned(), Feature {\n         level: Status::Unstable,\n-        since: String::new(),\n+        since: None,\n         has_gate_test: false,\n         tracking_issue: None,\n     });\n@@ -336,11 +401,11 @@ fn map_lib_features(base_src_path: &Path,\n                 // `const fn` features are handled specially.\n                 let feature_name = match find_attr_val(line, \"feature\") {\n                     Some(name) => name,\n-                    None => err!(\"malformed stability attribute\"),\n+                    None => err!(\"malformed stability attribute: missing `feature` key\"),\n                 };\n                 let feature = Feature {\n                     level: Status::Unstable,\n-                    since: \"None\".to_owned(),\n+                    since: None,\n                     has_gate_test: false,\n                     // FIXME(#57563): #57563 is now used as a common tracking issue,\n                     // although we would like to have specific tracking issues for each\n@@ -359,20 +424,23 @@ fn map_lib_features(base_src_path: &Path,\n             };\n             let feature_name = match find_attr_val(line, \"feature\") {\n                 Some(name) => name,\n-                None => err!(\"malformed stability attribute\"),\n+                None => err!(\"malformed stability attribute: missing `feature` key\"),\n             };\n-            let since = match find_attr_val(line, \"since\") {\n-                Some(name) => name,\n+            let since = match find_attr_val(line, \"since\").map(|x| x.parse()) {\n+                Some(Ok(since)) => Some(since),\n+                Some(Err(_err)) => {\n+                    err!(\"malformed stability attribute: can't parse `since` key\");\n+                },\n                 None if level == Status::Stable => {\n-                    err!(\"malformed stability attribute\");\n+                    err!(\"malformed stability attribute: missing the `since` key\");\n                 }\n-                None => \"None\",\n+                None => None,\n             };\n             let tracking_issue = find_attr_val(line, \"issue\").map(|s| s.parse().unwrap());\n \n             let feature = Feature {\n                 level,\n-                since: since.to_owned(),\n+                since,\n                 has_gate_test: false,\n                 tracking_issue,\n             };"}, {"sha": "6027e7d35e28c4d6b23dc3049ac9b2412b06b54d", "filename": "src/tools/tidy/src/features/version.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs?ref=9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "patch": "@@ -0,0 +1,92 @@\n+use std::str::FromStr;\n+use std::num::ParseIntError;\n+use std::fmt;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Version {\n+    parts: [u32; 3],\n+}\n+\n+impl fmt::Display for Version {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(&format!(\"{}.{}.{}\", self.parts[0], self.parts[1], self.parts[2]))\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum ParseVersionError {\n+    ParseIntError(ParseIntError),\n+    WrongNumberOfParts,\n+}\n+\n+impl From<ParseIntError> for ParseVersionError {\n+    fn from(err: ParseIntError) -> Self {\n+        ParseVersionError::ParseIntError(err)\n+    }\n+}\n+\n+impl FromStr for Version {\n+    type Err = ParseVersionError;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        let mut iter = s.split('.').map(|part| Ok(part.parse()?));\n+\n+        let parts = {\n+            let mut part = || {\n+                iter.next()\n+                    .unwrap_or(Err(ParseVersionError::WrongNumberOfParts))\n+            };\n+\n+            [part()?, part()?, part()?]\n+        };\n+\n+        if let Some(_) = iter.next() {\n+            // Ensure we don't have more than 3 parts.\n+            return Err(ParseVersionError::WrongNumberOfParts);\n+        }\n+\n+        Ok(Self { parts })\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Version;\n+\n+    #[test]\n+    fn test_try_from_invalid_version() {\n+        assert!(\"\".parse::<Version>().is_err());\n+        assert!(\"hello\".parse::<Version>().is_err());\n+        assert!(\"1.32.hi\".parse::<Version>().is_err());\n+        assert!(\"1.32..1\".parse::<Version>().is_err());\n+        assert!(\"1.32\".parse::<Version>().is_err());\n+        assert!(\"1.32.0.1\".parse::<Version>().is_err());\n+    }\n+\n+    #[test]\n+    fn test_try_from_single() {\n+        assert_eq!(\"1.32.0\".parse(), Ok(Version { parts: [1, 32, 0] }));\n+        assert_eq!(\"1.0.0\".parse(), Ok(Version { parts: [1, 0, 0] }));\n+    }\n+\n+    #[test]\n+    fn test_compare() {\n+        let v_1_0_0 = \"1.0.0\".parse::<Version>().unwrap();\n+        let v_1_32_0 = \"1.32.0\".parse::<Version>().unwrap();\n+        let v_1_32_1 = \"1.32.1\".parse::<Version>().unwrap();\n+        assert!(v_1_0_0 < v_1_32_1);\n+        assert!(v_1_0_0 < v_1_32_0);\n+        assert!(v_1_32_0 < v_1_32_1);\n+    }\n+\n+    #[test]\n+    fn test_to_string() {\n+        let v_1_0_0 = \"1.0.0\".parse::<Version>().unwrap();\n+        let v_1_32_1 = \"1.32.1\".parse::<Version>().unwrap();\n+\n+        assert_eq!(v_1_0_0.to_string(), \"1.0.0\");\n+        assert_eq!(v_1_32_1.to_string(), \"1.32.1\");\n+        assert_eq!(format!(\"{:<8}\", v_1_32_1), \"1.32.1  \");\n+        assert_eq!(format!(\"{:>8}\", v_1_32_1), \"  1.32.1\");\n+    }\n+}"}, {"sha": "30080452edc0199959474d61bf9b5c9558bb9e3b", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9199bb5f81eae1f8ea47c9945fc3f4c4dded4989/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=9199bb5f81eae1f8ea47c9945fc3f4c4dded4989", "patch": "@@ -5,6 +5,7 @@\n \n #![deny(rust_2018_idioms)]\n \n+extern crate regex;\n extern crate serde_json;\n #[macro_use]\n extern crate serde_derive;"}]}