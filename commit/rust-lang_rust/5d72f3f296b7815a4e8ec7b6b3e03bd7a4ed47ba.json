{"sha": "5d72f3f296b7815a4e8ec7b6b3e03bd7a4ed47ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNzJmM2YyOTZiNzgxNWE0ZThlYzdiNmIzZTAzYmQ3YTRlZDQ3YmE=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-06T03:42:45Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-06T05:26:04Z"}, "message": "deque: Remove rendundant field hi\n\nThe deque is determined by vec self.elts.len(), self.nelts, and self.lo,\nand self.hi is calculated from these.\n\nself.hi is just the raw index of element number `self.nelts`", "tree": {"sha": "7a67c3442f6118c4c6729b4c4cebecbd934e1ed7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a67c3442f6118c4c6729b4c4cebecbd934e1ed7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d72f3f296b7815a4e8ec7b6b3e03bd7a4ed47ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d72f3f296b7815a4e8ec7b6b3e03bd7a4ed47ba", "html_url": "https://github.com/rust-lang/rust/commit/5d72f3f296b7815a4e8ec7b6b3e03bd7a4ed47ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d72f3f296b7815a4e8ec7b6b3e03bd7a4ed47ba/comments", "author": null, "committer": null, "parents": [{"sha": "08dc72f5d54d3385d2a772b0ce2c92459ff25bfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/08dc72f5d54d3385d2a772b0ce2c92459ff25bfd", "html_url": "https://github.com/rust-lang/rust/commit/08dc72f5d54d3385d2a772b0ce2c92459ff25bfd"}], "stats": {"total": 48, "additions": 26, "deletions": 22}, "files": [{"sha": "04941e9886e2e09190674fbb04cb56a1fd543a86", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5d72f3f296b7815a4e8ec7b6b3e03bd7a4ed47ba/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d72f3f296b7815a4e8ec7b6b3e03bd7a4ed47ba/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=5d72f3f296b7815a4e8ec7b6b3e03bd7a4ed47ba", "patch": "@@ -21,7 +21,6 @@ static INITIAL_CAPACITY: uint = 32u; // 2^5\n pub struct Deque<T> {\n     priv nelts: uint,\n     priv lo: uint,\n-    priv hi: uint,\n     priv elts: ~[Option<T>]\n }\n \n@@ -39,26 +38,31 @@ impl<T> Mutable for Deque<T> {\n         for self.elts.mut_iter().advance |x| { *x = None }\n         self.nelts = 0;\n         self.lo = 0;\n-        self.hi = 0;\n     }\n }\n \n impl<T> Deque<T> {\n     /// Create an empty Deque\n     pub fn new() -> Deque<T> {\n-        Deque{nelts: 0, lo: 0, hi: 0,\n+        Deque{nelts: 0, lo: 0,\n               elts: vec::from_fn(INITIAL_CAPACITY, |_| None)}\n     }\n \n     /// Return a reference to the first element in the deque\n     ///\n     /// Fails if the deque is empty\n-    pub fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n+    pub fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.raw_index(0)) }\n \n     /// Return a reference to the last element in the deque\n     ///\n     /// Fails if the deque is empty\n-    pub fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n+    pub fn peek_back<'a>(&'a self) -> &'a T {\n+        if self.nelts > 0 {\n+            get(self.elts, self.raw_index(self.nelts - 1))\n+        } else {\n+            fail!(\"peek_back: empty deque\");\n+        }\n+    }\n \n     /// Retrieve an element in the deque by index\n     ///\n@@ -88,24 +92,28 @@ impl<T> Deque<T> {\n         result\n     }\n \n+    /// Return index in underlying vec for element index\n+    fn raw_index(&self, idx: uint) -> uint {\n+        if self.lo >= self.elts.len() - idx {\n+            (self.lo + idx) - self.elts.len()\n+        } else {\n+            (self.lo + idx)\n+        }\n+    }\n+\n     /// Remove and return the last element in the deque\n     ///\n     /// Fails if the deque is empty\n     pub fn pop_back(&mut self) -> T {\n-        if self.hi == 0u {\n-            self.hi = self.elts.len() - 1u;\n-        } else { self.hi -= 1u; }\n-        let result = self.elts[self.hi].swap_unwrap();\n-        self.elts[self.hi] = None;\n-        self.nelts -= 1u;\n-        result\n+        self.nelts -= 1;\n+        let hi = self.raw_index(self.nelts);\n+        self.elts[hi].swap_unwrap()\n     }\n \n     /// Prepend an element to the deque\n     pub fn add_front(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n             grow(self.nelts, self.lo, &mut self.elts);\n-            self.hi = self.lo + self.nelts;\n         }\n         if self.lo == 0u {\n             self.lo = self.elts.len() - 1u;\n@@ -116,15 +124,11 @@ impl<T> Deque<T> {\n \n     /// Append an element to the deque\n     pub fn add_back(&mut self, t: T) {\n-        if self.lo == self.hi && self.nelts != 0u {\n+        if self.nelts == self.elts.len() {\n             grow(self.nelts, self.lo, &mut self.elts);\n-            self.hi = self.lo + self.nelts;\n-        }\n-        self.elts[self.hi] = Some(t);\n-        self.hi += 1;\n-        if self.hi == self.elts.len() {\n-            self.hi = 0;\n         }\n+        let hi = self.raw_index(self.nelts);\n+        self.elts[hi] = Some(t);\n         self.nelts += 1u;\n     }\n \n@@ -165,12 +169,12 @@ impl<T> Deque<T> {\n \n     /// Back-to-front iterator.\n     pub fn rev_iter<'a>(&'a self) -> DequeRevIterator<'a, T> {\n-    DequeRevIterator { idx: self.hi - 1u, nelts: self.nelts, used: 0, vec: self.elts }\n+    DequeRevIterator { idx: self.raw_index(self.nelts-1), nelts: self.nelts, used: 0, vec: self.elts }\n     }\n \n     /// Back-to-front iterator which returns mutable values.\n     pub fn mut_rev_iter<'a>(&'a mut self) -> DequeMutRevIterator<'a, T> {\n-    DequeMutRevIterator { idx: self.hi - 1u, nelts: self.nelts, used: 0, vec: self.elts }\n+    DequeMutRevIterator { idx: self.raw_index(self.nelts-1), nelts: self.nelts, used: 0, vec: self.elts }\n     }\n }\n "}]}