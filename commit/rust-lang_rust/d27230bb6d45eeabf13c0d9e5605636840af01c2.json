{"sha": "d27230bb6d45eeabf13c0d9e5605636840af01c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNzIzMGJiNmQ0NWVlYWJmMTNjMGQ5ZTU2MDU2MzY4NDBhZjAxYzI=", "commit": {"author": {"name": "Michael Sproul", "email": "micsproul@gmail.com", "date": "2015-04-28T02:48:22Z"}, "committer": {"name": "Michael Sproul", "email": "micsproul@gmail.com", "date": "2015-04-29T22:59:53Z"}, "message": "Add metadata output to the diagnostics system.\n\nDiagnostic errors are now checked for uniqueness across the compiler and\nerror metadata is written to JSON files.", "tree": {"sha": "cf74549e405d9d3c287e5305de7d036c25d438d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf74549e405d9d3c287e5305de7d036c25d438d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d27230bb6d45eeabf13c0d9e5605636840af01c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d27230bb6d45eeabf13c0d9e5605636840af01c2", "html_url": "https://github.com/rust-lang/rust/commit/d27230bb6d45eeabf13c0d9e5605636840af01c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d27230bb6d45eeabf13c0d9e5605636840af01c2/comments", "author": {"login": "michaelsproul", "id": 4452260, "node_id": "MDQ6VXNlcjQ0NTIyNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelsproul", "html_url": "https://github.com/michaelsproul", "followers_url": "https://api.github.com/users/michaelsproul/followers", "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}", "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions", "organizations_url": "https://api.github.com/users/michaelsproul/orgs", "repos_url": "https://api.github.com/users/michaelsproul/repos", "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelsproul/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelsproul", "id": 4452260, "node_id": "MDQ6VXNlcjQ0NTIyNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/4452260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelsproul", "html_url": "https://github.com/michaelsproul", "followers_url": "https://api.github.com/users/michaelsproul/followers", "following_url": "https://api.github.com/users/michaelsproul/following{/other_user}", "gists_url": "https://api.github.com/users/michaelsproul/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelsproul/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelsproul/subscriptions", "organizations_url": "https://api.github.com/users/michaelsproul/orgs", "repos_url": "https://api.github.com/users/michaelsproul/repos", "events_url": "https://api.github.com/users/michaelsproul/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelsproul/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54d65092a49eba959b5cd7a1c4b2e43b3fedba1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/54d65092a49eba959b5cd7a1c4b2e43b3fedba1f", "html_url": "https://github.com/rust-lang/rust/commit/54d65092a49eba959b5cd7a1c4b2e43b3fedba1f"}], "stats": {"total": 290, "additions": 244, "deletions": 46}, "files": [{"sha": "b0fc4982a841c9a59347eed524d9863251623c09", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -517,5 +517,3 @@ register_diagnostics! {\n     E0316, // nested quantification of lifetimes\n     E0370  // discriminant overflow\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "53f46ff1605fc02314754e31197f893f24633381", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -161,3 +161,9 @@ pub mod lib {\n mod rustc {\n     pub use lint;\n }\n+\n+// Build the diagnostics array at the end so that the metadata includes error use sites.\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc, DIAGNOSTICS }"}, {"sha": "a43268ff1a8827c1cad97eef5a5f66c481467bb8", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -13,5 +13,3 @@\n register_diagnostics! {\n     E0373 // closure may outlive current fn, but it borrows {}, which is owned by current fn\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "5e083ed1ea912ef42bc5b72aea9baa9653299193", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -47,3 +47,8 @@ pub mod diagnostics;\n mod borrowck;\n \n pub mod graphviz;\n+\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc_borrowck, DIAGNOSTICS }"}, {"sha": "b02774afa86c8263ea86c416ad58837592fef983", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -854,9 +854,10 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n     use syntax::diagnostics::registry::Registry;\n \n     let all_errors = Vec::new() +\n-        &rustc::diagnostics::DIAGNOSTICS[..] +\n-        &rustc_typeck::diagnostics::DIAGNOSTICS[..] +\n-        &rustc_resolve::diagnostics::DIAGNOSTICS[..];\n+        &rustc::DIAGNOSTICS[..] +\n+        &rustc_typeck::DIAGNOSTICS[..] +\n+        &rustc_borrowck::DIAGNOSTICS[..] +\n+        &rustc_resolve::DIAGNOSTICS[..];\n \n     Registry::new(&*all_errors)\n }"}, {"sha": "a896bd311698c3cf55fd8d9a4e146d5bab99e8c3", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -28,5 +28,3 @@ register_diagnostics! {\n     E0364, // item is private\n     E0365  // item is private\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "67af2a60e0f821b135686f4c43ca021423f82826", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -3580,3 +3580,8 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n                     },\n     }\n }\n+\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "876a8bb41c6d273beee910baaf3ce2b7bd9f222f", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -183,5 +183,3 @@ register_diagnostics! {\n     E0371, // impl Trait for Trait is illegal\n     E0372  // impl Trait for Trait where Trait is not object safe\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "4d56ef95122ff0c78f5448ec6881ece7256bb4c9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -344,3 +344,8 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();\n }\n+\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}, {"sha": "6cb4f70b8607aceb3867e108f1277c6553778cfb", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -0,0 +1,155 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains utilities for outputting metadata for diagnostic errors.\n+//!\n+//! Each set of errors is mapped to a metadata file by a name, which is\n+//! currently always a crate name.\n+\n+use std::collections::BTreeMap;\n+use std::env;\n+use std::path::PathBuf;\n+use std::fs::{read_dir, create_dir_all, OpenOptions, File};\n+use std::io::{Read, Write};\n+use std::error::Error;\n+use rustc_serialize::json::{self, as_json};\n+\n+use codemap::Span;\n+use ext::base::ExtCtxt;\n+use diagnostics::plugin::{ErrorMap, ErrorInfo};\n+\n+pub use self::Uniqueness::*;\n+\n+// Default metadata directory to use for extended error JSON.\n+const ERROR_METADATA_DIR_DEFAULT: &'static str = \"tmp/extended-errors\";\n+\n+// The name of the environment variable that sets the metadata dir.\n+const ERROR_METADATA_VAR: &'static str = \"ERROR_METADATA_DIR\";\n+\n+/// JSON encodable/decodable version of `ErrorInfo`.\n+#[derive(PartialEq, RustcDecodable, RustcEncodable)]\n+pub struct ErrorMetadata {\n+    pub description: Option<String>,\n+    pub use_site: Option<ErrorLocation>\n+}\n+\n+/// Mapping from error codes to metadata that can be (de)serialized.\n+pub type ErrorMetadataMap = BTreeMap<String, ErrorMetadata>;\n+\n+/// JSON encodable error location type with filename and line number.\n+#[derive(PartialEq, RustcDecodable, RustcEncodable)]\n+pub struct ErrorLocation {\n+    pub filename: String,\n+    pub line: usize\n+}\n+\n+impl ErrorLocation {\n+    /// Create an error location from a span.\n+    pub fn from_span(ecx: &ExtCtxt, sp: Span) -> ErrorLocation {\n+        let loc = ecx.codemap().lookup_char_pos_adj(sp.lo);\n+        ErrorLocation {\n+            filename: loc.filename,\n+            line: loc.line\n+        }\n+    }\n+}\n+\n+/// Type for describing the uniqueness of a set of error codes, as returned by `check_uniqueness`.\n+pub enum Uniqueness {\n+    /// All errors in the set checked are unique according to the metadata files checked.\n+    Unique,\n+    /// One or more errors in the set occur in another metadata file.\n+    /// This variant contains the first duplicate error code followed by the name\n+    /// of the metadata file where the duplicate appears.\n+    Duplicate(String, String)\n+}\n+\n+/// Get the directory where metadata files should be stored.\n+pub fn get_metadata_dir() -> PathBuf {\n+    match env::var(ERROR_METADATA_VAR) {\n+        Ok(v) => From::from(v),\n+        Err(_) => From::from(ERROR_METADATA_DIR_DEFAULT)\n+    }\n+}\n+\n+/// Get the path where error metadata for the set named by `name` should be stored.\n+fn get_metadata_path(name: &str) -> PathBuf {\n+    get_metadata_dir().join(format!(\"{}.json\", name))\n+}\n+\n+/// Check that the errors in `err_map` aren't present in any metadata files in the\n+/// metadata directory except the metadata file corresponding to `name`.\n+pub fn check_uniqueness(name: &str, err_map: &ErrorMap) -> Result<Uniqueness, Box<Error>> {\n+    let metadata_dir = get_metadata_dir();\n+    let metadata_path = get_metadata_path(name);\n+\n+    // Create the error directory if it does not exist.\n+    try!(create_dir_all(&metadata_dir));\n+\n+    // Check each file in the metadata directory.\n+    for entry in try!(read_dir(&metadata_dir)) {\n+        let path = try!(entry).path();\n+\n+        // Skip any existing file for this set.\n+        if path == metadata_path {\n+            continue;\n+        }\n+\n+        // Read the metadata file into a string.\n+        let mut metadata_str = String::new();\n+        try!(\n+            File::open(&path).and_then(|mut f|\n+            f.read_to_string(&mut metadata_str))\n+        );\n+\n+        // Parse the JSON contents.\n+        let metadata: ErrorMetadataMap = try!(json::decode(&metadata_str));\n+\n+        // Check for duplicates.\n+        for err in err_map.keys() {\n+            let err_code = err.as_str();\n+            if metadata.contains_key(err_code) {\n+                return Ok(Duplicate(\n+                    err_code.to_string(),\n+                    path.to_string_lossy().into_owned()\n+                ));\n+            }\n+        }\n+    }\n+\n+    Ok(Unique)\n+}\n+\n+/// Write metadata for the errors in `err_map` to disk, to a file corresponding to `name`.\n+pub fn output_metadata(ecx: &ExtCtxt, name: &str, err_map: &ErrorMap)\n+    -> Result<(), Box<Error>>\n+{\n+    let metadata_path = get_metadata_path(name);\n+\n+    // Open the dump file.\n+    let mut dump_file = try!(OpenOptions::new()\n+        .write(true)\n+        .create(true)\n+        .open(&metadata_path)\n+    );\n+\n+    // Construct a serializable map.\n+    let json_map = err_map.iter().map(|(k, &ErrorInfo { description, use_site })| {\n+        let key = k.as_str().to_string();\n+        let value = ErrorMetadata {\n+            description: description.map(|n| n.as_str().to_string()),\n+            use_site: use_site.map(|sp| ErrorLocation::from_span(ecx, sp))\n+        };\n+        (key, value)\n+    }).collect::<ErrorMetadataMap>();\n+\n+    try!(write!(&mut dump_file, \"{}\", as_json(&json_map)));\n+    Ok(())\n+}"}, {"sha": "16841bd90398147b9919e1711c9f72c223deb53f", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 62, "deletions": 34, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -14,6 +14,7 @@ use std::collections::BTreeMap;\n use ast;\n use ast::{Ident, Name, TokenTree};\n use codemap::Span;\n+use diagnostics::metadata::{check_uniqueness, output_metadata, Duplicate};\n use ext::base::{ExtCtxt, MacEager, MacResult};\n use ext::build::AstBuilder;\n use parse::token;\n@@ -24,32 +25,28 @@ use util::small_vector::SmallVector;\n const MAX_DESCRIPTION_WIDTH: usize = 80;\n \n thread_local! {\n-    static REGISTERED_DIAGNOSTICS: RefCell<BTreeMap<Name, Option<Name>>> = {\n+    static REGISTERED_DIAGNOSTICS: RefCell<ErrorMap> = {\n         RefCell::new(BTreeMap::new())\n     }\n }\n-thread_local! {\n-    static USED_DIAGNOSTICS: RefCell<BTreeMap<Name, Span>> = {\n-        RefCell::new(BTreeMap::new())\n-    }\n+\n+/// Error information type.\n+pub struct ErrorInfo {\n+    pub description: Option<Name>,\n+    pub use_site: Option<Span>\n }\n \n+/// Mapping from error codes to metadata.\n+pub type ErrorMap = BTreeMap<Name, ErrorInfo>;\n+\n fn with_registered_diagnostics<T, F>(f: F) -> T where\n-    F: FnOnce(&mut BTreeMap<Name, Option<Name>>) -> T,\n+    F: FnOnce(&mut ErrorMap) -> T,\n {\n     REGISTERED_DIAGNOSTICS.with(move |slot| {\n         f(&mut *slot.borrow_mut())\n     })\n }\n \n-fn with_used_diagnostics<T, F>(f: F) -> T where\n-    F: FnOnce(&mut BTreeMap<Name, Span>) -> T,\n-{\n-    USED_DIAGNOSTICS.with(move |slot| {\n-        f(&mut *slot.borrow_mut())\n-    })\n-}\n-\n pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n@@ -58,23 +55,26 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         (1, Some(&ast::TtToken(_, token::Ident(code, _)))) => code,\n         _ => unreachable!()\n     };\n-    with_used_diagnostics(|diagnostics| {\n-        match diagnostics.insert(code.name, span) {\n-            Some(previous_span) => {\n+\n+    with_registered_diagnostics(|diagnostics| {\n+        match diagnostics.get_mut(&code.name) {\n+            // Previously used errors.\n+            Some(&mut ErrorInfo { description: _, use_site: Some(previous_span) }) => {\n                 ecx.span_warn(span, &format!(\n                     \"diagnostic code {} already used\", &token::get_ident(code)\n                 ));\n                 ecx.span_note(previous_span, \"previous invocation\");\n-            },\n-            None => ()\n-        }\n-        ()\n-    });\n-    with_registered_diagnostics(|diagnostics| {\n-        if !diagnostics.contains_key(&code.name) {\n-            ecx.span_err(span, &format!(\n-                \"used diagnostic code {} not registered\", &token::get_ident(code)\n-            ));\n+            }\n+            // Newly used errors.\n+            Some(ref mut info) => {\n+                info.use_site = Some(span);\n+            }\n+            // Unregistered errors.\n+            None => {\n+                ecx.span_err(span, &format!(\n+                    \"used diagnostic code {} not registered\", &token::get_ident(code)\n+                ));\n+            }\n         }\n     });\n     MacEager::expr(ecx.expr_tuple(span, Vec::new()))\n@@ -116,10 +116,14 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n                 token::get_ident(*code), MAX_DESCRIPTION_WIDTH\n             ));\n         }\n-        raw_msg\n     });\n+    // Add the error to the map.\n     with_registered_diagnostics(|diagnostics| {\n-        if diagnostics.insert(code.name, description).is_some() {\n+        let info = ErrorInfo {\n+            description: description,\n+            use_site: None\n+        };\n+        if diagnostics.insert(code.name, info).is_some() {\n             ecx.span_err(span, &format!(\n                 \"diagnostic code {} already registered\", &token::get_ident(*code)\n             ));\n@@ -143,19 +147,43 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                                           span: Span,\n                                           token_tree: &[TokenTree])\n                                           -> Box<MacResult+'cx> {\n-    let name = match (token_tree.len(), token_tree.get(0)) {\n-        (1, Some(&ast::TtToken(_, token::Ident(ref name, _)))) => name,\n+    assert_eq!(token_tree.len(), 3);\n+    let (crate_name, name) = match (&token_tree[0], &token_tree[2]) {\n+        (\n+            // Crate name.\n+            &ast::TtToken(_, token::Ident(ref crate_name, _)),\n+            // DIAGNOSTICS ident.\n+            &ast::TtToken(_, token::Ident(ref name, _))\n+        ) => (crate_name.as_str(), name),\n         _ => unreachable!()\n     };\n \n+    // Check uniqueness of errors and output metadata.\n+    with_registered_diagnostics(|diagnostics| {\n+        match check_uniqueness(crate_name, &*diagnostics) {\n+            Ok(Duplicate(err, location)) => {\n+                ecx.span_err(span, &format!(\n+                    \"error {} from `{}' also found in `{}'\",\n+                    err, crate_name, location\n+                ));\n+            },\n+            Ok(_) => (),\n+            Err(e) => panic!(\"{}\", e.description())\n+        }\n+\n+        output_metadata(&*ecx, crate_name, &*diagnostics).ok().expect(\"metadata output error\");\n+    });\n+\n+    // Construct the output expression.\n     let (count, expr) =\n         with_registered_diagnostics(|diagnostics| {\n             let descriptions: Vec<P<ast::Expr>> =\n-                diagnostics.iter().filter_map(|(code, description)| {\n-                    description.map(|description| {\n+                diagnostics.iter().filter_map(|(code, info)| {\n+                    info.description.map(|description| {\n                         ecx.expr_tuple(span, vec![\n                             ecx.expr_str(span, token::get_name(*code)),\n-                            ecx.expr_str(span, token::get_name(description))])\n+                            ecx.expr_str(span, token::get_name(description))\n+                        ])\n                     })\n                 }).collect();\n             (descriptions.len(), ecx.expr_vec(span, descriptions))"}, {"sha": "4d9d71fe56e9b36640316f071ac43f7ba2643f99", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -69,6 +69,7 @@ pub mod diagnostics {\n     pub mod macros;\n     pub mod plugin;\n     pub mod registry;\n+    pub mod metadata;\n }\n \n pub mod syntax {"}, {"sha": "8745cbecf913704df7cfa2c17631bb243b79a8a3", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d27230bb6d45eeabf13c0d9e5605636840af01c2/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=d27230bb6d45eeabf13c0d9e5605636840af01c2", "patch": "@@ -49,7 +49,7 @@ fn basic_sess(sysroot: PathBuf) -> Session {\n     opts.output_types = vec![OutputTypeExe];\n     opts.maybe_sysroot = Some(sysroot);\n \n-    let descriptions = Registry::new(&rustc::diagnostics::DIAGNOSTICS);\n+    let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let sess = build_session(opts, None, descriptions);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     sess"}]}