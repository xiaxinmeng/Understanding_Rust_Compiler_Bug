{"sha": "7b30f5c2563a27e45593aa72b7f34ee49f62144f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMzBmNWMyNTYzYTI3ZTQ1NTkzYWE3MmI3ZjM0ZWU0OWY2MjE0NGY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-11-25T17:36:11Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-11-30T21:10:47Z"}, "message": "Better docs for the str primitive\n\nPart of #29338", "tree": {"sha": "b8594aaeb16387e255aad88d63bc3e3c16962401", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8594aaeb16387e255aad88d63bc3e3c16962401"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b30f5c2563a27e45593aa72b7f34ee49f62144f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b30f5c2563a27e45593aa72b7f34ee49f62144f", "html_url": "https://github.com/rust-lang/rust/commit/7b30f5c2563a27e45593aa72b7f34ee49f62144f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b30f5c2563a27e45593aa72b7f34ee49f62144f/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edf2198f5fdc4488b354824f6d6947353ae80bcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/edf2198f5fdc4488b354824f6d6947353ae80bcc", "html_url": "https://github.com/rust-lang/rust/commit/edf2198f5fdc4488b354824f6d6947353ae80bcc"}], "stats": {"total": 879, "additions": 622, "deletions": 257}, "files": [{"sha": "6599b04352fed1f9cda7de325a47bef406d8bcd5", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 579, "deletions": 234, "changes": 813, "blob_url": "https://github.com/rust-lang/rust/blob/7b30f5c2563a27e45593aa72b7f34ee49f62144f/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b30f5c2563a27e45593aa72b7f34ee49f62144f/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7b30f5c2563a27e45593aa72b7f34ee49f62144f", "patch": "@@ -164,17 +164,27 @@ impl ToOwned for str {\n     }\n }\n \n-/// Any string that can be represented as a slice.\n+/// Methods for string slices.\n #[lang = \"str\"]\n #[cfg(not(test))]\n impl str {\n-    /// Returns the length of `self` in bytes.\n+    /// Returns the length of `self`.\n+    ///\n+    /// This length is in bytes, not [`char`]s or graphemes. In other words,\n+    /// it may not be what a human considers the length of the string.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// assert_eq!(\"foo\".len(), 3);\n-    /// assert_eq!(\"\u0192oo\".len(), 4); // fancy f!\n+    /// let len = \"foo\".len();\n+    /// assert_eq!(3, len);\n+    ///\n+    /// let len = \"\u0192oo\".len(); // fancy f!\n+    /// assert_eq!(4, len);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -186,8 +196,14 @@ impl str {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// assert!(\"\".is_empty());\n+    /// let s = \"\";\n+    /// assert!(s.is_empty());\n+    ///\n+    /// let s = \"not empty\";\n+    /// assert!(!s.is_empty());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -232,53 +248,77 @@ impl str {\n         core_str::StrExt::is_char_boundary(self, index)\n     }\n \n-    /// Converts `self` to a byte slice.\n+    /// Converts a string slice to a byte slice.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n+    /// let bytes = \"bors\".as_bytes();\n+    /// assert_eq!(b\"bors\", bytes);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline(always)]\n     pub fn as_bytes(&self) -> &[u8] {\n         core_str::StrExt::as_bytes(self)\n     }\n \n-    /// Returns a raw pointer to the `&str`'s buffer.\n+    /// Converts a string slice to a raw pointer.\n     ///\n-    /// The caller must ensure that the string outlives this pointer, and\n-    /// that it is not\n-    /// reallocated (e.g. by pushing to the string).\n+    /// As string slices are a slice of bytes, the raw pointer points to a\n+    /// `u8`. This pointer will be pointing to the first byte of the string\n+    /// slice.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = \"Hello\";\n-    /// let p = s.as_ptr();\n+    /// let ptr = s.as_ptr();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn as_ptr(&self) -> *const u8 {\n         core_str::StrExt::as_ptr(self)\n     }\n \n-    /// Takes a bytewise slice from a string.\n+    /// Creates a string slice from another string slice, bypassing safety\n+    /// checks.\n     ///\n-    /// Returns the substring from [`begin`..`end`).\n+    /// This new slice goes from `begin` to `end`, including `begin` but\n+    /// excluding `end`.\n+    ///\n+    /// To get a mutable string slice instead, see the\n+    /// [`slice_mut_unchecked()`] method.\n+    ///\n+    /// [`slice_mut_unchecked()`]: #method.slice_mut_unchecked\n     ///\n     /// # Safety\n     ///\n-    /// Caller must check both UTF-8 sequence boundaries and the boundaries\n-    /// of the entire slice as well.\n+    /// Callers of this function are responsible that three preconditions are\n+    /// satisifed:\n+    ///\n+    /// * `begin` must come before `end`.\n+    /// * `begin` and `end` must be bye positions within the string slice.\n+    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// unsafe {\n-    ///     assert_eq!(s.slice_unchecked(0, 21), \"L\u00f6we \u8001\u864e L\u00e9opard\");\n+    ///     assert_eq!(\"L\u00f6we \u8001\u864e L\u00e9opard\", s.slice_unchecked(0, 21));\n+    /// }\n+    ///\n+    /// let s = \"Hello, world!\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(\"world\", s.slice_unchecked(7, 12));\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -287,18 +327,32 @@ impl str {\n         core_str::StrExt::slice_unchecked(self, begin, end)\n     }\n \n-    /// Takes a bytewise mutable slice from a string.\n+    /// Creates a string slice from another string slice, bypassing safety\n+    /// checks.\n+    ///\n+    /// This new slice goes from `begin` to `end`, including `begin` but\n+    /// excluding `end`.\n+    ///\n+    /// To get an immutable string slice instead, see the\n+    /// [`slice_unchecked()`] method.\n+    ///\n+    /// [`slice_unchecked()`]: #method.slice_unchecked\n     ///\n-    /// Same as `slice_unchecked`, but works with `&mut str` instead of `&str`.\n+    /// # Safety\n+    ///\n+    /// Callers of this function are responsible that three preconditions are\n+    /// satisifed:\n+    ///\n+    /// * `begin` must come before `end`.\n+    /// * `begin` and `end` must be bye positions within the string slice.\n+    /// * `begin` and `end` must lie on UTF-8 sequence boundaries.\n     #[stable(feature = \"str_slice_mut\", since = \"1.5.0\")]\n     #[inline]\n     pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n         core_str::StrExt::slice_mut_unchecked(self, begin, end)\n     }\n \n-    /// Given a byte position, return the next code point and its index.\n-    ///\n-    /// This can be used to iterate over the Unicode code points of a string.\n+    /// Given a byte position, returns the next `char` and its index.\n     ///\n     /// # Panics\n     ///\n@@ -351,9 +405,7 @@ impl str {\n         core_str::StrExt::char_range_at(self, start)\n     }\n \n-    /// Given a byte position, return the previous `char` and its position.\n-    ///\n-    /// This function can be used to iterate over a Unicode code points in reverse.\n+    /// Given a byte position, returns the previous `char` and its position.\n     ///\n     /// Note that Unicode has many features, such as combining marks, ligatures,\n     /// and direction marks, that need to be taken into account to correctly reverse a string.\n@@ -411,7 +463,7 @@ impl str {\n         core_str::StrExt::char_range_at_reverse(self, start)\n     }\n \n-    /// Given a byte position, return the `char` at that position.\n+    /// Given a byte position, returns the `char` at that position.\n     ///\n     /// # Panics\n     ///\n@@ -440,7 +492,7 @@ impl str {\n         core_str::StrExt::char_at(self, i)\n     }\n \n-    /// Given a byte position, return the `char` at that position, counting\n+    /// Given a byte position, returns the `char` at that position, counting\n     /// from the end.\n     ///\n     /// # Panics\n@@ -468,7 +520,7 @@ impl str {\n         core_str::StrExt::char_at_reverse(self, i)\n     }\n \n-    /// Retrieves the first code point from a `&str` and returns it.\n+    /// Retrieves the first `char` from a `&str` and returns it.\n     ///\n     /// Note that a single Unicode character (grapheme cluster)\n     /// can be composed of multiple `char`s.\n@@ -506,24 +558,33 @@ impl str {\n \n     /// Divide one string slice into two at an index.\n     ///\n-    /// The index `mid` is a byte offset from the start of the string\n-    /// that must be on a `char` boundary.\n+    /// The argument, `mid`, should be a byte offset from the start of the\n+    /// string. It must also be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two slices returned go from the start of the string slice to `mid`,\n+    /// and from `mid` to the end of the string slice.\n     ///\n-    /// Return slices `&self[..mid]` and `&self[mid..]`.\n+    /// To get mutable string slices instead, see the [`split_at_mut()`]\n+    /// method.\n+    ///\n+    /// [`split_at_mut()`]: #method.split_at_mut\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `mid` is beyond the last code point of the string,\n-    /// or if it is not on a `char` boundary.\n+    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n+    /// beyond the last code point of the string slice.\n     ///\n     /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let first_space = s.find(' ').unwrap_or(s.len());\n-    /// let (a, b) = s.split_at(first_space);\n+    /// let s = \"Per Martin-L\u00f6f\";\n+    ///\n+    /// let (first, last) = s.split_at(3);\n     ///\n-    /// assert_eq!(a, \"L\u00f6we\");\n-    /// assert_eq!(b, \" \u8001\u864e L\u00e9opard\");\n+    /// assert_eq!(\"Per\", first);\n+    /// assert_eq!(\" Martin-L\u00f6f\", last);\n     /// ```\n     #[inline]\n     #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n@@ -532,138 +593,250 @@ impl str {\n     }\n \n     /// Divide one mutable string slice into two at an index.\n+    ///\n+    /// The argument, `mid`, should be a byte offset from the start of the\n+    /// string. It must also be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two slices returned go from the start of the string slice to `mid`,\n+    /// and from `mid` to the end of the string slice.\n+    ///\n+    /// To get immutable string slices instead, see the [`split_at()`] method.\n+    ///\n+    /// [`split_at()`]: #method.split_at\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is not on a UTF-8 code point boundary, or if it is\n+    /// beyond the last code point of the string slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \"Per Martin-L\u00f6f\";\n+    ///\n+    /// let (first, last) = s.split_at(3);\n+    ///\n+    /// assert_eq!(\"Per\", first);\n+    /// assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"str_split_at\", since = \"1.4.0\")]\n     pub fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str) {\n         core_str::StrExt::split_at_mut(self, mid)\n     }\n \n-    /// An iterator over the code points of `self`.\n+    /// Returns an iterator over the `char`s of a string slice.\n     ///\n-    /// In Unicode relationship between code points and characters is complex.\n-    /// A single character may be composed of multiple code points\n-    /// (e.g. diacritical marks added to a letter), and a single code point\n-    /// (e.g. Hangul syllable) may contain multiple characters.\n+    /// As a string slice consists of valid UTF-8, we can iterate through a\n+    /// string slice by [`char`]. This method returns such an iterator.\n     ///\n-    /// For iteration over human-readable characters a grapheme cluster iterator\n-    /// may be more appropriate. See the [unicode-segmentation crate][1].\n+    /// It's important to remember that [`char`] represents a Unicode Scalar\n+    /// Value, and may not match your idea of what a 'character' is. Iteration\n+    /// over grapheme clusters may be what you actually want.\n     ///\n-    /// [1]: https://crates.io/crates/unicode-segmentation\n+    /// [`char`]: ../primitive.char.html\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let word = \"goodbye\";\n+    ///\n+    /// let count = word.chars().count();\n+    /// assert_eq!(7, count);\n+    ///\n+    /// let mut chars = word.chars();\n+    ///\n+    /// assert_eq!(Some('g'), chars.next());\n+    /// assert_eq!(Some('o'), chars.next());\n+    /// assert_eq!(Some('o'), chars.next());\n+    /// assert_eq!(Some('d'), chars.next());\n+    /// assert_eq!(Some('b'), chars.next());\n+    /// assert_eq!(Some('y'), chars.next());\n+    /// assert_eq!(Some('e'), chars.next());\n+    ///\n+    /// assert_eq!(None, chars.next());\n     /// ```\n-    /// let v: Vec<char> = \"ASCII z\u0307o\u0301\u0142c\u0301 \ud83c\udde8\ud83c\udded \ud55c\".chars().collect();\n     ///\n-    /// assert_eq!(v, ['A', 'S', 'C', 'I', 'I', ' ',\n-    ///     'z', '\\u{307}', 'o', '\\u{301}', '\u0142', 'c', '\\u{301}', ' ',\n-    ///     '\\u{1f1e8}', '\\u{1f1ed}', ' ', '\ud55c']);\n+    /// Remember, `char`s may not match your human intuition about characters:\n+    ///\n+    /// ```\n+    /// let y = \"y\u0306\";\n+    ///\n+    /// let mut chars = y.chars();\n+    ///\n+    /// assert_eq!(Some('y'), chars.next()); // not 'y\u0306'\n+    /// assert_eq!(Some('\\u{0306}'), chars.next());\n+    ///\n+    /// assert_eq!(None, chars.next());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chars(&self) -> Chars {\n         core_str::StrExt::chars(self)\n     }\n-\n-    /// An iterator over the `char`s of `self` and their byte offsets.\n+    /// Returns an iterator over the `char`s of a string slice, and their\n+    /// positions.\n+    ///\n+    /// As a string slice consists of valid UTF-8, we can iterate through a\n+    /// string slice by `char`. This method returns an iterator of both\n+    /// these `char`s, as well as their byte positions.\n+    ///\n+    /// The iterator yields tuples. The position is first, the `char` is\n+    /// second.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let v: Vec<(usize, char)> = \"A\ud83c\udde8\ud83c\udded\".char_indices().collect();\n-    /// let b = vec![(0, 'A'), (1, '\\u{1f1e8}'), (5, '\\u{1f1ed}')];\n+    /// let word = \"goodbye\";\n+    ///\n+    /// let count = word.char_indices().count();\n+    /// assert_eq!(7, count);\n+    ///\n+    /// let mut char_indices = word.char_indices();\n+    ///\n+    /// assert_eq!(Some((0, 'g')), char_indices.next());\n+    /// assert_eq!(Some((1, 'o')), char_indices.next());\n+    /// assert_eq!(Some((2, 'o')), char_indices.next());\n+    /// assert_eq!(Some((3, 'd')), char_indices.next());\n+    /// assert_eq!(Some((4, 'b')), char_indices.next());\n+    /// assert_eq!(Some((5, 'y')), char_indices.next());\n+    /// assert_eq!(Some((6, 'e')), char_indices.next());\n+    ///\n+    /// assert_eq!(None, char_indices.next());\n+    /// ```\n+    ///\n+    /// Remember, `char`s may not match your human intuition about characters:\n     ///\n-    /// assert_eq!(v, b);\n+    /// ```\n+    /// let y = \"y\u0306\";\n+    ///\n+    /// let mut char_indices = y.char_indices();\n+    ///\n+    /// assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y\u0306')\n+    /// assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n+    ///\n+    /// assert_eq!(None, char_indices.next());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn char_indices(&self) -> CharIndices {\n         core_str::StrExt::char_indices(self)\n     }\n \n-    /// An iterator over the bytes of `self`.\n+    /// An iterator over the bytes of a string slice.\n+    ///\n+    /// As a string slice consists of a sequence of bytes, we can iterate\n+    /// through a string slice by byte. This method returns such an iterator.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let v: Vec<u8> = \"bors\".bytes().collect();\n+    /// let mut bytes = \"bors\".bytes();\n     ///\n-    /// assert_eq!(v, b\"bors\".to_vec());\n+    /// assert_eq!(Some(b'b'), bytes.next());\n+    /// assert_eq!(Some(b'o'), bytes.next());\n+    /// assert_eq!(Some(b'r'), bytes.next());\n+    /// assert_eq!(Some(b's'), bytes.next());\n+    ///\n+    /// assert_eq!(None, bytes.next());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn bytes(&self) -> Bytes {\n         core_str::StrExt::bytes(self)\n     }\n \n-    /// An iterator over the non-empty substrings of `self` which contain no whitespace,\n-    /// and which are separated by any amount of whitespace.\n+    /// Split a string slice by whitespace.\n+    ///\n+    /// The iterator returned will return string slices that are sub-slices of\n+    /// the original string slice, separated by any amount of whitespace.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let some_words = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\";\n-    /// let v: Vec<&str> = some_words.split_whitespace().collect();\n+    /// let mut iter = \"A few words\".split_whitespace();\n     ///\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// assert_eq!(Some(\"A\"), iter.next());\n+    /// assert_eq!(Some(\"few\"), iter.next());\n+    /// assert_eq!(Some(\"words\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n+    /// ```\n+    ///\n+    /// All kinds of whitespace are considered:\n+    ///\n+    /// ```\n+    /// let mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\n+    /// assert_eq!(Some(\"Mary\"), iter.next());\n+    /// assert_eq!(Some(\"had\"), iter.next());\n+    /// assert_eq!(Some(\"a\"), iter.next());\n+    /// assert_eq!(Some(\"little\"), iter.next());\n+    /// assert_eq!(Some(\"lamb\"), iter.next());\n+    ///\n+    /// assert_eq!(None, iter.next());\n     /// ```\n     #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n     #[inline]\n     pub fn split_whitespace(&self) -> SplitWhitespace {\n         UnicodeStr::split_whitespace(self)\n     }\n \n-    /// An iterator over the lines of a string, separated by `\\n` or `\\r\\n`.\n+    /// An iterator over the lines of a string, as string slices.\n     ///\n-    /// This does not include the empty string after a trailing newline or CRLF.\n+    /// Lines are ended with either a newline (`\\n`) or a carriage return with\n+    /// a line feed (`\\r\\n`).\n+    ///\n+    /// The final line ending is optional.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let four_lines = \"foo\\nbar\\n\\r\\nbaz\";\n-    /// let v: Vec<&str> = four_lines.lines().collect();\n+    /// let text = \"foo\\r\\nbar\\n\\nbaz\\n\";\n+    /// let mut lines = text.lines();\n     ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(Some(\"foo\"), lines.next());\n+    /// assert_eq!(Some(\"bar\"), lines.next());\n+    /// assert_eq!(Some(\"\"), lines.next());\n+    /// assert_eq!(Some(\"baz\"), lines.next());\n+    ///\n+    /// assert_eq!(None, lines.next());\n     /// ```\n     ///\n-    /// Leaving off the trailing character:\n+    /// The final line ending isn't required:\n     ///\n     /// ```\n-    /// let four_lines = \"foo\\r\\nbar\\n\\nbaz\\n\";\n-    /// let v: Vec<&str> = four_lines.lines().collect();\n+    /// let text = \"foo\\nbar\\n\\r\\nbaz\";\n+    /// let mut lines = text.lines();\n+    ///\n+    /// assert_eq!(Some(\"foo\"), lines.next());\n+    /// assert_eq!(Some(\"bar\"), lines.next());\n+    /// assert_eq!(Some(\"\"), lines.next());\n+    /// assert_eq!(Some(\"baz\"), lines.next());\n     ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(None, lines.next());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn lines(&self) -> Lines {\n         core_str::StrExt::lines(self)\n     }\n \n-    /// An iterator over the lines of a string, separated by either\n-    /// `\\n` or `\\r\\n`.\n-    ///\n-    /// As with `.lines()`, this does not include an empty trailing line.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\";\n-    /// let v: Vec<&str> = four_lines.lines_any().collect();\n-    ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n-    ///\n-    /// Leaving off the trailing character:\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n-    /// let v: Vec<&str> = four_lines.lines_any().collect();\n-    ///\n-    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n-    /// ```\n+    /// An iterator over the lines of a string.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.4.0\", reason = \"use lines() instead now\")]\n     #[inline]\n@@ -680,38 +853,57 @@ impl str {\n         Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n     }\n \n-    /// Returns `true` if `self` contains another `&str`.\n+    /// Returns `true` if the given `&str` is a sub-slice of this string slice.\n+    ///\n+    /// Returns `false` if it's not.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// assert!(\"bananas\".contains(\"nana\"));\n+    /// let bananas = \"bananas\";\n     ///\n-    /// assert!(!\"bananas\".contains(\"foobar\"));\n+    /// assert!(bananas.contains(\"nana\"));\n+    /// assert!(!bananas.contains(\"apples\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         core_str::StrExt::contains(self, pat)\n     }\n \n-    /// Returns `true` if the given `&str` is a prefix of the string.\n+    /// Returns `true` if the given `&str` is a prefix of this string slice.\n+    ///\n+    /// Returns `false` if it's not.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// assert!(\"banana\".starts_with(\"ba\"));\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.starts_with(\"bana\"));\n+    /// assert!(!bananas.starts_with(\"nana\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         core_str::StrExt::starts_with(self, pat)\n     }\n \n-    /// Returns true if the given `&str` is a suffix of the string.\n+    /// Returns `true` if the given `&str` is a suffix of this string slice.\n+    ///\n+    /// Returns `false` if not.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```rust\n-    /// assert!(\"banana\".ends_with(\"nana\"));\n+    /// let bananas = \"bananas\";\n+    ///\n+    /// assert!(bananas.ends_with(\"anas\"));\n+    /// assert!(!bananas.ends_with(\"nana\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n@@ -720,14 +912,15 @@ impl str {\n         core_str::StrExt::ends_with(self, pat)\n     }\n \n-    /// Returns the byte index of the first character of `self` that matches\n-    /// the pattern, if it\n-    /// exists.\n+    /// Returns the byte index of the first character of this string slice that\n+    /// matches the pattern.\n     ///\n-    /// Returns `None` if it doesn't exist.\n+    /// Returns `None` if the pattern doesn't match.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines if a character matches.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Examples\n     ///\n@@ -739,7 +932,6 @@ impl str {\n     /// assert_eq!(s.find('L'), Some(0));\n     /// assert_eq!(s.find('\u00e9'), Some(14));\n     /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n-    ///\n     /// ```\n     ///\n     /// More complex patterns with closures:\n@@ -764,14 +956,15 @@ impl str {\n         core_str::StrExt::find(self, pat)\n     }\n \n-    /// Returns the byte index of the last character of `self` that\n-    /// matches the pattern, if it\n-    /// exists.\n+    /// Returns the byte index of the last character of this string slice that\n+    /// matches the pattern.\n     ///\n-    /// Returns `None` if it doesn't exist.\n+    /// Returns `None` if the pattern doesn't match.\n     ///\n-    /// The pattern can be a simple `&str`, `char`,\n-    /// or a closure that determines if a character matches.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Examples\n     ///\n@@ -808,22 +1001,25 @@ impl str {\n         core_str::StrExt::rfind(self, pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern.\n+    /// An iterator over substrings of this string slice, separated by\n+    /// characters matched by a pattern.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split. Additional libraries might provide more complex\n-    /// patterns like regular expressions.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator will be double ended if the pattern allows a\n-    /// reverse search and forward/reverse search yields the same elements.\n-    /// This is true for, eg, `char` but not\n-    /// for `&str`.\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n     /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, `rsplit()` can be used.\n+    /// from a forward search, the [`rsplit()`] method can be used.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    /// [`rsplit()`]: #method.rsplit\n     ///\n     /// # Examples\n     ///\n@@ -882,36 +1078,39 @@ impl str {\n     /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n     /// ```\n     ///\n-    /// Use [`.split_whitespace()`][split_whitespace] for this behavior.\n+    /// Use [`split_whitespace()`] for this behavior.\n     ///\n-    /// [split_whitespace]: #method.split_whitespace\n+    /// [`split_whitespace()`]: #method.split_whitespace\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n         core_str::StrExt::split(self, pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern and yielded in reverse order.\n+    /// An iterator over substrings of the given string slice, separated by\n+    /// characters matched by a pattern and yielded in reverse order.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator requires that the pattern supports a\n-    /// reverse search,\n-    /// and it will be double ended if a forward/reverse search yields\n-    /// the same elements.\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    ///\n+    /// For iterating from the front, the [`split()`] method can be used.\n     ///\n-    /// For iterating from the front, `split()` can be used.\n+    /// [`split()`]: #method.split\n     ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n     /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n@@ -938,32 +1137,38 @@ impl str {\n         core_str::StrExt::rsplit(self, pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by a pattern.\n+    /// An iterator over substrings of the given string slice, separated by\n+    /// characters matched by a pattern.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns\n-    /// like regular expressions.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n     ///\n-    /// Equivalent to `split`, except that the trailing substring\n+    /// Equivalent to [`split()`], except that the trailing substring\n     /// is skipped if empty.\n     ///\n+    /// [`split()`]: #method.split\n+    ///\n     /// This method can be used for string data that is _terminated_,\n     /// rather than _separated_ by a pattern.\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator will be double ended if the pattern allows a\n-    /// reverse search\n-    /// and forward/reverse search yields the same elements. This is true\n-    /// for, eg, `char` but not for `&str`.\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    /// [`char`]: primitive.char.html\n     ///\n     /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, `rsplit_terminator()` can be used.\n+    /// from a forward search, the [`rsplit_terminator()`] method can be used.\n+    ///\n+    /// [`rsplit_terminator()`]: #method.rsplit_terminator\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n     /// assert_eq!(v, [\"A\", \"B\"]);\n@@ -996,7 +1201,10 @@ impl str {\n     /// reverse search, and it will be double ended if a forward/reverse\n     /// search yields the same elements.\n     ///\n-    /// For iterating from the front, `split_terminator()` can be used.\n+    /// For iterating from the front, the [`split_terminator()`] method can be\n+    /// used.\n+    ///\n+    /// [`split_terminator()`]: #method.split_terminator\n     ///\n     /// # Examples\n     ///\n@@ -1014,23 +1222,26 @@ impl str {\n         core_str::StrExt::rsplit_terminator(self, pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by a pattern,\n-    /// restricted to returning\n-    /// at most `count` items.\n+    /// An iterator over substrings of the given string slice, separated by a\n+    /// pattern, restricted to returning at most `count` items.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n-    /// string.\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    /// string slice.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines the\n+    /// split.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Iterator behavior\n     ///\n     /// The returned iterator will not be double ended, because it is\n     /// not efficient to support.\n     ///\n-    /// If the pattern allows a reverse search, `rsplitn()` can be used.\n+    /// If the pattern allows a reverse search, the [`rsplitn()`] method can be\n+    /// used.\n+    ///\n+    /// [`rsplitn()`]: #method.rsplitn\n     ///\n     /// # Examples\n     ///\n@@ -1061,24 +1272,26 @@ impl str {\n         core_str::StrExt::splitn(self, count, pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by a pattern,\n-    /// starting from the end of the string, restricted to returning\n+    /// An iterator over substrings of this string slice, separated by a\n+    /// pattern, starting from the end of the string, restricted to returning\n     /// at most `count` items.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n-    /// string.\n+    /// string slice.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n     /// determines the split.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Iterator behavior\n     ///\n     /// The returned iterator will not be double ended, because it is not\n     /// efficient to support.\n     ///\n-    /// `splitn()` can be used for splitting from the front.\n+    /// For splitting from the front, the [`splitn()`] method can be used.\n+    ///\n+    /// [`splitn()`]: #method.splitn\n     ///\n     /// # Examples\n     ///\n@@ -1108,26 +1321,32 @@ impl str {\n         core_str::StrExt::rsplitn(self, count, pat)\n     }\n \n-    /// An iterator over the matches of a pattern within `self`.\n+    /// An iterator over the matches of a pattern within the given string\n+    /// slice.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n     /// determines if a character matches.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator will be double ended if the pattern allows\n-    /// a reverse search\n-    /// and forward/reverse search yields the same elements. This is true\n-    /// for, eg, `char` but not\n-    /// for `&str`.\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+    /// [`char`]: primitive.char.html\n     ///\n     /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, `rmatches()` can be used.\n+    /// from a forward search, the [`rmatches()`] method can be used.\n+    ///\n+    /// [`rmatches()`]: #method.rmatches\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\n     /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n@@ -1140,25 +1359,30 @@ impl str {\n         core_str::StrExt::matches(self, pat)\n     }\n \n-    /// An iterator over the matches of a pattern within `self`, yielded in\n-    /// reverse order.\n+    /// An iterator over the matches of a pattern within this string slice,\n+    /// yielded in reverse order.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines if a character matches.\n-    /// Additional libraries might provide more complex patterns like\n-    /// regular expressions.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator requires that the pattern supports a\n-    /// reverse search,\n-    /// and it will be double ended if a forward/reverse search yields\n-    /// the same elements.\n+    /// The returned iterator requires that the pattern supports a reverse\n+    /// search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n-    /// For iterating from the front, `matches()` can be used.\n+    /// For iterating from the front, the [`matches()`] method can be used.\n+    ///\n+    /// [`matches`]: #method.matches\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\n     /// assert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n@@ -1173,27 +1397,34 @@ impl str {\n         core_str::StrExt::rmatches(self, pat)\n     }\n \n-    /// An iterator over the disjoint matches of a pattern within `self` as well\n-    /// as the index that the match starts at.\n+    /// An iterator over the disjoint matches of a pattern within this string\n+    /// slice as well as the index that the match starts at.\n     ///\n     /// For matches of `pat` within `self` that overlap, only the indices\n     /// corresponding to the first match are returned.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n-    /// if a character matches. Additional libraries might provide more complex\n-    /// patterns like regular expressions.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines\n+    /// if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Iterator behavior\n     ///\n-    /// The returned iterator will be double ended if the pattern allows a\n-    /// reverse search and forward/reverse search yields the same elements. This\n-    /// is true for, eg, `char` but not for `&str`.\n+    /// The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n+    /// allows a reverse search and forward/reverse search yields the same\n+    /// elements. This is true for, eg, [`char`] but not for `&str`.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n     /// If the pattern allows a reverse search but its results might differ\n-    /// from a forward search, `rmatch_indices()` can be used.\n+    /// from a forward search, the [`rmatch_indices()`] method can be used.\n+    ///\n+    /// [`rmatch_indices()`]: #method.rmatch_indices\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n@@ -1215,20 +1446,27 @@ impl str {\n     /// For matches of `pat` within `self` that overlap, only the indices\n     /// corresponding to the last match are returned.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that determines\n-    /// if a character matches. Additional libraries might provide more complex\n-    /// patterns like regular expressions.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if a\n+    /// character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Iterator behavior\n     ///\n     /// The returned iterator requires that the pattern supports a reverse\n-    /// search, and it will be double ended if a forward/reverse search yields\n-    /// the same elements.\n+    /// search, and it will be a `[DoubleEndedIterator]` if a forward/reverse\n+    /// search yields the same elements.\n+    ///\n+    /// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n     ///\n-    /// For iterating from the front, `match_indices()` can be used.\n+    /// For iterating from the front, the [`match_indices()`] method can be used.\n+    ///\n+    /// [`match_indices()`]: #method.match_indices\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\n     /// assert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n@@ -1246,51 +1484,71 @@ impl str {\n         core_str::StrExt::rmatch_indices(self, pat)\n     }\n \n-    /// Returns a `&str` with leading and trailing whitespace removed.\n+    /// Returns a string slice with leading and trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = \" Hello\\tworld\\t\";\n-    /// assert_eq!(s.trim(), \"Hello\\tworld\");\n+    ///\n+    /// assert_eq!(\"Hello\\tworld\", s.trim());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim(&self) -> &str {\n         UnicodeStr::trim(self)\n     }\n \n-    /// Returns a `&str` with leading whitespace removed.\n+    /// Returns a string slice with leading whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = \" Hello\\tworld\\t\";\n-    /// assert_eq!(s.trim_left(), \"Hello\\tworld\\t\");\n+    ///\n+    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_left(&self) -> &str {\n         UnicodeStr::trim_left(self)\n     }\n \n-    /// Returns a `&str` with trailing whitespace removed.\n+    /// Returns a string slice with trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = \" Hello\\tworld\\t\";\n-    /// assert_eq!(s.trim_right(), \" Hello\\tworld\");\n+    ///\n+    /// assert_eq!(\" Hello\\tworld\", s.trim_right());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_right(&self) -> &str {\n         UnicodeStr::trim_right(self)\n     }\n \n-    /// Returns a string with all pre- and suffixes that match a pattern\n-    /// repeatedly removed.\n+    /// Returns a string slice with all prefixes and suffixes that match a\n+    /// pattern repeatedly removed.\n     ///\n-    /// The pattern can be a simple `char`, or a closure that determines\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines\n     /// if a character matches.\n     ///\n+    /// [`char`]: primtive.char.html\n+    ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n@@ -1315,14 +1573,18 @@ impl str {\n         core_str::StrExt::trim_matches(self, pat)\n     }\n \n-    /// Returns a string with all prefixes that match a pattern\n+    /// Returns a string slice with all prefixes that match a pattern\n     /// repeatedly removed.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n-    /// determines if a character matches.\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n     /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n@@ -1335,12 +1597,14 @@ impl str {\n         core_str::StrExt::trim_left_matches(self, pat)\n     }\n \n-    /// Returns a string with all suffixes that match a pattern\n+    /// Returns a string slice with all suffixes that match a pattern\n     /// repeatedly removed.\n     ///\n-    /// The pattern can be a simple `&str`, `char`, or a closure that\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n     /// determines if a character matches.\n     ///\n+    /// [`char`]: primitive.char.html\n+    ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n@@ -1365,22 +1629,47 @@ impl str {\n         core_str::StrExt::trim_right_matches(self, pat)\n     }\n \n-    /// Parses `self` into the specified type.\n+    /// Parses this string slice into another type.\n+    ///\n+    /// Because `parse()` is so general, it can cause problems with type\n+    /// inference. As such, `parse()` is one of the few times you'll see\n+    /// the syntax affectionately known as the 'turbofish': `::<>`. This\n+    /// helps the inference algorithm understand specifically which type\n+    /// you're trying to parse into.\n+    ///\n+    /// `parse()` can parse any type that implements the [`FromStr`] trait.\n+    ///\n+    /// [`FromStr`]: trait.FromStr.html\n     ///\n     /// # Failure\n     ///\n-    /// Will return `Err` if it's not possible to parse `self` into the type.\n+    /// Will return `Err` if it's not possible to parse this string slice into\n+    /// the desired type.\n     ///\n     /// # Example\n     ///\n+    /// Basic usage\n+    ///\n     /// ```\n-    /// assert_eq!(\"4\".parse::<u32>(), Ok(4));\n+    /// let four: u32 = \"4\".parse().unwrap();\n+    ///\n+    /// assert_eq!(4, four);\n     /// ```\n     ///\n-    /// Failing:\n+    /// Using the 'turbofish' instead of annotationg `four`:\n     ///\n     /// ```\n-    /// assert!(\"j\".parse::<u32>().is_err());\n+    /// let four = \"4\".parse::<u32>();\n+    ///\n+    /// assert_eq!(Ok(4), four);\n+    /// ```\n+    ///\n+    /// Failing to parse:\n+    ///\n+    /// ```\n+    /// let nope = \"j\".parse::<u32>();\n+    ///\n+    /// assert!(nope.is_err());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1390,23 +1679,27 @@ impl str {\n \n     /// Replaces all occurrences of one string with another.\n     ///\n-    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a\n-    /// second `&str` to\n-    /// replace it with. If the original `&str` isn't found, no change occurs.\n+    /// `replace` creates a new [`String`], and copies the data from this string slice into it.\n+    /// While doing so, it attempts to find a sub-`&str`. If it finds it, it replaces it with\n+    /// the replacement string slice.\n+    ///\n+    /// [`String`]: string/struct.String.html\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = \"this is old\";\n     ///\n-    /// assert_eq!(s.replace(\"old\", \"new\"), \"this is new\");\n+    /// assert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\n     /// ```\n     ///\n     /// When a `&str` isn't found:\n     ///\n     /// ```\n     /// let s = \"this is old\";\n-    /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n+    /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn replace(&self, from: &str, to: &str) -> String {\n@@ -1421,13 +1714,40 @@ impl str {\n         result\n     }\n \n-    /// Returns the lowercase equivalent of this string.\n+    /// Returns the lowercase equivalent of this string slice, as a new `String`.\n+    ///\n+    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n+    /// `Lowercase`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = \"HELLO\";\n-    /// assert_eq!(s.to_lowercase(), \"hello\");\n+    ///\n+    /// assert_eq!(\"hello\", s.to_lowercase());\n+    /// ```\n+    ///\n+    /// A tricky example, with sigma:\n+    ///\n+    /// ```\n+    /// let sigma = \"\u03a3\";\n+    ///\n+    /// assert_eq!(\"\u03c3\", sigma.to_lowercase());\n+    ///\n+    /// // but at the end of a word, it's \u03c2, not \u03c3:\n+    /// let odysseus = \"\u1f48\u0394\u03a5\u03a3\u03a3\u0395\u038e\u03a3\";\n+    ///\n+    /// assert_eq!(\"\u1f40\u03b4\u03c5\u03c3\u03c3\u03b5\u03cd\u03c2\", odysseus.to_lowercase());\n+    /// ```\n+    ///\n+    /// Languages without case are not changed:\n+    ///\n+    /// ```\n+    /// let new_year = \"\u519c\u5386\u65b0\u5e74\";\n+    ///\n+    /// assert_eq!(new_year, new_year.to_lowercase());\n     /// ```\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_lowercase(&self) -> String {\n@@ -1465,13 +1785,27 @@ impl str {\n         }\n     }\n \n-    /// Returns the uppercase equivalent of this string.\n+    /// Returns the uppercase equivalent of this string slice, as a new `String`.\n+    ///\n+    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n+    /// `Uppercase`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = \"hello\";\n-    /// assert_eq!(s.to_uppercase(), \"HELLO\");\n+    ///\n+    /// assert_eq!(\"HELLO\", s.to_uppercase());\n+    /// ```\n+    ///\n+    /// Scripts without case are not changed:\n+    ///\n+    /// ```\n+    /// let new_year = \"\u519c\u5386\u65b0\u5e74\";\n+    ///\n+    /// assert_eq!(new_year, new_year.to_uppercase());\n     /// ```\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n@@ -1496,7 +1830,18 @@ impl str {\n         self.chars().flat_map(|c| c.escape_unicode()).collect()\n     }\n \n-    /// Converts the `Box<str>` into a `String` without copying or allocating.\n+    /// Converts a `Box<str>` into a `String` without copying or allocating.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let string = String::from(\"birthday gift\");\n+    /// let boxed_str = string.clone().into_boxed_str();\n+    ///\n+    /// assert_eq!(boxed_str.into_string(), string);\n+    /// ```\n     #[stable(feature = \"box_str\", since = \"1.4.0\")]\n     pub fn into_string(self: Box<str>) -> String {\n         unsafe {"}, {"sha": "867c6ff0b824d6d295951ed34bb252d5e0b2467a", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=7b30f5c2563a27e45593aa72b7f34ee49f62144f", "patch": "@@ -1 +1 @@\n-Subproject commit c27f4167a7706baba1ddbb0a9ab320ec18d097db\n+Subproject commit 867c6ff0b824d6d295951ed34bb252d5e0b2467a"}, {"sha": "e0d2011b293bdbbc87631a00fd93bded44908536", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7b30f5c2563a27e45593aa72b7f34ee49f62144f/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b30f5c2563a27e45593aa72b7f34ee49f62144f/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=7b30f5c2563a27e45593aa72b7f34ee49f62144f", "patch": "@@ -293,44 +293,64 @@ mod prim_slice { }\n \n #[doc(primitive = \"str\")]\n //\n-/// Unicode string slices.\n+/// String slices.\n ///\n-/// Rust's `str` type is one of the core primitive types of the language. `&str`\n-/// is the borrowed string type. This type of string can only be created from\n-/// other strings, unless it is a `&'static str` (see below). It is not possible\n-/// to move out of borrowed strings because they are owned elsewhere.\n+/// The `str` type, also called a 'string slice', is the most primitive string\n+/// type. It is usually seen in its borrowed form, `&str`. It is also the type\n+/// of string literals, `&'static str`.\n+///\n+/// Strings slices are always valid UTF-8.\n+///\n+/// This documentation describes a number of methods and trait implementations\n+/// on the `str` type. For technical reasons, there is additional, separate\n+/// documentation in [the `std::str` module](str/index.html) as well.\n ///\n /// # Examples\n ///\n-/// Here's some code that uses a `&str`:\n+/// String literals are string slices:\n ///\n /// ```\n-/// let s = \"Hello, world.\";\n+/// let hello = \"Hello, world!\";\n+///\n+/// // with an explicit type annotation\n+/// let hello: &'static str = \"Hello, world!\";\n /// ```\n ///\n-/// This `&str` is a `&'static str`, which is the type of string literals.\n-/// They're `'static` because literals are available for the entire lifetime of\n-/// the program.\n+/// They are `'static` because they're stored directly in the final binary, and\n+/// so will be valid for the `'static` duration.\n ///\n-/// You can get a non-`'static` `&str` by taking a slice of a `String`:\n+/// # Representation\n+///\n+/// A `&str` is made up of two components: a pointer to some bytes, and a\n+/// length. You can look at these with the [`.as_ptr()`] and [`len()`] methods:\n ///\n /// ```\n-/// let some_string = \"Hello, world.\".to_string();\n-/// let s = &some_string;\n-/// ```\n+/// use std::slice;\n+/// use std::str;\n ///\n-/// # Representation\n+/// let story = \"Once upon a time...\";\n+///\n+/// let ptr = story.as_ptr();\n+/// let len = story.len();\n ///\n-/// Rust's string type, `str`, is a sequence of Unicode scalar values encoded as\n-/// a stream of UTF-8 bytes. All [strings](../../reference.html#literals) are\n-/// guaranteed to be validly encoded UTF-8 sequences. Additionally, strings are\n-/// not null-terminated and can thus contain null bytes.\n+/// // story has thirteen bytes\n+/// assert_eq!(19, len);\n ///\n-/// The actual representation of `str`s have direct mappings to slices: `&str`\n-/// is the same as `&[u8]`.\n+/// // We can re-build a str out of ptr and len. This is all unsafe becuase\n+/// // we are responsible for making sure the two components are valid:\n+/// let s = unsafe {\n+///     // First, we build a &[u8]...\n+///     let slice = slice::from_raw_parts(ptr, len);\n ///\n-/// *[See also the `std::str` module](str/index.html).*\n+///     // ... and then convert that slice into a string slice\n+///     str::from_utf8(slice)\n+/// };\n+///\n+/// assert_eq!(s, Ok(story));\n+/// ```\n ///\n+/// [`.as_ptr()`]: #method.as_ptr\n+/// [`len()`]: # method.len\n mod prim_str { }\n \n #[doc(primitive = \"tuple\")]"}]}