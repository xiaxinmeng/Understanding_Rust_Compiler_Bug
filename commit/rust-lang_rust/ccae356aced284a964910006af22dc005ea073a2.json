{"sha": "ccae356aced284a964910006af22dc005ea073a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYWUzNTZhY2VkMjg0YTk2NDkxMDAwNmFmMjJkYzAwNWVhMDczYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-12T23:30:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-12T23:30:54Z"}, "message": "auto merge of #17155 : steveklabnik/rust/dherman_fixes, r=brson\n\nFixing more suggestions from @dherman . I made them individual commits in case we want to discuss any of them further.", "tree": {"sha": "1a5dec69b5eaeb8b39860e28c3c32e95ff8ae4f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a5dec69b5eaeb8b39860e28c3c32e95ff8ae4f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccae356aced284a964910006af22dc005ea073a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccae356aced284a964910006af22dc005ea073a2", "html_url": "https://github.com/rust-lang/rust/commit/ccae356aced284a964910006af22dc005ea073a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccae356aced284a964910006af22dc005ea073a2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8780d9c6b5abce83089ca1dafb7efd178569a052", "url": "https://api.github.com/repos/rust-lang/rust/commits/8780d9c6b5abce83089ca1dafb7efd178569a052", "html_url": "https://github.com/rust-lang/rust/commit/8780d9c6b5abce83089ca1dafb7efd178569a052"}, {"sha": "c3943b3c89834db8cbeb7edc0a1e4b0002f11aa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3943b3c89834db8cbeb7edc0a1e4b0002f11aa2", "html_url": "https://github.com/rust-lang/rust/commit/c3943b3c89834db8cbeb7edc0a1e4b0002f11aa2"}], "stats": {"total": 257, "additions": 33, "deletions": 224}, "files": [{"sha": "140536543d93dcbfd662666eac6b205216a19cf5", "filename": "src/doc/guide.md", "status": "modified", "additions": 33, "deletions": 224, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/ccae356aced284a964910006af22dc005ea073a2/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/ccae356aced284a964910006af22dc005ea073a2/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=ccae356aced284a964910006af22dc005ea073a2", "patch": "@@ -130,14 +130,15 @@ the documentation for your shell for more details.\n \n Let's make a new source file next. I'm going to use the syntax `editor\n filename` to represent editing a file in these examples, but you should use\n-whatever method you want. We'll call our file `hello_world.rs`:\n+whatever method you want. We'll call our file `main.rs`:\n \n ```{bash}\n-$ editor hello_world.rs\n+$ editor main.rs\n ```\n \n Rust files always end in a `.rs` extension. If you're using more than one word\n-in your file name, use an underscore. `hello_world.rs` versus `goodbye.rs`.\n+in your file name, use an underscore. `hello_world.rs` rather than\n+`helloworld.rs`.\n \n Now that you've got your file open, type this in:\n \n@@ -150,7 +151,7 @@ fn main() {\n Save the file, and then type this into your terminal window:\n \n ```{bash}\n-$ rustc hello_world.rs\n+$ rustc main.rs\n $ ./hello_world # or hello_world.exe on Windows\n Hello, world!\n ```\n@@ -212,22 +213,22 @@ Finally, actually **compiling** and **running** our program. We can compile\n with our compiler, `rustc`, by passing it the name of our source file:\n \n ```{bash}\n-$ rustc hello_world.rs\n+$ rustc main.rs\n ```\n \n This is similar to `gcc` or `clang`, if you come from a C or C++ background. Rust\n will output a binary executable. You can see it with `ls`:\n \n ```{bash}\n $ ls\n-hello_world  hello_world.rs\n+main  main.rs\n ```\n \n Or on Windows:\n \n ```{bash}\n $ dir\n-hello_world.exe  hello_world.rs\n+main.exe  main.rs\n ```\n \n There are now two files: our source code, with the `.rs` extension, and the\n@@ -284,7 +285,7 @@ do that part first:\n \n ```{bash}\n $ mkdir src\n-$ mv hello_world.rs src/hello_world.rs\n+$ mv main.rs src/main.rs\n ```\n \n Cargo expects your source files to live inside a `src` directory. That leaves\n@@ -452,9 +453,9 @@ let x;\n ...we'll get an error:\n \n ```{ignore}\n-src/hello_world.rs:2:9: 2:10 error: cannot determine a type for this local variable: unconstrained type\n-src/hello_world.rs:2     let x;\n-                             ^\n+src/main.rs:2:9: 2:10 error: cannot determine a type for this local variable: unconstrained type\n+src/main.rs:2     let x;\n+                      ^\n ```\n \n Giving it a type will compile, though:\n@@ -463,7 +464,7 @@ Giving it a type will compile, though:\n let x: int;\n ```\n \n-Let's try it out. Change your `src/hello_world.rs` file to look like this:\n+Let's try it out. Change your `src/main.rs` file to look like this:\n \n ```{rust}\n fn main() {\n@@ -478,8 +479,8 @@ but it will still print \"Hello, world!\":\n \n ```{ignore,notrust}\n    Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n-src/hello_world.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default\n-src/hello_world.rs:2     let x: int;\n+src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default\n+src/main.rs:2     let x: int;\n                              ^\n ```\n \n@@ -500,13 +501,13 @@ And try to build it. You'll get an error:\n ```{bash}\n $ cargo build\n    Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n-src/hello_world.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`\n-src/hello_world.rs:4     println!(\"The value of x is: {}\", x);\n-                                                           ^\n+src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`\n+src/main.rs:4     println!(\"The value of x is: {}\", x);\n+                                                    ^\n note: in expansion of format_args!\n <std macros>:2:23: 2:77 note: expansion site\n <std macros>:1:1: 3:2 note: in expansion of println!\n-src/hello_world.rs:4:5: 4:42 note: expansion site\n+src/main.rs:4:5: 4:42 note: expansion site\n error: aborting due to previous error\n Could not compile `hello_world`.\n ```\n@@ -1318,10 +1319,7 @@ upper bound is exclusive, though, so our loop will print `0` through `9`, not\n \n Rust does not have the \"C style\" `for` loop on purpose. Manually controlling\n each element of the loop is complicated and error prone, even for experienced C\n-developers. There's an old joke that goes, \"There are two hard problems in\n-computer science: naming things, cache invalidation, and off-by-one errors.\"\n-The joke, of course, being that the setup says \"two hard problems\" but then\n-lists three things. This happens quite a bit with \"C style\" `for` loops.\n+developers. \n \n We'll talk more about `for` when we cover **iterator**s, later in the Guide.\n \n@@ -2745,197 +2743,8 @@ $ cargo run\n Hello, world!\n ```\n \n-Nice!\n-\n-There's a common pattern when you're building an executable: you build both an\n-executable and a library, and put most of your logic in the library. That way,\n-other programs can use that library to build their own functionality.\n-\n-Let's do that with our project. If you remember, libraries and executables\n-are both crates, so while our project has one crate now, let's make a second:\n-one for the library, and one for the executable.\n-\n-To make the second crate, open up `src/lib.rs` and put this code in it:\n-\n-```{rust}\n-mod hello {\n-    pub fn print_hello() {\n-        println!(\"Hello, world!\");\n-    }\n-}\n-```\n-\n-And change your `src/main.rs` to look like this:\n-\n-```{rust,ignore}\n-extern crate modules;\n-\n-fn main() {\n-    modules::hello::print_hello();\n-}\n-```\n-\n-There's been a few changes. First, we moved our `hello` module into its own\n-file, `src/lib.rs`. This is the file that Cargo expects a library crate to\n-be named, by convention.\n-\n-Next, we added an `extern crate modules` to the top of our `src/main.rs`. This,\n-as you can guess, lets Rust know that our crate relies on another, external\n-crate. We also had to modify our call to `print_hello`: now that it's in\n-another crate, we need to specify that crate first.\n-\n-This doesn't _quite_ work yet. Try it:\n-\n-```{notrust,ignore}\n-$ cargo build\n-   Compiling modules v0.0.1 (file:///home/you/projects/modules)\n-/home/you/projects/modules/src/lib.rs:2:5: 4:6 warning: code is never used: `print_hello`, #[warn(dead_code)] on by default\n-/home/you/projects/modules/src/lib.rs:2     pub fn print_hello() {\n-/home/you/projects/modules/src/lib.rs:3         println!(\"Hello, world!\");\n-/home/you/projects/modules/src/lib.rs:4     }\n-/home/you/projects/modules/src/main.rs:4:5: 4:32 error: function `print_hello` is private\n-/home/you/projects/modules/src/main.rs:4     modules::hello::print_hello();\n-                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n-error: aborting due to previous error\n-Could not compile `modules`.\n-```\n-\n-First, we get a warning that some code is never used. Odd. Next, we get an error:\n-`print_hello` is private, so we can't call it. Notice that the first error came\n-from `src/lib.rs`, and the second came from `src/main.rs`: cargo is smart enough\n-to build it all with one command. Also, after seeing the second error, the warning\n-makes sense: we never actually call `hello_world`, because we're not allowed to!\n-\n-Just like modules, crates also have private visibility by default. Any modules\n-inside of a crate can only be used by other modules in the crate, unless they\n-use `pub`. In `src/lib.rs`, change this line:\n-\n-```{rust,ignore}\n-mod hello {\n-```\n-\n-To this:\n-\n-```{rust,ignore}\n-pub mod hello {\n-```\n-\n-And everything should work:\n-\n-```{notrust,ignore}\n-$ cargo run\n-   Compiling modules v0.0.1 (file:///home/you/projects/modules)\n-     Running `target/modules`\n-Hello, world!\n-```\n-\n-Let's do one more thing: add a `goodbye` module as well. Imagine a `src/lib.rs`\n-that looks like this:\n-\n-```{rust,ignore}\n-pub mod hello {\n-    pub fn print_hello() {\n-        println!(\"Hello, world!\");\n-    }\n-}\n-\n-pub mod goodbye {\n-    pub fn print_goodbye() {\n-        println!(\"Goodbye for now!\");\n-    }\n-}\n-```\n-\n-Now, these two modules are pretty small, but imagine we've written a real, large\n-program: they could both be huge. So maybe we want to move them into their own\n-files. We can do that pretty easily, and there are two different conventions\n-for doing it. Let's give each a try. First, make `src/lib.rs` look like this:\n-\n-```{rust,ignore}\n-pub mod hello;\n-pub mod goodbye;\n-```\n-\n-This tells Rust that this crate has two public modules: `hello` and `goodbye`.\n-\n-Next, make a `src/hello.rs` that contains this:\n-\n-```{rust,ignore}\n-pub fn print_hello() {\n-    println!(\"Hello, world!\");\n-}\n-```\n-\n-When we include a module like this, we don't need to make the `mod` declaration\n-in `hello.rs`, because it's already been declared in `lib.rs`. `hello.rs` just\n-contains the body of the module which is defined (by the `pub mod hello`) in\n-`lib.rs`.  This helps prevent 'rightward drift': when you end up indenting so\n-many times that your code is hard to read.\n-\n-Finally, make a new directory, `src/goodbye`, and make a new file in it,\n-`src/goodbye/mod.rs`:\n-\n-```{rust,ignore}\n-pub fn print_goodbye() {\n-    println!(\"Bye for now!\");\n-}\n-```\n-\n-Same deal, but we can make a folder with a `mod.rs` instead of `mod_name.rs` in\n-the same directory. If you have a lot of modules, nested folders can make\n-sense.  For example, if the `goodbye` module had its _own_ modules inside of\n-it, putting all of that in a folder helps keep our directory structure tidy.\n-And in fact, if you place the modules in separate files, they're required to be\n-in separate folders.\n-\n-This should all compile as usual:\n-\n-```{notrust,ignore}\n-$ cargo build\n-   Compiling modules v0.0.1 (file:///home/you/projects/modules)\n-```\n-\n-We've seen how the `::` operator can be used to call into modules, but when\n-we have deep nesting like `modules::hello::say_hello`, it can get tedious.\n-That's why we have the `use` keyword.\n-\n-`use` allows us to bring certain names into another scope. For example, here's\n-our main program:\n-\n-```{rust,ignore}\n-extern crate modules;\n-\n-fn main() {\n-    modules::hello::print_hello();\n-}\n-```\n-\n-We could instead write this:\n-\n-```{rust,ignore}\n-extern crate modules;\n-\n-use modules::hello::print_hello;\n-\n-fn main() {\n-    print_hello();\n-}\n-```\n-\n-By bringing `print_hello` into scope, we don't need to qualify it anymore. However,\n-it's considered proper style to do write this code like like this:\n-\n-```{rust,ignore}\n-extern crate modules;\n-\n-use modules::hello;\n-\n-fn main() {\n-    hello::print_hello();\n-}\n-```\n-\n-By just bringing the module into scope, we can keep one level of namespacing.\n+Nice! There are more things we can do with modules, including moving them into\n+their own files. This is enough detail for now.\n \n # Testing\n \n@@ -3801,9 +3610,9 @@ Here's the second note, which lets us know where the first borrow would be over.\n This is useful, because if we wait to try to borrow `x` after this borrow is\n over, then everything will work.\n \n-These rules are very simple, but that doesn't mean that they're easy. For more\n-advanced patterns, please consult the [Lifetime Guide](guide-lifetimes.html).\n-You'll also learn what this type signature with the `'a` syntax is:\n+For more advanced patterns, please consult the [Lifetime\n+Guide](guide-lifetimes.html).  You'll also learn what this type signature with\n+the `'a` syntax is:\n \n ```{rust,ignore}\n pub fn as_maybe_owned(&self) -> MaybeOwned<'a> { ... }\n@@ -4454,14 +4263,14 @@ for num in nums.iter() {\n }\n ```\n \n-There are two reasons for this. First, this is more semantic. We iterate\n-through the entire vector, rather than iterating through indexes, and then\n-indexing the vector. Second, this version is more efficient: the first version\n-will have extra bounds checking because it used indexing, `nums[i]`. But since\n-we yield a reference to each element of the vector in turn with the iterator,\n-there's no bounds checking in the second example. This is very common with\n-iterators: we can ignore unnecessary bounds checks, but still know that we're\n-safe.\n+There are two reasons for this. First, this more directly expresses what we\n+mean. We iterate through the entire vector, rather than iterating through\n+indexes, and then indexing the vector. Second, this version is more efficient:\n+the first version will have extra bounds checking because it used indexing,\n+`nums[i]`. But since we yield a reference to each element of the vector in turn\n+with the iterator, there's no bounds checking in the second example. This is\n+very common with iterators: we can ignore unnecessary bounds checks, but still\n+know that we're safe.\n \n There's another detail here that's not 100% clear because of how `println!`\n works. `num` is actually of type `&int`, that is, it's a reference to an `int`,"}]}