{"sha": "8ff0aac06c73d75d5eebea173889fb2ca94c0c75", "node_id": "C_kwDOAAsO6NoAKDhmZjBhYWMwNmM3M2Q3NWQ1ZWViZWExNzM4ODlmYjJjYTk0YzBjNzU", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-05-13T23:04:51Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-05-13T23:04:51Z"}, "message": "More review feedback\n\n* Store the local crates in an Rc<[CrateNum]>\n* Move all the allocation history into Stacks\n* Clean up the implementation of get_logs_relevant_to a bit", "tree": {"sha": "ac853f60ccbb8b55b67f71fffa230de2fb5e8fb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac853f60ccbb8b55b67f71fffa230de2fb5e8fb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ff0aac06c73d75d5eebea173889fb2ca94c0c75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ff0aac06c73d75d5eebea173889fb2ca94c0c75", "html_url": "https://github.com/rust-lang/rust/commit/8ff0aac06c73d75d5eebea173889fb2ca94c0c75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ff0aac06c73d75d5eebea173889fb2ca94c0c75/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "972b3b340ad99553618e551937d93bf28e2d2f5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/972b3b340ad99553618e551937d93bf28e2d2f5c", "html_url": "https://github.com/rust-lang/rust/commit/972b3b340ad99553618e551937d93bf28e2d2f5c"}], "stats": {"total": 355, "additions": 168, "deletions": 187}, "files": [{"sha": "2198bba4fe238bd392e2ac35430856612520b7ec", "filename": "src/helpers.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ff0aac06c73d75d5eebea173889fb2ca94c0c75/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff0aac06c73d75d5eebea173889fb2ca94c0c75/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=8ff0aac06c73d75d5eebea173889fb2ca94c0c75", "patch": "@@ -1,5 +1,6 @@\n use std::mem;\n use std::num::NonZeroUsize;\n+use std::rc::Rc;\n use std::time::Duration;\n \n use log::trace;\n@@ -797,7 +798,7 @@ pub fn isolation_abort_error(name: &str) -> InterpResult<'static> {\n \n /// Retrieve the list of local crates that should have been passed by cargo-miri in\n /// MIRI_LOCAL_CRATES and turn them into `CrateNum`s.\n-pub fn get_local_crates(tcx: &TyCtxt<'_>) -> Vec<CrateNum> {\n+pub fn get_local_crates(tcx: &TyCtxt<'_>) -> Rc<[CrateNum]> {\n     // Convert the local crate names from the passed-in config into CrateNums so that they can\n     // be looked up quickly during execution\n     let local_crate_names = std::env::var(\"MIRI_LOCAL_CRATES\")\n@@ -811,7 +812,7 @@ pub fn get_local_crates(tcx: &TyCtxt<'_>) -> Vec<CrateNum> {\n             local_crates.push(crate_num);\n         }\n     }\n-    local_crates\n+    Rc::from(local_crates.as_slice())\n }\n \n /// Formats an AllocRange like [0x1..0x3], for use in diagnostics."}, {"sha": "f215f465c00df86beb77beeeb1d356511deb4f58", "filename": "src/machine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ff0aac06c73d75d5eebea173889fb2ca94c0c75/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff0aac06c73d75d5eebea173889fb2ca94c0c75/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=8ff0aac06c73d75d5eebea173889fb2ca94c0c75", "patch": "@@ -6,6 +6,7 @@ use std::cell::RefCell;\n use std::collections::HashSet;\n use std::fmt;\n use std::num::NonZeroU64;\n+use std::rc::Rc;\n use std::time::Instant;\n \n use rand::rngs::StdRng;\n@@ -273,7 +274,7 @@ pub struct Evaluator<'mir, 'tcx> {\n     pub(crate) backtrace_style: BacktraceStyle,\n \n     /// Crates which are considered local for the purposes of error reporting.\n-    pub(crate) local_crates: Vec<CrateNum>,\n+    pub(crate) local_crates: Rc<[CrateNum]>,\n \n     /// Mapping extern static names to their base pointer.\n     extern_statics: FxHashMap<Symbol, Pointer<Tag>>,\n@@ -307,7 +308,6 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n                 config.tracked_pointer_tags.clone(),\n                 config.tracked_call_ids.clone(),\n                 config.tag_raw,\n-                local_crates.clone(),\n             )))\n         } else {\n             None\n@@ -575,6 +575,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 stacked_borrows,\n                 kind,\n                 &ecx.machine.threads,\n+                ecx.machine.local_crates.clone(),\n             ))\n         } else {\n             None"}, {"sha": "8dda4a9e22a0e8f7b742896242712f658b47dece", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 97, "deletions": 54, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/8ff0aac06c73d75d5eebea173889fb2ca94c0c75/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff0aac06c73d75d5eebea173889fb2ca94c0c75/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=8ff0aac06c73d75d5eebea173889fb2ca94c0c75", "patch": "@@ -3,9 +3,9 @@\n \n use log::trace;\n use std::cell::RefCell;\n-use std::collections::HashMap;\n use std::fmt;\n use std::num::NonZeroU64;\n+use std::rc::Rc;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::Mutability;\n@@ -22,7 +22,7 @@ use std::collections::HashSet;\n use crate::*;\n \n pub mod diagnostics;\n-use diagnostics::{AllocHistory, GlobalStateExt, StackExt};\n+use diagnostics::AllocHistory;\n \n use diagnostics::TagHistory;\n \n@@ -97,6 +97,8 @@ pub struct Stack {\n pub struct Stacks {\n     // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n     stacks: RefCell<RangeMap<Stack>>,\n+    /// Stores past operations on this allocation\n+    history: RefCell<AllocHistory>,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -118,10 +120,6 @@ pub struct GlobalStateInner {\n     tracked_call_ids: HashSet<CallId>,\n     /// Whether to track raw pointers.\n     tag_raw: bool,\n-    /// Crates which are considered local for the purposes of error reporting.\n-    local_crates: Vec<CrateNum>,\n-    /// Extra per-allocation information\n-    extras: HashMap<AllocId, AllocHistory>,\n }\n \n /// We need interior mutable access to the global state.\n@@ -174,7 +172,6 @@ impl GlobalStateInner {\n         tracked_pointer_tags: HashSet<PtrId>,\n         tracked_call_ids: HashSet<CallId>,\n         tag_raw: bool,\n-        local_crates: Vec<CrateNum>,\n     ) -> Self {\n         GlobalStateInner {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n@@ -184,8 +181,6 @@ impl GlobalStateInner {\n             tracked_pointer_tags,\n             tracked_call_ids,\n             tag_raw,\n-            local_crates,\n-            extras: HashMap::new(),\n         }\n     }\n \n@@ -331,30 +326,29 @@ impl<'tcx> Stack {\n     /// currently checking.\n     fn check_protector(\n         item: &Item,\n-        provoking_access: Option<(SbTag, AllocId, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n+        provoking_access: Option<(SbTag, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n+        alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n         if let SbTag::Tagged(id) = item.tag {\n             if global.tracked_pointer_tags.contains(&id) {\n                 register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n                     *item,\n-                    provoking_access\n-                        .map(|(tag, _alloc_id, _alloc_range, _size, access)| (tag, access)),\n+                    provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n                 ));\n             }\n         }\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n-                if let Some((tag, alloc_id, alloc_range, offset, _access)) = provoking_access {\n+                if let Some((tag, alloc_range, offset, _access)) = provoking_access {\n                     Err(err_sb_ub(\n                         format!(\n                             \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n                             tag, item\n                         ),\n                         None,\n-                        global.get_stack_history(\n+                        alloc_history.get_logs_relevant_to(\n                             tag,\n-                            alloc_id,\n                             alloc_range,\n                             offset,\n                             Some(item.tag),\n@@ -383,13 +377,14 @@ impl<'tcx> Stack {\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n         threads: &ThreadManager<'_, 'tcx>,\n+        alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self\n-            .find_granting(access, tag)\n-            .ok_or_else(|| self.access_error(access, tag, alloc_id, alloc_range, offset, global))?;\n+        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n+            alloc_history.access_error(access, tag, alloc_id, alloc_range, offset, self)\n+        })?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n@@ -401,10 +396,11 @@ impl<'tcx> Stack {\n                 trace!(\"access: popping item {:?}\", item);\n                 Stack::check_protector(\n                     &item,\n-                    Some((tag, alloc_id, alloc_range, offset, access)),\n+                    Some((tag, alloc_range, offset, access)),\n                     global,\n+                    alloc_history,\n                 )?;\n-                global.log_invalidation(item.tag, alloc_id, alloc_range, threads);\n+                alloc_history.log_invalidation(item.tag, alloc_range, threads);\n             }\n         } else {\n             // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n@@ -421,11 +417,12 @@ impl<'tcx> Stack {\n                     trace!(\"access: disabling item {:?}\", item);\n                     Stack::check_protector(\n                         item,\n-                        Some((tag, alloc_id, alloc_range, offset, access)),\n+                        Some((tag, alloc_range, offset, access)),\n                         global,\n+                        alloc_history,\n                     )?;\n                     item.perm = Permission::Disabled;\n-                    global.log_invalidation(item.tag, alloc_id, alloc_range, threads);\n+                    alloc_history.log_invalidation(item.tag, alloc_range, threads);\n                 }\n             }\n         }\n@@ -441,6 +438,7 @@ impl<'tcx> Stack {\n         tag: SbTag,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalStateInner,\n+        alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n         self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n@@ -449,13 +447,13 @@ impl<'tcx> Stack {\n                 tag, alloc_id,\n                 ),\n                 None,\n-                global.get_stack_history(tag, alloc_id, alloc_range, offset, None),\n+                alloc_history.get_logs_relevant_to(tag, alloc_range, offset, None),\n             )\n         })?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n         for item in self.borrows.drain(..).rev() {\n-            Stack::check_protector(&item, None, global)?;\n+            Stack::check_protector(&item, None, global, alloc_history)?;\n         }\n \n         Ok(())\n@@ -474,14 +472,15 @@ impl<'tcx> Stack {\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n         threads: &ThreadManager<'_, 'tcx>,\n+        alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n         let granting_idx = self.find_granting(access, derived_from).ok_or_else(|| {\n-            self.grant_error(derived_from, new, alloc_id, alloc_range, offset, global)\n+            alloc_history.grant_error(derived_from, new, alloc_id, alloc_range, offset, self)\n         })?;\n \n         // Compute where to put the new item.\n@@ -501,7 +500,14 @@ impl<'tcx> Stack {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access.\n             // This ensures F2b for `Unique`, by removing offending `SharedReadOnly`.\n-            self.access(access, derived_from, (alloc_id, alloc_range, offset), global, threads)?;\n+            self.access(\n+                access,\n+                derived_from,\n+                (alloc_id, alloc_range, offset),\n+                global,\n+                threads,\n+                alloc_history,\n+            )?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n             // on top of `derived_from`, and we want the new item at the top so that we\n@@ -527,22 +533,26 @@ impl<'tcx> Stack {\n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n-    fn new(size: Size, perm: Permission, tag: SbTag) -> Self {\n+    fn new(size: Size, perm: Permission, tag: SbTag, local_crates: Rc<[CrateNum]>) -> Self {\n         let item = Item { perm, tag, protector: None };\n         let stack = Stack { borrows: vec![item] };\n \n-        Stacks { stacks: RefCell::new(RangeMap::new(size, stack)) }\n+        Stacks {\n+            stacks: RefCell::new(RangeMap::new(size, stack)),\n+            history: RefCell::new(AllocHistory::new(local_crates)),\n+        }\n     }\n \n     /// Call `f` on every stack in the range.\n     fn for_each(\n         &self,\n         range: AllocRange,\n-        mut f: impl FnMut(Size, &mut Stack) -> InterpResult<'tcx>,\n+        mut f: impl FnMut(Size, &mut Stack, &mut AllocHistory) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let mut stacks = self.stacks.borrow_mut();\n+        let history = &mut *self.history.borrow_mut();\n         for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack)?;\n+            f(offset, stack, history)?;\n         }\n         Ok(())\n     }\n@@ -551,11 +561,12 @@ impl<'tcx> Stacks {\n     fn for_each_mut(\n         &mut self,\n         range: AllocRange,\n-        mut f: impl FnMut(Size, &mut Stack) -> InterpResult<'tcx>,\n+        mut f: impl FnMut(Size, &mut Stack, &mut AllocHistory) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let stacks = self.stacks.get_mut();\n+        let history = &mut *self.history.borrow_mut();\n         for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack)?;\n+            f(offset, stack, history)?;\n         }\n         Ok(())\n     }\n@@ -569,6 +580,7 @@ impl Stacks {\n         state: &GlobalState,\n         kind: MemoryKind<MiriMemoryKind>,\n         threads: &ThreadManager<'_, '_>,\n+        local_crates: Rc<[CrateNum]>,\n     ) -> Self {\n         let mut extra = state.borrow_mut();\n         let (base_tag, perm) = match kind {\n@@ -602,8 +614,14 @@ impl Stacks {\n                 (tag, Permission::SharedReadWrite)\n             }\n         };\n-        extra.log_creation(None, base_tag, id, alloc_range(Size::ZERO, size), threads);\n-        Stacks::new(size, perm, base_tag)\n+        let stacks = Stacks::new(size, perm, base_tag, local_crates);\n+        stacks.history.borrow_mut().log_creation(\n+            None,\n+            base_tag,\n+            alloc_range(Size::ZERO, size),\n+            threads,\n+        );\n+        stacks\n     }\n \n     #[inline(always)]\n@@ -622,8 +640,15 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let mut state = state.borrow_mut();\n-        self.for_each(range, |offset, stack| {\n-            stack.access(AccessKind::Read, tag, (alloc_id, range, offset), &mut state, threads)\n+        self.for_each(range, |offset, stack, history| {\n+            stack.access(\n+                AccessKind::Read,\n+                tag,\n+                (alloc_id, range, offset),\n+                &mut state,\n+                threads,\n+                history,\n+            )\n         })\n     }\n \n@@ -643,8 +668,15 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let mut state = state.borrow_mut();\n-        self.for_each_mut(range, |offset, stack| {\n-            stack.access(AccessKind::Write, tag, (alloc_id, range, offset), &mut state, threads)\n+        self.for_each_mut(range, |offset, stack, history| {\n+            stack.access(\n+                AccessKind::Write,\n+                tag,\n+                (alloc_id, range, offset),\n+                &mut state,\n+                threads,\n+                history,\n+            )\n         })\n     }\n \n@@ -658,10 +690,9 @@ impl Stacks {\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let mut state = state.borrow_mut();\n-        self.for_each_mut(range, |offset, stack| {\n-            stack.dealloc(tag, (alloc_id, range, offset), &mut state)\n+        self.for_each_mut(range, |offset, stack, history| {\n+            stack.dealloc(tag, (alloc_id, range, offset), &mut state, history)\n         })?;\n-        state.extras.remove(&alloc_id);\n         Ok(())\n     }\n }\n@@ -692,16 +723,20 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         let (alloc_id, base_offset, orig_tag) = this.ptr_get_alloc_id(place.ptr)?;\n \n-        let mem_extra = this.machine.stacked_borrows.as_mut().unwrap().get_mut();\n-        mem_extra.log_creation(\n-            Some(orig_tag),\n-            new_tag,\n-            alloc_id,\n-            alloc_range(base_offset, base_offset + size),\n-            &this.machine.threads,\n-        );\n-        if protect {\n-            mem_extra.log_protector(orig_tag, new_tag, alloc_id, &this.machine.threads);\n+        {\n+            let extra = this.get_alloc_extra(alloc_id)?;\n+            let stacked_borrows =\n+                extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+            let mut alloc_history = stacked_borrows.history.borrow_mut();\n+            alloc_history.log_creation(\n+                Some(orig_tag),\n+                new_tag,\n+                alloc_range(base_offset, base_offset + size),\n+                &this.machine.threads,\n+            );\n+            if protect {\n+                alloc_history.log_protector(orig_tag, new_tag, &this.machine.threads);\n+            }\n         }\n \n         // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n@@ -763,13 +798,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n                     let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n-                    stacked_borrows.for_each(range, |offset, stack| {\n+                    stacked_borrows.for_each(range, |offset, stack, history| {\n                         stack.grant(\n                             orig_tag,\n                             item,\n                             (alloc_id, range, offset),\n                             &mut *global,\n                             &this.machine.threads,\n+                            history,\n                         )\n                     })\n                 })?;\n@@ -785,8 +821,15 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let item = Item { perm, tag: new_tag, protector };\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n-        stacked_borrows.for_each_mut(range, |offset, stack| {\n-            stack.grant(orig_tag, item, (alloc_id, range, offset), &mut global, &machine.threads)\n+        stacked_borrows.for_each_mut(range, |offset, stack, history| {\n+            stack.grant(\n+                orig_tag,\n+                item,\n+                (alloc_id, range, offset),\n+                &mut global,\n+                &machine.threads,\n+                history,\n+            )\n         })?;\n \n         Ok(())"}, {"sha": "734c3a14e3b3b69e9931b351e427ea0b395e5ac2", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 65, "deletions": 129, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/8ff0aac06c73d75d5eebea173889fb2ca94c0c75/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ff0aac06c73d75d5eebea173889fb2ca94c0c75/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=8ff0aac06c73d75d5eebea173889fb2ca94c0c75", "patch": "@@ -1,34 +1,40 @@\n+use smallvec::SmallVec;\n+use std::rc::Rc;\n+\n use rustc_middle::mir::interpret::{AllocId, AllocRange};\n+use rustc_span::def_id::CrateNum;\n use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n use crate::helpers::HexRange;\n-use crate::stacked_borrows::{err_sb_ub, AccessKind, GlobalStateInner, Permission};\n+use crate::stacked_borrows::{err_sb_ub, AccessKind, Permission};\n use crate::Item;\n use crate::SbTag;\n use crate::Stack;\n use crate::ThreadManager;\n \n use rustc_middle::mir::interpret::InterpError;\n \n-#[derive(Debug, Default)]\n+#[derive(Clone, Debug)]\n pub struct AllocHistory {\n     // The time tags can be compressed down to one bit per event, by just storing a Vec<u8>\n     // where each bit is set to indicate if the event was a creation or a retag\n     current_time: usize,\n     creations: smallvec::SmallVec<[Event; 2]>,\n     invalidations: smallvec::SmallVec<[Event; 1]>,\n     protectors: smallvec::SmallVec<[Protection; 1]>,\n+    /// This field is a clone of the `local_crates` field on `Evaluator`.\n+    local_crates: Rc<[CrateNum]>,\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n struct Protection {\n     orig_tag: SbTag,\n     tag: SbTag,\n     span: Span,\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n struct Event {\n     time: usize,\n     parent: Option<SbTag>,\n@@ -52,45 +58,17 @@ pub enum TagHistory {\n     },\n }\n \n-pub trait GlobalStateExt {\n-    fn current_span(&self, threads: &ThreadManager<'_, '_>) -> Span;\n-\n-    fn log_creation(\n-        &mut self,\n-        parent: Option<SbTag>,\n-        tag: SbTag,\n-        alloc: AllocId,\n-        range: AllocRange,\n-        threads: &ThreadManager<'_, '_>,\n-    );\n-\n-    fn log_invalidation(\n-        &mut self,\n-        tag: SbTag,\n-        alloc: AllocId,\n-        range: AllocRange,\n-        threads: &ThreadManager<'_, '_>,\n-    );\n-\n-    fn log_protector(\n-        &mut self,\n-        orig_tag: SbTag,\n-        tag: SbTag,\n-        alloc: AllocId,\n-        threads: &ThreadManager<'_, '_>,\n-    );\n-\n-    fn get_stack_history(\n-        &self,\n-        tag: SbTag,\n-        alloc: AllocId,\n-        alloc_range: AllocRange,\n-        offset: Size,\n-        protector_tag: Option<SbTag>,\n-    ) -> Option<TagHistory>;\n-}\n+impl AllocHistory {\n+    pub fn new(local_crates: Rc<[CrateNum]>) -> Self {\n+        Self {\n+            current_time: 0,\n+            creations: SmallVec::new(),\n+            invalidations: SmallVec::new(),\n+            protectors: SmallVec::new(),\n+            local_crates,\n+        }\n+    }\n \n-impl GlobalStateExt for GlobalStateInner {\n     fn current_span(&self, threads: &ThreadManager<'_, '_>) -> Span {\n         threads\n             .active_thread_stack()\n@@ -104,64 +82,45 @@ impl GlobalStateExt for GlobalStateInner {\n             .unwrap_or(rustc_span::DUMMY_SP)\n     }\n \n-    fn log_creation(\n+    pub fn log_creation(\n         &mut self,\n         parent: Option<SbTag>,\n         tag: SbTag,\n-        alloc: AllocId,\n         range: AllocRange,\n         threads: &ThreadManager<'_, '_>,\n     ) {\n         let span = self.current_span(threads);\n-        let extras = self.extras.entry(alloc).or_default();\n-        extras.creations.push(Event { parent, tag, range, span, time: extras.current_time });\n-        extras.current_time += 1;\n+        self.creations.push(Event { parent, tag, range, span, time: self.current_time });\n+        self.current_time += 1;\n     }\n \n-    fn log_invalidation(\n+    pub fn log_invalidation(\n         &mut self,\n         tag: SbTag,\n-        alloc: AllocId,\n         range: AllocRange,\n         threads: &ThreadManager<'_, '_>,\n     ) {\n         let span = self.current_span(threads);\n-        let extras = self.extras.entry(alloc).or_default();\n-        extras.invalidations.push(Event {\n-            parent: None,\n-            tag,\n-            range,\n-            span,\n-            time: extras.current_time,\n-        });\n-        extras.current_time += 1;\n+        self.invalidations.push(Event { parent: None, tag, range, span, time: self.current_time });\n+        self.current_time += 1;\n     }\n \n-    fn log_protector(\n-        &mut self,\n-        orig_tag: SbTag,\n-        tag: SbTag,\n-        alloc: AllocId,\n-        threads: &ThreadManager<'_, '_>,\n-    ) {\n+    pub fn log_protector(&mut self, orig_tag: SbTag, tag: SbTag, threads: &ThreadManager<'_, '_>) {\n         let span = self.current_span(threads);\n-        let extras = self.extras.entry(alloc).or_default();\n-        extras.protectors.push(Protection { orig_tag, tag, span });\n-        extras.current_time += 1;\n+        self.protectors.push(Protection { orig_tag, tag, span });\n+        self.current_time += 1;\n     }\n \n-    fn get_stack_history(\n+    pub fn get_logs_relevant_to(\n         &self,\n         tag: SbTag,\n-        alloc: AllocId,\n         alloc_range: AllocRange,\n         offset: Size,\n         protector_tag: Option<SbTag>,\n     ) -> Option<TagHistory> {\n-        let extras = self.extras.get(&alloc)?;\n         let protected = protector_tag\n             .and_then(|protector| {\n-                extras.protectors.iter().find_map(|protection| {\n+                self.protectors.iter().find_map(|protection| {\n                     if protection.tag == protector {\n                         Some((protection.orig_tag, protection.span.data()))\n                     } else {\n@@ -170,14 +129,15 @@ impl GlobalStateExt for GlobalStateInner {\n                 })\n             })\n             .and_then(|(tag, call_span)| {\n-                extras.creations.iter().rev().find_map(|event| {\n+                self.creations.iter().rev().find_map(|event| {\n                     if event.tag == tag {\n                         Some((event.parent?, event.span.data(), call_span))\n                     } else {\n                         None\n                     }\n                 })\n             });\n+\n         if let SbTag::Tagged(_) = tag {\n             let get_matching = |events: &[Event]| {\n                 events.iter().rev().find_map(|event| {\n@@ -186,14 +146,14 @@ impl GlobalStateExt for GlobalStateInner {\n             };\n             Some(TagHistory::Tagged {\n                 tag,\n-                created: get_matching(&extras.creations)?,\n-                invalidated: get_matching(&extras.invalidations),\n+                created: get_matching(&self.creations)?,\n+                invalidated: get_matching(&self.invalidations),\n                 protected,\n             })\n         } else {\n             let mut created_time = 0;\n             // Find the most recently created tag that satsfies this offset\n-            let recently_created = extras.creations.iter().rev().find_map(|event| {\n+            let recently_created = self.creations.iter().rev().find_map(|event| {\n                 if event.tag == tag && offset >= event.range.start && offset < event.range.end() {\n                     created_time = event.time;\n                     Some((event.range, event.span.data()))\n@@ -206,8 +166,8 @@ impl GlobalStateExt for GlobalStateInner {\n             // the recently created tag, and has a different span.\n             // We're trying to make a guess at which span the user wanted to provide the tag that\n             // they're using.\n-            let matching_created = if let Some((_created_range, created_span)) = recently_created {\n-                extras.creations.iter().rev().find_map(|event| {\n+            let matching_created = recently_created.and_then(|(_created_range, created_span)| {\n+                self.creations.iter().rev().find_map(|event| {\n                     if event.tag == tag\n                         && alloc_range.start >= event.range.start\n                         && alloc_range.end() <= event.range.end()\n@@ -219,26 +179,26 @@ impl GlobalStateExt for GlobalStateInner {\n                         None\n                     }\n                 })\n-            } else {\n-                None\n-            };\n+            });\n+\n+            // Find the most recent invalidation of this tag which post-dates the creation\n+            let recently_invalidated = recently_created.and_then(|_| {\n+                self.invalidations\n+                    .iter()\n+                    .rev()\n+                    .take_while(|event| event.time > created_time)\n+                    .find_map(|event| {\n+                        if event.tag == tag\n+                            && offset >= event.range.start\n+                            && offset < event.range.end()\n+                        {\n+                            Some((event.range, event.span.data()))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+            });\n \n-            let recently_invalidated = if recently_created.is_some() {\n-                // Find the most recent invalidation of this tag which post-dates the creation\n-                let mut found = None;\n-                for event in extras.invalidations.iter().rev() {\n-                    if event.time < created_time {\n-                        break;\n-                    }\n-                    if event.tag == tag && offset >= event.range.start && offset < event.range.end()\n-                    {\n-                        found = Some((event.range, event.span.data()))\n-                    }\n-                }\n-                found\n-            } else {\n-                None\n-            };\n             Some(TagHistory::Untagged {\n                 recently_created,\n                 matching_created,\n@@ -247,40 +207,16 @@ impl GlobalStateExt for GlobalStateInner {\n             })\n         }\n     }\n-}\n-\n-pub trait StackExt {\n-    fn grant_error(\n-        &self,\n-        derived_from: SbTag,\n-        new: Item,\n-        alloc_id: AllocId,\n-        alloc_range: AllocRange,\n-        error_offset: Size,\n-        global: &GlobalStateInner,\n-    ) -> InterpError<'static>;\n-\n-    fn access_error(\n-        &self,\n-        access: AccessKind,\n-        tag: SbTag,\n-        alloc_id: AllocId,\n-        alloc_range: AllocRange,\n-        error_offset: Size,\n-        global: &GlobalStateInner,\n-    ) -> InterpError<'static>;\n-}\n \n-impl StackExt for Stack {\n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n-    fn grant_error(\n+    pub fn grant_error(\n         &self,\n         derived_from: SbTag,\n         new: Item,\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n         error_offset: Size,\n-        global: &GlobalStateInner,\n+        stack: &Stack,\n     ) -> InterpError<'static> {\n         let action = format!(\n             \"trying to reborrow {:?} for {:?} permission at {}[{:#x}]\",\n@@ -290,21 +226,21 @@ impl StackExt for Stack {\n             error_offset.bytes(),\n         );\n         err_sb_ub(\n-            format!(\"{}{}\", action, error_cause(self, derived_from)),\n+            format!(\"{}{}\", action, error_cause(stack, derived_from)),\n             Some(operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n-            global.get_stack_history(derived_from, alloc_id, alloc_range, error_offset, None),\n+            self.get_logs_relevant_to(derived_from, alloc_range, error_offset, None),\n         )\n     }\n \n     /// Report a descriptive error when `access` is not permitted based on `tag`.\n-    fn access_error(\n+    pub fn access_error(\n         &self,\n         access: AccessKind,\n         tag: SbTag,\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n         error_offset: Size,\n-        global: &GlobalStateInner,\n+        stack: &Stack,\n     ) -> InterpError<'static> {\n         let action = format!(\n             \"attempting a {} using {:?} at {}[{:#x}]\",\n@@ -314,9 +250,9 @@ impl StackExt for Stack {\n             error_offset.bytes(),\n         );\n         err_sb_ub(\n-            format!(\"{}{}\", action, error_cause(self, tag)),\n+            format!(\"{}{}\", action, error_cause(stack, tag)),\n             Some(operation_summary(\"an access\", alloc_id, alloc_range)),\n-            global.get_stack_history(tag, alloc_id, alloc_range, error_offset, None),\n+            self.get_logs_relevant_to(tag, alloc_range, error_offset, None),\n         )\n     }\n }"}]}