{"sha": "e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MmYyZmZlMjcwYzZhOWZjYTMxMmZiOGE1M2NkMGRhMGRkMDFmZGU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-03T09:59:24Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-03T09:59:24Z"}, "message": "Merge #410\n\n410: Detangle symbols r=matklad a=matklad\n\nPreviously, we used `FileSymbol` both to represent bytes which are stored in the index and as an API of `ra_analysis`. Mixing internal storage format and an API is not a really bright idea, so we introduce `NavigationTarget` to handle API part.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "7f72fee435e82c750b321a52c551010d1b7afd09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f72fee435e82c750b321a52c551010d1b7afd09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde", "html_url": "https://github.com/rust-lang/rust/commit/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "f673529a3355cdd00062c873cd4fdd100f60a243", "url": "https://api.github.com/repos/rust-lang/rust/commits/f673529a3355cdd00062c873cd4fdd100f60a243", "html_url": "https://github.com/rust-lang/rust/commit/f673529a3355cdd00062c873cd4fdd100f60a243"}, {"sha": "8d6185350953391d0dd405cf790a69bb65d88a36", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6185350953391d0dd405cf790a69bb65d88a36", "html_url": "https://github.com/rust-lang/rust/commit/8d6185350953391d0dd405cf790a69bb65d88a36"}], "stats": {"total": 392, "additions": 221, "deletions": 171}, "files": [{"sha": "b812c3441029852468eae4dfa6df4d455259c10f", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 150, "deletions": 61, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde", "patch": "@@ -8,11 +8,11 @@ use hir::{\n use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n use ra_editor::{self, find_node_at_offset, LocalEdit, Severity};\n use ra_syntax::{\n-    algo::find_covering_node,\n+    algo::{find_covering_node, visit::{visitor, Visitor}},\n     ast::{self, ArgListOwner, Expr, FnDef, NameOwner},\n     AstNode, SourceFileNode,\n     SyntaxKind::*,\n-    SyntaxNodeRef, TextRange, TextUnit,\n+    SyntaxNode, SyntaxNodeRef, TextRange, TextUnit,\n };\n \n use crate::{\n@@ -116,12 +116,13 @@ impl db::RootDatabase {\n         };\n         let decl = decl.borrowed();\n         let decl_name = decl.name().unwrap();\n-        let symbol = FileSymbol {\n+        Ok(vec![NavigationTarget {\n+            file_id,\n             name: decl_name.text(),\n-            node_range: decl_name.syntax().range(),\n+            range: decl_name.syntax().range(),\n             kind: MODULE,\n-        };\n-        Ok(vec![NavigationTarget { file_id, symbol }])\n+            ptr: None,\n+        }])\n     }\n     /// Returns `Vec` for the same reason as `parent_module`\n     pub(crate) fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n@@ -153,14 +154,13 @@ impl db::RootDatabase {\n                 let scope = fn_descr.scopes(self);\n                 // First try to resolve the symbol locally\n                 if let Some(entry) = scope.resolve_local_name(name_ref) {\n-                    rr.add_resolution(\n-                        position.file_id,\n-                        FileSymbol {\n-                            name: entry.name().to_string().into(),\n-                            node_range: entry.ptr().range(),\n-                            kind: NAME,\n-                        },\n-                    );\n+                    rr.resolves_to.push(NavigationTarget {\n+                        file_id: position.file_id,\n+                        name: entry.name().to_string().into(),\n+                        range: entry.ptr().range(),\n+                        kind: NAME,\n+                        ptr: None,\n+                    });\n                     return Ok(Some(rr));\n                 };\n             }\n@@ -182,12 +182,14 @@ impl db::RootDatabase {\n                             Some(name) => name.to_string().into(),\n                             None => \"\".into(),\n                         };\n-                        let symbol = FileSymbol {\n+                        let symbol = NavigationTarget {\n+                            file_id,\n                             name,\n-                            node_range: TextRange::offset_len(0.into(), 0.into()),\n+                            range: TextRange::offset_len(0.into(), 0.into()),\n                             kind: MODULE,\n+                            ptr: None,\n                         };\n-                        rr.add_resolution(file_id, symbol);\n+                        rr.resolves_to.push(symbol);\n                         return Ok(Some(rr));\n                     }\n                 }\n@@ -253,8 +255,7 @@ impl db::RootDatabase {\n         }\n     }\n     pub(crate) fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n-        let file = self.source_file(nav.file_id);\n-        let result = match (nav.symbol.description(&file), nav.symbol.docs(&file)) {\n+        let result = match (nav.description(self), nav.docs(self)) {\n             (Some(desc), Some(docs)) => {\n                 Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs)\n             }\n@@ -362,52 +363,52 @@ impl db::RootDatabase {\n         // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n         let file_symbols = self.index_resolve(name_ref)?;\n         for (fn_file_id, fs) in file_symbols {\n-            if fs.kind == FN_DEF {\n+            if fs.ptr.kind() == FN_DEF {\n                 let fn_file = self.source_file(fn_file_id);\n-                if let Some(fn_def) = find_node_at_offset(fn_file.syntax(), fs.node_range.start()) {\n-                    let descr = ctry!(source_binder::function_from_source(\n-                        self, fn_file_id, fn_def\n-                    )?);\n-                    if let Some(descriptor) = descr.signature_info(self) {\n-                        // If we have a calling expression let's find which argument we are on\n-                        let mut current_parameter = None;\n-\n-                        let num_params = descriptor.params.len();\n-                        let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n-\n-                        if num_params == 1 {\n-                            if !has_self {\n-                                current_parameter = Some(0);\n-                            }\n-                        } else if num_params > 1 {\n-                            // Count how many parameters into the call we are.\n-                            // TODO: This is best effort for now and should be fixed at some point.\n-                            // It may be better to see where we are in the arg_list and then check\n-                            // where offset is in that list (or beyond).\n-                            // Revisit this after we get documentation comments in.\n-                            if let Some(ref arg_list) = calling_node.arg_list() {\n-                                let start = arg_list.syntax().range().start();\n-\n-                                let range_search = TextRange::from_to(start, position.offset);\n-                                let mut commas: usize = arg_list\n-                                    .syntax()\n-                                    .text()\n-                                    .slice(range_search)\n-                                    .to_string()\n-                                    .matches(',')\n-                                    .count();\n-\n-                                // If we have a method call eat the first param since it's just self.\n-                                if has_self {\n-                                    commas += 1;\n-                                }\n-\n-                                current_parameter = Some(commas);\n-                            }\n+                let fn_def = fs.ptr.resolve(&fn_file);\n+                let fn_def = ast::FnDef::cast(fn_def.borrowed()).unwrap();\n+                let descr = ctry!(source_binder::function_from_source(\n+                    self, fn_file_id, fn_def\n+                )?);\n+                if let Some(descriptor) = descr.signature_info(self) {\n+                    // If we have a calling expression let's find which argument we are on\n+                    let mut current_parameter = None;\n+\n+                    let num_params = descriptor.params.len();\n+                    let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n+\n+                    if num_params == 1 {\n+                        if !has_self {\n+                            current_parameter = Some(0);\n                         }\n+                    } else if num_params > 1 {\n+                        // Count how many parameters into the call we are.\n+                        // TODO: This is best effort for now and should be fixed at some point.\n+                        // It may be better to see where we are in the arg_list and then check\n+                        // where offset is in that list (or beyond).\n+                        // Revisit this after we get documentation comments in.\n+                        if let Some(ref arg_list) = calling_node.arg_list() {\n+                            let start = arg_list.syntax().range().start();\n+\n+                            let range_search = TextRange::from_to(start, position.offset);\n+                            let mut commas: usize = arg_list\n+                                .syntax()\n+                                .text()\n+                                .slice(range_search)\n+                                .to_string()\n+                                .matches(',')\n+                                .count();\n+\n+                            // If we have a method call eat the first param since it's just self.\n+                            if has_self {\n+                                commas += 1;\n+                            }\n \n-                        return Ok(Some((descriptor, current_parameter)));\n+                            current_parameter = Some(commas);\n+                        }\n                     }\n+\n+                    return Ok(Some((descriptor, current_parameter)));\n                 }\n             }\n         }\n@@ -511,3 +512,91 @@ impl<'a> FnCallNode<'a> {\n         }\n     }\n }\n+\n+impl NavigationTarget {\n+    fn node(&self, db: &db::RootDatabase) -> Option<SyntaxNode> {\n+        let source_file = db.source_file(self.file_id);\n+        let source_file = source_file.syntax();\n+        let node = source_file\n+            .descendants()\n+            .find(|node| node.kind() == self.kind && node.range() == self.range)?\n+            .owned();\n+        Some(node)\n+    }\n+\n+    fn docs(&self, db: &db::RootDatabase) -> Option<String> {\n+        let node = self.node(db)?;\n+        let node = node.borrowed();\n+        fn doc_comments<'a, N: ast::DocCommentsOwner<'a>>(node: N) -> Option<String> {\n+            let comments = node.doc_comment_text();\n+            if comments.is_empty() {\n+                None\n+            } else {\n+                Some(comments)\n+            }\n+        }\n+\n+        visitor()\n+            .visit(doc_comments::<ast::FnDef>)\n+            .visit(doc_comments::<ast::StructDef>)\n+            .visit(doc_comments::<ast::EnumDef>)\n+            .visit(doc_comments::<ast::TraitDef>)\n+            .visit(doc_comments::<ast::Module>)\n+            .visit(doc_comments::<ast::TypeDef>)\n+            .visit(doc_comments::<ast::ConstDef>)\n+            .visit(doc_comments::<ast::StaticDef>)\n+            .accept(node)?\n+    }\n+\n+    /// Get a description of this node.\n+    ///\n+    /// e.g. `struct Name`, `enum Name`, `fn Name`\n+    fn description(&self, db: &db::RootDatabase) -> Option<String> {\n+        // TODO: After type inference is done, add type information to improve the output\n+        let node = self.node(db)?;\n+        let node = node.borrowed();\n+        // TODO: Refactor to be have less repetition\n+        visitor()\n+            .visit(|node: ast::FnDef| {\n+                let mut string = \"fn \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::StructDef| {\n+                let mut string = \"struct \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::EnumDef| {\n+                let mut string = \"enum \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::TraitDef| {\n+                let mut string = \"trait \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::Module| {\n+                let mut string = \"mod \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::TypeDef| {\n+                let mut string = \"type \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::ConstDef| {\n+                let mut string = \"const \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::StaticDef| {\n+                let mut string = \"static \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .accept(node)?\n+    }\n+}"}, {"sha": "61af676b2c254e6b59086ea8896d1ed05900e626", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde", "patch": "@@ -1,6 +1,8 @@\n-//! ra_analyzer crate is the brain of Rust analyzer. It relies on the `salsa`\n-//! crate, which provides and incremental on-demand database of facts.\n-\n+//! ra_analyzer crate provides \"ide-centric\" APIs for the rust-analyzer. What\n+//! powers this API are the `RootDatabase` struct, which defines a `salsa`\n+//! database, and the `ra_hir` crate, where majority of the analysis happens.\n+//! However, IDE specific bits of the analysis (most notably completion) happen\n+//! in this crate.\n macro_rules! ctry {\n     ($expr:expr) => {\n         match $expr {\n@@ -41,7 +43,7 @@ pub use ra_editor::{\n pub use hir::FnSignatureInfo;\n \n pub use ra_db::{\n-    Canceled, Cancelable, FilePosition, FileRange,\n+    Canceled, Cancelable, FilePosition, FileRange, LocalSyntaxPtr,\n     CrateGraph, CrateId, SourceRootId, FileId, SyntaxDatabase, FilesDatabase\n };\n \n@@ -219,24 +221,42 @@ impl Query {\n     }\n }\n \n+/// `NavigationTarget` represents and element in the editor's UI whihc you can\n+/// click on to navigate to a particular piece of code.\n+///\n+/// Typically, a `NavigationTarget` corresponds to some element in the source\n+/// code, like a function or a struct, but this is not strictly required.\n #[derive(Debug)]\n pub struct NavigationTarget {\n     file_id: FileId,\n-    symbol: FileSymbol,\n+    name: SmolStr,\n+    kind: SyntaxKind,\n+    range: TextRange,\n+    // Should be DefId ideally\n+    ptr: Option<LocalSyntaxPtr>,\n }\n \n impl NavigationTarget {\n-    pub fn name(&self) -> SmolStr {\n-        self.symbol.name.clone()\n+    fn from_symbol(file_id: FileId, symbol: FileSymbol) -> NavigationTarget {\n+        NavigationTarget {\n+            name: symbol.name.clone(),\n+            kind: symbol.ptr.kind(),\n+            file_id,\n+            range: symbol.ptr.range(),\n+            ptr: Some(symbol.ptr.clone()),\n+        }\n+    }\n+    pub fn name(&self) -> &SmolStr {\n+        &self.name\n     }\n     pub fn kind(&self) -> SyntaxKind {\n-        self.symbol.kind\n+        self.kind\n     }\n     pub fn file_id(&self) -> FileId {\n         self.file_id\n     }\n     pub fn range(&self) -> TextRange {\n-        self.symbol.node_range\n+        self.range\n     }\n }\n \n@@ -260,7 +280,8 @@ impl ReferenceResolution {\n     }\n \n     fn add_resolution(&mut self, file_id: FileId, symbol: FileSymbol) {\n-        self.resolves_to.push(NavigationTarget { file_id, symbol })\n+        self.resolves_to\n+            .push(NavigationTarget::from_symbol(file_id, symbol))\n     }\n }\n \n@@ -359,7 +380,7 @@ impl Analysis {\n     pub fn symbol_search(&self, query: Query) -> Cancelable<Vec<NavigationTarget>> {\n         let res = symbol_index::world_symbols(&*self.db, query)?\n             .into_iter()\n-            .map(|(file_id, symbol)| NavigationTarget { file_id, symbol })\n+            .map(|(file_id, symbol)| NavigationTarget::from_symbol(file_id, symbol))\n             .collect();\n         Ok(res)\n     }"}, {"sha": "10d8e80599a4ff20016bcf79067c94674bdb852a", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 29, "deletions": 93, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde", "patch": "@@ -1,16 +1,37 @@\n+//! This module handles fuzzy-searching of functions, structs and other symbols\n+//! by name across the whole workspace and dependencies.\n+//!\n+//! It works by building an incrementally-updated text-search index of all\n+//! symbols. The backbone of the index is the **awesome** `fst` crate by\n+//! @BurntSushi.\n+//!\n+//! In a nutshell, you give a set of strings to the `fst`, and it builds a\n+//! finite state machine describing this set of strtings. The strings which\n+//! could fuzzy-match a pattern can also be described by a finite state machine.\n+//! What is freakingly cool is that you can now traverse both state machines in\n+//! lock-step to enumerate the strings which are both in the input set and\n+//! fuzz-match the query. Or, more formally, given two langauges described by\n+//! fsts, one can build an product fst which describes the intersection of the\n+//! languages.\n+//!\n+//! `fst` does not support cheap updating of the index, but it supports unioning\n+//! of state machines. So, to account for changing source code, we build an fst\n+//! for each library (which is assumed to never change) and an fst for each rust\n+//! file in the current workspace, and run a query aginst the union of all\n+//! thouse fsts.\n use std::{\n     hash::{Hash, Hasher},\n     sync::Arc,\n };\n \n use fst::{self, Streamer};\n use ra_syntax::{\n-    AstNode, SyntaxNodeRef, SourceFileNode, SmolStr, TextRange,\n+    SyntaxNodeRef, SourceFileNode, SmolStr,\n     algo::visit::{visitor, Visitor},\n     SyntaxKind::{self, *},\n-    ast::{self, NameOwner, DocCommentsOwner},\n+    ast::{self, NameOwner},\n };\n-use ra_db::{SyntaxDatabase, SourceRootId, FilesDatabase};\n+use ra_db::{SyntaxDatabase, SourceRootId, FilesDatabase, LocalSyntaxPtr};\n use salsa::ParallelDatabase;\n use rayon::prelude::*;\n \n@@ -140,7 +161,7 @@ impl Query {\n                 let idx = indexed_value.value as usize;\n \n                 let (file_id, symbol) = &file_symbols.symbols[idx];\n-                if self.only_types && !is_type(symbol.kind) {\n+                if self.only_types && !is_type(symbol.ptr.kind()) {\n                     continue;\n                 }\n                 if self.exact && symbol.name != self.query {\n@@ -160,105 +181,20 @@ fn is_type(kind: SyntaxKind) -> bool {\n     }\n }\n \n+/// The actual data that is stored in the index. It should be as compact as\n+/// possible.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub(crate) struct FileSymbol {\n     pub(crate) name: SmolStr,\n-    pub(crate) node_range: TextRange,\n-    pub(crate) kind: SyntaxKind,\n-}\n-\n-impl FileSymbol {\n-    pub(crate) fn docs(&self, file: &SourceFileNode) -> Option<String> {\n-        file.syntax()\n-            .descendants()\n-            .filter(|node| node.kind() == self.kind && node.range() == self.node_range)\n-            .filter_map(|node: SyntaxNodeRef| {\n-                fn doc_comments<'a, N: DocCommentsOwner<'a>>(node: N) -> Option<String> {\n-                    let comments = node.doc_comment_text();\n-                    if comments.is_empty() {\n-                        None\n-                    } else {\n-                        Some(comments)\n-                    }\n-                }\n-\n-                visitor()\n-                    .visit(doc_comments::<ast::FnDef>)\n-                    .visit(doc_comments::<ast::StructDef>)\n-                    .visit(doc_comments::<ast::EnumDef>)\n-                    .visit(doc_comments::<ast::TraitDef>)\n-                    .visit(doc_comments::<ast::Module>)\n-                    .visit(doc_comments::<ast::TypeDef>)\n-                    .visit(doc_comments::<ast::ConstDef>)\n-                    .visit(doc_comments::<ast::StaticDef>)\n-                    .accept(node)?\n-            })\n-            .nth(0)\n-    }\n-    /// Get a description of this node.\n-    ///\n-    /// e.g. `struct Name`, `enum Name`, `fn Name`\n-    pub(crate) fn description(&self, file: &SourceFileNode) -> Option<String> {\n-        // TODO: After type inference is done, add type information to improve the output\n-        file.syntax()\n-            .descendants()\n-            .filter(|node| node.kind() == self.kind && node.range() == self.node_range)\n-            .filter_map(|node: SyntaxNodeRef| {\n-                // TODO: Refactor to be have less repetition\n-                visitor()\n-                    .visit(|node: ast::FnDef| {\n-                        let mut string = \"fn \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::StructDef| {\n-                        let mut string = \"struct \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::EnumDef| {\n-                        let mut string = \"enum \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::TraitDef| {\n-                        let mut string = \"trait \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::Module| {\n-                        let mut string = \"mod \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::TypeDef| {\n-                        let mut string = \"type \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::ConstDef| {\n-                        let mut string = \"const \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::StaticDef| {\n-                        let mut string = \"static \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .accept(node)?\n-            })\n-            .nth(0)\n-    }\n+    pub(crate) ptr: LocalSyntaxPtr,\n }\n \n fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n     fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<FileSymbol> {\n         let name = node.name()?;\n         Some(FileSymbol {\n             name: name.text(),\n-            node_range: node.syntax().range(),\n-            kind: node.syntax().kind(),\n+            ptr: LocalSyntaxPtr::new(node.syntax()),\n         })\n     }\n     visitor()"}, {"sha": "bcf29d29cac3f24169bdb6cd7826a8ee51ee137e", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde", "patch": "@@ -25,7 +25,7 @@ fn approximate_resolve_works_in_items() {\n     assert_eq_dbg(\n         r#\"ReferenceResolution {\n             reference_range: [23; 26),\n-            resolves_to: [NavigationTarget { file_id: FileId(1), symbol: FileSymbol { name: \"Foo\", node_range: [0; 11), kind: STRUCT_DEF } }]\n+            resolves_to: [NavigationTarget { file_id: FileId(1), name: \"Foo\", kind: STRUCT_DEF, range: [0; 11), ptr: Some(LocalSyntaxPtr { range: [0; 11), kind: STRUCT_DEF }) }]\n         }\"#,\n         &symbols,\n     );\n@@ -46,7 +46,7 @@ fn test_resolve_module() {\n     assert_eq_dbg(\n         r#\"ReferenceResolution {\n             reference_range: [4; 7),\n-            resolves_to: [NavigationTarget { file_id: FileId(2), symbol: FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE } }]\n+            resolves_to: [NavigationTarget { file_id: FileId(2), name: \"foo\", kind: MODULE, range: [0; 0), ptr: None }]\n         }\"#,\n         &symbols,\n     );\n@@ -64,7 +64,7 @@ fn test_resolve_module() {\n     assert_eq_dbg(\n         r#\"ReferenceResolution {\n             reference_range: [4; 7),\n-            resolves_to: [NavigationTarget { file_id: FileId(2), symbol: FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE } }]\n+            resolves_to: [NavigationTarget { file_id: FileId(2), name: \"foo\", kind: MODULE, range: [0; 0), ptr: None }]\n         }\"#,\n         &symbols,\n     );\n@@ -107,7 +107,7 @@ fn test_resolve_parent_module() {\n     );\n     let symbols = analysis.parent_module(pos).unwrap();\n     assert_eq_dbg(\n-        r#\"[NavigationTarget { file_id: FileId(1), symbol: FileSymbol { name: \"foo\", node_range: [4; 7), kind: MODULE } }]\"#,\n+        r#\"[NavigationTarget { file_id: FileId(1), name: \"foo\", kind: MODULE, range: [4; 7), ptr: None }]\"#,\n         &symbols,\n     );\n }\n@@ -126,7 +126,7 @@ fn test_resolve_parent_module_for_inline() {\n     );\n     let symbols = analysis.parent_module(pos).unwrap();\n     assert_eq_dbg(\n-        r#\"[NavigationTarget { file_id: FileId(1), symbol: FileSymbol { name: \"bar\", node_range: [18; 21), kind: MODULE } }]\"#,\n+        r#\"[NavigationTarget { file_id: FileId(1), name: \"bar\", kind: MODULE, range: [18; 21), ptr: None }]\"#,\n         &symbols,\n     );\n }"}, {"sha": "744cb23523339ab677c6c43f3b7b7bd3bf4128a7", "filename": "crates/ra_db/src/syntax_ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs?ref=e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde", "patch": "@@ -31,6 +31,10 @@ impl LocalSyntaxPtr {\n     pub fn range(self) -> TextRange {\n         self.range\n     }\n+\n+    pub fn kind(self) -> SyntaxKind {\n+        self.kind\n+    }\n }\n \n #[test]"}, {"sha": "b5792f3b81f1eb63328a7e52b896634d43c4a40a", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=e92f2ffe270c6a9fca312fb8a53cd0da0dd01fde", "patch": "@@ -190,7 +190,7 @@ pub fn handle_workspace_symbol(\n         let mut res = Vec::new();\n         for nav in world.analysis().symbol_search(query)? {\n             let info = SymbolInformation {\n-                name: nav.name().into(),\n+                name: nav.name().to_string(),\n                 kind: nav.kind().conv(),\n                 location: nav.try_conv_with(world)?,\n                 container_name: None,"}]}