{"sha": "6423cc7b52925dfe0ffaffb9e0319dee922ec48c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MjNjYzdiNTI5MjVkZmUwZmZhZmZiOWUwMzE5ZGVlOTIyZWM0OGM=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-29T22:07:27Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-07-29T22:21:40Z"}, "message": "Comments and cleanup, in preparation for more work on issue #702.", "tree": {"sha": "a5da781890684a5e5047c4297cd13835b83d16c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5da781890684a5e5047c4297cd13835b83d16c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6423cc7b52925dfe0ffaffb9e0319dee922ec48c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6423cc7b52925dfe0ffaffb9e0319dee922ec48c", "html_url": "https://github.com/rust-lang/rust/commit/6423cc7b52925dfe0ffaffb9e0319dee922ec48c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6423cc7b52925dfe0ffaffb9e0319dee922ec48c/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4eacbb3b44f8e56201dd66be9981669326ada6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4eacbb3b44f8e56201dd66be9981669326ada6d", "html_url": "https://github.com/rust-lang/rust/commit/f4eacbb3b44f8e56201dd66be9981669326ada6d"}], "stats": {"total": 75, "additions": 56, "deletions": 19}, "files": [{"sha": "8985193de8672e7a939ff57ed477f5879209fcbc", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6423cc7b52925dfe0ffaffb9e0319dee922ec48c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423cc7b52925dfe0ffaffb9e0319dee922ec48c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6423cc7b52925dfe0ffaffb9e0319dee922ec48c", "patch": "@@ -6482,23 +6482,42 @@ fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n }\n \n // process_fwding_mthd: Create the forwarding function that appears in a\n-// vtable slot for method calls that \"fall through\" to an inner object.  A\n+// vtable slot for method calls that need to forward to another object.  A\n // helper function for create_vtbl.\n+//\n+// We use forwarding functions in two situations:\n+//\n+//  (1) Forwarding: For method calls that fall through to an inner object, For\n+//      example, suppose an inner object has method foo and we extend it with\n+//      a method bar.  The only version of 'foo' we have is on the inner\n+//      object, but we would like to be able to call outer.foo().  So we use a\n+//      forwarding function to make the foo method available on the outer\n+//      object.  It takes all the same arguments as the foo method on the\n+//      inner object does, calls inner.foo() with those arguments, and then\n+//      returns the value returned from that call.  (The inner object won't\n+//      exist until run-time, but we know its type statically.)\n+//\n+//  (2) Backwarding: For method calls that dispatch back through an outer\n+//      object.  For example, suppose an inner object has methods foo and bar,\n+//      and bar contains the call self.foo().  We extend that object with a\n+//      foo method that overrides the inner foo.  Now, a call to outer.bar()\n+//      should send us to to inner.bar() via a normal forwarding function, and\n+//      then to self.foo().  But inner.bar() was already compiled under the\n+//      assumption that self.foo() is inner.foo(), when we really want to\n+//      reach outer.foo().  So, we give 'self' a vtable of backwarding\n+//      functions, one for each method on inner, each of which takes all the\n+//      same arguments as the corresponding method on inner does, calls that\n+//      method on outer, and returns the value returned from that call.\n+\n fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n-                       ty_params: &ast::ty_param[], inner_obj_ty: ty::t,\n+                       ty_params: &ast::ty_param[], target_obj_ty: ty::t,\n                        backwarding_vtbl: option::t[ValueRef],\n                        additional_field_tys: &ty::t[]) -> ValueRef {\n \n-\n-    // The method m is being called on the outer object, but the outer object\n-    // doesn't have that method; only the inner object does.  So what we have\n-    // to do is synthesize that method on the outer object.  It has to take\n-    // all the same arguments as the method on the inner object does, then\n-    // call m with those arguments on the inner object, and then return the\n-    // value returned from that call.  It's like an eta-expansion around m,\n-    // except we also have to pass the inner object that m should be called\n-    // on.  That object won't exist until run-time, but we know its type\n-    // statically.\n+    // NB: target_obj_ty is the type of the object being forwarded to.\n+    // Depending on whether this is a forwarding or backwarding function, it\n+    // will be either the inner obj's type or the outer obj's type,\n+    // respectively.\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n@@ -6534,16 +6553,24 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Do backwarding if necessary.\n     alt (backwarding_vtbl) {\n-      none. { /* fall through */ }\n+      none. {\n+        // NB: As before, this means that we are processing a backwarding fn\n+        // right now.\n+      }\n       some(bv) {\n-        // Grab the vtable out of the self-object.\n+        // NB: As before, this means that we are processing a forwarding fn\n+        // right now.\n+\n+        // Grab the vtable out of the self-object and replace it with the\n+        // backwarding vtable.\n         let llself_obj_vtbl =\n             bcx.build.GEP(llself_obj_ptr, ~[C_int(0),\n                                             C_int(abi::obj_field_vtbl)]);\n-\n-        // And replace it with the backwarding vtbl.\n         let llbv = bcx.build.PointerCast(bv, T_ptr(T_empty_struct()));\n         bcx.build.Store(llbv, llself_obj_vtbl);\n+\n+        // NB: llself_obj is now a freakish combination of outer object body\n+        // and backwarding (inner-object) vtable.\n       }\n     }\n \n@@ -6595,6 +6622,15 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Tuple type for body:\n     // [tydesc, [typaram, ...], [field, ...], inner_obj]\n+\n+    // NB: When we're creating a forwarding fn, target_obj_ty is indeed the\n+    // type of the inner object, so it makes sense to have 'target_obj_ty'\n+    // appear here.  When we're creating a backwarding fn, though,\n+    // target_obj_ty is the outer object's type, so instead, we need to use\n+    // the extra inner type we passed along.\n+\n+    let inner_obj_ty = target_obj_ty;\n+\n     let body_ty: ty::t =\n         ty::mk_imm_tup(cx.ccx.tcx,\n                        ~[tydesc_ty, typarams_ty, fields_ty, inner_obj_ty]);\n@@ -6621,14 +6657,14 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Get the index of the method we want.\n     let ix: uint = 0u;\n-    alt ty::struct(bcx_tcx(bcx), inner_obj_ty) {\n+    alt ty::struct(bcx_tcx(bcx), target_obj_ty) {\n       ty::ty_obj(methods) {\n         ix = ty::method_idx(cx.ccx.sess, sp, m.ident, methods);\n       }\n       _ {\n         // Shouldn't happen.\n         cx.ccx.sess.bug(\"process_fwding_mthd(): non-object type passed \\\n-                        as inner_obj_ty\");\n+                        as target_obj_ty\");\n       }\n     }\n \n@@ -6652,7 +6688,8 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n     // Set up the three implicit arguments to the original method we'll need\n     // to call.\n-    let llorig_mthd_args: ValueRef[] = ~[llretptr, fcx.lltaskptr, llself_obj];\n+    let self_arg = llself_obj;\n+    let llorig_mthd_args: ValueRef[] = ~[llretptr, fcx.lltaskptr, self_arg];\n \n     // Copy the explicit arguments that are being passed into the forwarding\n     // function (they're in fcx.llargs) to llorig_mthd_args."}]}