{"sha": "28467f5d197d1455e922711a28ea4a19702dbda9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NDY3ZjVkMTk3ZDE0NTVlOTIyNzExYTI4ZWE0YTE5NzAyZGJkYTk=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-02-07T22:58:37Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-02-08T06:31:51Z"}, "message": "Tweak from_utf8_lossy to return a new MaybeOwned enum\n\nMaybeOwned allows from_utf8_lossy to avoid allocation if there are no\ninvalid bytes in the input.", "tree": {"sha": "bfcd12c078fb6aa9bbd65053efbbd41d758b7778", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfcd12c078fb6aa9bbd65053efbbd41d758b7778"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28467f5d197d1455e922711a28ea4a19702dbda9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28467f5d197d1455e922711a28ea4a19702dbda9", "html_url": "https://github.com/rust-lang/rust/commit/28467f5d197d1455e922711a28ea4a19702dbda9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28467f5d197d1455e922711a28ea4a19702dbda9/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dde2e0b3865ba040261d2078db371adbefb32506", "url": "https://api.github.com/repos/rust-lang/rust/commits/dde2e0b3865ba040261d2078db371adbefb32506", "html_url": "https://github.com/rust-lang/rust/commit/dde2e0b3865ba040261d2078db371adbefb32506"}], "stats": {"total": 125, "additions": 96, "deletions": 29}, "files": [{"sha": "d5a69b12f2ac58d2b74edfd49ead954fe70a44a2", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28467f5d197d1455e922711a28ea4a19702dbda9/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28467f5d197d1455e922711a28ea4a19702dbda9/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=28467f5d197d1455e922711a28ea4a19702dbda9", "patch": "@@ -508,10 +508,10 @@ impl<'a, P: GenericPath> ToStr for Display<'a, P> {\n         if self.filename {\n             match self.path.filename() {\n                 None => ~\"\",\n-                Some(v) => str::from_utf8_lossy(v)\n+                Some(v) => str::from_utf8_lossy(v).into_owned()\n             }\n         } else {\n-            str::from_utf8_lossy(self.path.as_vec())\n+            str::from_utf8_lossy(self.path.as_vec()).into_owned()\n         }\n     }\n }"}, {"sha": "204139c5d78d61803082780e5bcfc68f912af3fb", "filename": "src/libstd/str.rs", "status": "modified", "additions": 94, "deletions": 27, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/28467f5d197d1455e922711a28ea4a19702dbda9/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28467f5d197d1455e922711a28ea4a19702dbda9/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=28467f5d197d1455e922711a28ea4a19702dbda9", "patch": "@@ -729,6 +729,11 @@ Section: Misc\n \n /// Determines if a vector of bytes contains valid UTF-8\n pub fn is_utf8(v: &[u8]) -> bool {\n+    first_non_utf8_index(v).is_none()\n+}\n+\n+#[inline(always)]\n+fn first_non_utf8_index(v: &[u8]) -> Option<uint> {\n     let mut i = 0u;\n     let total = v.len();\n     fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n@@ -740,10 +745,10 @@ pub fn is_utf8(v: &[u8]) -> bool {\n             i += 1u;\n         } else {\n             let w = utf8_char_width(v_i);\n-            if w == 0u { return false; }\n+            if w == 0u { return Some(i); }\n \n             let nexti = i + w;\n-            if nexti > total { return false; }\n+            if nexti > total { return Some(i); }\n \n             // 2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n             //        first  C2 80        last DF BF\n@@ -766,7 +771,7 @@ pub fn is_utf8(v: &[u8]) -> bool {\n             // UTF8-tail   = %x80-BF\n             match w {\n                 2 => if unsafe_get(v, i + 1) & 192u8 != TAG_CONT_U8 {\n-                    return false\n+                    return Some(i)\n                 },\n                 3 => match (v_i,\n                             unsafe_get(v, i + 1),\n@@ -775,7 +780,7 @@ pub fn is_utf8(v: &[u8]) -> bool {\n                     (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) => (),\n                     (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) => (),\n                     (0xEE .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => (),\n-                    _ => return false,\n+                    _ => return Some(i),\n                 },\n                 _ => match (v_i,\n                             unsafe_get(v, i + 1),\n@@ -784,14 +789,14 @@ pub fn is_utf8(v: &[u8]) -> bool {\n                     (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) => (),\n                     (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) => (),\n                     (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => (),\n-                    _ => return false,\n+                    _ => return Some(i)\n                 },\n             }\n \n             i = nexti;\n         }\n     }\n-    true\n+    None\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n@@ -910,6 +915,53 @@ macro_rules! utf8_acc_cont_byte(\n \n static TAG_CONT_U8: u8 = 128u8;\n \n+/// Enum that represents either a borrowed or an owned string.\n+#[deriving(Eq,Clone)]\n+pub enum MaybeOwned<'a> {\n+    /// A borrowed string\n+    Slice(&'a str),\n+    /// An owned string\n+    Owned(~str)\n+}\n+\n+impl<'a> Str for MaybeOwned<'a> {\n+    #[inline]\n+    fn as_slice<'b>(&'b self) -> &'b str {\n+        match *self {\n+            Slice(s) => s,\n+            Owned(ref s) => s.as_slice()\n+        }\n+    }\n+\n+    #[inline]\n+    fn into_owned(self) -> ~str {\n+        match self {\n+            Slice(s) => s.to_owned(),\n+            Owned(s) => s\n+        }\n+    }\n+}\n+\n+impl<'a> ToStr for MaybeOwned<'a> {\n+    #[inline]\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            Slice(s) => s.to_str(),\n+            Owned(ref s) => s.clone()\n+        }\n+    }\n+}\n+\n+impl<'a> ::fmt::Show for MaybeOwned<'a> {\n+    #[inline]\n+    fn fmt(mo: &MaybeOwned, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+        match *mo {\n+            Slice(ref s) => ::fmt::Show::fmt(s, f),\n+            Owned(ref s) => ::fmt::Show::fmt(&s.as_slice(), f)\n+        }\n+    }\n+}\n+\n /// Converts a vector of bytes to a new utf-8 string.\n /// Any invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n ///\n@@ -918,12 +970,16 @@ static TAG_CONT_U8: u8 = 128u8;\n /// ```rust\n /// let input = bytes!(\"Hello \", 0xF0, 0x90, 0x80, \"World\");\n /// let output = std::str::from_utf8_lossy(input);\n-/// assert_eq!(output, ~\"Hello \\uFFFDWorld\");\n+/// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n /// ```\n-pub fn from_utf8_lossy(v: &[u8]) -> ~str {\n+pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n+    let firstbad = match first_non_utf8_index(v) {\n+        None => return Slice(unsafe { cast::transmute(v) }),\n+        Some(i) => i\n+    };\n+\n     static REPLACEMENT: &'static [u8] = bytes!(0xEF, 0xBF, 0xBD); // U+FFFD in UTF-8\n-    let mut i = 0u;\n-    let mut lastgood = 0u;\n+    let mut i = firstbad;\n     let total = v.len();\n     fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n         unsafe { *xs.unsafe_ref(i) }\n@@ -937,23 +993,32 @@ pub fn from_utf8_lossy(v: &[u8]) -> ~str {\n     }\n     let mut res = with_capacity(total);\n \n+    if i > 0 {\n+        unsafe { raw::push_bytes(&mut res, v.slice_to(i)) };\n+    }\n+\n+    // subseqidx is the index of the first byte of the subsequence we're looking at.\n+    // It's used to copy a bunch of contiguous good codepoints at once instead of copying\n+    // them one by one.\n+    let mut subseqidx = firstbad;\n+\n     while i < total {\n         let i_ = i;\n         let byte = unsafe_get(v, i);\n         i += 1;\n \n-        macro_rules! error(() => {\n+        macro_rules! error(() => ({\n             unsafe {\n-                if lastgood != i_ {\n-                    raw::push_bytes(&mut res, v.slice(lastgood, i_));\n+                if subseqidx != i_ {\n+                    raw::push_bytes(&mut res, v.slice(subseqidx, i_));\n                 }\n-                lastgood = i;\n+                subseqidx = i;\n                 raw::push_bytes(&mut res, REPLACEMENT);\n             }\n-        })\n+        }))\n \n         if byte < 128u8 {\n-            // lastgood handles this\n+            // subseqidx handles this\n         } else {\n             let w = utf8_char_width(byte);\n \n@@ -1012,8 +1077,10 @@ pub fn from_utf8_lossy(v: &[u8]) -> ~str {\n             }\n         }\n     }\n-    unsafe { raw::push_bytes(&mut res, v.slice(lastgood, total)) };\n-    res\n+    if subseqidx < total {\n+        unsafe { raw::push_bytes(&mut res, v.slice(subseqidx, total)) };\n+    }\n+    Owned(res)\n }\n \n /// Unsafe operations\n@@ -3943,32 +4010,32 @@ mod tests {\n     #[test]\n     fn test_str_from_utf8_lossy() {\n         let xs = bytes!(\"hello\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"hello\");\n+        assert_eq!(from_utf8_lossy(xs), Slice(\"hello\"));\n \n         let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = bytes!(\"Hello\", 0xC2, \" There\", 0xFF, \" Goodbye\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"Hello\\uFFFD There\\uFFFD Goodbye\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"Hello\\uFFFD There\\uFFFD Goodbye\"));\n \n         let xs = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\"));\n \n         let xs = bytes!(0xF5, \"foo\", 0xF5, 0x80, \"bar\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFD\\uFFFDbar\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFDfoo\\uFFFD\\uFFFDbar\"));\n \n         let xs = bytes!(0xF1, \"foo\", 0xF1, 0x80, \"bar\", 0xF1, 0x80, 0x80, \"baz\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\"));\n \n         let xs = bytes!(0xF4, \"foo\", 0xF4, 0x80, \"bar\", 0xF4, 0xBF, \"baz\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\"));\n \n         let xs = bytes!(0xF0, 0x80, 0x80, 0x80, \"foo\", 0xF0, 0x90, 0x80, 0x80, \"bar\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFD\\uFFFD\\uFFFD\\uFFFDfoo\\U00010000bar\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFD\\uFFFD\\uFFFD\\uFFFDfoo\\U00010000bar\"));\n \n         // surrogates\n         let xs = bytes!(0xED, 0xA0, 0x80, \"foo\", 0xED, 0xBF, 0xBF, \"bar\");\n-        assert_eq!(from_utf8_lossy(xs), ~\"\\uFFFD\\uFFFD\\uFFFDfoo\\uFFFD\\uFFFD\\uFFFDbar\");\n+        assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFD\\uFFFD\\uFFFDfoo\\uFFFD\\uFFFD\\uFFFDbar\"));\n     }\n \n     #[test]"}]}