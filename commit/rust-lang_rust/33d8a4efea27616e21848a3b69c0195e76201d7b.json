{"sha": "33d8a4efea27616e21848a3b69c0195e76201d7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZDhhNGVmZWEyNzYxNmUyMTg0OGEzYjY5YzAxOTVlNzYyMDFkN2I=", "commit": {"author": {"name": "Carol Nichols", "email": "carol.nichols@gmail.com", "date": "2015-02-14T23:14:52Z"}, "committer": {"name": "Carol Nichols", "email": "carol.nichols@gmail.com", "date": "2015-03-06T01:37:49Z"}, "message": "Rearrange tests to be in the same order as implementation\n\nI was having trouble figuring out which functions had tests and which\ndidn't. This commit is just moving tests around and does not change\nanything.", "tree": {"sha": "7d25a8470a17da96b8bc6a99fae35cb79e4cd7b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d25a8470a17da96b8bc6a99fae35cb79e4cd7b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33d8a4efea27616e21848a3b69c0195e76201d7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33d8a4efea27616e21848a3b69c0195e76201d7b", "html_url": "https://github.com/rust-lang/rust/commit/33d8a4efea27616e21848a3b69c0195e76201d7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33d8a4efea27616e21848a3b69c0195e76201d7b/comments", "author": {"login": "carols10cents", "id": 193874, "node_id": "MDQ6VXNlcjE5Mzg3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/193874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carols10cents", "html_url": "https://github.com/carols10cents", "followers_url": "https://api.github.com/users/carols10cents/followers", "following_url": "https://api.github.com/users/carols10cents/following{/other_user}", "gists_url": "https://api.github.com/users/carols10cents/gists{/gist_id}", "starred_url": "https://api.github.com/users/carols10cents/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carols10cents/subscriptions", "organizations_url": "https://api.github.com/users/carols10cents/orgs", "repos_url": "https://api.github.com/users/carols10cents/repos", "events_url": "https://api.github.com/users/carols10cents/events{/privacy}", "received_events_url": "https://api.github.com/users/carols10cents/received_events", "type": "User", "site_admin": false}, "committer": {"login": "carols10cents", "id": 193874, "node_id": "MDQ6VXNlcjE5Mzg3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/193874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carols10cents", "html_url": "https://github.com/carols10cents", "followers_url": "https://api.github.com/users/carols10cents/followers", "following_url": "https://api.github.com/users/carols10cents/following{/other_user}", "gists_url": "https://api.github.com/users/carols10cents/gists{/gist_id}", "starred_url": "https://api.github.com/users/carols10cents/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carols10cents/subscriptions", "organizations_url": "https://api.github.com/users/carols10cents/orgs", "repos_url": "https://api.github.com/users/carols10cents/repos", "events_url": "https://api.github.com/users/carols10cents/events{/privacy}", "received_events_url": "https://api.github.com/users/carols10cents/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0746ff19b3bc204215f04bbb5756159f9bc5c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0746ff19b3bc204215f04bbb5756159f9bc5c92", "html_url": "https://github.com/rust-lang/rust/commit/b0746ff19b3bc204215f04bbb5756159f9bc5c92"}], "stats": {"total": 690, "additions": 345, "deletions": 345}, "files": [{"sha": "76e182f4b7254adeb0e996a804c68ad4acb86b52", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 173, "deletions": 173, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/33d8a4efea27616e21848a3b69c0195e76201d7b/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33d8a4efea27616e21848a3b69c0195e76201d7b/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=33d8a4efea27616e21848a3b69c0195e76201d7b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -468,6 +468,11 @@ mod tests {\n     use num::*;\n     use num::FpCategory as Fp;\n \n+    #[test]\n+    fn test_num_f32() {\n+        test_num(10f32, 2f32);\n+    }\n+\n     #[test]\n     fn test_min_nan() {\n         assert_eq!(NAN.min(2.0), 2.0);\n@@ -481,8 +486,49 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_num_f32() {\n-        test_num(10f32, 2f32);\n+    fn test_is_normal() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let zero: f32 = Float::zero();\n+        let neg_zero: f32 = Float::neg_zero();\n+        assert!(!nan.is_normal());\n+        assert!(!inf.is_normal());\n+        assert!(!neg_inf.is_normal());\n+        assert!(!zero.is_normal());\n+        assert!(!neg_zero.is_normal());\n+        assert!(1f32.is_normal());\n+        assert!(1e-37f32.is_normal());\n+        assert!(!1e-38f32.is_normal());\n+    }\n+\n+    #[test]\n+    fn test_classify() {\n+        let nan: f32 = Float::nan();\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let zero: f32 = Float::zero();\n+        let neg_zero: f32 = Float::neg_zero();\n+        assert_eq!(nan.classify(), Fp::Nan);\n+        assert_eq!(inf.classify(), Fp::Infinite);\n+        assert_eq!(neg_inf.classify(), Fp::Infinite);\n+        assert_eq!(zero.classify(), Fp::Zero);\n+        assert_eq!(neg_zero.classify(), Fp::Zero);\n+        assert_eq!(1f32.classify(), Fp::Normal);\n+        assert_eq!(1e-37f32.classify(), Fp::Normal);\n+        assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n+    }\n+\n+    #[test]\n+    fn test_integer_decode() {\n+        assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n+        assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n+        assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n+        assert_eq!(0f32.integer_decode(), (0, -150, 1));\n+        assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n+        assert_eq!(INFINITY.integer_decode(), (8388608, 105, 1));\n+        assert_eq!(NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n+        assert_eq!(NAN.integer_decode(), (12582912, 105, 1));\n     }\n \n     #[test]\n@@ -555,6 +601,65 @@ mod tests {\n         assert_approx_eq!((-1.7f32).fract(), -0.7f32);\n     }\n \n+    #[test]\n+    pub fn test_abs() {\n+        assert_eq!(INFINITY.abs(), INFINITY);\n+        assert_eq!(1f32.abs(), 1f32);\n+        assert_eq!(0f32.abs(), 0f32);\n+        assert_eq!((-0f32).abs(), 0f32);\n+        assert_eq!((-1f32).abs(), 1f32);\n+        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n+        assert_eq!((1f32/NEG_INFINITY).abs(), 0f32);\n+        assert!(NAN.abs().is_nan());\n+    }\n+\n+    #[test]\n+    fn test_signum() {\n+        assert_eq!(INFINITY.signum(), 1f32);\n+        assert_eq!(1f32.signum(), 1f32);\n+        assert_eq!(0f32.signum(), 1f32);\n+        assert_eq!((-0f32).signum(), -1f32);\n+        assert_eq!((-1f32).signum(), -1f32);\n+        assert_eq!(NEG_INFINITY.signum(), -1f32);\n+        assert_eq!((1f32/NEG_INFINITY).signum(), -1f32);\n+        assert!(NAN.signum().is_nan());\n+    }\n+\n+    #[test]\n+    fn test_is_positive() {\n+        assert!(INFINITY.is_positive());\n+        assert!(1f32.is_positive());\n+        assert!(0f32.is_positive());\n+        assert!(!(-0f32).is_positive());\n+        assert!(!(-1f32).is_positive());\n+        assert!(!NEG_INFINITY.is_positive());\n+        assert!(!(1f32/NEG_INFINITY).is_positive());\n+        assert!(!NAN.is_positive());\n+    }\n+\n+    #[test]\n+    fn test_is_negative() {\n+        assert!(!INFINITY.is_negative());\n+        assert!(!1f32.is_negative());\n+        assert!(!0f32.is_negative());\n+        assert!((-0f32).is_negative());\n+        assert!((-1f32).is_negative());\n+        assert!(NEG_INFINITY.is_negative());\n+        assert!((1f32/NEG_INFINITY).is_negative());\n+        assert!(!NAN.is_negative());\n+    }\n+\n+    #[test]\n+    fn test_sqrt_domain() {\n+        assert!(NAN.sqrt().is_nan());\n+        assert!(NEG_INFINITY.sqrt().is_nan());\n+        assert!((-1.0f32).sqrt().is_nan());\n+        assert_eq!((-0.0f32).sqrt(), -0.0);\n+        assert_eq!(0.0f32.sqrt(), 0.0);\n+        assert_eq!(1.0f32.sqrt(), 1.0);\n+        assert_eq!(INFINITY.sqrt(), INFINITY);\n+    }\n+\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f32.exp());\n@@ -582,6 +687,71 @@ mod tests {\n         assert!(nan.exp2().is_nan());\n     }\n \n+    #[test]\n+    fn test_ldexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        assert_eq!(Float::ldexp(1f32, -123), f1);\n+        assert_eq!(Float::ldexp(1f32, -111), f2);\n+\n+        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n+        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n+\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::nan();\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_nan());\n+    }\n+\n+    #[test]\n+    fn test_frexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        let (x1, exp1) = f1.frexp();\n+        let (x2, exp2) = f2.frexp();\n+        assert_eq!((x1, exp1), (0.5f32, -122));\n+        assert_eq!((x2, exp2), (0.5f32, -110));\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n+\n+        assert_eq!(0f32.frexp(), (0f32, 0));\n+        assert_eq!((-0f32).frexp(), (-0f32, 0));\n+    }\n+\n+    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n+    fn test_frexp_nowin() {\n+        let inf: f32 = Float::infinity();\n+        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = Float::nan();\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n+        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n+    }\n+\n+    #[test]\n+    fn test_abs_sub() {\n+        assert_eq!((-1f32).abs_sub(1f32), 0f32);\n+        assert_eq!(1f32.abs_sub(1f32), 0f32);\n+        assert_eq!(1f32.abs_sub(0f32), 1f32);\n+        assert_eq!(1f32.abs_sub(-1f32), 2f32);\n+        assert_eq!(NEG_INFINITY.abs_sub(0f32), 0f32);\n+        assert_eq!(INFINITY.abs_sub(1f32), INFINITY);\n+        assert_eq!(0f32.abs_sub(NEG_INFINITY), INFINITY);\n+        assert_eq!(0f32.abs_sub(INFINITY), 0f32);\n+    }\n+\n+    #[test]\n+    fn test_abs_sub_nowin() {\n+        assert!(NAN.abs_sub(-1f32).is_nan());\n+        assert!(1f32.abs_sub(NAN).is_nan());\n+    }\n+\n     #[test]\n     fn test_asinh() {\n         assert_eq!(0.0f32.asinh(), 0.0f32);\n@@ -674,174 +844,4 @@ mod tests {\n         assert_approx_eq!(ln_2, 2f32.ln());\n         assert_approx_eq!(ln_10, 10f32.ln());\n     }\n-\n-    #[test]\n-    pub fn test_abs() {\n-        assert_eq!(INFINITY.abs(), INFINITY);\n-        assert_eq!(1f32.abs(), 1f32);\n-        assert_eq!(0f32.abs(), 0f32);\n-        assert_eq!((-0f32).abs(), 0f32);\n-        assert_eq!((-1f32).abs(), 1f32);\n-        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f32/NEG_INFINITY).abs(), 0f32);\n-        assert!(NAN.abs().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        assert_eq!((-1f32).abs_sub(1f32), 0f32);\n-        assert_eq!(1f32.abs_sub(1f32), 0f32);\n-        assert_eq!(1f32.abs_sub(0f32), 1f32);\n-        assert_eq!(1f32.abs_sub(-1f32), 2f32);\n-        assert_eq!(NEG_INFINITY.abs_sub(0f32), 0f32);\n-        assert_eq!(INFINITY.abs_sub(1f32), INFINITY);\n-        assert_eq!(0f32.abs_sub(NEG_INFINITY), INFINITY);\n-        assert_eq!(0f32.abs_sub(INFINITY), 0f32);\n-    }\n-\n-    #[test]\n-    fn test_abs_sub_nowin() {\n-        assert!(NAN.abs_sub(-1f32).is_nan());\n-        assert!(1f32.abs_sub(NAN).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert_eq!(INFINITY.signum(), 1f32);\n-        assert_eq!(1f32.signum(), 1f32);\n-        assert_eq!(0f32.signum(), 1f32);\n-        assert_eq!((-0f32).signum(), -1f32);\n-        assert_eq!((-1f32).signum(), -1f32);\n-        assert_eq!(NEG_INFINITY.signum(), -1f32);\n-        assert_eq!((1f32/NEG_INFINITY).signum(), -1f32);\n-        assert!(NAN.signum().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_is_positive() {\n-        assert!(INFINITY.is_positive());\n-        assert!(1f32.is_positive());\n-        assert!(0f32.is_positive());\n-        assert!(!(-0f32).is_positive());\n-        assert!(!(-1f32).is_positive());\n-        assert!(!NEG_INFINITY.is_positive());\n-        assert!(!(1f32/NEG_INFINITY).is_positive());\n-        assert!(!NAN.is_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_negative() {\n-        assert!(!INFINITY.is_negative());\n-        assert!(!1f32.is_negative());\n-        assert!(!0f32.is_negative());\n-        assert!((-0f32).is_negative());\n-        assert!((-1f32).is_negative());\n-        assert!(NEG_INFINITY.is_negative());\n-        assert!((1f32/NEG_INFINITY).is_negative());\n-        assert!(!NAN.is_negative());\n-    }\n-\n-    #[test]\n-    fn test_is_normal() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Float::zero();\n-        let neg_zero: f32 = Float::neg_zero();\n-        assert!(!nan.is_normal());\n-        assert!(!inf.is_normal());\n-        assert!(!neg_inf.is_normal());\n-        assert!(!zero.is_normal());\n-        assert!(!neg_zero.is_normal());\n-        assert!(1f32.is_normal());\n-        assert!(1e-37f32.is_normal());\n-        assert!(!1e-38f32.is_normal());\n-    }\n-\n-    #[test]\n-    fn test_classify() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Float::zero();\n-        let neg_zero: f32 = Float::neg_zero();\n-        assert_eq!(nan.classify(), Fp::Nan);\n-        assert_eq!(inf.classify(), Fp::Infinite);\n-        assert_eq!(neg_inf.classify(), Fp::Infinite);\n-        assert_eq!(zero.classify(), Fp::Zero);\n-        assert_eq!(neg_zero.classify(), Fp::Zero);\n-        assert_eq!(1f32.classify(), Fp::Normal);\n-        assert_eq!(1e-37f32.classify(), Fp::Normal);\n-        assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n-    }\n-\n-    #[test]\n-    fn test_ldexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        assert_eq!(Float::ldexp(1f32, -123), f1);\n-        assert_eq!(Float::ldexp(1f32, -111), f2);\n-\n-        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n-        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n-\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_frexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        assert_eq!((x1, exp1), (0.5f32, -122));\n-        assert_eq!((x2, exp2), (0.5f32, -110));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-\n-        assert_eq!(0f32.frexp(), (0f32, 0));\n-        assert_eq!((-0f32).frexp(), (-0f32, 0));\n-    }\n-\n-    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n-    fn test_frexp_nowin() {\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n-    #[test]\n-    fn test_integer_decode() {\n-        assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n-        assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n-        assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n-        assert_eq!(0f32.integer_decode(), (0, -150, 1));\n-        assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n-        assert_eq!(INFINITY.integer_decode(), (8388608, 105, 1));\n-        assert_eq!(NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n-        assert_eq!(NAN.integer_decode(), (12582912, 105, 1));\n-    }\n-\n-    #[test]\n-    fn test_sqrt_domain() {\n-        assert!(NAN.sqrt().is_nan());\n-        assert!(NEG_INFINITY.sqrt().is_nan());\n-        assert!((-1.0f32).sqrt().is_nan());\n-        assert_eq!((-0.0f32).sqrt(), -0.0);\n-        assert_eq!(0.0f32.sqrt(), 0.0);\n-        assert_eq!(1.0f32.sqrt(), 1.0);\n-        assert_eq!(INFINITY.sqrt(), INFINITY);\n-    }\n }"}, {"sha": "12c58c2353b4ba87a4eb46d390fa6f1935e2a3d8", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 172, "deletions": 172, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/33d8a4efea27616e21848a3b69c0195e76201d7b/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33d8a4efea27616e21848a3b69c0195e76201d7b/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=33d8a4efea27616e21848a3b69c0195e76201d7b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -477,6 +477,11 @@ mod tests {\n     use num::*;\n     use num::FpCategory as Fp;\n \n+    #[test]\n+    fn test_num_f64() {\n+        test_num(10f64, 2f64);\n+    }\n+\n     #[test]\n     fn test_min_nan() {\n         assert_eq!(NAN.min(2.0), 2.0);\n@@ -490,8 +495,48 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_num_f64() {\n-        test_num(10f64, 2f64);\n+    fn test_is_normal() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let zero: f64 = Float::zero();\n+        let neg_zero: f64 = Float::neg_zero();\n+        assert!(!nan.is_normal());\n+        assert!(!inf.is_normal());\n+        assert!(!neg_inf.is_normal());\n+        assert!(!zero.is_normal());\n+        assert!(!neg_zero.is_normal());\n+        assert!(1f64.is_normal());\n+        assert!(1e-307f64.is_normal());\n+        assert!(!1e-308f64.is_normal());\n+    }\n+\n+    #[test]\n+    fn test_classify() {\n+        let nan: f64 = Float::nan();\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let zero: f64 = Float::zero();\n+        let neg_zero: f64 = Float::neg_zero();\n+        assert_eq!(nan.classify(), Fp::Nan);\n+        assert_eq!(inf.classify(), Fp::Infinite);\n+        assert_eq!(neg_inf.classify(), Fp::Infinite);\n+        assert_eq!(zero.classify(), Fp::Zero);\n+        assert_eq!(neg_zero.classify(), Fp::Zero);\n+        assert_eq!(1e-307f64.classify(), Fp::Normal);\n+        assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n+    }\n+\n+    #[test]\n+    fn test_integer_decode() {\n+        assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n+        assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n+        assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n+        assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n+        assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n+        assert_eq!(INFINITY.integer_decode(), (4503599627370496, 972, 1));\n+        assert_eq!(NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n+        assert_eq!(NAN.integer_decode(), (6755399441055744, 972, 1));\n     }\n \n     #[test]\n@@ -564,6 +609,65 @@ mod tests {\n         assert_approx_eq!((-1.7f64).fract(), -0.7f64);\n     }\n \n+    #[test]\n+    pub fn test_abs() {\n+        assert_eq!(INFINITY.abs(), INFINITY);\n+        assert_eq!(1f64.abs(), 1f64);\n+        assert_eq!(0f64.abs(), 0f64);\n+        assert_eq!((-0f64).abs(), 0f64);\n+        assert_eq!((-1f64).abs(), 1f64);\n+        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n+        assert_eq!((1f64/NEG_INFINITY).abs(), 0f64);\n+        assert!(NAN.abs().is_nan());\n+    }\n+\n+    #[test]\n+    fn test_signum() {\n+        assert_eq!(INFINITY.signum(), 1f64);\n+        assert_eq!(1f64.signum(), 1f64);\n+        assert_eq!(0f64.signum(), 1f64);\n+        assert_eq!((-0f64).signum(), -1f64);\n+        assert_eq!((-1f64).signum(), -1f64);\n+        assert_eq!(NEG_INFINITY.signum(), -1f64);\n+        assert_eq!((1f64/NEG_INFINITY).signum(), -1f64);\n+        assert!(NAN.signum().is_nan());\n+    }\n+\n+    #[test]\n+    fn test_is_positive() {\n+        assert!(INFINITY.is_positive());\n+        assert!(1f64.is_positive());\n+        assert!(0f64.is_positive());\n+        assert!(!(-0f64).is_positive());\n+        assert!(!(-1f64).is_positive());\n+        assert!(!NEG_INFINITY.is_positive());\n+        assert!(!(1f64/NEG_INFINITY).is_positive());\n+        assert!(!NAN.is_positive());\n+    }\n+\n+    #[test]\n+    fn test_is_negative() {\n+        assert!(!INFINITY.is_negative());\n+        assert!(!1f64.is_negative());\n+        assert!(!0f64.is_negative());\n+        assert!((-0f64).is_negative());\n+        assert!((-1f64).is_negative());\n+        assert!(NEG_INFINITY.is_negative());\n+        assert!((1f64/NEG_INFINITY).is_negative());\n+        assert!(!NAN.is_negative());\n+    }\n+\n+    #[test]\n+    fn test_sqrt_domain() {\n+        assert!(NAN.sqrt().is_nan());\n+        assert!(NEG_INFINITY.sqrt().is_nan());\n+        assert!((-1.0f64).sqrt().is_nan());\n+        assert_eq!((-0.0f64).sqrt(), -0.0);\n+        assert_eq!(0.0f64.sqrt(), 0.0);\n+        assert_eq!(1.0f64.sqrt(), 1.0);\n+        assert_eq!(INFINITY.sqrt(), INFINITY);\n+    }\n+\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f64.exp());\n@@ -591,6 +695,71 @@ mod tests {\n         assert!(nan.exp2().is_nan());\n     }\n \n+    #[test]\n+    fn test_ldexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        assert_eq!(Float::ldexp(1f64, -123), f1);\n+        assert_eq!(Float::ldexp(1f64, -111), f2);\n+\n+        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n+        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n+\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::nan();\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_nan());\n+    }\n+\n+    #[test]\n+    fn test_frexp() {\n+        // We have to use from_str until base-2 exponents\n+        // are supported in floating-point literals\n+        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n+        let (x1, exp1) = f1.frexp();\n+        let (x2, exp2) = f2.frexp();\n+        assert_eq!((x1, exp1), (0.5f64, -122));\n+        assert_eq!((x2, exp2), (0.5f64, -110));\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n+\n+        assert_eq!(0f64.frexp(), (0f64, 0));\n+        assert_eq!((-0f64).frexp(), (-0f64, 0));\n+    }\n+\n+    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n+    fn test_frexp_nowin() {\n+        let inf: f64 = Float::infinity();\n+        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = Float::nan();\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n+        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n+    }\n+\n+    #[test]\n+    fn test_abs_sub() {\n+        assert_eq!((-1f64).abs_sub(1f64), 0f64);\n+        assert_eq!(1f64.abs_sub(1f64), 0f64);\n+        assert_eq!(1f64.abs_sub(0f64), 1f64);\n+        assert_eq!(1f64.abs_sub(-1f64), 2f64);\n+        assert_eq!(NEG_INFINITY.abs_sub(0f64), 0f64);\n+        assert_eq!(INFINITY.abs_sub(1f64), INFINITY);\n+        assert_eq!(0f64.abs_sub(NEG_INFINITY), INFINITY);\n+        assert_eq!(0f64.abs_sub(INFINITY), 0f64);\n+    }\n+\n+    #[test]\n+    fn test_abs_sub_nowin() {\n+        assert!(NAN.abs_sub(-1f64).is_nan());\n+        assert!(1f64.abs_sub(NAN).is_nan());\n+    }\n+\n     #[test]\n     fn test_asinh() {\n         assert_eq!(0.0f64.asinh(), 0.0f64);\n@@ -677,173 +846,4 @@ mod tests {\n         assert_approx_eq!(ln_2, 2f64.ln());\n         assert_approx_eq!(ln_10, 10f64.ln());\n     }\n-\n-    #[test]\n-    pub fn test_abs() {\n-        assert_eq!(INFINITY.abs(), INFINITY);\n-        assert_eq!(1f64.abs(), 1f64);\n-        assert_eq!(0f64.abs(), 0f64);\n-        assert_eq!((-0f64).abs(), 0f64);\n-        assert_eq!((-1f64).abs(), 1f64);\n-        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n-        assert_eq!((1f64/NEG_INFINITY).abs(), 0f64);\n-        assert!(NAN.abs().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        assert_eq!((-1f64).abs_sub(1f64), 0f64);\n-        assert_eq!(1f64.abs_sub(1f64), 0f64);\n-        assert_eq!(1f64.abs_sub(0f64), 1f64);\n-        assert_eq!(1f64.abs_sub(-1f64), 2f64);\n-        assert_eq!(NEG_INFINITY.abs_sub(0f64), 0f64);\n-        assert_eq!(INFINITY.abs_sub(1f64), INFINITY);\n-        assert_eq!(0f64.abs_sub(NEG_INFINITY), INFINITY);\n-        assert_eq!(0f64.abs_sub(INFINITY), 0f64);\n-    }\n-\n-    #[test]\n-    fn test_abs_sub_nowin() {\n-        assert!(NAN.abs_sub(-1f64).is_nan());\n-        assert!(1f64.abs_sub(NAN).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert_eq!(INFINITY.signum(), 1f64);\n-        assert_eq!(1f64.signum(), 1f64);\n-        assert_eq!(0f64.signum(), 1f64);\n-        assert_eq!((-0f64).signum(), -1f64);\n-        assert_eq!((-1f64).signum(), -1f64);\n-        assert_eq!(NEG_INFINITY.signum(), -1f64);\n-        assert_eq!((1f64/NEG_INFINITY).signum(), -1f64);\n-        assert!(NAN.signum().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_is_positive() {\n-        assert!(INFINITY.is_positive());\n-        assert!(1f64.is_positive());\n-        assert!(0f64.is_positive());\n-        assert!(!(-0f64).is_positive());\n-        assert!(!(-1f64).is_positive());\n-        assert!(!NEG_INFINITY.is_positive());\n-        assert!(!(1f64/NEG_INFINITY).is_positive());\n-        assert!(!NAN.is_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_negative() {\n-        assert!(!INFINITY.is_negative());\n-        assert!(!1f64.is_negative());\n-        assert!(!0f64.is_negative());\n-        assert!((-0f64).is_negative());\n-        assert!((-1f64).is_negative());\n-        assert!(NEG_INFINITY.is_negative());\n-        assert!((1f64/NEG_INFINITY).is_negative());\n-        assert!(!NAN.is_negative());\n-    }\n-\n-    #[test]\n-    fn test_is_normal() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Float::zero();\n-        let neg_zero: f64 = Float::neg_zero();\n-        assert!(!nan.is_normal());\n-        assert!(!inf.is_normal());\n-        assert!(!neg_inf.is_normal());\n-        assert!(!zero.is_normal());\n-        assert!(!neg_zero.is_normal());\n-        assert!(1f64.is_normal());\n-        assert!(1e-307f64.is_normal());\n-        assert!(!1e-308f64.is_normal());\n-    }\n-\n-    #[test]\n-    fn test_classify() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Float::zero();\n-        let neg_zero: f64 = Float::neg_zero();\n-        assert_eq!(nan.classify(), Fp::Nan);\n-        assert_eq!(inf.classify(), Fp::Infinite);\n-        assert_eq!(neg_inf.classify(), Fp::Infinite);\n-        assert_eq!(zero.classify(), Fp::Zero);\n-        assert_eq!(neg_zero.classify(), Fp::Zero);\n-        assert_eq!(1e-307f64.classify(), Fp::Normal);\n-        assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n-    }\n-\n-    #[test]\n-    fn test_ldexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        assert_eq!(Float::ldexp(1f64, -123), f1);\n-        assert_eq!(Float::ldexp(1f64, -111), f2);\n-\n-        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n-        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n-\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n-    }\n-\n-    #[test]\n-    fn test_frexp() {\n-        // We have to use from_str until base-2 exponents\n-        // are supported in floating-point literals\n-        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let (x1, exp1) = f1.frexp();\n-        let (x2, exp2) = f2.frexp();\n-        assert_eq!((x1, exp1), (0.5f64, -122));\n-        assert_eq!((x2, exp2), (0.5f64, -110));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-\n-        assert_eq!(0f64.frexp(), (0f64, 0));\n-        assert_eq!((-0f64).frexp(), (-0f64, 0));\n-    }\n-\n-    #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n-    fn test_frexp_nowin() {\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n-        assert!(match nan.frexp() { (x, _) => x.is_nan() })\n-    }\n-\n-    #[test]\n-    fn test_integer_decode() {\n-        assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n-        assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n-        assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n-        assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n-        assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n-        assert_eq!(INFINITY.integer_decode(), (4503599627370496, 972, 1));\n-        assert_eq!(NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n-        assert_eq!(NAN.integer_decode(), (6755399441055744, 972, 1));\n-    }\n-\n-    #[test]\n-    fn test_sqrt_domain() {\n-        assert!(NAN.sqrt().is_nan());\n-        assert!(NEG_INFINITY.sqrt().is_nan());\n-        assert!((-1.0f64).sqrt().is_nan());\n-        assert_eq!((-0.0f64).sqrt(), -0.0);\n-        assert_eq!(0.0f64.sqrt(), 0.0);\n-        assert_eq!(1.0f64.sqrt(), 1.0);\n-        assert_eq!(INFINITY.sqrt(), INFINITY);\n-    }\n }"}]}